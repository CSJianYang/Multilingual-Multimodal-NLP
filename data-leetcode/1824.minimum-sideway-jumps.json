[
    {
        "title": "Maximum Number of Accepted Invitations",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565900,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 1567034,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 2060758,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            },
            {
                "id": 1810428,
                "content": [
                    {
                        "username": "guytryingtocode",
                        "content": "Looks like this question requires knowledge of specific algorithms and none of the existing solutions have clear explanations for a simpler way to solve."
                    },
                    {
                        "username": "f1re",
                        "content": "Looking at medium, couldn\\'t have guessed it\\'s a flow problem."
                    },
                    {
                        "username": "rogerwln",
                        "content": "This is not a good interview questions cuz it requires unique knowledge of bipartite graph. Its impossible to solve if you dont know that the algo and there is no alternative solution"
                    },
                    {
                        "username": "hodcse",
                        "content": "I think related topics is not matched with the hint and also Backtracking gives me TLE"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Customers With Positive Revenue this Year",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1942842,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            },
            {
                "id": 1712159,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            },
            {
                "id": 1990853,
                "content": [
                    {
                        "username": "danek1313",
                        "content": "I find it very hard to believe that Google asked this to a candidate during an interview."
                    },
                    {
                        "username": "dolong2110",
                        "content": "```\\n# Write your MySQL query statement below\\nselect distinct customer_id\\nfrom Customers\\nwhere year = 2021\\ngroup by customer_id, year\\nhaving sum(revenue) > 0;\\n```"
                    },
                    {
                        "username": "medhacodes28",
                        "content": "Is this meant for interns or non SE jobs? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Sign of the Product of an Array",
        "question_content": "<p>There is a function <code>signFunc(x)</code> that returns:</p>\n\n<ul>\n\t<li><code>1</code> if <code>x</code> is positive.</li>\n\t<li><code>-1</code> if <code>x</code> is negative.</li>\n\t<li><code>0</code> if <code>x</code> is equal to <code>0</code>.</li>\n</ul>\n\n<p>You are given an integer array <code>nums</code>. Let <code>product</code> be the product of all values in the array <code>nums</code>.</p>\n\n<p>Return <code>signFunc(product)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3,-4,3,2,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The product of all values in the array is 144, and signFunc(144) = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,0,2,-3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The product of all values in the array is 0, and signFunc(0) = 0\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,1,-1,1,-1]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> The product of all values in the array is -1, and signFunc(-1) = -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>-100 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1152555,
                "title": "java-solution-0-ms-seriously-why-we-need-2",
                "content": "We should just need to flip the count whenever encounter a negative number \\n```\\n   public int arraySign(int[] nums) {\\n        int sign = 1; \\n        for (int n : nums) {\\n            if (n == 0) {\\n                return 0; \\n            } \\n\\t\\t\\tif (n < 0) {\\n                sign = -sign; \\n            }\\n        }\\n        return sign; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int arraySign(int[] nums) {\\n        int sign = 1; \\n        for (int n : nums) {\\n            if (n == 0) {\\n                return 0; \\n            } \\n\\t\\t\\tif (n < 0) {\\n                sign = -sign; \\n            }\\n        }\\n        return sign; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476080,
                "title": "c-easy-approach-explained",
                "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Approach\\n- ##### The problem asks us to determine the sign of the product of all the numbers in the given array. To solve this problem, we need to consider the following cases:\\n    1. ##### If the product of all the numbers is positive, the sign is 1.\\n    1. ##### If the product of all the numbers is negative, the sign is -1.\\n    1. ##### If the product of all the numbers is zero, the sign is 0.\\n- ##### To compute the product of all the numbers in the array, we can iterate over the array and count the total negative numbers. We can initialize the cnt as 0 and then update it at each step of the iteration.\\n- ##### At any index, if number is 0, simply return 0.\\n- ##### Once we have computed the product, we can determine the sign of the product using an if-else statement. If the cnt is odd, the sign is -1. If the cnt is even, the sign is 1.\\n\\n- ##### Therefore, we can write a function that takes an array as input, computes the count of negative numbers in the array, and returns the sign of the product.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& a) {\\n        int cnt = 0;\\n        for(int i = 0; i < a.size(); i++) \\n        {\\n            if(a[i] == 0) return 0;\\n            if(a[i] < 0) cnt++;\\n        }\\n        return cnt%2 ? -1 : 1;\\n    }\\n};\\n```\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/e5cc6438-63d7-47fb-84d1-e4e36cf43c6e_1683003574.1370602.png)\\n",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& a) {\\n        int cnt = 0;\\n        for(int i = 0; i < a.size(); i++) \\n        {\\n            if(a[i] == 0) return 0;\\n            if(a[i] < 0) cnt++;\\n        }\\n        return cnt%2 ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152412,
                "title": "python3-line-sweep",
                "content": "\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        ans = 1\\n        for x in nums: \\n            if x == 0: return 0 \\n            if x < 0: ans *= -1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        ans = 1\\n        for x in nums: \\n            if x == 0: return 0 \\n            if x < 0: ans *= -1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168505,
                "title": "c-simple-easy-code",
                "content": "***Do upvote if you found it helpful to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i , count_neg = 0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count_neg++;\\n        }\\n        if(count_neg %2 == 0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i , count_neg = 0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count_neg++;\\n        }\\n        if(count_neg %2 == 0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152450,
                "title": "java-2-straightforward-solutions",
                "content": "We only care about 0 and the occurence of negative numbers in the array. No need to calculate the final product.\\n```\\n    public int arraySign(int[] nums) {\\n        int counter = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                return 0;\\n            }\\n            if (nums[i] < 0) {\\n                counter++;\\n            }\\n        }\\n        return counter % 2 == 0 ? 1 : -1;\\n    }\\n```\\n\\n```\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int i : nums) {\\n            if (i == 0) return 0;\\n            if (i < 0) sign *= -1;\\n        }\\n        return sign;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int arraySign(int[] nums) {\\n        int counter = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0) {\\n                return 0;\\n            }\\n            if (nums[i] < 0) {\\n                counter++;\\n            }\\n        }\\n        return counter % 2 == 0 ? 1 : -1;\\n    }\\n```\n```\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int i : nums) {\\n            if (i == 0) return 0;\\n            if (i < 0) sign *= -1;\\n        }\\n        return sign;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475407,
                "title": "java-simple-math-beats-100-5-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int arraySign(int[] nums) {\\n    var sign = 1;\\n\\n    for (var n : nums) {\\n      if (n == 0) return 0;\\n      sign *= n > 0 ? 1 : -1;\\n    }\\n    return sign;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n  public int arraySign(int[] nums) {\\n    var sign = 1;\\n\\n    for (var n : nums) {\\n      if (n == 0) return 0;\\n      sign *= n > 0 ? 1 : -1;\\n    }\\n    return sign;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837393,
                "title": "why-to-multiply-neat-and-simple-solution-o-n-72-ms",
                "content": "```\\nvar arraySign = function(nums) {\\n    var ans = 1\\n    for(i of nums){\\n        if(i == 0){\\n            return 0\\n        }\\n        if(i < 0){\\n            ans = -ans\\n        }\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    var ans = 1\\n    for(i of nums){\\n        if(i == 0){\\n            return 0\\n        }\\n        if(i < 0){\\n            ans = -ans\\n        }\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162480,
                "title": "easy-to-understand-and-implement-c-solution",
                "content": "**Intuition: why idea of finding product does not work:**\\nConsider this code:\\n```\\nint arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(auto x: nums)\\n            p *= x;\\n        if(p > 0)\\n            return 1;\\n        else if(p < 0)\\n            return -1;\\n        return 0;\\n    }\\n```\\nThis code passes successfully for small test cases where the input is small. Larger size of array can lead to Runtime Error:\\n```\\nRuntime Error Message:\\nLine 6: Char 15: runtime error: signed integer overflow: 688764384 * -77 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:15:15\\nLast executed input:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n```\\n\\nSo a better solution would be to check if any of the element in the array is a zero. If yes, then return 0, If no, then count how many negative numbers are there. If their count is even, then return 1, else return 0.\\n\\n**Code for the same:**\\n```\\nint arraySign(vector<int>& nums) {\\n        int countNeg = 0;\\n        for(auto x: nums){\\n            if(x < 0)\\n                countNeg++;\\n            else if(x == 0)\\n                return 0;\\n        }\\n        if(countNeg%2 ==0)\\n            return 1;\\n        return -1;\\n    }\\n```\\n**Time complexity: O(N)\\nSpace Complexity: O(1)**\\n\\nDo upvote this solution if it helped you. \\nPeace :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(auto x: nums)\\n            p *= x;\\n        if(p > 0)\\n            return 1;\\n        else if(p < 0)\\n            return -1;\\n        return 0;\\n    }\\n```\n```\\nRuntime Error Message:\\nLine 6: Char 15: runtime error: signed integer overflow: 688764384 * -77 cannot be represented in type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:15:15\\nLast executed input:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n```\n```\\nint arraySign(vector<int>& nums) {\\n        int countNeg = 0;\\n        for(auto x: nums){\\n            if(x < 0)\\n                countNeg++;\\n            else if(x == 0)\\n                return 0;\\n        }\\n        if(countNeg%2 ==0)\\n            return 1;\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891235,
                "title": "simple-javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n\\t// use filter to find total negative numbers in the array\\n    let negativeCount = nums.filter(n => n<0).length;\\n\\t\\n\\t// check if the nums array has zero. If it does, then return 0\\n    if(nums.includes(0)) return 0;\\n\\t\\n\\t// If negativeCount variable is even answer is 1 else -1\\n    return negativeCount % 2 === 0 ? 1 : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n\\t// use filter to find total negative numbers in the array\\n    let negativeCount = nums.filter(n => n<0).length;\\n\\t\\n\\t// check if the nums array has zero. If it does, then return 0\\n    if(nums.includes(0)) return 0;\\n\\t\\n\\t// If negativeCount variable is even answer is 1 else -1\\n    return negativeCount % 2 === 0 ? 1 : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155733,
                "title": "python-multiple-solutions-tracking-sign-lazy-evaluation-branchless-and-one-liners",
                "content": "Using a loop, terminate early if a zero is encountered. Otherwise, invert the sign each time a negative value is encountered. This is the optimal solution in terms of complexity with O(N) ***in the worst case***.\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n        for num in nums:\\n            if num == 0:\\n\\t\\t\\t\\treturn  0\\n            elif num < 0:\\n\\t\\t\\t\\tsign *= -1\\n        return sign\\n```\\nHowever, since we are using python, it is sometimes just as fast or faster to compute a list product if done correctly, even though computing the list product has complexity O(N) even if `nums` contains zeros. The best way to do this is to trade lazy evaluation in pure python for the blazing speed of functions pre-compiled in `Standard C`.\\n\\nWe can use `math.prod` to do this\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\tproduct = prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0\\n```\\n\\nThe walrus assignment operator (`:=`) in `Python 3.8+` allows us to do this in one-line\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := prod(nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nAnother built-in way to compute list products is to use `functools.reduce` with the `mul` operator\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(mul, nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nUse can also define your own multiplication operator to use with `reduce` using lambdas\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(lambda x, y: x * y, nums)) > 0 else -1 if product < 0 else 0\\n```\\n\\nAnd finally, we can use a `generator comprehension` inside whichever list product method you like.\\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return prod(1 if num > 0 else -1 if num < 0 else 0 for num in nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n        for num in nums:\\n            if num == 0:\\n\\t\\t\\t\\treturn  0\\n            elif num < 0:\\n\\t\\t\\t\\tsign *= -1\\n        return sign\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\tproduct = prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := prod(nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(mul, nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return 1 if (product := reduce(lambda x, y: x * y, nums)) > 0 else -1 if product < 0 else 0\\n```\n```\\n    def arraySign(self, nums: List[int]) -> int:\\n        return prod(1 if num > 0 else -1 if num < 0 else 0 for num in nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1153639,
                "title": "java-2-methods",
                "content": "**METHOD1:**\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.length;i++){\\n            int val=signFunc(nums[i]);\\n            prod*=val;\\n        }\\n        return prod;\\n    }\\n    \\n    private int signFunc(int x){\\n        if(x<0) return -1;\\n        else if(x>0) return 1;\\n        return 0;\\n    }\\n}\\n```\\n\\n**Method2:**\\nwe can see that answer is going to be 1,-1 or 0 .\\nwe just need to flip values when we encountered a negative value.\\n```\\n  public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int num:nums){\\n            if(num<0) prod=-prod;\\n            else if(num==0) return 0; \\n        }\\n        return prod;\\n    }\\n```\\n\\nComplexity:\\n`Time:O(n) and Space:O(1)` in both methods\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int i=0;i<nums.length;i++){\\n            int val=signFunc(nums[i]);\\n            prod*=val;\\n        }\\n        return prod;\\n    }\\n    \\n    private int signFunc(int x){\\n        if(x<0) return -1;\\n        else if(x>0) return 1;\\n        return 0;\\n    }\\n}\\n```\n```\\n  public int arraySign(int[] nums) {\\n        int prod=1;\\n        for(int num:nums){\\n            if(num<0) prod=-prod;\\n            else if(num==0) return 0; \\n        }\\n        return prod;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476195,
                "title": "java-100-faster-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to only predict the sign of the product of all the element in the array.\\n1. If we found 0 return 0 because anything one multipled to 0 will be 0 only.\\n2. Initalize a counter and count the total negative element present in the array.\\n3. If negative count is mutliple of 2 then the product output will be positive number so retrun 1.\\n4. If negative count is not a mutliple of 2 then the product output will be negative number so retrun 0.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int countMinus = 0;\\n        for(int i = 0 ; i < nums.length ; i ++){\\n            if(nums[i] == 0){\\n                return 0; // return 0 if we found a 0 in the array\\n            }\\n            if(nums[i] < 0){\\n                countMinus++; //increment the count wehn we found a negative number\\n            }\\n        }\\n        //check if countMinus is multiple of 2 then return 1 else return -1\\n        return countMinus % 2 == 0 ? 1 : -1;\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int countMinus = 0;\\n        for(int i = 0 ; i < nums.length ; i ++){\\n            if(nums[i] == 0){\\n                return 0; // return 0 if we found a 0 in the array\\n            }\\n            if(nums[i] < 0){\\n                countMinus++; //increment the count wehn we found a negative number\\n            }\\n        }\\n        //check if countMinus is multiple of 2 then return 1 else return -1\\n        return countMinus % 2 == 0 ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475758,
                "title": "c-easy-2-methods-100-beat",
                "content": "# Intuition\\nWe neet to determine the number of postive number , Negative Number , or is there any Zero or not.\\n\\nMutiply as given in quetion\\n-> 1 if x is positive.\\n-> -1 if x is negative.\\n-> 0 if x is equal to 0.\\n\\nIf we have Zero in a array, then product will be zero no matter other Number , because 0*(any number) = 0\\n\\n# Approach 1\\nLet\\'s Count the Number of postive Number or Negativer number\\n\\nif there is any zero in array answer will be 0\\nif negative number is odd answer will be -1\\nif negative numbers are even answer be 1\\nEX \\n`-1*-1 = 1`\\n`-1*-1*-1 = 1`\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n\\n# code 1\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int pos=0,neg=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) pos++;\\n            else if(nums[i]<0) neg++;\\n            else return 0;\\n        }\\n        if(neg%2==0) return 1;\\n        return -1;\\n    }\\n};\\n```\\n\\n# Approach 2\\nLet\\'s go dynamically \\n\\nif we found postive number multiply answer with 1 or leave as it is\\n\\nif we found 0 directly return 0\\n\\nif we found negetive multiply with -1\\n\\nfinally return our answer\\n\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code 2\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int a = 1;\\n        for(auto i : nums){\\n            if(i==0) return 0;\\n            else if(i>0) a *=1;\\n            else a *= -1;\\n        }\\n        return a;\\n    }\\n};\\n```\\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int pos=0,neg=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]>0) pos++;\\n            else if(nums[i]<0) neg++;\\n            else return 0;\\n        }\\n        if(neg%2==0) return 1;\\n        return -1;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int a = 1;\\n        for(auto i : nums){\\n            if(i==0) return 0;\\n            else if(i>0) a *=1;\\n            else a *= -1;\\n        }\\n        return a;\\n    }\\n};\\n```\n```\\nHOPE YOU LIKE IT !! PLEASE VOTE UP...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475335,
                "title": "check-the-sign-explained",
                "content": "The first thought probably is just to simulate it by calculating the product of `nums` and check the sign like what problem statement says. However, We don\\'t need to do that since we are not interested in the value but the sign. Therefore, we can just check the sign only. If we meet a zero, we can exit early since the final sign must be 0 anyway.\\n\\n<iframe src=\"https://leetcode.com/playground/fZuQh2vv/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\nYou may notice that when the number is positive, basically it won\\'t change the sign. Hence, we can just focus on negative numbers and flip the sign when we meet one. Zero case remain unchanged.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for (auto x : nums) {\\n            if (x == 0) return 0;\\n            if (x < 0) ans = -ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Rust"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for (auto x : nums) {\\n            if (x == 0) return 0;\\n            if (x < 0) ans = -ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630408,
                "title": "simple-approach-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int res = 1;\\n        for(auto x : nums)\\n        {\\n            if(x < 0) res *= -1;\\n            else if(x == 0) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int res = 1;\\n        for(auto x : nums)\\n        {\\n            if(x < 0) res *= -1;\\n            else if(x == 0) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152626,
                "title": "python-two-solutions-functional-programming-and-tracking-negatives",
                "content": "Calculate the product using reduce and return the sign.\\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        product = reduce(lambda x,y: x*y, nums)\\n        return 0 if not product else 1 if product > 0 else -1\\n```\\n\\nIf we encounter a 0, we can return immediately. Otherwise keep track of the negatives. If the count of negatives is odd, the product is negative. If the count of negatives is even, the product is positive.\\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        result = 1\\n        for n in nums:\\n            if not n:\\n                return n\\n\\t\\t\\tif n < 0:\\n\\t\\t\\t\\tresult = -result\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        product = reduce(lambda x,y: x*y, nums)\\n        return 0 if not product else 1 if product > 0 else -1\\n```\n```python\\n\\tdef arraySign(self, nums: List[int]) -> int:\\n        result = 1\\n        for n in nums:\\n            if not n:\\n                return n\\n\\t\\t\\tif n < 0:\\n\\t\\t\\t\\tresult = -result\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3502314,
                "title": "best-solution-by-java-in-runtime-8ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n         BigInteger res = BigInteger.ONE;\\n\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            res = res.multiply(BigInteger.valueOf(nums[i]));\\n        }\\n\\n        return res.signum() ;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/7f2e544c-bd28-4f74-9a69-02531ffef3a6_1683577246.8802.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n         BigInteger res = BigInteger.ONE;\\n\\n\\n        for (int i = 0; i < nums.length ; i++) {\\n            res = res.multiply(BigInteger.valueOf(nums[i]));\\n        }\\n\\n        return res.signum() ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476201,
                "title": "beat-98-in-javascript",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou have initial state which is positive. Iterate through the array. \\n- Ignore all positive numbers\\n- When you see 0, immediately return 0\\n- If it is negative, swap the sign of the state  \\n\\n# Complexity\\n- Time complexity: O(N) in the worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    // initial state\\n    let isNeg = false;\\n    // iterate through the array\\n    for(let num of nums) {\\n        if(num === 0) return 0;\\n        // swap the sign\\n        if(num < 0) isNeg = !isNeg;\\n    }\\n    return isNeg?-1:1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    // initial state\\n    let isNeg = false;\\n    // iterate through the array\\n    for(let num of nums) {\\n        if(num === 0) return 0;\\n        // swap the sign\\n        if(num < 0) isNeg = !isNeg;\\n    }\\n    return isNeg?-1:1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2750264,
                "title": "0ms-solution-with-explanation-c",
                "content": "This question was a bit tricky. At first I tried multiplying all the numbers in array to get product and then decide whether it\\'s positive or negative or it\\'s 0. But I got integer overflow error which probably could have been mitigated by $$long$$ or $$long$$ $$long$$ data types, but we have a better idea\\uD83D\\uDCA1\\n\\nLet\\'s multiply product by 1 if the element is positve instead of the whole number & -1 in case it\\'s negative. If it\\'s zero, we return 0.\\n\\nAnd then finally we will return product after this repetitive process. This saved us from the tedioud operation of multiplying the whole number and then storing it.. and as a result we get a much shorter runtime and better space complexity!\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product=1;\\n        for (int x:nums) {\\n            if (x<0) product*=-1;\\n            else if (x>0) product*=1;\\n            else return 0;\\n        }\\n        return product;\\n    }\\n};\\n```\\n\\n## if this explanation helped you please leave a upvote on this solution\\n\\n## Visit my GitHub: https://github.com/crimsonKn1ght\\n\\n## Happy coding \\uD83D\\uDE00",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product=1;\\n        for (int x:nums) {\\n            if (x<0) product*=-1;\\n            else if (x>0) product*=1;\\n            else return 0;\\n        }\\n        return product;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194388,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\treturn 0 if 0 in nums else -1 if sum(x < 0 for x in nums) % 2 else 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n\\t\\treturn 0 if 0 in nums else -1 if sum(x < 0 for x in nums) % 2 else 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152482,
                "title": "python-one-pass",
                "content": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        r = 1\\n        for i in nums:\\n            r *= i\\n        if r>0:\\n            return 1\\n        if r<0:\\n            return -1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        r = 1\\n        for i in nums:\\n            r *= i\\n        if r>0:\\n            return 1\\n        if r<0:\\n            return -1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086766,
                "title": "2023-fastest-solution-java-easy-to-understand",
                "content": "\\t* class Solution {\\n\\t\\tpublic int arraySign(int[] nums) {\\n\\t\\t\\tint product=1;\\n\\t\\t\\tfor(int num:nums){\\n\\t\\t\\t   if(num<0){\\n\\t\\t\\t\\tproduct=-(product);\\n\\t\\t\\t   }else if(num==0){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t   }\\n\\t\\t\\t}\\n\\t\\t\\treturn product;\\n\\t\\t}\\n}",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic int arraySign(int[] nums) {\\n\\t\\t\\tint product=1;\\n\\t\\t\\tfor(int num:nums){\\n\\t\\t\\t   if(num<0){\\n\\t\\t\\t\\tproduct=-(product);\\n\\t\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 2752360,
                "title": "simple-python3-solution-0-n-time-0-1-space",
                "content": "```\\n1. If nums has 0 it means the result of multiplication is guranteed to be 0\\n2. Otherwise count the number of negative signs\\n3. If the number of negative signs is even it means they are all cancelled during multiplication and we can return 1 else -1\\n\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n        \\n        count = 0\\n        \\n        for n in nums:\\n            if n < 0:\\n                count += 1\\n        \\n        return 1 if count % 2 == 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n1. If nums has 0 it means the result of multiplication is guranteed to be 0\\n2. Otherwise count the number of negative signs\\n3. If the number of negative signs is even it means they are all cancelled during multiplication and we can return 1 else -1\\n\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n        \\n        count = 0\\n        \\n        for n in nums:\\n            if n < 0:\\n                count += 1\\n        \\n        return 1 if count % 2 == 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402614,
                "title": "python-easy-solution",
                "content": "```\\ndef arraySign(self, nums: List[int]) -> int:\\n        if nums.count(0) >=1:\\n            return 0\\n        # no of negative numbers in list\\n        count_neg = sum([1 for i in nums if i <0])\\n        \\n        if count_neg %2 == 0:\\n            return 1\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef arraySign(self, nums: List[int]) -> int:\\n        if nums.count(0) >=1:\\n            return 0\\n        # no of negative numbers in list\\n        count_neg = sum([1 for i in nums if i <0])\\n        \\n        if count_neg %2 == 0:\\n            return 1\\n        else:\\n            return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3476495,
                "title": "easily-understandable-o-n-c-solution-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i,j,c=0;\\n        for(auto v:nums){\\n            if(v<0)\\n            c++;\\n            if(v==0)\\n            return 0;\\n        }\\n        if(c%2==0)\\n        return 1;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int i,j,c=0;\\n        for(auto v:nums){\\n            if(v<0)\\n            c++;\\n            if(v==0)\\n            return 0;\\n        }\\n        if(c%2==0)\\n        return 1;\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499851,
                "title": "solution-using-xor-and-only-a-bool-for-memory",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        signs = False\\n        for x in nums:\\n            if x == 0 : return 0\\n            signs = signs ^ (x < 0)\\n        if signs : return -1\\n        else: return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        signs = False\\n        for x in nums:\\n            if x == 0 : return 0\\n            signs = signs ^ (x < 0)\\n        if signs : return -1\\n        else: return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155462,
                "title": "c",
                "content": "```\\npublic int ArraySign(int[] nums) {\\n\\tvar result = 1;\\n\\tforeach (var num in nums) {\\n\\t\\tif (num == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tresult *= num > 0 ? 1 : -1;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int ArraySign(int[] nums) {\\n\\tvar result = 1;\\n\\tforeach (var num in nums) {\\n\\t\\tif (num == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tresult *= num > 0 ? 1 : -1;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152978,
                "title": "rust-fp-solution",
                "content": "Thanks to **rudy_** for help with shortest solution!\\n\\n```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(1, |prod, &x| prod * x.signum())\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(1, |prod, &x| prod * x.signum())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477379,
                "title": "easy-solution-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The input to the method arraySign is an array of integers called nums. The goal of the method is to return the sign of the product of all the elements in the array.\\n\\n- The method **signFunc** is called with **nums** as an argument. This method computes the sign of the product of all the elements in the array.\\n\\n- The variable **count** is initialized to 0. This variable will be used to count the number of negative elements in the array.\\n\\n- The loop **for(int i:nums)** iterates over all the elements in the array. For each element, if it is equal to 0, the method immediately returns 0 because the product of any number and 0 is 0.\\n\\n- If the element is negative (i.e., less than 0), the variable count is incremented by 1.\\n\\n- After the loop, the method checks whether the count of negative elements is even or odd. If it is even, the method returns 1 because the product of an even number of negative numbers is positive. If it is odd, the method returns -1 because the product of an odd number of negative numbers is negative.\\n\\n- Finally, the arraySign method returns the value returned by **signFunc**.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the provided arraySign method is O(n), where n is the length of the input array nums. This is because the method iterates over each element in the array exactly once.\\n- Space complexity:\\nThe space complexity of the method is O(1), because it only uses a constant amount of extra space to store the count variable. No additional data structures are used that depend on the size of the input array\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        return signFunc(nums);\\n    }\\n    static int signFunc(int[] nums){\\n        int count=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n            count++;\\n        }\\n        if(count%2==0)\\n            return 1;\\n        else \\n            return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        return signFunc(nums);\\n    }\\n    static int signFunc(int[] nums){\\n        int count=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n            count++;\\n        }\\n        if(count%2==0)\\n            return 1;\\n        else \\n            return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475342,
                "title": "simplest-python-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        p=nums[0]\\n        for i in range(1,len(nums)):\\n            p*=nums[i]\\n        if p==0: return 0\\n        elif p>0: return 1\\n        else: return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        p=nums[0]\\n        for i in range(1,len(nums)):\\n            p*=nums[i]\\n        if p==0: return 0\\n        elif p>0: return 1\\n        else: return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475334,
                "title": "daily-leetcoding-challenge-may-day-2",
                "content": "This problem is the Daily LeetCoding Challenge for May, Day 2.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sign-of-the-product-of-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Counting Negative Numbers\n\n  \n**Approach 2:** Tracking the Sign of the Product\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sign-of-the-product-of-an-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2789676,
                "title": "sign-of-the-product-of-an-array-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint arraySign(int* nums, int numsSize){\\n    int k=1;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            return 0;\\n        }\\n        if(nums[i]<0)\\n        {\\n            k++;\\n        }\\n        \\n    }\\n    if(k%2!=0)\\n    {\\n        return 1;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint arraySign(int* nums, int numsSize){\\n    int k=1;\\n    for(int i=0;i<numsSize;i++)\\n    {\\n        if(nums[i]==0)\\n        {\\n            return 0;\\n        }\\n        if(nums[i]<0)\\n        {\\n            k++;\\n        }\\n        \\n    }\\n    if(k%2!=0)\\n    {\\n        return 1;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2078722,
                "title": "sign-of-the-product-of-an-array-python-solution",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            product*=i\\n        if product<0:\\n            return -1\\n        elif product>0:\\n            return 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            product*=i\\n        if product<0:\\n            return -1\\n        elif product>0:\\n            return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159862,
                "title": "sign-of-the-product-of-an-array-c-solution-explained-easy-to-understand",
                "content": "As  said that if the product of all the array element will negative than return -1, if the product will positive return 1 otherwise product is zero return 0. \\nthis is very easy we did not need to calculate the product of all array element just calculate how may negative value is there if total number of -ve value is even then product will surelly positive otherwise negative. if a single zero is present then only the product will zero.\\n\\nso  we calculate number of negative values and any zero if present.\\nby doing this we can reduse the time comlexity.\\nif we go to calculate product than there may be large value which generate some error.\\nso this method is very good use.\\n\\nif you understand upvote.\\n```\\nclass Solution {  \\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                return 0;\\n            if(nums[i]<0)\\n                 c++;\\n        }\\n        if(c%2==0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                return 0;\\n            if(nums[i]<0)\\n                 c++;\\n        }\\n        if(c%2==0)\\n            return 1;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159844,
                "title": "golang-solution-faster-than-100-with-quick-explanation",
                "content": "[1822. Sign of the Product of an Array](https://leetcode.com/problems/sign-of-the-product-of-an-array/)\\n\\n\\nThe idea of this solution is elementary:\\n\\n* If the current number in `nums` is negative, then we can flip the sign\\n* If the current number in `nums` is equal to `0`, we can return `0` because any number multiplied by `0` is `0`. You might think that we can check for `if num == 0` after we have iterated, but that won\\'t work because we only switch the sign and don\\'t multiply by `0`, so we will never know whether there is a `0` in the array.\\n\\n``` go\\nfunc arraySign(nums []int) int {\\n    sign := 1\\n\\n    for _, num := range nums {\\n        if num <= -1 {\\n            sign = - sign\\n        } else if num == 0 {\\n            return 0\\n        }\\n    }\\n\\n    return sign\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc arraySign(nums []int) int {\\n    sign := 1\\n\\n    for _, num := range nums {\\n        if num <= -1 {\\n            sign = - sign\\n        } else if num == 0 {\\n            return 0\\n        }\\n    }\\n\\n    return sign\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152447,
                "title": "javascript-one-line-solution",
                "content": "```javascript\\nvar arraySign = (nums) => Math.min(1, Math.max(-1, nums.reduce((a,c) => a * c)))\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar arraySign = (nums) => Math.min(1, Math.max(-1, nums.reduce((a,c) => a * c)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476912,
                "title": "c-java-python-runtime-0-ms-beats-100-daily-leetcode-solution",
                "content": "# Please UpVote..\\uD83D\\uDE0A\\uD83D\\uDC95\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int neg=0;\\n        for(auto x:nums)\\n        {\\n            if(x==0)\\n            {\\n                return 0;\\n            }\\n            else if(x<0)\\n            {\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```python []\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        neg = 0\\n        for x in nums:\\n            if x == 0:\\n                return 0\\n            elif x < 0:\\n                neg += 1\\n        if neg % 2 == 0:\\n            return 1\\n        return -1\\n```\\n```JAVA []\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        for (int x : nums) {\\n            if (x == 0) {\\n                return 0;\\n            } else if (x < 0) {\\n                neg++;\\n            }\\n        }\\n        if (neg % 2 == 0) {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n# Please UpVote..\\uD83D\\uDE0A\\uD83D\\uDC95\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int neg=0;\\n        for(auto x:nums)\\n        {\\n            if(x==0)\\n            {\\n                return 0;\\n            }\\n            else if(x<0)\\n            {\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python []\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        neg = 0\\n        for x in nums:\\n            if x == 0:\\n                return 0\\n            elif x < 0:\\n                neg += 1\\n        if neg % 2 == 0:\\n            return 1\\n        return -1\\n```\n```JAVA []\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        for (int x : nums) {\\n            if (x == 0) {\\n                return 0;\\n            } else if (x < 0) {\\n                neg++;\\n            }\\n        }\\n        if (neg % 2 == 0) {\\n            return 1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476400,
                "title": "without-multiplication-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count = 0;\\n        for(auto i: nums){\\n            if(i == 0)\\n                return 0; // if 0 is part of array then product is 0\\n            else if(i < 0)\\n                count++;\\n        }  \\n        if(count%2 == 0) // even no. of negative integers then product is postive\\n            return 1;\\n        return -1; // odd no. of negative integers then product is negative\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count = 0;\\n        for(auto i: nums){\\n            if(i == 0)\\n                return 0; // if 0 is part of array then product is 0\\n            else if(i < 0)\\n                count++;\\n        }  \\n        if(count%2 == 0) // even no. of negative integers then product is postive\\n            return 1;\\n        return -1; // odd no. of negative integers then product is negative\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349017,
                "title": "beats-100-0-ms-very-easy-beginner-friendly-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## please Upvote..........................\\n```**\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        double prod=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prod*=nums[i];\\n        }\\n        if(prod<0)return -1;\\n        if(prod>0)return 1;\\n        else return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```**\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        double prod=1;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            prod*=nums[i];\\n        }\\n        if(prod<0)return -1;\\n        if(prod>0)return 1;\\n        else return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159651,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                count *= -1;\\n            }else if (nums[i] == 0)\\n                return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] < 0){\\n                count *= -1;\\n            }else if (nums[i] == 0)\\n                return 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054546,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int negCnt = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                negCnt++;    \\n        }\\n        return (negCnt % 2 == 0) ? 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int negCnt = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                negCnt++;    \\n        }\\n        return (negCnt % 2 == 0) ? 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513150,
                "title": "c-most-optimized-easy-to-understand",
                "content": "If element 0 found than return 0;\\nkeep a track for negative element \\nif negative elements are odd return -1\\nelse return 1;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            if(i<0)x ^= 1;\\n            else if(i==0)return 0;\\n        }\\n        if(x)return -1;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int x = 0;\\n        for(auto &i: nums){\\n            if(i<0)x ^= 1;\\n            else if(i==0)return 0;\\n        }\\n        if(x)return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477536,
                "title": "problem-of-the-day-very-easy-solution-best-approach",
                "content": "class Solution {\\npublic:\\n\\n    int arraySign(vector<int>& nums) {\\n       int neg = 0; \\n\\t   \\n     //neg will store number of negative numbers \\n\\t \\n        for(int i = 0 ; i<nums.size(); i++){\\n\\t\\t//if any number is 0 then product will be 0 \\n\\t\\t\\n            if(nums[i] == 0 )\\n                return 0;\\n            if(nums[i] < 0)\\n                neg++;\\n        }\\n        \\n\\t\\t// if negative numbers are not even the result will be negative hence -1\\n\\t\\t\\n        if(neg % 2 != 0)\\n            return -1;\\n        \\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int arraySign(vector<int>& nums) {\\n       int neg = 0; \\n\\t   \\n     //neg will store number of negative numbers \\n\\t \\n        for(int i = 0 ; i<nums.size(); i++){\\n\\t\\t//if any number is 0 then product will be 0 \\n\\t\\t\\n            if(nums[i] == 0 )\\n                return 0;\\n            if(nums[i] < 0)\\n                neg++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3477458,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n         for(auto num : nums){\\n             if(num==0){\\n                 return 0;\\n             }\\n             if(num<0){\\n                sign = -sign;\\n            }     \\n         }\\n        return sign;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n         for(auto num : nums){\\n             if(num==0){\\n                 return 0;\\n             }\\n             if(num<0){\\n                sign = -sign;\\n            }     \\n         }\\n        return sign;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477170,
                "title": "c-solution-easy-faster",
                "content": "# Intuition\\nIf you go on to multiply each value and check the answer at last then checking the constraints you will get a overflow error for sure.\\n\\nWe have to find a solution without computing the entire values.\\n\\n# Approach\\nFirst sort the entire vector and the ittitare till you find a positive or 0. Keep counting the number of occurances of negative values, if you encounter a zero then directly return 0 otherwise if count of negative is even then return 1 or else return -1.\\n\\n# Complexity\\n- Time complexity:\\n- O(nlogn)\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int neg=0;\\n        int pos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n            else if(nums[0]>0)\\n            {\\n                return 1;\\n            }\\n            else{\\n                if(nums[i]>0)\\n                {\\n                    break;\\n                }\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int neg=0;\\n        int pos=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n            else if(nums[0]>0)\\n            {\\n                return 1;\\n            }\\n            else{\\n                if(nums[i]>0)\\n                {\\n                    break;\\n                }\\n                neg++;\\n            }\\n        }\\n        if(neg%2==0)\\n        {\\n            return 1;\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475980,
                "title": "1-liner-using-reduce-method",
                "content": "# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef array_sign(nums)\\n    nums.reduce(:*) <=> 0\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef array_sign(nums)\\n    nums.reduce(:*) <=> 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3475396,
                "title": "2-liner-cool-clean-code-fast-efficient-c",
                "content": "```\\n\\n/*  \\nWe don\\'t need to multiple all elements and then check the product, it will give RTE\\n\\nTo avoid this, we just need to check for each element is it +ve, -ve or 0.\\nAnd depending on this we just need to update our sign variable,\\n\\nif the element is < 0 : multiple sign by -1,\\nif element == 0 :  multiply sign by 0\\nelse the only condition that left is, if element is > 0 : multiply sign by 1( can skip this condition)\\n\\nAt the end just return the sign\\n*/\\n\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n/*  \\nWe don\\'t need to multiple all elements and then check the product, it will give RTE\\n\\nTo avoid this, we just need to check for each element is it +ve, -ve or 0.\\nAnd depending on this we just need to update our sign variable,\\n\\nif the element is < 0 : multiple sign by -1,\\nif element == 0 :  multiply sign by 0\\nelse the only condition that left is, if element is > 0 : multiply sign by 1( can skip this condition)\\n\\nAt the end just return the sign\\n*/\\n\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475377,
                "title": "swift-good-interview-answer",
                "content": "**Good Interview Answer (accepted answer)**\\n\\nThis is good interview answer because:\\n1) It is simple, clear and concise. (One pass through the array, not a fancy sort + binary search, etc..)\\n2) Doesn\\'t use Multiplication (in theory faster)\\n3) Doesn\\'t use `.reduce()`, so can short-circuit at the first zero (faster).\\n\\nNote: Problem doesn\\'t state what to return for an empty array. Given constraints state that the array always has more than one element, but this would be a good followup with your interviewer to ask to remove the constraint and handle accordingly (return zero, throw, etc).\\n\\n```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        var result = 1\\n        for num in nums where num < 1 {\\n            guard num != 0 else { return 0 }\\n            result = -result\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        var result = 1\\n        for num in nums where num < 1 {\\n            guard num != 0 else { return 0 }\\n            result = -result\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475346,
                "title": "solutions-in-c-python-and-java-look-at-once",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/9bb9f5b1-fd11-4bb0-8644-4173cdf95d76_1682986023.367854.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n<iframe src=\"https://leetcode.com/playground/7XSmkm9m/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "<!-- Describe your first thoughts on how to solve this problem. -->\\n![b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png](https://assets.leetcode.com/users/images/9bb9f5b1-fd11-4bb0-8644-4173cdf95d76_1682986023.367854.png)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n<iframe src=\"https://leetcode.com/playground/7XSmkm9m/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2996375,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find the count of negative numbers. If the count is even , that means all the minus signs will cancel out each other and product will be postive otherwise negative.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirstly, if any number is 0 then product will be 0 so check for that first and no need to proceed further as we already encountered 0 final answer will also be 0 only.\\nthen, \\nIf count(negativeNumbers) is even, then return 1 otherwise return -1.\\n# Complexity\\n- Time complexity : O(N)\\n- Space complexity : O(1) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size(), negativecount = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(nums[i]==0)\\n          return 0;\\n          else if(nums[i]<0)\\n          negativecount++;\\n        }\\n        return negativecount%2 ? -1 : 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size(), negativecount = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n          if(nums[i]==0)\\n          return 0;\\n          else if(nums[i]<0)\\n          negativecount++;\\n        }\\n        return negativecount%2 ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835158,
                "title": "java-easiest-solution-using-only-if-and-else",
                "content": "# Approach\\nCount the number of **negative integer**, if number of count is **divisible by 2 **that means it will be a ****positive value**** so the answer is going to be 1, if the number of count is** not divisibleby 2 **that means it will be a **negative number**. and if the array contains any 0 so the product is ultimately going to 0,so the answer is 0. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 0,product = 1,result = 0;\\n        for (int num : nums) {\\n            if (num < 0) count++;\\n            if (num == 0) {\\n                product = 0;\\n                break;\\n            }\\n        }\\n        if (product == 0) return 0;\\n        else {\\n            if ((count % 2 != 0)) result = -1;\\n            if ((count % 2 == 0)) result = 1;\\n            if (result == -1) return -1;\\n            else return 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count = 0,product = 1,result = 0;\\n        for (int num : nums) {\\n            if (num < 0) count++;\\n            if (num == 0) {\\n                product = 0;\\n                break;\\n            }\\n        }\\n        if (product == 0) return 0;\\n        else {\\n            if ((count % 2 != 0)) result = -1;\\n            if ((count % 2 == 0)) result = 1;\\n            if (result == -1) return -1;\\n            else return 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456697,
                "title": "python-solution-faster-than-95-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = math.prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0  \\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = math.prod(nums)\\n        return 1 if product > 0 else -1 if product < 0 else 0  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058671,
                "title": "naive-solution",
                "content": "private static int cuts(int A, int B){\\n        int sum = A + B;\\n        int length = sum/4;\\n        while(length>0){\\n            if((A/length + B/length)==4)\\n                return length;\\n            else\\n                length--;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [],
                "code": "private static int cuts(int A, int B){\\n        int sum = A + B;\\n        int length = sum/4;\\n        while(length>0){\\n            if((A/length + B/length)==4)\\n                return length;\\n            else\\n                length--;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1940922,
                "title": "python-3-lines-of-code-faster-than-96",
                "content": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    class Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for n in nums: product*=n\\n        return 1 if product > 1 else (-1 if product < 0 else 0)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Upvote if it was usefull for you \\uD83D\\uDE42\\n\\n```\\nclass Solution:\\n    class Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product=1\\n        for n in nums: product*=n\\n        return 1 if product > 1 else (-1 if product < 0 else 0)",
                "codeTag": "Java"
            },
            {
                "id": 1484036,
                "title": "simple-javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    if(nums.includes(0)) return 0;\\n    return (nums.filter(item => item < 0).length % 2 === 0 ? 1 : -1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    if(nums.includes(0)) return 0;\\n    return (nums.filter(item => item < 0).length % 2 === 0 ? 1 : -1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463239,
                "title": "ruby-oneliner",
                "content": "```\\ndef array_sign(nums)\\n   nums.inject(:*) <=> 0\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef array_sign(nums)\\n   nums.inject(:*) <=> 0\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3478304,
                "title": "java-solution-for-sign-of-the-product-of-an-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n The intuition behind this approach is that the sign of the product of an array of numbers is determined by the number of negative elements in the array. If the number of negative elements is even, the product is positive, otherwise, it is negative. If there is a zero in the array, then the product is zero.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis implementation counts the number of negative integers in the input array. If the count is even, the product of all numbers is positive, and signFunc() returns 1. If the count is odd, the product of all numbers is negative, and signFunc() returns -1. If the input array contains a zero, the product is zero, and signFunc() returns 0. This approach works well even for large length of nums.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses a constant amount of space to store the count of negative elements, so the space complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n       int countNegatives = 0;\\n        for (int num : nums) \\n        {\\n            if (num == 0) \\n            {\\n                return 0;\\n            } \\n            else if (num < 0) \\n            {\\n                countNegatives++;\\n            }\\n        }\\n        return (countNegatives % 2 == 0) ? 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n       int countNegatives = 0;\\n        for (int num : nums) \\n        {\\n            if (num == 0) \\n            {\\n                return 0;\\n            } \\n            else if (num < 0) \\n            {\\n                countNegatives++;\\n            }\\n        }\\n        return (countNegatives % 2 == 0) ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477311,
                "title": "fastest-way-to-solve-this-question-beats-100",
                "content": "# What question says\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere is a function signFunc(x) that returns:\\n\\n1 if x is positive.\\n-1 if x is negative.\\n0 if x is equal to 0.\\n\\nYou are given an integer array nums. Let product be the product of all values in the array nums.\\n\\n# Approach\\n\\n1. The arraySign method takes an integer array nums as input.\\n\\n2. The method initializes the product variable to 1, which represents a positive product.\\n\\n3. The loop iterates over each element num of the input array nums.\\n\\n4. If the current element num is equal to 0, then the method immediately returns 0, since the product of the array will also be 0.\\n\\n5. If the current element num is negative (num < 0), then the product variable is multiplied by -1, which effectively flips the sign of the product to negative.\\n\\n6. After the loop has finished iterating over all the elements, the method returns the value of product.\\n\\n7. If product is positive, the method returns 1, which represents a positive product.\\n\\n8. If product is negative, the method returns -1, which represents a negative product.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int num : nums) {\\n            if (num == 0) {\\n                return 0;\\n            } else if (num < 0) {\\n                sign *= -1;\\n            }\\n        }\\n        return sign;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int sign = 1;\\n        for (int num : nums) {\\n            if (num == 0) {\\n                return 0;\\n            } else if (num < 0) {\\n                sign *= -1;\\n            }\\n        }\\n        return sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477050,
                "title": "easy-js-one-liner",
                "content": "# Code\\n```\\nconst arraySign = nums => nums.includes(0) ? 0 : Math.sign(nums.reduce((p, n) => p * n, 1));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst arraySign = nums => nums.includes(0) ? 0 : Math.sign(nums.reduce((p, n) => p * n, 1));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476507,
                "title": "detailed-analysis-and-explanation-for-3-approach-in-python-with-time-comparison",
                "content": "## Simple approach but contains explanation to why I wrote what I wrote!\\nClearly, you cannot multiply each element and then return the sign of the product. This is not feasible as we will be storing large size of data.\\n\\n`Check the execution time for each approach in Python at the end of 3 python approaches`\\n# Code in Python: Approach 1\\n\\n1. Given that we have to `return 0` when we find a \\'0\\', simply put in a condition in the loop for this.\\n2. Initialize `sign` to 1 and if you find a **neg**ative **num**ber, **flip the sign**\\n3. Return the `sign` at the end.\\n``` Python_Approach_1 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                sign = -sign\\n        \\n        return sign\\n```\\n# Code in Python: Approach 2\\n1. Return 0, if you find 0 in the list.\\n2. Initiliaze `sign=1`.\\n3. For each element, set `sign *= element//abs(element)`\\n\\n``` Python_Approach_2 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            sign *= i // abs(i)\\n        \\n        return sign\\n```\\n# Code in Python: Approach 3\\n1. Return 0, if you find 0 in the list.\\n2. Initiliaze `countOfNegatives=0`.\\n3. For each **neg**ative **ele**ment, set `countOfNegatives += 1`.\\n4. After the loop, **return 1** if `countOfNegatives % 2 == 0`. This means that there are even number of negatives.\\n**(-1)<sup>2*n</sup> = 1**\\n5. Else, return -1\\n**(-1)<sup>2*n+1</sup> = -1**\\n\\n``` Python_Approach_3 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        countOfNegatives = 0\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                countOfNegatives += 1\\n        \\n        return 1 if countOfNegatives % 2 == 0 else -1\\n```\\n<br>\\n\\n# Comparing Python execution time using timeit (in ms)\\n```ExecutionTime_Approach1 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'-(-19)\\', number = 10**8)\\n2.5612723330050358\\n```\\n\\n```ExecutionTime_Approach2 []\\n>>>timeit.timeit(\\'1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7137523339988547\\n>>>timeit.timeit(\\'-1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7235794579974026\\n```\\n\\n```ExecutionTime_Approach3 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'1+1\\', number = 10**8)\\n    + timeit.timeit(\\'2 % 2 == 0\\', number = 10**8)\\n4.421872499995516\\n```\\n---\\n\\n# Code in C\\n1. Use an **int** **var**iable for `sign` and initialize to 1.\\n2. When you find a negative number, **flip the sign**.\\n3. At the end, return the `sign`.\\n``` C []\\nint arraySign(int* nums, int numsSize){\\n\\n# Initialize sign to 1\\nint sign = 1;\\n\\nfor(int i =0; i<numsSize; i++){\\n\\n    if(nums[i] == 0)\\n        # If you encounter zero, the entire product will be zero\\n        return 0;\\n\\n    if (nums[i] < 0)\\n        # If number is negative, flip the sign\\n        sign = -sign;\\n}\\n\\nreturn sign;\\n}\\n```\\n\\n### Please consider upvoting if you liked it or comment if you have a better alternative! Thank you!",
                "solutionTags": [
                    "Python3",
                    "C",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "``` Python_Approach_1 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                sign = -sign\\n        \\n        return sign\\n```\n``` Python_Approach_2 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        sign = 1\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            sign *= i // abs(i)\\n        \\n        return sign\\n```\n``` Python_Approach_3 []\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        countOfNegatives = 0\\n\\n        for i in nums:\\n\\n            if i == 0:\\n                return 0\\n\\n            if i < 0:\\n                countOfNegatives += 1\\n        \\n        return 1 if countOfNegatives % 2 == 0 else -1\\n```\n```ExecutionTime_Approach1 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'-(-19)\\', number = 10**8)\\n2.5612723330050358\\n```\n```ExecutionTime_Approach2 []\\n>>>timeit.timeit(\\'1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7137523339988547\\n>>>timeit.timeit(\\'-1 * (-19)//abs(-19)\\', number = 10**8)\\n3.7235794579974026\\n```\n```ExecutionTime_Approach3 []\\n>>>timeit.timeit(\\'-19<0\\', number = 10**8) \\n    + timeit.timeit(\\'1+1\\', number = 10**8)\\n    + timeit.timeit(\\'2 % 2 == 0\\', number = 10**8)\\n4.421872499995516\\n```\n``` C []\\nint arraySign(int* nums, int numsSize){\\n\\n# Initialize sign to 1\\nint sign = 1;\\n\\nfor(int i =0; i<numsSize; i++){\\n\\n    if(nums[i] == 0)\\n        # If you encounter zero, the entire product will be zero\\n        return 0;\\n\\n    if (nums[i] < 0)\\n        # If number is negative, flip the sign\\n        sign = -sign;\\n}\\n\\nreturn sign;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476425,
                "title": "two-approach-without-product-and-with-product-c-beats-100",
                "content": "# Intuition\\nFirst Approach-01:\\nIn this we create a `signFunc` as stated in the question \\nThen We simply do the product of all elements in vector and then pass it to the `signFunc` \\nMain trick to this Question is **Modulo operator**\\nAs the product will exceed the int or long long Range so to overcome that we have to use a number to limit the product and to limit a number so that it dont cross a specific range we use Modulo operator \\n\\nThe task is to determine which number we can take as the upper limit\\nSo for that we will go for 1e9+7 (i.e. 1000000007) as it is the highest prime number close to the range of int data type.\\n*P.S. you can google it to know more about it *\\n\\nSecond Approach-02:(**Easy and Brainer way**)\\nIn this method we are counting the no. of negative elements and if we found a zero we will return the 0\\n\\nif we dont then we simply check the count of negative number,\\nif count is multiple of two then the resultant product will always be a positive number \\nelse it will be a negative number\\n\\n\\n\\n# Approach-01-Code\\n```\\nclass Solution {\\npublic:\\n    int signFunc(long long product){\\n        if(product < 0){\\n            return -1;\\n        }\\n        else if(product > 0){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int arraySign(vector<int>& n) {\\n        long long int product=1;\\n\\n        for(auto val:n){\\n            product *= val*1ll;\\n            product = product%1000000007 ;\\n        }\\n\\n        return signFunc(product);\\n    }\\n};\\n```\\n# Approach-02-Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& n) {\\n        int count=0;\\n        \\n        for(auto val:n){\\n            if(val<0){\\n                count++;\\n            }\\n            else if(val==0){\\n                return 0;\\n            }\\n        }\\n\\n        if(count&1){//condition to check a number is odd\\n            return -1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int signFunc(long long product){\\n        if(product < 0){\\n            return -1;\\n        }\\n        else if(product > 0){\\n            return 1;\\n        }\\n        else{\\n            return 0;\\n        }\\n    }\\n    int arraySign(vector<int>& n) {\\n        long long int product=1;\\n\\n        for(auto val:n){\\n            product *= val*1ll;\\n            product = product%1000000007 ;\\n        }\\n\\n        return signFunc(product);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& n) {\\n        int count=0;\\n        \\n        for(auto val:n){\\n            if(val<0){\\n                count++;\\n            }\\n            else if(val==0){\\n                return 0;\\n            }\\n        }\\n\\n        if(count&1){//condition to check a number is odd\\n            return -1;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476268,
                "title": "o-n-solution-java-python-easy-explained",
                "content": "# Intuition\\n- if any one is 0 all will get 0 \\n- if count of neg is even they will cancel each of them we will get positive \\n- if count of neg is odd it will be negative \\n\\n# Code\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg_cnt = 0\\n\\n        for i in nums:\\n            if(i==0):\\n                return 0\\n            elif(i<0):\\n                neg_cnt+=1\\n        \\n        if(neg_cnt%2==0):\\n            return 1\\n        return -1\\n```\\n# Java \\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int cntneg = 0;\\n        for(int i: nums){\\n            if(i==0){\\n                return 0;\\n            }else if(i<0){\\n                cntneg++;\\n            }\\n        }\\n        return cntneg%2==0?1:-1;\\n    }\\n}\\n```\\n# Complexity \\n- TC: O(n)\\n- SC: O(1)",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg_cnt = 0\\n\\n        for i in nums:\\n            if(i==0):\\n                return 0\\n            elif(i<0):\\n                neg_cnt+=1\\n        \\n        if(neg_cnt%2==0):\\n            return 1\\n        return -1\\n```\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int cntneg = 0;\\n        for(int i: nums){\\n            if(i==0){\\n                return 0;\\n            }else if(i<0){\\n                cntneg++;\\n            }\\n        }\\n        return cntneg%2==0?1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475884,
                "title": "python-shortest-1-liner-functional-programming",
                "content": "# Approach\\n1. Let `sign` be a function that returns `1` for positive numbers, `-1` for negative, and `0` for zero. We can define this as:\\n`sign = lambda x: (x > 0) - (x < 0)`\\n\\n2. Apply `sign` to each number in `nums`.\\n\\n3. Return the product of the signs.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is length of nums`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def arraySign(self, nums: list[int]) -> int:\\n        return reduce(mul, map(lambda x: (x > 0) - (x < 0), nums))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def arraySign(self, nums: list[int]) -> int:\\n        return reduce(mul, map(lambda x: (x > 0) - (x < 0), nums))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475742,
                "title": "easy-java-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n          if(nums[i]==0)\\n          return 0;\\n          if(nums[i]<0)\\n          c++;\\n        }\\n        return c%2==0 ? 1:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n          if(nums[i]==0)\\n          return 0;\\n          if(nums[i]<0)\\n          c++;\\n        }\\n        return c%2==0 ? 1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475616,
                "title": "java-solutions-easy-to-understand-100",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod = 1;\\n        for(int i: nums){\\n            if(i < 0){\\n                prod *= -1;\\n            }else if(i > 0){\\n                prod *= 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        return prod;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int prod = 1;\\n        for(int i: nums){\\n            if(i < 0){\\n                prod *= -1;\\n            }else if(i > 0){\\n                prod *= 1;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        return prod;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475415,
                "title": "easy-java-solution-using-iteration-beginner-friendly",
                "content": "# Intuition\\nIn Multiplciation\\n1. If any element is 0, multiplication is 0\\n2. if number if negative element are odd, multiplication is negative\\n3. multiplication is positive in other case\\n\\n# Approach\\n1. Count number of negative elements\\n2. If you see 0 while traversing, return 0 immediately\\n3. At the end if number of negative numbers is odd, return -1 else return 1 \\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negativeCount = 0;\\n        for(int num : nums) {\\n            if(num == 0) {\\n                return 0;\\n            } else if( num < 0) {\\n                negativeCount++;\\n            }\\n        }\\n\\n        if(negativeCount % 2 == 1) {\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negativeCount = 0;\\n        for(int num : nums) {\\n            if(num == 0) {\\n                return 0;\\n            } else if( num < 0) {\\n                negativeCount++;\\n            }\\n        }\\n\\n        if(negativeCount % 2 == 1) {\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475402,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n\\n        res=1\\n        for x in nums:\\n            res*=int(x/abs(x))\\n\\n        return res        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        if 0 in nums:\\n            return 0\\n\\n        res=1\\n        for x in nums:\\n            res*=int(x/abs(x))\\n\\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274865,
                "title": "c-2-solutions-easy-understanding",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/7990c4ba-a757-4a76-9eed-0d4cba0b8b5c_1678339994.0675652.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int product = 1 ; \\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if (nums[i] == 0)\\n            {\\n                return 0 ; \\n            }\\n\\n            else if (nums[i] < 0)\\n            {\\n                product *= -1 ; \\n            }\\n\\n            else \\n            {\\n                product *= 1 ;\\n            }\\n        }\\n        return product ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266151,
                "title": "java-easy-and-explained-solution-speed-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the array**, we can track the **sign** of the product without actually make the operation.  \\n\\n*At each iteration* we have to do three operations:\\n1) If the **number is zero**, `return 0` this because the product of every number with zero is zero;\\n2) If the **number is negative**, change the sign of the result;\\n3) If the **number is positive** go to the next iteration, this case does not change the sign of the result.\\n\\n**Note:** Is important *to not make the operation* because the product of lots of high numbers can generate an **overflow** (this happen when the operation attempts to create a numeric value that is outside of the range that can be represented with a given number of digits).\\n\\n# Complexity\\n- **Time complexity:** $O(n)$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(1)$\\n- **Memory Beats:** 74.72%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        \\n        int sign = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                sign *= -1;\\n        }\\n\\n        return sign;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        \\n        int sign = 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            if (nums[i] == 0)\\n                return 0;\\n            if (nums[i] < 0)\\n                sign *= -1;\\n        }\\n\\n        return sign;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226033,
                "title": "brute-force-but-beginner-friendly-code-c-62-69-beats",
                "content": "# Intuition\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/ff5c7348-6a3c-4428-886c-5682f8b40092_1678369404.0709472.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      \\n        int size = nums.size () ;\\n        double pro = 1 ;\\n       \\n        for ( int i = 0 ; i < size ; i ++ ){\\n            pro = pro * nums[ i ] ;\\n         }\\n         if ( pro > 0 ) {\\n             return 1 ;\\n        }\\n        else if ( pro < 0 ){\\n            return -1; \\n        }\\n        else \\n        return 0 ;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      \\n        int size = nums.size () ;\\n        double pro = 1 ;\\n       \\n        for ( int i = 0 ; i < size ; i ++ ){\\n            pro = pro * nums[ i ] ;\\n         }\\n         if ( pro > 0 ) {\\n             return 1 ;\\n        }\\n        else if ( pro < 0 ){\\n            return -1; \\n        }\\n        else \\n        return 0 ;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128152,
                "title": "simple-javascript-solution-using-reduce-method-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    const pdt = nums.reduce((a,b)=>a*b,1);\\n    if(pdt<0){\\n        return -1;\\n    }\\n    else if (pdt >0){\\n        return 1;\\n    }\\n    return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    const pdt = nums.reduce((a,b)=>a*b,1);\\n    if(pdt<0){\\n        return -1;\\n    }\\n    else if (pdt >0){\\n        return 1;\\n    }\\n    return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068013,
                "title": "simple-solution-with-explanation-on-swift",
                "content": "# Explanation\\n1. Check if nums array contains zero. __0 * n = 0__\\n2. Find how many negative numbers in array\\n3. if its even: __-2 * -2 = 4__. So result will be 1.\\n4. if its odd: __-2 * -2 * -1 = -4__. In this way result will be -1.\\n# Code\\n```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        guard !nums.contains(0) else { return 0 }\\n        return nums.filter { $0 < 0 }.count % 2 == 0 ? 1 : -1\\n    }\\n}\\n```\\n### Please upvote if my solution was helpful to you!",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func arraySign(_ nums: [Int]) -> Int {\\n        guard !nums.contains(0) else { return 0 }\\n        return nums.filter { $0 < 0 }.count % 2 == 0 ? 1 : -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926532,
                "title": "superb-logic-in-python3-java-golang",
                "content": "# 1. Python3 Solution\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        answer=0\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            if i<0:\\n                answer+=1\\n        return 1 if answer%2==0 else -1\\n\\t\\t\\n```\\n# 2. Golang Solution \\n```\\nfunc arraySign(nums []int) int {\\n    answer:=0\\n    for _,v:=range nums{\\n        if v==0{\\n            return 0\\n        }\\n        if v<0{\\n            answer++\\n        }\\n    }\\n    if answer%2==0{\\n        return 1\\n    }\\n    return -1\\n}\\n```\\n# 3. Java Solution\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int answer=0;\\n        for(int n :nums){\\n            if (n==0){\\n                return 0;\\n            }\\n            if (n<0){\\n                answer++;\\n            }\\n        }\\n        return answer%2==0?1:-1;\\n    }\\n}\\n```\\n# 4. Python3 Solution\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        #import math\\n        list1=[]\\n        for i in nums:\\n            if i<0:\\n                list1.append(-1)\\n            elif i>0:\\n                list1.append(1)\\n            else:\\n                list1.append(0)\\n        list2=math.prod(list1)\\n        return list2\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        answer=0\\n        for i in nums:\\n            if i==0:\\n                return 0\\n            if i<0:\\n                answer+=1\\n        return 1 if answer%2==0 else -1\\n\\t\\t\\n```\n```\\nfunc arraySign(nums []int) int {\\n    answer:=0\\n    for _,v:=range nums{\\n        if v==0{\\n            return 0\\n        }\\n        if v<0{\\n            answer++\\n        }\\n    }\\n    if answer%2==0{\\n        return 1\\n    }\\n    return -1\\n}\\n```\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int answer=0;\\n        for(int n :nums){\\n            if (n==0){\\n                return 0;\\n            }\\n            if (n<0){\\n                answer++;\\n            }\\n        }\\n        return answer%2==0?1:-1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        #import math\\n        list1=[]\\n        for i in nums:\\n            if i<0:\\n                list1.append(-1)\\n            elif i>0:\\n                list1.append(1)\\n            else:\\n                list1.append(0)\\n        list2=math.prod(list1)\\n        return list2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761996,
                "title": "fully-explained-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will maintain a counter to calculate the negative values in the array.\\nIf the counter got the even value after traversing the whole array, it means the product of all array elements will be positive.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the array, \\nIf any element in the array appears to be 0, simply return 0;\\nIf we encounter any negative value then we will increase our negativeCount by 1;\\n\\nWe dont have to deal with positive values as positive*positive is always positive.\\n\\nIn the last we will check if negativeCount is even or not, if its even, then product will be positive, else it will be negative.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        //counter to keep track of negative values\\n        int negativeCount = 0;\\n        //Traversing the loop\\n        for(int i=0; i<nums.length; i++) {\\n            //If any array element is 0, product will be zero\\n            if(nums[i] == 0) {\\n                return 0;\\n            }\\n            //If negative number, then increase the negativeCount by 1\\n            if(nums[i] < 0) {\\n                negativeCount++;\\n            }\\n        }\\n        //If negativeCount is even, product will be positive, hence return 1\\n        if(negativeCount%2 == 0) {\\n            return 1;\\n        } else {    //negativeCount is odd, product will be negative\\n            return -1; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        //counter to keep track of negative values\\n        int negativeCount = 0;\\n        //Traversing the loop\\n        for(int i=0; i<nums.length; i++) {\\n            //If any array element is 0, product will be zero\\n            if(nums[i] == 0) {\\n                return 0;\\n            }\\n            //If negative number, then increase the negativeCount by 1\\n            if(nums[i] < 0) {\\n                negativeCount++;\\n            }\\n        }\\n        //If negativeCount is even, product will be positive, hence return 1\\n        if(negativeCount%2 == 0) {\\n            return 1;\\n        } else {    //negativeCount is odd, product will be negative\\n            return -1; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723756,
                "title": "one-line-python-code",
                "content": "Don\\'t use this for interview, just for fun :)\\n\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        return reduce(lambda x, y: x*y, [0 if x==0 else (1 if x>0 else -1) for x in nums])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        return reduce(lambda x, y: x*y, [0 if x==0 else (1 if x>0 else -1) for x in nums])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627194,
                "title": "java-solution-no-need",
                "content": "```\\n public int arraySign(int[] a) {\\n     int n=a.length;\\n        int sign=1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                return 0;\\n            }\\n            else if(a[i]<0){\\n                sign=-sign;\\n            } \\n        }          \\n      return sign;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int arraySign(int[] a) {\\n     int n=a.length;\\n        int sign=1;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==0){\\n                return 0;\\n            }\\n            else if(a[i]<0){\\n                sign=-sign;\\n            } \\n        }          \\n      return sign;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2577104,
                "title": "easy-solution-fast-cpp",
                "content": "solution in CPP:\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n       long long prod=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]<0)\\n                prod*=-1;\\n            if(nums[i]==0)\\n                return 0;\\n            \\n        }\\n        if(prod<0)\\n            return -1;\\n        else\\n            return 1;\\n       \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n       long long prod=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          if(nums[i]<0)\\n                prod*=-1;\\n            if(nums[i]==0)\\n                return 0;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2298279,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int neg = 0; // number of negative numbers in given array\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 0) return 0; // there is no doubt, that if one of the multipliers is zero, the product is also zero\\n            if(nums[i] < 0) neg++; // count negative numbers in our array\\n        }\\n        return neg % 2 == 0 ? 1 : -1; // obviously, if the number of negative numbers is odd, the product is also odd\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int neg = 0; // number of negative numbers in given array\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] == 0) return 0; // there is no doubt, that if one of the multipliers is zero, the product is also zero\\n            if(nums[i] < 0) neg++; // count negative numbers in our array\\n        }\\n        return neg % 2 == 0 ? 1 : -1; // obviously, if the number of negative numbers is odd, the product is also odd\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224875,
                "title": "python3-simple-one-liner",
                "content": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        def signFun(x):\\n            return 1 if x > 0 else -1 if x < 0 else 0\\n        \\n        return signFun(math.prod(nums))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        \\n        def signFun(x):\\n            return 1 if x > 0 else -1 if x < 0 else 0\\n        \\n        return signFun(math.prod(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990967,
                "title": "java-easy-solution-faster-than-100",
                "content": "class Solution {\\n\\n    public int arraySign(int[] nums) {\\n\\t\\n        if(nums[0]==0)\\n            return 0;\\n        int sign= (int)nums[0]/Math.abs(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            \\n            if(nums[i]==0)\\n                return 0;\\n            \\n            if(nums[i]<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int arraySign(int[] nums) {\\n\\t\\n        if(nums[0]==0)\\n            return 0;\\n        int sign= (int)nums[0]/Math.abs(nums[0]);\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            \\n            if(nums[i]==0)\\n                return 0;\\n            \\n            if(nums[i]<0)\\n                sign*=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1913659,
                "title": "c-simple-solution-96-beats",
                "content": "Here I looped through the vector and with every element, I determined the sign of the product into a variable .\\nThis way we dont have to store huge valued data into a variable.\\n\\nTime Complexity : O(n)\\n\\n```\\n short int prod=1; /*this stores the sign of intermediate result*/\\n        \\n        for(int i:nums){\\n            prod*=i;\\n            \\n            if(prod>0)\\n\\t\\t\\t\\t\\tprod=1;\\n            else if(prod<0)\\n\\t\\t\\t\\t\\tprod=-1;\\n        }\\n        \\n        return prod;\\n```\\n\\n**Upvote** if you find this helpful. Thanks.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n short int prod=1; /*this stores the sign of intermediate result*/\\n        \\n        for(int i:nums){\\n            prod*=i;\\n            \\n            if(prod>0)\\n\\t\\t\\t\\t\\tprod=1;\\n            else if(prod<0)\\n\\t\\t\\t\\t\\tprod=-1;\\n        }\\n        \\n        return prod;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1897009,
                "title": "java-solution-100-beats-tc-o-n-sc-o-1",
                "content": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int sign=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                return 0;\\n            }\\n            else if(nums[i]<0){\\n                sign=-sign;\\n            }\\n        }\\n        return sign;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int sign=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1819961,
                "title": "c-simple-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                ans*=-1;\\n            }\\n            if(nums[i]==0){\\n                ans=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo upvote if you understood :-)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                ans*=-1;\\n            }\\n            if(nums[i]==0){\\n                ans=0;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818106,
                "title": "rust-one-liner-with-bit-op",
                "content": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .try_fold(0, |sign, &x| if x == 0 {Err(0)} else {Ok(sign^x)})\\n            .map(|sign| if sign < 0 {-1} else {1})\\n            .unwrap_or(0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn array_sign(nums: Vec<i32>) -> i32 {\\n        nums.iter()\\n            .try_fold(0, |sign, &x| if x == 0 {Err(0)} else {Ok(sign^x)})\\n            .map(|sign| if sign < 0 {-1} else {1})\\n            .unwrap_or(0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1200880,
                "title": "weeb-does-python-beats-99-32",
                "content": "![image](https://assets.leetcode.com/users/images/3e437a72-274e-4ada-890e-1cba6b175b2f_1620638449.5641868.png)\\n\\n\\tclass Solution:\\n\\t\\tdef arraySign(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, count = sorted(nums), 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif nums[i] > 0:\\n\\t\\t\\t\\t\\tif count % 2 == 0: return 1 \\n\\t\\t\\t\\t\\telse: return -1\\n\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\n\\t\\t\\tif count % 2 == 0: # if all are negative\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse: return -1\\n\\t\\t\\nAIght coders, its time for some anime recommendations \\nTry watching **Y\\u014Dkoso Jitsuryoku Shij\\u014D Shugi no Ky\\u014Dshitsu e(Classroom of the Elite)**\\n\\n# Episodes: 12\\n# Genres: Comedy(not sure about that but its what kicassanime says), School, Romance\\n\\nThe protagonist in this anime is a savage and everyone in this highschool has a contorted mentality\\nWatch it yourself, its quite interesting",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/3e437a72-274e-4ada-890e-1cba6b175b2f_1620638449.5641868.png)\\n\\n\\tclass Solution:\\n\\t\\tdef arraySign(self, nums: List[int]) -> int:\\n\\t\\t\\tnums, count = sorted(nums), 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif nums[i] > 0:\\n\\t\\t\\t\\t\\tif count % 2 == 0: return 1 \\n\\t\\t\\t\\t\\telse: return -1\\n\\t\\t\\t\\tcount+=1\\n\\t\\t\\t\\n\\t\\t\\tif count % 2 == 0: # if all are negative\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telse: return -1\\n\\t\\t\\nAIght coders, its time for some anime recommendations \\nTry watching **Y\\u014Dkoso Jitsuryoku Shij\\u014D Shugi no Ky\\u014Dshitsu e(Classroom of the Elite)**\\n\\n# Episodes: 12\\n# Genres: Comedy(not sure about that but its what kicassanime says), School, Romance\\n\\nThe protagonist in this anime is a savage and everyone in this highschool has a contorted mentality\\nWatch it yourself, its quite interesting",
                "codeTag": "Java"
            },
            {
                "id": 1155585,
                "title": "c-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int neg=0;\\n        for(auto i:nums) {\\n            if(i<0) ++neg;\\n            else if(!i) return 0;\\n        }\\n        return neg%2?-1:1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int res=1;\\n        for(auto i:nums) {\\n            if(i<0) res=-res;\\n            else if(!i) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int neg=0;\\n        for(auto i:nums) {\\n            if(i<0) ++neg;\\n            else if(!i) return 0;\\n        }\\n        return neg%2?-1:1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int arraySign(const vector<int>& nums) {\\n        int res=1;\\n        for(auto i:nums) {\\n            if(i<0) res=-res;\\n            else if(!i) return 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152844,
                "title": "c-easy-and-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int ans = 1;\\n        for(int i : nums)\\n        {\\n            if(i < 0)\\n                ans *= -1;\\n            if(i == 0)\\n                return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int ans = 1;\\n        for(int i : nums)\\n        {\\n            if(i < 0)\\n                ans *= -1;\\n            if(i == 0)\\n                return 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892204,
                "title": "simply-code-beat-100-of-users-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] ==0) return 0;\\n            else if(nums[i]<0)\\n           count++;\\n        }\\n        if(count%2==0) return 1;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] ==0) return 0;\\n            else if(nums[i]<0)\\n           count++;\\n        }\\n        if(count%2==0) return 1;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672974,
                "title": "c-code-0ms-runtime-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n    int d=0;\\n    for(int i=0;i<nums.size();i++){\\n     if(nums[i]<0){\\n          d=d+1;\\n        \\n      }\\n      else if(nums[i]==0){\\n         return 0;\\n      }\\n     \\n  }\\n   \\n    if(d%2==0){\\n        return 1;\\n    }\\n   return -1;\\n\\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n    int d=0;\\n    for(int i=0;i<nums.size();i++){\\n     if(nums[i]<0){\\n          d=d+1;\\n        \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 3522902,
                "title": "easy-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe only need to check the sign of each integer in the given array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n>make a variable ans = 1;\\n>iterate through the array\\n> if the number is positive, multiply 1 to the ans\\n>if the number is negative, numtiply -1 to ans\\n>if the number is zero, make ans = 0;\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        int ans = 1;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i] > 0){\\n                ans *= 1;\\n            }\\n            else if(nums[i] == 0){\\n                ans = 0;\\n            }\\n            else{\\n                ans *= -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        int ans = 1;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i] > 0){\\n                ans *= 1;\\n            }\\n            else if(nums[i] == 0){\\n                ans = 0;\\n            }\\n            else{\\n                ans *= -1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478995,
                "title": "o-1-space-c-easy-solution-traverse-the-array",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Maintain a variable neg =0;\\n2. increase neg every time the value of array is less than 0.\\n\\n\\n $$if$$ 0 is present in array, then return 0;\\n$$else if$$ neg is present **\\'even\\'** times, then return 1;\\n$$else$$ return -1;\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n\\n        // maintain count of negative number.\\n        int neg=0;\\n\\n        for(auto i:nums)\\n        {\\n             // if zero is present, then return 0;\\n             if(i==0) return 0;\\n\\n            // if number is negative, then increase the count\\n            if(i<0) neg++;\\n        }\\n\\n        // if count appears odd number of times.\\n        if(neg&1) return -1;\\n\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n\\n        // maintain count of negative number.\\n        int neg=0;\\n\\n        for(auto i:nums)\\n        {\\n             // if zero is present, then return 0;\\n             if(i==0) return 0;\\n\\n            // if number is negative, then increase the count\\n            if(i<0) neg++;\\n        }\\n\\n        // if count appears odd number of times.\\n        if(neg&1) return -1;\\n\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478965,
                "title": "easy-understable-code-javascript",
                "content": "ja# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate the array find the value \\nif value is greater than zero return 1\\nif value is lesser than zero return -1\\nif value is equal to zero return 1\\n\\n\\n# Complexity\\n- Time complexity: linear time complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let value=1;\\n    for(let i=0;i<nums.length;i++){\\n        value=value*nums[i];\\n    }\\n    if(value>0){\\n        return 1\\n    }else if(value<0){\\n        return -1\\n    }else{\\n        return 0\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let value=1;\\n    for(let i=0;i<nums.length;i++){\\n        value=value*nums[i];\\n    }\\n    if(value>0){\\n        return 1\\n    }else if(value<0){\\n        return -1\\n    }else{\\n        return 0\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478763,
                "title": "1-line-math-sign",
                "content": "# Code\\n```\\nfunction arraySign(nums: number[]): number {\\n    return nums.reduce((sign, cur) => sign * Math.sign(cur), 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction arraySign(nums: number[]): number {\\n    return nums.reduce((sign, cur) => sign * Math.sign(cur), 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3478296,
                "title": "2-liner-smart-code-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign = 1;\\n        for(int x : nums) sign *= (x == 0) ? 0 : ((x < 1) ? -1 : 1);\\n        return (sign < 0) ? -1 : ((sign > 0) ? 1 : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477862,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the array contains odd numbers of negative numbers, than answer is -1.\\nIf not than answer is 1.If zero exist\\xA0in the array, then the answer is 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCount how many times negative exist in the array by traversing whole array.If zero exist\\xA0in the array, then return 0. if odd numbers of negative numbers than return -1.otherwise return 1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int posnum = 0;\\n        int negnum = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                negnum++;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n        }\\n        if(negnum%2!=0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int posnum = 0;\\n        int negnum = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                negnum++;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                return 0;\\n            }\\n        }\\n        if(negnum%2!=0)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477534,
                "title": "golang-solution-with-good-description",
                "content": "# Intuition\\nThe task is to find the sign of the product of the elements in the array `nums`. The initial idea is to iterate through each element of the array and determine the sign of the final product based on the properties of the signs of the numbers.\\n\\n# Approach\\nWe can use a single loop to solve this problem. In the loop, we go through each element of the array. If the current element is equal to zero, we immediately return 0, as the product will be zero. If the current element is less than zero, we increment the counter of negative numbers (`result`). After going through the loop, if the number of negative numbers is odd, we return -1; otherwise, we return 1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the number of elements in the array `nums`. The time complexity is linear since we iterate through each element of the array.\\n\\n- Space complexity: $$O(1)$$, as we only use a constant amount of additional space for storing the result and loop variables.\\n\\n\\n# Code\\n```\\nfunc arraySign(nums []int) int {\\n    var result int\\n    for i:=0;i<len(nums);i++{\\n        if  nums[i]==0{\\n            return 0\\n        }\\n        if nums[i]<0{\\n            result++\\n        }\\n    }\\n    if result%2!=0{\\n        return -1\\n    }    \\n    return 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc arraySign(nums []int) int {\\n    var result int\\n    for i:=0;i<len(nums);i++{\\n        if  nums[i]==0{\\n            return 0\\n        }\\n        if nums[i]<0{\\n            result++\\n        }\\n    }\\n    if result%2!=0{\\n        return -1\\n    }    \\n    return 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476913,
                "title": "javascript-simple-and-neat-solution-in-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    return nums.reduce((res, value)=>{ return value <= 0 ? value == 0 ? 0 : -res : res;}, 1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    return nums.reduce((res, value)=>{ return value <= 0 ? value == 0 ? 0 : -res : res;}, 1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476587,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for(auto x: nums) {\\n            if(x < 0) ans *= -1;\\n            else if(x > 0) ans *= 1;\\n            else ans *= 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int ans = 1;\\n        for(auto x: nums) {\\n            if(x < 0) ans *= -1;\\n            else if(x > 0) ans *= 1;\\n            else ans *= 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476428,
                "title": "simple-solution-in-java-cpp-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force approach will be to multiply all numbers and then see whether product is 0, positive or negative.\\n\\n__BUT__ on a closer inspection it can be seen that the numbers that affect the naswer are the ones that are less than equal to 0, Positive number don\\'t change the sign of the product\\n> -4 * 2 = -8.\\n0 * 2 = 0\\n4 * 2 = 8\\n__Whatever sign of the first term was, is continued when multiplied with a positive number, hence we dont really need to know how many positives do we have in the array.__\\n\\n__Two observations are needed to solve this question__\\n\\n>__1)__ If an element in the array is 0, product will be 0, no need   to multiply anything anymore, that how powerful 0 is here!!\\n__2)__ If the number of negative integers in the array, the answer be negative, else positive\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1) Traverse the array/vector\\n>2) Check if the element is 0 or not\\n>> If the element is 0, the answer or product will stay 0, no matter what is multiplied to it now, therefore return 0\\n\\n>3) Check if the number is negative\\n>>If the number is negative track the frequency of the negative numbers\\nElse Continue\\n\\n>4) If in Nothing has been return so far, check if the frequency of the negatives is odd \\n>> If, yes : return -1\\nElse Return 1\\n\\n# Complexity\\n- Time complexity $$O(n) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```java []\\nclass Solution {\\n    public int arraySign(int[] nums) \\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if ((negatives & 1) == 1)\\n            return -1;\\n        return 1;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution\\n{\\npublic:\\n    int arraySign(vector<int> &nums)\\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if (negatives & 1)\\n            return -1;\\n        return 1;\\n    }\\n};\\n```\\n__Do Upvote, If it Helped :)__\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int arraySign(int[] nums) \\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if ((negatives & 1) == 1)\\n            return -1;\\n        return 1;\\n    }\\n}\\n```\n```cpp []\\nclass Solution\\n{\\npublic:\\n    int arraySign(vector<int> &nums)\\n    {\\n        int negatives = 0;\\n        for (int number : nums)\\n            if (number < 0)\\n                negatives++;\\n            else if (number == 0)\\n                return 0;\\n        if (negatives & 1)\\n            return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476342,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=0;\\n        for(int i=0;i<nums.size();i++)\\n          if(nums[i]==0)\\n              return 0;\\n           else if(nums[i]<0)\\n               n++;\\n       if(n%2==1)\\n          return -1;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n=0;\\n        for(int i=0;i<nums.size();i++)\\n          if(nums[i]==0)\\n              return 0;\\n           else if(nums[i]<0)\\n               n++;\\n       if(n%2==1)\\n          return -1;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476194,
                "title": "easy-c-solution",
                "content": "# Intuition\\n\\n- If there are even negative numbers in the array then the result always be a positive number.\\n\\n- If there are odd negative numbers in the array then the result always be a negative number.\\n\\n# Approach\\n\\nIterate over an array and count the number of negative integers in the entire array. Check a base condition If there is any zero return answer as zero.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int neg = 0;\\n        \\n        foreach(var num in nums)\\n        {\\n            if(num == 0) return 0;\\n\\n            if(num < 0) neg++;\\n        }        \\n\\n        return (neg%2 == 0) ? 1 : -1;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int neg = 0;\\n        \\n        foreach(var num in nums)\\n        {\\n            if(num == 0) return 0;\\n\\n            if(num < 0) neg++;\\n        }        \\n\\n        return (neg%2 == 0) ? 1 : -1;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476142,
                "title": "java-code",
                "content": "# Intuition\\nBy seeing question we can  easily understand that we have to just multiply all elsement of index.\\n\\n# Approach\\njust brute force and efficient approch\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int m=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                m=m*1;\\n            }else if(nums[i]<0){\\n                m*=-1;\\n            }else{\\n                m*=0;\\n            }\\n        }\\n        if(m>0){\\n            return 1;\\n        }else if(m==0){\\n             return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int m=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]>0){\\n                m=m*1;\\n            }else if(nums[i]<0){\\n                m*=-1;\\n            }else{\\n                m*=0;\\n            }\\n        }\\n        if(m>0){\\n            return 1;\\n        }else if(m==0){\\n             return 0;\\n        }else{\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475997,
                "title": "c-easy-solution-for-easy-problem",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        if(count(nums.begin(),nums.end(),0)){\\n            return 0;\\n        }\\n        int neg=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto x:nums){\\n            if(x<0){\\n                neg++;\\n            }\\n            if(x>=0){\\n                break;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        if(count(nums.begin(),nums.end(),0)){\\n            return 0;\\n        }\\n        int neg=0;\\n        sort(nums.begin(),nums.end());\\n        for(auto x:nums){\\n            if(x<0){\\n                neg++;\\n            }\\n            if(x>=0){\\n                break;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        else{\\n            return 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475743,
                "title": "typescript-one-liner",
                "content": "# Intuition\\nInitial thoughts were to approach as described: find the product and validate. \\n\\n# Approach\\nRealised after writing a solution with initial thoughts that could actually be simplified by checking/validating based on context resulting in expected products. E.g. if `0` exists then product will always be `0` or if there\\'s an odd number of negative integers then it\\'ll alaways end up at 0.\\n\\nAfter running a basic comparison of the two approaches it appeared that checking the underlying contexts was faster on larger arrays than using a reducer to find the product. After this I simplified the function down to a one liner.\\n\\n# Code\\n```\\nfunction arraySign(nums: number[]): number {\\n    return nums.includes(0) ? 0 : !!(nums.filter((n) => n < 0).length % 2) ? -1 : 1;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction arraySign(nums: number[]): number {\\n    return nums.includes(0) ? 0 : !!(nums.filter((n) => n < 0).length % 2) ? -1 : 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475646,
                "title": "solution-with-simple-foreach-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    var result = 1;\\n    nums.forEach(element => {\\n        result *= element;\\n    });\\n    return (result > 0)?1:(result < 0)?-1:0;\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    var result = 1;\\n    nums.forEach(element => {\\n        result *= element;\\n    });\\n    return (result > 0)?1:(result < 0)?-1:0;\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3475494,
                "title": "super-easy-code-for-this-super-easy-problem",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i]>0) p = p*1;\\n\\n            else if(nums[i]<0) p = p*-1;\\n\\n            else p = p*0;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p = 1;\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            if(nums[i]>0) p = p*1;\\n\\n            else if(nums[i]<0) p = p*-1;\\n\\n            else p = p*0;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475435,
                "title": "numpy-one-liner",
                "content": "# Approach\\nDid you know you could use numpy on LeetCode? I didn\\'t.\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        return np.prod(np.sign(nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        return np.prod(np.sign(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475429,
                "title": "java-xor-shift-100-fast",
                "content": "# Intuition\\nOnly the sign bit matter.\\n\\n# Approach\\n- 2 negative sign bit cancel each other using xor.\\n- Early exit on `0`.\\n- Drag the sign bit over the whole int and set last bit.\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n- Space complexity: *`O(1)`*\\n\\n# Code\\n```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327954,
                "title": "java-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negative_counter = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            if (nums[i] < 0){\\n                negative_counter++;\\n            }\\n            if (nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if (negative_counter % 2 != 0){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int negative_counter = 0;\\n        for (int i = 0; i < nums.length; i++){\\n            if (nums[i] < 0){\\n                negative_counter++;\\n            }\\n            if (nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if (negative_counter % 2 != 0){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210258,
                "title": "scala-oneliner",
                "content": "# Code\\n```\\nobject Solution {\\n  def arraySign(nums: Array[Int]): Int = nums.map(_.sign).reduce(_ * _)\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def arraySign(nums: Array[Int]): Int = nums.map(_.sign).reduce(_ * _)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3193644,
                "title": "simple-c-solution-count-number-of-minus-numbers-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this problem you simply need to count the number of minus numbers in the array. If the number of minuses is odd, the result will be negative (-1 * 1 = -1), otherwise it will be positive (-1 * -1 = 1). Also if you ever see a zero, return 0 as anything multiplied by zero is zero..\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int minuses = 0;\\n\\n        foreach(int i in nums)\\n        {\\n            if(i == 0) return 0;\\n            if(i < 0) minuses++;\\n        }     \\n\\n        return minuses % 2 == 0 ? 1 :-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ArraySign(int[] nums) {\\n        int minuses = 0;\\n\\n        foreach(int i in nums)\\n        {\\n            if(i == 0) return 0;\\n            if(i < 0) minuses++;\\n        }     \\n\\n        return minuses % 2 == 0 ? 1 :-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183410,
                "title": "simple-and-easy-to-understand-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p=1;\\n        for(auto i: nums){\\n            if(i>0){\\n                p=p* 1;\\n            }else if(i<0){\\n                p=p*-1;\\n            }else{\\n                p=p*0;\\n            } \\n        }\\n        if(p>0){\\n            return 1;\\n        }else if(p<0){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n```\\n\\nIf you like the code implementation, make sure to upvote :) \\u270C\\nKeep Coding.....\\nKeep chilling...",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int p=1;\\n        for(auto i: nums){\\n            if(i>0){\\n                p=p* 1;\\n            }else if(i<0){\\n                p=p*-1;\\n            }else{\\n                p=p*0;\\n            } \\n        }\\n        if(p>0){\\n            return 1;\\n        }else if(p<0){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149267,
                "title": "c-easiest-soln",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)    , N= array size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int c=1,d=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                c=0;\\n                break;\\n            }\\n            else if(nums[i]<0)\\n                d++;\\n        }\\n        if(c==0)\\n            return 0;\\n        if(d%2==1 && c==1)\\n            return -1;\\n    return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int c=1,d=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==0){\\n                c=0;\\n                break;\\n            }\\n            else if(nums[i]<0)\\n                d++;\\n        }\\n        if(c==0)\\n            return 0;\\n        if(d%2==1 && c==1)\\n            return -1;\\n    return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086440,
                "title": "easy-basic-solution-brute-force-using-loops-only",
                "content": "# Intuition\\nJust count number of negative numbers in the array, if count is even then return 1 else -1.\\nand also if one of the number in the array is zero then product will also be zero.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0) cnt++;\\n            else if(nums[i]==0) return 0;\\n        }\\n\\n        if(cnt%2==0) return 1;\\n        return -1;\\n    }\\n};\\n\\n\\n**// please like and upvote . If you like the approach.**\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]<0) cnt++;\\n            else if(nums[i]==0) return 0;\\n        }\\n\\n        if(cnt%2==0) return 1;\\n        return -1;\\n    }\\n};\\n\\n\\n**// please like and upvote . If you like the approach.**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026709,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def arraySign(nums: Array[Int]): Int = {\\n        nums.collect {\\n            case i if i<0 => -1\\n            case i if i>0 => 1\\n            case _ => 0\\n        }.product\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def arraySign(nums: Array[Int]): Int = {\\n        nums.collect {\\n            case i if i<0 => -1\\n            case i if i>0 => 1\\n            case _ => 0\\n        }.product\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2924655,
                "title": "compact-and-fast-beats-100",
                "content": "# Approach\\nChanging bool value while encountering any negetive value and just returning 0 when encountering any 0 in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean p=false;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0)\\n            return 0;\\n            p = (nums[i]<0)?((p)?false:true):p;\\n        }\\n        return (p)?-1:1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean p=false;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0)\\n            return 0;\\n            p = (nums[i]<0)?((p)?false:true):p;\\n        }\\n        return (p)?-1:1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842760,
                "title": "easy-simple-short-c-solution",
                "content": "```\\nint n = 0;\\n        for(int i = 0; i<nums.size();i++){\\n           \\n             if(nums[i]<0){\\n                n++;\\n            }\\n            else if(nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if(n%2 == 0){\\n            return 1;\\n        }\\n       \\n      return -1;",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nint n = 0;\\n        for(int i = 0; i<nums.size();i++){\\n           \\n             if(nums[i]<0){\\n                n++;\\n            }\\n            else if(nums[i] == 0){\\n                return 0;\\n            }\\n        }\\n        if(n%2 == 0){\\n            return 1;\\n        }\\n       \\n      return -1;",
                "codeTag": "Unknown"
            },
            {
                "id": 2823195,
                "title": "java-o-n-simple-sign-of-the-product-of-an-array",
                "content": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        Arrays.sort(nums);\\n        int neg=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)return 0;\\n            else if(i<0)neg++;\\n            else break;\\n        }\\n        return neg%2==0?1:-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        Arrays.sort(nums);\\n        int neg=0;\\n        for(int i:nums)\\n        {\\n            if(i==0)return 0;\\n            else if(i<0)neg++;\\n            else break;\\n        }\\n        return neg%2==0?1:-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772511,
                "title": "java-o-n-in-just-0-ms",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean isPositive = true;\\n        for (int n : nums) {\\n            if (n == 0) return 0;\\n            if (n < 0) isPositive = !isPositive;\\n        }\\n        return isPositive ? 1 : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        boolean isPositive = true;\\n        for (int n : nums) {\\n            if (n == 0) return 0;\\n            if (n < 0) isPositive = !isPositive;\\n        }\\n        return isPositive ? 1 : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767166,
                "title": "very-easy-solution-to-understand-in-python3-faster-than-99",
                "content": "```\\n        x=1\\n        for i in nums:\\n            x*=i\\n        if x==0:return 0\\n        elif x>0:return 1\\n        else:return -1\\n        \\n```\\n![image](https://assets.leetcode.com/users/images/eb8c431b-a56d-46dc-91a1-53b8ee387f77_1667314069.145179.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        x=1\\n        for i in nums:\\n            x*=i\\n        if x==0:return 0\\n        elif x>0:return 1\\n        else:return -1\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2749204,
                "title": "golang-solution-easy-understand",
                "content": "```\\n// 1822. Sign of the Product of an Array\\n// 1822. \\u6570\\u7EC4\\u5143\\u7D20\\u79EF\\u7684\\u7B26\\u53F7\\n// \\u601D\\u8DEF\\uFF1A\\u8D1F\\u8D1F\\u5F97\\u6B63\\n// time O(n) space O(1)\\nfunc arraySign(nums []int) int {\\n\\tans := 1\\n\\tfor _, num := range nums {\\n\\t\\tif num == 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif num < 0 {\\n\\t\\t\\tans = -ans\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// 1822. Sign of the Product of an Array\\n// 1822. \\u6570\\u7EC4\\u5143\\u7D20\\u79EF\\u7684\\u7B26\\u53F7\\n// \\u601D\\u8DEF\\uFF1A\\u8D1F\\u8D1F\\u5F97\\u6B63\\n// time O(n) space O(1)\\nfunc arraySign(nums []int) int {\\n\\tans := 1\\n\\tfor _, num := range nums {\\n\\t\\tif num == 0 {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tif num < 0 {\\n\\t\\t\\tans = -ans\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2656027,
                "title": "c-easy-solution-beginner-friendly",
                "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int len = nums.size();\\n        int count = 1;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                return 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count = -count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) \\n    {\\n        int len = nums.size();\\n        int count = 1;\\n        \\n        for(int i = 0; i < len; i++)\\n        {\\n            if(nums[i] == 0)\\n            {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2613866,
                "title": "python-simple-solution",
                "content": "```\\n# It is not neccesary to find the product of array. We only need the number of negatives in nums\\n# If number of negatives is odd result will be -1 else 1\\n# If there is one 0 result will be 0\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg = 0\\n        for x in nums:\\n            if x < 0:\\n                neg += 1\\n            elif x == 0:\\n                return 0\\n        if neg % 2 == 1:\\n            return -1\\n        return 1\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\n# It is not neccesary to find the product of array. We only need the number of negatives in nums\\n# If number of negatives is odd result will be -1 else 1\\n# If there is one 0 result will be 0\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        neg = 0\\n        for x in nums:\\n            if x < 0:\\n                neg += 1\\n            elif x == 0:\\n                return 0\\n        if neg % 2 == 1:\\n            return -1\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593029,
                "title": "with-explanation-comments-time-5-ms-83-42-space-10-3-mb-43-03",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        //to avoid overflow, we\\'ll not use the method where product all array values & then check coditions\\n        \\n        //initialize a sign variable \\n        int sign=1;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            //check if there\\'s any 0-> product=0 & return 0\\n            if(num==0)\\n                return 0;\\n            //check if there\\'s negative value-> product will be negative-> return -1\\n            if(num<0)\\n                sign*=-1;\\n        }\\n        \\n        //if all are positive | there\\'re even number of negative values-> positive & return 1\\n        return sign;\\n    }\\n\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        \\n        //to avoid overflow, we\\'ll not use the method where product all array values & then check coditions\\n        \\n        //initialize a sign variable \\n        int sign=1;\\n        \\n        //loop over the whole array elements\\n        for(int num:nums){\\n            //check if there\\'s any 0-> product=0 & return 0\\n            if(num==0)\\n                return 0;\\n            //check if there\\'s negative value-> product will be negative-> return -1\\n            if(num<0)\\n                sign*=-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2578810,
                "title": "python3-optimized-solution",
                "content": "![image](https://assets.leetcode.com/users/images/a6785442-0746-4fdb-9d2b-762ad6c565d5_1663232354.791573.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        count_negative = 0\\n        for ele in nums:\\n            if ele<0:\\n                count_negative+=1\\n            elif ele==0:\\n                return 0\\n        if count_negative&1:\\n            return -1\\n        return 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        count_negative = 0\\n        for ele in nums:\\n            if ele<0:\\n                count_negative+=1\\n            elif ele==0:\\n                return 0\\n        if count_negative&1:\\n            return -1\\n        return 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567281,
                "title": "easiest-solution-o-n-time-faster-than-100",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int> &nums) {\\n        int neg = 0;\\n        for (int &num : nums) {\\n            if (num == 0) return 0;\\n            else if (num < 0) neg++;\\n        }\\n        return (neg % 2) ? -1 : 1;\\n    }\\n};\\n```\\n\\nPlease do upvote and share : )",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int arraySign(vector<int> &nums) {\\n        int neg = 0;\\n        for (int &num : nums) {\\n            if (num == 0) return 0;\\n            else if (num < 0) neg++;\\n        }\\n        return (neg % 2) ? -1 : 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397096,
                "title": "javascript-easy-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    let sign = true;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == 0) return 0;\\n        if(nums[i] < 0) sign = !sign;\\n    }    \\n    return sign ? 1 : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    let sign = true;\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == 0) return 0;\\n        if(nums[i] < 0) sign = !sign;\\n    }    \\n    return sign ? 1 : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2351669,
                "title": "java-0ms-solution",
                "content": "```class Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }else if(nums[i]>0){\\n                pos++;\\n            }else{\\n                return 0;\\n            }\\n        }\\n        if(neg%2==1){\\n            return -1;\\n        }\\n        return 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int arraySign(int[] nums) {\\n        int neg = 0;\\n        int pos = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<0){\\n                neg++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2276614,
                "title": "javascript-fast-without-calculating-the-actual-product",
                "content": "Check elements of array.  Product sign is influenced by 0 and number of negative numbers.\\nIf the arr contains 0, return 0.\\n\\nAdvantages: When array is very large product will reach Infinite value. Infinite*0 = NaN\\n\\nWe could just return sign directly, but in problem description was mentioned the use of ```signFunc```\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let sign = 1;\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        if (nums[i] === 0) {\\n            sign = 0;\\n            break;\\n        }\\n        \\n        if (nums[i] < 0) \\n            sign = -sign;\\n    }\\n    \\n    return signFunc(sign);\\n};\\n\\nfunction signFunc(x) {\\n    if (x === 0)\\n        return 0;\\n    \\n    return x > 0 ? 1: -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```signFunc```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar arraySign = function(nums) {\\n    let sign = 1;\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        if (nums[i] === 0) {\\n            sign = 0;\\n            break;\\n        }\\n        \\n        if (nums[i] < 0) \\n            sign = -sign;\\n    }\\n    \\n    return signFunc(sign);\\n};\\n\\nfunction signFunc(x) {\\n    if (x === 0)\\n        return 0;\\n    \\n    return x > 0 ? 1: -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228229,
                "title": "javascript-solution",
                "content": "```\\nvar arraySign = function(nums) {\\n    var product = 1;\\n    for (var i=0;i<nums.length;i++) {\\n        product = product * nums[i];\\n    }\\n\\n    console.log(product);\\n\\n    if (isNaN(product)) {\\n        return 0;\\n    }\\n    \\n    if (product == 0) {\\n        return 0;\\n    } else if (product < 0) {\\n        return -1;\\n    } else {\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar arraySign = function(nums) {\\n    var product = 1;\\n    for (var i=0;i<nums.length;i++) {\\n        product = product * nums[i];\\n    }\\n\\n    console.log(product);\\n\\n    if (isNaN(product)) {\\n        return 0;\\n    }\\n    \\n    if (product == 0) {\\n        return 0;\\n    } else if (product < 0) {\\n        return -1;\\n    } else {\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224321,
                "title": "simple-fast-javascript-solution",
                "content": "```\\nfunction arraySign(nums) {\\n    let numbers = [];\\n    for (i of nums) {\\n        if (i < 0) numbers.push(-1)\\n        else if (i > 0) numbers.push(1)\\n        else numbers.push(0)\\n    }\\n    var product = 1\\n    for (i of numbers) product *= i\\n    if (product > 0) return 1\\n    else if (product < 0) return -1\\n    else return 0\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction arraySign(nums) {\\n    let numbers = [];\\n    for (i of nums) {\\n        if (i < 0) numbers.push(-1)\\n        else if (i > 0) numbers.push(1)\\n        else numbers.push(0)\\n    }\\n    var product = 1\\n    for (i of numbers) product *= i\\n    if (product > 0) return 1\\n    else if (product < 0) return -1\\n    else return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2157800,
                "title": "accepted-100-faster-with-0ms-run-time",
                "content": "When we read the question the first intuitive approach comes to our mind is that we calculate product of each number in array and then if product is less then 0 then print -1 and if product is greater than 0 then 1 and 0 otherwise.\\n**Problem with intuitive Approach:** The biggest problem that comes is the length of integer. Due to cyclic property of datatypes if the value goes out of bound it tries to bring it in the range of integer and if we use long int then its ;\\nTime Complexity: O(n)\\nSpace Complexity: long will take more space than int.\\n\\n**Optimal Approach: **\\n\\nWe know that in multiplication if a single zero is present then ans will be zero and if number of negative is even then by the rule ***negative  negative = positive*** we will get positive answer.\\nSo simply calculate number of negative numbers in nums array, if they are even ans is positive else negative and simultaneously check if a single zero is present return 0.**\\n\\nJava Code:-\\n\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count_negative=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n                count_negative++;\\n            if(nums[i]==0)\\n                return 0;\\n        }\\n       if(count_negative%2==0)\\n           return 1;\\n        else return -1;\\n    }\\n}\\n```\\n**Do upvote if you liked the approach and comment if you have any query.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int count_negative=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]<0)\\n                count_negative++;\\n            if(nums[i]==0)\\n                return 0;\\n        }\\n       if(count_negative%2==0)\\n           return 1;\\n        else return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053925,
                "title": "python-fast-and-easy-solution-with-comments-faster-than-98-92",
                "content": "Fast abd Easy solution for Python .\\n\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        product = 1\\n\\t\\t# Return zero if 0 exist in the array\\n        if 0 in nums:\\n            return 0\\n\\t\\t# We do not need to actually calculate the product but simply the end goal is to find the sign of the resultant product\\n\\t\\t# Using 1 and -1 as our flag has less computational effort on the system.\\n\\t\\t# Odd negatives result in Negative result . Even negatives result in Positive result.\\n        \\n\\t\\tfor num in nums:\\n            if num < 0:\\n                product = product * -1\\n        \\n        return product\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        product = 1\\n\\t\\t# Return zero if 0 exist in the array\\n        if 0 in nums:\\n            return 0\\n\\t\\t# We do not need to actually calculate the product but simply the end goal is to find the sign of the resultant product\\n\\t\\t# Using 1 and -1 as our flag has less computational effort on the system.\\n\\t\\t# Odd negatives result in Negative result . Even negatives result in Positive result.\\n        \\n\\t\\tfor num in nums:\\n            if num < 0:\\n                product = product * -1\\n        \\n        return product\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937467,
                "title": "c-solution-easy-to-understand",
                "content": "We don\\'t need to calculate the whole product of the elements of the given vector..\\nWe\\'ll simply initialise a int variable \"prod\" with a value = 1;\\nThen we will simply form a for loop to iterate over all the elements of the vector;\\nNow, we have 3 cases:\\n1) We\\'ll simply return 0 if any of the elements is found to be 0..\\n2) We\\'ll multiply -1 to the prod if the element is < 0..\\n3) We\\'ll keep the value of the prod intact if the element is > 0..\\n \\nPlease upvote the solution if you find this helpful....\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int prod = 1;\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(nums[i] == 0) return 0;\\n            else if(nums[i] < 0) prod *= -1;\\n            else continue;\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int n = nums.size();\\n        int prod = 1;\\n        for(int i = 0;i < n;i++)\\n        {\\n            if(nums[i] == 0) return 0;\\n            else if(nums[i] < 0) prod *= -1;\\n            else continue;\\n        }\\n        return prod;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926125,
                "title": "beginner-friendly-python-solution",
                "content": "```\\nTime Complexity : O(n)\\n```\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        mul = 1\\n        for num in nums:\\n            if num == 0:\\n                return 0\\n            mul *= num\\n        return 1 if mul > 0 else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nTime Complexity : O(n)\\n```\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        mul = 1\\n        for num in nums:\\n            if num == 0:\\n                return 0\\n            mul *= num\\n        return 1 if mul > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902604,
                "title": "c-short-code-with-simple-logic",
                "content": "Simply change the sign of the variable sign when encountered with a negative number. **Return 0** if get 0 as an element because the product will be going to be zero.\\n\\n```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign=1;\\n        for(int i:nums) {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n};\\n```\\n\\nTime Complexity: **O(N)** where N is the size of array.",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int sign=1;\\n        for(int i:nums) {\\n            if(i==0)\\n                return 0;\\n            if(i<0)\\n                sign*=-1;\\n        }\\n        return sign;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846503,
                "title": "c-4-solutions-advanced-techniques-linq-expression-matching-switch-clamping",
                "content": "**Solution 1:**\\nLINQ 2 lines\\n```\\npublic int ArraySign(int[] nums) {\\n\\tint result = nums.Aggregate((a,b) => (a*b) == 0 ? 0 : (a*b)/Math.Abs(a*b));\\n\\treturn result == 0 ? 0 : result / Math.Abs(result);\\n}\\n```\\n\\n----------\\n\\n**Solution 2:**\\nLINQ 1 Line\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\treturn Math.Clamp(nums.Aggregate((a, b) => (Math.Clamp(a, -1, 1) * Math.Clamp(b, -1, 1))), -1, 1);\\n}\\n```\\n\\n\\n---- \\n\\n**Solution 3:**\\nSwitch Expression Matching With Relational Operators\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint result = 1;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tresult *= n switch\\n\\t\\t{\\n\\t\\t\\t> 0         => 1,\\n\\t\\t\\t0           => 0,\\n\\t\\t\\t< 0         => -1,\\n\\t\\t};\\n\\t\\tif (result == 0)\\n\\t\\t\\treturn 0;\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\n--------\\n\\n**Solution 4:**\\nOnly count negatives\\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint negCt = 0;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tif (n == 0) return 0;\\n\\t\\tif (n < 0) negCt++;\\n\\t}\\n\\treturn negCt % 2 == 0 ? 1 : -1;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int ArraySign(int[] nums) {\\n\\tint result = nums.Aggregate((a,b) => (a*b) == 0 ? 0 : (a*b)/Math.Abs(a*b));\\n\\treturn result == 0 ? 0 : result / Math.Abs(result);\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\treturn Math.Clamp(nums.Aggregate((a, b) => (Math.Clamp(a, -1, 1) * Math.Clamp(b, -1, 1))), -1, 1);\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint result = 1;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tresult *= n switch\\n\\t\\t{\\n\\t\\t\\t> 0         => 1,\\n\\t\\t\\t0           => 0,\\n\\t\\t\\t< 0         => -1,\\n\\t\\t};\\n\\t\\tif (result == 0)\\n\\t\\t\\treturn 0;\\n\\t}\\n\\treturn result;\\n}\\n```\n```\\npublic int ArraySign(int[] nums)\\n{\\n\\tint negCt = 0;\\n\\tforeach (int n in nums)\\n\\t{\\n\\t\\tif (n == 0) return 0;\\n\\t\\tif (n < 0) negCt++;\\n\\t}\\n\\treturn negCt % 2 == 0 ? 1 : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815568,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic int ArraySign(int[] nums) => nums.Aggregate(1, (a, c) => a * c.CompareTo(0));\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int ArraySign(int[] nums) => nums.Aggregate(1, (a, c) => a * c.CompareTo(0));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809773,
                "title": "easytounderstand-fast-0ms-without-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int t=1;\\n        for(auto i:nums)\\n            if(i==0)\\n                return 0;\\n            else if(i<0)\\n                t=(t<0?1:-1);\\n          \\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n        int t=1;\\n        for(auto i:nums)\\n            if(i==0)\\n                return 0;\\n            else if(i<0)\\n                t=(t<0?1:-1);\\n          \\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808101,
                "title": "easy-simple-java-solution",
                "content": "1. negative * negative = positive\\n2. negative * positive = negative\\n\\n* We count the total number of negative numbers. If the count is even then product will turn positive else negative.\\n\\n```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n\\n        int count = 0;\\n        for(int num: nums){\\n            if(num == 0) return 0;\\n            count += (num < 0)? 1: 0;\\n        }\\n        \\n        return (count%2 == 0)? 1: -1;\\n    }\\n}\\n```\\n\\nplease upvote if you think this is simple and easy to understand. Thanks :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n\\n        int count = 0;\\n        for(int num: nums){\\n            if(num == 0) return 0;\\n            count += (num < 0)? 1: 0;\\n        }\\n        \\n        return (count%2 == 0)? 1: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806477,
                "title": "c-simple-approach-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int n = nums.size() ;\\n      int ans = 1 ;\\n       \\n      for(int i : nums){\\n          if(i == 0) return 0 ;\\n          else if(i < 0) ans = ans * -1 ;\\n      }\\n      return ans > 0 ? 1 : -1 ;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int n = nums.size() ;\\n      int ans = 1 ;\\n       \\n      for(int i : nums){\\n          if(i == 0) return 0 ;\\n          else if(i < 0) ans = ans * -1 ;\\n      }\\n      return ans > 0 ? 1 : -1 ;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676196,
                "title": "java-most-concise-o-n-time-o-1-space-solution",
                "content": "I am seeing a lot of solutions using `int` to store the product, or `int` to keep track of the sign by performing multiplication. \\n\\nThere is a much more concise way -- use a `bool`. Start with a boolean `sign` set to `false`. When we come across a number that is negative, negate `sign`. Once we\\'ve passed through every element of the array, just check if `sign` is `true`. If it is, return `-1`, else return `1`. \\n\\nOh, also, we know that any number multiplied by `0` is just going to be `0`, so if at any point we encounter a `0` in our traversal, we can just return `0` right away and be done. \\n\\n```\\nclass Solution {\\n    \\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n    public int arraySign(int[] nums) {\\n        \\n        boolean sign = false; \\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) // If any number is 0, return 0, right away. \\n                return 0; \\n            if(nums[i] < 0)\\n                sign = !sign; \\n        }\\n        \\n        return (sign) ? -1 : 1; \\n            \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Time complexity: O(N)\\n    // Space complexity: O(1)\\n    public int arraySign(int[] nums) {\\n        \\n        boolean sign = false; \\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) // If any number is 0, return 0, right away. \\n                return 0; \\n            if(nums[i] < 0)\\n                sign = !sign; \\n        }\\n        \\n        return (sign) ? -1 : 1; \\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649505,
                "title": "javascript-typescript-easy-100",
                "content": "```\\nconst arraySign = (nums: number[]): number => {\\n  // edgeCase\\n  if(nums.includes(0)) {\\n    return 0;\\n  };\\n  \\n  // count of negative\\n  let count: number = 0;\\n  nums.forEach(num => num < 0 && count++);\\n  \\n  // if count is odd, return 1, else return -1\\n  return count % 2 ? -1 : 1;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/0a5ecfa9-a724-4b12-9a03-8fcab9a3ed5e_1640571384.0467677.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst arraySign = (nums: number[]): number => {\\n  // edgeCase\\n  if(nums.includes(0)) {\\n    return 0;\\n  };\\n  \\n  // count of negative\\n  let count: number = 0;\\n  nums.forEach(num => num < 0 && count++);\\n  \\n  // if count is odd, return 1, else return -1\\n  return count % 2 ? -1 : 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585927,
                "title": "c-90-faster",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool check(vector<int> &nums)\\n    {\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int arraySign(vector<int> &nums)\\n    {\\n        int multi = 1;\\n        if (check(nums))\\n            return 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] >= 1)\\n            {\\n                nums[i] = 1;\\n            }\\n            else\\n            {\\n                nums[i] = -1;\\n            }\\n            multi *= nums[i];\\n        }\\n        return (multi >= 1) ? 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool check(vector<int> &nums)\\n    {\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] == 0)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int arraySign(vector<int> &nums)\\n    {\\n        int multi = 1;\\n        if (check(nums))\\n            return 0;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] >= 1)\\n            {\\n                nums[i] = 1;\\n            }\\n            else\\n            {\\n                nums[i] = -1;\\n            }\\n            multi *= nums[i];\\n        }\\n        return (multi >= 1) ? 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541342,
                "title": "easy-java-solution",
                "content": "```\\n  int p=1;\\n        for(int i: nums){\\n            if(i==0) return 0;\\n            \\n            p *= i>0 ? 1 : -1;\\n           \\n        }\\n        \\n        return p;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  int p=1;\\n        for(int i: nums){\\n            if(i==0) return 0;\\n            \\n            p *= i>0 ? 1 : -1;\\n           \\n        }\\n        \\n        return p;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1424377,
                "title": "python-87-using-reduce-with-lambda-argument",
                "content": "I took this approach since I have a bit of a Javascript background. The reduce function returns 1 value after it completes the lambda operations.\\n\\nMake sure to import functools. \\n\\n```python\\nimport functools\\n\\nclass Solution:\\n    def signProduct(self, num) -> int:\\n        if num > 0:\\n            return 1\\n        elif num < 0:\\n            return -1\\n        elif num == 0:\\n            return 0\\n        \\n    def arraySign(self, nums: List[int]) -> int:\\n        product = functools.reduce(lambda a, b: a * b, nums)\\n        return self.signProduct(product)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nimport functools\\n\\nclass Solution:\\n    def signProduct(self, num) -> int:\\n        if num > 0:\\n            return 1\\n        elif num < 0:\\n            return -1\\n        elif num == 0:\\n            return 0\\n        \\n    def arraySign(self, nums: List[int]) -> int:\\n        product = functools.reduce(lambda a, b: a * b, nums)\\n        return self.signProduct(product)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363191,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun arraySign(nums: IntArray): Int {\\n        var sign = 1\\n        for (number in nums) {\\n            if (number == 0) return 0\\n            if (number<0) sign *= -1\\n        }\\n        return sign\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun arraySign(nums: IntArray): Int {\\n        var sign = 1\\n        for (number in nums) {\\n            if (number == 0) return 0\\n            if (number<0) sign *= -1\\n        }\\n        return sign\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250512,
                "title": "java-math-0ms-beats-100-t-c-o-n-s-c-o-1",
                "content": "\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, negative = 0;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            negative += (nums[i] < 0) ? 1 : 0;\\n        }\\n        \\n        return (negative % 2 == 0) ? 1 : -1;\\n        \\n    }\\n\\t\\n\\t\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, sign = 1;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            if(nums[i] < 0)\\n                sign = -sign;\\n        }\\n        \\n        return sign;\\n    }\\n\\n",
                "solutionTags": [],
                "code": "\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, negative = 0;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            negative += (nums[i] < 0) ? 1 : 0;\\n        }\\n        \\n        return (negative % 2 == 0) ? 1 : -1;\\n        \\n    }\\n\\t\\n\\t\\n    public int arraySign(int[] nums) {\\n        \\n        int len = nums.length, sign = 1;\\n        for(int i = 0; i < len; i++){\\n            \\n            if(nums[i] == 0)\\n                return 0;\\n            \\n            if(nums[i] < 0)\\n                sign = -sign;\\n        }\\n        \\n        return sign;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1197853,
                "title": "c-easy-concise-o-n-o-1",
                "content": "The sign depends upon weather the -ve\\'s are even (return 1) or odd(return -1).\\nIf you caught a zero it will give a product zero .Hence no need to traverse further , just return 0;\\n\\n```\\n int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]==0)return 0;\\n         if(nums[i]<0)count++;}\\n        if(count%2==0)return 1;\\n        return -1;\\n```",
                "solutionTags": [],
                "code": "```\\n int arraySign(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {if(nums[i]==0)return 0;\\n         if(nums[i]<0)count++;}\\n        if(count%2==0)return 1;\\n        return -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166799,
                "title": "python3-one-pass",
                "content": "Initialize a variable \"sign\" to be 1, and update it when passing every number if the list.\\n```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sign = 1\\n        for n in nums:\\n            if n > 0:\\n                continue\\n            elif n == 0:\\n                return 0\\n            else:\\n                sign = sign * (-1)\\n        return sign\\n```\\nPlease upvote if you find it helpful. Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def arraySign(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sign = 1\\n        for n in nums:\\n            if n > 0:\\n                continue\\n            elif n == 0:\\n                return 0\\n            else:\\n                sign = sign * (-1)\\n        return sign\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1845402,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879678,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1806781,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1720834,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1699694,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879888,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845409,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1787236,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1730316,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1957906,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845402,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879678,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1806781,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1720834,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1699694,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1879888,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1845409,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1787236,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1730316,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 1957906,
                "content": [
                    {
                        "username": "WallaWonka",
                        "content": "`error: cannot find \\'signFunc\\' in scope`\\n\\nThe description leads us to think there is an implemented `signFunc` but there isn\\'t. We have to write it for ourselves. Just don\\'t say \"there is a function\" where there isn\\'t. It is a simple function, we can write it, just don\\'t say it is already available."
                    },
                    {
                        "username": "workforprabhat1254",
                        "content": "[@Minatokun](/Minatokun)  me with broken perspective \\uD83D\\uDE42"
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@DontPeek_4538](/DontPeek_4538) yeah, but don\\'t say there is a function if there is not, it will mislead the reader to bias their solution to the existence of that function. "
                    },
                    {
                        "username": "Minatokun",
                        "content": "By the way i read, it felt to me that we are the once who has to write the signFunc(). So yeah its all about perspective."
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Exactly."
                    },
                    {
                        "username": "DontPeek_4538",
                        "content": "You don\\'t need signFunc implementation to solve this problem. "
                    },
                    {
                        "username": "alt909",
                        "content": "So easy it feels a little dirty."
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "true, if i see a question and go like, hmmm thats too easy my brain wont let me live guilt free especially if i solve something that i didnt spend more than 15 mins to do"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Calm before the storm!"
                    },
                    {
                        "username": "vnk01",
                        "content": "wait for weekend"
                    },
                    {
                        "username": "sweemeow",
                        "content": "hint 1 = You don\\'t need to multiply (think differently)\\nhint 2 = (return only the sign at each step)"
                    },
                    {
                        "username": "AbdulazizSayed",
                        "content": "My solution works fine in my machine but it fails 31 testcase and when I try the input in my machine it prints the expected output, Can anyone tell me why this happens?\\n31 Testcase:\\ninput: [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\noutput: 1\\nexpected: -1 (Which I got when trying it in locally)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "what\\'s the point of multiplying just check whether each number in array is less than zero and equal to zero. count the negative one use logic when multiplication becomes negative. Easy pzzy lemon squizy my friend! "
                    },
                    {
                        "username": "ayush1505",
                        "content": "Just find if their is 0 at any index, then answer will be 0.\\nOther than that count negative elements, if they are odd in count then answer will be -1.\\nOtherwise answer will be 1.\\nBecause in multiplying every element their can be overflow."
                    },
                    {
                        "username": "Jayesh_Ironside",
                        "content": "I tried the same testcase in my code it is working file. But the correct output will come as -1.\\n\\nTry using this code:-\\nclass Solution:\\n    def arraySign(self, nums: List[int]) -> int:\\n        product = 1\\n        for num in nums:\\n            product *= num\\n        \\n        if product > 0:\\n            return 1\\n        elif product < 0:\\n            return -1\\n        else:\\n            return 0"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Be careful with overflow."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "[@ynos062002](/ynos062002) Boolean is enough, no need to multiply at all."
                    },
                    {
                        "username": "deleted_user",
                        "content": "keep double instead of int or long \\nit is working for me"
                    },
                    {
                        "username": "akhilachepuri543",
                        "content": "Its really very simple "
                    },
                    {
                        "username": "Firebelias12",
                        "content": "Don\\'t brute force finding product. You don\\'t really need the product for the answer."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "Do not try to multiply all the numbers within the array without passing them though the signFunc before. It\\'s easier to multiply -1 with -1 and get 1 than multiply -12 with -20, get 240 and then return 1. Be careful with Integer overflow."
                    },
                    {
                        "username": "jwonz",
                        "content": "Don\\'t multiply numbers at all, just count number of negatives."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Don\\'t use the long  long int because the number after getting multiplied  it become huge number ,resulting in overflow ,instead of long int  use double \\uD83D\\uDE0E\\uD83D\\uDC4D."
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Kidding? Just use boolean and check if number is negative or 0. No need to multiply."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "This is normal way to find it run each and every Testcase : \\nI runed it on : [9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24]\\n                    : [41,65,14,80,20,10,55,58,24,56,28,86,96,10,3,84,4,41,13,32,42,43,83,78,82,70,15,-41]\\nthey successfully work. \\n\\nso, Here I did to find length and create a loop until n-1 \\nand I taken a variable with double datatype because Data can be huse after multiply.\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length; \\n         double pro = 1;\\n         for(int i=0; i<n; i++){\\n             pro *= nums[i];\\n         }\\n         if(pro>0){\\n             return 1;\\n         }\\n         else if(pro<0){\\n             return -1;\\n         }\\n         return 0;\\n    }\\n}"
                    },
                    {
                        "username": "eakesh_07",
                        "content": "Bro don\\'t multiply everything just check no. of elements that are negative  and check if no. of negative elements  in an array is even or odd then you can 1 or -1 and also check if the element is 0 then return 0 immediately"
                    },
                    {
                        "username": "ujjwal_kumar69",
                        "content": "thanks doubles save me"
                    },
                    {
                        "username": "SAIVARUN_GAJULA",
                        "content": "MICROSOFT loves this question (asked many times in online assessment)"
                    }
                ]
            },
            {
                "id": 2049095,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1671670,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1880393,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1746054,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 2072011,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 2045904,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1987192,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1977976,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1965940,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1917526,
                "content": [
                    {
                        "username": "Fifan",
                        "content": "I had difficulties with this problem, so here's a hint that probably can help:\n1. It was mentioned before by many people: you only need a sign, not the whole product.\n2. You need to check if the value in list is less than 0. \n3. Beware of zeros in list.\n\nPersonally I couldn't simplify this problem and overthought it. A lot. The solution is easy, and this task is good for training simplification. It also helps you restrain yourself from creating overly complex algorithms."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9Easy C++ O(N) Soln. [ FAANG\\uD83D\\uDE31 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/2773632/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "harshopes",
                        "content": "Use Double "
                    },
                    {
                        "username": "SDEGoogle",
                        "content": "class Solution {\\npublic:\\n    int arraySign(vector<int>& nums) {\\n      int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n        }\\n        //cout<<-1* -1;\\n        if(product<0){\\n            return -1;\\n        }\\n        else if(product>0){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\nHere, if I am mentioning int as data type then it is showing Signed Integer Overflow error so to avoid this if you mention double, the code works fine."
                    },
                    {
                        "username": "anushka-yadav",
                        "content": "it is a nice question for beginners as it make us to trigger our minds a little bit with the cases."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If nums contains a 0, return 0. \\nOtherwise if the number of negative integers is even, return 1.\\nIf its odd return -1."
                    },
                    {
                        "username": "buttoski44",
                        "content": "freaking stupid question...."
                    },
                    {
                        "username": "hafixah",
                        "content": "I tried using np.prod() here, but for one test case:\\n[9,72,34,29,-49,-22,-77,-17,-66,-75,-44,-30,-24], it gives a positive value rather than negative one, hence making the signFunc() wrong.\\n\\nAny idea why this is the case? "
                    },
                    {
                        "username": "INSHAYAQOOB",
                        "content": "what does the mean of product here ?"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "## No actual product computation is required at all :)\nWe only need to know if `0` is presented in `nums` and the number of negative number in `nums`."
                    }
                ]
            },
            {
                "id": 1912323,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1899081,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1884875,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1884366,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880420,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880271,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880234,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880200,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880174,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880129,
                "content": [
                    {
                        "username": "dactung93",
                        "content": "I complete the task on the first try but it seemed not perform well because both speed and memory ranked to very low position.\\nThen I adjust the code. The second time, speed went up to 95% and memory went to 73%.\\n\\nMethod 1\\n1, Sort the array\\n2, Using Binary Search to find index of 0\\n + If found then return 0\\n + if not found then do next\\n3, Foreach num in nums\\n + negativeNum ++ if num < 0\\n + if num > 0 then break;\\n4, if negativeNum % 2\\n + =1 then return -1\\n + =0 then return +1\\n\\nMethod 2\\n1, Using float x and set x = 1;\\n2, Foreach num in nums\\n + if num = 0 then return 0\\n + x *= num;\\n3, if x> 0 return 1 else return -1"
                    },
                    {
                        "username": "sainath81061",
                        "content": "double sum = 1;    \\n        for (int i =0;i<nums.Length;i++)\\n        {\\n            sum = sum * nums[i];\\n        }\\n        if(sum > 0)\\n        {\\n            return 1;\\n        }else if(sum <= -1)\\n        {\\n            return -1;\\n        }\\n        else\\n        {\\n            return 0;  \\n        }"
                    },
                    {
                        "username": "gnoblin_44",
                        "content": "Man, it took me a while but, I did complete it. \nFor anyone that struggled through this one, keep trying! You will get it!"
                    },
                    {
                        "username": "Mohammed_Raziullah_Ansari",
                        "content": "There are multiple ways to solve this problem:\\n\\nBrute force: We can simply traverse the array and multiply all the elements together. Then we check the sign of the result and return the corresponding value. However, this approach has a time complexity of O(n), where n is the length of the array, and it may result in integer overflow.\\n\\nUsing a counter: We can count the number of negative integers in the array. If the count is odd, the product is negative, otherwise, it is positive. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing the math library: We can use the math library in Python to find the sign of the product. The math library has a function called copysign(x, y) that returns x with the sign of y. We can calculate the product of all elements in the array and then use copysign to find the sign. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow.\\n\\nUsing bit manipulation: We can use bit manipulation to find the sign of the product. We can traverse the array and count the number of negative integers. If the count is odd, we return -1, otherwise, we return 1. This approach has a time complexity of O(n), where n is the length of the array, and it avoids the issue of integer overflow. However, it may not be as intuitive as the previous approaches."
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Low level problem .Isn\\'t it ?"
                    },
                    {
                        "username": "dasrupal",
                        "content": "Don\\'t multiply and store every element. (We only need sign of that element)."
                    },
                    {
                        "username": "harshdevs",
                        "content": "People here be giving advice on efficient way of finding the product but in reality, we don\\'t need the product for the answer!"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "leetcode going with the usual trend of monday -wednesday easy and hards on weekends"
                    },
                    {
                        "username": "niranjank2022",
                        "content": "This one is quite easy. "
                    },
                    {
                        "username": "ajay2305",
                        "content": " public int arraySign(int[] nums) {\\n        int product = 0;\\n        for(int num: nums){\\n            if(num==0)\\n            return 0;\\n            else{\\n                product*=num;\\n            }\\n        }\\n        return( product >= 1)  ? 1 : -1;\\n    }\\nwhy expected answer is 1 and my code returning -1"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Because u start with 0 and your product will not change, it should be\n int product=1; "
                    }
                ]
            },
            {
                "id": 1880125,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880124,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880122,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880110,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880098,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880046,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880028,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1880001,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879991,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879969,
                "content": [
                    {
                        "username": "Singh_uday99",
                        "content": "Very Simple "
                    },
                    {
                        "username": "eduard92",
                        "content": "Yep I got baited into doing a product of all numbers"
                    },
                    {
                        "username": "Yakub28",
                        "content": "Really easy, we do not need to multiply, just use 1 for positive number and -1 for negative, if you meet 0 just return it, there is no need to  go on."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDD35 I think this is just the waste of time."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "nah it increases ques solved "
                    },
                    {
                        "username": "Amar___",
                        "content": "I witnessed integer overflow worked with other but still in other cases i faced the same problem\\n"
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "Leetcode should have tag`Super Easy`to consider this type of question. "
                    },
                    {
                        "username": "utkarsh_v1901",
                        "content": "count the number of negative signs and lookout for 0"
                    },
                    {
                        "username": "bits_magma",
                        "content": "easy peasy lemon squeezy"
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "This is to give people the courage to face the hard of the day after tomorrow."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "calm before the storm \\n"
                    }
                ]
            },
            {
                "id": 1879940,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879922,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879878,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879873,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879864,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879861,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879853,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879851,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879820,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879806,
                "content": [
                    {
                        "username": "PratikPramanik",
                        "content": "hint :Just keep a count of the negative numbers and use that count to write your function"
                    },
                    {
                        "username": "im-naime",
                        "content": "When I see this kind of problem, my brain to me \"Let\\'s do it in one line\"! \\nEnjoy folks!"
                    },
                    {
                        "username": "sathwik_karne",
                        "content": "Starting this month with easy questions"
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Hint: Don\\'t multiply , Just Count"
                    },
                    {
                        "username": "Husoski",
                        "content": "I didn\\'t count the negative values.  Rather, I initialized a result variable to 1, then set \"result = -result;\" each time a negative array value was seen.  Obviously, any zero seen causes an immediate return of a zero result.  No multiplication needed and no need to convert a count to +/- 1."
                    },
                    {
                        "username": "sourabh4pvt",
                        "content": "This question was a bit tricky because of overflow. \\nI didn\\'t thought of overflow in my first attempt and got runtime error.\\nIn my second attempt I just count the -ve numbers and booom. Beats 100 percent.\\nhasta la vista..."
                    },
                    {
                        "username": "Minatokun",
                        "content": "Suprised to see this ques has only 66% acceptance rate."
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "no need to calculate the product; and what are they talking about signFunc??"
                    },
                    {
                        "username": "saakshikobarne",
                        "content": "Hint : You don\\'t need to multiply these values and return the sign of the product, just check if there exists a 0 in the array, if it does, simply return 0.\\nor if 0 does not exist, just count the total negative numbers (numbers less than 0) in the array, if the count of negative numbers is even, return 1 (as Multiplying an Even Number of Negatives is always positive) and if the count of negative nos in the array is odd, return -1 from the function."
                    },
                    {
                        "username": "sandro__77",
                        "content": "That\\'s true, this is not what you would do in the real life. But it is not what this problem asks to you. It asks you to multiply them."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is an Approach:-)***\\n\\n- Initialize a boolean variable hasOddNegatives to false.\\n- Iterate through each element i in the array:\\na. If i is equal to 0, return 0.\\nb. If i is negative, flip the value of hasOddNegatives.\\n- After the loop finishes, check the value of hasOddNegatives and return 1 or -1 accordingly."
                    }
                ]
            },
            {
                "id": 1879802,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879801,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879777,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879766,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879764,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879753,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879741,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879737,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879695,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1784254,
                "content": [
                    {
                        "username": "vetor",
                        "content": "Easy\\uD83D\\uDE38"
                    },
                    {
                        "username": "Maang-io",
                        "content": "        return negativeCount%2 == 0 ? 1: -1; // handle 0 explicitly"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "The silent before the storm \\u2620\\uFE0F"
                    },
                    {
                        "username": "adityasahay15",
                        "content": "Hint:- No need to multiply"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "Can I have this problem on google interview?"
                    },
                    {
                        "username": "Maang-io",
                        "content": "I am surprised that this question has been asked by Microsoft like 10 times. crazy!! it took less than 3.5 min to code and accepted by LC. I am sure something more in real interview"
                    },
                    {
                        "username": "daring-calf",
                        "content": "\\u4ECA\\u5929\\u8FD9\\u9898\\u662F\\u771F\\u9E21\\u513F\\u7B80\\u5355"
                    },
                    {
                        "username": "psionl0",
                        "content": "I don\\'t know why my code is so comparatively slow. Some solutions count the number of negative entries and some use a double variable to store the product of the nums array (that would SURELY take forever?). My solution simply toggles the result between +1 and -1 whenever a number from the nums array is negative.\\n```\\nint arraySign(int* nums, int numsSize){\\n    int i, res = 1;\\n    for (i = 0; i < numsSize; ++i) {\\n        if (nums[i] == 0) {\\n            return 0;\\n        }\\n        if (nums[i] < 0) {\\n            res = - res;\\n        }\\n    }\\n    return res;\\n}\\n```"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "dont multiply, use the parity of the negative numbers in the array "
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public int arraySign(int[] nums) {\\n        int n = nums.length, count = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] == 0)\\n                return 0;\\n            else if(nums[i] < 0)\\n                count++;\\n        }\\n        \\n        if(count % 2 == 0)\\n            return 1;\\n        else if(count % 2 != 0)\\n            return -1;\\n        return 0;\\n    }\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find the Winner of the Circular Game",
        "question_content": "<p>There are <code>n</code> friends that are playing a game. The friends are sitting in a circle and are numbered from <code>1</code> to <code>n</code> in <strong>clockwise order</strong>. More formally, moving clockwise from the <code>i<sup>th</sup></code> friend brings you to the <code>(i+1)<sup>th</sup></code> friend for <code>1 &lt;= i &lt; n</code>, and moving clockwise from the <code>n<sup>th</sup></code> friend brings you to the <code>1<sup>st</sup></code> friend.</p>\n\n<p>The rules of the game are as follows:</p>\n\n<ol>\n\t<li><strong>Start</strong> at the <code>1<sup>st</sup></code> friend.</li>\n\t<li>Count the next <code>k</code> friends in the clockwise direction <strong>including</strong> the friend you started at. The counting wraps around the circle and may count some friends more than once.</li>\n\t<li>The last friend you counted leaves the circle and loses the game.</li>\n\t<li>If there is still more than one friend in the circle, go back to step <code>2</code> <strong>starting</strong> from the friend <strong>immediately clockwise</strong> of the friend who just lost and repeat.</li>\n\t<li>Else, the last friend in the circle wins the game.</li>\n</ol>\n\n<p>Given the number of friends, <code>n</code>, and an integer <code>k</code>, return <em>the winner of the game</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q2-ex11.png\" style=\"width: 500px; height: 345px;\" />\n<pre>\n<strong>Input:</strong> n = 5, k = 2\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 6, k = 5\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 500</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<p>Could you solve this problem in linear time with constant space?</p>\n",
        "solutions": [
            {
                "id": 1152594,
                "title": "c-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int x=k;\\n            while(x>1){\\n                int r=q.front();\\n                q.pop();\\n                q.push(r);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int x=k;\\n            while(x>1){\\n                int r=q.front();\\n                q.pop();\\n                q.push(r);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601186,
                "title": "c-3-approach-easy-understanding",
                "content": "The 3 Easy Approaches are : Circular Linked List, Recursive and Iterative.\\n\\n# 1. **Brute Force Solution : CIRCULAR LINKED LIST**\\n```\\n/* Time Complexity : O(n*k)  Space Complexity : O(n) */\\n```\\nIf we look at the question, it says that the people are playing the game on a round table. That means, A Circular Linked List can be used to visualize the round table. We store 1,2,3,4,.......,n as the nodes of our List and go on deleting every kth node that we encounter. When we are left with only 1 node i.e. the head node, it is our WINNER. Since we are consuming extra space for Circular Linked List so, our Space Complexity goes to O(n).\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(ListNode *head,int k){\\n        ListNode *temp=head;  //For traversing through the List and delete every kth Node \\n        while(head->next!=head){   //Till the last Node remains in the list i.e. the winner\\n            ListNode *pre=NULL;\\n            for(int i=1; i<k; i++){\\n                pre=temp;\\n                temp=temp->next;\\n            }\\n            //Deletion procedure\\n            if(temp==head)\\n                head=head->next;\\n            pre->next=temp->next;\\n            delete(temp);\\n            temp=pre->next;\\n        }\\n        //The last node remaining becomes the head of the Circular Linked List i.e. Winner\\n        return head->val;\\n    }\\n    int findTheWinner(int n, int k) {\\n        if(k==1)\\n            return n;\\n        //Designing Circular Linked List for Node 1,2,3,4,.....,n\\n        ListNode *head=NULL,*tail=NULL;\\n        for(int i=1; i<=n; i++){\\n            ListNode *node=new ListNode(i);\\n            if(head==NULL)\\n                head=tail=node;\\n            else{\\n                tail->next=node;\\n                tail=node;\\n            }\\n            tail->next=head;\\n        }\\n        //Helper function will eliminate the nodes and give us the winner\\n        return helper(head,k);\\n    }\\n};\\n```\\n\\n# 2. **Simple Solution : RECURSION**\\n```\\n/* Time Complexity : O(n)  Space Complexity : O(n) */\\n```\\nThis problem can also be solved using Recursion. If you observe, you can see that we are doing the same activity again and again i.e. deleting every kth element we encounter. Therefore, we can think towards the recursive approach also.\\nIntution : If I have  the winner for \\'n-1\\' and \\'k\\'. I can find the winner for \\'n\\' and \\'k\\' by moving on to the next kth person (i.e. f(n) = f(n-1)+k). Keeping in mind that they are sitting on a round table we have to rotate also (i.e. f(n) = (f(n-1)+k)%n).\\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int k){\\n        if(n==1)\\n            return 0;\\n        return (helper(n-1,k) + k) % n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;   //+1 is for converting 0-based indexing to 1-based indexing\\n    }\\n};\\n```\\n**Note : You might think that you have not taken any extra space in for the problem so the space complexity is O(1) but this is not true. The function calls are stored in the Stack memory of the machine and therefore these recursive calls end up making a Stack at the machine end. So, the Space Complexity for this program goes to O(n). INTERESTING HUH XD**\\n# 3. **Optimised Solution : ITERATIVE APPROACH**\\n```\\n/* Time Complexity : O(n)  Space Complexity : O(1) */\\n```\\nWe can simply convert our Recursive Solution into Iterative Solution. This will bring no change in the Time Complexity but the Space Complexity will be optimised from O(n) to O(1). Our intution remains the same and looks very much similar to our Recursive Solution.\\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int k){\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;   //+1 is for conterting 0-based indexing to 1-based indexing\\n    }\\n};\\n```\\n**Note : Since, we are doing the problem Iteratively. So, extra space is not consumed neither from our side nor from machine\\'s side. Therefore the space complexity of our program is optimised to O(1).**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/* Time Complexity : O(n*k)  Space Complexity : O(n) */\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(ListNode *head,int k){\\n        ListNode *temp=head;  //For traversing through the List and delete every kth Node \\n        while(head->next!=head){   //Till the last Node remains in the list i.e. the winner\\n            ListNode *pre=NULL;\\n            for(int i=1; i<k; i++){\\n                pre=temp;\\n                temp=temp->next;\\n            }\\n            //Deletion procedure\\n            if(temp==head)\\n                head=head->next;\\n            pre->next=temp->next;\\n            delete(temp);\\n            temp=pre->next;\\n        }\\n        //The last node remaining becomes the head of the Circular Linked List i.e. Winner\\n        return head->val;\\n    }\\n    int findTheWinner(int n, int k) {\\n        if(k==1)\\n            return n;\\n        //Designing Circular Linked List for Node 1,2,3,4,.....,n\\n        ListNode *head=NULL,*tail=NULL;\\n        for(int i=1; i<=n; i++){\\n            ListNode *node=new ListNode(i);\\n            if(head==NULL)\\n                head=tail=node;\\n            else{\\n                tail->next=node;\\n                tail=node;\\n            }\\n            tail->next=head;\\n        }\\n        //Helper function will eliminate the nodes and give us the winner\\n        return helper(head,k);\\n    }\\n};\\n```\n```\\n/* Time Complexity : O(n)  Space Complexity : O(n) */\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int k){\\n        if(n==1)\\n            return 0;\\n        return (helper(n-1,k) + k) % n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;   //+1 is for converting 0-based indexing to 1-based indexing\\n    }\\n};\\n```\n```\\n/* Time Complexity : O(n)  Space Complexity : O(1) */\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int n,int k){\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;   //+1 is for conterting 0-based indexing to 1-based indexing\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157717,
                "title": "java-full-solution-and-explanation",
                "content": "*Note : I realized I used the word kill instead of loose. It\\'s just because I was thinking of the original Josephus problem when writing it. To comply exactly to the leetcode problem, just replace kill by loose when you read it.*\\n# Solution to the problem in Java\\n## First approach (Naive)\\nThe first approach could be to just translate the problem we have into code. Let\\'s assume we define a classe `Node` with a `num` value (the integer 1, 2, 3, ...) and a `prev` and `next` values, which both are of type `Node`. Then we would have a class which represents what we have, a number as label, a follower and a previous.\\n\\n```\\nclass Node{\\n    final int num;\\n    Node next = null;\\n    Node prev = null;\\n    \\n    public Node(int num) {\\n        this.num = num;\\n    }\\n}\\n```\\n\\nThen, what happend when we kill a `Node` ? We simply set the previous of the follower to be the previous of the current `Node` and same for the follower of the previous :\\n\\n```\\npublic void kill(){\\n    prev.next = next;\\n    next.prev = prev;\\n}\\n```\\n\\nSo now we have defined the Node with the behavior, let\\'s start by initializing the nodes in the solution :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n\\t    // We set the first node and keep it (to be able to set it as the follower of the last node we will create)\\n        Node firstNode = new Node(1);\\n\\t\\t// This is just part of our loop\\n        Node prevNode = firstNode;\\n        for(int i=2; i<=n; i++) {\\n            Node currentNode = new Node(i);\\n            currentNode.prev = prevNode;\\n            prevNode.next = currentNode;\\n            prevNode = currentNode;\\n        }\\n\\t\\t// Then set the last and first nodes\\n        firstNode.prev = prevNode;\\n        prevNode.next = firstNode;\\n    }\\n}\\n```\\n\\nNow, what we have to do is pretty easy. Start from the last Node (the one before the first) and count k each time, and kill the `Node` on which we are. As the current `Node` will be the one killed, its next will be the one that we will start with. So we are still before the first one to start with :\\n\\n```\\nNode currentNode = prevNode;\\nfor(int i=0; i<n; i++) {\\n\\tfor(int j=0; j<k; j++) {\\n\\t\\tcurrentNode = currentNode.next;\\n\\t}\\n\\tcurrentNode.kill();\\n}\\n```\\n\\nAll we have to do finally is to return the `num` of the next node, the only one surviving.\\n\\n```\\nreturn currentNode.next.num;\\n```\\n\\nSo the final solution is :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Node firstNode = new Node(1);\\n        Node prevNode = firstNode;\\n        for(int i=2; i<=n; i++) {\\n            Node currentNode = new Node(i);\\n            currentNode.prev = prevNode;\\n            prevNode.next = currentNode;\\n            prevNode = currentNode;\\n        }\\n        firstNode.prev = prevNode;\\n        prevNode.next = firstNode;\\n        \\n        \\n        Node currentNode = prevNode;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<k; j++) {\\n                currentNode = currentNode.next;\\n            }\\n            currentNode.kill();\\n        }\\n        return currentNode.next.num;\\n    }\\n}\\n\\nclass Node{\\n    final int num;\\n    Node next = null;\\n    Node prev = null;\\n    \\n    public Node(int num) {\\n        this.num = num;\\n    }\\n    \\n    public void kill(){\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n}\\n```\\n\\n### Complexity\\n\\nTime complexity is O(n \\xD7 k) as we count `k` times for the `n` turns.\\nSpace complexity is O(k) as we create `k` nodes for playing the game\\n\\n## Second Approach (Code optimization using Data Structure)\\nRemember good code is based in three criterias :\\n\\n* Time complexity\\n* Space complexity\\n* Readability\\n\\nA good first step could be to reduce the code drastically, to make it more readable. What we can do here is using `LinkedList` instead of our `Node` custom class. The logic will just to pass the first value to the last one until we arrive to the one to kill. Let\\'s see with `n=5` and `k=2` how we will perform.\\n\\n```\\n=== Initialization ===\\n1 => 2 => 3 => 4 => 5\\n=== First round ===\\n1) we put the 1 to the end :\\n2 => 3 => 4 => 5 => 1\\n2) Second step, meaning current step = k, we just poll the node :\\n3 => 4 => 5 => 1\\n=== Second round ===\\n1) We put 3 at the end\\n4 => 5 => 1 => 3\\n2) We poll 4\\n5 => 1 => 3\\n=== Third round ===\\n1) We put 5 at the end\\n1 => 3 => 5\\n2) We poll 1\\n3 => 5\\n=== Forth round ===\\n1) We put 3 at the end\\n5 => 3\\n2) We poll 5\\n3\\n```\\n\\nNow that it is clear, the question could be, how to put the first value to the last position in a LinkedList. Actually, it\\'s quite easy : polling it and adding to the LinkedList: `linkedList.add(linkedList.poll())`\\n\\nThat being said, let\\'s translate this into code :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n\\t    // Initialisation of the LinkedList\\n        LinkedList<Integer> participants = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t    participants.add(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint lastKilled = 0;\\n\\t\\t// Run the game\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k-1; j++) {\\n\\t\\t\\t    participants.add(participants.poll());\\n\\t\\t\\t}\\n            lastKilled = participants.poll();\\n        }\\n        // Return the last one killed\\n        return lastKilled;\\n    }\\n}\\n```\\n\\n### Complexity\\nTime complexity is O(n \\xD7 k) as we count `k` times for the `n` turns.\\nSpace complexity is O(k) as we create `k` nodes for playing the game\\n*In terms of time with LeetCode, the first solution is better than this one, especially because (add(poll)) is really time consuming in Java.*\\n\\n### Interview tips\\nIn an interview, the first or second solution will be good. But interviewer may ask you is there a better approach, and then, you can talk about time consumed by the first solution, and code complexity of the first one, and tell that you would make trade-offs based in this.\\n\\n## Third approach (Mathematical)\\n\\n### Basic approach\\nLet\\'s assume we have f(n,k) which will give you the one remaining after nth turn in a group of nth people if we count k person at each turn. If you don\\'t have any tool, it may take you few hours to realize how to calculate f(n,2). For the generic k, it will take you few hours just to understand the demonstration. So of course, this solution will never be expected from you in an interview.\\nSo let\\'s assume all participants are numbered 0 based, and that f(1,k) = 0 (if we have only one participant, numbered 0 as it is the first one, of course it\\'s the one who will remain).\\nThen f(n,k) = (f(n-1, k)+k) mod n. Considering this, it\\'s easy to code the solution :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findTheWinner0Based(n, k)+1;\\n    }\\n    \\n    public int findTheWinner0Based(int n, int k) {\\n        if(n == 1) {\\n            return 0;\\n        } else {\\n            return (findTheWinner0Based(n - 1, k) + k) % n;\\n        }\\n    }\\n}\\n```\\n\\n#### Complexity\\nAs we can see, we will iterate on the function n times, the time complexity is O(n).\\nOf course, calling recursive functions will have a space complexity of O(n) (storing all the temporary results of the method called)\\n\\n### Removing recursive function to have a space complexity of O(1)\\n\\nWe could remove the recursive calls in order to achieve a space complexity of O(1). Instead of starting from the last item and counting down until 1, we could start at one, and counting up until we reach n :\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int result = 0;\\n        for(int i=1; i<=n; i++) {\\n            result = (result + k) % i;\\n        }\\n        return result + 1;\\n    }\\n}\\n```\\n\\n*This last solution will give you a result of 0ms on leetcode, so you may think that you came up with the best solution. Actually, it\\'s possible to make it even faster.*\\n\\n### Improving time complexity\\n\\nIt\\'s possible to decrease time complexity for certain scenarii using mathematical formulas. It\\'s possible to achieve a time complexity of O(k \\xD7 log(n)) which may be faster than O(n) especially when n is huge and k is little.\\n\\nDon\\'t try to understand this if you\\'re not a mathematician (I\\'m not) ;-)\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findTheWinner0Based(n, k)+1;\\n    }\\n    \\n    public int findTheWinner0Based(int n, int k) {\\n        if(k == 1) return n-1;\\n        if(n == 1) return 0;\\n        if(k <= n) {\\n            return findTheWinnerForLargeN(n, k);\\n        } else {\\n            return findTheWinnerForSmallN(n, k);\\n        }\\n    }\\n    \\n    public int findTheWinnerForLargeN(int n, int k) {\\n        int np = n - (n/k);\\n        int result = (k*(((findTheWinner0Based(np, k) - n%k)+np) % np))/(k-1);\\n        return result;\\n    }\\n    \\n    public int findTheWinnerForSmallN(int n, int k) {\\n        int result = 0;\\n        for(int i=1; i<=n; i++) {\\n            result = (result + k) % i;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n### Complexity\\nTime complexity is O(k \\xD7 log(n)) if n is higher than k, O(n) otherwise.\\nSpace complexity is the same as time complexity as we are using recursive functions.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node{\\n    final int num;\\n    Node next = null;\\n    Node prev = null;\\n    \\n    public Node(int num) {\\n        this.num = num;\\n    }\\n}\\n```\n```\\npublic void kill(){\\n    prev.next = next;\\n    next.prev = prev;\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n\\t    // We set the first node and keep it (to be able to set it as the follower of the last node we will create)\\n        Node firstNode = new Node(1);\\n\\t\\t// This is just part of our loop\\n        Node prevNode = firstNode;\\n        for(int i=2; i<=n; i++) {\\n            Node currentNode = new Node(i);\\n            currentNode.prev = prevNode;\\n            prevNode.next = currentNode;\\n            prevNode = currentNode;\\n        }\\n\\t\\t// Then set the last and first nodes\\n        firstNode.prev = prevNode;\\n        prevNode.next = firstNode;\\n    }\\n}\\n```\n```\\nNode currentNode = prevNode;\\nfor(int i=0; i<n; i++) {\\n\\tfor(int j=0; j<k; j++) {\\n\\t\\tcurrentNode = currentNode.next;\\n\\t}\\n\\tcurrentNode.kill();\\n}\\n```\n```\\nreturn currentNode.next.num;\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Node firstNode = new Node(1);\\n        Node prevNode = firstNode;\\n        for(int i=2; i<=n; i++) {\\n            Node currentNode = new Node(i);\\n            currentNode.prev = prevNode;\\n            prevNode.next = currentNode;\\n            prevNode = currentNode;\\n        }\\n        firstNode.prev = prevNode;\\n        prevNode.next = firstNode;\\n        \\n        \\n        Node currentNode = prevNode;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<k; j++) {\\n                currentNode = currentNode.next;\\n            }\\n            currentNode.kill();\\n        }\\n        return currentNode.next.num;\\n    }\\n}\\n\\nclass Node{\\n    final int num;\\n    Node next = null;\\n    Node prev = null;\\n    \\n    public Node(int num) {\\n        this.num = num;\\n    }\\n    \\n    public void kill(){\\n        prev.next = next;\\n        next.prev = prev;\\n    }\\n}\\n```\n```\\n=== Initialization ===\\n1 => 2 => 3 => 4 => 5\\n=== First round ===\\n1) we put the 1 to the end :\\n2 => 3 => 4 => 5 => 1\\n2) Second step, meaning current step = k, we just poll the node :\\n3 => 4 => 5 => 1\\n=== Second round ===\\n1) We put 3 at the end\\n4 => 5 => 1 => 3\\n2) We poll 4\\n5 => 1 => 3\\n=== Third round ===\\n1) We put 5 at the end\\n1 => 3 => 5\\n2) We poll 1\\n3 => 5\\n=== Forth round ===\\n1) We put 3 at the end\\n5 => 3\\n2) We poll 5\\n3\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n\\t    // Initialisation of the LinkedList\\n        LinkedList<Integer> participants = new LinkedList<>();\\n        for (int i = 1; i <= n; i++) {\\n\\t\\t    participants.add(i);\\n\\t\\t}\\n\\t\\t\\n\\t\\tint lastKilled = 0;\\n\\t\\t// Run the game\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k-1; j++) {\\n\\t\\t\\t    participants.add(participants.poll());\\n\\t\\t\\t}\\n            lastKilled = participants.poll();\\n        }\\n        // Return the last one killed\\n        return lastKilled;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findTheWinner0Based(n, k)+1;\\n    }\\n    \\n    public int findTheWinner0Based(int n, int k) {\\n        if(n == 1) {\\n            return 0;\\n        } else {\\n            return (findTheWinner0Based(n - 1, k) + k) % n;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int result = 0;\\n        for(int i=1; i<=n; i++) {\\n            result = (result + k) % i;\\n        }\\n        return result + 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findTheWinner0Based(n, k)+1;\\n    }\\n    \\n    public int findTheWinner0Based(int n, int k) {\\n        if(k == 1) return n-1;\\n        if(n == 1) return 0;\\n        if(k <= n) {\\n            return findTheWinnerForLargeN(n, k);\\n        } else {\\n            return findTheWinnerForSmallN(n, k);\\n        }\\n    }\\n    \\n    public int findTheWinnerForLargeN(int n, int k) {\\n        int np = n - (n/k);\\n        int result = (k*(((findTheWinner0Based(np, k) - n%k)+np) % np))/(k-1);\\n        return result;\\n    }\\n    \\n    public int findTheWinnerForSmallN(int n, int k) {\\n        int result = 0;\\n        for(int i=1; i<=n; i++) {\\n            result = (result + k) % i;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152585,
                "title": "o-n-o-klg-n-with-table-explanation",
                "content": "This is the josephus problem, [wikipedia](https://en.wikipedia.org/wiki/Josephus_problem)\\nThe classic algorithm to this problem is very weird, let me talk with the example1 in \"leetcode problem description\". \\nAt first [aaa,bbb,cac,ddd,eee] is playing this game.\\n\\n| #alive | aaa | bbb | cac | ddd | eee |\\n|-------------|-----|-----|-----|-----|-----|\\n| 5           | 1   | 2   | 3   | 4   | 5   |\\n| 4           | 4   | (\\u2191eliminated)  | 1   | 2   | 3   |\\n| 3           | 2   |     | 3   |  (0)   | 1   |\\n| 2           |     |     | 1   |     | 2   |\\n| 1           |     |     | 1   |     |   |\\n\\nEvery different round, we name these people using different number sequences.\\nEvery time someone died, the number sequence start again from 1.\\nThe table describes how we name these people.\\n\\nThe winner have a number `1` in the last round. \\nYou have to induce his(cac) \\'s number in the first round.\\nSuppose when there are `i` people alive, cac\\'s number is `f(i,\\'cac\\')`. And when there are `i+1` people alive, cac\\'s number is `f(i+1,\\'cac\\')`.\\nThen `f(i+1,\\'cac\\') == (k + f(i,\\'cac\\') - 1 )%(i+1) + 1`.\\n\\n<details><summary> prove </summary><p>\\n\\n**When there are `i+1` people alive**, person with number *`k % (i+1)`* will be eliminated \\n\\n**When `i` people alive**, He(\\u2191) has a dummy number 0 . So count the next `f(i,\\'cac\\')` people , ( turn back to round when `i+1` people alive ) number *`(k+f(i,\\'cac\\')) % (i+1)`* is the value of *`f(i+1, \\'cac\\')`* . \\n\\nA good example from this table is when `i==3`. `f(i,\\'cac\\')` is `3`, \\'ddd\\' will be eliminated, `f(i+1, \\'cac\\')` is *`(2+f(i,\\'cac\\'))%4`*.\\n\\nNotice, `f(i+1,\\'cac\\')` can\\'t be zero, you need change it to *`(k+f(i,\\'cac\\')-1)%(i+1)+1`*. ( for example, when `i==2`, the value of *`(k+f(i,\\'cac\\'))%(i+1)`* maybe `0,1,2`, but indeed, we need `3,1,2`, so additionally map `0` into `3` while remeining other values unchanged. ). \\n\\nTo avoid this problem, you can make all indices in this problem start from 0, i.e. map all indices from `i` to `i-1`. \\n\\n---\\n</p></details>\\n\\nThen you can build a relation between each round and finally get the correct answer.\\n\\nThere is also a `O(klg(n))` hybrid algorithm, I will introduce later.\\nThere is also a time `O(lgn)` space `O(1)` formula/algorithm when `k` is `2`, refer to wikipedia.\\n## code\\n-----\\n\\ntop-down recursion: time \\u0398(n) space \\u0398(n)\\n```python\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        if n==1: return 1\\n        return (k + self.findTheWinner(n-1, k) -1) % n + 1\\n```\\n\\nbottom-up time \\u0398(n) space \\u0398(1)\\n\\n```python\\ndef findTheWinner(self, n: int, k: int) -> int:\\n    p = 1\\n    for i in range(1,n):\\n        # here i represent number of alive people\\n\\t\\t# p is f(i,\\'cac\\')\\n        p=(k+p-1)%(i+1)+1\\n\\t\\t# p is f(i+1, \\'cac\\')\\n    return p\\n```\\n\\n## advanced code1\\nhttps://stackoverflow.com/a/69891445/7721525\\n## advanced code2\\n-----\\n\\nlet\\'s use `g(n,k)` to represent answer of this problem.\\nIn the previous section, we know for any positive n,k, `g(n,k) = (k + g(n-1, k) -1)%n + 1`.\\n\\nWhen `n >= k and k!=1`, we can eliminate `floor(n/k)` people in a round, and then use new indices.\\nFor example, `n=11, k=3`\\n\\nhere for convenience, index start from 0\\n\\n|||||||||||foo||\\n|---|---|---|---|---|---|---|---|---|---|---|----|\\n| y | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\\n| z | 2 | 3 | / | 4 | 5 | / | 6 | 7 | / | 0 | 1  |\\n| x | 0 | 1 | / | 2 | 3 | / | 4 | 5 | / | 6 | 7  |\\n|y-x| 0 | 0 |   | 1 | 1 |   | 2 | 2 |   | 3 | 3  |\\n\\nAs table, on the same column, `x,y,z` are different indices on the same person. From row1 to row2, eliminate `floor(n/k)` people, the indices start again on foo.\\n  \\n+ `nextn = n - floor(n/k)`\\n+ `x = (z-n%k) mod nextn ` (`x>=0`)\\n+ `y = x + floor(x/(k-1))`\\n+ so let  `z = g(nextn,k)` we can get `g(n,k)` from `y`\\n\\n```python\\ndef findTheWinner(self, n: int, k: int) -> int:\\n    if n==1: \\n        return 1\\n    elif k==1:\\n        return n\\n    elif n>=k:\\n        next_n = n - n//k\\n        z = self.findTheWinner(next_n, k) - 1\\n        x = (z-n%k + next_n) % next_n\\n        return x + x//(k-1) + 1\\n    else:\\n        return (k + self.findTheWinner(n-1, k) -1) % n + 1\\n```\\n\\nthe time complexity `O(klg(n))`, space `O(klg(n))`\\n\\nSolve `T(n) = T(n*k/(k+1)) + O(1) if n>k else T(n)=T(n-1)+1`, \\n`(k/(k+1))^(T(n)-k) = k/n` \\n> `T(n) = (log(n/k))/(log(k+1)-log(k)) + k`\\n>> `1/(log(k+1)-log(k)) \\u2248 k + 0.5` ( logarithm base `math.e`)\\n>> \\n> `T(n) \\u2248 klog(n/k) + k`\\n\\nSo `klg(n)` is an upper bound, also refer to wikipedia.\\n\\n## similar problems\\n-----\\n\\n+ leetcode #390 (hard on log(n) solution)\\n+ leetcode #1900 (super hard on log(n) solution )\\n\\n## where I learn from \\n\\n+ https://maskray.me/blog/2013-08-27-josephus-problem-two-log-n-solutions, but there are some mistakes.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        if n==1: return 1\\n        return (k + self.findTheWinner(n-1, k) -1) % n + 1\\n```\n```python\\ndef findTheWinner(self, n: int, k: int) -> int:\\n    p = 1\\n    for i in range(1,n):\\n        # here i represent number of alive people\\n\\t\\t# p is f(i,\\'cac\\')\\n        p=(k+p-1)%(i+1)+1\\n\\t\\t# p is f(i+1, \\'cac\\')\\n    return p\\n```\n```python\\ndef findTheWinner(self, n: int, k: int) -> int:\\n    if n==1: \\n        return 1\\n    elif k==1:\\n        return n\\n    elif n>=k:\\n        next_n = n - n//k\\n        z = self.findTheWinner(next_n, k) - 1\\n        x = (z-n%k + next_n) % next_n\\n        return x + x//(k-1) + 1\\n    else:\\n        return (k + self.findTheWinner(n-1, k) -1) % n + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152460,
                "title": "java-queue-self-explanatory",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            queue.offer(i);\\n        }\\n        \\n        while(queue.size()>1){\\n            int delete = k-1;\\n            while(delete>0){\\n                queue.offer(queue.remove());\\n                delete--;\\n            }\\n            \\n            queue.remove();\\n        }\\n        \\n        return queue.remove();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            queue.offer(i);\\n        }\\n        \\n        while(queue.size()>1){\\n            int delete = k-1;\\n            while(delete>0){\\n                queue.offer(queue.remove());\\n                delete--;\\n            }\\n            \\n            queue.remove();\\n        }\\n        \\n        return queue.remove();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152420,
                "title": "python3-simulation",
                "content": "\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        nums = list(range(n))\\n        i = 0 \\n        while len(nums) > 1: \\n            i = (i + k-1) % len(nums)\\n            nums.pop(i)\\n        return nums[0] + 1\\n```\\n\\n**Approach 2 -- dp**\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        ans = 0\\n        for x in range(2, n+1): ans = (ans + k) % x\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        nums = list(range(n))\\n        i = 0 \\n        while len(nums) > 1: \\n            i = (i + k-1) % len(nums)\\n            nums.pop(i)\\n        return nums[0] + 1\\n```\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        ans = 0\\n        for x in range(2, n+1): ans = (ans + k) % x\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152617,
                "title": "josephus-problem-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int n,int k)\\n    {\\n        if(n==1) return 0;\\n        int x=solve(n-1,k);\\n        int y=(x+k)%n;\\n        return y;\\n    }\\n    int findTheWinner(int n, int k) {\\n       if(k>n) k=k%n;\\n        return solve(n,k)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,int k)\\n    {\\n        if(n==1) return 0;\\n        int x=solve(n-1,k);\\n        int y=(x+k)%n;\\n        return y;\\n    }\\n    int findTheWinner(int n, int k) {\\n       if(k>n) k=k%n;\\n        return solve(n,k)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626018,
                "title": "5-lines-java-solution-0ms-100-faster",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nProblem is same as famous \"Josephus Problem\".\\n\\nclass Solution {\\n\\n    public int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;\\n    }\\n    public int helper(int n,int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (helper(n-1,k)+k)%n;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n    public int findTheWinner(int n, int k) {\\n        return helper(n,k)+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1490558,
                "title": "python-simulation-solution-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Simulation**\\n```python\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circle = [i for i in range(1, n+1)]\\n        lastIndex = 0\\n        while len(circle) > 1:\\n            lastIndex = (lastIndex + k - 1) % len(circle)\\n            del circle[lastIndex]\\n            lastIndex = lastIndex % len(circle)\\n        return circle[0]\\n```\\nComplexity:\\n- Time: `O(K * N)`, where `K <= N <= 500`.\\n- Space: `O(N^2)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circle = [i for i in range(1, n+1)]\\n        lastIndex = 0\\n        while len(circle) > 1:\\n            lastIndex = (lastIndex + k - 1) % len(circle)\\n            del circle[lastIndex]\\n            lastIndex = lastIndex % len(circle)\\n        return circle[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181025,
                "title": "c-solution-josephus-problem",
                "content": "This is the standard **[Josephus Problem](https://en.wikipedia.org/wiki/Josephus_problem)**. \\nThis solution uses recursion to eliminate one person in each round and return the last standing person.\\n\\n![image](https://assets.leetcode.com/users/images/3ca609dc-d55a-416c-bcb7-27f891932e1a_1655869639.4225068.gif)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void josephus(vector<int> &v, int start, int k){\\n        if(v.size()==1){             //Return last standing person\\n            return;\\n        }\\n        start+=k;                    //Position of person form start which is to be eliminated\\n        int s = v.size();\\n        start%=s;                    //Taking remainder so that index does not go above the size of array\\n        v.erase(v.begin()+start);      //Eliminating the person\\n        josephus(v,start,k);             //Recusive call\\n        return;\\n    }\\n    \\n    \\n    int findTheWinner(int n, int k) {\\n        vector<int> v(n);\\n        k--;\\n        for(int i=1; i<=n; i++){\\n            v[i-1]=i;\\n        }\\n        josephus(v,0,k);\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void josephus(vector<int> &v, int start, int k){\\n        if(v.size()==1){             //Return last standing person\\n            return;\\n        }\\n        start+=k;                    //Position of person form start which is to be eliminated\\n        int s = v.size();\\n        start%=s;                    //Taking remainder so that index does not go above the size of array\\n        v.erase(v.begin()+start);      //Eliminating the person\\n        josephus(v,start,k);             //Recusive call\\n        return;\\n    }\\n    \\n    \\n    int findTheWinner(int n, int k) {\\n        vector<int> v(n);\\n        k--;\\n        for(int i=1; i<=n; i++){\\n            v[i-1]=i;\\n        }\\n        josephus(v,0,k);\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152829,
                "title": "javascript-solution-with-explanation-queue-iterative",
                "content": "```\\nEXAMPLE: You are given an array [1,2,3,4,5] and you are asked to delete every second element while visualizing these numbers (elements of array) in a circle.\\n\\nYou are probably picturing this: \\n 1-2-3-4-5 ---> 1-3-4-5 ----> 1-3-5 ----> 3-5----> 3 Answer!\\n ```\\n \\n`Approach 1: ` Pick (k-1) elements from the front of the array and push/append it to the back of this array while deleting the kth element  at every step .\\n \\n `How to implement? `\\n- Use queue data structure\\n-  Iteratively dequeue(remove from front) k-1 elements from it\\n-  Enqueue(push/append) the removed (k-1) elements to the back of the same array.\\n-  Delete the kth element\\n- Now you have a que of length of (previous-queue-length -1)\\n- Repeat this until you have only one number left in your queue\\n- Return the number from your queue! \\n\\n\\n\\n\\n\\n```\\nconst findTheWinner = function(n, k) {\\n// Build queue\\n    let que = [] \\n    for(let i = 1; i <= n;i++){\\n        que.push(i)\\n    }\\n\\n    while(que.length > 1){\\n\\t\\tlet deleteCount = k-1\\n\\t\\t\\twhile(deleteCount > 0){\\n\\t\\t\\t\\tque.push(que.shift())    //Rotate Elements  \\n\\t\\t\\t\\tdeleteCount--\\n\\t\\t\\t}\\n        que.shift()                    // Delete kth element\\n    }\\n    return que.shift()  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nEXAMPLE: You are given an array [1,2,3,4,5] and you are asked to delete every second element while visualizing these numbers (elements of array) in a circle.\\n\\nYou are probably picturing this: \\n 1-2-3-4-5 ---> 1-3-4-5 ----> 1-3-5 ----> 3-5----> 3 Answer!\\n ```\n```\\nconst findTheWinner = function(n, k) {\\n// Build queue\\n    let que = [] \\n    for(let i = 1; i <= n;i++){\\n        que.push(i)\\n    }\\n\\n    while(que.length > 1){\\n\\t\\tlet deleteCount = k-1\\n\\t\\t\\twhile(deleteCount > 0){\\n\\t\\t\\t\\tque.push(que.shift())    //Rotate Elements  \\n\\t\\t\\t\\tdeleteCount--\\n\\t\\t\\t}\\n        que.shift()                    // Delete kth element\\n    }\\n    return que.shift()  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1155396,
                "title": "short-and-easy-python3-beats-100",
                "content": "\\tclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        ls=list(range(1,n+1))\\n        while len(ls)>1:\\n            i=(k-1)%len(ls)\\n            ls.pop(i)\\n            ls=ls[i:]+ls[:i]\\n        \\n        return ls[0]\\n\\n![image](https://assets.leetcode.com/users/images/1d40eef7-fc62-4764-a8d0-3eccd859c9c8_1618255596.4814124.png)\\n\\n**Edit: Even faster and shorter code**\\n\\n\\tclass Solution:\\n\\tdef findTheWinner(self, n: int, k: int) -> int:\\n\\t\\tls=list(range(1,n+1))\\n\\t\\twhile len(ls)>1:\\n\\t\\t\\ti=(k-1)%len(ls)\\n\\t\\t\\tls=ls[i+1:]+ls[:i]\\n\\n\\t\\treturn ls[0]",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        ls=list(range(1,n+1))\\n        while len(ls)>1:\\n            i=(k-1)%len(ls)\\n            ls.pop(i)\\n            ls=ls[i:]+ls[:i]\\n        \\n        return ls[0]\\n\\n![image](https://assets.leetcode.com/users/images/1d40eef7-fc62-4764-a8d0-3eccd859c9c8_1618255596.4814124.png)\\n\\n**Edit: Even faster and shorter code**\\n\\n\\tclass Solution:\\n\\tdef findTheWinner(self, n: int, k: int) -> int:\\n\\t\\tls=list(range(1,n+1))\\n\\t\\twhile len(ls)>1:\\n\\t\\t\\ti=(k-1)%len(ls)\\n\\t\\t\\tls=ls[i+1:]+ls[:i]\\n\\n\\t\\treturn ls[0]",
                "codeTag": "Java"
            },
            {
                "id": 1152544,
                "title": "c-simulation",
                "content": "Sure, there is a mathematical solution, and there is a list/queue solution.\\n\\nThough, since we are limted to `500` elements, we can just use a boolean array and skip through empty elements.\\n\\n```cpp\\nint findTheWinner(int n, int k) {\\n    vector<bool> f(n, true);\\n    int i = 0, cnt = n;\\n    while (cnt > 1) {\\n        for (int j = 0; j < k; ++j, ++i) {\\n            while(!f[i % n])\\n                ++i;\\n        }\\n        f[(i - 1) % n] = false;\\n        --cnt;\\n    }\\n    for (i = 0; !f[i]; ++i);\\n    return i  + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint findTheWinner(int n, int k) {\\n    vector<bool> f(n, true);\\n    int i = 0, cnt = n;\\n    while (cnt > 1) {\\n        for (int j = 0; j < k; ++j, ++i) {\\n            while(!f[i % n])\\n                ++i;\\n        }\\n        f[(i - 1) % n] = false;\\n        --cnt;\\n    }\\n    for (i = 0; !f[i]; ++i);\\n    return i  + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152474,
                "title": "josephus-problem",
                "content": "Read about Josephus problem here -> https://en.wikipedia.org/wiki/Josephus_problem\\n\\nQuite simply, you can use list.pop(i) to delete each number (and get his ID) in a loop. Then, we just have to worry about wrapping the indices, which you can do just by taking the skipped index mod the number of remaining numbers.\\n\\nSo then, the question solution becomes\\n\\n```\\ndef josephus(ls, skip):\\n    skip -= 1 \\n    idx = skip\\n    while len(ls) > 1:\\n        ls.pop(idx)\\n        idx = (idx + skip) % len(ls)\\n    return ls[0]\\n```\\n\\n```\\n\\n\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        n = list(range(1,n+1))\\n        return self.josephus(n, k)\\n        \\n    def josephus(self, ls, skip):\\n        skip -= 1 \\n        idx = skip\\n        while len(ls) > 1:\\n            ls.pop(idx)\\n            idx = (idx + skip) % len(ls)\\n        return ls[0]\\n```",
                "solutionTags": [],
                "code": "```\\ndef josephus(ls, skip):\\n    skip -= 1 \\n    idx = skip\\n    while len(ls) > 1:\\n        ls.pop(idx)\\n        idx = (idx + skip) % len(ls)\\n    return ls[0]\\n```\n```\\n\\n\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        n = list(range(1,n+1))\\n        return self.josephus(n, k)\\n        \\n    def josephus(self, ls, skip):\\n        skip -= 1 \\n        idx = skip\\n        while len(ls) > 1:\\n            ls.pop(idx)\\n            idx = (idx + skip) % len(ls)\\n        return ls[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2847011,
                "title": "python-code-with-intuition-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution code is of few lines. You just need to understand the pattern here.\\n\\n## 1) Iterating over queue (If you know how to can skip this)\\nBefore that understand how to iterate over the circular queue.\\nSuppose no of students in circular queue are 6 starting from 0 index till 5th index.\\nLet\\'s say we are at 4th index \\n\\n![image.png](https://assets.leetcode.com/users/images/d6ca01b4-fbed-4669-87c2-a074d6db46da_1669362182.4144485.png)\\n\\nincrementing to the next element is no brainer add just to the index\\nNow we are at 5th.\\nincrementing from here will reach to 6th index which is out of bound.\\nUse modulus for incrementing\\n## next_index = (current_index+1) % total_students\\n  next_index = (5+1) % 6 = 0\\nThis will work for index less than 6 \\n  next_index = (4+1) % 6 = 5\\n\\n## 2) Understanding the pattern\\n\\nSuppose there are 7 friends are seating in linear way.\\n### n = 7 and k = 4\\n\\n![image.png](https://assets.leetcode.com/users/images/3cb740df-6209-45d3-bda9-914ac9ef33f3_1669362717.3768306.png)\\n\\nstarting from 0th index counting till 4 friend at index 3 will loose.\\n\\n![image.png](https://assets.leetcode.com/users/images/bc1b95ea-48a5-47fb-a3c1-a68b01a62958_1669362875.6951969.png)\\n\\n>  Keep  in mind that we are counting in circular way even if they are seating in linear. \\n\\nThe number of students remain are\\nn - 1 = 7 - 1 = 6\\n\\nStarting from 4 the next friend to loose will be at index 0\\n\\n![image.png](https://assets.leetcode.com/users/images/2821b9b5-ea44-43d3-ab13-6289a6b2dc34_1669363225.32804.png)\\n\\n### In linear way\\n\\n![image.png](https://assets.leetcode.com/users/images/b51242ec-1a48-428a-8cfe-831d632380d7_1669363437.5197673.png)\\n\\nThere are 6 friends now seating in circular fashion and their indices are\\n4 5 6 0 1 2\\nSo we need to find out which friend will leave the queue if there are 6 friends and k is 4. (k has not changed.)\\n\\n![image.png](https://assets.leetcode.com/users/images/e5677ad2-a0e1-4e4c-a7e5-71b54407da71_1669363806.16414.png)\\n\\nKeep faith in recursion that it will return correct result for n=6 and k=4\\n\\nbut after the results will be returned we need to find out the relation between our current indices and index returned from the recursion.\\n\\nObserving first 3 element we can observe that after adding 4 to the indices are n=6 we can get indices of level n=7\\n\\n![image.png](https://assets.leetcode.com/users/images/a38d40f1-375c-4e1c-94f8-cafbccfdb251_1669364000.7314184.png)\\n\\nNow to iterate over start index again we will use modulus as it is circular queue.\\n\\nwe are at level n=7 , k = 4\\nthe formula for conversion will be \\n#### (findTheWinner(n-1) + k) % n\\n\\n![image.png](https://assets.leetcode.com/users/images/dbad1e65-d9f2-4556-bbca-f408d2c8f3c4_1672772120.906986.png)\\n\\n\\nThus we can retrieve the indices from the n-1 levels.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        return self.helper(n,k)+1\\n\\n    def helper(self, n:int, k:int)-> int:\\n        if(n==1):\\n            return 0\\n        prevWinner = self.helper(n-1, k)\\n        return (prevWinner + k) % n\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        return self.helper(n,k)+1\\n\\n    def helper(self, n:int, k:int)-> int:\\n        if(n==1):\\n            return 0\\n        prevWinner = self.helper(n-1, k)\\n        return (prevWinner + k) % n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149752,
                "title": "c-josephus-problem-best-explanation-recursion-queue",
                "content": "We need to return the last person standing after every ```k```th person leaves the circle.\\n\\n* Let\\'s say ```n = 6``` and ```k = 2```. \\n\\n* After killing the person standing at position ```2```, there are ```5``` people remaining. So we can solve this problem by calling ```f (5, 2)```.\\n\\n* But there\\'s a catch here. While solving the problem with ```5``` people and ```k = 2```, we start from at position ```1```. \\n\\n* But for ```f (6, 2)```, after killing ```2```, we start from ```3```. \\n\\n* See the image below:\\n![image](https://assets.leetcode.com/users/images/f904aba6-4dd4-4faa-b0cf-6e9c8d35ab15_1655183599.8877122.png)\\n\\n* So we need to convert the ```1``` of ```f (5, 2)``` to ```3```, ```2``` to ```4```, ```3``` to ```5```, ```4``` to ```6``` and ```5``` to ```1```.\\n\\n* Try doing ```(k-1)%n + 1```. It works!.\\n\\n* So we\\'ve defined the recursion function: ```f(n, k) = ( f(n-1, k) + (k-1) )%n + 1```.\\n\\n* Ofcourse``` f(1, k) = 1``` is the base condition.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n == 1) return 1;\\n        \\n        return (findTheWinner(n-1, k) + k-1) % n + 1;\\n    }\\n};\\n```\\n\\n**QUEUE:**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1; i<=n; i++) q.push(i);\\n        \\n        while(q.size() > 1) {\\n            int i = k;\\n            while(i > 1) {\\n                auto f = q.front(); q.pop();\\n                q.push(f);\\n                i--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Queue"
                ],
                "code": "```k```\n```n = 6```\n```k = 2```\n```2```\n```5```\n```f (5, 2)```\n```5```\n```k = 2```\n```1```\n```f (6, 2)```\n```2```\n```3```\n```1```\n```f (5, 2)```\n```3```\n```2```\n```4```\n```3```\n```5```\n```4```\n```6```\n```5```\n```1```\n```(k-1)%n + 1```\n```f(n, k) = ( f(n-1, k) + (k-1) )%n + 1```\n``` f(1, k) = 1```\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n == 1) return 1;\\n        \\n        return (findTheWinner(n-1, k) + k-1) % n + 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1; i<=n; i++) q.push(i);\\n        \\n        while(q.size() > 1) {\\n            int i = k;\\n            while(i > 1) {\\n                auto f = q.front(); q.pop();\\n                q.push(f);\\n                i--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158697,
                "title": "java-simple-using-arraylist",
                "content": "```\\n   public int findTheWinner(int n, int k) {\\n     \\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            ans.add(i);\\n        }\\n        int cur=0;\\n        while(ans.size()>1){\\n            cur=(cur+k-1)%ans.size();\\n            ans.remove(cur);\\n        }\\n        return ans.get(0);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   public int findTheWinner(int n, int k) {\\n     \\n        List<Integer>ans=new ArrayList<>();\\n        for(int i=1;i<=n;i++){\\n            ans.add(i);\\n        }\\n        int cur=0;\\n        while(ans.size()>1){\\n            cur=(cur+k-1)%ans.size();\\n            ans.remove(cur);\\n        }\\n        return ans.get(0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2254512,
                "title": "c-simple-approach-using-josephus-solution-tc-o-n",
                "content": "int findTheWinner(int n, int k) {\\n        \\n        if(n==1) return n;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n            \\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "int findTheWinner(int n, int k) {\\n        \\n        if(n==1) return n;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n            \\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1152433,
                "title": "clean-python-3-doubly-linked-list-o-nk",
                "content": "Time: `O(nk)`\\nSpace: `O(n)`\\n```\\nclass ListNode(object):\\n    def __init__(self, val, prev=None, next=None):\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        head = prev = ListNode(1)\\n        for i in range(2, n+1):\\n            node = ListNode(i)\\n            node.prev = prev\\n            prev.next = node\\n            prev = node\\n        head.prev = prev\\n        prev.next = head\\n        curr = head.prev\\n        while curr.next is not curr:\\n            for _ in range(k):\\n                curr = curr.next\\n            curr.prev.next = curr.next\\n            curr.next.prev = curr.prev\\n        return curr.val\\n```\\nSame idea with deque, credit to @JummyEgg\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = collections.deque(list(range(1, n + 1)))\\n        cnt = 0\\n        while len(q) > 1:\\n            cnt += 1\\n            val = q.popleft()\\n            if cnt % k: q.append(val)\\n        return q[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass ListNode(object):\\n    def __init__(self, val, prev=None, next=None):\\n        self.val = val\\n        self.prev = prev\\n        self.next = next\\n\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        head = prev = ListNode(1)\\n        for i in range(2, n+1):\\n            node = ListNode(i)\\n            node.prev = prev\\n            prev.next = node\\n            prev = node\\n        head.prev = prev\\n        prev.next = head\\n        curr = head.prev\\n        while curr.next is not curr:\\n            for _ in range(k):\\n                curr = curr.next\\n            curr.prev.next = curr.next\\n            curr.next.prev = curr.prev\\n        return curr.val\\n```\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = collections.deque(list(range(1, n + 1)))\\n        cnt = 0\\n        while len(q) > 1:\\n            cnt += 1\\n            val = q.popleft()\\n            if cnt % k: q.append(val)\\n        return q[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633909,
                "title": "java-intuitive-solution-queue-approach-faster-than-95-easiest",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer>qu=new LinkedList<>() ;\\n        for(int i=1;i<=n;i++)\\n        {\\n            qu.offer(i);\\n        }\\n        while (qu.size()!=1)\\n        {\\n            for(int i=1;i<=k-1;i++)\\n            {\\n                qu.offer(qu.poll());\\n            }\\n            qu.poll();\\n        }\\n        return qu.poll();\\n    }\\n}\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer>qu=new LinkedList<>() ;\\n        for(int i=1;i<=n;i++)\\n        {\\n            qu.offer(i);\\n        }\\n        while (qu.size()!=1)\\n        {\\n            for(int i=1;i<=k-1;i++)\\n            {\\n                qu.offer(qu.poll());\\n            }\\n            qu.poll();\\n        }\\n        return qu.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321253,
                "title": "c-easy-solution-queue",
                "content": "```\\nint findTheWinner(int n, int k) {\\n        queue<int> q;\\n        //pushing the elements from 1 to k in a queue\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()>1){\\n            int temp=k;    \\n            for(temp=k;temp>1;temp--){\\n                int first=q.front();\\n                q.pop();\\n                q.push(first);\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n\\n\\n**Please Upvote if it was helpful**",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nint findTheWinner(int n, int k) {\\n        queue<int> q;\\n        //pushing the elements from 1 to k in a queue\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()>1){\\n            int temp=k;    \\n            for(temp=k;temp>1;temp--){\\n                int first=q.front();\\n                q.pop();\\n                q.push(first);\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n\\n\\n**Please Upvote if it was helpful**",
                "codeTag": "Unknown"
            },
            {
                "id": 1152581,
                "title": "java-1-liner-josephus-problem",
                "content": "# Just one line of code\\nThis is a standard Josephus problem. To learn more about it, visit [Josephus Problem](https://en.wikipedia.org/wiki/Josephus_problem#:~:text=In%20computer%20science%20and%20mathematics,a%20certain%20counting%2Dout%20game.). \\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return (n == 1) ? 1 : (findTheWinner(n - 1, k) + k - 1) % n + 1;\\n    }\\n}\\n```\\n\\n`Time Complexity : O(n)`",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return (n == 1) ? 1 : (findTheWinner(n - 1, k) + k - 1) % n + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726522,
                "title": "java-similar-to-josephus-problem",
                "content": "At first problem seems to be simple but circular sitting arrangement makes it a bit complex.\\n\\nTake a look to the given example:\\n**Tricky part** is to handle the ignoring part that once the number/node is removed how will our code come to know that it is removed from the game. \\n\\n\\n![image](https://assets.leetcode.com/users/images/813244c8-3213-4f8c-b76e-a1a31d84500c_1666285853.7795105.png)\\n\\nIf you draw all values of n from 1 to 5 with k = 2 to **understand the pattern** to be used for recursion \\n```\\nsolve(n, k) depends upon previous step, i.e. solve(n - 1, k), \\nsolve(n, k) = (solve(n - 1, k) + k) but what if it result in value greater than n? Then if it result in greater value then we will use mod of n with it \\n\\nn = 1, k = 2 --> winner = 1\\n\\tsolve(1, 2) = (0 + 2) % 1 = 0\\n\\nn = 2, k = 2 --> winner = 1\\n\\tsolve(2, 2) --> (solve(1, 2) + k) % n = (1 + 2) % 2 = 1 \\n\\nn = 3, k = 2 --> winner = 3\\n\\tsolve(3, 2) --> (solve(2, 2) + k) % n = (1 + 2) = 3\\n\\t\\nn = 4, k = 2 --> winner = 1\\n\\tsolve(4, 2) --> (solve(3, 2) + k) % n = (3 + 2) % 4 = 1\\n\\t\\nn = 5, k = 2 --> winner = 3\\n\\tsolve(5, 2) --> (solve(4, 2) + k) % n = (1 + 2) = 3\\n\\n```\\nCode\\n```\\nclass Solution {\\n    static int solve(int n, int k) {\\n\\t    /* if there is only one friend left */\\n        if (n == 1)\\n            return 0; \\n        return (solve(n - 1, k) + k) % n;\\n    }\\n    public int findTheWinner(int n, int k) {\\n         return solve(n, k) + 1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nsolve(n, k) depends upon previous step, i.e. solve(n - 1, k), \\nsolve(n, k) = (solve(n - 1, k) + k) but what if it result in value greater than n? Then if it result in greater value then we will use mod of n with it \\n\\nn = 1, k = 2 --> winner = 1\\n\\tsolve(1, 2) = (0 + 2) % 1 = 0\\n\\nn = 2, k = 2 --> winner = 1\\n\\tsolve(2, 2) --> (solve(1, 2) + k) % n = (1 + 2) % 2 = 1 \\n\\nn = 3, k = 2 --> winner = 3\\n\\tsolve(3, 2) --> (solve(2, 2) + k) % n = (1 + 2) = 3\\n\\t\\nn = 4, k = 2 --> winner = 1\\n\\tsolve(4, 2) --> (solve(3, 2) + k) % n = (3 + 2) % 4 = 1\\n\\t\\nn = 5, k = 2 --> winner = 3\\n\\tsolve(5, 2) --> (solve(4, 2) + k) % n = (1 + 2) = 3\\n\\n```\n```\\nclass Solution {\\n    static int solve(int n, int k) {\\n\\t    /* if there is only one friend left */\\n        if (n == 1)\\n            return 0; \\n        return (solve(n - 1, k) + k) % n;\\n    }\\n    public int findTheWinner(int n, int k) {\\n         return solve(n, k) + 1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051013,
                "title": "simple-recursion-josephus-problem-aditya-verma",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    //Josephus Problem\\n    \\n    void solve(int i ,int k , vector<int> &v, int &ans)\\n    {\\n        if(v.size()==1)\\n        {\\n            ans = v[0];\\n            return;\\n        }\\n        \\n        // index moves around to kill\\n        i = (i+k)%v.size();\\n        v.erase(v.begin() + i);        \\n        \\n        solve( i, k , v ,ans);\\n        \\n    }\\n    \\n    int findTheWinner(int n, int k) {\\n        \\n    vector<int> v(n,0);\\n    \\n    for(int i =0; i<n; i++) v[i] = i+1;\\n    k--;\\n    \\n    int ans;\\n    \\n    solve(0,k,v,ans);\\n    return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    //Josephus Problem\\n    \\n    void solve(int i ,int k , vector<int> &v, int &ans)\\n    {\\n        if(v.size()==1)\\n        {\\n            ans = v[0];\\n            return;\\n        }\\n        \\n        // index moves around to kill\\n        i = (i+k)%v.size();\\n        v.erase(v.begin() + i);        \\n        \\n        solve( i, k , v ,ans);\\n        \\n    }\\n    \\n    int findTheWinner(int n, int k) {\\n        \\n    vector<int> v(n,0);\\n    \\n    for(int i =0; i<n; i++) v[i] = i+1;\\n    k--;\\n    \\n    int ans;\\n    \\n    solve(0,k,v,ans);\\n    return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472212,
                "title": "c-josephus-problem-recursion-with-explanation",
                "content": "//In the given test case when 2 gets removed we are left with 3 4 5 1 now we will change the numbering of 3 4 5 1 //to 1 2 3 4 respectively and it will happen for all calls until n==1.Now while going back in  recursion we change //the numbers back to their original value using the formula **((ans+k-1)%n)+1**\\n\\n//if we started the count from 0 instead of 1, then the formula would have been **(ans+k)%n**\\n\\n\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        else{\\n        int ans=findTheWinner(n-1,k);\\n        int finalans=((ans+k-1)%n)+1;\\n        return finalans;\\n    }\\n    }\\n};\\n\\t//pls upvote if you like my solution :)",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1152461,
                "title": "java-list-solution",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for( int i = 0; i < n; i++ ){\\n            list.add(i+1);\\n        }\\n       \\n        return eliminate(list, 0, k-1);\\n    }\\n    private int eliminate(List<Integer> list, int start, int k){\\n        if(list.size() == 1)\\n            return list.get(0);\\n        start = (start+k) % list.size();\\n        list.remove(start);\\n        return eliminate(list, start, k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for( int i = 0; i < n; i++ ){\\n            list.add(i+1);\\n        }\\n       \\n        return eliminate(list, 0, k-1);\\n    }\\n    private int eliminate(List<Integer> list, int start, int k){\\n        if(list.size() == 1)\\n            return list.get(0);\\n        start = (start+k) % list.size();\\n        list.remove(start);\\n        return eliminate(list, start, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403097,
                "title": "find-the-winner-of-circular-game-josephus-problem-java-recursive-approach",
                "content": "```\\nclass Solution {\\n    int output = -1;\\n    \\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tlist.add(i + 1);\\n\\t\\t}\\n        permutationFind(n, k - 1, 0, list);\\n\\t\\treturn output;\\n    }\\n    \\n    public void permutationFind(int n, int k, int index, ArrayList<Integer> list) {\\n        /* base condition */\\n\\t\\tif (n == 1) {\\n\\t\\t\\toutput = list.get(0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n        index = (index + k) % list.size();\\n\\t\\tlist.remove(index);\\n\\n        /* hypothesis */\\n\\t\\tpermutationFind(n - 1, k, index, list);\\n\\t}\\n}\\n```\\n\\nIf it helped, please UPVOTE .\\nHappy Coding and keep up the good work :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int output = -1;\\n    \\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tlist.add(i + 1);\\n\\t\\t}\\n        permutationFind(n, k - 1, 0, list);\\n\\t\\treturn output;\\n    }\\n    \\n    public void permutationFind(int n, int k, int index, ArrayList<Integer> list) {\\n        /* base condition */\\n\\t\\tif (n == 1) {\\n\\t\\t\\toutput = list.get(0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n        index = (index + k) % list.size();\\n\\t\\tlist.remove(index);\\n\\n        /* hypothesis */\\n\\t\\tpermutationFind(n - 1, k, index, list);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331147,
                "title": "c-iterative-and-recursive-solution-100-faster",
                "content": "Iterative\\n```\\n  /*josephus problem*/\\nclass Solution {\\npublic:\\n    int res=0;\\n    int findTheWinner(int n, int k) {\\n      \\n     \\n        for(int i=1;i<=n;i++)\\n        {\\n            res=(res+k)%i;\\n        }\\n    return res+1;\\n    }\\n};\\n```\\n\\nRecursion\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int>v;\\n        for(int i=1;i<=n;i++)\\n            v.push_back(i);\\n        \\n        solve(v,k-1,0);\\n        \\n        return v[0];\\n    }\\n    \\n    void solve(vector<int>&v, int k, int i)\\n    {\\n        if(v.size()==1)\\n            return ;\\n        \\n        int index = (i+k)%v.size();\\n        v.erase(v.begin()+index);\\n        solve(v,k,index) ;\\n        return ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  /*josephus problem*/\\nclass Solution {\\npublic:\\n    int res=0;\\n    int findTheWinner(int n, int k) {\\n      \\n     \\n        for(int i=1;i<=n;i++)\\n        {\\n            res=(res+k)%i;\\n        }\\n    return res+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int>v;\\n        for(int i=1;i<=n;i++)\\n            v.push_back(i);\\n        \\n        solve(v,k-1,0);\\n        \\n        return v[0];\\n    }\\n    \\n    void solve(vector<int>&v, int k, int i)\\n    {\\n        if(v.size()==1)\\n            return ;\\n        \\n        int index = (i+k)%v.size();\\n        v.erase(v.begin()+index);\\n        solve(v,k,index) ;\\n        return ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315446,
                "title": "c-josephus-problem-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n        if (n == 1)\\n            return n;\\n        return (((findTheWinner(n - 1, k) + k - 1 ) % n) + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n        if (n == 1)\\n            return n;\\n        return (((findTheWinner(n - 1, k) + k - 1 ) % n) + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152946,
                "title": "java-queue",
                "content": "```\\npublic int findTheWinner(int n, int k) {\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor(int i=1;i<=n;i++) queue.offer(i);\\n\\twhile(queue.size() > 1) {\\n\\t\\tfor(int i=0;i<k-1;i++)\\n\\t\\t\\tqueue.offer(queue.poll());\\n\\t\\tqueue.poll();\\n\\t}\\n\\treturn queue.poll();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTheWinner(int n, int k) {\\n\\tQueue<Integer> queue = new LinkedList<>();\\n\\tfor(int i=1;i<=n;i++) queue.offer(i);\\n\\twhile(queue.size() > 1) {\\n\\t\\tfor(int i=0;i<k-1;i++)\\n\\t\\t\\tqueue.offer(queue.poll());\\n\\t\\tqueue.poll();\\n\\t}\\n\\treturn queue.poll();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152488,
                "title": "python-one-loop-with-slicing",
                "content": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        r, i = [e for e in range(1,n+1)], 0\\n        while len(r)>1:\\n            i = (i+k-1)%len(r)\\n            r = r[:i]+r[i+1:]\\n        return r[-1]\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        r, i = [e for e in range(1,n+1)], 0\\n        while len(r)>1:\\n            i = (i+k-1)%len(r)\\n            r = r[:i]+r[i+1:]\\n        return r[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152472,
                "title": "c-using-recursion-only-3-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648100,
                "title": "3-lines-solution-better-than-100-in-runtime-better-than-98-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we know winner of n - 1 friends, we can easily know the winner of n friends.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake the example as n = 5 and k = 3:\\nif only 1 person had been there, then winner = 1\\nnow 2nd person comes, move two times: 1 -> 2 -> 1 -> 2 winner = 2\\nnow 3rd person comes, move two times: 1 -> 2 -> 3 -> 1 winner = 1\\nnow 4th person comes, move two times: 3 -> 4 -> 1 -> 2 winner = 2\\nnow 5th person comes, move two times: 1 -> 2 -> 3 -> 4 winner = 4\\n\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            ans = (ans + k) % i;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            ans = (ans + k) % i;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788850,
                "title": "c-winner-of-the-circular-game-using-queue-itretive-approach",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()>1){\\n            int x=k;\\n            while(x>1){\\n                int f=q.front();\\n                q.pop();\\n                q.push(f);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\nif it helps plzz don\\'t forget to upvote it :)\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()>1){\\n            int x=k;\\n            while(x>1){\\n                int f=q.front();\\n                q.pop();\\n                q.push(f);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\nif it helps plzz don\\'t forget to upvote it :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666619,
                "title": "c-iterative-solution-with-linear-space-complexity",
                "content": "# Intuition\\nThink about the recursive approach\\n\\n# Approach\\nBasically, we know that at last, who ever gets the kth turn is lost. Now this k is including the current player, so if the current player is x, we know x+k, will be the person just after person eliminated. At last, the person \\'just after the person eliminated\\' on the table will be the winner. So in the recursion, one can say that base condition is number of players (n) == 1, so answer is the player sitting at index 0. For rest of the number of players (2 to n), we know that answer will be-> F(n) = (F(n-1)+k)%n, so we can have a recursion for that, but recursion stack will make space complexity O(n). So instead of recursion we have an iterative approach. \\nAtlast, add +1 to the index found, cause our index starts from 0 but player\\'s index starts from 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int n, int k)\\n    {\\n        int ans = 0;\\n        for(int i=2; i<=n; i++)\\n            ans = (ans+k)%i;\\n        return ans;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n, k)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int n, int k)\\n    {\\n        int ans = 0;\\n        for(int i=2; i<=n; i++)\\n            ans = (ans+k)%i;\\n        return ans;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return helper(n, k)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561365,
                "title": "java-easy-arraylist-clean-readable-easy-understanding-code-josephus-problem",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        for(int i=1;i<=n;i++) al.add(i);\\n        int index=0;\\n        while(al.size()>1){\\n            index=(index+k-1)%(al.size());\\n            al.remove(index);\\n        }\\n        return al.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        for(int i=1;i<=n;i++) al.add(i);\\n        int index=0;\\n        while(al.size()>1){\\n            index=(index+k-1)%(al.size());\\n            al.remove(index);\\n        }\\n        return al.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528009,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        k = k-1\\n        index = 0\\n        li = [i for i in range(1,n+1)]\\n        def cal(k,index):\\n            if len(li) == 1:\\n                return li[0]\\n            index = (index + k)% len(li)\\n            del li[index]\\n            return cal(k,index)\\n        return cal(k,index)\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        k = k-1\\n        index = 0\\n        li = [i for i in range(1,n+1)]\\n        def cal(k,index):\\n            if len(li) == 1:\\n                return li[0]\\n            index = (index + k)% len(li)\\n            del li[index]\\n            return cal(k,index)\\n        return cal(k,index)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043294,
                "title": "c-recursive-approach-easy-to-understand",
                "content": "**//PLEASE UPVOTE IF IT IS HELPFUL**\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840889,
                "title": "4-solutions",
                "content": "**straightforward simulation/tombstones**\\n**time: `O(n*n)`; space: `O(n)`**\\n![image](https://assets.leetcode.com/users/images/5510dad9-fe1d-4860-a75a-18e8353c4a37_1647281429.7793665.png)\\n\\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tint t{};\\n\\tfor(int m{n}, v[500]{} ; m; --m)\\n\\t{           \\n\\t\\tfor(int c{k-1}; c; t=(t+1)%n)\\n\\t\\t\\tc -= 1-v[t];\\n\\t\\tfor( ; v[t]; t=(t+1)%n);\\n\\t\\tv[t] = 1;\\n\\t}\\n\\treturn t+1;\\n}\\n```\\n**\"linked-list\" simulation**\\n**time: `O(n*k)`; space: `O(n)`**\\n![image](https://assets.leetcode.com/users/images/c3b694a7-3c41-4b81-be8e-9558877b315e_1647281583.6727467.png)\\n\\n\\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tif(k==1) return n;\\n\\tint v[500]{};\\n\\tiota(begin(v), begin(v)+n-1, 1);\\n\\n\\tint t{};\\n\\tfor( ; v[t]!=t; )\\n\\t{   \\n\\t\\tfor(int i{k-1}; --i; t = v[t]);\\n\\t\\tt = v[t] = v[v[t]];\\n\\t}\\n\\treturn t+1;\\n}\\n```\\n**dp/recursion/top-bottom**\\n**time: `O(n)`; space: `O(n)(recursion stack)`**\\n![image](https://assets.leetcode.com/users/images/87890844-e9a0-4673-b294-bfe1bb76829d_1647278821.084183.png)\\n\\n```\\nint findTheWinner(int n, int k) \\n{\\n   return n==1 ? 1 : (findTheWinner(n-1, k)+k-1)%n+1;\\n}\\n```\\n**dp/iteration/bottom-top**\\n**time: `O(n)`; space: `O(1)`**\\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tint out{1};\\n\\tfor(int i{2}; i<=n; ++i)\\n\\t\\tout = (out+k-1)%i+1;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint findTheWinner(int n, int k) \\n{\\n\\tint t{};\\n\\tfor(int m{n}, v[500]{} ; m; --m)\\n\\t{           \\n\\t\\tfor(int c{k-1}; c; t=(t+1)%n)\\n\\t\\t\\tc -= 1-v[t];\\n\\t\\tfor( ; v[t]; t=(t+1)%n);\\n\\t\\tv[t] = 1;\\n\\t}\\n\\treturn t+1;\\n}\\n```\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tif(k==1) return n;\\n\\tint v[500]{};\\n\\tiota(begin(v), begin(v)+n-1, 1);\\n\\n\\tint t{};\\n\\tfor( ; v[t]!=t; )\\n\\t{   \\n\\t\\tfor(int i{k-1}; --i; t = v[t]);\\n\\t\\tt = v[t] = v[v[t]];\\n\\t}\\n\\treturn t+1;\\n}\\n```\n```\\nint findTheWinner(int n, int k) \\n{\\n   return n==1 ? 1 : (findTheWinner(n-1, k)+k-1)%n+1;\\n}\\n```\n```\\nint findTheWinner(int n, int k) \\n{\\n\\tint out{1};\\n\\tfor(int i{2}; i<=n; ++i)\\n\\t\\tout = (out+k-1)%i+1;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1839508,
                "title": "python-solution",
                "content": "Here\\'s my solution:\\n```\\n# Runtime: 45 ms, faster than 77.07% of Python3 online submissions for Find the Winner of the Circular Game.\\n# Memory Usage: 13.9 MB, less than 61.73% of Python3 online submissions for Find the Winner of the Circular Game.\\nclass Solution:\\n    def findTheWinner(self, n, k):\\n        result, start = [i for i in range(1,n+1)], 0\\n        while len(result)>1:\\n            loser = (start+k-1)%len(result)\\n            del result[loser]\\n            start = loser if loser<=len(result) else 0\\n        return result[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Runtime: 45 ms, faster than 77.07% of Python3 online submissions for Find the Winner of the Circular Game.\\n# Memory Usage: 13.9 MB, less than 61.73% of Python3 online submissions for Find the Winner of the Circular Game.\\nclass Solution:\\n    def findTheWinner(self, n, k):\\n        result, start = [i for i in range(1,n+1)], 0\\n        while len(result)>1:\\n            loser = (start+k-1)%len(result)\\n            del result[loser]\\n            start = loser if loser<=len(result) else 0\\n        return result[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829183,
                "title": "c-solution-with-comments-and-example-using-queue-easy-and-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(k == 1)\\n            return n;\\n        queue<int> q; // store friends from 1 to n\\n        for(int i = 1; i <= n; i++)\\n            q.push(i);\\n        int count = 1, temp;\\n        while(!q.empty() && q.size() > 1){\\n            if(count == k){ // leaves the circle\\n                q.pop();\\n                count = 1;\\n            }//end if\\n            else{\\n                temp = q.front();\\n                q.pop();\\n                q.push(temp); // make circle via move the front to the end \\n                count++;\\n            }//end else\\n        }//end while\\n        return q.front();\\n    }\\n};\\n\\n/*\\nFor example :\\nn = 5, k = 2\\n---------------\\nq = {1, 2, 3, 4, 5} count = 1 \\n1) q = {2, 3, 4, 5, 1} count++\\n2) q = {3, 4, 5, 1}    Friend 2 leaves ---> count = 1\\n3) q = {4, 5, 1, 3}    count++\\n4) q = {5, 1, 3}       Friend 4 leaves---> count = 1\\n5) q = {1, 3, 5}       count++\\n6) q = {3, 5}          Friend 1 leaves ---> count = 1 \\n6) q = {3}             Friend 5 leaves ---> count = 1 \\nfriend 3 is left, so they are the winner\\n*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(k == 1)\\n            return n;\\n        queue<int> q; // store friends from 1 to n\\n        for(int i = 1; i <= n; i++)\\n            q.push(i);\\n        int count = 1, temp;\\n        while(!q.empty() && q.size() > 1){\\n            if(count == k){ // leaves the circle\\n                q.pop();\\n                count = 1;\\n            }//end if\\n            else{\\n                temp = q.front();\\n                q.pop();\\n                q.push(temp); // make circle via move the front to the end \\n                count++;\\n            }//end else\\n        }//end while\\n        return q.front();\\n    }\\n};\\n\\n/*\\nFor example :\\nn = 5, k = 2\\n---------------\\nq = {1, 2, 3, 4, 5} count = 1 \\n1) q = {2, 3, 4, 5, 1} count++\\n2) q = {3, 4, 5, 1}    Friend 2 leaves ---> count = 1\\n3) q = {4, 5, 1, 3}    count++\\n4) q = {5, 1, 3}       Friend 4 leaves---> count = 1\\n5) q = {1, 3, 5}       count++\\n6) q = {3, 5}          Friend 1 leaves ---> count = 1 \\n6) q = {3}             Friend 5 leaves ---> count = 1 \\nfriend 3 is left, so they are the winner\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670710,
                "title": "recursive-solution-java",
                "content": "In this problem it can be clearly seen we need to divide it into further subproblems.\\nHence recursive approach is mostly followed.\\nFirst, we need to find the kth element.\\nIt can be simply found by the formula `(k+start)%n` where start is the position to start counting.\\nSince this position changes after every pass we will follow a reverse recursive approach i.e. implement recursion in a way such that the functional calls when popped from stack simulate the entire procedure.\\nThus, we will keep the base condition to return 0 so that the start initially is 0.\\nAnd then calculate.\\nThe code is as follows :\\n```\\n    class Solution {\\n        public int findTheWinner(int n, int k) {\\n            return helper(n,k)+1;\\n        }\\n        public int helper(int size, int k){\\n            if(size==1)return 0;\\n            return (helper(size-1,k)+k)%size;\\n        }\\n    }\\n```\\nPlease upvote if you found this helpful :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    class Solution {\\n        public int findTheWinner(int n, int k) {\\n            return helper(n,k)+1;\\n        }\\n        public int helper(int size, int k){\\n            if(size==1)return 0;\\n            return (helper(size-1,k)+k)%size;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571615,
                "title": "simple-c-solution-0ms-100-with-2-ways-just-2-lines",
                "content": "Solution using recursion\\nn = 2 -> the winner index is (0 + k) % 2 (base-0)\\nn = 3 -> the winner index is (f(2) + k) % 3 (base-0)\\nwith n -> the winner index is (f(n-1) + k) % n (base-0)\\n\\n```\\nint findTheWinner(int n, int k){\\n    if(n == 1) return 1;\\n    return (findTheWinner(n-1, k) + k - 1) % n + 1;\\n}\\n```\\n\\nSolution with linear time, O(1) extra space\\n```\\nint findTheWinner(int n, int k){\\n    int result = 0;\\n    for(int i = 1; i<=n; ++i)\\n        result = (result + k) % i;\\n    return result + 1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint findTheWinner(int n, int k){\\n    if(n == 1) return 1;\\n    return (findTheWinner(n-1, k) + k - 1) % n + 1;\\n}\\n```\n```\\nint findTheWinner(int n, int k){\\n    int result = 0;\\n    for(int i = 1; i<=n; ++i)\\n        result = (result + k) % i;\\n    return result + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1549751,
                "title": "python-deque",
                "content": "Idea is to rotate deque k times, and delete the last element\\n\\n```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n       \\n        d = collections.deque([i for i in range(1, n + 1)])\\n        while(len(d) != 1):\\n            d.rotate(-k)\\n            d.pop()\\n        return d.pop() \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n       \\n        d = collections.deque([i for i in range(1, n + 1)])\\n        while(len(d) != 1):\\n            d.rotate(-k)\\n            d.pop()\\n        return d.pop() \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345985,
                "title": "java-josephus-problem-solution",
                "content": "This question is also known as **Josephus problem**.\\nThis problem states that:-\\n*there are **n** people standing in a circle waiting to be executed. The counting out begins at some point in the circle and proceeds around the circle in a fixed direction. In each step, a certain number of people are skipped and the next person is executed. The elimination proceeds around the circle (which is becoming smaller and smaller as the executed people are removed), until only the last person remains, who is given freedom. Given the total number of persons **n** and a number  **k** which indicates that **k-1** persons are skipped and kth person is killed in circle. The task is to choose the place in the initial circle so that you are the last one remaining and so survive.*\\n Now we\\'ll use recursion as follows\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        if (n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k) + k - 1) % n + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        if (n==1)\\n            return 1;\\n        else\\n            return (findTheWinner(n-1,k) + k - 1) % n + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337153,
                "title": "queue-solution-c",
                "content": "**I was wondering if anyone had a solution using queue but couldn\\'t find one recently. So, here\\'s mine with queue implementation in C++, though it is not so fast.**\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1; i<=n; i++) {\\n            q.push(i);\\n        }\\n        while(q.size() > 1) {\\n            for(int i=1; i<k; i++) {\\n               int x = q.front();\\n               q.pop();\\n               q.push(x);\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1; i<=n; i++) {\\n            q.push(i);\\n        }\\n        while(q.size() > 1) {\\n            for(int i=1; i<k; i++) {\\n               int x = q.front();\\n               q.pop();\\n               q.push(x);\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985873,
                "title": "beginner-friendly-simple-solution-with-using-queue-ds-on-python3",
                "content": "# Intuition\\nLet\\'s briefly explain the task and provide some `pseudocode`:\\n```\\n# There\\'re n-friends, playing a game\\nfriends = [1,2,3,4,5]\\n\\n# at each step there\\'s an option to SKIP some players in order\\nn = 2\\ni = 0\\n\\n# to EXCLUDE the player, that the pointer has stopped on\\n# [1, (2), 3, 4, 5]\\n# i=1 i=2==k\\n\\nfriends = [1, 3, 4, 5]\\n\\n# the process continues UNTIL there will only ONE player\\nfriends = [3]\\n```\\nThis example leads us to create a `queue`, that\\'ll represent a source of players, that will leave the `queue`, when the `i` **points** at a particular player.\\n\\n# Approach\\n1. initialize a `q` and map `x+1` to the current player\\n2. create a loop, that\\'ll stop, when there\\'ll only **one player** inside of a `q`\\n3. at each `c = k-1` step exclude the participant, and continue to iterate\\n4. once there\\'is only one player, return it\\'s index from `q`\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = deque([x + 1 for x in range(n)])\\n\\n        while len(q) > 1:\\n            c = k - 1\\n\\n            while c:\\n                q.append(q.popleft())\\n                c -= 1\\n            \\n            q.popleft()\\n\\n        return q[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue"
                ],
                "code": "```\\n# There\\'re n-friends, playing a game\\nfriends = [1,2,3,4,5]\\n\\n# at each step there\\'s an option to SKIP some players in order\\nn = 2\\ni = 0\\n\\n# to EXCLUDE the player, that the pointer has stopped on\\n# [1, (2), 3, 4, 5]\\n# i=1 i=2==k\\n\\nfriends = [1, 3, 4, 5]\\n\\n# the process continues UNTIL there will only ONE player\\nfriends = [3]\\n```\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = deque([x + 1 for x in range(n)])\\n\\n        while len(q) > 1:\\n            c = k - 1\\n\\n            while c:\\n                q.append(q.popleft())\\n                c -= 1\\n            \\n            q.popleft()\\n\\n        return q[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446043,
                "title": "find-the-winner-of-the-circular-game-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int i, idx=0, x;\\n\\n        // Make a array and store the integers from 1 to n\\n        vector<int> nums;\\n        for(i=0 ; i<n ; i++)\\n        {\\n            nums.push_back(i+1);\\n        }\\n\\n        // In each iteration remove the element at position x and then update the value of x \\n        while(nums.size()>1)\\n        {\\n            x = (idx+k-1)%nums.size();\\n            nums.erase(nums.begin()+x);\\n            idx = (x)%nums.size();\\n        }\\n        return nums[0];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/555fb03e-4e6b-430c-9817-686986aeaa7f_1682612811.6249762.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int i, idx=0, x;\\n\\n        // Make a array and store the integers from 1 to n\\n        vector<int> nums;\\n        for(i=0 ; i<n ; i++)\\n        {\\n            nums.push_back(i+1);\\n        }\\n\\n        // In each iteration remove the element at position x and then update the value of x \\n        while(nums.size()>1)\\n        {\\n            x = (idx+k-1)%nums.size();\\n            nums.erase(nums.begin()+x);\\n            idx = (x)%nums.size();\\n        }\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303326,
                "title": "simple-python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        nums=[]\\n        for i in range(1,n+1):\\n            nums.append(i)\\n        j=0\\n        while len(nums)!=1:\\n           j=(j+k-1)%len(nums)\\n           nums.remove(nums[j])\\n        return nums[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        nums=[]\\n        for i in range(1,n+1):\\n            nums.append(i)\\n        j=0\\n        while len(nums)!=1:\\n           j=(j+k-1)%len(nums)\\n           nums.remove(nums[j])\\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964194,
                "title": "josephus-problem-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasily solved by Josephus\\' problem-solving method.\\nThe formula is (func(n-1,k)+k)%n; calculate in a recursive way and return the answer by adding 1, as 1 is the minimum number here.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\nAn iterative approach can solve it in O(1) SC.\\xA0\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,int k){\\n         if(n==1)return 0;\\n        return (((solve(n-1,k))+k)%n);\\n    }\\n    int findTheWinner(int n, int k) {\\n       return 1+solve(n,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,int k){\\n         if(n==1)return 0;\\n        return (((solve(n-1,k))+k)%n);\\n    }\\n    int findTheWinner(int n, int k) {\\n       return 1+solve(n,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749184,
                "title": "c-3-lines-easiest-approach",
                "content": "```\\n    int findTheWinner(int n, int k) {\\n        int ans =0;\\n        for(int i=1; i<=n; i++) ans = (ans+k)%i;\\n        return ans+1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int findTheWinner(int n, int k) {\\n        int ans =0;\\n        for(int i=1; i<=n; i++) ans = (ans+k)%i;\\n        return ans+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2736702,
                "title": "1ms-java-solution",
                "content": "```\\nclass Solution {\\n   public int findTheWinner(int n, int k) {\\n        return result(n, k - 1) + 1; // result here is finding the Winner Helper\\n    }\\n    \\n    private int result(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        return ((k + 1) % n + result(n - 1, k)) % n;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int findTheWinner(int n, int k) {\\n        return result(n, k - 1) + 1; // result here is finding the Winner Helper\\n    }\\n    \\n    private int result(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        return ((k + 1) % n + result(n - 1, k)) % n;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579859,
                "title": "queue-solution-python-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = deque(range(n))\\n        while len(q) > 1:\\n            for _ in range(k - 1):\\n                q.append(q.popleft())\\n            q.popleft()\\n        return q[0] + 1\\n    # Time: O(n * k)\\n    # Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        q = deque(range(n))\\n        while len(q) > 1:\\n            for _ in range(k - 1):\\n                q.append(q.popleft())\\n            q.popleft()\\n        return q[0] + 1\\n    # Time: O(n * k)\\n    # Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384915,
                "title": "java-josephus-problem-easy-recursion-approach-using-list",
                "content": "**Josephus Problem**\\n\\nEasy understanding recursive approach:\\n1. Create an **ArrayList** and initialize it with **1 to n**\\n2. Create a tracking variable **i** initially indexed at **0**\\n3. Call **help()** method to return; help() calls itself recursively\\n4. Move **i** to **(k-1)th** index from current position of i\\n5. remove **i th** element from list; therefore size of the list decreases\\n6. When we call it recursively and list size becomes 1, return the only left element of list\\n\\n```\\n /* Recursion using List */\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) list.add(i);\\n        return help(k, list, 0);\\n    }\\n    \\n    public int help(int k, List<Integer> list, int i){\\n        if(list.size() == 1) return list.get(0);\\n        i = (i + k - 1) % list.size();\\n        list.remove(i);\\n        return help(k, list, i);\\n    }\\n```\\n\\nHope it helps!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n /* Recursion using List */\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++) list.add(i);\\n        return help(k, list, 0);\\n    }\\n    \\n    public int help(int k, List<Integer> list, int i){\\n        if(list.size() == 1) return list.get(0);\\n        i = (i + k - 1) % list.size();\\n        list.remove(i);\\n        return help(k, list, i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2377190,
                "title": "python-simple-queue-solution-no-recursion",
                "content": "**<<< Do uptvote if you liked my solution. If you have any queries I am happy to answer.**\\n\\nInitial queue = [5, 4, 3, 2, 1]\\nk = 2\\n\\nPop and Push k-1 friends to the back of queue\\n[1, 5, 4, 3, 2]\\n\\nPop front element\\n[1, 5, 4, 3] --> **2** (looses)\\n\\nRepeat\\n[3, 1, 5, 4]\\n[3, 1, 5] --> **4**\\n\\n[5, 3, 1]\\n[5, 3] --> **1**\\n\\n[3, 5]\\n[3] --> **5**\\n\\nWinner **3**!!\\n\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        queue = list(range(n, 0, -1))    #Creates list of n to 1\\n        cur_k = k - 1\\n        while len(queue) != 1:\\n            while cur_k != 0:\\n                queue.insert(0, queue.pop())    #Popping front element and pushing it to the end of queue\\n                cur_k -= 1\\n            queue.pop()      #Popping the friend that looses\\n            cur_k = k - 1    #Resetting\\n        \\n        return queue.pop()   #Winner\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        queue = list(range(n, 0, -1))    #Creates list of n to 1\\n        cur_k = k - 1\\n        while len(queue) != 1:\\n            while cur_k != 0:\\n                queue.insert(0, queue.pop())    #Popping front element and pushing it to the end of queue\\n                cur_k -= 1\\n            queue.pop()      #Popping the friend that looses\\n            cur_k = k - 1    #Resetting\\n        \\n        return queue.pop()   #Winner\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374851,
                "title": "aditya-verma-c-solution-very-easy",
                "content": "class Solution {\\npublic:\\n    \\n   void solve(vector<int> v , int k , int index , int& ans)\\n    {\\n        //base case\\n        if(v.size()==1)\\n        {ans=v[0];\\n         return;\\n        }\\n       index =(index+k)%(v.size());\\n       v.erase(v.begin()+index);\\n       solve(v,k,index,ans);\\n    }\\n    \\n    \\n    \\n    \\n    int findTheWinner(int n, int k) {\\n        int ans=-1,index=0;k--;\\n        vector<int> v;\\n        for(int i=1;i<=n;i++)\\n         v.push_back(i);\\n        solve(v,k,index,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n   void solve(vector<int> v , int k , int index , int& ans)\\n    {\\n        //base case\\n        if(v.size()==1)\\n        {ans=v[0];\\n         return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2177733,
                "title": "learn-use-of-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        queue<int>q;\\n        int i;\\n        // so we are making queue and storing all the indexes in the queue\\n        for(i=1;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        // now the basic priniciple of queue tells that the the number pops onj doing q.pop is the least recent num,bner added means if i added some number in thje first that will be removed first basically opposite of stack in stck it is lifo last in first out but in queue fifo first in first out\\n        //so we will iterate till size of q is greater than 1\\n        while(q.size()>1)\\n        {\\n            //now we will do the operation of removinbg and adding till each just one before kth number\\n            for(i=1;i<k;i++)\\n            {\\n                int temp = q.front();\\n                // we are stroing it in temp variable because we want to remobve and then add it\\n                q.pop();\\n                // nikal gya ab fir se add kr denge\\n                q.push(temp);\\n                \\n            }\\n            q.pop();\\n            // yahha k th nbumber nikal jkaega kyuki usko dynamically add or remove hmlog nhi kiye\\n        }\\n        int res = q.front();\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        queue<int>q;\\n        int i;\\n        // so we are making queue and storing all the indexes in the queue\\n        for(i=1;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        // now the basic priniciple of queue tells that the the number pops onj doing q.pop is the least recent num,bner added means if i added some number in thje first that will be removed first basically opposite of stack in stck it is lifo last in first out but in queue fifo first in first out\\n        //so we will iterate till size of q is greater than 1\\n        while(q.size()>1)\\n        {\\n            //now we will do the operation of removinbg and adding till each just one before kth number\\n            for(i=1;i<k;i++)\\n            {\\n                int temp = q.front();\\n                // we are stroing it in temp variable because we want to remobve and then add it\\n                q.pop();\\n                // nikal gya ab fir se add kr denge\\n                q.push(temp);\\n                \\n            }\\n            q.pop();\\n            // yahha k th nbumber nikal jkaega kyuki usko dynamically add or remove hmlog nhi kiye\\n        }\\n        int res = q.front();\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913216,
                "title": "easy-c-solution-100-faster-self-explanatory",
                "content": "```\\n                      //Do upvote if this helps you :)\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k)\\n    {\\n        vector<int> v;\\n        int p=n;\\n        for(int i=1; i<=n; i++)\\n            v.push_back(i);\\n        k--;\\n        int j=0;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            v.erase(v.begin()+((k+j)%p));\\n            j=(k+j)%p;   \\n            p--; \\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n                      //Do upvote if this helps you :)\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k)\\n    {\\n        vector<int> v;\\n        int p=n;\\n        for(int i=1; i<=n; i++)\\n            v.push_back(i);\\n        k--;\\n        int j=0;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            v.erase(v.begin()+((k+j)%p));\\n            j=(k+j)%p;   \\n            p--; \\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851435,
                "title": "c-linked-list-approach-simple-solution-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        ListNode *prev = NULL;\\n        int x = 1;\\n        \\n        // making linked list from the array \\n        for(int i=n; i>=1; i--){\\n            ListNode *temp = new ListNode(i);\\n            temp->next = prev;\\n            prev = temp;\\n        }\\n        \\n        // making it circular linked list\\n        ListNode *head = prev, *curr = prev;\\n        while(head->next != NULL) \\n            head = head->next;\\n        head->next = prev;\\n        \\n        if(k == 1)\\n            return n; // best case\\n        \\n        while(n != 1){\\n            if(x == k-1){\\n                curr->next = curr->next->next; // deleting the friend of k position\\n                x = 1;\\n                n--;\\n            }else\\n                x++;\\n            curr = curr->next;\\n        }\\n        \\n        return curr->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        ListNode *prev = NULL;\\n        int x = 1;\\n        \\n        // making linked list from the array \\n        for(int i=n; i>=1; i--){\\n            ListNode *temp = new ListNode(i);\\n            temp->next = prev;\\n            prev = temp;\\n        }\\n        \\n        // making it circular linked list\\n        ListNode *head = prev, *curr = prev;\\n        while(head->next != NULL) \\n            head = head->next;\\n        head->next = prev;\\n        \\n        if(k == 1)\\n            return n; // best case\\n        \\n        while(n != 1){\\n            if(x == k-1){\\n                curr->next = curr->next->next; // deleting the friend of k position\\n                x = 1;\\n                n--;\\n            }else\\n                x++;\\n            curr = curr->next;\\n        }\\n        \\n        return curr->val;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1741852,
                "title": "3-java-solution-from-o-n-to-o-1-space-josephus-problem",
                "content": "For problem understanding watch ->\\nhttps://www.youtube.com/watch?v=uCsD3ZGzMgE&t=7s\\n# Recursive\\n```\\n public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tlist.add(i);\\n\\t\\t}\\n\\t\\treturn findTheWinner(0, k - 1, list);\\n\\t}\\n\\t//keep on removing till 1 element left\\n\\tprivate int findTheWinner(int start, int k, List<Integer> list) {\\n\\t\\tif (list.size() == 1) {\\n\\t\\t\\treturn list.get(0);\\n\\t\\t}\\n\\t\\t//index which needed to be removed.modulo used just to make with-in boundary of list\\n\\t\\tstart = (start + k) % list.size();\\n\\t\\tlist.remove(start);\\n\\t\\treturn findTheWinner(start, k, list);\\n\\t}\\n```\\n# Iterative\\n```\\npublic int findTheWinner(int n, int k) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\tfor(int i=1;i<=n;i++) {\\n\\t\\tlist.add(i);\\n\\t}\\n\\tint start=0;\\n\\tk--;\\n\\twhile(list.size()>1) {\\n\\t\\tstart=(start+k)%list.size();\\n\\t\\tlist.remove(start);\\n\\t}\\n\\treturn list.get(0);\\n}\\n```\\n\\n# Approach 3-> constant space\\nWe can optimize the code and can remove use of list. since we need to delete kth person always.\\n\\n```\\npublic int findTheWinner(int n, int k) {\\n\\tint start=0;\\n\\tfor(int i=1;i<=n;i++) {\\n\\t\\tstart=(start+k)%i;\\n\\t}\\n\\treturn start+1; //+1 is for converting 0-based index to 1-based index\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 1; i <= n; i++) {\\n\\t\\t\\tlist.add(i);\\n\\t\\t}\\n\\t\\treturn findTheWinner(0, k - 1, list);\\n\\t}\\n\\t//keep on removing till 1 element left\\n\\tprivate int findTheWinner(int start, int k, List<Integer> list) {\\n\\t\\tif (list.size() == 1) {\\n\\t\\t\\treturn list.get(0);\\n\\t\\t}\\n\\t\\t//index which needed to be removed.modulo used just to make with-in boundary of list\\n\\t\\tstart = (start + k) % list.size();\\n\\t\\tlist.remove(start);\\n\\t\\treturn findTheWinner(start, k, list);\\n\\t}\\n```\n```\\npublic int findTheWinner(int n, int k) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\tfor(int i=1;i<=n;i++) {\\n\\t\\tlist.add(i);\\n\\t}\\n\\tint start=0;\\n\\tk--;\\n\\twhile(list.size()>1) {\\n\\t\\tstart=(start+k)%list.size();\\n\\t\\tlist.remove(start);\\n\\t}\\n\\treturn list.get(0);\\n}\\n```\n```\\npublic int findTheWinner(int n, int k) {\\n\\tint start=0;\\n\\tfor(int i=1;i<=n;i++) {\\n\\t\\tstart=(start+k)%i;\\n\\t}\\n\\treturn start+1; //+1 is for converting 0-based index to 1-based index\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1635633,
                "title": "simple-java-solution-queue",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            q.offer(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i=1;i<k;i++)\\n                q.offer(q.poll());\\n            q.poll();\\n        }\\n     return q.poll();   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            q.offer(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i=1;i<k;i++)\\n                q.offer(q.poll());\\n            q.poll();\\n        }\\n     return q.poll();   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604228,
                "title": "simple-golang-solution",
                "content": "```\\nfunc findTheWinner(n int, k int) int {\\n\\tif n == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tm := []int{}\\n\\t// 0 based indexing\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm = append(m, i)\\n\\t}\\n\\n    start := 0\\n\\tfor len(m) != 1 {\\n\\t\\tout := (start + k - 1) % len(m)\\n\\t\\t// delete element at index k\\n\\t\\tm = append(m[:out], m[out+1:]...)\\n\\t\\tstart = out\\n\\t}\\n\\n\\treturn m[0] + 1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findTheWinner(n int, k int) int {\\n\\tif n == 1 {\\n\\t\\treturn 1\\n\\t}\\n\\n\\tm := []int{}\\n\\t// 0 based indexing\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tm = append(m, i)\\n\\t}\\n\\n    start := 0\\n\\tfor len(m) != 1 {\\n\\t\\tout := (start + k - 1) % len(m)\\n\\t\\t// delete element at index k\\n\\t\\tm = append(m[:out], m[out+1:]...)\\n\\t\\tstart = out\\n\\t}\\n\\n\\treturn m[0] + 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1592907,
                "title": "fastest-c-solution-time-complexity-0-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int jos(int n, int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (jos(n-1,k)+k)%n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return jos(n,k)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int jos(int n, int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (jos(n-1,k)+k)%n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return jos(n,k)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567505,
                "title": "python-linked-list",
                "content": "The idea is just simulate the game using the linked list. We pass through the list and remove every `k`th element until we left with just one element.\\n\\nTime: in worst case when `n` === `k` we have to scan whole list until we remove an element so complexity is **O(n*k)** \\nSpace: **O(n)** for the linked list\\n\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n\\t\\tclass Node:\\n\\t\\t\\tdef __init__(self, val):\\n\\t\\t\\t\\tself.val = val\\n\\t\\t\\t\\tself.next = None\\n\\t\\t\\t\\t\\n        if n == 1:\\n            return 1\\n\\t\\t\\t\\t\\n        # create linked list\\n        head = Node(1)\\n        cur = head\\n        for i in range(2, n + 1):\\n            cur.next = Node(i)\\n            cur = cur.next\\n        \\n\\t\\t# connect tail to the head to create a circle\\n        cur.next = head\\n        \\n        i = 1\\n\\t\\t# remove each kth element\\n        while cur != cur.next:   \\n            if i % k == 0:\\n                cur.next = cur.next.next # remove element\\n            else:\\n                cur = cur.next\\n                \\n            i += 1\\n            \\n        return cur.val\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n\\t\\tclass Node:\\n\\t\\t\\tdef __init__(self, val):\\n\\t\\t\\t\\tself.val = val\\n\\t\\t\\t\\tself.next = None\\n\\t\\t\\t\\t\\n        if n == 1:\\n            return 1\\n\\t\\t\\t\\t\\n        # create linked list\\n        head = Node(1)\\n        cur = head\\n        for i in range(2, n + 1):\\n            cur.next = Node(i)\\n            cur = cur.next\\n        \\n\\t\\t# connect tail to the head to create a circle\\n        cur.next = head\\n        \\n        i = 1\\n\\t\\t# remove each kth element\\n        while cur != cur.next:   \\n            if i % k == 0:\\n                cur.next = cur.next.next # remove element\\n            else:\\n                cur = cur.next\\n                \\n            i += 1\\n            \\n        return cur.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502654,
                "title": "c-josephus-problem",
                "content": "class Solution\\n{\\npublic:\\n\\n    void solve(vector<int> &v, int k, int cont_1)\\n    {\\n        if (v.size() == 1)\\n        {\\n            return;\\n        }\\n\\n        cont_1 = ((cont_1 + k) % v.size());\\n        v.erase(v.begin() + cont_1);\\n        solve(v, k, cont_1);\\n    }\\n\\n    int findTheWinner(int n, int k)\\n    {\\n        vector<int> v;\\n        int cont_1 = 0;\\n        for (int i = 1; i <= n; i++)\\n        {\\n            v.push_back(i);\\n        }\\n        k -= 1;\\n        solve(v, k, cont_1);\\n        return v[0];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    void solve(vector<int> &v, int k, int cont_1)\\n    {\\n        if (v.size() == 1)\\n        {\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1350541,
                "title": "josephus-problem-with-explanation",
                "content": "Formulating recursive solution:\\n\\n`function(n, k)` -> returns the winner if there are `n` players and `kth` players is killed in each step\\n`function(n-1, k)` -> return the winner if there are `n-1` players and `kth` players is killed in each step\\nand so on.\\n\\nIf the number of player is `n` then its ```0```   to `n-1` \\nIf the number of player is `n-1` then its `0`   to `n-2`\\n```\\n\\tfunction(n, k){\\n\\t\\tint winner = find(n-1, k)\\n\\t\\t// map the winner from the group of n-1 players to group of n players\\n\\t\\t// Let\\'s take an example of n = 6, and k = 3\\n\\t}\\n```\\n`n = 6, k = 3`\\nSo the `6` players are from `0` to `n - 1`, i.e ` 0 1 2 3 4 5`\\nAt first round 3rd players gets killed i.e player `2` will be killed.\\nSo, the remaining players are `0 1 ~ 3 4 5`\\n\\nNow, we\\'ll solve the problem for size `5` with players `0 1 2 3 4`  and we\\'ll map `(k + 1)`th player as a first player in new problem.\\n`` 0 1 2 3 4 5 `` -> `` 3 4 - 0 1 2 ``\\nSo if our subproblem of size `n-1` return `x` as a winner and original winner `y` can be derived by using \\n```  \\ny = (x + k) % n\\n```\\nSo our final solution to Josephus problem\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findWinner(n, k) + 1;   // 1 for converting 0 indexed to 1 indexed\\n    }\\n    \\n    public int findWinner(int n, int k){\\n        if(n == 1) return 0;\\n        int x = findWinner(n-1, k);\\n        int y = (x  + k )% n;\\n        return y;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```0```\n```\\n\\tfunction(n, k){\\n\\t\\tint winner = find(n-1, k)\\n\\t\\t// map the winner from the group of n-1 players to group of n players\\n\\t\\t// Let\\'s take an example of n = 6, and k = 3\\n\\t}\\n```\n```  \\ny = (x + k) % n\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return findWinner(n, k) + 1;   // 1 for converting 0 indexed to 1 indexed\\n    }\\n    \\n    public int findWinner(int n, int k){\\n        if(n == 1) return 0;\\n        int x = findWinner(n-1, k);\\n        int y = (x  + k )% n;\\n        return y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285122,
                "title": "c-clean-concise-code-100-one-liner-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        return n==1 ? 1:((k + findTheWinner(n-1, k) - 1)%n + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        return n==1 ? 1:((k + findTheWinner(n-1, k) - 1)%n + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187817,
                "title": "4-line-solution-with-simple-explanation-100-time-98-space-could-be-tweaked-to-get-100",
                "content": "Let\\'s work 0-based so the first person has number 0. We will add 1 in the end to make up for that.\\n\\nAlso for a change let us assume that we start the game at position -k. After the first round we will end up at position 0. Subsequently we play the original game with n replaced by n-1. Assume we have already computed that w was the winner of the latter game, then it would also be the winner of the former game. But if we change the starting position from -k to 0 that only shifts the winner by k (mod n). So given that w is the winner of the game with n-1, the winner of the game with n is (w+k)%n.\\n\\nWe use this to iteratively determine the winner. If there is only one player (numbered 0), she is the winner. We then update the game for i=2 players, i=3 players up to i=n players and voila, we are done.\\n\\nWe could obtain optimum space complexity by getting rid of the iterator i, using n instead. Do you see how? This seems a bit contrived though.\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int winner=0;\\n        for(int i=2;i < = n;++i)\\n            winner=(winner+k)%i;\\n        return winner+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int winner=0;\\n        for(int i=2;i < = n;++i)\\n            winner=(winner+k)%i;\\n        return winner+1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1181024,
                "title": "python3-simple-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l = list(range(1,n+1))\\n        i = 0\\n        while len(l) > 1:\\n            i = (i + k - 1)%len(l)\\n            l.pop(i)\\n        return l[0]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l = list(range(1,n+1))\\n        i = 0\\n        while len(l) > 1:\\n            i = (i + k - 1)%len(l)\\n            l.pop(i)\\n        return l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159389,
                "title": "simple-c-solution-using-a-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (k==1) return n;\\n        queue<int> rotation;\\n        for (int i=1; i<=n; ++i) {\\n            rotation.push(i);\\n        }\\n        while (rotation.size()>1) {\\n            for (int i=1; i<k; ++i) {\\n                rotation.push(rotation.front());\\n                rotation.pop();\\n            }\\n            rotation.pop();\\n        }\\n        return rotation.front();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (k==1) return n;\\n        queue<int> rotation;\\n        for (int i=1; i<=n; ++i) {\\n            rotation.push(i);\\n        }\\n        while (rotation.size()>1) {\\n            for (int i=1; i<k; ++i) {\\n                rotation.push(rotation.front());\\n                rotation.pop();\\n            }\\n            rotation.pop();\\n        }\\n        return rotation.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152725,
                "title": "c-simple-o-n-josephus-circle-problem",
                "content": "```csharp\\npublic int FindTheWinner(int n, int k)\\n{\\n\\tint result = 0;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tresult = (result + k) % i;\\n\\t}\\n\\n\\treturn result + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int FindTheWinner(int n, int k)\\n{\\n\\tint result = 0;\\n\\n\\tfor (int i = 1; i <= n; i++)\\n\\t{\\n\\t\\tresult = (result + k) % i;\\n\\t}\\n\\n\\treturn result + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152631,
                "title": "javascript-joseph-ring-rotated-array-100ms",
                "content": "reference:\\nhttps://en.wikipedia.org/wiki/Josephus_problem\\nhttps://programming.vip/docs/joseph-problem-of-data-structure-and-algorithms.html\\n```\\nconst findTheWinner = (n, k) => {\\n    let a = [];\\n    for (let i = 0; i < n; i++) a.push(i + 1);\\n    let remove = 0;\\n    for (let i = 0; i < n - 1; i++) {\\n        remove = (remove + k - 1) % (n - i);\\n        a.splice(remove, 1);\\n    } \\n    return a;\\n};\\n\\n////////////////////// Another version  124ms ////////////////\\nconst findTheWinner = (n, k) => {\\n    let a = [];\\n    for (let i = 0; i < n; i++) a.push(i + 1);\\n    let remove = 0;\\n    while (a.length > 1) {\\n        remove = (remove + k - 1) % a.length;\\n        a.splice(remove, 1);\\n    }\\n    return a;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findTheWinner = (n, k) => {\\n    let a = [];\\n    for (let i = 0; i < n; i++) a.push(i + 1);\\n    let remove = 0;\\n    for (let i = 0; i < n - 1; i++) {\\n        remove = (remove + k - 1) % (n - i);\\n        a.splice(remove, 1);\\n    } \\n    return a;\\n};\\n\\n////////////////////// Another version  124ms ////////////////\\nconst findTheWinner = (n, k) => {\\n    let a = [];\\n    for (let i = 0; i < n; i++) a.push(i + 1);\\n    let remove = 0;\\n    while (a.length > 1) {\\n        remove = (remove + k - 1) % a.length;\\n        a.splice(remove, 1);\\n    }\\n    return a;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152611,
                "title": "python-5-lines",
                "content": "```python\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        remaining, index = [x for x in range(1,n+1)], 0\\n        while remaining:\\n            index = (index+k-1) % len(remaining)\\n            result = remaining.pop(index)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        remaining, index = [x for x in range(1,n+1)], 0\\n        while remaining:\\n            index = (index+k-1) % len(remaining)\\n            result = remaining.pop(index)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1152502,
                "title": "short-easy-recursive-solution-1-liner-solution-w-explanation",
                "content": "We have following recursive structure - \\n\\n1. If last member remaining - **return 1**.\\n2. Recurse for remaining n - 1 members. Just `findTheWinner(n-1, k)` would mean that we are starting from 0. So, we adjust the new position by adding `k - 1` (denotes that we skip *`k - 1`* players) and modding with `n` for wrap-around. `+1` in the below equation accounts for the index starting from 1 and not from 0. \\n\\tSo final recursive equation becomes - **`1 + findTheWinner(n - 1, k) + k - 1) % n`**\\n\\n```\\nint findTheWinner(int n, int k) {\\n\\treturn (n == 1 ? 1 : 1 + (findTheWinner(n - 1, k) + k - 1) % n);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findTheWinner(int n, int k) {\\n\\treturn (n == 1 ? 1 : 1 + (findTheWinner(n - 1, k) + k - 1) % n);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152495,
                "title": "java-easy-to-understand-simulation-using-linkedlist",
                "content": "Java\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        // using linked list is easier to simulate and run faster\\n        LinkedList<Integer> ll = new LinkedList<>();\\n        for(int i = 1; i <= n; i++){\\n            ll.add(i);\\n        }\\n\\n        // follow the rules and remove the loser\\n        int ind = 0;\\n        while(ll.size() > 1){\\n            ind = ind + k-1;\\n            while(ind >= ll.size())\\n                ind -= ll.size();\\n            ll.remove(ind);\\n        }\\n        return ll.getFirst();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        // using linked list is easier to simulate and run faster\\n        LinkedList<Integer> ll = new LinkedList<>();\\n        for(int i = 1; i <= n; i++){\\n            ll.add(i);\\n        }\\n\\n        // follow the rules and remove the loser\\n        int ind = 0;\\n        while(ll.size() > 1){\\n            ind = ind + k-1;\\n            while(ind >= ll.size())\\n                ind -= ll.size();\\n            ll.remove(ind);\\n        }\\n        return ll.getFirst();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152410,
                "title": "c-easy-implemation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (n == 1)\\n        return 1;\\n    else\\n        return (findTheWinner(n - 1, k) + k-1) % n + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (n == 1)\\n        return 1;\\n    else\\n        return (findTheWinner(n - 1, k) + k-1) % n + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909580,
                "title": "3-c-solutions-iterative-recursive-and-o-1-space-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\n// Iterative approach\\nclass Solution {\\npublic:\\n    void solve(queue<int> &q, int k){\\n        while(q.size() != 1){\\n            int count = 0;\\n            while(++count != k){\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n        }\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i = 1; i<=n; i++){\\n            q.push(i);\\n        }\\n        solve(q, k);\\n        return q.front();\\n    }\\n};\\n\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void solve(queue<int> &q, int k){\\n        if(q.size() == 1)\\n            return;\\n\\n        int count = 0;\\n        while(++count != k){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n        q.pop();\\n\\n        solve(q, k);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i = 1; i<=n; i++){\\n            q.push(i);\\n        }\\n        solve(q, k);\\n        return q.front();\\n    }\\n};\\n\\n// O(1) space approach\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Recursion",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\n// Iterative approach\\nclass Solution {\\npublic:\\n    void solve(queue<int> &q, int k){\\n        while(q.size() != 1){\\n            int count = 0;\\n            while(++count != k){\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n        }\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i = 1; i<=n; i++){\\n            q.push(i);\\n        }\\n        solve(q, k);\\n        return q.front();\\n    }\\n};\\n\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void solve(queue<int> &q, int k){\\n        if(q.size() == 1)\\n            return;\\n\\n        int count = 0;\\n        while(++count != k){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n        q.pop();\\n\\n        solve(q, k);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i = 1; i<=n; i++){\\n            q.push(i);\\n        }\\n        solve(q, k);\\n        return q.front();\\n    }\\n};\\n\\n// O(1) space approach\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i = 1; i <= n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595667,
                "title": "queue-c-easiest-explanation",
                "content": "# Intuition\\nEliminate a person after every k turns until a single person is left.\\nn and k have really small values. Simply simulate the process.\\n\\n# Approach\\n- Create a queue which initially contains numbers from 1 to n.\\n- For k-1 times, shift the first element of the queue to the end of the queue and pop the element from queue at the kth turn.\\n- Do above step until queue have only 1 element left which is the required answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int temp=k-1;\\n            while(temp>0){\\n                int t=q.front();\\n                q.pop();\\n                q.push(t);\\n                temp--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int temp=k-1;\\n            while(temp>0){\\n                int t=q.front();\\n                q.pop();\\n                q.push(t);\\n                temp--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476490,
                "title": "java-easy-solution-using-recursion-and-100-fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int solve(int n,int k){\\n        if(n==1) return 0;\\n     return (solve(n-1,k)+k)%n;\\n     \\n    }\\n    public int findTheWinner(int n, int k) {\\n        return solve(n,k)+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int solve(int n,int k){\\n        if(n==1) return 0;\\n     return (solve(n-1,k)+k)%n;\\n     \\n    }\\n    public int findTheWinner(int n, int k) {\\n        return solve(n,k)+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409108,
                "title": "circular-linked-list-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    We can represent the circle using a queue of integers, where each integer corresponds to a person in the circle.\\n\\n    To simulate the elimination process, we can repeatedly remove the k-th person from the front of the queue and add them to the back of the queue until only one person is left.\\n\\n    Finally, we return the remaining person as the winner. Since the queue is 0-indexed, we need to add 1 to the result before returning it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. Create a queue and add all the elements from 1 to n to the queue\\n    2. Start a loop until there is only one element remaining in the queue.\\n    3. In each iteration, remove k-1 elements from the front of the queue and add them to the rear of the queue.\\n    4. Remove the kth element from the front of the queue.\\n    5. Repeat steps 3-4 until only one element remains in the queue.\\n    6. The remaining element is the winner.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> nums(n);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = i + 1;\\n        }\\n\\n        int index = 0;\\n        while (n > 1) {\\n            // Move k steps in the linked list\\n            index = (index + k - 1) % n;\\n            // Remove the node at the current index\\n            nums.erase(nums.begin() + index);\\n            n--;\\n        }\\n\\n        return nums[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> nums(n);\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = i + 1;\\n        }\\n\\n        int index = 0;\\n        while (n > 1) {\\n            // Move k steps in the linked list\\n            index = (index + k - 1) % n;\\n            // Remove the node at the current index\\n            nums.erase(nums.begin() + index);\\n            n--;\\n        }\\n\\n        return nums[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361846,
                "title": "easy-solution-using-queue-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList();\\n\\n        for(int i = 1;i<n+1;i++){\\n            q.add(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i = k-1;i>0;i--){\\n                q.add(q.poll());\\n            }\\n            q.poll();\\n        }\\n\\n        return q.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList();\\n\\n        for(int i = 1;i<n+1;i++){\\n            q.add(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i = k-1;i>0;i--){\\n                q.add(q.poll());\\n            }\\n            q.poll();\\n        }\\n\\n        return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308840,
                "title": "josephus-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int findTheWinner(int n, int k) {\\n         if(n<=1)\\n            return 1;\\n        return ((findTheWinner(n-1,k)+k-1)%n)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findTheWinner(int n, int k) {\\n         if(n<=1)\\n            return 1;\\n        return ((findTheWinner(n-1,k)+k-1)%n)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251106,
                "title": "queue-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            q.offer(i);\\n        }\\n        while(q.size()>1){\\n            for(int i=0;i<k-1;i++){\\n                q.offer(q.remove());\\n            }\\n            q.remove();\\n        }\\n        return q.peek()+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new LinkedList<>();\\n        for(int i=0;i<n;i++){\\n            q.offer(i);\\n        }\\n        while(q.size()>1){\\n            for(int i=0;i<k-1;i++){\\n                q.offer(q.remove());\\n            }\\n            q.remove();\\n        }\\n        return q.peek()+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078610,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList();\\n\\n        for(int i = 0; i<n; i++){\\n            list.add(i+1);\\n        }\\n\\n        int ind = k-1;\\n\\n        while(list.size() != 1){\\n\\n            if(ind>=list.size() ){\\n\\n                ind = ind%list.size();                \\n            }\\n\\n            list.remove(ind);\\n            ind+=k-1;\\n        }\\n        return list.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList();\\n\\n        for(int i = 0; i<n; i++){\\n            list.add(i+1);\\n        }\\n\\n        int ind = k-1;\\n\\n        while(list.size() != 1){\\n\\n            if(ind>=list.size() ){\\n\\n                ind = ind%list.size();                \\n            }\\n\\n            list.remove(ind);\\n            ind+=k-1;\\n        }\\n        return list.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076604,
                "title": "0ms-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int ans=solve(n,k);\\n        return ans+1;\\n\\n    }\\n    public int solve(int n,int k){\\n        if(n==1) return 0;\\n        return (solve(n-1,k)+k)%n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int ans=solve(n,k);\\n        return ans+1;\\n\\n    }\\n    public int solve(int n,int k){\\n        if(n==1) return 0;\\n        return (solve(n-1,k)+k)%n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071585,
                "title": "0ms-100-faster-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int solve(int n,int k){\\n        if(n==1){\\n            return 0;\\n        }\\n        return (solve(n-1,k)+k)%n;\\n    }\\n    public int findTheWinner(int n, int k) {\\n        int ans=solve(n,k);\\n        return ans+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(int n,int k){\\n        if(n==1){\\n            return 0;\\n        }\\n        return (solve(n-1,k)+k)%n;\\n    }\\n    public int findTheWinner(int n, int k) {\\n        int ans=solve(n,k);\\n        return ans+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059116,
                "title": "simple-solution-using-recursion-josephus-problem",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findAns(int n,int k){\\n        if(n==1)return 0;\\n        else\\n        return (findAns(n-1,k)+k)%n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return findAns(n,k)+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findAns(int n,int k){\\n        if(n==1)return 0;\\n        else\\n        return (findAns(n-1,k)+k)%n;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return findAns(n,k)+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058518,
                "title": "flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion",
                "content": "\\n# Approach\\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n# !!!PLZ UPVOTE IF YOU LIKE THE SOLUTION!!!\\n![WhatsApp Image 2023-01-16 at 5.05.00 PM.jpeg](https://assets.leetcode.com/users/images/46113a3c-1599-43ad-adcb-5234ea95788c_1673868980.7228653.jpeg)\\n\\n\\n**# Code\\n```\\nclass Solution {\\npublic:\\n    int myjos(int n, int k)\\n    {\\n        //if n is itself 1 then no matter how many k we took it will always come to that person so return 0.\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        //1)WHY n-1??\\n        //Because we want to decrease the number of persons as mentioned in the question.At one time we are decreasing one person at a time so n-1\\n\\n        //2)WHY +k??\\n        //I am attaching a page,while explaining look into that page.\\n        //Lets think like what would have happened if we have not inluded +k? \\n        //eg-: n=5 k=3 -->(let us consider n is from 0)-->0,1,2,3,4-->(delete 2)-->0,1,3,4-->now it should start from 3 as mentioned in question but what happens is it will again start from 0-->0,1,4 it is deleting 3 but in reality it should delete 1        \\n        else{\\n            return (myjos(n-1,k)+k)%n;\\n        }\\n    }\\n    int findTheWinner(int n, int k) {\\n        //myjos function is from 0 to n-1 i.e n is starting from 0 to n-1 so to start from 1 just add 1 to the function.\\n        return myjos(n,k)+1;\\n    }\\n};\\n```\\n# **!!!PLZ UPVOTE IF YOU LIKE THE SOLUTION!!!**",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int myjos(int n, int k)\\n    {\\n        //if n is itself 1 then no matter how many k we took it will always come to that person so return 0.\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        //1)WHY n-1??\\n        //Because we want to decrease the number of persons as mentioned in the question.At one time we are decreasing one person at a time so n-1\\n\\n        //2)WHY +k??\\n        //I am attaching a page,while explaining look into that page.\\n        //Lets think like what would have happened if we have not inluded +k? \\n        //eg-: n=5 k=3 -->(let us consider n is from 0)-->0,1,2,3,4-->(delete 2)-->0,1,3,4-->now it should start from 3 as mentioned in question but what happens is it will again start from 0-->0,1,4 it is deleting 3 but in reality it should delete 1        \\n        else{\\n            return (myjos(n-1,k)+k)%n;\\n        }\\n    }\\n    int findTheWinner(int n, int k) {\\n        //myjos function is from 0 to n-1 i.e n is starting from 0 to n-1 so to start from 1 just add 1 to the function.\\n        return myjos(n,k)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945734,
                "title": "java-solution-using-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int rec(int n, int k){\\n        if(n==1){\\n            return 0;\\n        }\\n        return (rec(n-1, k)+k)%n;\\n    }\\n\\n    public int findTheWinner(int n, int k) {\\n        int ans = rec(n,k)+1;\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int rec(int n, int k){\\n        if(n==1){\\n            return 0;\\n        }\\n        return (rec(n-1, k)+k)%n;\\n    }\\n\\n    public int findTheWinner(int n, int k) {\\n        int ans = rec(n,k)+1;\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937048,
                "title": "python3-solutions",
                "content": "# Approach 1: Straight Forward\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        players = [playerNum+1 for playerNum in range(n)] #setup player numbers\\n        idx = 0 #starting player index\\n        while len(players)>1:\\n            idx = (idx+k-1) % len(players) #get last counter player, mod len(remaining_players) to avoid out of bounds\\n            players.pop(idx) #pop because it\\'s faster than remove\\n        return players[0] #return last remaining player numbber\\n```\\n# Approach 2: Recurrsion\\n```\\nclass Solution:\\n    def sol(self, n, k, arr, i=0):\\n        if len(arr) == 1:\\n            return arr[0]\\n        else:\\n            index = (i + k - 1) % len(arr)\\n            arr.pop(index)\\n            i = index\\n            return self.sol(n, k, arr, i)\\n\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        arr = list(range(1, n + 1))\\n        return self.sol(n, k, arr)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        players = [playerNum+1 for playerNum in range(n)] #setup player numbers\\n        idx = 0 #starting player index\\n        while len(players)>1:\\n            idx = (idx+k-1) % len(players) #get last counter player, mod len(remaining_players) to avoid out of bounds\\n            players.pop(idx) #pop because it\\'s faster than remove\\n        return players[0] #return last remaining player numbber\\n```\n```\\nclass Solution:\\n    def sol(self, n, k, arr, i=0):\\n        if len(arr) == 1:\\n            return arr[0]\\n        else:\\n            index = (i + k - 1) % len(arr)\\n            arr.pop(index)\\n            i = index\\n            return self.sol(n, k, arr, i)\\n\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        arr = list(range(1, n + 1))\\n        return self.sol(n, k, arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784018,
                "title": "how-recursion-brings-answer-detailed-explanation",
                "content": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**\\n\\n```\\n\\t// Lets understand with an example\\n\\t/*   n = 5   k = 2  x --> dead\\n\\t\\t 0 1 2 3 4\\n\\t\\t 0 x 2 x 4\\n\\t\\t x x 2 x x \\n\\t\\t 2(0 indexed) i.e 3(1 indexed) survives\\n\\t\\t \\n\\t\\t note : for any value of k if n = 1 then surviver is 1(1 indexed)\\n\\t\\t \\n\\t\\t we have n = 5 and k = 3\\n\\t\\t 1 2 3 4 5\\n\\t\\t 1 st kill is of 3 -->\\n\\t\\t 1 2 x 4 5\\n\\t\\t after this bring [1 2] to the end ->\\n\\t\\t 4 5 1 2 (here n becomes 4 and k is 2) \\n\\t\\t \\n\\t\\t lets map 1 2 3 4 with above values\\n\\t\\t i.e 1 -> 4 , 2 -> 5 , 3 -> 1 , 4 -> 2\\n\\t\\t \\n\\t\\t how these are related ?\\n\\t\\t 4 is (1 + 3) % 5 = 4 \\n\\t\\t 5 is (2 + 3) % 5 = 0 (needs special handelling)\\n\\t\\t 3 is (3 + 3) % 5 = 1\\n\\t\\t 4 is (4 + 3) % 5 = 2\\n\\t\\t \\n\\t\\t in genral y is (x + k) % n\\n\\t\\t \\n\\t\\t we repeat the above till only 1 player remains and as we always index him as 1, by using \\n\\t\\t the formula we go on converting back the value and we arrive at the answer\\n\\t*/\\n```\\n\\tpublic int findTheWinner(int n, int k) {\\n        if(n == 1)\\n            return 1;\\n        \\n        int x = findTheWinner(n - 1, k);\\n        int y = (x + k) % n;\\n        if(y == 0)\\n            return n;\\n        return y ;\\n    }\\n\\t\\n```\\n// to get clear idea you can watch this video (credits : pepcoding)\\n[https://www.youtube.com/watch?v=dzYq5VEMZIg&list=PL-Jc9J83PIiE-181crLG1xSIWhTGKFiMY&index=4](http://)",
                "solutionTags": [],
                "code": "```\\n\\t// Lets understand with an example\\n\\t/*   n = 5   k = 2  x --> dead\\n\\t\\t 0 1 2 3 4\\n\\t\\t 0 x 2 x 4\\n\\t\\t x x 2 x x \\n\\t\\t 2(0 indexed) i.e 3(1 indexed) survives\\n\\t\\t \\n\\t\\t note : for any value of k if n = 1 then surviver is 1(1 indexed)\\n\\t\\t \\n\\t\\t we have n = 5 and k = 3\\n\\t\\t 1 2 3 4 5\\n\\t\\t 1 st kill is of 3 -->\\n\\t\\t 1 2 x 4 5\\n\\t\\t after this bring [1 2] to the end ->\\n\\t\\t 4 5 1 2 (here n becomes 4 and k is 2) \\n\\t\\t \\n\\t\\t lets map 1 2 3 4 with above values\\n\\t\\t i.e 1 -> 4 , 2 -> 5 , 3 -> 1 , 4 -> 2\\n\\t\\t \\n\\t\\t how these are related ?\\n\\t\\t 4 is (1 + 3) % 5 = 4 \\n\\t\\t 5 is (2 + 3) % 5 = 0 (needs special handelling)\\n\\t\\t 3 is (3 + 3) % 5 = 1\\n\\t\\t 4 is (4 + 3) % 5 = 2\\n\\t\\t \\n\\t\\t in genral y is (x + k) % n\\n\\t\\t \\n\\t\\t we repeat the above till only 1 player remains and as we always index him as 1, by using \\n\\t\\t the formula we go on converting back the value and we arrive at the answer\\n\\t*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2770302,
                "title": "simple-approach-bf",
                "content": "# Code\\n```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l = list(range(n))\\n        s = 0\\n        while len(l) > 1:\\n            i = (k%len(l) + s)%len(l)\\n            l = l[: i] + l[i+1: ]\\n            s = i-1\\n        return l[0] or n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l = list(range(n))\\n        s = 0\\n        while len(l) > 1:\\n            i = (k%len(l) + s)%len(l)\\n            l = l[: i] + l[i+1: ]\\n            s = i-1\\n        return l[0] or n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2706729,
                "title": "c-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(vector<int>v, int i, int k){\\n        int n=v.size();\\n        if(n==1)\\n            return v[0];\\n        int nxt=(i+k-1)%n;\\n        v.erase(v.begin()+nxt);\\n       // nxt=(nxt+1)%(n);\\n        return f(v,nxt,k);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        vector<int>v;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n        }\\n        return f(v,0,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(vector<int>v, int i, int k){\\n        int n=v.size();\\n        if(n==1)\\n            return v[0];\\n        int nxt=(i+k-1)%n;\\n        v.erase(v.begin()+nxt);\\n       // nxt=(nxt+1)%(n);\\n        return f(v,nxt,k);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        vector<int>v;\\n        for(int i=1;i<=n;i++){\\n            v.push_back(i);\\n        }\\n        return f(v,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583677,
                "title": "c-using-queue-data-structure",
                "content": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n     queue<int>circle;\\n        for(int i=1;i<=n;i++)\\n        {\\n            circle.push(i);\\n        }\\n        while(circle.size()!=1)\\n        {\\n            int kk=k;\\n            while(kk>1)\\n            {\\n                int f=circle.front();\\n                circle.pop();\\n                circle.push(f);\\n                kk--;\\n            }\\n            circle.pop();\\n        }\\n        return circle.front();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n     queue<int>circle;\\n        for(int i=1;i<=n;i++)\\n        {\\n            circle.push(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2576185,
                "title": "java-solution-arraylist",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){\\n            list.add(i);\\n        }\\n        \\n        int i = 0;\\n        while(list.size() > 1){\\n            i = i+k-1;\\n            i = i%list.size();\\n            list.remove(i);\\n        }\\n        \\n        return list.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i = 1; i <= n; i++){\\n            list.add(i);\\n        }\\n        \\n        int i = 0;\\n        while(list.size() > 1){\\n            i = i+k-1;\\n            i = i%list.size();\\n            list.remove(i);\\n        }\\n        \\n        return list.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549575,
                "title": "python-simple-logic-without-recursion",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l=[i for i in range(1,n+1)]\\n        start=0\\n        r=0\\n        while(len(l)!=1):\\n            r=(start + k-1)%len(l)\\n            l.pop(r)\\n            start=r\\n                \\n        return l[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l=[i for i in range(1,n+1)]\\n        start=0\\n        r=0\\n        while(len(l)!=1):\\n            r=(start + k-1)%len(l)\\n            l.pop(r)\\n            start=r\\n                \\n        return l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531293,
                "title": "java-queue-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new ArrayDeque<>();\\n        for(int i=1;i<=n;i++)q.offer(i);\\n        int ok=k;\\n        while(q.size()>1){\\n            k=ok;\\n            while(k-->1){\\n                q.offer(q.poll());\\n            }\\n            q.poll();\\n        }\\n        return q.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q=new ArrayDeque<>();\\n        for(int i=1;i<=n;i++)q.offer(i);\\n        int ok=k;\\n        while(q.size()>1){\\n            k=ok;\\n            while(k-->1){\\n                q.offer(q.poll());\\n            }\\n            q.poll();\\n        }\\n        return q.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460185,
                "title": "easy-java-solution-using-queue",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            q.add(i);\\n        }\\n        \\n        while(q.size()!=1){\\n            for(int i=0;i<k-1;i++){\\n                q.add(q.poll());\\n            }\\n            q.poll();\\n        }\\n        return q.poll();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList<>();\\n        for(int i=1;i<=n;i++){\\n            q.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2268868,
                "title": "simplest-explaination-time-0-n-space-o-1",
                "content": "As usual we follow zero-base indexing hence for n=5,k=3\\nFriends initially : 0 1 2 3 4\\n\\nwe keep removing friends a total for n-1 time\\nThus when only one friend (**winner**) is left we return its position as we know it will obviously be 0th position as it was only one left.\\nWe keep backtracking, using the previous position value to find the **winner** position at the currently backtracked cycle. To do this we put to use formula : **{(fn(n-1,k)+k)%n}**\\n\\nfinally we add 1 to the answer to get the final answer in 1 based indexing.\\n\\n```\\nvar findTheWinner = function(n, k) {\\n   let y=n;\\n    function ans(n,k){\\n        if(n==1){\\n            return 0;\\n        }\\n        else{\\n            return (ans(n-1,k)+k)%(n);    \\n        }\\n    }\\n    \\n    return ans(n,k)+1;\\n};\\n```\\n\\n***Do upvote if it helped ! TIA ;)***\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvar findTheWinner = function(n, k) {\\n   let y=n;\\n    function ans(n,k){\\n        if(n==1){\\n            return 0;\\n        }\\n        else{\\n            return (ans(n-1,k)+k)%(n);    \\n        }\\n    }\\n    \\n    return ans(n,k)+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219645,
                "title": "python-easy-understand-clear-approach",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l=[]\\n        curr=0\\n        for i in range(n):\\n            l.append(i+1)\\n        while n>1:\\n            l.pop(((curr-1+k)%n))\\n            curr=(curr-1+k)%n\\n            n=n-1\\n        return l[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        l=[]\\n        curr=0\\n        for i in range(n):\\n            l.append(i+1)\\n        while n>1:\\n            l.pop(((curr-1+k)%n))\\n            curr=(curr-1+k)%n\\n            n=n-1\\n        return l[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212758,
                "title": "c-100ms-2-line-of-code",
                "content": "***DO UPVOTE IF IT HELPS !!***\\n\\n\\tint findTheWinner(int n, int k) {\\n        \\n        if(n==1) return 1;\\n        \\n        return (findTheWinner(n-1,k)+k-1)%(n) + 1;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!***\\n\\n\\tint findTheWinner(int n, int k) {\\n        \\n        if(n==1) return 1;\\n        \\n        return (findTheWinner(n-1,k)+k-1)%(n) + 1;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2183257,
                "title": "c-5-lines-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        int res=0;\\n        while(q.size()!=1)\\n        {\\n            for(int i=1;i<k;i++)\\n            {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n            \\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n        {\\n            q.push(i);\\n        }\\n        int res=0;\\n        while(q.size()!=1)\\n        {\\n            for(int i=1;i<k;i++)\\n            {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n            \\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156455,
                "title": "c-easy-solution-2-line-code-100-faster",
                "content": "**It is a Standard Josephus Problem\\nyou can search it on google you will find lot of content there**\\n\\n**C++ Easy Solution**\\n```\\n// It is a Josephus Problem\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (n == 1)\\n        return 1;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```\\n**If You Find it Hepful Kindly UPVOTE**\\n\\n[](https://www.youtube.com/watch?v=ULUNeD0N9yI)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// It is a Josephus Problem\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if (n == 1)\\n        return 1;\\n        return (findTheWinner(n-1,k)+k-1)%n+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142395,
                "title": "without-using-queue-c",
                "content": "Here\\'s My code\\n**EXPLANATION:-**\\n\\nmake a while loop untill the size of vector goes 1\\nkeep erasing the elements at kth position including just after the deleted element\\nafter erasing the vector automatically resizes itself and u are on the element next to\\nthe deleted position element now again move to the kth position and del that element \\n\\n**NOTE**\\nif u are exceeding the vector length then use modulo operator to be in range\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n    \\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(i+1);\\n        }\\n        \\n        int i=0,m;\\n     while(v.size()!=1)\\n     {\\n              m=k-1;\\n              if(v.size()==1)\\n                  break;\\n              while(m--)\\n              {\\n                   i++;       \\n              } \\n              i=i%v.size();\\n              \\n              v.erase(v.begin()+i);          \\n         }\\n        return v[0];\\n    }\\n};\\n```\\n\\nTHANK U\\uD83D\\uDE4F\\uD83D\\uDE4F",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n    \\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(i+1);\\n        }\\n        \\n        int i=0,m;\\n     while(v.size()!=1)\\n     {\\n              m=k-1;\\n              if(v.size()==1)\\n                  break;\\n              while(m--)\\n              {\\n                   i++;       \\n              } \\n              i=i%v.size();\\n              \\n              v.erase(v.begin()+i);          \\n         }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071722,
                "title": "python-straight-forward-simulation",
                "content": "It takes exactly ```n-1``` times to remove ```n-1``` people off the ```n```-person circle. In the simulation, we simply make a circle (which is just a list running from 0 to ```n-1```). \\n\\nNote that because we count ```k``` people inclusively each time, algorithmically we subtract ```k``` by one before we start the for-loop. \\n\\nEach time inside the for-loop, we calculate the index ```curr_pos``` at which the next \"victim\" would be (we need to take mod by the length of the circle here), and pop the \"victim\". Note that after popping, the ```curr_pos``` automatically takes care of going to the next person in the circle for the next round.\\n\\n```\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circle = list(range(n))\\n        curr_pos = 0\\n        k -= 1\\n        for i in range(n-1):\\n            curr_pos = (curr_pos + k) % (n-i)\\n            _ = circle.pop(curr_pos)\\n        return circle[0] + 1\\n```\\n\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```n-1```\n```n-1```\n```n```\n```n-1```\n```k```\n```k```\n```curr_pos```\n```curr_pos```\n```\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circle = list(range(n))\\n        curr_pos = 0\\n        k -= 1\\n        for i in range(n-1):\\n            curr_pos = (curr_pos + k) % (n-i)\\n            _ = circle.pop(curr_pos)\\n        return circle[0] + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1963208,
                "title": "java-recursion",
                "content": "\\n1. Fill an ArrayList with the numbers from 1 to n.\\n2. Return a helper function.\\n3. The helper function takes a list of integers as argument, k and current k (current k is the value which has to be dropped from the game).\\n4. Update the current k, with the value that has to be dropped and call the recursion function until you are left with only one element in the arraylist and return it. \\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> lis = new ArrayList<Integer>();\\n        for(int i=1; i<=n; i++){\\n            lis.add(i);\\n        }\\n        return helper(lis, k, 0);        \\n    }\\n    private int helper(List<Integer> lis, int k, int curr){\\n        if(lis.size()==1){\\n            return lis.get(0);\\n        }\\n        //int cur = 0;\\n        curr = (curr+k-1)%lis.size();\\n        //k=k%lis.size();\\n        lis.remove(curr);\\n        return helper(lis, k, curr);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> lis = new ArrayList<Integer>();\\n        for(int i=1; i<=n; i++){\\n            lis.add(i);\\n        }\\n        return helper(lis, k, 0);        \\n    }\\n    private int helper(List<Integer> lis, int k, int curr){\\n        if(lis.size()==1){\\n            return lis.get(0);\\n        }\\n        //int cur = 0;\\n        curr = (curr+k-1)%lis.size();\\n        //k=k%lis.size();\\n        lis.remove(curr);\\n        return helper(lis, k, curr);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944207,
                "title": "one-line-code-c-faster-than-100-memory-usage-less-than-95",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n          int index=0;\\n        for(int i=1;i<=n;++i){\\n        index = (index+k)%i;\\n    }\\n        return index+1;\\n      }\\n};\\n```\\nENJOY !!!",
                "solutionTags": [
                    "C",
                    "Array",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n          int index=0;\\n        for(int i=1;i<=n;++i){\\n        index = (index+k)%i;\\n    }\\n        return index+1;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912428,
                "title": "java-100-fast",
                "content": "Method1: Recursion 100% Fast\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return helper(n, k) + 1;\\n    }\\n    \\n    public int helper(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        return (helper(n-1, k) + k) % n;\\n    }\\n}\\n```\\n\\nMethod2: Loop 81% Fast\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int res = 0;\\n        for(int i = 1; i < n + 1; i++){\\n            res = (res + k) % i;\\n        }\\n        return res + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return helper(n, k) + 1;\\n    }\\n    \\n    public int helper(int n, int k) {\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        return (helper(n-1, k) + k) % n;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int res = 0;\\n        for(int i = 1; i < n + 1; i++){\\n            res = (res + k) % i;\\n        }\\n        return res + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895622,
                "title": "java-recursive-iterative-both-beats-100",
                "content": "**--> RECURSIVE**\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return recur(n,k)+1;\\n    }\\n    int recur(int n,int k){\\n        if(n==1)\\n            return 0;\\n        return (recur(n-1,k)+k)%n;\\n    }\\n}\\n```\\n**-->ITERATIVE**\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans+1;\\n    }\\n}\\n```\\n**EXPLAINATION-**\\n-->Here we are eliminating  the kth person from the start and then starting the next recursion from (k+1)th person assuming it as the first person and subtracting 1 from n because 1 person is eliminated in each call reducing the total number of friends.when there is only one person left then he will be the winner and 0th person so we are returning 0 when n=1 and we are adding 1 to make it 1 indexed \\n\\n**DRY RUN**\\nn=5 and k=2\\n```\\n0 1 2 3 4 --> n=5,Eliminate 1\\n    2 3 4 0 -->n=4,Eliminate 3\\n\\t    4 0 2 -->n=3,Eliminate 0\\n\\t\\t    2 4-->n=2,Eliminate 4\\n\\t\\t\\t  2-->n=1\\n\\t\\t\\t  \\n\\t2+1=3 is winner\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return recur(n,k)+1;\\n    }\\n    int recur(int n,int k){\\n        if(n==1)\\n            return 0;\\n        return (recur(n-1,k)+k)%n;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            ans = (ans + k) % i;\\n        }\\n        return ans+1;\\n    }\\n}\\n```\n```\\n0 1 2 3 4 --> n=5,Eliminate 1\\n    2 3 4 0 -->n=4,Eliminate 3\\n\\t    4 0 2 -->n=3,Eliminate 0\\n\\t\\t    2 4-->n=2,Eliminate 4\\n\\t\\t\\t  2-->n=1\\n\\t\\t\\t  \\n\\t2+1=3 is winner\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882108,
                "title": "c-easy-solution-0-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\t\\n        queue<int> list;\\n        for(int i=1;i<=n;i++){\\n            list.push(i);\\n        }\\n        while(list.size()!=1){\\n            for(int j=1;j<k;j++){\\n                int r=list.front();\\n                list.push(r);\\n                list.pop();\\n            }\\n            list.pop();\\n        }\\n        return list.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\t\\n        queue<int> list;\\n        for(int i=1;i<=n;i++){\\n            list.push(i);\\n        }\\n        while(list.size()!=1){\\n            for(int j=1;j<k;j++){\\n                int r=list.front();\\n                list.push(r);\\n                list.pop();\\n            }\\n            list.pop();\\n        }\\n        return list.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796693,
                "title": "simplest-solution-easiest-to-understand-0ms-runtime-faster-than-100",
                "content": "Approach-1:\\n\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        \\n        int res=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            res=(res+k)%i;\\n        }\\n        \\n        return res+1;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        \\n        int res=0;\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            res=(res+k)%i;\\n        }\\n        \\n        return res+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734671,
                "title": "c-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n            q.push(i);\\n        while(q.size()!=1){\\n            int x = k;\\n            while(x>1){\\n                int a = q.front();\\n                q.pop();\\n                q.push(a);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int>q;\\n        for(int i=1;i<=n;i++)\\n            q.push(i);\\n        while(q.size()!=1){\\n            int x = k;\\n            while(x>1){\\n                int a = q.front();\\n                q.pop();\\n                q.push(a);\\n                x--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723325,
                "title": "simplest-recursive-solution-c-2-lines-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        return myjos(n,k)+1;\\n    }\\n        \\n    int myjos(int n,int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (myjos(n-1,k)+k)%n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        return myjos(n,k)+1;\\n    }\\n        \\n    int myjos(int n,int k){\\n        if(n==1)\\n            return 0;\\n        else\\n            return (myjos(n-1,k)+k)%n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712196,
                "title": "it-s-a-standard-josephus-problem",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return helper(n, k)+1;    //return ans+1 because the helper returns ans based on 0 based indexing\\n    }\\n    private int helper(int n, int k){\\n        if(n==1) return 0;    // base case\\n        \\n        return (helper(n-1, k)+k) % n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        return helper(n, k)+1;    //return ans+1 because the helper returns ans based on 0 based indexing\\n    }\\n    private int helper(int n, int k){\\n        if(n==1) return 0;    // base case\\n        \\n        return (helper(n-1, k)+k) % n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691145,
                "title": "c-two-methods-very-simple-and-clear-solution-100-faster",
                "content": "```\\nint solve(int n, int k)\\n{\\n\\tif(n==1)\\n\\t\\treturn 0;\\n\\treturn (solve(n-1,k)+k)%n;\\n}\\n\\nint findTheWinner(int n, int k)\\n{\\n\\treturn solve(n, k)+1;\\n}\\n```\\n\\n```\\nint findTheWinner(int n, int k)\\n    {\\n        int res=0;\\n        for (int i=1; i<=n; i++)\\n            res=(res+k)%i;\\n        return res+1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint solve(int n, int k)\\n{\\n\\tif(n==1)\\n\\t\\treturn 0;\\n\\treturn (solve(n-1,k)+k)%n;\\n}\\n\\nint findTheWinner(int n, int k)\\n{\\n\\treturn solve(n, k)+1;\\n}\\n```\n```\\nint findTheWinner(int n, int k)\\n    {\\n        int res=0;\\n        for (int i=1; i<=n; i++)\\n            res=(res+k)%i;\\n        return res+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688605,
                "title": "java-recursion-iterative-easy-self-explanatory",
                "content": "// Iterative \\n\\t\\n    public int findTheWinner(int n, int k) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 1; i<=n; i++)    \\n            list.add(i);\\n\\t\\t\\t\\n        int start = 0;\\n        while(list.size() > 1){\\n            int ind = (start+k-1)%list.size();\\n            list.remove(ind);\\n            start = (ind)%list.size();\\n        }\\n        return list.get(0);\\n    }\\n\\n \\n ```\\n //Recursion \\n \\n   public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i = 1; i<=n; i++)\\n            list.add(i);\\n        return josephus(n, k, 0, list);\\n    }\\n\\t\\n   public int josephus(int n, int k, int start, ArrayList<Integer> list){\\n        if(n > 1) {\\n            int curr = (start + k - 1 )% n;\\n            list.remove(list.get(curr));\\n            josephus(n - 1, k, curr, list);\\n        }\\n        return list.get(0);\\n    }\\n```\\n\\n\"Make sure to upVote if you understood\"",
                "solutionTags": [],
                "code": "```\\n //Recursion \\n \\n   public int findTheWinner(int n, int k) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i = 1; i<=n; i++)\\n            list.add(i);\\n        return josephus(n, k, 0, list);\\n    }\\n\\t\\n   public int josephus(int n, int k, int start, ArrayList<Integer> list){\\n        if(n > 1) {\\n            int curr = (start + k - 1 )% n;\\n            list.remove(list.get(curr));\\n            josephus(n - 1, k, curr, list);\\n        }\\n        return list.get(0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646380,
                "title": "faster-than-100-and-memory-usage-beats-89-59-of-cpp-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int a = soln(n,k);\\n        a+=1;                   // added 1 in \\'a\\' as the index of a vector starts from 0;\\n        return a;\\n    }\\n\\n    int soln(int n, int k){\\n        if(n==1) return 0;      // return 0 when n=1;\\n        int x = soln(n-1, k);   // final element x always is 0 as returned when n=1;\\n        int y = (x+k) % n;      // the actual mapping of the final \\n                                // element to our original number of person ;\\n        return y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int a = soln(n,k);\\n        a+=1;                   // added 1 in \\'a\\' as the index of a vector starts from 0;\\n        return a;\\n    }\\n\\n    int soln(int n, int k){\\n        if(n==1) return 0;      // return 0 when n=1;\\n        int x = soln(n-1, k);   // final element x always is 0 as returned when n=1;\\n        int y = (x+k) % n;      // the actual mapping of the final \\n                                // element to our original number of person ;\\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619957,
                "title": "c-deque-easy-and-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(k==1) return n;\\n        deque<int> dq;\\n        \\n        for(int i=1; i<=n; i++){\\n            dq.push_back(i);\\n        }\\n        \\n        while(dq.size()!=1){\\n            for(int i=0; i<k-1; i++){\\n                int x = dq.front();\\n                dq.pop_front();\\n                dq.push_back(x);\\n            }\\n             dq.pop_front();\\n        }\\n         return dq.front();\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        if(k==1) return n;\\n        deque<int> dq;\\n        \\n        for(int i=1; i<=n; i++){\\n            dq.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1615677,
                "title": "my-python-solution-deque",
                "content": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circular_queue = deque(range(1, n+1))\\n        \\n        circular_queue.rotate(-k)\\n        while len(circular_queue) != 1:\\n            circular_queue.pop()\\n            circular_queue.rotate(-k)\\n        \\n        return circular_queue.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findTheWinner(self, n: int, k: int) -> int:\\n        circular_queue = deque(range(1, n+1))\\n        \\n        circular_queue.rotate(-k)\\n        while len(circular_queue) != 1:\\n            circular_queue.pop()\\n            circular_queue.rotate(-k)\\n        \\n        return circular_queue.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598341,
                "title": "simple-js-solution-using-array",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findTheWinner = function(n, k) {\\n    let friends = Array.from({length: n}, (_, index) => index + 1)\\n    let start = 0;\\n    while(friends.length != 1){\\n        start += (k - 1)\\n        start = start % friends.length\\n        friends.splice(start,1)\\n    }\\n    return friends[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findTheWinner = function(n, k) {\\n    let friends = Array.from({length: n}, (_, index) => index + 1)\\n    let start = 0;\\n    while(friends.length != 1){\\n        start += (k - 1)\\n        start = start % friends.length\\n        friends.splice(start,1)\\n    }\\n    return friends[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1580669,
                "title": "c-solution-queue-simulation",
                "content": "We can mimic the process with simple queue.\\nwe can remove the Kth element while we can rotate all else elements in the queue until there\\'s only one element exists which is our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n        queue<int>q;\\n        for(auto i = 1;i<=n;i++)\\n            q.push(i);\\n        int kk = 1;\\n        while(q.size()!=1)\\n        {\\n            if(kk==k)\\n            {\\n                kk = 1;\\n                q.pop();\\n            }\\n            else\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                q.push(temp);\\n                kk++;\\n            }\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) \\n    {\\n        queue<int>q;\\n        for(auto i = 1;i<=n;i++)\\n            q.push(i);\\n        int kk = 1;\\n        while(q.size()!=1)\\n        {\\n            if(kk==k)\\n            {\\n                kk = 1;\\n                q.pop();\\n            }\\n            else\\n            {\\n                int temp = q.front();\\n                q.pop();\\n                q.push(temp);\\n                kk++;\\n            }\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1561818,
                "title": "go-recursion-100",
                "content": "```\\nfunc findTheWinner(n int, k int) int {\\n    return joseph(n, k)\\n}\\n\\nfunc joseph(n int, k int) int {\\n    if n==1 {\\n        return 1\\n    }\\n    return (joseph(n-1, k)+k-1)%n+1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findTheWinner(n int, k int) int {\\n    return joseph(n, k)\\n}\\n\\nfunc joseph(n int, k int) int {\\n    if n==1 {\\n        return 1\\n    }\\n    return (joseph(n-1, k)+k-1)%n+1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1526389,
                "title": "0-ms-best-solution-recusion-3-line-code",
                "content": "class Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(n==1){\\n           return 1; \\n        }\\n        int x = findTheWinner(n-1,k);\\n        int y = (x+k) % n==0 ? n :(x+k) % n ;\\n        return y;\\n                 \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(n==1){\\n           return 1; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1473088,
                "title": "c-easy-using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) { \\n        vector<int>v(n);\\n        for(int i=1;i<=n;i++)v[i-1]=i;\\n        int i=0;\\n        while(v.size()>1){ \\n            i=( (i+k-1) %v.size() );\\n            v.erase( v.begin()+i );\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) { \\n        vector<int>v(n);\\n        for(int i=1;i<=n;i++)v[i-1]=i;\\n        int i=0;\\n        while(v.size()>1){ \\n            i=( (i+k-1) %v.size() );\\n            v.erase( v.begin()+i );\\n        }\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459225,
                "title": "java-clean-concise-optimal-code-josephus-problem-o-n-time",
                "content": "```\\nclass Solution {\\n    \\n    private int josephusProblem (int n, int k) {\\n        \\n        return n == 1 ? 0 : (josephusProblem (n - 1, k) + k) % n;\\n    }\\n    \\n    public int findTheWinner(int n, int k) {\\n        \\n        return 1 + josephusProblem (n, k);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int josephusProblem (int n, int k) {\\n        \\n        return n == 1 ? 0 : (josephusProblem (n - 1, k) + k) % n;\\n    }\\n    \\n    public int findTheWinner(int n, int k) {\\n        \\n        return 1 + josephusProblem (n, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441103,
                "title": "simple-c-code-using-vector",
                "content": "I am using vector to get index of next element to be deleted in O(1) time and then deleting the element using vector::erase() function.\\n```\\nint findTheWinner(int n, int k) {\\n\\tif(k==1)\\n\\t\\treturn n;\\n\\n\\tvector<int> v;\\n\\tfor(int i=1 ; i<=n ; ++i)\\n\\t\\tv.push_back(i);\\n\\n\\tint offset = 0;\\n\\twhile(v.size()>1) {\\n\\t\\toffset = (offset+k-1)%v.size();\\n\\t\\tv.erase(v.begin()+offset);\\n\\t}\\n\\treturn v[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findTheWinner(int n, int k) {\\n\\tif(k==1)\\n\\t\\treturn n;\\n\\n\\tvector<int> v;\\n\\tfor(int i=1 ; i<=n ; ++i)\\n\\t\\tv.push_back(i);\\n\\n\\tint offset = 0;\\n\\twhile(v.size()>1) {\\n\\t\\toffset = (offset+k-1)%v.size();\\n\\t\\tv.erase(v.begin()+offset);\\n\\t}\\n\\treturn v[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430864,
                "title": "c-one-line-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int i, res=0;\\n        for(i=1; i<=n; i++) res = (res + k) % i;\\n        return res + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int i, res=0;\\n        for(i=1; i<=n; i++) res = (res + k) % i;\\n        return res + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430861,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(int n, int k){\\n        if(n==1) return 1;\\n        return (fun(n-1, k)+ k-1)% n +1;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return fun(n, k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int n, int k){\\n        if(n==1) return 1;\\n        return (fun(n-1, k)+ k-1)% n +1;\\n    }\\n    int findTheWinner(int n, int k) {\\n        return fun(n, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398924,
                "title": "find-the-winner-of-the-circular-game-cpp-c-with-explanation",
                "content": "**Explanation**\\nThis is a classic josephus problem. It\\'s very easy to implement but the main part of this question is to understand that what it is saying. Let\\'s solve this together.\\n\\nSo, the question says, there are n friends sitting in a circle and we have also one more variable k. As the rule says, start from the 1st friend and count the next k friends in clockwise direction including the friend you started at. Now, the last friend you counted after k leaves the circle and loses the game. See figure below,\\n\\n![image](https://assets.leetcode.com/users/images/9376ff8c-443a-4a77-bc08-4e6b4258f516_1628752294.7855227.png)\\n\\nIn the figure you can see that n=5, and k=2. If you will dry run this example you will endup having 3 as a winner of the game. So, now we have understood the problem so far.\\n\\nNow, if we flatten the cirlce into an array, so it will be\\n`1, 2, 3, 4, 5` for `n = 5, k=2`\\n\\nNow, here we know that the players are leaving the game after the k count, or effectively we can say that the elements are getting deleted. Also, let\\'s design our hypothesis function that how it will work.\\n\\n![image](https://assets.leetcode.com/users/images/8baf6a95-cbb1-4328-b4cf-0c4391bbd90a_1628752433.7937167.png)\\n\\nWe can see that from the figure above the ele from the array is deleted after every call but there is one catch here. We can see that we are at 5 now from the above figure, but don\\'t know how to move further because if we do so we will have index overflow problem. So, to remove this we have to do something like, `index = (index + k) % v.size()`\\n\\nNow, we have solved the index overflow also. Now, we have everything set, Let\\'s talk about the base:\\n* If the array size is 1 then just return the element because we have a winner.\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    //Time: O(N), Space: O(N)\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for(int i=1; i<=n; i++){\\n            v.push_back(i);\\n        }\\n        \\n        k = k-1;\\n        int index = 0;\\n        int result = -1;\\n        helper(v, k, index, result);\\n        return result;\\n    }\\n    \\n    void helper(vector<int>& v, int k, int index, int& result){\\n        //Base condition\\n        if(v.size() == 1){\\n            result = v[0];\\n            return;\\n        }\\n        \\n        //handles the index overflow\\n        index = (index + k) % v.size();\\n        //player will leave the circle\\n        v.erase(v.begin() + index);\\n        helper(v, k, index, result);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Time: O(N), Space: O(N)\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for(int i=1; i<=n; i++){\\n            v.push_back(i);\\n        }\\n        \\n        k = k-1;\\n        int index = 0;\\n        int result = -1;\\n        helper(v, k, index, result);\\n        return result;\\n    }\\n    \\n    void helper(vector<int>& v, int k, int index, int& result){\\n        //Base condition\\n        if(v.size() == 1){\\n            result = v[0];\\n            return;\\n        }\\n        \\n        //handles the index overflow\\n        index = (index + k) % v.size();\\n        //player will leave the circle\\n        v.erase(v.begin() + index);\\n        helper(v, k, index, result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354796,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> v, int idx, int k, int &ans){\\n        //base case\\n        if(v.size()==1){\\n            ans=v[0];\\n            return;\\n        }\\n        idx = (idx + k) % v.size();\\n        v.erase(v.begin() + idx);\\n        solve(v, idx, k, ans);\\n        \\n    }\\n    int findTheWinner(int n, int k) {\\n        vector<int> vec;\\n        for(int i = 1 ; i <= n ; i++){\\n            vec.push_back(i);\\n        }\\n        k = k - 1;\\n        int ans;\\n        solve(vec ,0, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int> v, int idx, int k, int &ans){\\n        //base case\\n        if(v.size()==1){\\n            ans=v[0];\\n            return;\\n        }\\n        idx = (idx + k) % v.size();\\n        v.erase(v.begin() + idx);\\n        solve(v, idx, k, ans);\\n        \\n    }\\n    int findTheWinner(int n, int k) {\\n        vector<int> vec;\\n        for(int i = 1 ; i <= n ; i++){\\n            vec.push_back(i);\\n        }\\n        k = k - 1;\\n        int ans;\\n        solve(vec ,0, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344087,
                "title": "everyone-is-running-behind-the-suggested-ds-how-a-circular-linked-list-will-help-you",
                "content": "What if we can build a circular linked list ?\\n1->2->3->4->5->1, k=2,  currNode=1\\n1. Find (k-1)-th node from currNode and delete next of currNode.\\n2. Recure for remains linked list.\\n3. Base case :\\n\\t\\t1. \\t\\tIf you have linkedList of size 1, then just return the data at that node (Keep track of length so that you can find the length in each recursive call in constant time).\\n\\t\\t2. \\t\\tSecond base case which will violate our algo is when k=1, then in this case we have to delete our crrNode, so we wouldn\\'t able to linked the prev of currNode to the next of currNode, but wait; Is it really need to process k==1? No, We all know each time each player removed and at the end last one be remains.\\n\\n```\\nclass Solution {\\n   public:\\n    int solve(int k, Node* curr, int len) {\\n        if (len == 1) {\\n            return curr->data;\\n        }\\n        int x = 1;\\n        while (x < k - 1) {\\n            curr = curr->next;\\n            x++;\\n        }\\n        Node* del = curr->next;\\n        curr->next = del->next;\\n        delete del;\\n        return solve(k, curr->next, len - 1);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        if (k == 1) return n;\\n        Node *node = nullptr, *tell = nullptr;\\n        int i = 1;\\n        while (i <= n) {\\n            if (node == nullptr) {\\n                node = new Node(i);\\n                tell = node;\\n            } else {\\n                tell->next = new Node(i);\\n                tell = tell->next;\\n            }\\n            i++;\\n        }\\n        tell->next = node;\\n        return solve(k, node, n);\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public:\\n    int solve(int k, Node* curr, int len) {\\n        if (len == 1) {\\n            return curr->data;\\n        }\\n        int x = 1;\\n        while (x < k - 1) {\\n            curr = curr->next;\\n            x++;\\n        }\\n        Node* del = curr->next;\\n        curr->next = del->next;\\n        delete del;\\n        return solve(k, curr->next, len - 1);\\n    }\\n\\n    int findTheWinner(int n, int k) {\\n        if (k == 1) return n;\\n        Node *node = nullptr, *tell = nullptr;\\n        int i = 1;\\n        while (i <= n) {\\n            if (node == nullptr) {\\n                node = new Node(i);\\n                tell = node;\\n            } else {\\n                tell->next = new Node(i);\\n                tell = tell->next;\\n            }\\n            i++;\\n        }\\n        tell->next = node;\\n        return solve(k, node, n);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294041,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        \\n        int store=findTheWinner(n-1,k)+k;\\n        if(store%n==0)\\n            return n;\\n        return store%n;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int findTheWinner(int n, int k) {\\n        if(n==1)\\n            return 1;\\n        \\n        int store=findTheWinner(n-1,k)+k;\\n        if(store%n==0)\\n            return n;\\n        return store%n;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1252137,
                "title": "using-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n       vector<int> temp;\\n        for(int i = 1;i<=n;i++)\\n            temp.push_back(i);\\n        int j = 0;\\n        while(temp.size()>1)\\n        {   int len = temp.size();\\n            j= (j+k-1)%len;\\n            temp.erase(temp.begin()+j);\\n            j--;\\n            j = (j+1)%temp.size();\\n        }\\n        return temp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n       vector<int> temp;\\n        for(int i = 1;i<=n;i++)\\n            temp.push_back(i);\\n        int j = 0;\\n        while(temp.size()>1)\\n        {   int len = temp.size();\\n            j= (j+k-1)%len;\\n            temp.erase(temp.begin()+j);\\n            j--;\\n            j = (j+1)%temp.size();\\n        }\\n        return temp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225476,
                "title": "c-recursion-time-o-n-space-o-n",
                "content": "```]\\nclass Solution {\\npublic:\\n    int find_winner(int n,int k){\\n         \\n        if(n == 1)\\n            return n;\\n        // this is a simple math that if n people are in a circle then remainder(k%n) shows the kth\\n        // person starting from 1 after (int)(k/n) complete cycles.\\n        // if remainder is 0 that means nth person is kth person starting \\n        // from 1 after (int)(k/n)  complete cycles.\\n        \\n        int killed = ( k % n == 0) ? n : (k % n);\\n        \\n        \\n        // getting the winner from (n-1,k) and mapping it with (n,k)\\n        // so mapping is like this:-\\n        // next person after killed person in circle(n,k) will be 1st person in new circle(n-1,k)\\n        // so suppose winner of the child circle (n-1,k) is w, then in the \\n        // parent circle (n,k), new winner is killed of(n,k) + w( that is winner(n-1,k) )\\n        // sometimes what happens is that killed(n,k) + w( that is winner(n-1,k) ) becomes more than n\\n        // that is why we want modulo of position of new winner with n once again\\n        \\n        int winner = killed + find_winner(n-1,k);\\n        return (winner % n == 0) ? n : (winner % n);\\n    }\\n    int findTheWinner(int n, int k) {\\n        \\n        return find_winner(n,k);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find_winner(int n,int k){\\n         \\n        if(n == 1)\\n            return n;\\n        // this is a simple math that if n people are in a circle then remainder(k%n) shows the kth\\n        // person starting from 1 after (int)(k/n) complete cycles.\\n        // if remainder is 0 that means nth person is kth person starting \\n        // from 1 after (int)(k/n)  complete cycles.\\n        \\n        int killed = ( k % n == 0) ? n : (k % n);\\n        \\n        \\n        // getting the winner from (n-1,k) and mapping it with (n,k)\\n        // so mapping is like this:-\\n        // next person after killed person in circle(n,k) will be 1st person in new circle(n-1,k)\\n        // so suppose winner of the child circle (n-1,k) is w, then in the \\n        // parent circle (n,k), new winner is killed of(n,k) + w( that is winner(n-1,k) )\\n        // sometimes what happens is that killed(n,k) + w( that is winner(n-1,k) ) becomes more than n\\n        // that is why we want modulo of position of new winner with n once again\\n        \\n        int winner = killed + find_winner(n-1,k);\\n        return (winner % n == 0) ? n : (winner % n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1215438,
                "title": "java-bottom-up-dp-time-o-n-space-o-1",
                "content": "```\\npublic int findTheWinner(int n, int k) {\\n\\tint winner = 1;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\twinner = (winner+k-1)%i+1;\\n\\t}\\n\\treturn winner;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findTheWinner(int n, int k) {\\n\\tint winner = 1;\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\twinner = (winner+k-1)%i+1;\\n\\t}\\n\\treturn winner;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197745,
                "title": "java-easy-to-understand-recursion",
                "content": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {        \\n        List<Integer> list = new ArrayList<>();\\n        for (int i=0; i<n; i++) {\\n            list.add(i+1);\\n        }\\n        \\n        int ans = helper(list, k - 1, 0);\\n        \\n        return ans;\\n    }\\n    \\n    private static int helper(List<Integer> list, int k, int index) {\\n        int size = list.size();\\n        \\n        if (size == 1) {\\n            return list.get(0);\\n        }\\n        \\n        index = (index + k) % size;\\n        list.remove(index);\\n        \\n        return helper(list, k, index);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {        \\n        List<Integer> list = new ArrayList<>();\\n        for (int i=0; i<n; i++) {\\n            list.add(i+1);\\n        }\\n        \\n        int ans = helper(list, k - 1, 0);\\n        \\n        return ans;\\n    }\\n    \\n    private static int helper(List<Integer> list, int k, int index) {\\n        int size = list.size();\\n        \\n        if (size == 1) {\\n            return list.get(0);\\n        }\\n        \\n        index = (index + k) % size;\\n        list.remove(index);\\n        \\n        return helper(list, k, index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158457,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        li = [i for i in range(1,n+1)]\\n        k = k-1\\n        offset = k\\n        while len(li) >1:\\n            li.pop(offset)\\n            offset = (offset+k) % len(li)\\n        return li[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findTheWinner(self, n, k):\\n        li = [i for i in range(1,n+1)]\\n        k = k-1\\n        offset = k\\n        while len(li) >1:\\n            li.pop(offset)\\n            offset = (offset+k) % len(li)\\n        return li[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155597,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func findTheWinner(_ n: Int, _ k: Int) -> Int {\\n        var friends = Array(1...n), loser = 0\\n        for i in 1..<n {\\n            loser = (loser + k - 1) % friends.count\\n            friends.remove(at: loser)\\n        }\\n        return friends.first!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findTheWinner(_ n: Int, _ k: Int) -> Int {\\n        var friends = Array(1...n), loser = 0\\n        for i in 1..<n {\\n            loser = (loser + k - 1) % friends.count\\n            friends.remove(at: loser)\\n        }\\n        return friends.first!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154159,
                "title": "c-1823-find-the-winner-of-the-circular-game",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> nums(n); \\n        for (int i = 0; i < n; ++i) \\n            nums[i] = i + 1; \\n        \\n        int i = 0; \\n        while (nums.size() > 1) {\\n            i = (i + k - 1) % nums.size(); \\n            nums.erase(nums.begin() + i); \\n        }\\n        return nums[0]; \\n    }\\n};\\n```\\n\\n**Approach 2 -- dp**\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0; \\n        for (int x = 2; x <= n; ++x)\\n            ans = (ans + k) % x; \\n        return ans + 1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> nums(n); \\n        for (int i = 0; i < n; ++i) \\n            nums[i] = i + 1; \\n        \\n        int i = 0; \\n        while (nums.size() > 1) {\\n            i = (i + k - 1) % nums.size(); \\n            nums.erase(nums.begin() + i); \\n        }\\n        return nums[0]; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        int ans = 0; \\n        for (int x = 2; x <= n; ++x)\\n            ans = (ans + k) % x; \\n        return ans + 1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152920,
                "title": "java-list-simple-qn-query-reply-solution",
                "content": "Don\\'t be too picky!! Do what the question wants!!\\n```\\nclass Solution {\\n\\n\\tpublic int findTheWinner(int n, int k) {\\n\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\tint lastInd = 0;\\n\\t\\twhile (list.size() != 1) {\\n\\t\\t\\tlastInd = (lastInd + k - 1) % (list.size());\\n\\t\\t\\tlist.remove(lastInd);\\n\\t\\t}\\n\\t\\treturn list.get(0);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n\\tpublic int findTheWinner(int n, int k) {\\n\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\tfor (int i = 1; i <= n; i++)\\n\\t\\t\\tlist.add(i);\\n\\n\\t\\tint lastInd = 0;\\n\\t\\twhile (list.size() != 1) {\\n\\t\\t\\tlastInd = (lastInd + k - 1) % (list.size());\\n\\t\\t\\tlist.remove(lastInd);\\n\\t\\t}\\n\\t\\treturn list.get(0);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152740,
                "title": "easy-queue-solution-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue <int> q;\\n        for(int i=1;i<=n;i++)\\n            q.push(i);\\n        while(q.size()>1)\\n        {\\n            int t=k;\\n            while(--t>=1)\\n            {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue <int> q;\\n        for(int i=1;i<=n;i++)\\n            q.push(i);\\n        while(q.size()>1)\\n        {\\n            int t=k;\\n            while(--t>=1)\\n            {\\n                q.push(q.front());\\n                q.pop();\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152561,
                "title": "arraylist",
                "content": "```\\n    fun findTheWinner(n: Int, k: Int): Int {\\n        val group = ArrayList<Int>()\\n        for (i in 1..n) group.add(i)\\n        var prevIdx = 0\\n        while (group.size != 1) {\\n            val loserIdx = (prevIdx + k - 1) % group.size\\n            group.removeAt(loserIdx)\\n            prevIdx = loserIdx\\n        }\\n        return group[0]\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun findTheWinner(n: Int, k: Int): Int {\\n        val group = ArrayList<Int>()\\n        for (i in 1..n) group.add(i)\\n        var prevIdx = 0\\n        while (group.size != 1) {\\n            val loserIdx = (prevIdx + k - 1) % group.size\\n            group.removeAt(loserIdx)\\n            prevIdx = loserIdx\\n        }\\n        return group[0]\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152503,
                "title": "c-simple-solution-with-comments-do-as-directed",
                "content": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        //Temp array to hold the active candidates.\\n        vector<int> circular(n);        \\n        for(int i = 0; i< n; i++){\\n            circular[i] = i+1;            \\n        }\\n        \\n        \\n        int start = 0;        \\n        while(true){      \\n            //Check if only one element is remaining.\\n            if(circular.size() ==  1)\\n                break;\\n                        \\n            start += (k-1);                         //Add k to current (start is inclusive.)\\n            start %= circular.size();               //Array size is changing, remain in boundary\\n            circular.erase(circular.begin() + start);//Erase the selected candidate.\\n        }\\n        \\n        return circular[0]; //Return the winner, only 1st element.                \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        \\n        //Temp array to hold the active candidates.\\n        vector<int> circular(n);        \\n        for(int i = 0; i< n; i++){\\n            circular[i] = i+1;            \\n        }\\n        \\n        \\n        int start = 0;        \\n        while(true){      \\n            //Check if only one element is remaining.\\n            if(circular.size() ==  1)\\n                break;\\n                        \\n            start += (k-1);                         //Add k to current (start is inclusive.)\\n            start %= circular.size();               //Array size is changing, remain in boundary\\n            circular.erase(circular.begin() + start);//Erase the selected candidate.\\n        }\\n        \\n        return circular[0]; //Return the winner, only 1st element.                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152444,
                "title": "c-using-list",
                "content": "```\\npublic int FindTheWinner(int n, int k) {\\n        var list = new List<int>();\\n        for (var i = 1; i <= n; i++)\\n            list.Add(i);\\n        \\n        var index = 0;\\n        while (list.Count > 1)\\n        {\\n            index = (index + k - 1) % list.Count;\\n            list.RemoveAt(index);\\n        }\\n        \\n        return list[0];\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int FindTheWinner(int n, int k) {\\n        var list = new List<int>();\\n        for (var i = 1; i <= n; i++)\\n            list.Add(i);\\n        \\n        var index = 0;\\n        while (list.Count > 1)\\n        {\\n            index = (index + k - 1) % list.Count;\\n            list.RemoveAt(index);\\n        }\\n        \\n        return list[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4052776,
                "title": "easy-cirular-linkelist",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(k==1){\\n            return n;\\n        }\\n        ListNode head =new ListNode(1);\\n        ListNode temp=head;\\n        for(int i=2; i<=n; i++){\\n            temp.next=new ListNode(i);\\n            temp=temp.next;\\n        }\\n        temp.next=head;\\n        int count=n;\\n        while(count>1){\\n            for(int i=1; i<k-1 ; i++){\\n                head=head.next;\\n            }\\n            head.next=head.next.next;\\n            head=head.next;\\n            --count;\\n        }\\n        return head.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        if(k==1){\\n            return n;\\n        }\\n        ListNode head =new ListNode(1);\\n        ListNode temp=head;\\n        for(int i=2; i<=n; i++){\\n            temp.next=new ListNode(i);\\n            temp=temp.next;\\n        }\\n        temp.next=head;\\n        int count=n;\\n        while(count>1){\\n            for(int i=1; i<k-1 ; i++){\\n                head=head.next;\\n            }\\n            head.next=head.next.next;\\n            head=head.next;\\n            --count;\\n        }\\n        return head.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046763,
                "title": "js-simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findTheWinner = function(n, k) {\\n    const array = Array.from({ length: n }, (_, index) => index + 1);\\n    var i=0;\\n    while (array.length > 1) {\\n        i = (i + k - 1) % array.length;\\n        array.splice(i, 1);\\n    }\\n    return array[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findTheWinner = function(n, k) {\\n    const array = Array.from({ length: n }, (_, index) => index + 1);\\n    var i=0;\\n    while (array.length > 1) {\\n        i = (i + k - 1) % array.length;\\n        array.splice(i, 1);\\n    }\\n    return array[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036733,
                "title": "circular-linked-list-you-will-learn-so-many-concepts-from-my-code-check-it-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public class Node {\\n        int data;\\n        Node next;\\n\\n        public Node(int data) {\\n            this.data = data;\\n        }\\n    }\\n\\n    public int findTheWinner(int n, int k) {\\n        Node prev = newone(n);\\n        Node curr=prev.next;\\n        \\n      \\n\\n        while (n > 1) {\\n            \\n            int count = (k-1) % n;\\n            while(count>0) {\\n                prev = curr;\\n                curr = curr.next;\\n                count--;\\n            }\\n\\n            prev.next = curr.next;\\n            curr = curr.next;\\n            n--;\\n        }\\n\\n        return curr.data;\\n    }\\n    public Node newone(int n)\\n    {\\n        Node first=new Node(1);\\n        Node curr=first;\\n        for (int i = 2; i <= n; i++) {\\n            Node temp=new Node(i);\\n            curr.next=temp;\\n            curr=temp;\\n\\n        }\\n        curr.next=first;\\n        return curr;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public class Node {\\n        int data;\\n        Node next;\\n\\n        public Node(int data) {\\n            this.data = data;\\n        }\\n    }\\n\\n    public int findTheWinner(int n, int k) {\\n        Node prev = newone(n);\\n        Node curr=prev.next;\\n        \\n      \\n\\n        while (n > 1) {\\n            \\n            int count = (k-1) % n;\\n            while(count>0) {\\n                prev = curr;\\n                curr = curr.next;\\n                count--;\\n            }\\n\\n            prev.next = curr.next;\\n            curr = curr.next;\\n            n--;\\n        }\\n\\n        return curr.data;\\n    }\\n    public Node newone(int n)\\n    {\\n        Node first=new Node(1);\\n        Node curr=first;\\n        for (int i = 2; i <= n; i++) {\\n            Node temp=new Node(i);\\n            curr.next=temp;\\n            curr=temp;\\n\\n        }\\n        curr.next=first;\\n        return curr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972902,
                "title": "simple-vector-solution-faster-than-100",
                "content": "# Intuition\\nCreating the temp vector: The vector is used to simulate the circle of people, with values from 1 to n representing the positions of individuals in the circle.\\n\\nThe while loop: This loop continues until there\\'s only one person left in the circle.\\n\\nCalculating t: In each iteration of the loop, the size of the temp vector is calculated (t = temp.size()). This represents the number of people remaining in the circle.\\n\\nUpdating i: The line i = (i + k - 1) % t is responsible for finding the position of the person to be eliminated in the current iteration. The i variable keeps track of the current position in the circle, and (i + k - 1) % t calculates the new position after counting k steps around the circle. The % t operation ensures that the counting wraps around when the end of the circle is reached.\\n\\nRemoving the person: The line temp.erase(temp.begin() + i) removes the person at the calculated position from the temp vector, simulating their elimination from the circle.\\n\\nLoop continues: The loop continues until there\\'s only one person left in the circle. This process models the elimination of every k-th person until only one person remains.\\n\\nReturning the winner: Once the loop finishes, the remaining person\\'s position is the winner of the game, and their position (index) in the temp vector is returned.\\n\\n# Approach\\nInitialization: Create a vector temp containing integers from 1 to n, representing the initial positions of people in the circle.\\n\\nLoop: Enter a loop that continues as long as there is more than one person remaining in the circle (temp.size() > 1).\\n\\nPosition Calculation (i update): Calculate the new position to eliminate using the formula i = (i + k - 1) % t, where:\\n\\ni is the current position to start counting from.\\nk is the step size, indicating how many people to skip before eliminating someone.\\nt is the number of remaining people in the circle (temp.size()).\\nThis formula calculates the position of the person to be eliminated in the current iteration. The -1 is needed to account for the 0-based index.\\n\\nElimination: Remove the person at the calculated position (temp[i]) from the vector temp. This simulates their elimination from the circle.\\n\\nLoop Continuation: The loop continues, repeating steps 3 and 4, until only one person remains in the circle.\\n\\nResult: After the loop finishes, return the value of the last remaining person in the temp vector, which corresponds to the 0-based index of the winner.\\n\\nThe key insight of this approach is that it models the elimination process iteratively. In each iteration of the loop, the person at the calculated position is removed, effectively skipping over k-1 people before eliminating someone. This approach ensures that the elimination process progresses in a circular manner until only one person is left standing. The position update formula (i = (i + k - 1) % t) is crucial for determining the next person to eliminate.\\n\\n# Complexity\\n- Time complexity:\\n- O(N*N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int>temp;\\n\\n        for(int i=1;i<=n;i++) temp.push_back(i);\\n\\n        int i=0;\\n\\n        while(temp.size()>1){\\n            int t=temp.size();\\n            i=(i+k-1)%t;\\n            temp.erase(temp.begin()+i);\\n        }\\n        return *temp.begin();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Recursion",
                    "Queue",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int>temp;\\n\\n        for(int i=1;i<=n;i++) temp.push_back(i);\\n\\n        int i=0;\\n\\n        while(temp.size()>1){\\n            int t=temp.size();\\n            i=(i+k-1)%t;\\n            temp.erase(temp.begin()+i);\\n        }\\n        return *temp.begin();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926739,
                "title": "100-faster-using-recursion-7-lines-cpp-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int solve(int n,int k){\\n     if(n==1){\\n         return 0;\\n     }\\n    return  (solve(n-1,k) +k)%n;\\n }\\n    int findTheWinner(int n, int k) {\\n        int ans= solve(n,k) +1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int solve(int n,int k){\\n     if(n==1){\\n         return 0;\\n     }\\n    return  (solve(n-1,k) +k)%n;\\n }\\n    int findTheWinner(int n, int k) {\\n        int ans= solve(n,k) +1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867537,
                "title": "find-the-winner-of-the-circular-game-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> arr = new LinkedList<>();\\n        for(int i=1; i<=n; i++){\\n            arr.add(i);\\n        }\\n\\n        while(arr.size() != 1){\\n            for(int i=k-1; i>0; i--){\\n                arr.add(arr.poll());\\n            }\\n            arr.poll();\\n        }\\n        return arr.poll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> arr = new LinkedList<>();\\n        for(int i=1; i<=n; i++){\\n            arr.add(i);\\n        }\\n\\n        while(arr.size() != 1){\\n            for(int i=k-1; i>0; i--){\\n                arr.add(arr.poll());\\n            }\\n            arr.poll();\\n        }\\n        return arr.poll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1679552,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1693744,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1820347,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2017651,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1932480,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1879886,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1760384,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2067307,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2011165,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1988298,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1679552,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1693744,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1820347,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2017651,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1932480,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1879886,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1760384,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2067307,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 2011165,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            },
            {
                "id": 1988298,
                "content": [
                    {
                        "username": "Vishesh2001",
                        "content": "@\\nApproach:\\nI am using queue data structure, so that i can move the items from one end to another linearly.\\nwe have given \\'K\\' the moves we can shift, so after shifting K-1 items to the end of the queue, I am deleting the front element.\\nOn repeating the above step, a stage will come when only one element will be left, this is answer itself.\\n\\nTime complexity: O(N+K)\\nspace complexity: O(N) \\n \\n\\n\\n\\n`class Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n\\n        queue<int> q;\\n        int i=1;\\n        while(i<=n){\\n        q.push(i);\\n        i++;\\n        }\\n\\n        while(q.size()!=1){\\n\\n            int j=1;\\n            while(j<k){\\n                int temp=q.front();\\n                q.push(temp);\\n                q.pop();\\n                j++;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};`"
                    },
                    {
                        "username": "ychokhani7",
                        "content": "Yes the time complexity will be O(n*k)"
                    },
                    {
                        "username": "arjun202",
                        "content": "I think the time complexity will be O(n*K) and not O(n+k)."
                    },
                    {
                        "username": "andrewcleonard",
                        "content": "This is known as the \"Josephus problem.\" It\\'s well-known among mathematicians and computer scientists.\\nhttps://en.wikipedia.org/wiki/Josephus_problem"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I'm really confused why my brute force implementation in O(n**2) is faster than 93% of submissions in python3... Is it because the testcases are too small to penalize higher complexities properly?\nI'm just using the most naive apporach, using a list of friends and deleting the loser in O(n) each round. Yet the code runs in 29 ms, and I see submissions taking over 500 ms. I have absolutely no idea why my solution is relatively fast when it should be garbage"
                    },
                    {
                        "username": "ghoshalsomnath213",
                        "content": "probably because others are using recursion to do it"
                    },
                    {
                        "username": "Zxun2",
                        "content": "Can be solved using queue/circular LinkedList but would require some knowledge of the Josephus problem if you want to solve the Follow Up Question."
                    },
                    {
                        "username": "Msey",
                        "content": "what a shitty example png image"
                    },
                    {
                        "username": "naveen_vm",
                        "content": "[@Akash_Naik](/Akash_Naik) Switched from dark mode to light mode to solve this problem!"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "true lol, I thought my screen was glitched or something"
                    },
                    {
                        "username": "rohit__27",
                        "content": "Just go see the solution"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Josephus problem.\nUse Recursion-->Think like while making recursive calls we are deleting one person while moving so make n-1 like calls-->and Dont forget to add (+k)-->Try with test cases you will get the idea.  \n\nhttps://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/3058518/flipkart-line-by-line-explaination-with-diagrams-josephus-problem-recursion/"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n static int round(ArrayList<Integer> arr , int pointer , int k){\\n      if(arr.size()==2){\\n          if(pointer==0){\\n              if(k%2==0){\\n                  return arr.get(0);\\n              }else{\\n                  return arr.get(1);\\n              }\\n          }else {\\n              if(k%2==0){\\n                  return arr.get(1);\\n              }else {\\n                  return arr.get(0);\\n              }\\n          }\\n      }\\n      for(int i=1;i<k;i++){\\n          pointer++;\\n          if(pointer==arr.size()){\\n              pointer=0;\\n          }\\n      }\\n      arr.remove(pointer);\\n      if(pointer==arr.size()){\\n          pointer=0;\\n      }\\n      return round(arr,pointer,k);\\n    }\\n    public static int findTheWinner(int n, int k) {\\n        if(n==1){\\n            return 1;\\n        }\\n        ArrayList<Integer> arr = new ArrayList<>(n);\\n        for(int i=0;i<n;i++){\\n            arr.add(i,i+1);\\n        }\\n       return round(arr,0,k);\\n    }\\n\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "It was Easy i did this with ArrayList. I Don\\'t Know why its for Queue Data Structure."
                    },
                    {
                        "username": "user3734My",
                        "content": "Hii bro I am also trying to do it with arraylist but getting error....Can you help......\\nMy code:\\npublic int findTheWinner(int n, int k) {\\n        int t =n;\\n        int c =k;\\n        ArrayList<Integer> al = new ArrayList<>();\\n        for(int i=1;i<=n;i++)\\n        {\\n            al.add(i);\\n        }\\n        for(int i=0;i<al.size();i++)\\n        {\\n            int j=i;\\n            while(c>1)\\n            {\\n                c--;\\n                if(j==al.size())\\n                {\\n                    j=1;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            al.remove(j);\\n            c=k;\\n            if(i==al.size() && al.size()>1)\\n            {\\n                i=1;\\n            }\\n        }\\n        return al.get(0);\\n    }"
                    },
                    {
                        "username": "sandeepmit25",
                        "content": "anyone thought of using circular link list"
                    },
                    {
                        "username": "District_12",
                        "content": "[@bharsa09](/bharsa09) so proper solution is loop + array modification?"
                    },
                    {
                        "username": "bharsa09",
                        "content": "it can be done but in interview you may avoid it. Because it will become time exhausting."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Sideway Jumps",
        "question_content": "<p>There is a <strong>3 lane road</strong> of length <code>n</code> that consists of <code>n + 1</code> <strong>points</strong> labeled from <code>0</code> to <code>n</code>. A frog <strong>starts</strong> at point <code>0</code> in the <strong>second </strong>lane<strong> </strong>and wants to jump to point <code>n</code>. However, there could be obstacles along the way.</p>\n\n<p>You are given an array <code>obstacles</code> of length <code>n + 1</code> where each <code>obstacles[i]</code> (<strong>ranging from 0 to 3</strong>) describes an obstacle on the lane <code>obstacles[i]</code> at point <code>i</code>. If <code>obstacles[i] == 0</code>, there are no obstacles at point <code>i</code>. There will be <strong>at most one</strong> obstacle in the 3 lanes at each point.</p>\n\n<ul>\n\t<li>For example, if <code>obstacles[2] == 1</code>, then there is an obstacle on lane 1 at point 2.</li>\n</ul>\n\n<p>The frog can only travel from point <code>i</code> to point <code>i + 1</code> on the same lane if there is not an obstacle on the lane at point <code>i + 1</code>. To avoid obstacles, the frog can also perform a <strong>side jump</strong> to jump to <strong>another</strong> lane (even if they are not adjacent) at the <strong>same</strong> point if there is no obstacle on the new lane.</p>\n\n<ul>\n\t<li>For example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.</li>\n</ul>\n\n<p>Return<em> the <strong>minimum number of side jumps</strong> the frog needs to reach <strong>any lane</strong> at point n starting from lane <code>2</code> at point 0.</em></p>\n\n<p><strong>Note:</strong> There will be no obstacles on points <code>0</code> and <code>n</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex1.png\" style=\"width: 500px; height: 244px;\" />\n<pre>\n<strong>Input:</strong> obstacles = [0,1,2,3,0]\n<strong>Output:</strong> 2 \n<strong>Explanation:</strong> The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex2.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<strong>Input:</strong> obstacles = [0,1,1,3,3,0]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no obstacles on lane 2. No side jumps are required.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/25/ic234-q3-ex3.png\" style=\"width: 500px; height: 196px;\" />\n<pre>\n<strong>Input:</strong> obstacles = [0,2,1,0,3,0]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The optimal solution is shown by the arrows above. There are 2 side jumps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>obstacles.length == n + 1</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= obstacles[i] &lt;= 3</code></li>\n\t<li><code>obstacles[0] == obstacles[n] == 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1152665,
                "title": "java-c-python-dp-o-1-space",
                "content": "# **Explanation**\\ndp[0] = minimum jump to reach lane 1\\ndp[1] = minimum jump to reach lane 2\\ndp[2] = minimum jump to reach lane 3\\nIf meet a stone, set its `dp[i]` to infinity.\\nresult equals to  `min(dp)`\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minSideJumps(int[] A) {\\n        int[] dp = new int[]{1, 0, 1};\\n        for (int a: A) {\\n            if (a > 0)\\n                dp[a - 1] = 1000000;\\n            for (int i = 0; i < 3; ++i)\\n                if (a != i + 1)\\n                    dp[i] = Math.min(dp[i], Math.min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1);\\n        }\\n        return Math.min(dp[0], Math.min(dp[1], dp[2]));\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minSideJumps(vector<int>& A) {\\n        int dp[] = {1, 0, 1};\\n        for (int a: A) {\\n            if (a > 0)\\n                dp[a - 1] = 1e6;\\n            for (int i = 0; i < 3; ++i)\\n                if (a != i + 1)\\n                    dp[i] = min(dp[i], min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1);\\n        }\\n        return min(dp[0], min(dp[1], dp[2]));\\n    }\\n```\\n\\n**Python**\\n```py\\n    def minSideJumps(self, A):\\n        dp = [1, 0, 1]\\n        for a in A:\\n            if a:\\n                dp[a - 1] = float(\\'inf\\')\\n            for i in xrange(3):\\n                if a != i + 1:\\n                    dp[i] = min(dp[i], dp[(i + 1) % 3] + 1, dp[(i + 2) % 3] + 1)\\n        return min(dp)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minSideJumps(int[] A) {\\n        int[] dp = new int[]{1, 0, 1};\\n        for (int a: A) {\\n            if (a > 0)\\n                dp[a - 1] = 1000000;\\n            for (int i = 0; i < 3; ++i)\\n                if (a != i + 1)\\n                    dp[i] = Math.min(dp[i], Math.min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1);\\n        }\\n        return Math.min(dp[0], Math.min(dp[1], dp[2]));\\n    }\\n```\n```cpp\\n    int minSideJumps(vector<int>& A) {\\n        int dp[] = {1, 0, 1};\\n        for (int a: A) {\\n            if (a > 0)\\n                dp[a - 1] = 1e6;\\n            for (int i = 0; i < 3; ++i)\\n                if (a != i + 1)\\n                    dp[i] = min(dp[i], min(dp[(i + 1) % 3], dp[(i + 2) % 3]) + 1);\\n        }\\n        return min(dp[0], min(dp[1], dp[2]));\\n    }\\n```\n```py\\n    def minSideJumps(self, A):\\n        dp = [1, 0, 1]\\n        for a in A:\\n            if a:\\n                dp[a - 1] = float(\\'inf\\')\\n            for i in xrange(3):\\n                if a != i + 1:\\n                    dp[i] = min(dp[i], dp[(i + 1) % 3] + 1, dp[(i + 2) % 3] + 1)\\n        return min(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1152411,
                "title": "python-c-clean-dp-solution-with-explanation-o-n",
                "content": "**Idea**\\n\\nWe can use DP to solve this problem. `dp[i][r]` means the minimum jumps when the frog gets to point `i` lane `r` (0-index).\\n\\nThe base cases are:\\n\\n- `dp[0][0], dp[0][1], dp[0][2] = 1, 0, 1`\\n- `dp[i][r] = inf` when there\\'s obstacle at `(i, r)` or `(i+1, r)` \\n\\nAnd the transition function is:\\n\\n- `dp[i][r] = min([dp[i-1][r], dp[i-1][(r+1)%3] + 1,  dp[i-1][(r+2)%3] + 1]) for r = 0, 1, 2`\\n\\n`dp[i-1][r]` means the frog comes from the same lane, so there\\'s no jump needed; otherwise, the frog moves from point `i-1` to point `i` on another lane and jumps to `(i, r)`.\\n\\n</br>\\n\\n**Complexity**\\n\\n- Time complexity: `O(N)`\\n- Space complexity: `O(N)` or `O(1)` if we use rolling array\\n\\n</br>\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def minSideJumps(self, arr: List[int]) -> int:\\n        n = len(arr) - 1\\n        dp = [[0] * 3 for _ in range(n)]\\n        dp[0][0] = dp[0][2] = 1\\n        \\n        for i in range(1, n):\\n            for r in range(3):\\n                if arr[i] == r+1 or arr[i+1] == r+1:\\n                    dp[i][r] = float(\\'inf\\')\\n                else:\\n                    dp[i][r] = min([dp[i-1][r],\\n                                    dp[i-1][(r+1)%3] + 1, \\n                                    dp[i-1][(r+2)%3] + 1])\\n        return min(dp[-1])\\n```\\n\\n</br>\\n\\n**C++**\\n```C++\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& arr) {\\n        int n = arr.size() - 1;\\n        int dp[n][3];\\n        dp[0][1] = 0;\\n        dp[0][0] = dp[0][2] = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int r = 0; r < 3; ++r) {\\n                if (arr[i] == r+1 || arr[i+1] == r+1)\\n                    dp[i][r] = n;\\n                else\\n                    dp[i][r] = min(dp[i-1][r], min(dp[i-1][(r+1)%3],  dp[i-1][(r+2)%3]) + 1);\\n            }\\n        }\\n        \\n        return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def minSideJumps(self, arr: List[int]) -> int:\\n        n = len(arr) - 1\\n        dp = [[0] * 3 for _ in range(n)]\\n        dp[0][0] = dp[0][2] = 1\\n        \\n        for i in range(1, n):\\n            for r in range(3):\\n                if arr[i] == r+1 or arr[i+1] == r+1:\\n                    dp[i][r] = float(\\'inf\\')\\n                else:\\n                    dp[i][r] = min([dp[i-1][r],\\n                                    dp[i-1][(r+1)%3] + 1, \\n                                    dp[i-1][(r+2)%3] + 1])\\n        return min(dp[-1])\\n```\n```C++\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& arr) {\\n        int n = arr.size() - 1;\\n        int dp[n][3];\\n        dp[0][1] = 0;\\n        dp[0][0] = dp[0][2] = 1;\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int r = 0; r < 3; ++r) {\\n                if (arr[i] == r+1 || arr[i+1] == r+1)\\n                    dp[i][r] = n;\\n                else\\n                    dp[i][r] = min(dp[i-1][r], min(dp[i-1][(r+1)%3],  dp[i-1][(r+2)%3]) + 1);\\n            }\\n        }\\n        \\n        return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153269,
                "title": "java-recursion-memoization-top-down-explained",
                "content": "**Upvote if you found this helpful. :)**\\n```\\nclass Solution { \\n    public int minSideJumps(int[] obstacles) {\\n\\t    // 4 rows (lanes) -0,1,2,3 (ignore 0th row) || obstacles.length columns\\n        int dp[][] = new int[4][obstacles.length];\\n        for(int[] a : dp)\\n         Arrays.fill(a, -1); // fill whole dp with -1;\\n\\t\\t \\n        return minSideJumps( obstacles, 0, 2, dp); // start at 0th point at 2nd lane,\\n    }\\n    \\n    private int minSideJumps(int [] ob, int p, int lane, int dp[][]){\\n        if(p == ob.length-1) return 0;             // reached last point \\n        if( ob[p]==lane) return Integer.MAX_VALUE; // if encountered an obstacle\\n        if(dp[lane][p]!=-1) return dp[lane][p];    // if sub problem already solved\\n        \\n        if(ob[p+1]!=lane){                    // if the next point in lane has no obstacle\\n             dp[lane][p] =  minSideJumps(ob, p+1, lane, dp);\\n        }else{                                // if the next point in lane has  obstacle then we have 2 choices\\n            int l1 = lane-1 !=0 ? lane-1 : lane+2;\\n            int l2 = lane+1!=4 ? lane+1 : lane-2;\\n                                                //get the min of two choices\\n             dp[lane][p] =  1+ Math.min(minSideJumps(ob, p, l1, dp), minSideJumps(ob, p, l2, dp)); \\n        }\\n        return  dp[lane][p];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution { \\n    public int minSideJumps(int[] obstacles) {\\n\\t    // 4 rows (lanes) -0,1,2,3 (ignore 0th row) || obstacles.length columns\\n        int dp[][] = new int[4][obstacles.length];\\n        for(int[] a : dp)\\n         Arrays.fill(a, -1); // fill whole dp with -1;\\n\\t\\t \\n        return minSideJumps( obstacles, 0, 2, dp); // start at 0th point at 2nd lane,\\n    }\\n    \\n    private int minSideJumps(int [] ob, int p, int lane, int dp[][]){\\n        if(p == ob.length-1) return 0;             // reached last point \\n        if( ob[p]==lane) return Integer.MAX_VALUE; // if encountered an obstacle\\n        if(dp[lane][p]!=-1) return dp[lane][p];    // if sub problem already solved\\n        \\n        if(ob[p+1]!=lane){                    // if the next point in lane has no obstacle\\n             dp[lane][p] =  minSideJumps(ob, p+1, lane, dp);\\n        }else{                                // if the next point in lane has  obstacle then we have 2 choices\\n            int l1 = lane-1 !=0 ? lane-1 : lane+2;\\n            int l2 = lane+1!=4 ? lane+1 : lane-2;\\n                                                //get the min of two choices\\n             dp[lane][p] =  1+ Math.min(minSideJumps(ob, p, l1, dp), minSideJumps(ob, p, l2, dp)); \\n        }\\n        return  dp[lane][p];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152455,
                "title": "java-c-python-dp-greedy-bonus",
                "content": "#### DP\\n\\nFor each step, we first determine a lane with an obstacle, and set its number of jumps to a large number.\\n\\nFor every other lane, the number of side jumps is the smallest among:\\n- The number of jumps for the current lane, or\\n- The number of jums for other lines plus 1.\\n\\nHere is the annotated example from the problem description:\\n![image](https://assets.leetcode.com/users/images/5a088469-1201-4daa-8ecf-d0db02471bec_1618118068.5978096.png)\\n\\n**Java**\\n```java\\npublic int minSideJumps(int[] obstacles) {\\n    int[] dp = {1000000,1,0,1};\\n    for (var i : obstacles) {\\n        dp[i] = dp[0];\\n        for (var j = 1; j < 4; ++j)\\n            if (j != i)\\n                for (var k = 1; k < 4; ++k)\\n                    dp[j] = Math.min(dp[j], dp[k] + (j == k ? 0 : 1));\\n    }\\n    return Math.min(dp[1], Math.min(dp[2], dp[3]));\\n}\\n```\\n**C++**\\n```cpp\\nint minSideJumps(vector<int>& obs) {\\n    array<int, 4> dp{1000000, 1, 0, 1};\\n    for (auto i : obs) {\\n        dp[i] = dp[0];\\n        for (auto j = 1; j <= 3; ++j)\\n            if (i != j)\\n                dp[j] = min({dp[1] + (j != 1), dp[2] + (j != 2), dp[3] + (j != 3)});\\n    }\\n    return min({dp[1], dp[2], dp[3]});\\n}\\n```\\n**Python 3**\\n```python\\nclass Solution:\\n    def minSideJumps(self, obs: List[int]) -> int:\\n        dp = [1000000, 1, 0, 1]\\n        for i in obs:\\n            dp[i] = dp[0]\\n            for j in range(1, 4):\\n                dp[j] = min(dp[1] + (1 if j != 1 else 0),\\n                           dp[2] + (1 if j != 2 else 0),\\n                           dp[3] + (1 if j != 3 else 0)) if j != i else dp[j]\\n        return min(dp)\\n```\\n\\n#### Greedy\\nThe idea - suggested by [voidp](https://leetcode.com/voidp/) - is that when we hit an obstacle, we can greedily choose a lane where the next obstacle is further out. \\n\\nThis works because we can jump to any line with the same `+1` penalty. \\n\\n**C++**\\n```cpp\\nint minSideJumps(vector<int>& obs) {\\n    int res = 0, cur = 2;\\n    for (auto i = 0; i + 1 < obs.size(); ++i) {\\n        if (cur == obs[i + 1]) {\\n            ++res;\\n            for (bool b[4] = {}; i < obs.size(); ++i) {\\n                b[obs[i]] = true;\\n                if (b[1] && b[2] && b[3])\\n                    break;\\n            }\\n            cur = obs[i];\\n            i -= 2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int minSideJumps(int[] obstacles) {\\n    int[] dp = {1000000,1,0,1};\\n    for (var i : obstacles) {\\n        dp[i] = dp[0];\\n        for (var j = 1; j < 4; ++j)\\n            if (j != i)\\n                for (var k = 1; k < 4; ++k)\\n                    dp[j] = Math.min(dp[j], dp[k] + (j == k ? 0 : 1));\\n    }\\n    return Math.min(dp[1], Math.min(dp[2], dp[3]));\\n}\\n```\n```cpp\\nint minSideJumps(vector<int>& obs) {\\n    array<int, 4> dp{1000000, 1, 0, 1};\\n    for (auto i : obs) {\\n        dp[i] = dp[0];\\n        for (auto j = 1; j <= 3; ++j)\\n            if (i != j)\\n                dp[j] = min({dp[1] + (j != 1), dp[2] + (j != 2), dp[3] + (j != 3)});\\n    }\\n    return min({dp[1], dp[2], dp[3]});\\n}\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, obs: List[int]) -> int:\\n        dp = [1000000, 1, 0, 1]\\n        for i in obs:\\n            dp[i] = dp[0]\\n            for j in range(1, 4):\\n                dp[j] = min(dp[1] + (1 if j != 1 else 0),\\n                           dp[2] + (1 if j != 2 else 0),\\n                           dp[3] + (1 if j != 3 else 0)) if j != i else dp[j]\\n        return min(dp)\\n```\n```cpp\\nint minSideJumps(vector<int>& obs) {\\n    int res = 0, cur = 2;\\n    for (auto i = 0; i + 1 < obs.size(); ++i) {\\n        if (cur == obs[i + 1]) {\\n            ++res;\\n            for (bool b[4] = {}; i < obs.size(); ++i) {\\n                b[obs[i]] = true;\\n                if (b[1] && b[2] && b[3])\\n                    break;\\n            }\\n            cur = obs[i];\\n            i -= 2;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152537,
                "title": "c-memoised-dp-solution",
                "content": "First write down the recursive solution and then memoize it to approach it in a simple way. \\n\\nStart with lane 2 and we have the following options:-\\n1) If no obstacle on current lane on next position then we can move forward in same lane.\\n2) If we have an obstacle at the next pos, we can jump to either of the other two lanes (L1 and L2).\\nSo, here we have 3 options :-\\ni) If we have an obstacle at L1 at same pos, jump to L2.\\nii) If we have an obstacle at L2 at same pos, jump to L1.\\niii) If no obstacle at either L2 or L1 at this pos, take minimum of both.\\nRepeat the same for the new current lane until we reach the second last position.\\n\\n3) If we reached second last pos, we can return the ans.\\n\\n**Recursive Solution: (TLE)**\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles, int pos, int lane)\\n    {\\n        if(pos == obstacles.size()-2)\\n            return 0;\\n        \\n        if(obstacles[pos+1]!=lane)\\n        {\\n            return solve(obstacles, pos+1, lane);\\n        }\\n        if(obstacles[pos+1]==lane){\\n            int l1=0, l2=0;\\n            if(lane==1)\\n            {\\n                l1=2;\\n                l2=3;\\n            }\\n            else if(lane==2)\\n            {\\n                l1=1;\\n                l2=3;\\n            }\\n            else{\\n                l1=1;\\n                l2=2;\\n            }\\n            if(obstacles[pos]==l1)\\n                return 1 + solve(obstacles, pos+1, l2);\\n            else if(obstacles[pos]==l2)\\n                return 1 + solve(obstacles, pos+1, l1);\\n            else\\n                return 1 + min(solve(obstacles, pos+1, l1), solve(obstacles, pos+1, l2));\\n        }\\n        return 0;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        return solve(obstacles, 0, 2);\\n    }\\n};\\n```\\n\\n**Memoized Approach (Accepted)**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles, int pos, int lane, vector<vector<int>>&dp)\\n    {\\n        if(pos == obstacles.size()-2)\\n            return dp[pos][lane] = 0;\\n        \\n        if(dp[pos][lane]!=-1)\\n            return dp[pos][lane];\\n        \\n        if(obstacles[pos+1]!=lane)\\n        {\\n            return dp[pos][lane] = solve(obstacles, pos+1, lane, dp);\\n        }\\n        if(obstacles[pos+1]==lane){\\n            int l1=0, l2=0;\\n            if(lane==1)\\n            {\\n                l1=2;\\n                l2=3;\\n            }\\n            else if(lane==2)\\n            {\\n                l1=1;\\n                l2=3;\\n            }\\n            else{\\n                l1=1;\\n                l2=2;\\n            }\\n            if(obstacles[pos]==l1)\\n                return dp[pos][lane] = 1 + solve(obstacles, pos+1, l2, dp);\\n            else if(obstacles[pos]==l2)\\n                return dp[pos][lane] = 1 + solve(obstacles, pos+1, l1, dp);\\n            else\\n                return dp[pos][lane] = 1 + min(solve(obstacles, pos+1, l1, dp), solve(obstacles, pos+1, l2, dp));\\n        }\\n        return dp[pos][lane] = 0;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size()+1, vector<int>(4,-1));\\n        return solve(obstacles, 0, 2, dp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles, int pos, int lane)\\n    {\\n        if(pos == obstacles.size()-2)\\n            return 0;\\n        \\n        if(obstacles[pos+1]!=lane)\\n        {\\n            return solve(obstacles, pos+1, lane);\\n        }\\n        if(obstacles[pos+1]==lane){\\n            int l1=0, l2=0;\\n            if(lane==1)\\n            {\\n                l1=2;\\n                l2=3;\\n            }\\n            else if(lane==2)\\n            {\\n                l1=1;\\n                l2=3;\\n            }\\n            else{\\n                l1=1;\\n                l2=2;\\n            }\\n            if(obstacles[pos]==l1)\\n                return 1 + solve(obstacles, pos+1, l2);\\n            else if(obstacles[pos]==l2)\\n                return 1 + solve(obstacles, pos+1, l1);\\n            else\\n                return 1 + min(solve(obstacles, pos+1, l1), solve(obstacles, pos+1, l2));\\n        }\\n        return 0;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        return solve(obstacles, 0, 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles, int pos, int lane, vector<vector<int>>&dp)\\n    {\\n        if(pos == obstacles.size()-2)\\n            return dp[pos][lane] = 0;\\n        \\n        if(dp[pos][lane]!=-1)\\n            return dp[pos][lane];\\n        \\n        if(obstacles[pos+1]!=lane)\\n        {\\n            return dp[pos][lane] = solve(obstacles, pos+1, lane, dp);\\n        }\\n        if(obstacles[pos+1]==lane){\\n            int l1=0, l2=0;\\n            if(lane==1)\\n            {\\n                l1=2;\\n                l2=3;\\n            }\\n            else if(lane==2)\\n            {\\n                l1=1;\\n                l2=3;\\n            }\\n            else{\\n                l1=1;\\n                l2=2;\\n            }\\n            if(obstacles[pos]==l1)\\n                return dp[pos][lane] = 1 + solve(obstacles, pos+1, l2, dp);\\n            else if(obstacles[pos]==l2)\\n                return dp[pos][lane] = 1 + solve(obstacles, pos+1, l1, dp);\\n            else\\n                return dp[pos][lane] = 1 + min(solve(obstacles, pos+1, l1, dp), solve(obstacles, pos+1, l2, dp));\\n        }\\n        return dp[pos][lane] = 0;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size()+1, vector<int>(4,-1));\\n        return solve(obstacles, 0, 2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152416,
                "title": "python3-dp-solution",
                "content": "```\\ndef minSideJumps(self, obstacles: List[int]) -> int:\\n        # Approach: DP.\\n        # Idea: dp[i][j] means minimum number of side jumps to reach i-th position at j-th lane.\\n        #       \\'inf\\' values in resulting dp array mean unreachable states.\\n        \\n        # init dp\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(len(obstacles))]\\n        dp[0] = [1, 0, 1]\\n        \\n        # run dp process\\n        for i in range(1, len(obstacles)):\\n            # 1. fill next position trying to move without side jumps\\n            for j in range(3):\\n                if obstacles[i] != j + 1:\\n                    dp[i][j] = dp[i - 1][j]\\n            # 2. update dp for i-th position with possible side jumps\\n            min_cur = min(dp[i])\\n            for j in range(3):\\n                if obstacles[i] != j + 1:\\n                    dp[i][j] = min(dp[i][j], min_cur + 1)\\n        return min(dp[-1])\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef minSideJumps(self, obstacles: List[int]) -> int:\\n        # Approach: DP.\\n        # Idea: dp[i][j] means minimum number of side jumps to reach i-th position at j-th lane.\\n        #       \\'inf\\' values in resulting dp array mean unreachable states.\\n        \\n        # init dp\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(len(obstacles))]\\n        dp[0] = [1, 0, 1]\\n        \\n        # run dp process\\n        for i in range(1, len(obstacles)):\\n            # 1. fill next position trying to move without side jumps\\n            for j in range(3):\\n                if obstacles[i] != j + 1:\\n                    dp[i][j] = dp[i - 1][j]\\n            # 2. update dp for i-th position with possible side jumps\\n            min_cur = min(dp[i])\\n            for j in range(3):\\n                if obstacles[i] != j + 1:\\n                    dp[i][j] = min(dp[i][j], min_cur + 1)\\n        return min(dp[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1152422,
                "title": "java-dp-time-o-n-space-o-1-brief-explanation",
                "content": "`dp[i][j]`: the min jump to arrive at lane `j` at point `i`\\n\\nSince the frog starts at lane 2, the initial states should be,\\n`dp[0][2] = 0`, \\n`dp[0][1] = 1`,\\n`dp[0][3] = 1`.\\n\\nThis is an space `O(1)` solution.\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        //dp[i][j]: the min jump to arrive at lane j at point i\\n        int[] dp = new int[4];\\n        dp[1] = dp[3] = 1;\\n        for (int i = 1; i < n; i++) {\\n            int y = obstacles[i];\\n            int[] temp = new int[4];\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) {\\n                    temp[j] = Integer.MAX_VALUE;\\n                } else {\\n                    temp[j] = dp[j];\\n                }\\n            }\\n            //get the min at point i for all 3 lanes\\n            int min = Math.min(temp[1], Math.min(temp[2], temp[3]));\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) continue;\\n                //update dp[i][j]\\n                temp[j] = Math.min(min+1, temp[j]);\\n            }\\n            dp = temp;\\n        }\\n        return Math.min(dp[1], Math.min(dp[2], dp[3]));\\n    }\\n}\\n```\\n\\nWe can also have an space `O(n)` solution,\\n\\n ```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        //dp[i][j]: the min jump to arrive at lane j at point i\\n        int[][] dp = new int[n][4];\\n\\t\\t//initial point\\n        dp[0][1] = dp[0][3] = 1;\\n        for (int i = 1; i < n; i++) {\\n            int y = obstacles[i];\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) {\\n                    dp[i][j] = Integer.MAX_VALUE;\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n            //get the min at point i for all 3 lanes\\n            int min = Math.min(dp[i][1], Math.min(dp[i][2], dp[i][3]));\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) continue;\\n                //update dp[i][j]\\n                dp[i][j] = Math.min(min+1, dp[i][j]);\\n            }\\n        }\\n        return Math.min(dp[n-1][1], Math.min(dp[n-1][2], dp[n-1][3]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        //dp[i][j]: the min jump to arrive at lane j at point i\\n        int[] dp = new int[4];\\n        dp[1] = dp[3] = 1;\\n        for (int i = 1; i < n; i++) {\\n            int y = obstacles[i];\\n            int[] temp = new int[4];\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) {\\n                    temp[j] = Integer.MAX_VALUE;\\n                } else {\\n                    temp[j] = dp[j];\\n                }\\n            }\\n            //get the min at point i for all 3 lanes\\n            int min = Math.min(temp[1], Math.min(temp[2], temp[3]));\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) continue;\\n                //update dp[i][j]\\n                temp[j] = Math.min(min+1, temp[j]);\\n            }\\n            dp = temp;\\n        }\\n        return Math.min(dp[1], Math.min(dp[2], dp[3]));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        //dp[i][j]: the min jump to arrive at lane j at point i\\n        int[][] dp = new int[n][4];\\n\\t\\t//initial point\\n        dp[0][1] = dp[0][3] = 1;\\n        for (int i = 1; i < n; i++) {\\n            int y = obstacles[i];\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) {\\n                    dp[i][j] = Integer.MAX_VALUE;\\n                } else {\\n                    dp[i][j] = dp[i-1][j];\\n                }\\n            }\\n            //get the min at point i for all 3 lanes\\n            int min = Math.min(dp[i][1], Math.min(dp[i][2], dp[i][3]));\\n            for (int j = 1; j <= 3; j++) {\\n                if (j == y) continue;\\n                //update dp[i][j]\\n                dp[i][j] = Math.min(min+1, dp[i][j]);\\n            }\\n        }\\n        return Math.min(dp[n-1][1], Math.min(dp[n-1][2], dp[n-1][3]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152429,
                "title": "easy-o-n-dp-solution-c-with-explanation-top-down-and-iterative-solution",
                "content": "\\nExplanation: Initially we are in lane2 ,and for index=0,we can jump to lane1 and lane3 .\\nAfter that for reaching every lane ,we have two options  either continue from last index,or jump from other lane to this lane,\\n\\n\\n```\\n```\\n \\n Top Down approach:-\\n \\n \\n ```\\nclass Solution {\\npublic:\\n    //  Dp state= {index of frog position, lane of frog position}\\n\\tvector<vector<long>>dp;\\n\\tint n;\\n    int minSideJumps(vector<int>& obstacles) {\\n\\t\\tn=obstacles.size()-1;\\n\\t\\t// Declaring size of Dp with n and number of lanes\\n\\t\\tdp.resize(n+1,vector<long>(4,-1));\\n\\t\\t// Find the answer for index 0 and lane 2\\n\\t\\treturn find(obstacles,0,2);\\n    }\\n\\tlong find(vector<int>&obstacles,int idx,int lane){\\n\\t\\t// Reach end return 0\\n\\t\\tif(idx==n) return 0;\\n\\t\\t// Current Position has Obstacle return INT_MAX, we can\\'t be here\\n\\t\\tif(obstacles[idx]==lane) return INT_MAX;\\n\\t\\t// return if previously calculated\\n\\t\\tif(dp[idx][lane]!=-1) return dp[idx][lane];\\n\\t\\t// Going in Current forward\\n\\t\\tlong res=find(obstacles,idx+1,lane);\\n\\t\\t// Iterating over all lanes\\n\\t\\tfor(int i=1;i<4;i++){\\n\\t\\t\\t// Going in same lane is not possible\\n\\t\\t\\tif(lane==i) continue;\\n\\t\\t\\t// if ith lane has obsatacle we can\\'t go there\\n\\t\\t\\tif(obstacles[idx]==i) continue;\\n\\t\\t\\t// Calculating for idx+1 in ith lane and adding one extra cost\\n\\t\\t\\tres=min(res,find(obstacles,idx+1,i)+1);\\n\\t\\t}\\n\\t\\treturn dp[idx][lane]=res;\\n\\t}\\n};\\n```\\nIterative solution:-\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>&v) {\\n        int n=v.size();\\n        int mx=10000000;\\n        vector<vector<int>>dp(n+1,vector<int>(4,mx));\\n        \\n        dp[0][1]=1;dp[0][2]=0;dp[0][3]=1;\\n        for(int i=1;i<n;++i){\\n           \\n            \\n            // continuing the previous lane\\n            \\n            if(v[i]!=1)dp[i][1]=dp[i-1][1];\\n            if(v[i]!=2)dp[i][2]=dp[i-1][2];\\n            if(v[i]!=3)dp[i][3]=dp[i-1][3];\\n            \\n            // jumping from other lane\\n            \\n            if(v[i]!=1)\\n            dp[i][1]=min(dp[i][1],min(dp[i][2]+1,dp[i][3]+1));\\n            if(v[i]!=2)\\n            dp[i][2]=min(dp[i][2],min(dp[i][3]+1,dp[i][1]+1));\\n            if(v[i]!=3)\\n            dp[i][3]=min(dp[i][3],min(dp[i][1]+1,dp[i][2]+1));\\n           \\n        }\\n        return min(dp[n-1][1],min(dp[n-1][2],dp[n-1][3]));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\nclass Solution {\\npublic:\\n    //  Dp state= {index of frog position, lane of frog position}\\n\\tvector<vector<long>>dp;\\n\\tint n;\\n    int minSideJumps(vector<int>& obstacles) {\\n\\t\\tn=obstacles.size()-1;\\n\\t\\t// Declaring size of Dp with n and number of lanes\\n\\t\\tdp.resize(n+1,vector<long>(4,-1));\\n\\t\\t// Find the answer for index 0 and lane 2\\n\\t\\treturn find(obstacles,0,2);\\n    }\\n\\tlong find(vector<int>&obstacles,int idx,int lane){\\n\\t\\t// Reach end return 0\\n\\t\\tif(idx==n) return 0;\\n\\t\\t// Current Position has Obstacle return INT_MAX, we can\\'t be here\\n\\t\\tif(obstacles[idx]==lane) return INT_MAX;\\n\\t\\t// return if previously calculated\\n\\t\\tif(dp[idx][lane]!=-1) return dp[idx][lane];\\n\\t\\t// Going in Current forward\\n\\t\\tlong res=find(obstacles,idx+1,lane);\\n\\t\\t// Iterating over all lanes\\n\\t\\tfor(int i=1;i<4;i++){\\n\\t\\t\\t// Going in same lane is not possible\\n\\t\\t\\tif(lane==i) continue;\\n\\t\\t\\t// if ith lane has obsatacle we can\\'t go there\\n\\t\\t\\tif(obstacles[idx]==i) continue;\\n\\t\\t\\t// Calculating for idx+1 in ith lane and adding one extra cost\\n\\t\\t\\tres=min(res,find(obstacles,idx+1,i)+1);\\n\\t\\t}\\n\\t\\treturn dp[idx][lane]=res;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>&v) {\\n        int n=v.size();\\n        int mx=10000000;\\n        vector<vector<int>>dp(n+1,vector<int>(4,mx));\\n        \\n        dp[0][1]=1;dp[0][2]=0;dp[0][3]=1;\\n        for(int i=1;i<n;++i){\\n           \\n            \\n            // continuing the previous lane\\n            \\n            if(v[i]!=1)dp[i][1]=dp[i-1][1];\\n            if(v[i]!=2)dp[i][2]=dp[i-1][2];\\n            if(v[i]!=3)dp[i][3]=dp[i-1][3];\\n            \\n            // jumping from other lane\\n            \\n            if(v[i]!=1)\\n            dp[i][1]=min(dp[i][1],min(dp[i][2]+1,dp[i][3]+1));\\n            if(v[i]!=2)\\n            dp[i][2]=min(dp[i][2],min(dp[i][3]+1,dp[i][1]+1));\\n            if(v[i]!=3)\\n            dp[i][3]=min(dp[i][3],min(dp[i][1]+1,dp[i][2]+1));\\n           \\n        }\\n        return min(dp[n-1][1],min(dp[n-1][2],dp[n-1][3]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152446,
                "title": "c-greedy-o-n-with-comments-and-proof-100",
                "content": "### Algorithm\\n        //The algorithm is a greeedy one.\\n        //On seeing obstacle in the current lane\\n        //We need to select the next lane which have obstacle at the farthest point. \\n        \\n\\n### Proof by Contradiction:\\n\\nSay we don\\'t choose the `Farthest lane (A)`, instead there is one `optimal` lane (B) passing by, But if B is an optimal lane and `not the Farthest` there is one `extra jump` required in Lane B (Surely as obstacle is going to be before the farthest lane.).\\n\\nSo for time being, lets assume we choose the `farthest lane` and delay this  unnecessary `extra Jump` once fathest lane hits the obstacle we jump to the `optimal lane`. Now if question arise what if we can\\'t jump on the optimal lane (optimal lane is having the obstacle `at the same point`: that can be the only case), that won\\'t be the case as at any point in time there is obstacle at only ``ONE LANE``. Also if optimal lane is having obstacle then there are `two many` obstacle on the optimal lane, which won\\'t be the `optimal`  .     \\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int jumps = 0;\\n        int lane = 2;   //Starting lane.\\n        \\n        //The algorithm is a greeedy one.\\n        //On seeing obstacle in the current lane\\n        //We need to select the next lane which have obstacle at the farthest point. \\n        \\n        for(int i = 0; i < obstacles.size(); ){        \\n            if(i+1 < obstacles.size() && obstacles[i+1] == lane){ \\n                \\n                //Obstacle, jump required.\\n                jumps++;\\n                \\n                //Find the farthest lane without obstacle\\n                int farthest = i;\\n                unordered_set<int> lanes_with_obstacle;\\n                lanes_with_obstacle.reserve(2);\\n                while(farthest < obstacles.size()){\\n                    \\n                    if(obstacles[farthest] != 0)\\n                        lanes_with_obstacle.insert(obstacles[farthest]);\\n                    \\n                    if(lanes_with_obstacle.size() == 2)\\n                        break;\\n                    farthest++;\\n                }\\n                \\n                \\n                //Jump to the farthest lane\\n                i = farthest;\\n                for(int farthest_laneidx = 1; farthest_laneidx <= 3; farthest_laneidx++){\\n                    if(lanes_with_obstacle.find(farthest_laneidx) == lanes_with_obstacle.end())\\n                        lane = farthest_laneidx;                    \\n                }\\n            }else\\n                i++;\\n        }        \\n        \\n        return jumps;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int jumps = 0;\\n        int lane = 2;   //Starting lane.\\n        \\n        //The algorithm is a greeedy one.\\n        //On seeing obstacle in the current lane\\n        //We need to select the next lane which have obstacle at the farthest point. \\n        \\n        for(int i = 0; i < obstacles.size(); ){        \\n            if(i+1 < obstacles.size() && obstacles[i+1] == lane){ \\n                \\n                //Obstacle, jump required.\\n                jumps++;\\n                \\n                //Find the farthest lane without obstacle\\n                int farthest = i;\\n                unordered_set<int> lanes_with_obstacle;\\n                lanes_with_obstacle.reserve(2);\\n                while(farthest < obstacles.size()){\\n                    \\n                    if(obstacles[farthest] != 0)\\n                        lanes_with_obstacle.insert(obstacles[farthest]);\\n                    \\n                    if(lanes_with_obstacle.size() == 2)\\n                        break;\\n                    farthest++;\\n                }\\n                \\n                \\n                //Jump to the farthest lane\\n                i = farthest;\\n                for(int farthest_laneidx = 1; farthest_laneidx <= 3; farthest_laneidx++){\\n                    if(lanes_with_obstacle.find(farthest_laneidx) == lanes_with_obstacle.end())\\n                        lane = farthest_laneidx;                    \\n                }\\n            }else\\n                i++;\\n        }        \\n        \\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152499,
                "title": "python-one-pass-with-saving-state",
                "content": "```\\nclass Solution(object):\\n    def minSideJumps(self, obstacles):\\n        path,res,i = [2],0,0\\n        while i < len(obstacles):\\n            if obstacles[i] in path:\\n                if len(path) == 1:\\n                    res+=1\\n                    if obstacles[i] == 1:\\n                        path= [2,3]\\n                    if obstacles[i] == 2:\\n                        path = [1,3]\\n                    if obstacles[i] == 3:\\n                        path = [1,2]\\n                    i-=1\\n                if len(path)==2:\\n                    if path[0] == obstacles[i]:\\n                        path = [path[1]]\\n                    elif path[1] == obstacles[i]:\\n                        path.pop()\\n            i+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSideJumps(self, obstacles):\\n        path,res,i = [2],0,0\\n        while i < len(obstacles):\\n            if obstacles[i] in path:\\n                if len(path) == 1:\\n                    res+=1\\n                    if obstacles[i] == 1:\\n                        path= [2,3]\\n                    if obstacles[i] == 2:\\n                        path = [1,3]\\n                    if obstacles[i] == 3:\\n                        path = [1,2]\\n                    i-=1\\n                if len(path)==2:\\n                    if path[0] == obstacles[i]:\\n                        path = [path[1]]\\n                    elif path[1] == obstacles[i]:\\n                        path.pop()\\n            i+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152515,
                "title": "c-w-o-dp-beats-100-with-comments",
                "content": "Time: 308 ms\\nMemory: 162.2 MB\\n```\\nclass Solution {\\npublic:\\n\\xA0 \\xA0 int minSideJumps(vector<int>& obstacles) {\\n\\xA0 \\xA0 \\xA0 \\xA0 int sidejumps=0;\\n\\xA0 \\xA0 \\xA0 \\xA0 int curr=2;\\n\\xA0 \\xA0 \\xA0 \\xA0 int lane1=1;int lane=3;\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=0;i<obstacles.size()-1;i++){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(obstacles[i+1]==curr){\\n                // find the occurance of obstacles in the rest 2 lanes for the rest of the path\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 auto x=find(obstacles.begin()+i,obstacles.end(),lane1);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 auto y= find(obstacles.begin()+i,obstacles.end(),lane);\\n\\t\\t\\t\\t// if there is no obstacle in any lane till the end jump to that lane and break\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(x==obstacles.end() || y==obstacles.end()){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 sidejumps++;break;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int r=x-obstacles.begin();int s=y-obstacles.begin();\\n                     // otherwise move to that lane in which the occurance of obstacle is at later stage so we can get min no. of jumps\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(r>s){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 swap(curr,lane1); //make this lane as the current lane\\n\\t\\t\\t\\t\\t\\tsidejumps++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 swap(curr,lane);sidejumps++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 continue;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 return sidejumps;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\xA0 \\xA0 int minSideJumps(vector<int>& obstacles) {\\n\\xA0 \\xA0 \\xA0 \\xA0 int sidejumps=0;\\n\\xA0 \\xA0 \\xA0 \\xA0 int curr=2;\\n\\xA0 \\xA0 \\xA0 \\xA0 int lane1=1;int lane=3;\\n\\xA0 \\xA0 \\xA0 \\xA0 for(int i=0;i<obstacles.size()-1;i++){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(obstacles[i+1]==curr){\\n                // find the occurance of obstacles in the rest 2 lanes for the rest of the path\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 auto x=find(obstacles.begin()+i,obstacles.end(),lane1);\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 auto y= find(obstacles.begin()+i,obstacles.end(),lane);\\n\\t\\t\\t\\t// if there is no obstacle in any lane till the end jump to that lane and break\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(x==obstacles.end() || y==obstacles.end()){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 sidejumps++;break;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 int r=x-obstacles.begin();int s=y-obstacles.begin();\\n                     // otherwise move to that lane in which the occurance of obstacle is at later stage so we can get min no. of jumps\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 if(r>s){\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 swap(curr,lane1); //make this lane as the current lane\\n\\t\\t\\t\\t\\t\\tsidejumps++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 swap(curr,lane);sidejumps++;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }else{\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 continue;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 }\\n\\xA0 \\xA0 \\xA0 \\xA0 return sidejumps;\\n\\xA0 \\xA0 \\xA0 \\xA0 \\n\\xA0 \\xA0 }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756264,
                "title": "recursive-top-down-bottom-up-space-optimization",
                "content": "\\nWe are checking all the possibilies and taking the minimum, so basically recursion!\\n\\n1. if there is no obstacle in the lane we are standing at i.e. (`currLane`) then we will simply move to the next index (no jumps needed).\\n\\n2. Now if there is an obstacle, then obiviously we can\\'t stay in the same lane i.e. `i!=currLane` && there must not be an obstacle in the lane we gonna move i.e. `obstacles[idx]!=i`. Here we are taking a jump so +. \\n\\n3. We will take minimum of all the possiblities \\n\\n**Recursion (gives TLE)**\\n```\\nint solve(int idx, int currLane, vector<int>& obstacles){\\n        if(idx == obstacles.size() -1) return 0;\\n        // 1\\n        if(obstacles[idx+1] != currLane) return solve(idx+1, currLane, obstacles);\\n        // 2\\n        int mn = 1e9;\\n        for(int i = 1; i<=3; i++){\\n            if(i!=currLane && obstacles[idx]!=i){\\n        // 3\\n                mn = min(mn, 1 + solve(idx+1, i, obstacles));\\n            }\\n        }\\n        return mn;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        return solve(0, 2, obstacles);\\n    }\\n```\\n\\nNow if you can write the recurrence then writing top down is childplay.\\nJust store the computed values so that we can use them later when required.\\n\\n**Top-down (Memoization)** \\n```\\n int solve(int idx, int currLane, vector<int>& obstacles, vector<vector<int>>& dp){\\n        if(idx == obstacles.size()-1) return 0;\\n        if(dp[idx][currLane] != -1) return dp[idx][currLane];\\n        if(obstacles[idx+1] != currLane) return solve(idx+1, currLane, obstacles, dp);\\n        int mn = 1e9;\\n        for(int i = 1; i<=3; i++){\\n            if(i!=currLane && obstacles[idx]!=i){\\n                mn = min(mn, 1 + solve(idx+1, i, obstacles, dp));\\n            }\\n        }\\n        return dp[idx][currLane] = mn;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n, vector<int> (4, -1));\\n        return solve(0, 2, obstacles, dp);\\n    }\\n```\\nWe will write tabulation to get ride of the recursive stack space.\\n\\nBottom-up is starting with the base cases (reverse of top-down). So we will first write the base case in top down our idx was going from 0 to n-1 so here we will do the opposite. Other thing will remain same\\n\\n\\n**Bottom-up (Tabulation)** \\n```\\n    int minSideJumps(vector<int> &obstacles){\\n            int n = obstacles.size();\\n            vector<vector < int>> dp(n, vector<int> (3, 1e9));\\n            for (int i = 0; i <= 2; i++) dp[n - 1][i] = 0;\\n\\n            for (int idx = n - 2; idx >= 0; idx--){\\n                for (int currLane = 0; currLane <= 2; currLane++){\\n                    if (obstacles[idx+1] != currLane +1) dp[idx][currLane] = dp[idx + 1][currLane];\\n                    else\\n                    {\\n                        int mn = 1e9;\\n                        for (int i = 0; i <= 2; i++){\\n                            if (i != currLane && obstacles[idx] != i + 1){\\n                                mn = min(mn, 1 + dp[idx + 1][i]);\\n                            }\\n                        }\\n                        dp[idx][currLane] = mn;\\n                    }\\n                }\\n            }\\n            return min(dp[0][1], 1 + min(dp[0][0], dp[0][2]));\\n    }\\n```\\n\\nWe can notice that we only need values for idx & idx+1, so why store the whole vector. instead of this we will initilize two 1D arrays curr and prev, and keep on updating them in each iteration\\n\\n**Space Optimized to O(n)**\\n\\n```\\n    int minSideJumps(vector<int> &obstacles){\\n            int n = obstacles.size();\\n            vector<int> curr(3, 1e9), prev(3, 0);\\n            for (int idx = n - 2; idx >= 0; idx--){\\n                for (int currLane = 0; currLane <= 2; currLane++){\\n                    if (obstacles[idx+1] != currLane +1) curr[currLane] = prev[currLane];\\n                    else{\\n                        int mn = 1e9;\\n                        for (int i = 0; i <= 2; i++){\\n                            if (i != currLane && obstacles[idx] != i + 1){\\n                                mn = min(mn, 1 + prev[i]);\\n                            }\\n                        }\\n                        curr[currLane] = mn;\\n                    }\\n                }\\n                prev = curr;\\n            }\\n            return min(prev[1], 1 + min(prev[0], prev[2]));\\n    }\\n\\n```\\n\\nPlease upvote if you find this helpful :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(int idx, int currLane, vector<int>& obstacles){\\n        if(idx == obstacles.size() -1) return 0;\\n        // 1\\n        if(obstacles[idx+1] != currLane) return solve(idx+1, currLane, obstacles);\\n        // 2\\n        int mn = 1e9;\\n        for(int i = 1; i<=3; i++){\\n            if(i!=currLane && obstacles[idx]!=i){\\n        // 3\\n                mn = min(mn, 1 + solve(idx+1, i, obstacles));\\n            }\\n        }\\n        return mn;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        return solve(0, 2, obstacles);\\n    }\\n```\n```\\n int solve(int idx, int currLane, vector<int>& obstacles, vector<vector<int>>& dp){\\n        if(idx == obstacles.size()-1) return 0;\\n        if(dp[idx][currLane] != -1) return dp[idx][currLane];\\n        if(obstacles[idx+1] != currLane) return solve(idx+1, currLane, obstacles, dp);\\n        int mn = 1e9;\\n        for(int i = 1; i<=3; i++){\\n            if(i!=currLane && obstacles[idx]!=i){\\n                mn = min(mn, 1 + solve(idx+1, i, obstacles, dp));\\n            }\\n        }\\n        return dp[idx][currLane] = mn;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n, vector<int> (4, -1));\\n        return solve(0, 2, obstacles, dp);\\n    }\\n```\n```\\n    int minSideJumps(vector<int> &obstacles){\\n            int n = obstacles.size();\\n            vector<vector < int>> dp(n, vector<int> (3, 1e9));\\n            for (int i = 0; i <= 2; i++) dp[n - 1][i] = 0;\\n\\n            for (int idx = n - 2; idx >= 0; idx--){\\n                for (int currLane = 0; currLane <= 2; currLane++){\\n                    if (obstacles[idx+1] != currLane +1) dp[idx][currLane] = dp[idx + 1][currLane];\\n                    else\\n                    {\\n                        int mn = 1e9;\\n                        for (int i = 0; i <= 2; i++){\\n                            if (i != currLane && obstacles[idx] != i + 1){\\n                                mn = min(mn, 1 + dp[idx + 1][i]);\\n                            }\\n                        }\\n                        dp[idx][currLane] = mn;\\n                    }\\n                }\\n            }\\n            return min(dp[0][1], 1 + min(dp[0][0], dp[0][2]));\\n    }\\n```\n```\\n    int minSideJumps(vector<int> &obstacles){\\n            int n = obstacles.size();\\n            vector<int> curr(3, 1e9), prev(3, 0);\\n            for (int idx = n - 2; idx >= 0; idx--){\\n                for (int currLane = 0; currLane <= 2; currLane++){\\n                    if (obstacles[idx+1] != currLane +1) curr[currLane] = prev[currLane];\\n                    else{\\n                        int mn = 1e9;\\n                        for (int i = 0; i <= 2; i++){\\n                            if (i != currLane && obstacles[idx] != i + 1){\\n                                mn = min(mn, 1 + prev[i]);\\n                            }\\n                        }\\n                        curr[currLane] = mn;\\n                    }\\n                }\\n                prev = curr;\\n            }\\n            return min(prev[1], 1 + min(prev[0], prev[2]));\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1386249,
                "title": "easy-c-bfs-easy-to-understand",
                "content": "We can use basic idea of BFS here just make a visited array and count total steps to reach nth location and subract the horizontal distance n from total steps.\\n\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size()-1,step=0;\\n        vector<vector<int>> vis(4,vector<int>(n+1,0));\\n        queue<pair<int,int>> q;\\n        q.push({2,0});\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int p=0;p<sz;p++){\\n                auto [x,y]=q.front();\\n                q.pop();\\n                if(x>3||x<1||y>n||y<0||vis[x][y]==1||obs[y]==x) continue;  // eliminate the invalid points \\n                if(y==n) return step-n;  // subract horizontal distance->n\\n                vis[x][y]=1;                    // mark visited\\n                q.push({x-1,y});              // onr step up  \\n                q.push({x-2,y});             //two steps up\\n                \\n                q.push({x+1,y});           //one step down\\n                q.push({x+2,y});           //two steps down \\n                \\n                q.push({x,y+1});         //one step right\\n                //(if any case is invalid it will get eliminated by if condition)\\n            }\\n            step++;\\n        }\\n        \\n        return -1;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "We can use basic idea of BFS here just make a visited array and count total steps to reach nth location and subract the horizontal distance n from total steps.\\n\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size()-1,step=0;\\n        vector<vector<int>> vis(4,vector<int>(n+1,0));\\n        queue<pair<int,int>> q;\\n        q.push({2,0});\\n        while(!q.empty()){\\n            int sz=q.size();\\n            for(int p=0;p<sz;p++){\\n                auto [x,y]=q.front();\\n                q.pop();\\n                if(x>3||x<1||y>n||y<0||vis[x][y]==1||obs[y]==x) continue;  // eliminate the invalid points \\n                if(y==n) return step-n;  // subract horizontal distance->n\\n                vis[x][y]=1;                    // mark visited\\n                q.push({x-1,y});              // onr step up  \\n                q.push({x-2,y});             //two steps up\\n                \\n                q.push({x+1,y});           //one step down\\n                q.push({x+2,y});           //two steps down \\n                \\n                q.push({x,y+1});         //one step right\\n                //(if any case is invalid it will get eliminated by if condition)\\n            }\\n            step++;\\n        }\\n        \\n        return -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1152951,
                "title": "greedy-c-choose-lane-with-farthest-obstacle",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> v(3, vector<int>(n, n)); //v[k][i] -> position of next obstacle on lane k if currently standing at position i\\n        for (int i=n-2; i >=0; i--)\\n        {\\n            for (int k=0; k<3; k++)\\n            {\\n                v[k][i] = v[k][i+1];\\n            }\\n            if (obstacles[i]) v[obstacles[i]-1][i] = i;\\n        }\\n        int ret = 0;\\n        for (int i=0, lane=1; i<n-1; i++)\\n        {\\n            if (obstacles[i+1] - 1 == lane)\\n            {\\n                if (v[(lane+1)%3][i] > v[(lane+2)%3][i]) lane = (lane+1)%3;\\n                else lane = (lane+2)%3;\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> v(3, vector<int>(n, n)); //v[k][i] -> position of next obstacle on lane k if currently standing at position i\\n        for (int i=n-2; i >=0; i--)\\n        {\\n            for (int k=0; k<3; k++)\\n            {\\n                v[k][i] = v[k][i+1];\\n            }\\n            if (obstacles[i]) v[obstacles[i]-1][i] = i;\\n        }\\n        int ret = 0;\\n        for (int i=0, lane=1; i<n-1; i++)\\n        {\\n            if (obstacles[i+1] - 1 == lane)\\n            {\\n                if (v[(lane+1)%3][i] > v[(lane+2)%3][i]) lane = (lane+1)%3;\\n                else lane = (lane+2)%3;\\n                ret++;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152670,
                "title": "c-dp-solution-using-top-down-approach-in-o-n",
                "content": "**KEY POINTS :**\\n* The state of dp[lane][i] will be storing the minimum no. of side moves to be taken to reach n.\\n* If the current state i.e dp[lane][i] is having obstacle , we return with a large value as it is not possible to go through this obstacle .\\n* The lane are taken as { 0 , 1 , 2 } instead of { 1 , 2 , 3 } .\\n```\\nint dp[3][1000000] ;\\nint n ;\\nint dfs(vector<int>& obstacles , int lane , int i )\\n{\\n    if(i >= n)\\n        return 0 ;\\n    if(dp[lane][i] != -1)\\n        return dp[lane][i] ;\\n    if(obstacles[i] == lane + 1)\\n        return 1e9 ;\\n    int lane2 = (lane+1) % 3 , lane3 = (lane+2) % 3 ;\\n    dp[lane][i] = dfs(obstacles , lane , i+1) ;\\n    if(obstacles[i] != lane2 + 1)\\n        dp[lane][i] = min(dp[lane][i] , dfs(obstacles , lane2 , i+1) + 1) ;\\n    if(obstacles[i] != lane3 + 1)\\n        dp[lane][i] = min(dp[lane][i] , dfs(obstacles , lane3 , i+1) + 1) ;\\n    return dp[lane][i] ;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        n = obstacles.size() ;\\n        memset(dp , -1 , sizeof(dp)) ;\\n        return dfs(obstacles , 1 , 0 ) ;\\n    }\\n};\\n\\n```\\nHope you understand it very clearly. \\n**keep coding :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nint dp[3][1000000] ;\\nint n ;\\nint dfs(vector<int>& obstacles , int lane , int i )\\n{\\n    if(i >= n)\\n        return 0 ;\\n    if(dp[lane][i] != -1)\\n        return dp[lane][i] ;\\n    if(obstacles[i] == lane + 1)\\n        return 1e9 ;\\n    int lane2 = (lane+1) % 3 , lane3 = (lane+2) % 3 ;\\n    dp[lane][i] = dfs(obstacles , lane , i+1) ;\\n    if(obstacles[i] != lane2 + 1)\\n        dp[lane][i] = min(dp[lane][i] , dfs(obstacles , lane2 , i+1) + 1) ;\\n    if(obstacles[i] != lane3 + 1)\\n        dp[lane][i] = min(dp[lane][i] , dfs(obstacles , lane3 , i+1) + 1) ;\\n    return dp[lane][i] ;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        n = obstacles.size() ;\\n        memset(dp , -1 , sizeof(dp)) ;\\n        return dfs(obstacles , 1 , 0 ) ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480169,
                "title": "c-best-approach-o-1-space-optimised-solution-3-different-mehtods",
                "content": "```\\nclass Solution {\\n    \\n    vector<vector<int>> dpmemo;\\n    \\n    int SolveByMemo(vector<int>& obstacles, int index  , int lane)\\n    {\\n        if(index  == obstacles.size()-1)\\n            return 0;\\n        \\n        if(dpmemo[index][lane] != -1)\\n            return dpmemo[index][lane];\\n        \\n      \\n        if(obstacles[index+1] != lane+1)\\n            return dpmemo[index][lane] = SolveByMemo(obstacles, index+1, lane);\\n      \\n        int ans = 10e5;\\n            for(int i = 0 ; i < 3 ; i++)\\n            {\\n                if(i == lane || obstacles[index] == i+1)\\n                    continue;\\n                ans = min(ans, SolveByMemo(obstacles, index, i));\\n                if(ans == 0)\\n                    break;\\n            }\\n         return dpmemo[index][lane] = 1 + ans;\\n    }\\n    \\n    int SolveByTab(vector<int> obstacles)\\n    {\\n        vector<vector<int>>  dp = vector<vector<int>> (obstacles.size() , vector<int> (3, 10e6) );\\n        \\n        int n = obstacles.size();\\n        dp[n-1][0] = dp[n-1][1] = dp[n-1][2] =  0;\\n        \\n       \\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j<3 ; j++)\\n            {   \\n                if (obstacles[i+1] != j+1)\\n                    dp[i][j] = dp[i+1][j];\\n                else\\n                {\\n                    int ans = 10e6;\\n                    for(int k = 0 ; k< 3 ; k++)\\n                    {\\n                        if(k != j && obstacles[i] != k+1)\\n                        ans = min(ans,1 + dp[i+1][k]);\\n                    }\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        return min(dp[0][1], 1 + min(dp[0][0], dp[0][2]));\\n    }\\n    \\n     int SolveBySpaceOptimisation(vector<int> obstacles)\\n    {\\n       vector<int> curr(3, 10e6) , prev(3, 0);\\n         \\n        int n = obstacles.size();\\n       \\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j<3 ; j++)\\n            {   \\n                if (obstacles[i+1] != j+1)\\n                    curr[j] = prev[j];\\n                else\\n                {\\n                    int ans = 10e6;\\n                    for(int k = 0 ; k< 3 ; k++)\\n                    {\\n                        if(k != j && obstacles[i] != k+1)\\n                        ans = min(ans,1 + prev[k]);\\n                    }\\n                    curr[j] = ans;\\n                }\\n            }\\n            \\n            prev = curr;\\n        }\\n        \\n        return min(curr[1] , 1 + min(curr[0], curr[2]));\\n    }\\n    \\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        // 1. By Recursion + Memoization  \\n        // dpmemo = vector<vector<int>> (obstacles.size() , vector<int> (3, -1) );\\n        //     return SolveByMemo(obstacles, 0 , 1) ;\\n        \\n        // 2. By Tabulation Method\\n        //return SolveByTab(obstacles);\\n        \\n        //3. By Tabulation and Space optimisation \\n        return SolveBySpaceOptimisation(obstacles);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<vector<int>> dpmemo;\\n    \\n    int SolveByMemo(vector<int>& obstacles, int index  , int lane)\\n    {\\n        if(index  == obstacles.size()-1)\\n            return 0;\\n        \\n        if(dpmemo[index][lane] != -1)\\n            return dpmemo[index][lane];\\n        \\n      \\n        if(obstacles[index+1] != lane+1)\\n            return dpmemo[index][lane] = SolveByMemo(obstacles, index+1, lane);\\n      \\n        int ans = 10e5;\\n            for(int i = 0 ; i < 3 ; i++)\\n            {\\n                if(i == lane || obstacles[index] == i+1)\\n                    continue;\\n                ans = min(ans, SolveByMemo(obstacles, index, i));\\n                if(ans == 0)\\n                    break;\\n            }\\n         return dpmemo[index][lane] = 1 + ans;\\n    }\\n    \\n    int SolveByTab(vector<int> obstacles)\\n    {\\n        vector<vector<int>>  dp = vector<vector<int>> (obstacles.size() , vector<int> (3, 10e6) );\\n        \\n        int n = obstacles.size();\\n        dp[n-1][0] = dp[n-1][1] = dp[n-1][2] =  0;\\n        \\n       \\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j<3 ; j++)\\n            {   \\n                if (obstacles[i+1] != j+1)\\n                    dp[i][j] = dp[i+1][j];\\n                else\\n                {\\n                    int ans = 10e6;\\n                    for(int k = 0 ; k< 3 ; k++)\\n                    {\\n                        if(k != j && obstacles[i] != k+1)\\n                        ans = min(ans,1 + dp[i+1][k]);\\n                    }\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        return min(dp[0][1], 1 + min(dp[0][0], dp[0][2]));\\n    }\\n    \\n     int SolveBySpaceOptimisation(vector<int> obstacles)\\n    {\\n       vector<int> curr(3, 10e6) , prev(3, 0);\\n         \\n        int n = obstacles.size();\\n       \\n        for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            for(int j = 0 ; j<3 ; j++)\\n            {   \\n                if (obstacles[i+1] != j+1)\\n                    curr[j] = prev[j];\\n                else\\n                {\\n                    int ans = 10e6;\\n                    for(int k = 0 ; k< 3 ; k++)\\n                    {\\n                        if(k != j && obstacles[i] != k+1)\\n                        ans = min(ans,1 + prev[k]);\\n                    }\\n                    curr[j] = ans;\\n                }\\n            }\\n            \\n            prev = curr;\\n        }\\n        \\n        return min(curr[1] , 1 + min(curr[0], curr[2]));\\n    }\\n    \\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        // 1. By Recursion + Memoization  \\n        // dpmemo = vector<vector<int>> (obstacles.size() , vector<int> (3, -1) );\\n        //     return SolveByMemo(obstacles, 0 , 1) ;\\n        \\n        // 2. By Tabulation Method\\n        //return SolveByTab(obstacles);\\n        \\n        //3. By Tabulation and Space optimisation \\n        return SolveBySpaceOptimisation(obstacles);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194847,
                "title": "c-fully-detailed-solution-o-n-solution",
                "content": "# \\n# So before I explain my intutuion to you guys let\\'s look over the complexities\\n# \\n# Time Complexity - O(n) \\n# Space Complexity - O(3*n) --> O(n)\\n# So I sacrifice the space complexity for the time complexity I will tell you reason why\\n\\n# Intution - \\n# Problem - \\nSo at any position let\\'s suppose frog is at lan 2 and at next point their is obstacle in the lan to avoid collision I have two choices to make that is I can go to Lan1 or Lan3\\nNow question comes in my mind how would i select which lane should I move when i know next point in the current lan leads to collision.. \\nIf I know which lan to move optimally than I can reduce the side jumps and can reach to destination with the minimum side jumps.\\n\\n# To answer the question comes in my mind of choosing the optimal lan \\n\\nSo I know that whether frog will collide in its next jump or not\\nIf frog going to collide in the next jum than i have to change the lan\\n\\nTo appropriately select which lan i need to know at current point which lan is most far away from the obstacles in their lan\\n\\nSo to know how far is the obstacle from the current point we can use three arrays for each lan.\\nI know not good to use the three lan but I don\\'t get any other way to know the furthest distance obstacle from the current point\\n\\nSo I created three array  **Lan1,Lan2,Lan3**\\nLan1 tells me at current point farthest obstacle and similarly other for their respective Lan\\n\\n# Let\\'s go through the example to easily understand my intution - \\n![image](https://assets.leetcode.com/users/images/64d58173-5bd2-4709-8b04-9e554fde25cb_1620324981.0937715.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/72de722c-07c4-4e2d-927f-f1c0279c683b_1620324924.2989788.png)\\n\\nSo let\\'s build Lan1\\n We have 4 points we start from the end \\n \\n#  At point 4\\nWe know their never be the obstacle so we will give **-1**  \\n# lan1[4] = -1\\n\\n# At point 3\\nNow obstacle[3] = 3 so their is no obstacle at point 3 and from lan1[4] = -1 we know that after point 3 also their is no obstacle so we can have **lan1[3] = -1** because we don\\'t have any obstacles after point 3(including the point 3)\\n\\n# At point 2\\nobstacles[2] = 2 so still no obstacle at lan1 and also at point 2 lan2[2] = -1 so we don\\'t have any obstacles after the point 2(including the point 2)\\n# lan1[2] = -1\\n\\n# At point 1\\n\\nNow obstacles[1] = 1 so we encounter the obstacle so find what is the distance of the point 1 from the obstacle in the lan1 \\nDistance is = 1 - 1 = 0 because it is present in the current point so \\n# Now we will assign the lan1[1] = 0\\n\\n# At point 0\\n\\nobstacles[0] = 0 which mean no obstacles is present in any lan but in lan1 we know that lan1[1] = 0 which means we have the obstacle after point 0 so we need the distance of point 0 from the obstacle\\n\\n# Distance = lan[1] + 1 = 0 + 1 = 1\\n\\nbecause we are just one point away from the point 1 so that means if point 1 is 0 distance far away from the obstacle than point 0 will be the 1 distance away\\n\\n# So resultant Lan1 array looks like - \\n\\n![image](https://assets.leetcode.com/users/images/aeccd72e-3717-48ec-b6bb-00ea6729b5e4_1620325759.1817436.png)\\n\\nSimilarly you guys can fill the lan2 and lan3 array\\n\\n# Lan2 array - \\n\\n![image](https://assets.leetcode.com/users/images/3b328f24-af90-4596-8458-548efa53c6aa_1620325815.7243474.png)\\n\\n\\n# Lan 3 array - \\n\\n![image](https://assets.leetcode.com/users/images/b3fd3aeb-ebc3-4152-b3c7-7eb15758cddc_1620325878.3202064.png)\\n\\nNow we have all three arrays for Lan1,Lan2 ,Lan3\\n\\nNow all we need to do whenever we encounter the obstacle search in the rest of the two lan and find out which point in the respective lan is most far away from the obstacle and select that lan\\n\\nCode - \\n```\\nclass Solution {\\npublic:\\n    \\n    void fill_lan(vector<int> obstacles,int lan_no,vector<int>& lan){\\n        int n = obstacles.size();\\n        lan[n-1] = -1;\\n        for(int i=n-2;i>=0;i--){\\n            if(obstacles[i]==lan_no){\\n                lan[i] = 0;\\n            }else{\\n                if(lan[i+1]!=-1) lan[i] = lan[i+1]+1;\\n                else lan[i] = -1;\\n            }\\n        }\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        vector<int> lan1(n,0);\\n        vector<int> lan2(n,0);\\n        vector<int> lan3(n,0);\\n        \\n        fill_lan(obstacles,1,lan1);\\n        fill_lan(obstacles,2,lan2);\\n        fill_lan(obstacles,3,lan3);\\n        \\n        int res = 0;\\n        int curr_lan = 2;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(curr_lan==obstacles[i+1]){\\n                if(curr_lan==1){\\n                    if(lan2[i]==-1){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan3[i]==-1){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan2[i]<lan3[i]){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan2[i]>lan3[i]){\\n                        res++;\\n                        curr_lan = 2;\\n                    }\\n                }else if(curr_lan==2){\\n                    if(lan1[i]==-1){\\n                        res++;\\n                        curr_lan = 1;\\n                    }else if(lan3[i]==-1){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan1[i]<lan3[i]){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan1[i]>lan3[i]){\\n                        res++;\\n                        curr_lan = 1;\\n                    }\\n                }else if(curr_lan==3){\\n                    if(lan1[i]==-1){\\n                        res++;\\n                        curr_lan = 1;\\n                    }else if(lan2[i]==-1){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan1[i]<lan2[i]){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan1[i]>lan2[i]){\\n                        res++;\\n                        curr_lan = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n         \\n    }\\n};\\n```\\n\\nHopefully my intution and code is enough for you guys to understand the question",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void fill_lan(vector<int> obstacles,int lan_no,vector<int>& lan){\\n        int n = obstacles.size();\\n        lan[n-1] = -1;\\n        for(int i=n-2;i>=0;i--){\\n            if(obstacles[i]==lan_no){\\n                lan[i] = 0;\\n            }else{\\n                if(lan[i+1]!=-1) lan[i] = lan[i+1]+1;\\n                else lan[i] = -1;\\n            }\\n        }\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        vector<int> lan1(n,0);\\n        vector<int> lan2(n,0);\\n        vector<int> lan3(n,0);\\n        \\n        fill_lan(obstacles,1,lan1);\\n        fill_lan(obstacles,2,lan2);\\n        fill_lan(obstacles,3,lan3);\\n        \\n        int res = 0;\\n        int curr_lan = 2;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(curr_lan==obstacles[i+1]){\\n                if(curr_lan==1){\\n                    if(lan2[i]==-1){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan3[i]==-1){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan2[i]<lan3[i]){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan2[i]>lan3[i]){\\n                        res++;\\n                        curr_lan = 2;\\n                    }\\n                }else if(curr_lan==2){\\n                    if(lan1[i]==-1){\\n                        res++;\\n                        curr_lan = 1;\\n                    }else if(lan3[i]==-1){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan1[i]<lan3[i]){\\n                        res++;\\n                        curr_lan = 3;\\n                    }else if(lan1[i]>lan3[i]){\\n                        res++;\\n                        curr_lan = 1;\\n                    }\\n                }else if(curr_lan==3){\\n                    if(lan1[i]==-1){\\n                        res++;\\n                        curr_lan = 1;\\n                    }else if(lan2[i]==-1){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan1[i]<lan2[i]){\\n                        res++;\\n                        curr_lan = 2;\\n                    }else if(lan1[i]>lan2[i]){\\n                        res++;\\n                        curr_lan = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166811,
                "title": "c-memoization-easy-and-small",
                "content": "```\\nclass Solution {\\npublic:int n;\\n\\n    int help(int lane,int i,vector<int>&ob,vector<vector<int>>& dp)\\n    {\\n        \\n        if(i==n-1)\\n            return 0;\\n        if(ob[i]==lane+1)\\n            return INT_MAX;\\n        if(dp[i][lane]!=-1)\\n            return dp[i][lane];\\n        if(ob[i+1]!=lane+1)\\n            return dp[i][lane]=help(lane,i+1,ob,dp);\\n        return dp[i][lane]=1+min(help((lane+1)%3,i,ob,dp),help((lane+2)%3,i,ob,dp));\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        n=obstacles.size();\\n        vector<vector<int>>dp(n+1,vector<int>(3,-1));\\n        return help(1,0,obstacles,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:int n;\\n\\n    int help(int lane,int i,vector<int>&ob,vector<vector<int>>& dp)\\n    {\\n        \\n        if(i==n-1)\\n            return 0;\\n        if(ob[i]==lane+1)\\n            return INT_MAX;\\n        if(dp[i][lane]!=-1)\\n            return dp[i][lane];\\n        if(ob[i+1]!=lane+1)\\n            return dp[i][lane]=help(lane,i+1,ob,dp);\\n        return dp[i][lane]=1+min(help((lane+1)%3,i,ob,dp),help((lane+2)%3,i,ob,dp));\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        n=obstacles.size();\\n        vector<vector<int>>dp(n+1,vector<int>(3,-1));\\n        return help(1,0,obstacles,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480131,
                "title": "python-3-dp-explanation",
                "content": "### Explanation\\n- 3 rows, for each index `i`, frog can only come from either **same row, column `i-1`** or **different row, same column `i`**\\n- Based on above, we can get our transition function:\\n\\t- DP state: `dp[i][j]` number of side steps to reach row `i`, column `j`\\n\\t- Initial value: `dp[0][0] = dp[2][0] = 1, dp[1][0] = 0`\\n\\t- Transition function:\\n\\t\\t```\\n\\t\\tdp[i][j] = dp[i][j-1] if obstacles[j] != 1 else sys.maxsize\\n\\t\\tif obstacles[i] != 1: # for first row\\n\\t\\t\\tfor j in [1, 2]:  # side jump from other 2 rows\\n\\t\\t\\t\\tdp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n\\t\\t```\\n\\t- Final result: `min(dp[0][-1], dp[1][-1], dp[2][-1])`\\n### Implementation\\n- `O(n) space & time solution`\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)\\n        dp = [[sys.maxsize] * n for _ in range(3)]\\n        dp[0][0]= 1\\n        dp[1][0]= 0\\n        dp[2][0]= 1\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] if obstacles[i] != 1 else sys.maxsize\\n            dp[1][i] = dp[1][i-1] if obstacles[i] != 2 else sys.maxsize\\n            dp[2][i] = dp[2][i-1] if obstacles[i] != 3 else sys.maxsize\\n            if obstacles[i] != 1:\\n                for j in [1, 2]:\\n                    dp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n            if obstacles[i] != 2:\\n                for j in [0, 2]:\\n                    dp[1][i] = min(dp[1][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n            if obstacles[i] != 3:\\n                for j in [0, 1]:\\n                    dp[2][i] = min(dp[2][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])\\n```\\n- `O(1) space solution`, since only the value from `i-1` is used\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)\\n        a, b, c = 1, 0, 1\\n        for i in range(1, n):\\n            a = a if obstacles[i] != 1 else sys.maxsize\\n            b = b if obstacles[i] != 2 else sys.maxsize\\n            c = c if obstacles[i] != 3 else sys.maxsize\\n            if obstacles[i] != 1:\\n                a = min(a, b + 1 if obstacles[i] != 2 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)\\n            if obstacles[i] != 2:\\n                b = min(b, a + 1 if obstacles[i] != 1 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)\\n            if obstacles[i] != 3:\\n                c = min(c, a + 1 if obstacles[i] != 1 else sys.maxsize, b + 1 if obstacles[i] != 2 else sys.maxsize)\\n        return min(a, b, c)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t\\tdp[i][j] = dp[i][j-1] if obstacles[j] != 1 else sys.maxsize\\n\\t\\tif obstacles[i] != 1: # for first row\\n\\t\\t\\tfor j in [1, 2]:  # side jump from other 2 rows\\n\\t\\t\\t\\tdp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n\\t\\t```\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)\\n        dp = [[sys.maxsize] * n for _ in range(3)]\\n        dp[0][0]= 1\\n        dp[1][0]= 0\\n        dp[2][0]= 1\\n        for i in range(1, n):\\n            dp[0][i] = dp[0][i-1] if obstacles[i] != 1 else sys.maxsize\\n            dp[1][i] = dp[1][i-1] if obstacles[i] != 2 else sys.maxsize\\n            dp[2][i] = dp[2][i-1] if obstacles[i] != 3 else sys.maxsize\\n            if obstacles[i] != 1:\\n                for j in [1, 2]:\\n                    dp[0][i] = min(dp[0][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n            if obstacles[i] != 2:\\n                for j in [0, 2]:\\n                    dp[1][i] = min(dp[1][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n            if obstacles[i] != 3:\\n                for j in [0, 1]:\\n                    dp[2][i] = min(dp[2][i], dp[j][i] + 1 if obstacles[i] != j+1 else sys.maxsize)\\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])\\n```\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)\\n        a, b, c = 1, 0, 1\\n        for i in range(1, n):\\n            a = a if obstacles[i] != 1 else sys.maxsize\\n            b = b if obstacles[i] != 2 else sys.maxsize\\n            c = c if obstacles[i] != 3 else sys.maxsize\\n            if obstacles[i] != 1:\\n                a = min(a, b + 1 if obstacles[i] != 2 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)\\n            if obstacles[i] != 2:\\n                b = min(b, a + 1 if obstacles[i] != 1 else sys.maxsize, c + 1 if obstacles[i] != 3 else sys.maxsize)\\n            if obstacles[i] != 3:\\n                c = min(c, a + 1 if obstacles[i] != 1 else sys.maxsize, b + 1 if obstacles[i] != 2 else sys.maxsize)\\n        return min(a, b, c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279177,
                "title": "easy-c-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        //for every point we are calculating the minimum sideway jumps that can be jump to the a lane from thr other two lanes\\n        \\n        vector<int> jumps(3,0);\\n        jumps[0]=1; //at first frog is in lane 2 so it requires 1 sideway jump \\n        //to get on to lane 1 (1-based indexing)\\n        jumps[2]=1; \\n        \\n        for(int k=0;k<obstacles.size();k++)\\n        {\\n            if(obstacles[k]>0)\\n            {\\n                //a obstacle is present make the value in the current lane to infinite \\n                jumps[obstacles[k]-1]=1e6;\\n            }\\n            //for every lane check whether other way exists to get on to the current lane from other lane which has minimum sideway jumps than the current\\n           for(int i=0;i<3;i++)\\n           {\\n               if(i!=obstacles[k]-1) {//if the obstacle is not present in current lane\\n               //i+1%3 and i+2%3 returns the other two lanes indices (0-based)\\n               \\n               //and also add 1 as we are jumping from other lane to current lane\\n               //ie., minimum of current sideway jumps to reach the current lane \\n               //and the other lanes sideway jumps+1\\n                jumps[i]=min(jumps[i],min(jumps[(i+1)%3],jumps[(i+2)%3])+1);\\n               }\\n           }\\n        }\\n        //have reached point n\\n        //jumps[0] stores the sideway jumps to get on to lane 0\\n        //jumps[1] stores the sideway jumps to get on to lane 1\\n        //jumps[2] stores the sideway jumps to get on to lane 2\\n        //get the minimum of them\\n        return min(jumps[0],min(jumps[1],jumps[2]));\\n    }\\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        //for every point we are calculating the minimum sideway jumps that can be jump to the a lane from thr other two lanes\\n        \\n        vector<int> jumps(3,0);\\n        jumps[0]=1; //at first frog is in lane 2 so it requires 1 sideway jump \\n        //to get on to lane 1 (1-based indexing)\\n        jumps[2]=1; \\n        \\n        for(int k=0;k<obstacles.size();k++)\\n        {\\n            if(obstacles[k]>0)\\n            {\\n                //a obstacle is present make the value in the current lane to infinite \\n                jumps[obstacles[k]-1]=1e6;\\n            }\\n            //for every lane check whether other way exists to get on to the current lane from other lane which has minimum sideway jumps than the current\\n           for(int i=0;i<3;i++)\\n           {\\n               if(i!=obstacles[k]-1) {//if the obstacle is not present in current lane\\n               //i+1%3 and i+2%3 returns the other two lanes indices (0-based)\\n               \\n               //and also add 1 as we are jumping from other lane to current lane\\n               //ie., minimum of current sideway jumps to reach the current lane \\n               //and the other lanes sideway jumps+1\\n                jumps[i]=min(jumps[i],min(jumps[(i+1)%3],jumps[(i+2)%3])+1);\\n               }\\n           }\\n        }\\n        //have reached point n\\n        //jumps[0] stores the sideway jumps to get on to lane 0\\n        //jumps[1] stores the sideway jumps to get on to lane 1\\n        //jumps[2] stores the sideway jumps to get on to lane 2\\n        //get the minimum of them\\n        return min(jumps[0],min(jumps[1],jumps[2]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456225,
                "title": "recursive-memoization-tabulation-space-optimization-beats-95",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ $$ tabulation, space Optimization $$ \\n\\n- Space complexity: $$O(1)$$ $$ space Optimization$$\\n\\n# Code\\n```\\nclass Solution {\\n    int mod = 1000000000;\\n    public int minSideJumps(int[] obstacles) {\\n        // return helperRec(obstacles, 2, 0);\\n\\n        // int[][] dp = new int[4][obstacles.length];\\n        // for(int row[] : dp) Arrays.fill(row, -1);\\n        // return helperMem(obstacles, 2, 0, dp);\\n\\n        // return helperTab(obstacles);\\n\\n        return helperSO(obstacles);\\n    }\\n    \\n    // RECURSIVE APPROACH\\n    public int helperRec(int[] obstacles, int lane, int index){\\n        int n = obstacles.length;\\n        //BASE CASE\\n        if(index == n - 1) return 0;\\n\\n        // CONTINUING TO THE SAME LANE\\n        if(obstacles[index + 1] != lane){\\n            return helperRec(obstacles, lane, index + 1);\\n        }\\n        // MEET OBSTACLE IN SAME LANE THEN TRYING SIDE JUMPS\\n        else{ \\n            int ans = Integer.MAX_VALUE;\\n            for(int i = 1; i <= 3; i++){\\n                if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + helperRec(obstacles, i, index));\\n            }\\n            return ans;\\n        }\\n    }\\n\\n    // MEMOIZATION APPROACH\\n    public int helperMem(int[] obstacles, int lane, int index, int[][] dp){\\n        int n = obstacles.length;\\n        //BASE CASE\\n        if(index == n - 1) return 0;\\n\\n        //MEMOIZATION CHECK\\n        if(dp[lane][index] != -1) return dp[lane][index];\\n        if(obstacles[index + 1] != lane){\\n            return helperMem(obstacles, lane, index + 1, dp);\\n        }else{\\n            int ans = Integer.MAX_VALUE;\\n            for(int i = 1; i <= 3; i++){\\n                if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + helperMem(obstacles, i, index, dp));\\n            }\\n            return dp[lane][index] = ans;\\n        }\\n    }\\n\\n    // TABULATION APPROACH\\n    public int helperTab(int[] obstacles){\\n        int n = obstacles.length;\\n        int[][] dp = new int[4][obstacles.length];\\n        // mod because max value m kuch bhi add krenge to negative chlna jayega value, mod is defined globally\\n        for(int row[] : dp) Arrays.fill(row, mod);\\n        \\n        // BASE CASE ANALYSIS\\n        for(int i = 0; i <= 3; i++) dp[i][n-1] = 0;\\n        \\n        // CHECKING FOR EVERY LANE AND EVERY INDEX\\n        for(int index = n - 2; index >= 0; index--){\\n            for(int lane = 1; lane <= 3; lane++){\\n                if(obstacles[index + 1] != lane){\\n                    dp[lane][index] = dp[lane][index + 1];\\n                }else{\\n                    int ans = mod;\\n                    for(int i = 1; i <= 3; i++){\\n                        // index + 1 because humara for loop 1 se 3 pe jara h, if 3 ka ans nikla nhi h to uski jgah to 1e9 hoga\\n                        // and 1 lane m mano obstackle h to usse side jump nhi ho skta, to mtlb hum lane 2 m lane 3 se aaye hai\\n                        // and if 3rd lane ka ans calculate nhi hua to udhr 1e9 hoga jisse humara ans 1e9 + 1 hojayega\\n                        // jo pura glt h that\\'s why hum usko next index p depend kra dete h\\n                        if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + dp[i][index + 1]);\\n                    }\\n                    dp[lane][index] = ans;\\n                }\\n            }\\n        }\\n        //BECASUSE IF FIRST LANE SE 2 H, 2ND LANE M 5, AND 3RD LANE M 3 H TO, HUM 1ST AND 3RD LANE SE EK EXTRA SIDE JUMP LEKE\\n        // BHI TO 2,0 STARTING POSTION TK PAHUCH SKTE H TO UNME 1 ADD KRKE min le liya\\n        return Math.min(dp[1][0] + 1, Math.min(dp[2][0], dp[3][0] + 1));\\n    }\\n\\n    // SPACE OPTIMIZATION APPROACH\\n    public int helperSO(int[] obstacles){\\n        int n = obstacles.length;\\n\\n        int[] curr = new int[4];\\n        int[] next = new int[4];\\n        Arrays.fill(curr, mod);\\n        // BASE CASE ANALYSIS\\n        Arrays.fill(next, 0);\\n        \\n        // CHECKING FOR EVERY LANE AND EVERY INDEX\\n        for(int index = n - 2; index >= 0; index--){\\n            for(int lane = 1; lane <= 3; lane++){\\n                if(obstacles[index + 1] != lane){\\n                    curr[lane] = next[lane];\\n                }else{\\n                    int ans = mod;\\n                    for(int i = 1; i <= 3; i++){\\n                        if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + next[i]);\\n                    }\\n                    curr[lane] = ans;\\n                }\\n            }\\n            next = curr;\\n        }\\n        return Math.min(next[1] + 1, Math.min(next[2], next[3] + 1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int mod = 1000000000;\\n    public int minSideJumps(int[] obstacles) {\\n        // return helperRec(obstacles, 2, 0);\\n\\n        // int[][] dp = new int[4][obstacles.length];\\n        // for(int row[] : dp) Arrays.fill(row, -1);\\n        // return helperMem(obstacles, 2, 0, dp);\\n\\n        // return helperTab(obstacles);\\n\\n        return helperSO(obstacles);\\n    }\\n    \\n    // RECURSIVE APPROACH\\n    public int helperRec(int[] obstacles, int lane, int index){\\n        int n = obstacles.length;\\n        //BASE CASE\\n        if(index == n - 1) return 0;\\n\\n        // CONTINUING TO THE SAME LANE\\n        if(obstacles[index + 1] != lane){\\n            return helperRec(obstacles, lane, index + 1);\\n        }\\n        // MEET OBSTACLE IN SAME LANE THEN TRYING SIDE JUMPS\\n        else{ \\n            int ans = Integer.MAX_VALUE;\\n            for(int i = 1; i <= 3; i++){\\n                if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + helperRec(obstacles, i, index));\\n            }\\n            return ans;\\n        }\\n    }\\n\\n    // MEMOIZATION APPROACH\\n    public int helperMem(int[] obstacles, int lane, int index, int[][] dp){\\n        int n = obstacles.length;\\n        //BASE CASE\\n        if(index == n - 1) return 0;\\n\\n        //MEMOIZATION CHECK\\n        if(dp[lane][index] != -1) return dp[lane][index];\\n        if(obstacles[index + 1] != lane){\\n            return helperMem(obstacles, lane, index + 1, dp);\\n        }else{\\n            int ans = Integer.MAX_VALUE;\\n            for(int i = 1; i <= 3; i++){\\n                if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + helperMem(obstacles, i, index, dp));\\n            }\\n            return dp[lane][index] = ans;\\n        }\\n    }\\n\\n    // TABULATION APPROACH\\n    public int helperTab(int[] obstacles){\\n        int n = obstacles.length;\\n        int[][] dp = new int[4][obstacles.length];\\n        // mod because max value m kuch bhi add krenge to negative chlna jayega value, mod is defined globally\\n        for(int row[] : dp) Arrays.fill(row, mod);\\n        \\n        // BASE CASE ANALYSIS\\n        for(int i = 0; i <= 3; i++) dp[i][n-1] = 0;\\n        \\n        // CHECKING FOR EVERY LANE AND EVERY INDEX\\n        for(int index = n - 2; index >= 0; index--){\\n            for(int lane = 1; lane <= 3; lane++){\\n                if(obstacles[index + 1] != lane){\\n                    dp[lane][index] = dp[lane][index + 1];\\n                }else{\\n                    int ans = mod;\\n                    for(int i = 1; i <= 3; i++){\\n                        // index + 1 because humara for loop 1 se 3 pe jara h, if 3 ka ans nikla nhi h to uski jgah to 1e9 hoga\\n                        // and 1 lane m mano obstackle h to usse side jump nhi ho skta, to mtlb hum lane 2 m lane 3 se aaye hai\\n                        // and if 3rd lane ka ans calculate nhi hua to udhr 1e9 hoga jisse humara ans 1e9 + 1 hojayega\\n                        // jo pura glt h that\\'s why hum usko next index p depend kra dete h\\n                        if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + dp[i][index + 1]);\\n                    }\\n                    dp[lane][index] = ans;\\n                }\\n            }\\n        }\\n        //BECASUSE IF FIRST LANE SE 2 H, 2ND LANE M 5, AND 3RD LANE M 3 H TO, HUM 1ST AND 3RD LANE SE EK EXTRA SIDE JUMP LEKE\\n        // BHI TO 2,0 STARTING POSTION TK PAHUCH SKTE H TO UNME 1 ADD KRKE min le liya\\n        return Math.min(dp[1][0] + 1, Math.min(dp[2][0], dp[3][0] + 1));\\n    }\\n\\n    // SPACE OPTIMIZATION APPROACH\\n    public int helperSO(int[] obstacles){\\n        int n = obstacles.length;\\n\\n        int[] curr = new int[4];\\n        int[] next = new int[4];\\n        Arrays.fill(curr, mod);\\n        // BASE CASE ANALYSIS\\n        Arrays.fill(next, 0);\\n        \\n        // CHECKING FOR EVERY LANE AND EVERY INDEX\\n        for(int index = n - 2; index >= 0; index--){\\n            for(int lane = 1; lane <= 3; lane++){\\n                if(obstacles[index + 1] != lane){\\n                    curr[lane] = next[lane];\\n                }else{\\n                    int ans = mod;\\n                    for(int i = 1; i <= 3; i++){\\n                        if(lane != i && obstacles[index] != i) ans = Math.min(ans, 1 + next[i]);\\n                    }\\n                    curr[lane] = ans;\\n                }\\n            }\\n            next = curr;\\n        }\\n        return Math.min(next[1] + 1, Math.min(next[2], next[3] + 1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513903,
                "title": "python3-solution-dp-o-n-time-o-1-space",
                "content": "`Time Complexity` : `O(N)`\\n`Space Complexity` : `O(1)`\\n```\\nclass Solution:\\n    def minSideJumps(self, obs):\\n        n = len(obs)\\n        dp = [0] * 4\\n        for i in range(n - 2, 0, -1):\\n            if obs[i] == 0 or obs[i] == obs[i - 1]: continue    # this line can be ignored\\n            dp[obs[i]] = min(dp[j] for j in range(1, 4) if obs[i] != j and obs[i-1] != j) + 1\\n        return dp[2]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obs):\\n        n = len(obs)\\n        dp = [0] * 4\\n        for i in range(n - 2, 0, -1):\\n            if obs[i] == 0 or obs[i] == obs[i - 1]: continue    # this line can be ignored\\n            dp[obs[i]] = min(dp[j] for j in range(1, 4) if obs[i] != j and obs[i-1] != j) + 1\\n        return dp[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197001,
                "title": "c-memoization-on-recursion-simple-readable-code",
                "content": "```\\nIf you have any queries in this code, feel free to discuss. \\nThank you.\\n```\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &obstacles, int n, int currPos, int currLane, vector<vector<int>> &dp) {\\n        if(currPos==n)\\n            return(0);\\n        if(dp[currPos][currLane]!=-1)\\n            return(dp[currPos][currLane]);\\n        if(obstacles[currPos+1]!=currLane)\\n            return(dp[currPos][currLane]=solve(obstacles, n, currPos+1, currLane, dp));\\n        int mini=1e9;\\n        for(int i=1;i<=3;i++) {\\n            if(i!=currLane) {\\n                if(obstacles[currPos]!=i) {\\n                    mini=min(mini, 1+solve(obstacles, n, currPos, i, dp));\\n                }\\n            }\\n        }\\n        return(dp[currPos][currLane]=mini);\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size()-1;\\n        vector<vector<int>> dp(n+5, vector<int>(4, -1));\\n        int ans=solve(obstacles, n, 0, 2, dp);\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nIf you have any queries in this code, feel free to discuss. \\nThank you.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int> &obstacles, int n, int currPos, int currLane, vector<vector<int>> &dp) {\\n        if(currPos==n)\\n            return(0);\\n        if(dp[currPos][currLane]!=-1)\\n            return(dp[currPos][currLane]);\\n        if(obstacles[currPos+1]!=currLane)\\n            return(dp[currPos][currLane]=solve(obstacles, n, currPos+1, currLane, dp));\\n        int mini=1e9;\\n        for(int i=1;i<=3;i++) {\\n            if(i!=currLane) {\\n                if(obstacles[currPos]!=i) {\\n                    mini=min(mini, 1+solve(obstacles, n, currPos, i, dp));\\n                }\\n            }\\n        }\\n        return(dp[currPos][currLane]=mini);\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size()-1;\\n        vector<vector<int>> dp(n+5, vector<int>(4, -1));\\n        int ans=solve(obstacles, n, 0, 2, dp);\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160406,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master): It is more natural for me to switch the rows and columns, ie. let `dp[i][j]` denote the minimum side-steps performed to reach cell `i`,`j`.  The goal is to reach the `N`<sup>th</sup> row at minimum cost.  This bottom-up solution first attempts to perform optimal side-steps for the previous `i - 1`<sup>th</sup> row by optimally side-stepping from each column `j` to each column `k` (an astute observer will notice when `j == k`, this minimum operation is a no-op, since `min(x, x) == x`).  Then use those optimal solutions of the previous `i - 1`<sup>th</sup> row to formulate the optimal solutions of the current `i`<sup>th</sup> row until the `N`<sup>th</sup> row is reached.  Then we return the minimal value of the `N - 1`<sup>th</sup> row as the best answer.\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n1. Create the bottom-up solution\\n```\\nclass Solution {\\n    fun minSideJumps(A: IntArray): Int {\\n        var INF = (1e9 + 7).toInt()\\n        var N = A.size\\n        var dp = Array(N){ IntArray(3){ INF } }                                 // \\uD83E\\uDD14 memo\\n        dp[0][1] = 0                                                            // \\uD83D\\uDED1 base case\\n        for (i in 1 until N) {\\n            var x = A[i - 1] - 1                                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            var y = A[i] - 1                                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n            for (j in 0..2) {\\n                // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n                if (j != x)                                                     // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (k in 0..2)\\n                        dp[i - 1][j] = Math.min(dp[i - 1][j], 1 + dp[i - 1][k]) // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if (j != y)                                                     // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j])                 // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            }\\n        }\\n        return dp[N - 1].min()!!                                                // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n}\\n```\\n\\n2. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution {\\n    fun minSideJumps(A: IntArray): Int {\\n        var INF = (1e9 + 7).toInt()\\n        var N = A.size\\n        var pre = arrayOf(1, 0, 1)                            // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (i in 1 until N) {\\n            var x = A[i - 1] - 1                              // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            var y = A[i] - 1                                  // cur obstacle \\uD83C\\uDF4F at cur row i\\n            var cur = arrayOf(INF, INF, INF)\\n            for (j in 0..2) {\\n                // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n                if (j != x)                                   // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (k in 0..2)\\n                        pre[j] = Math.min(pre[j], 1 + pre[k]) // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if (j != y)                                   // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = Math.min(cur[j], pre[j])         // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            }\\n            pre = cur.copyOf()                                // \\uD83E\\uDD14 memo\\n        }\\n        return pre.min()!!                                    // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n1. Create the bottom-up solution\\n```\\nlet minSideJumps = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(3).fill(Infinity));                // \\uD83E\\uDD14 memo\\n    dp[0][1] = 0;                                                            // \\uD83D\\uDED1 base case\\n    for (let i = 1; i < N; ++i) {\\n        let x = A[i - 1] - 1,                                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1;                                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n        for (let j = 0; j < 3; ++j) {\\n            // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            if (j != x)                                                      // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                for (let k = 0; k < 3; ++k)\\n                    dp[i - 1][j] = Math.min(dp[i - 1][j], 1 + dp[i - 1][k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n            // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n            if (j != y)                                                      // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);                 // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        }\\n    }\\n    return Math.min(...dp[N - 1]);                                           // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n};\\n```\\n\\n2. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nlet minSideJumps = A => {\\n    let N = A.length;\\n    let pre = [1, 0, 1];                                     // \\uD83E\\uDD14 memo\\n    for (let i = 1; i < N; ++i) {\\n        let x = A[i - 1] - 1,                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1;                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n        let cur = [Infinity, Infinity, Infinity];\\n        for (let j = 0; j < 3; ++j) {\\n            // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            if (j != x)                                      // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                for (let k = 0; k < 3; ++k)\\n                    pre[j] = Math.min(pre[j], 1 + pre[k]);   // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n            // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n            if (j != y)                                      // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                cur[j] = Math.min(cur[j], pre[j]);           // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        }\\n        pre = [...cur];                                      // \\uD83E\\uDD14 memo\\n    }\\n    return Math.min(...pre);                                 // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n1. Create the bottom-up solution\\n```\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(N)]                        # \\uD83E\\uDD14 memo\\n        dp[0][1] = 0                                                       # \\uD83D\\uDED1 base case\\n        for i in range(1, N):\\n            x = A[i - 1] - 1                                               # pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1                                                   # cur obstacle \\uD83C\\uDF4F at cur row i\\n            # best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            for j in range(3):\\n                if j != x:                                                 # \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for k in range(3):\\n                        dp[i - 1][j] = min(dp[i - 1][j], 1 + dp[i - 1][k]) # \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                # best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if j != y:                                                 # \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j])                 # \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        return min(dp[N - 1])                                              # \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n```\\n\\n2. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution:\\n    def minSideJumps(self, A: List[int], INF = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        pre = [1, 0, 1]                                  # \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for i in range(1, N):\\n            x = A[i - 1] - 1                             # pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1                                 # cur obstacle \\uD83C\\uDF4F at cur row i\\n            cur = [INF, INF, INF]\\n            for j in range(3):\\n                if j != x:                               # \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for k in range(3):\\n                        pre[j] = min(pre[j], 1 + pre[k]) # \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                # best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if j != y:                               # \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = min(cur[j], pre[j])         # \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            pre = cur.copy()                             # \\uD83E\\uDD14 memo\\n        return min(pre)                                  # \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n1. Create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minSideJumps(VI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        VVI dp(N, VI(3, INF));                                              // \\uD83E\\uDD14 memo\\n        dp[0][1] = 0;                                                       // \\uD83D\\uDED1 base case\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto x = A[i - 1] - 1,                                          // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n                 y = A[i] - 1;                                              // cur obstacle \\uD83C\\uDF4F at cur row i\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                // pre row i - 1: best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k\\n                if (j != x)                                                 // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (auto k{ 0 }; k < 3; ++k)\\n                        dp[i - 1][j] = min(dp[i - 1][j], 1 + dp[i - 1][k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // cur row i: best \\uD83D\\uDC47 forward-hops from row i - 1 -> i\\n                if (j != y)                                                 // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j]);                 // \\u2705 no penalty for forward-hops from row i - 1 -> i\\n            }\\n        }\\n        return *min_element(dp[N - 1].begin(), dp[N - 1].end());            // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n};\\n```\\n\\n2. Memory optimization (ie. we only need the previous row to formulate the current row)\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minSideJumps(VI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        VI pre{ 1, 0, 1 };                                // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto x = A[i - 1] - 1,                        // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n                 y = A[i] - 1;                            // cur obstacle \\uD83C\\uDF4F at cur row i\\n            VI cur{ INF, INF, INF };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                // pre row i - 1: best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k\\n                if (j != x)                               // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (auto k{ 0 }; k < 3; ++k)\\n                        pre[j] = min(pre[j], 1 + pre[k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // cur row i: best \\uD83D\\uDC47 forward-hops from row i - 1 -> i\\n                if (j != y)                               // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = min(cur[j], pre[j]);         // \\u2705 no penalty for forward-hops from row i - 1 -> i\\n            }\\n            pre.swap(cur);                                // \\uD83E\\uDD14 memo\\n        }\\n        return *min_element(pre.begin(), pre.end());      // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minSideJumps(A: IntArray): Int {\\n        var INF = (1e9 + 7).toInt()\\n        var N = A.size\\n        var dp = Array(N){ IntArray(3){ INF } }                                 // \\uD83E\\uDD14 memo\\n        dp[0][1] = 0                                                            // \\uD83D\\uDED1 base case\\n        for (i in 1 until N) {\\n            var x = A[i - 1] - 1                                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            var y = A[i] - 1                                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n            for (j in 0..2) {\\n                // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n                if (j != x)                                                     // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (k in 0..2)\\n                        dp[i - 1][j] = Math.min(dp[i - 1][j], 1 + dp[i - 1][k]) // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if (j != y)                                                     // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j])                 // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            }\\n        }\\n        return dp[N - 1].min()!!                                                // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minSideJumps(A: IntArray): Int {\\n        var INF = (1e9 + 7).toInt()\\n        var N = A.size\\n        var pre = arrayOf(1, 0, 1)                            // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (i in 1 until N) {\\n            var x = A[i - 1] - 1                              // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            var y = A[i] - 1                                  // cur obstacle \\uD83C\\uDF4F at cur row i\\n            var cur = arrayOf(INF, INF, INF)\\n            for (j in 0..2) {\\n                // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n                if (j != x)                                   // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (k in 0..2)\\n                        pre[j] = Math.min(pre[j], 1 + pre[k]) // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if (j != y)                                   // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = Math.min(cur[j], pre[j])         // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            }\\n            pre = cur.copyOf()                                // \\uD83E\\uDD14 memo\\n        }\\n        return pre.min()!!                                    // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n}\\n```\n```\\nlet minSideJumps = A => {\\n    let N = A.length;\\n    let dp = [...Array(N)].map(_ => Array(3).fill(Infinity));                // \\uD83E\\uDD14 memo\\n    dp[0][1] = 0;                                                            // \\uD83D\\uDED1 base case\\n    for (let i = 1; i < N; ++i) {\\n        let x = A[i - 1] - 1,                                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1;                                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n        for (let j = 0; j < 3; ++j) {\\n            // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            if (j != x)                                                      // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                for (let k = 0; k < 3; ++k)\\n                    dp[i - 1][j] = Math.min(dp[i - 1][j], 1 + dp[i - 1][k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n            // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n            if (j != y)                                                      // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);                 // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        }\\n    }\\n    return Math.min(...dp[N - 1]);                                           // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n};\\n```\n```\\nlet minSideJumps = A => {\\n    let N = A.length;\\n    let pre = [1, 0, 1];                                     // \\uD83E\\uDD14 memo\\n    for (let i = 1; i < N; ++i) {\\n        let x = A[i - 1] - 1,                                // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1;                                    // cur obstacle \\uD83C\\uDF4F at cur row i\\n        let cur = [Infinity, Infinity, Infinity];\\n        for (let j = 0; j < 3; ++j) {\\n            // best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            if (j != x)                                      // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                for (let k = 0; k < 3; ++k)\\n                    pre[j] = Math.min(pre[j], 1 + pre[k]);   // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n            // best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n            if (j != y)                                      // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                cur[j] = Math.min(cur[j], pre[j]);           // \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        }\\n        pre = [...cur];                                      // \\uD83E\\uDD14 memo\\n    }\\n    return Math.min(...pre);                                 // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n};\\n```\n```\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(N)]                        # \\uD83E\\uDD14 memo\\n        dp[0][1] = 0                                                       # \\uD83D\\uDED1 base case\\n        for i in range(1, N):\\n            x = A[i - 1] - 1                                               # pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1                                                   # cur obstacle \\uD83C\\uDF4F at cur row i\\n            # best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k for pre row i - 1:\\n            for j in range(3):\\n                if j != x:                                                 # \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for k in range(3):\\n                        dp[i - 1][j] = min(dp[i - 1][j], 1 + dp[i - 1][k]) # \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                # best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if j != y:                                                 # \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j])                 # \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n        return min(dp[N - 1])                                              # \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n```\n```\\nclass Solution:\\n    def minSideJumps(self, A: List[int], INF = float(\\'inf\\')) -> int:\\n        N = len(A)\\n        pre = [1, 0, 1]                                  # \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for i in range(1, N):\\n            x = A[i - 1] - 1                             # pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n            y = A[i] - 1                                 # cur obstacle \\uD83C\\uDF4F at cur row i\\n            cur = [INF, INF, INF]\\n            for j in range(3):\\n                if j != x:                               # \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for k in range(3):\\n                        pre[j] = min(pre[j], 1 + pre[k]) # \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                # best \\uD83D\\uDC47 forward-hops from pre row i - 1 -> cur row i\\n                if j != y:                               # \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = min(cur[j], pre[j])         # \\uD83D\\uDCB0 no penalty for forward-hops from pre row i - 1 -> cur row i\\n            pre = cur.copy()                             # \\uD83E\\uDD14 memo\\n        return min(pre)                                  # \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minSideJumps(VI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        VVI dp(N, VI(3, INF));                                              // \\uD83E\\uDD14 memo\\n        dp[0][1] = 0;                                                       // \\uD83D\\uDED1 base case\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto x = A[i - 1] - 1,                                          // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n                 y = A[i] - 1;                                              // cur obstacle \\uD83C\\uDF4F at cur row i\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                // pre row i - 1: best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k\\n                if (j != x)                                                 // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (auto k{ 0 }; k < 3; ++k)\\n                        dp[i - 1][j] = min(dp[i - 1][j], 1 + dp[i - 1][k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // cur row i: best \\uD83D\\uDC47 forward-hops from row i - 1 -> i\\n                if (j != y)                                                 // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j]);                 // \\u2705 no penalty for forward-hops from row i - 1 -> i\\n            }\\n        }\\n        return *min_element(dp[N - 1].begin(), dp[N - 1].end());            // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minSideJumps(VI& A, int INF = 1e9 + 7) {\\n        int N = A.size();\\n        VI pre{ 1, 0, 1 };                                // \\uD83E\\uDD14 memo + \\uD83D\\uDED1 base case\\n        for (auto i{ 1 }; i < N; ++i) {\\n            auto x = A[i - 1] - 1,                        // pre obstacle \\uD83C\\uDF4E at pre row i - 1\\n                 y = A[i] - 1;                            // cur obstacle \\uD83C\\uDF4F at cur row i\\n            VI cur{ INF, INF, INF };\\n            for (auto j{ 0 }; j < 3; ++j) {\\n                // pre row i - 1: best \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops from col j -> k\\n                if (j != x)                               // \\uD83D\\uDEAB disclude possibility due to pre obstacle \\uD83C\\uDF4E at col j\\n                    for (auto k{ 0 }; k < 3; ++k)\\n                        pre[j] = min(pre[j], 1 + pre[k]); // \\uD83D\\uDCB0 +1 penalty for side-hops from col j -> k\\n                // cur row i: best \\uD83D\\uDC47 forward-hops from row i - 1 -> i\\n                if (j != y)                               // \\uD83D\\uDEAB disclude possibility due to cur obstacle \\uD83C\\uDF4F at col j\\n                    cur[j] = min(cur[j], pre[j]);         // \\u2705 no penalty for forward-hops from row i - 1 -> i\\n            }\\n            pre.swap(cur);                                // \\uD83E\\uDD14 memo\\n        }\\n        return *min_element(pre.begin(), pre.end());      // \\uD83C\\uDFAF minimum \\uD83D\\uDC48 \\uD83D\\uDC49 side-hops to reach row N - 1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155406,
                "title": "java-dp-o-n-o-1",
                "content": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int[] dp = new int[]{1, 0, 1};\\n        for(int i=1; i<obstacles.length; i++){\\n            switch(obstacles[i]){\\n                case 0:\\n                    dp[0] = min(dp[0], dp[1]+1, dp[2]+1);\\n                    dp[1] = min(dp[0]+1, dp[1], dp[2]+1);\\n                    dp[2] = min(dp[0]+1, dp[1]+1, dp[2]);\\n                    break;\\n                case 1:\\n                    dp[0] = Integer.MAX_VALUE;\\n                    dp[1] = min(dp[1], dp[2]+1);\\n                    dp[2] = min(dp[1]+1, dp[2]);\\n                    break;\\n                case 2:\\n                    dp[0] = min(dp[0], dp[2]+1);\\n                    dp[1] = Integer.MAX_VALUE;\\n                    dp[2] = min(dp[0]+1, dp[2]);\\n                    break;\\n                case 3:\\n                    dp[0] = min(dp[0], dp[1]+1);\\n                    dp[1] = min(dp[0]+1, dp[1]);\\n                    dp[2] = Integer.MAX_VALUE;\\n                    break;\\n            }\\n        }\\n        return min(dp[0], dp[1], dp[2]);\\n    }\\n    \\n    int min(int... vals){\\n        int min = Integer.MAX_VALUE;\\n        for(int val: vals){\\n            if(val>=0) min = Math.min(min, val);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int[] dp = new int[]{1, 0, 1};\\n        for(int i=1; i<obstacles.length; i++){\\n            switch(obstacles[i]){\\n                case 0:\\n                    dp[0] = min(dp[0], dp[1]+1, dp[2]+1);\\n                    dp[1] = min(dp[0]+1, dp[1], dp[2]+1);\\n                    dp[2] = min(dp[0]+1, dp[1]+1, dp[2]);\\n                    break;\\n                case 1:\\n                    dp[0] = Integer.MAX_VALUE;\\n                    dp[1] = min(dp[1], dp[2]+1);\\n                    dp[2] = min(dp[1]+1, dp[2]);\\n                    break;\\n                case 2:\\n                    dp[0] = min(dp[0], dp[2]+1);\\n                    dp[1] = Integer.MAX_VALUE;\\n                    dp[2] = min(dp[0]+1, dp[2]);\\n                    break;\\n                case 3:\\n                    dp[0] = min(dp[0], dp[1]+1);\\n                    dp[1] = min(dp[0]+1, dp[1]);\\n                    dp[2] = Integer.MAX_VALUE;\\n                    break;\\n            }\\n        }\\n        return min(dp[0], dp[1], dp[2]);\\n    }\\n    \\n    int min(int... vals){\\n        int min = Integer.MAX_VALUE;\\n        for(int val: vals){\\n            if(val>=0) min = Math.min(min, val);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153580,
                "title": "c-solution-based-on-bfs",
                "content": "Apply the standard BFS algorithm, but with some modifications.\\nIf there is no obstacles on current line -> just move forward (it will be most optimal solution).\\nIf there is an obstacle consider both of two other lines.\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        using ip = pair<int, pair<int, int>>;\\n        int size = obstacles.size();\\n        queue<ip> q;\\n        vector<vector<bool>> vis(4, vector<bool>(size, false));\\n        int sidej = INT_MAX;\\n        q.push({0, {2, 0}});\\n        vis[2][0] = true;\\n        while (!q.empty()) {\\n            auto p = q.front(); q.pop();\\n            int point = p.second.second;\\n            int line = p.second.first;\\n            int jumps = p.first;\\n            if (point >= size) return jumps;\\n            if (obstacles[point + 1] != line) {\\n                q.push({jumps, {line, point + 1}});\\n                vis[line][point + 1] = true;\\n            } else {\\n                for (int i = 1; i <= 3; i++) {\\n                    if (i != line && obstacles[point] != i) {\\n                        if (!vis[i][point]) {\\n                            q.push({jumps + 1, {i, point}});\\n                            vis[i][point] = true;\\n                        }\\n                    }\\n                }   \\n            }\\n        }\\n        return sidej;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        using ip = pair<int, pair<int, int>>;\\n        int size = obstacles.size();\\n        queue<ip> q;\\n        vector<vector<bool>> vis(4, vector<bool>(size, false));\\n        int sidej = INT_MAX;\\n        q.push({0, {2, 0}});\\n        vis[2][0] = true;\\n        while (!q.empty()) {\\n            auto p = q.front(); q.pop();\\n            int point = p.second.second;\\n            int line = p.second.first;\\n            int jumps = p.first;\\n            if (point >= size) return jumps;\\n            if (obstacles[point + 1] != line) {\\n                q.push({jumps, {line, point + 1}});\\n                vis[line][point + 1] = true;\\n            } else {\\n                for (int i = 1; i <= 3; i++) {\\n                    if (i != line && obstacles[point] != i) {\\n                        if (!vis[i][point]) {\\n                            q.push({jumps + 1, {i, point}});\\n                            vis[i][point] = true;\\n                        }\\n                    }\\n                }   \\n            }\\n        }\\n        return sidej;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153503,
                "title": "java-dp-recursive-code-with-matrix-to-memorize",
                "content": "my lane values will be 0,1,2\\nto switch between the lanes i have subtracted -1 from the array given\\nso to switch i can easily add +1 and +2 to the currentlane and do % with 3 to find the available option\\nex- current lane=1 so to switch between lanes, available options are 0 and 2\\nto get that 1+1%3=2 and 1+2%3=0\\nsimilarly for current lane=0 so to switch between lanes, options available are 1 and 2\\nto get that 0+1%3=1 and 0+2%3=2\\nand  for current lane=2 so to switch between lanes options available are 0 and 1\\nto get that 2+1%3=0 and 2+2%3=1\\n\\nRecursive Trree will be \\ncureentlane !=obstracle[i+1] in that case just move forward no need to jump\\nor\\nin this find the min between (switch lane option)\\nMy code\\n~~~\\nclass Solution {\\n    int[][] t=new int[3][500001];\\n    public int minSideJumps(int[] obstacles) {\\n        int index=0;\\n        int laneno=1;\\n        for(int i=0;i<obstacles.length;i++){\\n            obstacles[i]=obstacles[i]-1;\\n        }\\n       \\n        for(int i=0;i<3;i++){\\n            for(int j=0;j<500001;j++){\\n                t[i][j]=-1;\\n            }\\n        }\\n        return minJump(index,laneno,obstacles);\\n    }\\n\\n    public int minJump(int index,int currLane,int[] obstacles){\\n        \\n        if(index>=obstacles.length-1){\\n            return 0;\\n        }\\n        \\n        if(t[currLane][index]!=-1){\\n            return t[currLane][index];\\n        }\\n\\n        if(currLane!=obstacles[index+1]){\\n            t[currLane][index]= 0+minJump(index+1,currLane,obstacles);\\n        }else {\\n            int a=500001;\\n            int b=500001;\\n            \\n            if(obstacles[index]!=(currLane+1)%3){\\n                a= minJump(index,(currLane+1)%3,obstacles);\\n            }\\n\\n            if(obstacles[index]!=(currLane+2)%3){\\n                b=minJump(index,(currLane+2)%3,obstacles);\\n            }\\n\\n            t[currLane][index] = 1+Math.min(a,b);\\n        }\\n      return t[currLane][index];      \\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int[][] t=new int[3][500001];\\n    public int minSideJumps(int[] obstacles) {\\n        int index=0;\\n        int laneno=1;\\n        for(int i=0;i<obstacles.length;i++){\\n            obstacles[i]=obstacles[i]-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1152790,
                "title": "java-bfs-solution-o-n",
                "content": "```\\nclass State{\\n    int jumps;\\n    int index;\\n    int lane;\\n    State(){\\n        this.lane = 2;\\n    }\\n    State(int j, int i, int l){\\n        this.jumps = j;\\n        this.index = i;\\n        this.lane = l;\\n    }\\n}\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        Queue<State> q = new LinkedList<State>();\\n        boolean[][] vis = new boolean[4][obstacles.length];\\n        q.offer(new State(0,0,2));\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                //Get current state\\n                State front = q.poll();\\n                \\n                //Check if we are at the end of the road\\n                if(front.index == obstacles.length-1){\\n                    return front.jumps;\\n                }\\n                \\n                //Check if we are obstructed or check if this is visited already\\n                if(obstacles[front.index] == front.lane || vis[front.lane][front.index]){\\n                    continue;\\n                }\\n                \\n                //Visit current lane by marking it visited\\n                vis[front.lane][front.index] = true;\\n                \\n                \\n                //Add all other options from this state to next state\\n                for(int i=1;i<=3;i++){\\n                    \\n                    //Moving/Hopping to next index in same lane\\n                    if(i == front.lane){\\n                        q.offer(new State(front.jumps, front.index+1, i));\\n                    }\\n                    //Exploring sideways jumps also\\n                    else{\\n                        q.offer(new State(front.jumps+1, front.index, i));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //No route till end of the road, Not possible in this question I guess\\n        return -1;\\n    }\\n}\\n```\\n**Time Complexity:** We are visiting every possible position on the road for the frog, \\n\\t\\t\\t\\t\\t\\t\\tO(No. of lanes * length of the lane(obstacles)) = O(3 * N)\\n**Space Complexity:** O(4 * N), for keeping track whether each position is visited or not,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tusing 4 instead of 3 as the rows of vis[][] is 4, to handle 1-indexed\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tlanes.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass State{\\n    int jumps;\\n    int index;\\n    int lane;\\n    State(){\\n        this.lane = 2;\\n    }\\n    State(int j, int i, int l){\\n        this.jumps = j;\\n        this.index = i;\\n        this.lane = l;\\n    }\\n}\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        Queue<State> q = new LinkedList<State>();\\n        boolean[][] vis = new boolean[4][obstacles.length];\\n        q.offer(new State(0,0,2));\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-- > 0){\\n                //Get current state\\n                State front = q.poll();\\n                \\n                //Check if we are at the end of the road\\n                if(front.index == obstacles.length-1){\\n                    return front.jumps;\\n                }\\n                \\n                //Check if we are obstructed or check if this is visited already\\n                if(obstacles[front.index] == front.lane || vis[front.lane][front.index]){\\n                    continue;\\n                }\\n                \\n                //Visit current lane by marking it visited\\n                vis[front.lane][front.index] = true;\\n                \\n                \\n                //Add all other options from this state to next state\\n                for(int i=1;i<=3;i++){\\n                    \\n                    //Moving/Hopping to next index in same lane\\n                    if(i == front.lane){\\n                        q.offer(new State(front.jumps, front.index+1, i));\\n                    }\\n                    //Exploring sideways jumps also\\n                    else{\\n                        q.offer(new State(front.jumps+1, front.index, i));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //No route till end of the road, Not possible in this question I guess\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152687,
                "title": "simple-c-o-n-time-complexity-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n      \\n        int l[] = {0,0,0,0};\\n        \\n        for(int i=obstacles.size()-2; i>0 ; i--){\\n            \\n            int nl[] = {0,0,0,0};\\n            \\n            l[obstacles[i+1]] = 500001;\\n            l[obstacles[i]] = 500001;          \\n            \\n            nl[1] = min(l[1], min(l[2]+1, l[3]+1));\\n            nl[2] = min(l[2], min(l[1]+1, l[3]+1));\\n            nl[3] = min(l[3], min(l[2]+1, l[1]+1));           \\n            \\n            \\n            copy(begin(nl),end(nl),begin(l));\\n            \\n        }\\n        \\n        return min(l[2], min(l[1]+1, l[3]+1));\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n      \\n        int l[] = {0,0,0,0};\\n        \\n        for(int i=obstacles.size()-2; i>0 ; i--){\\n            \\n            int nl[] = {0,0,0,0};\\n            \\n            l[obstacles[i+1]] = 500001;\\n            l[obstacles[i]] = 500001;          \\n            \\n            nl[1] = min(l[1], min(l[2]+1, l[3]+1));\\n            nl[2] = min(l[2], min(l[1]+1, l[3]+1));\\n            nl[3] = min(l[3], min(l[2]+1, l[1]+1));           \\n            \\n            \\n            copy(begin(nl),end(nl),begin(l));\\n            \\n        }\\n        \\n        return min(l[2], min(l[1]+1, l[3]+1));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152680,
                "title": "python-3-clear-easy",
                "content": "Calculating optimal no of steps required for travelling from particular position to end (each line)\\nfrom the end\\n##### Example\\n\\t\\t       0       1      2      3      0\\n\\t\\t\\t   ---------------------------------\\n\\t\\t x    inf    inf      1      0      0\\n\\t     y     2     2       inf     0      0  \\n\\t\\t z     1     1        1      i      0\\n\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        x,y,z=0,0,0\\n        px,py,pz=0,0,0\\n\\n        for o in obstacles[::-1][1:]:\\n            \\n            if o==1:\\n                x = float(\"inf\")\\n                y = min(py, pz+1)\\n                z = min(pz, py+1)\\n            elif o==2:\\n                y = float(\"inf\")\\n                x = min(px, pz+1)\\n                z = min(pz, px+1)\\n            elif o==3:\\n                z = float(\"inf\")\\n                y = min(py, px+1)\\n                x = min(px, py+1)\\n            else:\\n                y = min(py, px+1, pz+1)\\n                x = min(px, py+1, pz+1)\\n                z = min(pz, px+1, py+1)\\n            px,py,pz=x,y,z                \\n\\n        return y\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        x,y,z=0,0,0\\n        px,py,pz=0,0,0\\n\\n        for o in obstacles[::-1][1:]:\\n            \\n            if o==1:\\n                x = float(\"inf\")\\n                y = min(py, pz+1)\\n                z = min(pz, py+1)\\n            elif o==2:\\n                y = float(\"inf\")\\n                x = min(px, pz+1)\\n                z = min(pz, px+1)\\n            elif o==3:\\n                z = float(\"inf\")\\n                y = min(py, px+1)\\n                x = min(px, py+1)\\n            else:\\n                y = min(py, px+1, pz+1)\\n                x = min(px, py+1, pz+1)\\n                z = min(pz, px+1, py+1)\\n            px,py,pz=x,y,z                \\n\\n        return y\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253238,
                "title": "simple-memoized-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->]\\nhere  at each step if the current lane does not have any obstacle in the next point then move in the current lane .otherwise need to use sideways jumps\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int help(int point,int lane,vector<int>&obstacles,vector<vector<int>>&dp){\\n\\n\\n        if(point>=obstacles.size()-1){\\n            return dp[point][lane]=0;\\n            //this is the base case\\n        }\\n\\n        if(dp[point][lane]!=-1){\\n            return dp[point][lane];\\n        }\\n\\n\\n\\n        if(obstacles[point+1]==0||obstacles[point+1]!=lane){\\n            //current lane me hi i will move one step formward for the most optimal answer \\n            //as i need to optimse the n umber of side jumps overall\\n             dp[point][lane]=help(point+1,lane,obstacles,dp);\\n        }else{\\n\\n            int c=obstacles[point+1];\\n            int mn=INT_MAX;\\n            if(c!=1 && obstacles[point]!=1){\\n                mn=min(mn,help(point+1,1,obstacles,dp)+1);\\n\\n            }\\n            if(c!=2 && obstacles[point]!=2){\\n                mn=min(mn,help(point+1,2,obstacles,dp)+1);\\n\\n            }\\n            if(c!=3 && obstacles[point]!=3){\\n                mn=min(mn,help(point+1,3,obstacles,dp)+1);\\n            }\\n             dp[point][lane]=mn;\\n        }\\n        return dp[point][lane];\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        //note you should first read the question carefully \\n\\n        if(obstacles.size()<=1){\\n            return 0;\\n        }\\n        //when ever he makes a sideway jump he makes it to a diff lane on the same point\\n        int n=obstacles.size();\\n        //now we willl optimse it \\n        //see which all variables are changing in the current recursiuve \\n        //logic building and implementation both somewhat diff\\n        vector<vector<int>>dp(n+2,vector<int>(4,-1));\\n        //assign meaning to the dp matrix \\n        //dp[i][j]-min number of side way jumps to reach the last points\\n\\n\\n        return help(0,2,obstacles,dp);\\n\\n        //there are no obstacles on point 0 to n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int help(int point,int lane,vector<int>&obstacles,vector<vector<int>>&dp){\\n\\n\\n        if(point>=obstacles.size()-1){\\n            return dp[point][lane]=0;\\n            //this is the base case\\n        }\\n\\n        if(dp[point][lane]!=-1){\\n            return dp[point][lane];\\n        }\\n\\n\\n\\n        if(obstacles[point+1]==0||obstacles[point+1]!=lane){\\n            //current lane me hi i will move one step formward for the most optimal answer \\n            //as i need to optimse the n umber of side jumps overall\\n             dp[point][lane]=help(point+1,lane,obstacles,dp);\\n        }else{\\n\\n            int c=obstacles[point+1];\\n            int mn=INT_MAX;\\n            if(c!=1 && obstacles[point]!=1){\\n                mn=min(mn,help(point+1,1,obstacles,dp)+1);\\n\\n            }\\n            if(c!=2 && obstacles[point]!=2){\\n                mn=min(mn,help(point+1,2,obstacles,dp)+1);\\n\\n            }\\n            if(c!=3 && obstacles[point]!=3){\\n                mn=min(mn,help(point+1,3,obstacles,dp)+1);\\n            }\\n             dp[point][lane]=mn;\\n        }\\n        return dp[point][lane];\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        //note you should first read the question carefully \\n\\n        if(obstacles.size()<=1){\\n            return 0;\\n        }\\n        //when ever he makes a sideway jump he makes it to a diff lane on the same point\\n        int n=obstacles.size();\\n        //now we willl optimse it \\n        //see which all variables are changing in the current recursiuve \\n        //logic building and implementation both somewhat diff\\n        vector<vector<int>>dp(n+2,vector<int>(4,-1));\\n        //assign meaning to the dp matrix \\n        //dp[i][j]-min number of side way jumps to reach the last points\\n\\n\\n        return help(0,2,obstacles,dp);\\n\\n        //there are no obstacles on point 0 to n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935585,
                "title": "easy-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*4) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*4)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602192,
                "title": "c-recursion-tle-memoization-top-down-bottom-up",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]\\n**There are 3 approaches :**\\n* Recursion **(TLE)**\\n* Recursion + (DP) **Memoization** (Top down approach ) \\n* Dp with Bottom up approach **Will upload code tomarrow **\\n\\n\\n\\n***1st Approach : Recursion (TLE) NOT ACCEPTED*** \\n```\\nint solve(vector<int>& obstacles, int pos,int currlane){\\n        if(pos==obstacles.size()-1){                                                                                                \\n            return 0;\\n        }\\n        if(currlane!=obstacles[pos+1]){\\n            return solve(obstacles,pos+1,currlane);\\n        }else{\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currlane!=i && obstacles[pos]!=i)\\n                ans=min(ans,1+solve(obstacles,pos+1,i));\\n            }\\n            return ans;\\n        }\\n    }\\n    int minSideJumps(vector<int>& obstacles) {  \\n        return solve(obstacles,0,2);\\n        \\n    }\\n```\\n\\n***2nd Approach : Recursion + Memoization (TOP Down approach )***\\n```\\nint solve(vector<int>& obstacles, int pos,int currlane,vector<vector<int>>& dp){\\n        if(pos==obstacles.size()-1){                                                                                                \\n            return 0;\\n        }\\n        if(dp[currlane][pos]!=-1) return dp[currlane][pos];\\n        if(currlane!=obstacles[pos+1]){\\n            return solve(obstacles,pos+1,currlane,dp);\\n        }else{\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currlane!=i && obstacles[pos]!=i)\\n                ans=min(ans,1+solve(obstacles,pos+1,i,dp));\\n            }\\n            return dp[currlane][pos]=ans;\\n        }\\n    }\\n    int minSideJumps(vector<int>& obstacles) {  \\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return solve(obstacles,0,2,dp);\\n        \\n    }\\n```\\n***3rd Approach : dp (Bottom up  approach )***\\n```\\nint minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size()-1;\\n        vector<vector<int> > dp(4,vector<int>(obstacles.size(),1e9));\\n        \\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n        for(int currpos=n-1;currpos>=0;currpos--){\\n            for(int currlane=1;currlane<=3;currlane++){\\n                if(currlane!=obstacles[currpos+1]){\\n                    dp[currlane][currpos]=dp[currlane][currpos+1];\\n                }else{\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(currlane!=i && obstacles[currpos]!=i)\\n                         ans=min(ans,1+dp[i][currpos+1]);\\n                    }\\n                    dp[currlane][currpos]=ans;\\n                }\\n            }\\n        }\\n        return min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n    }\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n**CLICK HERE AND SUBSCRIBE PLEASE (\\uD83D\\uDE42)->** [[CLCK HERE](https://www.youtube.com/channel/UCus2cmS0yQHmoszCRt9JeRQ)]",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solve(vector<int>& obstacles, int pos,int currlane){\\n        if(pos==obstacles.size()-1){                                                                                                \\n            return 0;\\n        }\\n        if(currlane!=obstacles[pos+1]){\\n            return solve(obstacles,pos+1,currlane);\\n        }else{\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currlane!=i && obstacles[pos]!=i)\\n                ans=min(ans,1+solve(obstacles,pos+1,i));\\n            }\\n            return ans;\\n        }\\n    }\\n    int minSideJumps(vector<int>& obstacles) {  \\n        return solve(obstacles,0,2);\\n        \\n    }\\n```\n```\\nint solve(vector<int>& obstacles, int pos,int currlane,vector<vector<int>>& dp){\\n        if(pos==obstacles.size()-1){                                                                                                \\n            return 0;\\n        }\\n        if(dp[currlane][pos]!=-1) return dp[currlane][pos];\\n        if(currlane!=obstacles[pos+1]){\\n            return solve(obstacles,pos+1,currlane,dp);\\n        }else{\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currlane!=i && obstacles[pos]!=i)\\n                ans=min(ans,1+solve(obstacles,pos+1,i,dp));\\n            }\\n            return dp[currlane][pos]=ans;\\n        }\\n    }\\n    int minSideJumps(vector<int>& obstacles) {  \\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return solve(obstacles,0,2,dp);\\n        \\n    }\\n```\n```\\nint minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size()-1;\\n        vector<vector<int> > dp(4,vector<int>(obstacles.size(),1e9));\\n        \\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n        for(int currpos=n-1;currpos>=0;currpos--){\\n            for(int currlane=1;currlane<=3;currlane++){\\n                if(currlane!=obstacles[currpos+1]){\\n                    dp[currlane][currpos]=dp[currlane][currpos+1];\\n                }else{\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(currlane!=i && obstacles[currpos]!=i)\\n                         ans=min(ans,1+dp[i][currpos+1]);\\n                    }\\n                    dp[currlane][currpos]=ans;\\n                }\\n            }\\n        }\\n        return min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258473,
                "title": "c-dp-tabulation-time-complexity-o-n",
                "content": "```\\n int minSideJumps(vector<int>& obstacles) {\\n        \\n        int i,j,n=obstacles.size();\\n        int dp[n][4],mini=INT_MAX;\\n        dp[0][1] = INT_MIN;\\n        dp[0][2] = 0;\\n        dp[0][3] = INT_MIN;\\n        for(i=1;i<n;i++)\\n        {\\n            for(j=1;j<=3;j++)\\n            {\\n                if(j==obstacles[i])\\n                {\\n                    dp[i][j] = INT_MIN;\\n                    continue;\\n                }\\n                dp[i][j] = INT_MAX;\\n                if(j==1)\\n                {\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][1]);\\n                    }\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        if(2!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                        if(1!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        if(3!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                        if(1!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                 if(j==2)\\n                {\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][2]);\\n                    }\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        if(1!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                        if(2!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        if(3!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                        if(2!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                 if(j==3)\\n                {\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][3]);\\n                    }\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        if(2!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                        if(3!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        if(1!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                        if(3!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                \\n                \\n            }\\n        }\\n        for(i=1;i<=3;i++)\\n        {\\n            if(dp[n-1][i]>=0)\\n            {\\n                mini = min(mini,dp[n-1][i]);\\n            }\\n        }\\n      \\n        return mini;",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n int minSideJumps(vector<int>& obstacles) {\\n        \\n        int i,j,n=obstacles.size();\\n        int dp[n][4],mini=INT_MAX;\\n        dp[0][1] = INT_MIN;\\n        dp[0][2] = 0;\\n        dp[0][3] = INT_MIN;\\n        for(i=1;i<n;i++)\\n        {\\n            for(j=1;j<=3;j++)\\n            {\\n                if(j==obstacles[i])\\n                {\\n                    dp[i][j] = INT_MIN;\\n                    continue;\\n                }\\n                dp[i][j] = INT_MAX;\\n                if(j==1)\\n                {\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][1]);\\n                    }\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        if(2!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                        if(1!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        if(3!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                        if(1!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                 if(j==2)\\n                {\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][2]);\\n                    }\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        if(1!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                        if(2!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        if(3!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                        if(2!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][3]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                 if(j==3)\\n                {\\n                    if(dp[i-1][3]>=0)\\n                    {\\n                        dp[i][j] = min(dp[i][j],dp[i-1][3]);\\n                    }\\n                    if(dp[i-1][2]>=0)\\n                    {\\n                        if(2!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                        if(3!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][2]+1);\\n                        }\\n                    }\\n                    if(dp[i-1][1]>=0)\\n                    {\\n                        if(1!=obstacles[i])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                        if(3!=obstacles[i-1])\\n                        {\\n                            dp[i][j] = min(dp[i][j],dp[i-1][1]+1);\\n                        }\\n                    }\\n                    continue;\\n                }\\n                \\n                \\n            }\\n        }\\n        for(i=1;i<=3;i++)\\n        {\\n            if(dp[n-1][i]>=0)\\n            {\\n                mini = min(mini,dp[n-1][i]);\\n            }\\n        }\\n      \\n        return mini;",
                "codeTag": "Unknown"
            },
            {
                "id": 2096522,
                "title": "python-100-speed-simplest-dp",
                "content": "The key idea is to remember the last lanes we can stay, remove the facing obstacle, and jump to the avaliable lanes with added steps (Ok, maybe rename it with jump would be a little better) when no more past lanes. \\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # solution 1\\n        n = len(obstacles)\\n        step = 0\\n        lanes = {2}\\n        pre_lanes = {i: {not_i for not_i in range(1,4) if not_i != i} for i in range(1, 4)}\\n        for i in range(1, n):\\n            lanes -= {obstacles[i]}\\n            if not len(lanes):\\n                step += 1\\n                lanes = pre_lanes[obstacles[i]] - {obstacles[i-1]}\\n        return step\\n                \\n```\\n![image](https://assets.leetcode.com/users/images/4ccde6a8-00e4-4fd2-a4fa-bc0cf9eab17f_1654055140.292658.png)\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # solution 1\\n        n = len(obstacles)\\n        step = 0\\n        lanes = {2}\\n        pre_lanes = {i: {not_i for not_i in range(1,4) if not_i != i} for i in range(1, 4)}\\n        for i in range(1, n):\\n            lanes -= {obstacles[i]}\\n            if not len(lanes):\\n                step += 1\\n                lanes = pre_lanes[obstacles[i]] - {obstacles[i-1]}\\n        return step\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069904,
                "title": "c-greedy-bit-manipulation-creative-time-o-n-space-o-1-90-81-86-88",
                "content": "### Why greedy method works?\\nLook at example 3:\\nAt index 0, frog can **side jump** to lane 1 or lane 3. \\nFor the case **side jump**  to lane 1, frog  need to go back to lane 3 at index 1 because of  obstacles[2].\\n\\nWe can find that **two cases have *the same status* at index 1**, but the case side jump to lane 1 costs **two** side jump.\\nSo, we can claim the case jump to lane 1 **will never be better than** another case, in any situation.\\n![image](https://assets.leetcode.com/users/images/2184a8a0-3bcd-479c-bb7e-9588e60368c6_1653395982.937031.png)\\n\\n\\n\\n### But ... How to keep track of two cases? \\n### The answer is Quantum Frogs!!\\n\\n1. When frog side jump, frog **split**.\\n2. We can use **3 bits** ( lane1 to lane3 ) to record if the quantum frog alive in that lane.\\n3. When quantum frog meet obstacles, it dies.\\n4. When all quantum frogs die, means a side jump. \\nAnd quantum frogs appear in other two lanes, excepting obstacle exist at this index.\\n![image](https://assets.leetcode.com/users/images/1020876b-366b-4543-a9cd-d755ec4757b6_1653399540.528078.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int cnt = 0;\\n        // 3 bits status\\n        // 000\\n        // 001\\n        // 010\\n        // 011\\n        // 100\\n        // 101\\n        // 110\\n        // 111\\n        // turn left 90\\'\\n        int status = 2;\\n        for(int i = 0; i < obstacles.size()-1; i++){\\n            if(obstacles[i+1] == 2 && (status & (1<<1)) ){\\n                status -= 2;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 5;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n            else if(obstacles[i+1] == 3 && (status & (1<<2)) ){\\n                status -= 4;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 3;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n            else if(obstacles[i+1] == 1 && (status & 1) ){\\n                status -= 1;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 6;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n```\\nRuntime: 327 ms, faster than 90.81% of C++ online submissions for Minimum Sideway Jumps.\\nMemory Usage: 188 MB, less than 86.88% of C++ online submissions for Minimum Sideway Jumps.\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int cnt = 0;\\n        // 3 bits status\\n        // 000\\n        // 001\\n        // 010\\n        // 011\\n        // 100\\n        // 101\\n        // 110\\n        // 111\\n        // turn left 90\\'\\n        int status = 2;\\n        for(int i = 0; i < obstacles.size()-1; i++){\\n            if(obstacles[i+1] == 2 && (status & (1<<1)) ){\\n                status -= 2;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 5;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n            else if(obstacles[i+1] == 3 && (status & (1<<2)) ){\\n                status -= 4;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 3;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n            else if(obstacles[i+1] == 1 && (status & 1) ){\\n                status -= 1;\\n                if(status == 0){\\n                    cnt++;\\n                    status = 6;\\n                    // has obstacle on i\\n                    if(obstacles[i] > 0){\\n                        status -= (1<<(obstacles[i]-1));\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nRuntime: 327 ms, faster than 90.81% of C++ online submissions for Minimum Sideway Jumps.\\nMemory Usage: 188 MB, less than 86.88% of C++ online submissions for Minimum Sideway Jumps.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584262,
                "title": "java-clean-and-concise-dp-tabulation-solution-o-3-n",
                "content": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        int[][] dp = new int[4][n];\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = 1; j <= 3; j++){\\n                dp[j][i] = dp[j][i+1];\\n                if(obstacles[i] == j)\\n                    dp[j][i] = Integer.MAX_VALUE;\\n            }\\n            int j = obstacles[i+1];\\n            dp[j][i] = Math.min(dp[1][i], Math.min(dp[2][i], dp[3][i])) + 1;\\n        }\\n        \\n        return dp[2][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        int[][] dp = new int[4][n];\\n        for(int i = n - 2; i >= 0; i--){\\n            for(int j = 1; j <= 3; j++){\\n                dp[j][i] = dp[j][i+1];\\n                if(obstacles[i] == j)\\n                    dp[j][i] = Integer.MAX_VALUE;\\n            }\\n            int j = obstacles[i+1];\\n            dp[j][i] = Math.min(dp[1][i], Math.min(dp[2][i], dp[3][i])) + 1;\\n        }\\n        \\n        return dp[2][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449150,
                "title": "c-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<int> dp = {INT_MAX,1,0,1};\\n        for(int ob : obstacles) {\\n            dp[ob] = INT_MAX;\\n            int minJumps = *min_element(dp.begin(), dp.end());\\n            for(int i = 1; i < 4; ++i) {\\n                if(ob == i) continue;\\n                dp[i] = min(minJumps+1, dp[i]);\\n            }\\n        }\\n        return *min_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<int> dp = {INT_MAX,1,0,1};\\n        for(int ob : obstacles) {\\n            dp[ob] = INT_MAX;\\n            int minJumps = *min_element(dp.begin(), dp.end());\\n            for(int i = 1; i < 4; ++i) {\\n                if(ob == i) continue;\\n                dp[i] = min(minJumps+1, dp[i]);\\n            }\\n        }\\n        return *min_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355888,
                "title": "c-short-and-crisp-explanation-similar-to-frog-jump-1",
                "content": "-------1--------\\nf  --2---------2--\\n   ------3---------\\n   \\n   Frog is intially in second lane so just keep in mind that we have to go from point 0 to point N and whenever we see an obstacle at current position so we change our lane where there is no obstacle at current point.\\n   \\n  So here only two states are changing --> position of the frog and Lane of the frog\\n  These states becomes our dp states which makes this problem exactly similar to Frog jump1\\n  \\n  ```\\n  class Solution {\\npublic:\\n    vector<int>lanes={1,2,3};\\n    \\n    int last_pos;\\n    vector<vector<int>>dp;\\n    int rec(int pos, int lane,vector<int>&obstacles){\\n        if(pos==last_pos) return 0;\\n        if(dp[pos][lane]!=-1) return dp[pos][lane];\\n        if(obstacles[pos]==lane){\\n            return INT_MAX;\\n        }\\n        \\n        if(obstacles[pos+1]!=lane){\\n            dp[pos][lane]=rec(pos+1,lane,obstacles);\\n        }\\n        else{\\n           int ans=INT_MAX;\\n            for(int i=0;i<=2;i++){\\n                if(lane!=lanes[i]){\\n                    ans=min(rec(pos,lanes[i],obstacles),ans);\\n                }\\n            }\\n          dp[pos][lane]=1+ans;  \\n        }\\n           \\n          \\n        \\n        \\n        return dp[pos][lane];\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        last_pos=obstacles.size()-1;\\n        dp.resize(obstacles.size(),vector<int>(4,-1));\\n        return rec(0,2,obstacles);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n  class Solution {\\npublic:\\n    vector<int>lanes={1,2,3};\\n    \\n    int last_pos;\\n    vector<vector<int>>dp;\\n    int rec(int pos, int lane,vector<int>&obstacles){\\n        if(pos==last_pos) return 0;\\n        if(dp[pos][lane]!=-1) return dp[pos][lane];\\n        if(obstacles[pos]==lane){\\n            return INT_MAX;\\n        }\\n        \\n        if(obstacles[pos+1]!=lane){\\n            dp[pos][lane]=rec(pos+1,lane,obstacles);\\n        }\\n        else{\\n           int ans=INT_MAX;\\n            for(int i=0;i<=2;i++){\\n                if(lane!=lanes[i]){\\n                    ans=min(rec(pos,lanes[i],obstacles),ans);\\n                }\\n            }\\n          dp[pos][lane]=1+ans;  \\n        }\\n           \\n          \\n        \\n        \\n        return dp[pos][lane];\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        last_pos=obstacles.size()-1;\\n        dp.resize(obstacles.size(),vector<int>(4,-1));\\n        return rec(0,2,obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242581,
                "title": "c-dp-solution-explained-most-efficient",
                "content": "We Initialize the DP with INFINITY.\\nIf there is obstackle on previous index or there is obstacle on current index , thn we cannot reach that index so we will assign INFINITY to it,\\notherwise we will assignt the mininum value from (considering that lane to reach the end, changing the lane)\\n\\n```\\nclass Solution {\\npublic:\\n     int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp (n, vector<int>(3, 99999999));\\n        dp[0][1] = 0;\\n        dp[0][0] = dp[0][2] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int k = 0; k < 3; k++) {\\n                if (obstacles[i - 1] == (k + 1) || obstacles[i] == (k + 1)) {\\n                    dp[i][k] = 99999999;\\n                } else {\\n                    int a_lane = (k + 1) % 3;\\n                    int b_lane = (k + 2) % 3;\\n                    dp[i][k] = min(dp[i - 1][k], min(dp[i - 1][a_lane], dp[i - 1][b_lane]) + 1);\\n                }\\n            }\\n        }\\n        \\n        return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));\\n    }\\n};\\n```\\n\\nDo Upvote!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp (n, vector<int>(3, 99999999));\\n        dp[0][1] = 0;\\n        dp[0][0] = dp[0][2] = 1;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int k = 0; k < 3; k++) {\\n                if (obstacles[i - 1] == (k + 1) || obstacles[i] == (k + 1)) {\\n                    dp[i][k] = 99999999;\\n                } else {\\n                    int a_lane = (k + 1) % 3;\\n                    int b_lane = (k + 2) % 3;\\n                    dp[i][k] = min(dp[i - 1][k], min(dp[i - 1][a_lane], dp[i - 1][b_lane]) + 1);\\n                }\\n            }\\n        }\\n        \\n        return min(dp[n-1][0], min(dp[n-1][1], dp[n-1][2]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193555,
                "title": "python-dp-solution",
                "content": "The idea is quite simple. Given initial position, we update each column of the dp with the shortest path, which is either shortest path from the same column +1 or from the previous position. The stones are weighted with a barrier, big number, which indicates that it needs inf many steps to get into that position.\\n\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        barrier = float(\\'inf\\')\\n        \\n        dp = [[0]*len(obstacles) for i in range(3)]\\n        \\n        if len(obstacles) < 3:\\n            return 0\\n        \\n        dp[0][0] = 1\\n        dp[1][0] = 0\\n        dp[2][0] = 1\\n        \\n        for i in range(1,len(obstacles)):\\n            if obstacles[i]>0:\\n                dp[obstacles[i]-1][i] = barrier \\n\\n            dp[0][i] = max(dp[0][i], min(dp[0][i-1], max(dp[1][i],dp[1][i-1]+1), max(dp[2][i],dp[2][i-1]+1)))\\n            dp[1][i] = max(dp[1][i], min(dp[1][i-1], max(dp[0][i],dp[0][i-1]+1), max(dp[2][i],dp[2][i-1]+1)))\\n            dp[2][i] = max(dp[2][i], min(dp[2][i-1], max(dp[0][i],dp[0][i-1]+1), max(dp[1][i],dp[1][i-1]+1)))\\n\\n                    \\n        return min([dp[i][-1] for i in range(3)])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        barrier = float(\\'inf\\')\\n        \\n        dp = [[0]*len(obstacles) for i in range(3)]\\n        \\n        if len(obstacles) < 3:\\n            return 0\\n        \\n        dp[0][0] = 1\\n        dp[1][0] = 0\\n        dp[2][0] = 1\\n        \\n        for i in range(1,len(obstacles)):\\n            if obstacles[i]>0:\\n                dp[obstacles[i]-1][i] = barrier \\n\\n            dp[0][i] = max(dp[0][i], min(dp[0][i-1], max(dp[1][i],dp[1][i-1]+1), max(dp[2][i],dp[2][i-1]+1)))\\n            dp[1][i] = max(dp[1][i], min(dp[1][i-1], max(dp[0][i],dp[0][i-1]+1), max(dp[2][i],dp[2][i-1]+1)))\\n            dp[2][i] = max(dp[2][i], min(dp[2][i-1], max(dp[0][i],dp[0][i-1]+1), max(dp[1][i],dp[1][i-1]+1)))\\n\\n                    \\n        return min([dp[i][-1] for i in range(3)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153526,
                "title": "c-memoization-faster-than-100",
                "content": "```\\nclass Solution {\\n    int dp[4][500001];\\npublic:\\n   int solve(vector<int>& obs,int currLane,int i){\\n        if(i==obs.size()-1) return 0;\\n        if(currLane == obs[i]) return 1e6;\\n        if(dp[currLane][i]!=-1) return dp[currLane][i];\\n       \\n        if(obs[i+1] == currLane)\\n             return dp[currLane][i]= 1+min(solve(obs,((currLane+1)%3 == 0)?3:(currLane+1)%3,i),solve(obs,((currLane+2)%3 == 0)?3:(currLane+2)%3,i));\\n        else \\n            return dp[currLane][i]=solve(obs,currLane,i+1);\\n             \\n    }\\n    \\n    int minSideJumps(vector<int>& obs) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obs,2,0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[4][500001];\\npublic:\\n   int solve(vector<int>& obs,int currLane,int i){\\n        if(i==obs.size()-1) return 0;\\n        if(currLane == obs[i]) return 1e6;\\n        if(dp[currLane][i]!=-1) return dp[currLane][i];\\n       \\n        if(obs[i+1] == currLane)\\n             return dp[currLane][i]= 1+min(solve(obs,((currLane+1)%3 == 0)?3:(currLane+1)%3,i),solve(obs,((currLane+2)%3 == 0)?3:(currLane+2)%3,i));\\n        else \\n            return dp[currLane][i]=solve(obs,currLane,i+1);\\n             \\n    }\\n    \\n    int minSideJumps(vector<int>& obs) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obs,2,0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152647,
                "title": "clean-java-solution-recursion-with-caching",
                "content": "```\\nInteger[][] cache;\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        cache = new Integer[4][obstacles.length+1];\\n        return recurs(2, obstacles, 0);\\n    }\\n    \\n     private int recurs(int lane, int[] obs, int i) {\\n\\t        \\n        if(i+1 == obs.length-1) return 0;\\n\\n        if(cache[lane][i] != null) return cache[lane][i];\\n\\n        int val1 = Integer.MAX_VALUE, val2 = Integer.MAX_VALUE, val3 = Integer.MAX_VALUE, val4 = Integer.MAX_VALUE;\\n\\n        if(i+1 < obs.length && obs[i+1] == lane) {\\n\\n            if(lane-1 > 0 && obs[i] != lane-1) val1 = recurs(lane-1, obs, i+1);\\n            if(lane-2 > 0 && obs[i] != lane-2) val2 = recurs(lane-2, obs, i+1);\\n            if(lane+1 <= 3 && obs[i] != lane+1) val3 = recurs(lane+1, obs, i+1);\\n            if(lane+2 <= 3 && obs[i] != lane+2) val4 = recurs(lane+2, obs, i+1);\\n\\n            cache[lane][i] = 1 + Math.min(Math.min(Math.min(val1, val2), val3), val4);\\n\\n        } else {\\n\\n            cache[lane][i] = recurs(lane, obs, i+1);\\n\\n        }\\n         \\n        return cache[lane][i];\\n\\t        \\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nInteger[][] cache;\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        cache = new Integer[4][obstacles.length+1];\\n        return recurs(2, obstacles, 0);\\n    }\\n    \\n     private int recurs(int lane, int[] obs, int i) {\\n\\t        \\n        if(i+1 == obs.length-1) return 0;\\n\\n        if(cache[lane][i] != null) return cache[lane][i];\\n\\n        int val1 = Integer.MAX_VALUE, val2 = Integer.MAX_VALUE, val3 = Integer.MAX_VALUE, val4 = Integer.MAX_VALUE;\\n\\n        if(i+1 < obs.length && obs[i+1] == lane) {\\n\\n            if(lane-1 > 0 && obs[i] != lane-1) val1 = recurs(lane-1, obs, i+1);\\n            if(lane-2 > 0 && obs[i] != lane-2) val2 = recurs(lane-2, obs, i+1);\\n            if(lane+1 <= 3 && obs[i] != lane+1) val3 = recurs(lane+1, obs, i+1);\\n            if(lane+2 <= 3 && obs[i] != lane+2) val4 = recurs(lane+2, obs, i+1);\\n\\n            cache[lane][i] = 1 + Math.min(Math.min(Math.min(val1, val2), val3), val4);\\n\\n        } else {\\n\\n            cache[lane][i] = recurs(lane, obs, i+1);\\n\\n        }\\n         \\n        return cache[lane][i];\\n\\t        \\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1152603,
                "title": "java-bfs-solution",
                "content": "The time complexity should be O(N). Correct me if I\\'m wrong.\\n```\\nclass Solution {\\n    class Node {\\n        int i;\\n        int j;\\n        int step;\\n        \\n        public Node(int i, int j, int step) {\\n            this.i = i;\\n            this.j = j;\\n            this.step = step;\\n        }\\n    }\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int N = obstacles.length;\\n        boolean visited[][] = new boolean[3][N];\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(1, 0, 0));\\n        visited[1][0] = true;\\n        \\n        while(!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            \\n            if(curr.j == N - 1) {\\n                return curr.step;\\n            }\\n            \\n            if(curr.i != obstacles[curr.j + 1] - 1 && !visited[curr.i][curr.j + 1]) {\\n                // jump forward\\n                visited[curr.i][curr.j + 1] = true;\\n                queue.add(new Node(curr.i, curr.j+1, curr.step));\\n            }\\n            \\n            int rowAfterJump = (curr.i + 1) % 3;\\n            if(rowAfterJump != obstacles[curr.j] - 1 && !visited[rowAfterJump][curr.j]) {\\n                // jump to next lane\\n                visited[rowAfterJump][curr.j] = true;\\n                queue.add(new Node(rowAfterJump, curr.j, curr.step + 1));\\n            }\\n            \\n            rowAfterJump = (curr.i + 2) % 3;\\n            if(rowAfterJump != obstacles[curr.j] - 1 && !visited[rowAfterJump][curr.j]) {\\n                // jump to next next lane\\n                visited[rowAfterJump][curr.j] = true;\\n                queue.add(new Node(rowAfterJump, curr.j, curr.step + 1));\\n            }\\n        }\\n        \\n         return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Node {\\n        int i;\\n        int j;\\n        int step;\\n        \\n        public Node(int i, int j, int step) {\\n            this.i = i;\\n            this.j = j;\\n            this.step = step;\\n        }\\n    }\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int N = obstacles.length;\\n        boolean visited[][] = new boolean[3][N];\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(1, 0, 0));\\n        visited[1][0] = true;\\n        \\n        while(!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            \\n            if(curr.j == N - 1) {\\n                return curr.step;\\n            }\\n            \\n            if(curr.i != obstacles[curr.j + 1] - 1 && !visited[curr.i][curr.j + 1]) {\\n                // jump forward\\n                visited[curr.i][curr.j + 1] = true;\\n                queue.add(new Node(curr.i, curr.j+1, curr.step));\\n            }\\n            \\n            int rowAfterJump = (curr.i + 1) % 3;\\n            if(rowAfterJump != obstacles[curr.j] - 1 && !visited[rowAfterJump][curr.j]) {\\n                // jump to next lane\\n                visited[rowAfterJump][curr.j] = true;\\n                queue.add(new Node(rowAfterJump, curr.j, curr.step + 1));\\n            }\\n            \\n            rowAfterJump = (curr.i + 2) % 3;\\n            if(rowAfterJump != obstacles[curr.j] - 1 && !visited[rowAfterJump][curr.j]) {\\n                // jump to next next lane\\n                visited[rowAfterJump][curr.j] = true;\\n                queue.add(new Node(rowAfterJump, curr.j, curr.step + 1));\\n            }\\n        }\\n        \\n         return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152546,
                "title": "python3-dp",
                "content": "\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        ans = [0]*3 \\n        for i in reversed(range(len(obstacles) - 1)): \\n            tmp = [inf]*3\\n            for k in range(3):\\n                if obstacles[i]-1 != k: \\n                    tmp[k] = ans[k]\\n                    if obstacles[i]-1 != (k+1)%3: tmp[k] = min(tmp[k], 1 + ans[(k+1)%3])\\n                    if obstacles[i]-1 != (k+2)%3: tmp[k] = min(tmp[k], 1 + ans[(k+2)%3])\\n            ans = tmp\\n        return ans[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        ans = [0]*3 \\n        for i in reversed(range(len(obstacles) - 1)): \\n            tmp = [inf]*3\\n            for k in range(3):\\n                if obstacles[i]-1 != k: \\n                    tmp[k] = ans[k]\\n                    if obstacles[i]-1 != (k+1)%3: tmp[k] = min(tmp[k], 1 + ans[(k+1)%3])\\n                    if obstacles[i]-1 != (k+2)%3: tmp[k] = min(tmp[k], 1 + ans[(k+2)%3])\\n            ans = tmp\\n        return ans[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152512,
                "title": "c-o-n-space-time-dynamic-programming",
                "content": "In this approach we will solve this problem by dynamic programming\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&dp,int pos,int i,int n,vector<int>&arr){\\n        if(arr[i]==pos)return INT_MAX;\\n        \\n        //when we reach finale position then we return 0 value\\n        if(i+1==n)return 0;\\n        if(dp[pos][i]!=1e6)return dp[pos][i];\\n        \\n        //if in next index there is a obstacles on current position then we will change our direction\\n        if(pos==arr[i+1]){\\n            int x=(pos+1)%3;\\n            int y=(pos+2)%3;\\n            if(x==0)x=3;\\n            if(y==0)y=3;\\n            //we will check in both position for getting minimum side jump\\n            dp[pos][i]= 1+min(f(dp,x,i,n,arr),f(dp,y,i,n,arr));\\n        }\\n        else dp[pos][i]=f(dp,pos,i+1,n,arr); //if there is no obstacles then we will go further\\n        return dp[pos][i];\\n    }\\n    int minSideJumps(vector<int>& arr) {\\n        vector<vector<int>>dp(4,vector<int>(arr.size()+2,1e6));\\n        return f(dp,2,0,arr.size(),arr);\\n    }\\n};\\n```\\nIf you like this solution then pls upvote :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&dp,int pos,int i,int n,vector<int>&arr){\\n        if(arr[i]==pos)return INT_MAX;\\n        \\n        //when we reach finale position then we return 0 value\\n        if(i+1==n)return 0;\\n        if(dp[pos][i]!=1e6)return dp[pos][i];\\n        \\n        //if in next index there is a obstacles on current position then we will change our direction\\n        if(pos==arr[i+1]){\\n            int x=(pos+1)%3;\\n            int y=(pos+2)%3;\\n            if(x==0)x=3;\\n            if(y==0)y=3;\\n            //we will check in both position for getting minimum side jump\\n            dp[pos][i]= 1+min(f(dp,x,i,n,arr),f(dp,y,i,n,arr));\\n        }\\n        else dp[pos][i]=f(dp,pos,i+1,n,arr); //if there is no obstacles then we will go further\\n        return dp[pos][i];\\n    }\\n    int minSideJumps(vector<int>& arr) {\\n        vector<vector<int>>dp(4,vector<int>(arr.size()+2,1e6));\\n        return f(dp,2,0,arr.size(),arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152448,
                "title": "java-simple-recursion-with-memoization",
                "content": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int res = 0;\\n        int n = obstacles.length - 1;\\n        int curLane = 2;\\n        \\n       Map<String, Integer> map = new HashMap<>();\\n        return findMinDistance(0, 2, obstacles, n, map);\\n    }\\n    \\n    private int findMinDistance(int pos, int curLane, int[] obstacles, int n, Map<String, Integer> map) {\\n        \\n        if(map.containsKey(pos + \"_\" + curLane)) {\\n            return map.get(pos + \"_\" + curLane);\\n        }\\n        int curPos = pos;\\n        while(pos < n && obstacles[pos+1] != curLane) {\\n            pos++;\\n        }\\n        \\n        if(pos == n) {\\n            return 0;\\n        }\\n        \\n        if(obstacles[pos] == 0) {\\n\\t\\t// multiple options available : choose min of both possible lanes where we can choose to go\\n            if(curLane == 1) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 2, obstacles, n, map), findMinDistance(pos+1, 3, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 2) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 1, obstacles, n, map), findMinDistance(pos+1, 3, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 1, obstacles, n, map), findMinDistance(pos+1, 2, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 1) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 2) {\\n                int res = 1 + findMinDistance(pos+1, 3, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + findMinDistance(pos+1, 2, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 2) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 1) {\\n                int res = 1 + findMinDistance(pos+1, 3, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + findMinDistance(pos+1, 1, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 3) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 2) {\\n                int res = 1 + findMinDistance(pos+1, 1, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 1) {\\n                int res = 1 + findMinDistance(pos+1, 2, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException(\"shouldn\\'t have reached here!!\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int res = 0;\\n        int n = obstacles.length - 1;\\n        int curLane = 2;\\n        \\n       Map<String, Integer> map = new HashMap<>();\\n        return findMinDistance(0, 2, obstacles, n, map);\\n    }\\n    \\n    private int findMinDistance(int pos, int curLane, int[] obstacles, int n, Map<String, Integer> map) {\\n        \\n        if(map.containsKey(pos + \"_\" + curLane)) {\\n            return map.get(pos + \"_\" + curLane);\\n        }\\n        int curPos = pos;\\n        while(pos < n && obstacles[pos+1] != curLane) {\\n            pos++;\\n        }\\n        \\n        if(pos == n) {\\n            return 0;\\n        }\\n        \\n        if(obstacles[pos] == 0) {\\n\\t\\t// multiple options available : choose min of both possible lanes where we can choose to go\\n            if(curLane == 1) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 2, obstacles, n, map), findMinDistance(pos+1, 3, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 2) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 1, obstacles, n, map), findMinDistance(pos+1, 3, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + Math.min(findMinDistance(pos+1, 1, obstacles, n, map), findMinDistance(pos+1, 2, obstacles, n, map));\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 1) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 2) {\\n                int res = 1 + findMinDistance(pos+1, 3, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + findMinDistance(pos+1, 2, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 2) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 1) {\\n                int res = 1 + findMinDistance(pos+1, 3, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 3) {\\n                int res = 1 + findMinDistance(pos+1, 1, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        } else if(obstacles[pos] == 3) {\\n\\t\\t// go to the only posssible lane\\n            if(curLane == 2) {\\n                int res = 1 + findMinDistance(pos+1, 1, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            } else if (curLane == 1) {\\n                int res = 1 + findMinDistance(pos+1, 2, obstacles, n, map);\\n                map.put(curPos + \"_\" + curLane, res);\\n                return res;\\n            }\\n        }\\n        \\n        throw new IllegalArgumentException(\"shouldn\\'t have reached here!!\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152414,
                "title": "js-easy-o-n-time-o-1-space-dp-solution-with-explanations",
                "content": "We look at the previous point (or column/index) and determine what our current point\\'s best solution is. At any lane, if no obstacle, we can go either up, down, or forward.\\n\\nSo if previous point has obstacle at `current lane 1`, we know it\\'s **impossible** to go from `previous lane 1` to any of the current lanes because we cannot go up/down/forward from an obstacle. Therefore, `current lane 1` will be impossible to reach. The only reachable points would be `lane2` and `lane3`.\\nSame goes for obstacles at 2 or 3. But if there is no obstacle at previous point, we can then update all three current lanes based on three previous lane\\n\\n```\\nvar minSideJumps = function(obstacles) {\\n    let m1 = 1;\\n    let m2 = 0;\\n    let m3 = 1;\\n    for (let i = 1; i < obstacles.length; i++) {\\n        const mm1 = m1;\\n        const mm2 = m2;\\n        const mm3 = m3;\\n        if (obstacles[i-1] == 1) {\\n            m1 = Infinity;\\n            m2 = Math.min(mm2, mm3+1);\\n            m3 = Math.min(mm3, mm2+1);\\n        } else if (obstacles[i-1] == 2) {\\n            m1 = Math.min(mm1, mm3+1);\\n            m2 = Infinity\\n            m3 = Math.min(mm3, mm1+1);\\n        } else if (obstacles[i-1] == 3) {\\n            m1 = Math.min(mm1, mm2+1);\\n            m2 = Math.min(mm2, mm1+1);\\n            m3 = Infinity\\n        } else {\\n            m1 = Math.min(mm1, mm2+1, mm3+1);\\n            m2 = Math.min(mm2, mm1+1, mm3+1);\\n            m3 = Math.min(mm3, mm1+1, mm2+1);\\n        }\\n    }\\n    return Math.min(m1,m2,m3);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minSideJumps = function(obstacles) {\\n    let m1 = 1;\\n    let m2 = 0;\\n    let m3 = 1;\\n    for (let i = 1; i < obstacles.length; i++) {\\n        const mm1 = m1;\\n        const mm2 = m2;\\n        const mm3 = m3;\\n        if (obstacles[i-1] == 1) {\\n            m1 = Infinity;\\n            m2 = Math.min(mm2, mm3+1);\\n            m3 = Math.min(mm3, mm2+1);\\n        } else if (obstacles[i-1] == 2) {\\n            m1 = Math.min(mm1, mm3+1);\\n            m2 = Infinity\\n            m3 = Math.min(mm3, mm1+1);\\n        } else if (obstacles[i-1] == 3) {\\n            m1 = Math.min(mm1, mm2+1);\\n            m2 = Math.min(mm2, mm1+1);\\n            m3 = Infinity\\n        } else {\\n            m1 = Math.min(mm1, mm2+1, mm3+1);\\n            m2 = Math.min(mm2, mm1+1, mm3+1);\\n            m3 = Math.min(mm3, mm1+1, mm2+1);\\n        }\\n    }\\n    return Math.min(m1,m2,m3);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877702,
                "title": "short-easy-and-clean-c-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int>dp1(n,n), dp2(n,n), dp3(n,n);\\n        dp1[0] = 1; dp2[0] = 0; dp3[0] = 1;\\n\\n        for(int i=1; i<n; i++){\\n            if(arr[i-1] != 1 && arr[i] != 1) dp1[i] = dp1[i-1];\\n            if(arr[i-1] != 2 && arr[i] != 2) dp2[i] = dp2[i-1];\\n            if(arr[i-1] != 3 && arr[i] != 3) dp3[i] = dp3[i-1];\\n\\n            dp1[i] = min({dp1[i], 1 + dp2[i], 1 + dp3[i]});\\n            dp2[i] = min({1 + dp1[i], dp2[i], 1 + dp3[i]});\\n            dp3[i] = min({1 + dp1[i], 1 + dp2[i], dp3[i]});\\n        }\\n\\n        return min({dp1[n-1],dp2[n-1],dp3[n-1]});\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        vector<int>dp1(n,n), dp2(n,n), dp3(n,n);\\n        dp1[0] = 1; dp2[0] = 0; dp3[0] = 1;\\n\\n        for(int i=1; i<n; i++){\\n            if(arr[i-1] != 1 && arr[i] != 1) dp1[i] = dp1[i-1];\\n            if(arr[i-1] != 2 && arr[i] != 2) dp2[i] = dp2[i-1];\\n            if(arr[i-1] != 3 && arr[i] != 3) dp3[i] = dp3[i-1];\\n\\n            dp1[i] = min({dp1[i], 1 + dp2[i], 1 + dp3[i]});\\n            dp2[i] = min({1 + dp1[i], dp2[i], 1 + dp3[i]});\\n            dp3[i] = min({1 + dp1[i], 1 + dp2[i], dp3[i]});\\n        }\\n\\n        return min({dp1[n-1],dp2[n-1],dp3[n-1]});\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476984,
                "title": "understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        // now there will be repeated calls so we will use dp , and for dp we have to figure\\n        // out no of unique calls ; so in this quesiton unique calls will be ; \\n        // no of Lane(3) * obstacles.length ; \\n\\n        int dp[][] = new int[4][obstacles.length+1] ; \\n\\n        for( int i = 0 ; i < dp.length ; i++)\\n        {\\n            for( int j = 0 ; j < dp[0].length ; j++)\\n            {\\n                dp[i][j] = -1 ; \\n            }\\n        }\\n        return answer(2 , 0 , obstacles , dp ) ;\\n    }\\n    public int answer ( int currentLane , int index , int obstacles[], int dp[][])\\n    {\\n        if( index == obstacles.length-1)\\n        {\\n            return 0 ;  // because no side jump required ; \\n        }\\n\\n        if( dp[currentLane][index] != -1 )\\n        return dp[currentLane][index] ;\\n\\n           \\n           int count = 0 ; \\n        if( obstacles[index+1] == currentLane) // toh side jum karna padhega ; \\n        {\\n            \\n             if( currentLane == 1)\\n             { \\n                  \\n\\n                 int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 2 )\\n                   {\\n                       option1 = answer(2 , index , obstacles ,dp ) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 3 )\\n                   {\\n                       option2 = answer(3 , index , obstacles , dp) ; \\n                   }\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n\\n\\n             }\\n             else if( currentLane == 2)\\n             {\\n                   int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 1 )\\n                   {\\n                       option1 = answer(1 , index , obstacles , dp) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 3 )\\n                   {\\n                       option2 = answer(3 , index , obstacles , dp) ; \\n                   }\\n\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n             }\\n             else\\n             {\\n                   int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 2 )\\n                   {\\n                       option1 = answer(2 , index , obstacles , dp) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 1 )\\n                   {\\n                       option2 = answer(1 , index , obstacles , dp) ; \\n                   }\\n\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n             }\\n        }\\n        else\\n        {\\n            dp[currentLane][index] = answer(currentLane , index+1 , obstacles , dp) ;\\n             return dp[currentLane][index] ; \\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        \\n        // now there will be repeated calls so we will use dp , and for dp we have to figure\\n        // out no of unique calls ; so in this quesiton unique calls will be ; \\n        // no of Lane(3) * obstacles.length ; \\n\\n        int dp[][] = new int[4][obstacles.length+1] ; \\n\\n        for( int i = 0 ; i < dp.length ; i++)\\n        {\\n            for( int j = 0 ; j < dp[0].length ; j++)\\n            {\\n                dp[i][j] = -1 ; \\n            }\\n        }\\n        return answer(2 , 0 , obstacles , dp ) ;\\n    }\\n    public int answer ( int currentLane , int index , int obstacles[], int dp[][])\\n    {\\n        if( index == obstacles.length-1)\\n        {\\n            return 0 ;  // because no side jump required ; \\n        }\\n\\n        if( dp[currentLane][index] != -1 )\\n        return dp[currentLane][index] ;\\n\\n           \\n           int count = 0 ; \\n        if( obstacles[index+1] == currentLane) // toh side jum karna padhega ; \\n        {\\n            \\n             if( currentLane == 1)\\n             { \\n                  \\n\\n                 int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 2 )\\n                   {\\n                       option1 = answer(2 , index , obstacles ,dp ) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 3 )\\n                   {\\n                       option2 = answer(3 , index , obstacles , dp) ; \\n                   }\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n\\n\\n             }\\n             else if( currentLane == 2)\\n             {\\n                   int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 1 )\\n                   {\\n                       option1 = answer(1 , index , obstacles , dp) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 3 )\\n                   {\\n                       option2 = answer(3 , index , obstacles , dp) ; \\n                   }\\n\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n             }\\n             else\\n             {\\n                   int option1 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 2 )\\n                   {\\n                       option1 = answer(2 , index , obstacles , dp) ; \\n                   }\\n\\n                 int option2 = Integer.MAX_VALUE ; \\n                   \\n                   if(obstacles[index] != 1 )\\n                   {\\n                       option2 = answer(1 , index , obstacles , dp) ; \\n                   }\\n\\n\\n                   dp[currentLane][index] = Math.min(option1,option2) + 1 ; \\n                   return dp[currentLane][index] ; \\n             }\\n        }\\n        else\\n        {\\n            dp[currentLane][index] = answer(currentLane , index+1 , obstacles , dp) ;\\n             return dp[currentLane][index] ; \\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358523,
                "title": "memoized-dp-solution-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, vector<int> &obs, vector<vector<int>> &dp) {\\n        if(i == n - 1) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(obs[i + 1] != j) return dp[i][j] = dfs(i + 1, j, n, obs, dp);\\n        int up = 1e9, down = 1e9;\\n        for(int c=1; c<=2; c++) {\\n            up = min(up, (int)(j + c <= 3 && obs[i] != j + c ? 1 + dfs(i, j + c, n, obs, dp) : 1e9));\\n            down = min(down, (int)(j - c >= 1 && obs[i] != j - c ? 1 + dfs(i, j - c, n, obs, dp) : 1e9));\\n        }\\n        return dp[i][j] = min(up, down);\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n, vector<int>(4, -1));\\n        return dfs(0, 2, n, obstacles, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, vector<int> &obs, vector<vector<int>> &dp) {\\n        if(i == n - 1) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        if(obs[i + 1] != j) return dp[i][j] = dfs(i + 1, j, n, obs, dp);\\n        int up = 1e9, down = 1e9;\\n        for(int c=1; c<=2; c++) {\\n            up = min(up, (int)(j + c <= 3 && obs[i] != j + c ? 1 + dfs(i, j + c, n, obs, dp) : 1e9));\\n            down = min(down, (int)(j - c >= 1 && obs[i] != j - c ? 1 + dfs(i, j - c, n, obs, dp) : 1e9));\\n        }\\n        return dp[i][j] = min(up, down);\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n, vector<int>(4, -1));\\n        return dfs(0, 2, n, obstacles, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300296,
                "title": "c-solution-recursion-memorization-tabulation-dp-beats-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(4*n);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int>&obstacles,int lane,int pos,vector<vector<int>>&dp)\\n    {\\n        if(pos == n-1)\\n        return 0;\\n\\n        if(dp[lane][pos]!= -1)\\n            return dp[lane][pos];\\n\\n        if(obstacles[pos+1]!= lane)\\n            return solve(n,obstacles,lane,pos+1,dp);\\n        \\n        int ans =1e9;\\n\\n            for(int k = 1;k<=3;k++)\\n            {\\n                if(lane != k && obstacles[pos]!=k)\\n                {\\n                    ans = min(ans,1+solve(n,obstacles,k,pos,dp));\\n                }   \\n            }\\n            dp[lane][pos] = ans;\\n            return ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n    vector<vector<int>>dp(4,vector<int>(n,-1));\\n        return solve(n,obstacles,2,0,dp);\\n    }\\n};\\n```\\n\\n** Tabulation + Space Optimization ** \\n\\n**Time Complexity -> O(n)\\nSpace compllexity -> O(1)**\\n\\n\\n```\\nint minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        // vector<vector<int>>dp(4,vector<int>(n,1e9));\\n        vector<int>curr(4,1e9);\\n        vector<int>next(4,1e9);\\n\\n        next[0] = 0;\\n        next[1] = 0;\\n        next[2] = 0;\\n        next[3] = 0;\\n\\n        for(int pos = n-2;pos>=0;pos--)\\n        {\\n            for(int lane=1;lane<=3;lane++)\\n            {\\n                if(obstacles[pos+1]!= lane)\\n                    curr[lane] =  next[lane];\\n                else{\\n                    int ans =1e9;\\n                    for(int k = 1;k<=3;k++)\\n                    {\\n                        if(lane != k && obstacles[pos]!=k)\\n                        {\\n                            ans = min(ans,1+next[k]);\\n                        }   \\n                    }\\n                    curr[lane] = ans;\\n                }\\n            }\\n            next = curr;\\n        }\\n\\n        return min(curr[2],min(curr[1]+1,curr[3]+1));\\n    }\\n\\n```\\n\\n\\n\\n**Please vote me if you like the complete methods of dp**\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int>&obstacles,int lane,int pos,vector<vector<int>>&dp)\\n    {\\n        if(pos == n-1)\\n        return 0;\\n\\n        if(dp[lane][pos]!= -1)\\n            return dp[lane][pos];\\n\\n        if(obstacles[pos+1]!= lane)\\n            return solve(n,obstacles,lane,pos+1,dp);\\n        \\n        int ans =1e9;\\n\\n            for(int k = 1;k<=3;k++)\\n            {\\n                if(lane != k && obstacles[pos]!=k)\\n                {\\n                    ans = min(ans,1+solve(n,obstacles,k,pos,dp));\\n                }   \\n            }\\n            dp[lane][pos] = ans;\\n            return ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n    vector<vector<int>>dp(4,vector<int>(n,-1));\\n        return solve(n,obstacles,2,0,dp);\\n    }\\n};\\n```\n```\\nint minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        // vector<vector<int>>dp(4,vector<int>(n,1e9));\\n        vector<int>curr(4,1e9);\\n        vector<int>next(4,1e9);\\n\\n        next[0] = 0;\\n        next[1] = 0;\\n        next[2] = 0;\\n        next[3] = 0;\\n\\n        for(int pos = n-2;pos>=0;pos--)\\n        {\\n            for(int lane=1;lane<=3;lane++)\\n            {\\n                if(obstacles[pos+1]!= lane)\\n                    curr[lane] =  next[lane];\\n                else{\\n                    int ans =1e9;\\n                    for(int k = 1;k<=3;k++)\\n                    {\\n                        if(lane != k && obstacles[pos]!=k)\\n                        {\\n                            ans = min(ans,1+next[k]);\\n                        }   \\n                    }\\n                    curr[lane] = ans;\\n                }\\n            }\\n            next = curr;\\n        }\\n\\n        return min(curr[2],min(curr[1]+1,curr[3]+1));\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313557,
                "title": "recursive-approach-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int f(int idx, int lane, int n, vector<int>& obstacles, vector<vector<int>>& dp){\\n        \\n        if(idx == n-1) return 0;\\n        \\n        if(obstacles[idx] == lane) return 1e6;\\n        \\n        if(dp[idx][lane] != -1) return dp[idx][lane];\\n        \\n        int ans = 1e6;\\n        \\n        if(idx+1 < n && obstacles[idx+1] == lane){\\n            \\n            if(lane == 1){\\n                ans = min(ans, 1 + f(idx, 2, n, obstacles, dp));\\n                ans = min(ans, 1 + f(idx, 3, n, obstacles, dp));\\n            }\\n            else if(lane == 2){\\n                ans = min(ans, 1 + f(idx, 1, n, obstacles, dp));\\n                ans = min(ans, 1 + f(idx, 3, n, obstacles, dp));\\n            }\\n            else{\\n                ans = min(ans, 1 + f(idx, 1, n, obstacles, dp));\\n                ans = min(ans, 1 + f(idx, 2, n, obstacles, dp));\\n            }\\n            \\n        }\\n        else if(idx + 1 < n && (obstacles[idx+1] != lane || obstacles[idx+1] == 0)){\\n            \\n            ans = min(ans, f(idx+1, lane, n, obstacles, dp));\\n            \\n        }\\n        \\n        \\n        return dp[idx][lane] = ans;\\n        \\n    }\\n    \\n    \\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        vector<vector<int>> dp(n+1, vector<int>(4, -1));\\n        \\n        return f(0, 2, n, obstacles, dp);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int f(int idx, int lane, int n, vector<int>& obstacles, vector<vector<int>>& dp){\\n        \\n        if(idx == n-1) return 0;\\n        \\n        if(obstacles[idx] == lane) return 1e6;\\n        \\n        if(dp[idx][lane] != -1) return dp[idx][lane];\\n        \\n        int ans = 1e6;\\n        \\n        if(idx+1 < n && obstacles[idx+1] == lane){\\n            \\n            if(lane == 1){\\n                ans = min(ans, 1 + f(idx, 2, n, obstacles, dp));\\n                ans = min(ans, 1 + f(idx, 3, n, obstacles, dp));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2303223,
                "title": "java-memorization-easy-dp",
                "content": "```\\nclass Solution {\\n    int n;\\n    int dp[][];\\n    public int minSideJumps(int[] o) {\\n        n = o.length;\\n        dp = new int[4][n];\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < n; j++){\\n                dp[i][j] = -1;\\n            }\\n        }\\n        return f(2 , 0 , o);\\n    }\\n    int f(int lane , int idx , int o[]){\\n        if(idx == n - 1){\\n            return 0;\\n        }\\n        if(dp[lane][idx] != -1) return dp[lane][idx];\\n        int fj = 1000000;\\n        int sj = 1000000;\\n        if(o[idx + 1] != lane){\\n            fj = f(lane , idx + 1 , o);\\n        }\\n        else{\\n            for(int i = 1; i <= 3; i++){\\n                if(lane == i || o[idx] == i) continue;\\n                sj = Math.min(sj , f(i , idx , o) + 1);\\n            }\\n        }\\n        return dp[lane][idx] = Math.min(sj , fj);\\n    }\\n}",
                "solutionTags": [
                    "Brainteaser"
                ],
                "code": "class Solution {\\n    int n;\\n    int dp[][];\\n    public int minSideJumps(int[] o) {\\n        n = o.length;\\n        dp = new int[4][n];\\n        for(int i = 0; i < 4; i++){\\n            for(int j = 0; j < n; j++){\\n                dp[i][j] = -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2260213,
                "title": "c-dp-bottom-up",
                "content": "DP bottom-up approach.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> D(3, vector<int>(n, 0));\\n        for(int i=n-2; i>=0; --i)\\n        {\\n            if(obstacles[i]==0)\\n            {\\n                D[0][i]=min(D[0][i+1], min(D[1][i+1], D[2][i+1])+1); \\n                D[1][i]=min(D[1][i+1], min(D[0][i+1], D[2][i+1])+1); \\n                D[2][i]=min(D[2][i+1], min(D[0][i+1], D[1][i+1])+1);\\n            }\\n            else if(obstacles[i]==1)\\n            {\\n                D[0][i]=n;\\n                D[1][i] = min(D[1][i+1], D[2][i+1]+1);\\n                D[2][i] = min(D[2][i+1], D[1][i+1]+1);\\n            }\\n            else if(obstacles[i]==2)\\n            {\\n                D[1][i]=n;\\n                D[0][i] = min(D[0][i+1], D[2][i+1]+1);\\n                D[2][i] = min(D[2][i+1], D[0][i+1]+1);\\n            }\\n            else if(obstacles[i]==3)\\n            {\\n                D[2][i]=n;\\n                D[0][i] = min(D[0][i+1], D[1][i+1]+1);\\n                D[1][i] = min(D[1][i+1], D[0][i+1]+1);\\n            }\\n        }\\n        return D[1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> D(3, vector<int>(n, 0));\\n        for(int i=n-2; i>=0; --i)\\n        {\\n            if(obstacles[i]==0)\\n            {\\n                D[0][i]=min(D[0][i+1], min(D[1][i+1], D[2][i+1])+1); \\n                D[1][i]=min(D[1][i+1], min(D[0][i+1], D[2][i+1])+1); \\n                D[2][i]=min(D[2][i+1], min(D[0][i+1], D[1][i+1])+1);\\n            }\\n            else if(obstacles[i]==1)\\n            {\\n                D[0][i]=n;\\n                D[1][i] = min(D[1][i+1], D[2][i+1]+1);\\n                D[2][i] = min(D[2][i+1], D[1][i+1]+1);\\n            }\\n            else if(obstacles[i]==2)\\n            {\\n                D[1][i]=n;\\n                D[0][i] = min(D[0][i+1], D[2][i+1]+1);\\n                D[2][i] = min(D[2][i+1], D[0][i+1]+1);\\n            }\\n            else if(obstacles[i]==3)\\n            {\\n                D[2][i]=n;\\n                D[0][i] = min(D[0][i+1], D[1][i+1]+1);\\n                D[1][i] = min(D[1][i+1], D[0][i+1]+1);\\n            }\\n        }\\n        return D[1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171795,
                "title": "c-easy-dp-memoization-beats-90",
                "content": "![image](https://assets.leetcode.com/users/images/d39d86ba-24d8-4ea5-a43b-58ebdb1d815c_1655666311.2374113.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[500001][3];\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(obstacles, 0, 1);\\n    }\\n    int rec(vector<int>& obstacles, int i, int j){\\n        if(j<0||j>2||obstacles[i]-1==j)//reject impossible cases\\n            return INT_MAX;\\n        if(i>=obstacles.size()-1)//reached end\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(obstacles[i+1]-1!=j)//subtract 1 since lane is indexed 1\\n            return dp[i][j]=rec(obstacles, i+1, j);\\n        return dp[i][j]=1+min(rec(obstacles, i, j+1), min(rec(obstacles, i, j+2), min(rec(obstacles, i, j-1), rec(obstacles, i, j-2))));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500001][3];\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(obstacles, 0, 1);\\n    }\\n    int rec(vector<int>& obstacles, int i, int j){\\n        if(j<0||j>2||obstacles[i]-1==j)//reject impossible cases\\n            return INT_MAX;\\n        if(i>=obstacles.size()-1)//reached end\\n            return 0;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        if(obstacles[i+1]-1!=j)//subtract 1 since lane is indexed 1\\n            return dp[i][j]=rec(obstacles, i+1, j);\\n        return dp[i][j]=1+min(rec(obstacles, i, j+1), min(rec(obstacles, i, j+2), min(rec(obstacles, i, j-1), rec(obstacles, i, j-2))));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088982,
                "title": "c-dp-tabulation-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        int dp[n][4];\\n        dp[0][1]=1;\\n        dp[0][2]=0;\\n        dp[0][3]=1;\\n        for(int i=1; i<n-1; i++) {\\n             if(obstacles[i] == 1)\\n             {\\n                 dp[i][2] = (obstacles[i-1] == 2) ? dp[i-1][3] + 1 : dp[i-1][2];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? dp[i-1][2] + 1 : dp[i-1][3];\\n                 dp[i][1] = INT_MAX;\\n             } else if(obstacles[i] == 2) {\\n                 dp[i][1] = (obstacles[i-1] == 1) ? dp[i-1][3] + 1 : dp[i-1][1];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? dp[i-1][1] + 1 : dp[i-1][3];\\n                 dp[i][2] = INT_MAX;\\n             } else if(obstacles[i] == 3) {\\n                 dp[i][2] = (obstacles[i-1] == 2) ? dp[i-1][1] + 1 : dp[i-1][2];\\n                 dp[i][1] = (obstacles[i-1] == 1) ? dp[i-1][2] + 1 : dp[i-1][1];\\n                 dp[i][3] = INT_MAX;\\n             } else {\\n                 dp[i][1] = (obstacles[i-1] == 1) ? min(dp[i-1][2], dp[i-1][3]) + 1 : dp[i-1][1];\\n                 dp[i][2] = (obstacles[i-1] == 2) ? min(dp[i-1][3], dp[i-1][1]) + 1 : dp[i-1][2];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? min(dp[i-1][2], dp[i-1][1]) + 1 : dp[i-1][3];   \\n             }\\n        }\\n        // for(int i=1; i<n-1; i++) {\\n        //     for(int j = 1; j<=3; j++)\\n        //         cout<<dp[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return min(dp[n-2][1], min(dp[n-2][2], dp[n-2][3]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        int dp[n][4];\\n        dp[0][1]=1;\\n        dp[0][2]=0;\\n        dp[0][3]=1;\\n        for(int i=1; i<n-1; i++) {\\n             if(obstacles[i] == 1)\\n             {\\n                 dp[i][2] = (obstacles[i-1] == 2) ? dp[i-1][3] + 1 : dp[i-1][2];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? dp[i-1][2] + 1 : dp[i-1][3];\\n                 dp[i][1] = INT_MAX;\\n             } else if(obstacles[i] == 2) {\\n                 dp[i][1] = (obstacles[i-1] == 1) ? dp[i-1][3] + 1 : dp[i-1][1];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? dp[i-1][1] + 1 : dp[i-1][3];\\n                 dp[i][2] = INT_MAX;\\n             } else if(obstacles[i] == 3) {\\n                 dp[i][2] = (obstacles[i-1] == 2) ? dp[i-1][1] + 1 : dp[i-1][2];\\n                 dp[i][1] = (obstacles[i-1] == 1) ? dp[i-1][2] + 1 : dp[i-1][1];\\n                 dp[i][3] = INT_MAX;\\n             } else {\\n                 dp[i][1] = (obstacles[i-1] == 1) ? min(dp[i-1][2], dp[i-1][3]) + 1 : dp[i-1][1];\\n                 dp[i][2] = (obstacles[i-1] == 2) ? min(dp[i-1][3], dp[i-1][1]) + 1 : dp[i-1][2];\\n                 dp[i][3] = (obstacles[i-1] == 3) ? min(dp[i-1][2], dp[i-1][1]) + 1 : dp[i-1][3];   \\n             }\\n        }\\n        // for(int i=1; i<n-1; i++) {\\n        //     for(int j = 1; j<=3; j++)\\n        //         cout<<dp[i][j]<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return min(dp[n-2][1], min(dp[n-2][2], dp[n-2][3]));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2072806,
                "title": "python-simple-fast-intuitive",
                "content": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # inits\\n        cur_lane, side_steps, len_obs = 2, 0, len(obstacles)\\n        \\n        # O(1) lookup to obtain most empty other lane\\n        other_lanes = [{2:3, 3:2}, {1:3, 3:1}, {1:2, 2:1}]\\n        \\n        \\n        for i in range(len_obs):\\n            # Go until next obstacle and increment side steps\\n            if obstacles[i] == cur_lane:\\n                side_steps += 1\\n                \\n                # Search for obstacles in other lanes\\n                for j in range(i-1, len_obs):\\n                    if obstacles[j] in other_lanes[cur_lane-1]:\\n                        \\n                        # Next lane is the one that doesn\\'t have the next obstacle\\n                        cur_lane = other_lanes[cur_lane-1][obstacles[j]]\\n                        break\\n                        \\n                # We are at the end\\n                if j == len_obs-1:\\n                    break\\n                    \\n        return side_steps\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fc5bb4c5-b276-4fa8-b03b-aea7584ffad7_1653484220.7957945.png)\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # inits\\n        cur_lane, side_steps, len_obs = 2, 0, len(obstacles)\\n        \\n        # O(1) lookup to obtain most empty other lane\\n        other_lanes = [{2:3, 3:2}, {1:3, 3:1}, {1:2, 2:1}]\\n        \\n        \\n        for i in range(len_obs):\\n            # Go until next obstacle and increment side steps\\n            if obstacles[i] == cur_lane:\\n                side_steps += 1\\n                \\n                # Search for obstacles in other lanes\\n                for j in range(i-1, len_obs):\\n                    if obstacles[j] in other_lanes[cur_lane-1]:\\n                        \\n                        # Next lane is the one that doesn\\'t have the next obstacle\\n                        cur_lane = other_lanes[cur_lane-1][obstacles[j]]\\n                        break\\n                        \\n                # We are at the end\\n                if j == len_obs-1:\\n                    break\\n                    \\n        return side_steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060692,
                "title": "c-easy-memoization",
                "content": "the basic concept which the solutions works is when there is no obstacle aahead let the frog move in the same lane and as an obstacle arrive check for options where the frog can change lanes andafter changing it has to take minimum side jump. :)\\n```\\nclass Solution {\\npublic:\\n    int dp[500005][3];\\n    int solve(vector<int>& arr, int i, int l) {\\n        int n = arr.size();\\n        if(i == n-1) {\\n            return 0;\\n        }\\n        if(arr[i] == l+1) {\\n            return 1e9;\\n        }\\n        if(dp[i][l] != -1) {\\n            return dp[i][l];\\n        }\\n        if(arr[i+1] != l+1) {\\n\\t\\t//move in same lane\\n         dp[i][l] = solve(arr, i+1, l);\\n        } else {\\n\\t\\t//change lane and check for min\\n         dp[i][l] = 1 + min(solve(arr, i, (l+1)%3), solve(arr, i, (l+2)%3));\\n        }\\n        return dp[i][l];\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(obstacles, 0, 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500005][3];\\n    int solve(vector<int>& arr, int i, int l) {\\n        int n = arr.size();\\n        if(i == n-1) {\\n            return 0;\\n        }\\n        if(arr[i] == l+1) {\\n            return 1e9;\\n        }\\n        if(dp[i][l] != -1) {\\n            return dp[i][l];\\n        }\\n        if(arr[i+1] != l+1) {\\n\\t\\t//move in same lane\\n         dp[i][l] = solve(arr, i+1, l);\\n        } else {\\n\\t\\t//change lane and check for min\\n         dp[i][l] = 1 + min(solve(arr, i, (l+1)%3), solve(arr, i, (l+2)%3));\\n        }\\n        return dp[i][l];\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(obstacles, 0, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002779,
                "title": "python-top-down-dp-easy-to-understand",
                "content": "**Explanation:**\\n1. There are two options at each step: jump or not jump.\\n2. We follow the greedy idea that we only jump when there\\'s a stone at the nearest next position.\\n3. If there\\'s a stone at the next position, we try to jump to other lanes.\\n4. Otherwise, we keep moving to the next position.\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        \\n        choices = {1,2,3}\\n        memo = {}\\n        \\n        # need to use memo, lru_cache leads to runtime error\\n\\t\\t# state means the current lane state, it can take value 1 or 2 or 3; idx is the index of the obstacles array\\n        def dfs(state, idx):\\n            if idx == len(obstacles):\\n                return 0\\n            if (state, idx) in memo:\\n                return memo[(state, idx)]\\n            \\n            res = float(\"inf\")\\n\\t\\t\\t# if there\\'s a stone at the next position, try to jump to other lanes\\n            if idx + 1 < len(obstacles) and state == obstacles[idx + 1]:\\n                for choice in choices:\\n\\t\\t\\t\\t\\t# check the available choices, the choice should be a different lane from the current lane and there\\'s no stone on that chosen lane\\n                    if state != choice and obstacles[idx] != choice:\\n                        res = min(res, 1 + dfs(choice, idx + 1))\\n            \\n\\t\\t\\t#  if there\\'s no stone at the next position, continue moving\\n            else:\\n                res = dfs(state, idx + 1)\\n            \\n            memo[(state, idx)] = res\\n            return res\\n        \\n        return dfs(2, 0)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        \\n        choices = {1,2,3}",
                "codeTag": "Java"
            },
            {
                "id": 1926187,
                "title": "java-simple-solution",
                "content": "\\n\\n        \\n        int dp[][]=new int[4][obstacles.length];\\n        for(int i=obstacles.length-2;i>=0;i--)\\n        {\\n            for(int j=1;j<=3;j++)\\n            {\\n                dp[j][i]=dp[j][i+1];\\n                if(obstacles[i]==j)\\n                    dp[j][i]=Integer.MAX_VALUE;\\n            }\\n            int j=obstacles[i+1];\\n            if(j!=0)\\n            {\\n                int min=Integer.MAX_VALUE;\\n                for(int k=1;k<=3;k++)\\n                {\\n                    if(k!=j)\\n                    {\\n                        min=Math.min(min,dp[k][i]);\\n                    }\\n                }\\n                dp[j][i]=min+1;\\n            }\\n        }\\n        \\n        return dp[2][0];\\n            \\n        \\n \\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "\\n\\n        \\n        int dp[][]=new int[4][obstacles.length];\\n        for(int i=obstacles.length-2;i>=0;i--)\\n        {\\n            for(int j=1;j<=3;j++)\\n            {\\n                dp[j][i]=dp[j][i+1];\\n                if(obstacles[i]==j)\\n                    dp[j][i]=Integer.MAX_VALUE;\\n            }\\n            int j=obstacles[i+1];\\n            if(j!=0)\\n            {\\n                int min=Integer.MAX_VALUE;\\n                for(int k=1;k<=3;k++)\\n                {\\n                    if(k!=j)\\n                    {\\n                        min=Math.min(min,dp[k][i]);\\n                    }\\n                }\\n                dp[j][i]=min+1;\\n            }\\n        }\\n        \\n        return dp[2][0];\\n            \\n        \\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1915016,
                "title": "schr-dinger-s-frog-o-n-o-1-python-fast",
                "content": "av_lanes represents the lanes we could potentially be travelling on, we start of with {2} because we know that we start on lane 2. however when we need to switch lanes, we remove the current lane we are travelling on and add the other two potential lanes to the set. This means if the other two lanes are available then we are travelling on both of them at the same time untill we hit an obstacle, then our quantum state collapses and we only have one lane we can travel on untill we hit an obstacle and have to jump. hope you enjoy this little joke.\\n\\n```\\nclass Solution:\\n   \\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        jumps=0\\n        av_lanes={2}\\n        for idx,v in enumerate(obstacles):\\n            if v in av_lanes and len(av_lanes)<2:\\n                jumps+=1\\n                av_lanes={1,2,3}-{av_lanes.pop(),obstacles[idx-1]}\\n            elif v in av_lanes:\\n                av_lanes.remove(v)\\n        return jumps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n   \\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        jumps=0\\n        av_lanes={2}\\n        for idx,v in enumerate(obstacles):\\n            if v in av_lanes and len(av_lanes)<2:\\n                jumps+=1\\n                av_lanes={1,2,3}-{av_lanes.pop(),obstacles[idx-1]}\\n            elif v in av_lanes:\\n                av_lanes.remove(v)\\n        return jumps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894720,
                "title": "c-memoization-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>memo;\\n    int findAns(vector<int>&obs,int index,int lane){\\n        int n=obs.size()-1;\\n        if(index==n){\\n            return 0;\\n        } else if(memo[index][lane]!=-1){\\n            return memo[index][lane];\\n        } else {\\n            if(obs[index+1]!=lane){\\n                return memo[index][lane]=findAns(obs,index+1,lane);\\n            } else {\\n                int ans=INT_MAX;\\n                for(int l=1;l<=3;l++){\\n                    if(l!=lane and obs[index]!=l){\\n                        ans=min(ans,findAns(obs,index,l));\\n                    }\\n                }\\n                return memo[index][lane]=ans+1;\\n            }\\n        }\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        memo=vector<vector<int>>(n,vector<int>(4,-1));\\n        return findAns(obs,0,2);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\nprivate:\\n    vector<vector<int>>memo;\\n    int findAns(vector<int>&obs,int index,int lane){\\n        int n=obs.size()-1;\\n        if(index==n){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1856595,
                "title": "java-solution-no-recursion-no-dp-runtime-faster-than-99-52-memory-usage-less-than-88-41",
                "content": "```\\npublic int minSideJumps(int[] obstacles) {\\n        int sideJumps = 0;  // track side jumps\\n        int currLane = 2;   // track lane that the frog is currently in\\n        for (int i = 0; i < obstacles.length - 1; i++) {\\n            if (obstacles[i+1] == currLane) {   // check if there is a obstacle right in front of the frog\\n                if (obstacles[i] != 0) {    // check if there is an obstacle in any of the lanes at the current point that the frog is in\\n                    currLane = getNextLane(obstacles[i], obstacles[i+1]);   // if so, only one lane for the frog to move to, update current lane frog is in\\n                } else {    // if there are no obstacles at the current point, we have 2 lanes we could jump to, so we need to choose the right one\\n                    // the right lane to jump to is the one that does not hit an obstacle first\\n                    int j = i + 2;  // j will act as a running pointer to find the next obstacle in a different lane\\n                    while (j < obstacles.length && (obstacles[j] == 0 || obstacles[j] == obstacles[i+1])) {     // we do not count points where there are no obstacles or if the next obstacle is in the same lane as the first obstacle we ran into\\n                        j++;\\n                    }\\n                    if (j < obstacles.length) { // if this condition is met, that means we found a obstacle in another lane before getting to the end\\n                        currLane = getNextLane(obstacles[i+1], obstacles[j]);   // update current lane frog is in\\n                    } else {    // if this else statement is hit, that means that we reached the end of the list without hitting anymore obstacles\\n                        i = obstacles.length - 1;   // update i in order to break out of the loop\\n                    }\\n                }\\n                sideJumps++;    // frog side jumps to get past the obstacle in front of it\\n            }\\n        }\\n        return sideJumps;\\n    }\\n    \\n    /* given 2 lanes with obstacles, function returns the open lane */\\n    public int getNextLane(int nextObstacle, int nextNextObstacle) {\\n        if ((nextObstacle == 2 && nextNextObstacle == 3) ||\\n            (nextObstacle == 3 && nextNextObstacle == 2)) {\\n            return 1;\\n        }\\n        if ((nextObstacle == 1 && nextNextObstacle == 3) ||\\n            (nextObstacle == 3 && nextNextObstacle == 1)) {\\n            return 2;\\n        }\\n        else {\\n\\t\\t\\treturn 3;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minSideJumps(int[] obstacles) {\\n        int sideJumps = 0;  // track side jumps\\n        int currLane = 2;   // track lane that the frog is currently in\\n        for (int i = 0; i < obstacles.length - 1; i++) {\\n            if (obstacles[i+1] == currLane) {   // check if there is a obstacle right in front of the frog\\n                if (obstacles[i] != 0) {    // check if there is an obstacle in any of the lanes at the current point that the frog is in\\n                    currLane = getNextLane(obstacles[i], obstacles[i+1]);   // if so, only one lane for the frog to move to, update current lane frog is in\\n                } else {    // if there are no obstacles at the current point, we have 2 lanes we could jump to, so we need to choose the right one\\n                    // the right lane to jump to is the one that does not hit an obstacle first\\n                    int j = i + 2;  // j will act as a running pointer to find the next obstacle in a different lane\\n                    while (j < obstacles.length && (obstacles[j] == 0 || obstacles[j] == obstacles[i+1])) {     // we do not count points where there are no obstacles or if the next obstacle is in the same lane as the first obstacle we ran into\\n                        j++;\\n                    }\\n                    if (j < obstacles.length) { // if this condition is met, that means we found a obstacle in another lane before getting to the end\\n                        currLane = getNextLane(obstacles[i+1], obstacles[j]);   // update current lane frog is in\\n                    } else {    // if this else statement is hit, that means that we reached the end of the list without hitting anymore obstacles\\n                        i = obstacles.length - 1;   // update i in order to break out of the loop\\n                    }\\n                }\\n                sideJumps++;    // frog side jumps to get past the obstacle in front of it\\n            }\\n        }\\n        return sideJumps;\\n    }\\n    \\n    /* given 2 lanes with obstacles, function returns the open lane */\\n    public int getNextLane(int nextObstacle, int nextNextObstacle) {\\n        if ((nextObstacle == 2 && nextNextObstacle == 3) ||\\n            (nextObstacle == 3 && nextNextObstacle == 2)) {\\n            return 1;\\n        }\\n        if ((nextObstacle == 1 && nextNextObstacle == 3) ||\\n            (nextObstacle == 3 && nextNextObstacle == 1)) {\\n            return 2;\\n        }\\n        else {\\n\\t\\t\\treturn 3;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1672997,
                "title": "java-easy-dp-memoization-solution-intuitive-soln",
                "content": "```\\nclass Solution {\\n    private int solve(int i,int lane,int n,int[] obstacles,int[][] dp){\\n        if((i<n-1 && obstacles[i]==lane) || (i>0 && obstacles[i-1]==lane))\\n            return 1000000;\\n        if(i==n-1)\\n            return 0;\\n        if(dp[i][lane]!=-1)\\n            return dp[i][lane];\\n        int a=solve(i+1,lane,n,obstacles,dp);\\n        int b=0,c=0;\\n        if(lane==1){\\n            b=1+solve(i+1,2,n,obstacles,dp);\\n            c=1+solve(i+1,3,n,obstacles,dp);\\n        }else if(lane==2){\\n            b=1+solve(i+1,1,n,obstacles,dp);\\n            c=1+solve(i+1,3,n,obstacles,dp);\\n        }else{\\n            b=1+solve(i+1,1,n,obstacles,dp);\\n            c=1+solve(i+1,2,n,obstacles,dp);\\n        }\\n        return dp[i][lane]=Math.min(a,Math.min(b,c));\\n    }\\n    public int minSideJumps(int[] obstacles) {\\n        int n=obstacles.length;\\n        int[][] dp=new int[n+1][4];\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-1);\\n        return solve(0,2,n,obstacles,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private int solve(int i,int lane,int n,int[] obstacles,int[][] dp){\\n        if((i<n-1 && obstacles[i]==lane) || (i>0 && obstacles[i-1]==lane))\\n            return 1000000;\\n        if(i==n-1)\\n            return 0;\\n        if(dp[i][lane]!=-1)\\n            return dp[i][lane];\\n        int a=solve(i+1,lane,n,obstacles,dp);\\n        int b=0,c=0;\\n        if(lane==1){\\n            b=1+solve(i+1,2,n,obstacles,dp);\\n            c=1+solve(i+1,3,n,obstacles,dp);\\n        }else if(lane==2){\\n            b=1+solve(i+1,1,n,obstacles,dp);\\n            c=1+solve(i+1,3,n,obstacles,dp);\\n        }else{\\n            b=1+solve(i+1,1,n,obstacles,dp);\\n            c=1+solve(i+1,2,n,obstacles,dp);\\n        }\\n        return dp[i][lane]=Math.min(a,Math.min(b,c));\\n    }\\n    public int minSideJumps(int[] obstacles) {\\n        int n=obstacles.length;\\n        int[][] dp=new int[n+1][4];\\n        for(int[] arr:dp)\\n            Arrays.fill(arr,-1);\\n        return solve(0,2,n,obstacles,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665751,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[600000][5];\\n    int find(vector<int>&nums,int index,int line)\\n    {\\n        if(index==nums.size()-1)\\n        {\\n            return 0;\\n        }\\n        if(nums[index]==line)\\n        {\\n            return INT_MAX;\\n        }\\n        if(dp[index][line]!=-1)\\n        {\\n            return dp[index][line];\\n        }\\n        if(nums[index+1]!=line)\\n        {\\n            return find(nums,index+1,line);\\n        }\\n        else\\n        {\\n            int val=0;\\n            if(line==1)\\n            {\\n                val=1+min(find(nums,index,2),find(nums,index,3));\\n            }\\n            else if(line==2)\\n            {\\n                val=1+min(find(nums,index,1),find(nums,index,3));\\n            }\\n            else \\n            {\\n                val=1+min(find(nums,index,1),find(nums,index,2));\\n            }\\n            return dp[index][line]=val;\\n        }\\n    }\\n    int minSideJumps(vector<int>&nums)\\n    {\\n        n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return find(nums,0,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[600000][5];\\n    int find(vector<int>&nums,int index,int line)\\n    {\\n        if(index==nums.size()-1)\\n        {\\n            return 0;\\n        }\\n        if(nums[index]==line)\\n        {\\n            return INT_MAX;\\n        }\\n        if(dp[index][line]!=-1)\\n        {\\n            return dp[index][line];\\n        }\\n        if(nums[index+1]!=line)\\n        {\\n            return find(nums,index+1,line);\\n        }\\n        else\\n        {\\n            int val=0;\\n            if(line==1)\\n            {\\n                val=1+min(find(nums,index,2),find(nums,index,3));\\n            }\\n            else if(line==2)\\n            {\\n                val=1+min(find(nums,index,1),find(nums,index,3));\\n            }\\n            else \\n            {\\n                val=1+min(find(nums,index,1),find(nums,index,2));\\n            }\\n            return dp[index][line]=val;\\n        }\\n    }\\n    int minSideJumps(vector<int>&nums)\\n    {\\n        n=nums.size();\\n        memset(dp,-1,sizeof(dp));\\n        return find(nums,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488014,
                "title": "simple-concept-beats-90-by-both-space-and-time",
                "content": "class Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        int count = 0;\\n        int row = 2; \\n        int i = 0;\\n        \\n        while(i < n){\\n            \\n            while(i < n && obstacles[i] != row){\\n                i++;\\n            }\\n            \\n            if(i < n && obstacles[i] == row){\\n                \\n                i--;\\n                \\n                if(i < n && obstacles[i] != 0){\\n                    count ++;\\n                    row = 6 - row - obstacles[i];\\n                }\\n                \\n                else{\\n                    count++;\\n                    int go1 = (row + 1) > 3 ? (row + 1 - 3) : (row + 1);\\n                    int go2 = (row + 2) > 3 ? (row + 2 - 3) : (row + 2);\\n                    \\n                    while(i < n && obstacles[i] != go1 && obstacles[i] != go2){\\n                        i++;\\n                    }\\n                    \\n                    if(i < n && obstacles[i] == go1){\\n                         row = go2;\\n                         i--;\\n                    }\\n                    \\n                    if(i < n && obstacles[i] == go2){\\n                         row = go1;\\n                        i--;\\n                    }\\n                    \\n                }\\n            }\\n            \\n        }\\n        \\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        int n = obstacles.size();\\n        \\n        int count = 0;\\n        int row = 2; \\n        int i = 0;\\n        \\n        while(i < n){\\n            \\n            while(i < n && obstacles[i] != row){\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1419305,
                "title": "c-bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> dp(n,vector<int>(3,1e6));\\n        dp[0][1]=0;\\n        for (int idx=0;idx<n;idx++){\\n            for (int i=0;i<3;i++){\\n                if (i!=(obstacles[idx]-1)){\\n                    int Min=INT_MAX;\\n                    for (int j=0;j<3;j++){\\n                        Min=min(Min,(i!=j)?dp[idx][j]+1:dp[idx][i]);\\n                    }\\n                    dp[idx][i]=Min;\\n                    if (idx+1<n &&  i!=obstacles[idx+1]-1) dp[idx+1][i]=dp[idx][i];\\n                }\\n            }\\n        }\\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> dp(n,vector<int>(3,1e6));\\n        dp[0][1]=0;\\n        for (int idx=0;idx<n;idx++){\\n            for (int i=0;i<3;i++){\\n                if (i!=(obstacles[idx]-1)){\\n                    int Min=INT_MAX;\\n                    for (int j=0;j<3;j++){\\n                        Min=min(Min,(i!=j)?dp[idx][j]+1:dp[idx][i]);\\n                    }\\n                    dp[idx][i]=Min;\\n                    if (idx+1<n &&  i!=obstacles[idx+1]-1) dp[idx+1][i]=dp[idx][i];\\n                }\\n            }\\n        }\\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382260,
                "title": "bfs-c-solution-based-on-bfs",
                "content": "**LOGIC-Apply BFS and check if x+1 is obstacle in same lane then add other lanes with jumps+1 to the queue else moving one step ahead in the same lane will be optimal.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) \\n    {\\n        \\n       int n=obstacles.size(); \\n      queue<pair<pair<int,int>,int>>q;\\n      q.push({{2,0},0});\\n      set<pair<int,int>>vis;\\n      while(q.size()>0)\\n      {\\n          pair<pair<int,int>,int>d=q.front();\\n          q.pop();\\n          if(vis.find(d.first)!=vis.end())continue;\\n          vis.insert(d.first);\\n          int lane=d.first.first;\\n          int x=d.first.second;\\n          int jumps=d.second;\\n          if(x==n-1)return jumps;\\n          if(obstacles[x+1]!=lane)\\n          {\\n              q.push({{lane,x+1},jumps});                 //No obstacle so move forward\\n          }\\n          else \\n          {\\n              for(int i=1;i<=3;i++)\\n              {\\n                  if(i!=lane && obstacles[x]!=i)\\n                  {\\n                    q.push({{i,x},jumps+1});   //Obstacle ahead in the current lane so jump to other\\n                  }\\n              }\\n          }\\n      }\\n        \\n       return -1;   \\n         }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) \\n    {\\n        \\n       int n=obstacles.size(); \\n      queue<pair<pair<int,int>,int>>q;\\n      q.push({{2,0},0});\\n      set<pair<int,int>>vis;\\n      while(q.size()>0)\\n      {\\n          pair<pair<int,int>,int>d=q.front();\\n          q.pop();\\n          if(vis.find(d.first)!=vis.end())continue;\\n          vis.insert(d.first);\\n          int lane=d.first.first;\\n          int x=d.first.second;\\n          int jumps=d.second;\\n          if(x==n-1)return jumps;\\n          if(obstacles[x+1]!=lane)\\n          {\\n              q.push({{lane,x+1},jumps});                 //No obstacle so move forward\\n          }\\n          else \\n          {\\n              for(int i=1;i<=3;i++)\\n              {\\n                  if(i!=lane && obstacles[x]!=i)\\n                  {\\n                    q.push({{i,x},jumps+1});   //Obstacle ahead in the current lane so jump to other\\n                  }\\n              }\\n          }\\n      }\\n        \\n       return -1;   \\n         }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376221,
                "title": "top-down-solution-dp-java",
                "content": "`dp[idx][currLane]` represents the min jumps to reach `idx` on lane `currLane`\\n\\n```\\n\\n\\nclass Solution {\\n  int[] lanes = new int[]{1,2,3};\\n  public int minSideJumps(int[] obstacles) {\\n    int n = obstacles.length;\\n    Integer[][] dp = new Integer[n][4];\\n    return jump(n, obstacles, dp, 2, 0);\\n  }\\n  \\n  public int jump(int n, int[] obstacles, Integer[][] dp, int currLane, int idx) {\\n    if(idx >= n-1) return 0;\\n    if(dp[idx][currLane] != null) return dp[idx][currLane];\\n    int rockLocation = obstacles[idx+1];\\n    int min = n; \\n    \\n    if(currLane == rockLocation) {\\n      for(int lane: lanes) {\\n        if(lane == currLane) continue;\\n        if(obstacles[idx] == lane) continue;\\n        int res = jump(n, obstacles, dp, lane, idx);    \\n        min = Math.min(min, res);\\n      }\\n      dp[idx][currLane] = 1+min;\\n      return 1 + min;\\n    }\\n    min = jump(n, obstacles, dp, currLane, idx+1);\\n    dp[idx][currLane] = min;\\n    return min;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n  int[] lanes = new int[]{1,2,3};\\n  public int minSideJumps(int[] obstacles) {\\n    int n = obstacles.length;\\n    Integer[][] dp = new Integer[n][4];\\n    return jump(n, obstacles, dp, 2, 0);\\n  }\\n  \\n  public int jump(int n, int[] obstacles, Integer[][] dp, int currLane, int idx) {\\n    if(idx >= n-1) return 0;\\n    if(dp[idx][currLane] != null) return dp[idx][currLane];\\n    int rockLocation = obstacles[idx+1];\\n    int min = n; \\n    \\n    if(currLane == rockLocation) {\\n      for(int lane: lanes) {\\n        if(lane == currLane) continue;\\n        if(obstacles[idx] == lane) continue;\\n        int res = jump(n, obstacles, dp, lane, idx);    \\n        min = Math.min(min, res);\\n      }\\n      dp[idx][currLane] = 1+min;\\n      return 1 + min;\\n    }\\n    min = jump(n, obstacles, dp, currLane, idx+1);\\n    dp[idx][currLane] = min;\\n    return min;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324513,
                "title": "optimal-greedy-solution",
                "content": "```\\ndef greedy(k,a):\\n    \\n    def do_stuff(x,y,i,j,l):\\n        if a[j]==x: #check previous obstacle and change lane\\n            return y\\n        elif a[j]==y:\\n            return x\\n        else:\\n            while i<n and (a[i+1]==0 or a[i+1]==l):#to avoid 0s and same lane duplicates\\n                i+=1\\n            if i==n:\\n                return -1\\n            if a[i+1]==x: #check the next coming obstacle\\n                return y\\n            elif a[i+1]==y:\\n                return x\\n    n=k-1\\n    ans=0\\n    \\n    l=2 #current lane\\n    \\n    i=0\\n    while i<n:\\n        if l==a[i+1]: #when we encounter next obstacle\\n            j=i #stored for checking before obstacle\\n            while i<n and l==a[i+1]: #avoiding same lane duplicates\\n                i+=1\\n            ans+=1\\n            if i==n:\\n                break\\n\\n            if l==2: #deciding which lane to shift next\\n                l = do_stuff(1,3,i,j,l)\\n            elif l==1:\\n                l = do_stuff(2,3,i,j,l)\\n            else:\\n                l= do_stuff(1,2,i,j,l)\\n            \\n            if l==-1: #case when i==n hits\\n                    break\\n                \\n            if i>0: #edge case\\n                i-=1\\n        i+=1\\n    return ans\\n\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        return greedy(len(obstacles),obstacles)\\n```\\n\\nSimple greedy approach by checking previous obstacle and the immediate next obstacle approriately.[](http://)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\ndef greedy(k,a):\\n    \\n    def do_stuff(x,y,i,j,l):\\n        if a[j]==x: #check previous obstacle and change lane\\n            return y\\n        elif a[j]==y:\\n            return x\\n        else:\\n            while i<n and (a[i+1]==0 or a[i+1]==l):#to avoid 0s and same lane duplicates\\n                i+=1\\n            if i==n:\\n                return -1\\n            if a[i+1]==x: #check the next coming obstacle\\n                return y\\n            elif a[i+1]==y:\\n                return x\\n    n=k-1\\n    ans=0\\n    \\n    l=2 #current lane\\n    \\n    i=0\\n    while i<n:\\n        if l==a[i+1]: #when we encounter next obstacle\\n            j=i #stored for checking before obstacle\\n            while i<n and l==a[i+1]: #avoiding same lane duplicates\\n                i+=1\\n            ans+=1\\n            if i==n:\\n                break\\n\\n            if l==2: #deciding which lane to shift next\\n                l = do_stuff(1,3,i,j,l)\\n            elif l==1:\\n                l = do_stuff(2,3,i,j,l)\\n            else:\\n                l= do_stuff(1,2,i,j,l)\\n            \\n            if l==-1: #case when i==n hits\\n                    break\\n                \\n            if i>0: #edge case\\n                i-=1\\n        i+=1\\n    return ans\\n\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        return greedy(len(obstacles),obstacles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310227,
                "title": "java-dp-solution-with-explanation-time-o-n-space-o-1",
                "content": "```\\n// DP Solution\\n// 1. dp[j] is the min jump to reach lane j\\n// 2. If there is a stone at lane j, set dp[j] to infinity.\\n// 3. Jump: lane 0 -> 1 or 2, lane 1 -> 0 or 2, lane 2 -> 0 or 1. \\n//    So it\\'s lane j -> (j+1) % 3 or (j+2) % 3.\\n// 4. The final result is the min in dp.\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        if (obstacles == null || obstacles.length <= 1) return 0;\\n        final int N = obstacles.length - 1, INF = N * 2;\\n        int[] dp = new int[]{1, 0, 1};\\n        for (int i = 1; i <= N; i++) {\\n            int ob = obstacles[i];\\n            if (ob != 0) {\\n                dp[ob - 1] = INF;\\n            }\\n            for (int j = 0; j < 3; j++) {\\n                if (ob != j + 1) {\\n                    dp[j] = min(dp[j], dp[(j+1) % 3] + 1, dp[(j+2) % 3] + 1);\\n                }\\n            }\\n        }\\n        return min(dp[0], dp[1], dp[2]);\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(a, Math.min(b, c));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// DP Solution\\n// 1. dp[j] is the min jump to reach lane j\\n// 2. If there is a stone at lane j, set dp[j] to infinity.\\n// 3. Jump: lane 0 -> 1 or 2, lane 1 -> 0 or 2, lane 2 -> 0 or 1. \\n//    So it\\'s lane j -> (j+1) % 3 or (j+2) % 3.\\n// 4. The final result is the min in dp.\\n// Time complexity: O(N)\\n// Space complexity: O(1)\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        if (obstacles == null || obstacles.length <= 1) return 0;\\n        final int N = obstacles.length - 1, INF = N * 2;\\n        int[] dp = new int[]{1, 0, 1};\\n        for (int i = 1; i <= N; i++) {\\n            int ob = obstacles[i];\\n            if (ob != 0) {\\n                dp[ob - 1] = INF;\\n            }\\n            for (int j = 0; j < 3; j++) {\\n                if (ob != j + 1) {\\n                    dp[j] = min(dp[j], dp[(j+1) % 3] + 1, dp[(j+2) % 3] + 1);\\n                }\\n            }\\n        }\\n        return min(dp[0], dp[1], dp[2]);\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(a, Math.min(b, c));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1254622,
                "title": "java-simple-dp-o-n-and-o-1-solution",
                "content": "```\\nclass Solution {\\n       public int minSideJumps(int[] obstacles) {\\n        int[] prev = new int[3];\\n        prev[0] = 1;\\n        prev[1] = 0;\\n        prev[2] = 1;\\n\\n        for (int i = 0; i < obstacles.length; ++i) {\\n            int[] curr = new int[3];\\n            int obsIndex = obstacles[i] -1;\\n            if (obsIndex >= 0)\\n                curr[obsIndex] = Integer.MAX_VALUE;\\n\\n            // move forward\\n            for (int j = 0; j < 3; j++) {\\n                if (curr[j] != Integer.MAX_VALUE && prev[j] != Integer.MAX_VALUE)\\n                    curr[j] = prev[j];\\n            }\\n            // move sideways - meanigful only for cell just after the obstacle.\\n            for (int j = 0; j < 3; ++j) {\\n                if (prev[j] == Integer.MAX_VALUE && curr[j] != Integer.MAX_VALUE) {\\n                    curr[j] = Math.min(curr[(j+1) % 3], curr[(j+2)%3]) + 1;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return Math.min(prev[0], Math.min(prev[1], prev[2]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n       public int minSideJumps(int[] obstacles) {\\n        int[] prev = new int[3];\\n        prev[0] = 1;\\n        prev[1] = 0;\\n        prev[2] = 1;\\n\\n        for (int i = 0; i < obstacles.length; ++i) {\\n            int[] curr = new int[3];\\n            int obsIndex = obstacles[i] -1;\\n            if (obsIndex >= 0)\\n                curr[obsIndex] = Integer.MAX_VALUE;\\n\\n            // move forward\\n            for (int j = 0; j < 3; j++) {\\n                if (curr[j] != Integer.MAX_VALUE && prev[j] != Integer.MAX_VALUE)\\n                    curr[j] = prev[j];\\n            }\\n            // move sideways - meanigful only for cell just after the obstacle.\\n            for (int j = 0; j < 3; ++j) {\\n                if (prev[j] == Integer.MAX_VALUE && curr[j] != Integer.MAX_VALUE) {\\n                    curr[j] = Math.min(curr[(j+1) % 3], curr[(j+2)%3]) + 1;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return Math.min(prev[0], Math.min(prev[1], prev[2]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250533,
                "title": "o-n-recursive-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,dp[500005][4];\\n    int find(vector<int>&v,int i,int k)\\n    {  \\n        if(i==n-1)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        if(v[i+1]==k)\\n        { \\n            int x=INT_MAX,y=INT_MAX;\\n            if(k==1)\\n            {   \\n                if(v[i]!=2)\\n                x=1+find(v,i+1,2);\\n                 if(v[i]!=3)\\n                y=1+find(v,i+1,3);\\n            }\\n           else if(k==2)\\n           {  \\n               if(v[i]!=1)\\n               x=1+find(v,i+1,1);\\n                if(v[i]!=3)\\n                y=1+find(v,i+1,3);\\n           }\\n          else\\n          { \\n              if(v[i]!=1)\\n              x=1+find(v,i+1,1);\\n             if(v[i]!=2)\\n                y=1+find(v,i+1,2);\\n          }\\n         return dp[i][k]=min(x,y);\\n        }\\n        else\\n        return dp[i][k]=find(v,i+1,k);\\n        \\n    }\\n    int minSideJumps(vector<int>& v) {\\n        n=v.size();\\n        memset(dp,-1,sizeof(dp));\\n        return find(v,0,2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,dp[500005][4];\\n    int find(vector<int>&v,int i,int k)\\n    {  \\n        if(i==n-1)\\n        {\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        if(v[i+1]==k)\\n        { \\n            int x=INT_MAX,y=INT_MAX;\\n            if(k==1)\\n            {   \\n                if(v[i]!=2)\\n                x=1+find(v,i+1,2);\\n                 if(v[i]!=3)\\n                y=1+find(v,i+1,3);\\n            }\\n           else if(k==2)\\n           {  \\n               if(v[i]!=1)\\n               x=1+find(v,i+1,1);\\n                if(v[i]!=3)\\n                y=1+find(v,i+1,3);\\n           }\\n          else\\n          { \\n              if(v[i]!=1)\\n              x=1+find(v,i+1,1);\\n             if(v[i]!=2)\\n                y=1+find(v,i+1,2);\\n          }\\n         return dp[i][k]=min(x,y);\\n        }\\n        else\\n        return dp[i][k]=find(v,i+1,k);\\n        \\n    }\\n    int minSideJumps(vector<int>& v) {\\n        n=v.size();\\n        memset(dp,-1,sizeof(dp));\\n        return find(v,0,2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238483,
                "title": "python-recursive-bottom-up",
                "content": "Top down idea:\\n- Memory limit exceeds :0\\n- More intuitive to come up with thou\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n                                \\n        @functools.lru_cache(None)\\n        def recurse(idx, lane):                    \\n            if idx >= len(obstacles): return 0            \\n            if obstacles[idx] == lane: return float(\\'inf\\')            \\n            return min([\\n                (1 if l != lane else 0) + recurse(idx+1, l)\\n                for l in range(1, 4)\\n                if l != obstacles[idx]\\n            ])\\n        \\n        return recurse(0, 2)\\n```\\n\\nBottom up!\\n```python\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n                        \\n\\t\\t# Because we also \"look ahead\", we want to shorten the DP array\\n        N = len(A) - 1\\n            \\n        dp = [\\n            [float(\\'inf\\')] * 3\\n            for _ in range(N)\\n        ]\\n        \\n\\t\\t# Initial state\\n        dp[0] = [1, 0, 1]\\n        \\n        for i in range(1, N):\\n            for j in range(3):\\n            \\n                \"\"\"\\n\\t\\t\\t\\tThis line here is the tricky one.\\n\\t\\t\\t\\tThink about this: if we can jump to a space but the immediate next space is a rock,\\n\\t\\t\\t\\tcan will we succeed? NO. We don\\'t! So we must consider this\\n\\t\\t\\t\\t\"\"\"\\n                if A[i] == j+1 or A[i+1] == j+1:\\n                    dp[i][j] = float(\\'inf\\')\\n                else:\\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tOther people use the modulo \"%\" to be a bit more clean,\\n\\t\\t\\t\\t\\tbut to me, this is the easiest to read :)\\n\\t\\t\\t\\t\\t\"\"\"\\n                    dp[i][j] = min([\\n                        dp[i-1][0] + (1 if j != 0 else 0),\\n                        dp[i-1][1] + (1 if j != 1 else 0),\\n                        dp[i-1][2] + (1 if j != 2 else 0),\\n                    ])\\n                    \\n        return min(dp[-1])\\n```\\n\\nWe don\\'t really need to use the extra space however, so we can simply do:\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n        \\n        # 1\\n        N = len(A) - 1        \\n        dp = [1, 0, 1]\\n        \\n        # 2\\n        for i in range(1, N):\\n            for j in range(3):\\n                \\n                # 3\\n                if j+1 == A[i]:\\n                    dp[j] = float(\\'inf\\')\\n                else:\\n                    dp[j] = min(\\n                        dp[0] + (1 if j != 0 else 0) + (float(\\'inf\\') if A[i] == 1 else 0),\\n                        dp[1] + (1 if j != 1 else 0) + (float(\\'inf\\') if A[i] == 2 else 0),\\n                        dp[2] + (1 if j != 2 else 0) + (float(\\'inf\\') if A[i] == 3 else 0),\\n                    )\\n                    \\n        # 4\\n        return min(dp)\\n```\\n\\nAlso, I refactored the area in `#3` to only check for the current rock, and thus added the extra `(float(\\'inf\\') if A[i] == 1 else 0)` etc, etc.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n                                \\n        @functools.lru_cache(None)\\n        def recurse(idx, lane):                    \\n            if idx >= len(obstacles): return 0            \\n            if obstacles[idx] == lane: return float(\\'inf\\')            \\n            return min([\\n                (1 if l != lane else 0) + recurse(idx+1, l)\\n                for l in range(1, 4)\\n                if l != obstacles[idx]\\n            ])\\n        \\n        return recurse(0, 2)\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n                        \\n\\t\\t# Because we also \"look ahead\", we want to shorten the DP array\\n        N = len(A) - 1\\n            \\n        dp = [\\n            [float(\\'inf\\')] * 3\\n            for _ in range(N)\\n        ]\\n        \\n\\t\\t# Initial state\\n        dp[0] = [1, 0, 1]\\n        \\n        for i in range(1, N):\\n            for j in range(3):\\n            \\n                \"\"\"\\n\\t\\t\\t\\tThis line here is the tricky one.\\n\\t\\t\\t\\tThink about this: if we can jump to a space but the immediate next space is a rock,\\n\\t\\t\\t\\tcan will we succeed? NO. We don\\'t! So we must consider this\\n\\t\\t\\t\\t\"\"\"\\n                if A[i] == j+1 or A[i+1] == j+1:\\n                    dp[i][j] = float(\\'inf\\')\\n                else:\\n\\t\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\t\\tOther people use the modulo \"%\" to be a bit more clean,\\n\\t\\t\\t\\t\\tbut to me, this is the easiest to read :)\\n\\t\\t\\t\\t\\t\"\"\"\\n                    dp[i][j] = min([\\n                        dp[i-1][0] + (1 if j != 0 else 0),\\n                        dp[i-1][1] + (1 if j != 1 else 0),\\n                        dp[i-1][2] + (1 if j != 2 else 0),\\n                    ])\\n                    \\n        return min(dp[-1])\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, A: List[int]) -> int:\\n        \\n        # 1\\n        N = len(A) - 1        \\n        dp = [1, 0, 1]\\n        \\n        # 2\\n        for i in range(1, N):\\n            for j in range(3):\\n                \\n                # 3\\n                if j+1 == A[i]:\\n                    dp[j] = float(\\'inf\\')\\n                else:\\n                    dp[j] = min(\\n                        dp[0] + (1 if j != 0 else 0) + (float(\\'inf\\') if A[i] == 1 else 0),\\n                        dp[1] + (1 if j != 1 else 0) + (float(\\'inf\\') if A[i] == 2 else 0),\\n                        dp[2] + (1 if j != 2 else 0) + (float(\\'inf\\') if A[i] == 3 else 0),\\n                    )\\n                    \\n        # 4\\n        return min(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233835,
                "title": "c-easy-recursion-and-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[4][500002];\\n    \\n    int recurs(int lane,int i,vector<int>& obstacles)\\n    {\\n        if(i+1>=obstacles.size())\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        if(dp[lane][i]!=-1)\\n        {\\n            return dp[lane][i];\\n        }\\n        \\n        \\n        int ans=INT_MAX;\\n        \\n        if(obstacles[i+1]==lane)\\n        {\\n            if(obstacles[i]!=0)\\n            {\\n                   for(int i1=1;i1<=3;i1++)\\n               {\\n                       if(i1!=obstacles[i]&&i1!=obstacles[i+1])\\n                       {\\n                          ans=min(ans,recurs(i1,i,obstacles)+1);\\n                       }\\n               }\\n            }\\n                                  \\n            else\\n            {\\n                     for(int i1=1;i1<=3;i1++)\\n               {\\n                       if(i1!=obstacles[i+1])\\n                       {\\n                          ans=min(ans,recurs(i1,i,obstacles)+1);\\n                       }\\n               }\\n\\n            }\\n        }\\n         else\\n         {\\n              ans=min(ans,recurs(lane,i+1,obstacles));\\n         }\\n            \\n            \\n                return dp[lane][i]=ans;\\n            \\n        }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        \\n        for(int i=0;i<=3;i++)\\n        {\\n            for(int j=0;j<=obstacles.size();j++)\\n                dp[i][j]=-1;\\n        }\\n        \\n        \\n        \\n        return recurs(2,0,obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[4][500002];\\n    \\n    int recurs(int lane,int i,vector<int>& obstacles)\\n    {\\n        if(i+1>=obstacles.size())\\n        {\\n            return 0;\\n        }\\n        \\n        \\n        if(dp[lane][i]!=-1)\\n        {\\n            return dp[lane][i];\\n        }\\n        \\n        \\n        int ans=INT_MAX;\\n        \\n        if(obstacles[i+1]==lane)\\n        {\\n            if(obstacles[i]!=0)\\n            {\\n                   for(int i1=1;i1<=3;i1++)\\n               {\\n                       if(i1!=obstacles[i]&&i1!=obstacles[i+1])\\n                       {\\n                          ans=min(ans,recurs(i1,i,obstacles)+1);\\n                       }\\n               }\\n            }\\n                                  \\n            else\\n            {\\n                     for(int i1=1;i1<=3;i1++)\\n               {\\n                       if(i1!=obstacles[i+1])\\n                       {\\n                          ans=min(ans,recurs(i1,i,obstacles)+1);\\n                       }\\n               }\\n\\n            }\\n        }\\n         else\\n         {\\n              ans=min(ans,recurs(lane,i+1,obstacles));\\n         }\\n            \\n            \\n                return dp[lane][i]=ans;\\n            \\n        }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        \\n        \\n        for(int i=0;i<=3;i++)\\n        {\\n            for(int j=0;j<=obstacles.size();j++)\\n                dp[i][j]=-1;\\n        }\\n        \\n        \\n        \\n        return recurs(2,0,obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220290,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    \\n    int dp[][] = new int[500009][4];\\n    \\n    public int minSideJumps(int[] nums) {\\n        int len = nums.length;\\n        return solve(nums , 0 , 2);\\n    }\\n    \\n    public int solve(int nums[] , int index , int currPos) {\\n        if(index == nums.length - 1) return 0;\\n        \\n        if(dp[index][currPos] != 0) return dp[index][currPos];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1 ; i <= 3 ; i++) {\\n            if(nums[index + 1] != i && nums[index] != i) {\\n                if(i == currPos)\\n                  ans = Math.min(ans , solve(nums , index + 1 , i));\\n                else \\n                  ans = Math.min(ans , 1 + solve(nums , index + 1 , i));\\n            }\\n        }\\n        return dp[index][currPos] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int dp[][] = new int[500009][4];\\n    \\n    public int minSideJumps(int[] nums) {\\n        int len = nums.length;\\n        return solve(nums , 0 , 2);\\n    }\\n    \\n    public int solve(int nums[] , int index , int currPos) {\\n        if(index == nums.length - 1) return 0;\\n        \\n        if(dp[index][currPos] != 0) return dp[index][currPos];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 1 ; i <= 3 ; i++) {\\n            if(nums[index + 1] != i && nums[index] != i) {\\n                if(i == currPos)\\n                  ans = Math.min(ans , solve(nums , index + 1 , i));\\n                else \\n                  ans = Math.min(ans , 1 + solve(nums , index + 1 , i));\\n            }\\n        }\\n        return dp[index][currPos] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180693,
                "title": "javascript-o-n-solution-not-recursive-although-can-be-implemented-recursivly",
                "content": "So the idea is to keep note of the current position and jump every time there is a brick directly in front of the frog\\nIf there is also a brick above or below that means there is only 1 jump possible so the frog jumps to the lane with no brick\\nIf multiple jumps possible then frog jumps to the lane where the brick is further away since u dont want to hit the brick with the frog\\n```\\nfunction minSideJumps(obstacles) {\\n  const n = obstacles.length - 1\\n  let jumps = 0\\n  let cur = 2\\n  for (let i = 1; i < n; i++) {\\n    if (obstacles[i] != cur) continue\\n    jumps++ /* JUMPS ++ */\\n    if (obstacles[i - 1]) {\\n      cur = 3 - ((obstacles[i - 1] + cur) % 3) /* MAKE A JUMP IF ONLY 1 AVALIABLE */\\n      continue\\n    }\\n    while (i < n) {\\n      let rock = obstacles[i]\\n      if (rock != 0 && rock != cur) {\\n        cur = 3 - ((rock + cur) % 3) /* CHOOSE LONGEST BRICK-FREE LANE*/\\n        break\\n      }\\n      i++\\n    }\\n  }\\n  return jumps\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction minSideJumps(obstacles) {\\n  const n = obstacles.length - 1\\n  let jumps = 0\\n  let cur = 2\\n  for (let i = 1; i < n; i++) {\\n    if (obstacles[i] != cur) continue\\n    jumps++ /* JUMPS ++ */\\n    if (obstacles[i - 1]) {\\n      cur = 3 - ((obstacles[i - 1] + cur) % 3) /* MAKE A JUMP IF ONLY 1 AVALIABLE */\\n      continue\\n    }\\n    while (i < n) {\\n      let rock = obstacles[i]\\n      if (rock != 0 && rock != cur) {\\n        cur = 3 - ((rock + cur) % 3) /* CHOOSE LONGEST BRICK-FREE LANE*/\\n        break\\n      }\\n      i++\\n    }\\n  }\\n  return jumps\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1177860,
                "title": "java-recursion-memoization",
                "content": "\\n```\\n public int minSideJumps(int[] obstacles) {\\n        int dp[][]=new int[obstacles.length][4];\\n        for(int arr[]:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(obstacles,obstacles.length,0,2,dp);\\n    }\\n    \\n    private int helper(int obstacles[],int length,int start,int lane,int [][]dp){\\n        /* if the last element is reached return*/\\n        if(start==length-1){\\n            return 0;\\n        }\\n        \\n        if(dp[start][lane]!=-1){\\n            return dp[start][lane];\\n        }\\n        \\n        /*if the next element in the current lane doesnot have a obstacle\\n        continue in the same lane*/\\n        if(lane!=obstacles[start+1]){ \\n            return dp[start][lane]= helper(obstacles,length,start+1,lane,dp);\\n        }\\n        /*if the lane is 1 and the 2 and 3 doesnot contain obstacle then\\n        traverse those path and return the minimum value similarly for all other*/\\n        else{\\n            int jump1=0;\\n            int jump2=0;\\n             if(lane==1){\\n                 if(obstacles[start]!=2){\\n                     jump1=1+helper(obstacles,length,start+1,2,dp);\\n                 }\\n                 if(obstacles[start]!=3){\\n                     jump2=1+helper(obstacles,length,start+1,3,dp);\\n                 }\\n                 return dp[start][lane]= min(jump1,jump2);\\n             }\\n            else if(lane==2){\\n                 if(obstacles[start]!=1){\\n                     jump1=1+helper(obstacles,length,start+1,1,dp);\\n                 }\\n                 if(obstacles[start]!=3){\\n                     jump2=1+helper(obstacles,length,start+1,3,dp);\\n                 }\\n                 return dp[start][lane]=  min(jump1,jump2);\\n            }\\n            else{\\n                 if(obstacles[start]!=1){\\n                     jump1=1+helper(obstacles,length,start+1,1,dp);\\n                 }\\n                 if(obstacles[start]!=2){\\n                     jump2=1+helper(obstacles,length,start+1,2,dp);\\n                 }\\n                return dp[start][lane]=  min(jump1,jump2);\\n            }\\n            \\n        }\\n                \\n    }\\n    \\n    private int min(int jump1,int jump2){\\n        \\n        if(jump1==0 && jump2==0){\\n            return 0;\\n        }\\n        else if(jump1==0){\\n            return jump2;\\n        }\\n        else if(jump2==0){\\n            return jump1;\\n        }\\n        else{\\n            return Math.min(jump1,jump2);\\n        }\\n        \\n        \\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "\\n```\\n public int minSideJumps(int[] obstacles) {\\n        int dp[][]=new int[obstacles.length][4];\\n        for(int arr[]:dp){\\n            Arrays.fill(arr,-1);\\n        }\\n        return helper(obstacles,obstacles.length,0,2,dp);\\n    }\\n    \\n    private int helper(int obstacles[],int length,int start,int lane,int [][]dp){\\n        /* if the last element is reached return*/\\n        if(start==length-1){\\n            return 0;\\n        }\\n        \\n        if(dp[start][lane]!=-1){\\n            return dp[start][lane];\\n        }\\n        \\n        /*if the next element in the current lane doesnot have a obstacle\\n        continue in the same lane*/\\n        if(lane!=obstacles[start+1]){ \\n            return dp[start][lane]= helper(obstacles,length,start+1,lane,dp);\\n        }\\n        /*if the lane is 1 and the 2 and 3 doesnot contain obstacle then\\n        traverse those path and return the minimum value similarly for all other*/\\n        else{\\n            int jump1=0;\\n            int jump2=0;\\n             if(lane==1){\\n                 if(obstacles[start]!=2){\\n                     jump1=1+helper(obstacles,length,start+1,2,dp);\\n                 }\\n                 if(obstacles[start]!=3){\\n                     jump2=1+helper(obstacles,length,start+1,3,dp);\\n                 }\\n                 return dp[start][lane]= min(jump1,jump2);\\n             }\\n            else if(lane==2){\\n                 if(obstacles[start]!=1){\\n                     jump1=1+helper(obstacles,length,start+1,1,dp);\\n                 }\\n                 if(obstacles[start]!=3){\\n                     jump2=1+helper(obstacles,length,start+1,3,dp);\\n                 }\\n                 return dp[start][lane]=  min(jump1,jump2);\\n            }\\n            else{\\n                 if(obstacles[start]!=1){\\n                     jump1=1+helper(obstacles,length,start+1,1,dp);\\n                 }\\n                 if(obstacles[start]!=2){\\n                     jump2=1+helper(obstacles,length,start+1,2,dp);\\n                 }\\n                return dp[start][lane]=  min(jump1,jump2);\\n            }\\n            \\n        }\\n                \\n    }\\n    \\n    private int min(int jump1,int jump2){\\n        \\n        if(jump1==0 && jump2==0){\\n            return 0;\\n        }\\n        else if(jump1==0){\\n            return jump2;\\n        }\\n        else if(jump2==0){\\n            return jump1;\\n        }\\n        else{\\n            return Math.min(jump1,jump2);\\n        }\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1173870,
                "title": "python-o-n-dp",
                "content": "```\\nclass Solution(object):\\n\\n    def minSideJumps(self, obs) :\\n        dp = [1,0,1]\\n        for i in range(1,len(obs)-1):\\n            if obs[i] != 0:\\n                dp[obs[i]-1] = 1000000         \\n            if obs[i]-1 != 0:\\n                if dp[0]!= 1000000:\\n                    dp[0] = min(dp[0],dp[1]+1,dp[2]+1)\\n                else:\\n                    dp[0] = min(dp[1]+1,dp[2]+1)\\n            if obs[i]-1 != 1:\\n                if dp[1]!= 1000000:\\n                    dp[1] = min(dp[0]+1, dp[1], dp[2]+1)\\n                else:\\n                    dp[1] = min(dp[0]+1, dp[2]+1)\\n            if obs[i]-1 != 2: \\n                if dp[2]!= 1000000:\\n                    dp[2] = min(dp[0]+1, dp[1]+1, dp[2])\\n                else:\\n                    dp[2] = min(dp[0]+1, dp[1]+1)\\n            \\n        return min(dp)\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n\\n    def minSideJumps(self, obs) :\\n        dp = [1,0,1]\\n        for i in range(1,len(obs)-1):\\n            if obs[i] != 0:\\n                dp[obs[i]-1] = 1000000         \\n            if obs[i]-1 != 0:\\n                if dp[0]!= 1000000:\\n                    dp[0] = min(dp[0],dp[1]+1,dp[2]+1)\\n                else:\\n                    dp[0] = min(dp[1]+1,dp[2]+1)\\n            if obs[i]-1 != 1:\\n                if dp[1]!= 1000000:\\n                    dp[1] = min(dp[0]+1, dp[1], dp[2]+1)\\n                else:\\n                    dp[1] = min(dp[0]+1, dp[2]+1)\\n            if obs[i]-1 != 2: \\n                if dp[2]!= 1000000:\\n                    dp[2] = min(dp[0]+1, dp[1]+1, dp[2])\\n                else:\\n                    dp[2] = min(dp[0]+1, dp[1]+1)\\n            \\n        return min(dp)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165485,
                "title": "c-memoization-solution-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[500001][4];\\n    \\n    int go(int pos,int lane,vector<int>& A){\\n        if(pos>=A.size())return 0;\\n        if(A[pos]==lane)return 1e8;\\n        \\n        if(dp[pos][lane]!=-1)\\n            return dp[pos][lane];\\n        \\n        long long int ans=go(pos+1,lane,A);\\n        for(int pos_lane=1;pos_lane<=3;pos_lane++){\\n            if(lane==pos_lane){\\n                continue;\\n            }\\n            else if(A[pos]!=pos_lane){\\n                ans=min(ans,(long long int)(1ll+(long long int)go(pos+1,pos_lane,A)));\\n            }\\n        }\\n        \\n        return dp[pos][lane]=ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp,-1,sizeof(dp));\\n        return go(0,2,obstacles);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[500001][4];\\n    \\n    int go(int pos,int lane,vector<int>& A){\\n        if(pos>=A.size())return 0;\\n        if(A[pos]==lane)return 1e8;\\n        \\n        if(dp[pos][lane]!=-1)\\n            return dp[pos][lane];\\n        \\n        long long int ans=go(pos+1,lane,A);\\n        for(int pos_lane=1;pos_lane<=3;pos_lane++){\\n            if(lane==pos_lane){\\n                continue;\\n            }\\n            else if(A[pos]!=pos_lane){\\n                ans=min(ans,(long long int)(1ll+(long long int)go(pos+1,pos_lane,A)));\\n            }\\n        }\\n        \\n        return dp[pos][lane]=ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp,-1,sizeof(dp));\\n        return go(0,2,obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161090,
                "title": "python-solution-minimum-sideway-jumps",
                "content": "\\nTo represent stones we put \\'inf\\'.\\nRepresenting the min jumps required at each lane using variables : lane1,lane2,lane3.\\n\\nEg :[0,1,2,3,0]\\nstep 1:  at i=0 ,Minimum no.of jumps required to reach lane 1 or lane 3 will be 1 since we start from lane 2.\\nlane1 = |1|\\nlane2 = |0|\\nlane3 = |1|\\nstep 2: now at i=1, lane 1 has obstacle so we assign value infinity to it .and now we dont want to consider lane 1 so we make lane1_yes = False. \\nwe keep lane2 and lane3s value same .\\nlane 1 =| 1 | inf|\\nlane2 = | 0 | 0  |\\nlane3 = | 1 | 1  |\\nNow we need to find minimum no.of jumps to reach lane 2 and lane 3.\\nto reach lane 2 we can either come from same row or we can make a jump from lane 1 to lane 2 or make a  jump from lane 3 to lane 2 .\\nhence *lane2 = min(lane2,min(lane1+1,lane3+1))*.similarly for lane3.\\nfinally \\nlane 1 =| 1 | inf|\\nlane2 = | 0 | 0  |\\nlane3 = | 1 | 1  |\\n\\ni=3 \\nlane 1 =| 1 | inf|inf|     \\nlane2 = | 0 | 0  |inf|\\nlane3 = | 1 | 1  |1|\\n\\nnow finding minimum at i=3\\nlane 1 =| 1 | inf| 2 |     \\nlane2 = | 0 | 0  |inf|\\nlane3 = | 1 | 1  | 1 |.\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:    \\n            \\n        n = len(obstacles)\\n        inf = sys.maxsize\\n        \\n        lane1,lane2,lane3 = 1,0,1\\n        \\n        for indx in range(1,n):\\n            lane1_yes,lane2_yes,lane3_yes = True,True,True\\n            if obstacles[indx] == 1:\\n                lane1 = inf\\n                lane1_yes = False\\n            elif obstacles[indx] == 2:\\n                lane2 = inf\\n                lane2_yes = False\\n            elif obstacles[indx] == 3:\\n                lane3 = inf\\n                lane3_yes = False\\n            \\n            \\n            if lane1_yes:\\n                lane1 = min(lane1,min(lane2+1,lane3+1))\\n            if lane2_yes:\\n                lane2 = min(lane2,min(lane1+1,lane3+1))\\n            if lane3_yes:\\n                lane3 = min(lane3,min(lane1+1,lane2+1))\\n        return min(lane3,min(lane1,lane2))\\n            \\n        \\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:    \\n            \\n        n = len(obstacles)\\n        inf = sys.maxsize\\n        \\n        lane1,lane2,lane3 = 1,0,1\\n        \\n        for indx in range(1,n):\\n            lane1_yes,lane2_yes,lane3_yes = True,True,True\\n            if obstacles[indx] == 1:\\n                lane1 = inf\\n                lane1_yes = False\\n            elif obstacles[indx] == 2:\\n                lane2 = inf\\n                lane2_yes = False\\n            elif obstacles[indx] == 3:\\n                lane3 = inf\\n                lane3_yes = False\\n            \\n            \\n            if lane1_yes:\\n                lane1 = min(lane1,min(lane2+1,lane3+1))\\n            if lane2_yes:\\n                lane2 = min(lane2,min(lane1+1,lane3+1))\\n            if lane3_yes:\\n                lane3 = min(lane3,min(lane1+1,lane2+1))\\n        return min(lane3,min(lane1,lane2))\\n            \\n        \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157132,
                "title": "simple-solution-in-python-with-some-comments",
                "content": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # so let me try to explain\\n        # scan over the obstacles and keep track when the point is reached when you\\'ve  \\n        # encountered at least one boulder in each unique lane (multiple boulders in the same lane don\\'t count)\\n        # this means you need to sidejump at one place to get beyond this point\\n        # start again from this point onwards\\n        # keep doing this until you\\'re at the finish\\n        \\n        O = obstacles\\n        N = len(O)\\n\\n        # this means one boulder encountered in lane 1 and lane 3\\n        # this is a special starting condition to account for the requirement you start in lane 2\\n        L = [True, False, True]\\n        i = 0 # point 0\\n        s = 0 # amount of sidejumps\\n        \\n        while i < N: # while not at end\\n            if O[i] == 0: # no boulder means do nothing just move on\\n                i += 1\\n                continue\\n                \\n            L[O[i] - 1] = True # boulder encountered and take note\\n\\n            # if you\\'ve encountered three boulders\\n            if all(L):\\n                i -= 1         # start again one place before the third boulder\\n                L  = [False, False, False] # reinitialize array L so no boulders accounted for at this point\\n                s += 1         # one jump needed\\n                continue\\n                \\n            i += 1 # next\\n            \\n        return s # return sidejumps needed\\n```\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # so let me try to explain\\n        # scan over the obstacles and keep track when the point is reached when you\\'ve  \\n        # encountered at least one boulder in each unique lane (multiple boulders in the same lane don\\'t count)\\n        # this means you need to sidejump at one place to get beyond this point\\n        # start again from this point onwards\\n        # keep doing this until you\\'re at the finish\\n        \\n        O = obstacles\\n        N = len(O)\\n\\n        # this means one boulder encountered in lane 1 and lane 3\\n        # this is a special starting condition to account for the requirement you start in lane 2\\n        L = [True, False, True]\\n        i = 0 # point 0\\n        s = 0 # amount of sidejumps\\n        \\n        while i < N: # while not at end\\n            if O[i] == 0: # no boulder means do nothing just move on\\n                i += 1\\n                continue\\n                \\n            L[O[i] - 1] = True # boulder encountered and take note\\n\\n            # if you\\'ve encountered three boulders\\n            if all(L):\\n                i -= 1         # start again one place before the third boulder\\n                L  = [False, False, False] # reinitialize array L so no boulders accounted for at this point\\n                s += 1         # one jump needed\\n                continue\\n                \\n            i += 1 # next\\n            \\n        return s # return sidejumps needed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155503,
                "title": "c-avoiding-stackoverflow-runtime-error-recursive-dp-o-n",
                "content": "You might be having some difficulty in avoiding the runtime error, so here\\'s the solution. What I have done here basically is ran the loop backwards and called the function *f* this ensured that there are not many states in the stack at a time, hence controlling the expansion of the implicit stack. Slowly, the *dp* values in the memoized container built up, thus controlling the expansion in the futher calls.\\n\\nIf you have any difficulty in understanding the code, please let me know I\\'ll try to get back as soon as I can.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> grid(n,vector<int>(3));\\n        for(int i=0;i<n;i++){\\n            if(obstacles[i]==0) continue;\\n            grid[i][obstacles[i]-1]=1;\\n        }\\n        int inf = 1e9;\\n        \\n        vector<vector<int>> dp(n,vector<int>(3,-1));\\n        \\n        std::function<int(int,int)> f = [&](int i, int lane){\\n            if(dp[i][lane]!=-1) return dp[i][lane];\\n            if(i+1<n){\\n                int l1,l2;\\n                if(lane==0){\\n                    l1=1;\\n                    l2=2;\\n                }\\n                else if(lane==1){\\n                    l1=0;\\n                    l2=2;\\n                }\\n                else if(lane==2){\\n                    l1=0;\\n                    l2=1;\\n                }\\n                return dp[i][lane] = min({\\n                    grid[i+1][lane]==0?f(i+1,lane):inf,\\n                    (grid[i][l1]==0 && grid[i+1][l1]==0)?1+f(i+1,l1):inf,\\n                    (grid[i][l2]==0 && grid[i+1][l2]==0)?1+f(i+1,l2):inf\\n                });\\n            }\\n            else return dp[i][lane] = 0;\\n        };\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<=2;j++){\\n                if(grid[i][j]==0){\\n                    f(i,j);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> grid(n,vector<int>(3));\\n        for(int i=0;i<n;i++){\\n            if(obstacles[i]==0) continue;\\n            grid[i][obstacles[i]-1]=1;\\n        }\\n        int inf = 1e9;\\n        \\n        vector<vector<int>> dp(n,vector<int>(3,-1));\\n        \\n        std::function<int(int,int)> f = [&](int i, int lane){\\n            if(dp[i][lane]!=-1) return dp[i][lane];\\n            if(i+1<n){\\n                int l1,l2;\\n                if(lane==0){\\n                    l1=1;\\n                    l2=2;\\n                }\\n                else if(lane==1){\\n                    l1=0;\\n                    l2=2;\\n                }\\n                else if(lane==2){\\n                    l1=0;\\n                    l2=1;\\n                }\\n                return dp[i][lane] = min({\\n                    grid[i+1][lane]==0?f(i+1,lane):inf,\\n                    (grid[i][l1]==0 && grid[i+1][l1]==0)?1+f(i+1,l1):inf,\\n                    (grid[i][l2]==0 && grid[i+1][l2]==0)?1+f(i+1,l2):inf\\n                });\\n            }\\n            else return dp[i][lane] = 0;\\n        };\\n        \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=0;j<=2;j++){\\n                if(grid[i][j]==0){\\n                    f(i,j);\\n                }\\n            }\\n        }\\n        return dp[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154884,
                "title": "simple-dp-tabulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obst) {\\n        int dp[500005][4];\\n        memset(dp , 0 , sizeof(dp));\\n        \\n        int n = obst.size();\\n        dp[n-1][1] = dp[n-1][2] = dp[n-1][3] = 0;\\n        \\n        dp[n-1][obst[n-1]] = INT_MAX;\\n        \\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            dp[i][obst[i]] = INT_MAX;\\n            \\n            if(dp[i][1] != INT_MAX )   dp[i][1] = dp[i+1][1] == INT_MAX ? min(max(dp[i][2],dp[i+1][2]) , max(dp[i][3] , dp[i+1][3])) + 1 : dp[i+1][1];\\n            if(dp[i][2] != INT_MAX )   dp[i][2] = dp[i+1][2] == INT_MAX ? min(max(dp[i][1],dp[i+1][1]) , max(dp[i][3] , dp[i+1][3])) + 1 : dp[i+1][2];\\n            if(dp[i][3] != INT_MAX )   dp[i][3] = dp[i+1][3] == INT_MAX ? min(max(dp[i][2],dp[i+1][2]) , max(dp[i][1] , dp[i+1][1])) + 1 : dp[i+1][3];\\n            \\n        }   \\n        return dp[0][2];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSideJumps(vector<int>& obst) {\\n        int dp[500005][4];\\n        memset(dp , 0 , sizeof(dp));\\n        \\n        int n = obst.size();\\n        dp[n-1][1] = dp[n-1][2] = dp[n-1][3] = 0;\\n        \\n        dp[n-1][obst[n-1]] = INT_MAX;\\n        \\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            dp[i][obst[i]] = INT_MAX;\\n            \\n            if(dp[i][1] != INT_MAX )   dp[i][1] = dp[i+1][1] == INT_MAX ? min(max(dp[i][2],dp[i+1][2]) , max(dp[i][3] , dp[i+1][3])) + 1 : dp[i+1][1];\\n            if(dp[i][2] != INT_MAX )   dp[i][2] = dp[i+1][2] == INT_MAX ? min(max(dp[i][1],dp[i+1][1]) , max(dp[i][3] , dp[i+1][3])) + 1 : dp[i+1][2];\\n            if(dp[i][3] != INT_MAX )   dp[i][3] = dp[i+1][3] == INT_MAX ? min(max(dp[i][2],dp[i+1][2]) , max(dp[i][1] , dp[i+1][1])) + 1 : dp[i+1][3];\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1154639,
                "title": "simple-dp-top-down-approach-well-explained-naive-approach",
                "content": "EXPLANATION:\\nsuppose you are in any lane l and index i the simplest move is to move to index i+1 of lane l without taking any jumps but this is possible only if the the next index in the current lane is not an obstacle. \\nin the absence of an obstacle we move to lane,index+1\\nOtherwise we have two possible option \\njump to one of the two remaining lanes but for this we first check if there is n obstacle or not \\nie: if you are at index i and lane 2 we can jump to index i lane 1 (if there is no obstacle at this place ) or we can jump at index i lane 3 again considering that there should not be an obstacle. \\nincase both these lanes dont have an obstacle we take the minimum fo the two result:)\\n```class Solution {\\npublic: \\n    int helper(vector<int>&ob,int lane,int index,vector<vector<int>>&dp)\\n    {   if(dp[index][lane]!=1000000007)\\n          return dp[index][lane];\\n        if(index>=ob.size()-1)\\n          return dp[index][lane]=0;\\n        if(ob[index+1]!=lane)\\n          dp[index][lane]=helper(ob,lane,index+1,dp);\\n        else\\n        {   if(lane==1 && ob[index]!=2)                  //currently in lane 1\\n            dp[index][1]=min(dp[index][1],helper(ob,2,index,dp)+1);\\n            if(lane==1 && ob[index]!=3)\\n            dp[index][1]=min(dp[index][1],helper(ob,3,index,dp)+1);\\n         \\n            if(lane==2 && ob[index]!=1)                  //currently in lane 2\\n            dp[index][2]=min(dp[index][2],helper(ob,1,index,dp)+1);\\n            if(lane==2 && ob[index]!=3)\\n            dp[index][2]=min(dp[index][2],helper(ob,3,index,dp)+1);\\n         \\n            if(lane==3 && ob[index]!=1)                 //currently in lane 3\\n            dp[index][3]=min(dp[index][3],helper(ob,1,index,dp)+1);\\n            if(lane==3 && ob[index]!=2)\\n            dp[index][3]=min(dp[index][3],helper(ob,2,index,dp)+1);\\n                   \\n        }\\n        return dp[index][lane];\\n    }\\n    int minSideJumps(vector<int>& ob) {\\n         int n=ob.size();\\n         vector<vector<int>>dp(n,vector<int>(4,1000000007));\\n         int result=helper(ob,2,0,dp);         \\n         return result;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic: \\n    int helper(vector<int>&ob,int lane,int index,vector<vector<int>>&dp)\\n    {   if(dp[index][lane]!=1000000007)\\n          return dp[index][lane];\\n        if(index>=ob.size()-1)\\n          return dp[index][lane]=0;\\n        if(ob[index+1]!=lane)\\n          dp[index][lane]=helper(ob,lane,index+1,dp);\\n        else\\n        {   if(lane==1 && ob[index]!=2)                  //currently in lane 1\\n            dp[index][1]=min(dp[index][1],helper(ob,2,index,dp)+1);\\n            if(lane==1 && ob[index]!=3)\\n            dp[index][1]=min(dp[index][1],helper(ob,3,index,dp)+1);\\n         \\n            if(lane==2 && ob[index]!=1)                  //currently in lane 2\\n            dp[index][2]=min(dp[index][2],helper(ob,1,index,dp)+1);\\n            if(lane==2 && ob[index]!=3)\\n            dp[index][2]=min(dp[index][2],helper(ob,3,index,dp)+1);\\n         \\n            if(lane==3 && ob[index]!=1)                 //currently in lane 3\\n            dp[index][3]=min(dp[index][3],helper(ob,1,index,dp)+1);\\n            if(lane==3 && ob[index]!=2)\\n            dp[index][3]=min(dp[index][3],helper(ob,2,index,dp)+1);\\n                   \\n        }\\n        return dp[index][lane];\\n    }\\n    int minSideJumps(vector<int>& ob) {\\n         int n=ob.size();\\n         vector<vector<int>>dp(n,vector<int>(4,1000000007));\\n         int result=helper(ob,2,0,dp);         \\n         return result;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1154531,
                "title": "solved-using-dfs-and-memoiziation-java",
                "content": "```\\nclass Solution {\\n    //All possible directions to go up and down. Some could become invalid which we will check\\n    int[] directions = new int[]{1, 2, -1, -2};\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        //We will this array to eleminate solving sub problems repetedly\\n        int[][] memo = new int[obstacles.length][4];\\n        //-1 represents no value found\\n        for(int[] m : memo) {\\n            Arrays.fill(m, -1);\\n        }\\n        //let\\'s solve by dfs\\n        return dfs(obstacles, 0, 2, memo);\\n    }\\n    \\n    private int dfs(int[] obstacles, int curPoint, int lane, int[][] memo) {\\n        //we are one point behind n and there wont be any obstacles in n as problem defins. So we can stop here\\n        if(curPoint+1 == obstacles.length) {\\n            return 0;\\n        }\\n        \\n        //We already calculatted this, so just return\\n        if(memo[curPoint][lane] > -1) {\\n            return memo[curPoint][lane];\\n        }\\n        \\n        int result;\\n        if(obstacles[curPoint+1] != lane) { //We can move to next point since there is no blocker\\n            result = dfs(obstacles, curPoint+1, lane, memo);//Moved to next point in same lane\\n        } else {\\n            //There is blocker so we need to go to other lane in same point\\n            result = Integer.MAX_VALUE;\\n            for(int jumpDir : directions) {\\n                int newLane = lane + jumpDir;\\n                //Check if it is within lane 1-3 and that has no blocker\\n                if(1 <= newLane && newLane <= 3 && obstacles[curPoint] != newLane) {\\n                    result = Math.min(result, 1+dfs(obstacles, curPoint, newLane, memo)); //jumped to different lane in same point\\n                }\\n            }\\n        }\\n        \\n        //Remeber this best decession for the given point and lane\\n        memo[curPoint][lane] = result;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    //All possible directions to go up and down. Some could become invalid which we will check\\n    int[] directions = new int[]{1, 2, -1, -2};\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        //We will this array to eleminate solving sub problems repetedly\\n        int[][] memo = new int[obstacles.length][4];\\n        //-1 represents no value found\\n        for(int[] m : memo) {\\n            Arrays.fill(m, -1);\\n        }\\n        //let\\'s solve by dfs\\n        return dfs(obstacles, 0, 2, memo);\\n    }\\n    \\n    private int dfs(int[] obstacles, int curPoint, int lane, int[][] memo) {\\n        //we are one point behind n and there wont be any obstacles in n as problem defins. So we can stop here\\n        if(curPoint+1 == obstacles.length) {\\n            return 0;\\n        }\\n        \\n        //We already calculatted this, so just return\\n        if(memo[curPoint][lane] > -1) {\\n            return memo[curPoint][lane];\\n        }\\n        \\n        int result;\\n        if(obstacles[curPoint+1] != lane) { //We can move to next point since there is no blocker\\n            result = dfs(obstacles, curPoint+1, lane, memo);//Moved to next point in same lane\\n        } else {\\n            //There is blocker so we need to go to other lane in same point\\n            result = Integer.MAX_VALUE;\\n            for(int jumpDir : directions) {\\n                int newLane = lane + jumpDir;\\n                //Check if it is within lane 1-3 and that has no blocker\\n                if(1 <= newLane && newLane <= 3 && obstacles[curPoint] != newLane) {\\n                    result = Math.min(result, 1+dfs(obstacles, curPoint, newLane, memo)); //jumped to different lane in same point\\n                }\\n            }\\n        }\\n        \\n        //Remeber this best decession for the given point and lane\\n        memo[curPoint][lane] = result;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154248,
                "title": "python3-dp-o-n-time-o-1-space-no-modulo",
                "content": "```\\n        N = len(obstacles)\\n        dp = [float(\\'inf\\')] * 3\\n        dp[1] = 0\\n        for obs in obstacles:\\n            if obs:\\n                dp[obs - 1] = float(\\'inf\\')\\n            cur = min(dp)\\n            for i in range(3):\\n                if i != (obs - 1):\\n                    dp[i] = min(dp[i], cur + 1)\\n        return min(dp)\\n```",
                "solutionTags": [],
                "code": "```\\n        N = len(obstacles)\\n        dp = [float(\\'inf\\')] * 3\\n        dp[1] = 0\\n        for obs in obstacles:\\n            if obs:\\n                dp[obs - 1] = float(\\'inf\\')\\n            cur = min(dp)\\n            for i in range(3):\\n                if i != (obs - 1):\\n                    dp[i] = min(dp[i], cur + 1)\\n        return min(dp)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153984,
                "title": "javascript-bottom-up-dp-tabulation-100-100",
                "content": "## Understanding the logic\\n\\nThe idea is to create a table storing the minimum side jumps required to reach a particular lane of a particular index.\\n\\nSuppose index is denoted by i (0 <= i < obstacle.length) and lane is denoted by j (1, 2, 3).\\ndp[i][j] denotes the minimum side jumps to reach index i and lane j\\nTo find the value of dp[i][j] there are 3 different paths from the previous index(i-1) to reach [i][j].\\n**dp[i][j] = Math.min(path1, path2, path3)**\\n\\nInitially I am assigning **dp[i][j] = Infinity**; when there is an obstacle present at index i, lane j. To preserve the obstacle data I am simply adding dp[i][j] with itself.**Hence, dp[i][j] = dp[i][j] + Math.min(path1, path2, path3)**\\n\\n**Example: say, i = 3; j = 1\\nthen path1 = dp[i-1][1] + 0 side jump (since we are not changing lanes)\\npath2 =  dp[i-1][2] + 1 side jump (if there is no obstacle at [i][2]); else + 2 side jumps\\npath3 = dp[i-1][3] + 1 side jump (if there is no obstacle at [i][3]); else + 2 side jumps**\\n\\n\\n## Code\\n```\\nlet minSideJumps = function (obstacle){\\n\\tlet dp = new Array (obstacle.length);\\n\\tfor(let i = 0; i < obstacle.length; i++){\\n\\t\\tdp[i] = new Array(4).fill(0);\\n\\t\\tdp[i][obstacle[i]] = Infinity;\\n\\t}\\n\\t// Initial State\\n\\tdp[0][1] = 1;\\n\\tdp[0][2] = 0;\\n\\tdp[0][3] = 1;\\n\\tfor(let i = 1; i < dp.length; i++){\\n\\t\\tfor(let j = 1; j < 4; j++){\\n\\t\\t\\tvalue1 = j === 1 ? dp[i-1][1] : (obstacle[i] === 1 ? dp[i-1][1]+2 : dp[i-1][1]+1)\\n\\t\\t\\tvalue2 = j === 2 ? dp[i-1][2] : (obstacle[i] === 2 ? dp[i-1][2]+2 : dp[i-1][2]+1)\\n\\t\\t\\tvalue3 = j === 3 ? dp[i-1][3] : (obstacle[i] === 3 ? dp[i-1][3]+2 : dp[i-1][3]+1)\\n\\t\\t\\tdp[i][j] += Math.min(value3, value2, value1);\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(...dp[dp.length-1]);\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nlet minSideJumps = function (obstacle){\\n\\tlet dp = new Array (obstacle.length);\\n\\tfor(let i = 0; i < obstacle.length; i++){\\n\\t\\tdp[i] = new Array(4).fill(0);\\n\\t\\tdp[i][obstacle[i]] = Infinity;\\n\\t}\\n\\t// Initial State\\n\\tdp[0][1] = 1;\\n\\tdp[0][2] = 0;\\n\\tdp[0][3] = 1;\\n\\tfor(let i = 1; i < dp.length; i++){\\n\\t\\tfor(let j = 1; j < 4; j++){\\n\\t\\t\\tvalue1 = j === 1 ? dp[i-1][1] : (obstacle[i] === 1 ? dp[i-1][1]+2 : dp[i-1][1]+1)\\n\\t\\t\\tvalue2 = j === 2 ? dp[i-1][2] : (obstacle[i] === 2 ? dp[i-1][2]+2 : dp[i-1][2]+1)\\n\\t\\t\\tvalue3 = j === 3 ? dp[i-1][3] : (obstacle[i] === 3 ? dp[i-1][3]+2 : dp[i-1][3]+1)\\n\\t\\t\\tdp[i][j] += Math.min(value3, value2, value1);\\n\\t\\t}\\n\\t}\\n\\treturn Math.min(...dp[dp.length-1]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153722,
                "title": "javascript-dp",
                "content": "Not a whole lot of things to consider here, just need to understand the problem and figure out how to deal\\nwith the few conditions it presents.\\n1. We start from lane 2, so set the starting cost for lanes 1 and 3 to ```MAX``` so we\\'re forced to jump from lane 2 if we want to use them.\\n2. At each turn, find the minimum cost for each lane to either stay in the same lane, or jump from one of the other two lanes.\\n    - If the current lane is an obstacle, the cost should be ```MAX``` because we can\\'t reach it\\n    - If the current lane was the last obstacle, and the lane we\\'re trying to get to it from is the current obstacle, we have to jump in a zigzag pattern to get to it, which requires an extra jump, \\n        ```\\n\\t    // to get from lane 1 to lane 2, we have to jump to lane 3, then lane 2\\n\\t    [-, x, -]\\n\\t    [x, -, -]\\n\\t    ```\\n3. Normal DP things like we don\\'t need an entire table for this, just the last two rows. Really only need variables, but maybe it\\'s a little cleaner with arrays.\\n```\\nvar minSideJumps = function (obstacles) {\\n  // pretty unnecessary, but use a MAX number <= 2 ** 31 and array literals to get packed SMIs\\n  const MAX = 10 ** 6;\\n  let current = [MAX, 0, MAX];\\n  let next = [0, 0, 0];\\n  let lastLaneBlocked = -1;\\n\\n  for (let i = 1; i < obstacles.length; i += 1) {\\n    // could just increase the size of current / next by one\\n    const laneBlocked = obstacles[i] - 1;\\n    for (let currentLane = 0; currentLane < 3; currentLane += 1) {\\n      next[currentLane] = MAX;\\n      if (laneBlocked === currentLane) continue;\\n\\n      for (let previousLane = 0; previousLane < 3; previousLane += 1) {\\n        const jumpCost = currentLane === previousLane ? 0 : 1;\\n\\t\\t// if this lane was blocked last time, they couldn\\'t jump to it to switch\\n\\t\\t// last turn, so would require an extra jump to get here\\n        const extraJump = lastLaneBlocked === currentLane && laneBlocked === previousLane ? 1 : 0;\\n        next[currentLane] = Math.min(\\n          next[currentLane],\\n          current[previousLane] + jumpCost + extraJump,\\n        );\\n      }\\n    }\\n\\n    lastLaneBlocked = laneBlocked;\\n    [current, next] = [next, current];\\n  }\\n\\n  return Math.min(...current);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```MAX```\n```MAX```\n```\\n\\t    // to get from lane 1 to lane 2, we have to jump to lane 3, then lane 2\\n\\t    [-, x, -]\\n\\t    [x, -, -]\\n\\t    ```\n```\\nvar minSideJumps = function (obstacles) {\\n  // pretty unnecessary, but use a MAX number <= 2 ** 31 and array literals to get packed SMIs\\n  const MAX = 10 ** 6;\\n  let current = [MAX, 0, MAX];\\n  let next = [0, 0, 0];\\n  let lastLaneBlocked = -1;\\n\\n  for (let i = 1; i < obstacles.length; i += 1) {\\n    // could just increase the size of current / next by one\\n    const laneBlocked = obstacles[i] - 1;\\n    for (let currentLane = 0; currentLane < 3; currentLane += 1) {\\n      next[currentLane] = MAX;\\n      if (laneBlocked === currentLane) continue;\\n\\n      for (let previousLane = 0; previousLane < 3; previousLane += 1) {\\n        const jumpCost = currentLane === previousLane ? 0 : 1;\\n\\t\\t// if this lane was blocked last time, they couldn\\'t jump to it to switch\\n\\t\\t// last turn, so would require an extra jump to get here\\n        const extraJump = lastLaneBlocked === currentLane && laneBlocked === previousLane ? 1 : 0;\\n        next[currentLane] = Math.min(\\n          next[currentLane],\\n          current[previousLane] + jumpCost + extraJump,\\n        );\\n      }\\n    }\\n\\n    lastLaneBlocked = laneBlocked;\\n    [current, next] = [next, current];\\n  }\\n\\n  return Math.min(...current);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1153673,
                "title": "java-recursion-and-memo",
                "content": "Consider all possible paths.\\n```\\n// i -> 0 indexed x coordinate\\n// j -> 0 indexed y coordinate\\n// arr[i] = j   ==>  There is an obstacle at point (i,j)\\n// arr[i] = -1  ==>  There is no obstacle at x = i\\nclass Solution\\n{\\n    int[][] minJumps;  // Memo to store min jumps required from (i,j)\\n    int[] arr;         // Input\\n    int n;             // length of arr\\n    int solve(int i, int j)\\n    {\\n\\t    if(i>=n-1)    // If i>=n-1, you have reached or crossed the last point (here n is taken as length of the array).\\n        {\\n            return 0;\\n        }\\n        if(i<0 || j<0 || j>2 || arr[i]==j)  // base cases, out of bounds or land on obstacle (so not a valid path and hence return max_value).\\n            return 1000000;\\n        if(minJumps[i][j]!=1000000)   // If min jumps from (i,j) already known simply return it.\\n            return minJumps[i][j];\\n\\t\\t// Moving towards +ve x\\n        if(i+1<n && arr[i+1]!=j)      // Moving right possible if one to the right of current point is not an obstacle.\\n            minJumps[i][j] = Math.min(minJumps[i][j], solve(i+1,j));\\n        // Below are different cases of moving up and down on the same x coordinate by 1 or 2 units based on only condition that do not land on obstacle.\\n        if(j==0)    // point has y coordinate = 0\\n        {\\n            if(arr[i]!=1)   // If y = 1 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,1) + 1);\\n            if(arr[i]!=2)   // If y = 2 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,2) + 1);\\n        }\\n\\t\\telse if(j==1)  // point has y coordinate = 1\\n        {\\n            if(arr[i]!=0)  // If y = 0 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,0) + 1);\\n            if(arr[i]!=2)  // If y = 2 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,2) + 1);\\n        }\\n        else if(j==2)   // point has y coordinate = 2\\n        {\\n            if(arr[i]!=1)  // If y = 1 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,1) + 1);\\n            if(arr[i]!=0)  // If y = 0 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,0) + 1);\\n        }\\n        return minJumps[i][j];  // Return answer stored as minimum of all possible cases.\\n    }\\n    public int minSideJumps(int[] arr)\\n    {\\n        this.n = arr.length;\\n        this.arr = arr;\\n        this.minJumps = new int[n][3];\\n        for(int i=0; i<n; i++)\\n        {\\n            this.arr[i] -= 1;\\n            this.minJumps[i][0] = 1000000;\\n            this.minJumps[i][1] = 1000000;\\n            this.minJumps[i][2] = 1000000;\\n        }\\n        return solve(0,1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// i -> 0 indexed x coordinate\\n// j -> 0 indexed y coordinate\\n// arr[i] = j   ==>  There is an obstacle at point (i,j)\\n// arr[i] = -1  ==>  There is no obstacle at x = i\\nclass Solution\\n{\\n    int[][] minJumps;  // Memo to store min jumps required from (i,j)\\n    int[] arr;         // Input\\n    int n;             // length of arr\\n    int solve(int i, int j)\\n    {\\n\\t    if(i>=n-1)    // If i>=n-1, you have reached or crossed the last point (here n is taken as length of the array).\\n        {\\n            return 0;\\n        }\\n        if(i<0 || j<0 || j>2 || arr[i]==j)  // base cases, out of bounds or land on obstacle (so not a valid path and hence return max_value).\\n            return 1000000;\\n        if(minJumps[i][j]!=1000000)   // If min jumps from (i,j) already known simply return it.\\n            return minJumps[i][j];\\n\\t\\t// Moving towards +ve x\\n        if(i+1<n && arr[i+1]!=j)      // Moving right possible if one to the right of current point is not an obstacle.\\n            minJumps[i][j] = Math.min(minJumps[i][j], solve(i+1,j));\\n        // Below are different cases of moving up and down on the same x coordinate by 1 or 2 units based on only condition that do not land on obstacle.\\n        if(j==0)    // point has y coordinate = 0\\n        {\\n            if(arr[i]!=1)   // If y = 1 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,1) + 1);\\n            if(arr[i]!=2)   // If y = 2 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,2) + 1);\\n        }\\n\\t\\telse if(j==1)  // point has y coordinate = 1\\n        {\\n            if(arr[i]!=0)  // If y = 0 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,0) + 1);\\n            if(arr[i]!=2)  // If y = 2 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,2) + 1);\\n        }\\n        else if(j==2)   // point has y coordinate = 2\\n        {\\n            if(arr[i]!=1)  // If y = 1 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,1) + 1);\\n            if(arr[i]!=0)  // If y = 0 on the same x coordinate is not an obstacle, jump is allowed\\n                minJumps[i][j] = Math.min(minJumps[i][j], solve(i,0) + 1);\\n        }\\n        return minJumps[i][j];  // Return answer stored as minimum of all possible cases.\\n    }\\n    public int minSideJumps(int[] arr)\\n    {\\n        this.n = arr.length;\\n        this.arr = arr;\\n        this.minJumps = new int[n][3];\\n        for(int i=0; i<n; i++)\\n        {\\n            this.arr[i] -= 1;\\n            this.minJumps[i][0] = 1000000;\\n            this.minJumps[i][1] = 1000000;\\n            this.minJumps[i][2] = 1000000;\\n        }\\n        return solve(0,1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153029,
                "title": "100-faster-0-n-bottom-up-dp-solution",
                "content": "This can be a very ideal problem for those we are newly learning dp(like me), first try to find recursion and the try to memoize it.  Find inline comments. \\nThis can be done is greedy as well, but here i tried to implement dp.\\nhere 0(n) time as the table is 4\\\\*0(n) we need to basically fill the table\\nand space complexity is also 4*0(n) i.e. 0(n)\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)-1\\n        mem = [[-1]*(4) for i in range(n+1)]\\n        def jumps(pos, lane):\\n            # if we reached the last position return 0\\n\\t\\t\\tif pos == n:  \\n                return 0\\n            # first we check in memoization table, if already present return that\\n\\t\\t\\tif mem[pos][lane]!=-1: \\n                return mem[pos][lane]\\n\\t\\t\\t#if either we dont have any obstacle in next pos or the obstacle in not in our lane, then \\n\\t\\t\\t# recur for the next position but in the same lane\\n            if obstacles[pos+1] == 0 or obstacles[pos+1]!=lane: \\n                mem[pos][lane] =  jumps(pos+1, lane)\\n                return mem[pos][lane]\\n\\t\\t\\t# if obstacle is in our lane then we need to jump to sideways\\n            if obstacles[pos+1] == lane:\\n                first, second = sys.maxsize, sys.maxsize\\n\\t\\t\\t\\t# we can check for all the lanes, if currently in lane 1, then check for lane 2 and 3\\n                if lane == 1:\\n\\t\\t\\t\\t\\t#if we have a obstacle in 2, then we cant jump there.\\n\\t\\t\\t\\t\\t#else we can jump so add 1 to the ans and recur for next position\\n                    if obstacles[pos]!=2:\\n                        first = 1+ jumps(pos+1, 2)\\n                    if obstacles[pos]!=3:\\n                        second =1+ jumps(pos+1, 3)\\n                if lane == 2:\\n                    if obstacles[pos]!=1:\\n                        first = 1+ jumps(pos+1, 1)\\n                    if obstacles[pos]!=3:\\n                        second = 1+ jumps(pos+1, 3)\\n                if lane == 3:\\n                    if obstacles[pos]!=2:\\n                        first = 1+ jumps(pos+1, 2)\\n                    if obstacles[pos]!=1:\\n                        second = 1+ jumps(pos+1, 1)\\n\\t\\t\\t\\t#after calculation of first and second path, take the minimum\\n                mem[pos][lane] =  min(first, second)\\n                return mem[pos][lane]\\n        return jumps(0, 2)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles)-1\\n        mem = [[-1]*(4) for i in range(n+1)]\\n        def jumps(pos, lane):\\n            # if we reached the last position return 0\\n\\t\\t\\tif pos == n:  \\n                return 0\\n            # first we check in memoization table, if already present return that\\n\\t\\t\\tif mem[pos][lane]!=-1: \\n                return mem[pos][lane]\\n\\t\\t\\t#if either we dont have any obstacle in next pos or the obstacle in not in our lane, then \\n\\t\\t\\t# recur for the next position but in the same lane\\n            if obstacles[pos+1] == 0 or obstacles[pos+1]!=lane: \\n                mem[pos][lane] =  jumps(pos+1, lane)\\n                return mem[pos][lane]\\n\\t\\t\\t# if obstacle is in our lane then we need to jump to sideways\\n            if obstacles[pos+1] == lane:\\n                first, second = sys.maxsize, sys.maxsize\\n\\t\\t\\t\\t# we can check for all the lanes, if currently in lane 1, then check for lane 2 and 3\\n                if lane == 1:\\n\\t\\t\\t\\t\\t#if we have a obstacle in 2, then we cant jump there.\\n\\t\\t\\t\\t\\t#else we can jump so add 1 to the ans and recur for next position\\n                    if obstacles[pos]!=2:\\n                        first = 1+ jumps(pos+1, 2)\\n                    if obstacles[pos]!=3:\\n                        second =1+ jumps(pos+1, 3)\\n                if lane == 2:\\n                    if obstacles[pos]!=1:\\n                        first = 1+ jumps(pos+1, 1)\\n                    if obstacles[pos]!=3:\\n                        second = 1+ jumps(pos+1, 3)\\n                if lane == 3:\\n                    if obstacles[pos]!=2:\\n                        first = 1+ jumps(pos+1, 2)\\n                    if obstacles[pos]!=1:\\n                        second = 1+ jumps(pos+1, 1)\\n\\t\\t\\t\\t#after calculation of first and second path, take the minimum\\n                mem[pos][lane] =  min(first, second)\\n                return mem[pos][lane]\\n        return jumps(0, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153013,
                "title": "c-greedy-272ms-time-100",
                "content": "we will continue to travel in the current lane until we find the stone\\nwhen we find a stone we will calculate the distance of the next stone in the other 2 lanes from the current point \\nwe will shift to the lane that have the stone at the greater distance from the current point;\\n\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        vector<vector<int>>lane(3,vector<int>(n+1));\\n        for(int i=0;i<n;i++)\\n        {\\n            if(obs[i]==0)\\n                continue;\\n            lane[obs[i]-1][i]=1;\\n        }\\n        int p=0;\\n        int ans=0;\\n        int l=1;\\n        int s;\\n        while(p<n)\\n        {\\n            while(p<n&&lane[l][p]==0)\\n            {\\n                p++;\\n            }\\n            if(p==n)\\n                return ans;\\n            p--;\\n            cout<<p<<\" \";\\n            int c1=0;\\n            int c2=0;\\n            int a=(l+1)%3;\\n            int b=(l+2)%3;\\n            s=p;\\n            while(s<n&&lane[a][s]==0)\\n            {\\n                s++;\\n                c1++;\\n            }\\n            s=p;\\n            while(s<n&&lane[b][s]==0)\\n            {\\n                s++;\\n                c2++;\\n            }\\n            if(c1>c2)\\n            {\\n              l=a;\\n                p=p+c1-1;\\n                ans++;\\n            }\\n            else\\n            {\\n                l=b;\\n                p=p+c2-1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        vector<vector<int>>lane(3,vector<int>(n+1));\\n        for(int i=0;i<n;i++)\\n        {\\n            if(obs[i]==0)\\n                continue;\\n            lane[obs[i]-1][i]=1;\\n        }\\n        int p=0;\\n        int ans=0;\\n        int l=1;\\n        int s;\\n        while(p<n)\\n        {\\n            while(p<n&&lane[l][p]==0)\\n            {\\n                p++;\\n            }\\n            if(p==n)\\n                return ans;\\n            p--;\\n            cout<<p<<\" \";\\n            int c1=0;\\n            int c2=0;\\n            int a=(l+1)%3;\\n            int b=(l+2)%3;\\n            s=p;\\n            while(s<n&&lane[a][s]==0)\\n            {\\n                s++;\\n                c1++;\\n            }\\n            s=p;\\n            while(s<n&&lane[b][s]==0)\\n            {\\n                s++;\\n                c2++;\\n            }\\n            if(c1>c2)\\n            {\\n              l=a;\\n                p=p+c1-1;\\n                ans++;\\n            }\\n            else\\n            {\\n                l=b;\\n                p=p+c2-1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1152948,
                "title": "dp-backtracking-java-codes-heavily-commented-go-recursion",
                "content": "```\\n//Note: Frog jumps to another lane one and only when no forward movement is possible in the same lane.\\nclass Solution {\\n    boolean [][] matrix;\\n    int n;\\n    int [][] dp;\\n    public int minSideJumps(int[] obstacles) {\\n        n=obstacles.length;\\n        matrix=new boolean[3][n];\\n        \\n        dp=new int [3][n];\\n        for(int [] arr:dp)Arrays.fill(arr,-1);\\n        \\n\\t\\t//I used a matrix of 3*n dimension for my exploration\\n        for(int i=0;i<n;i++){\\n            int val = obstacles[i];\\n            if(val!=0)matrix[val-1][i]=true; //mark obstacled position\\n        }\\n        return helper(1,0,new boolean [3][n]); //lane is counted on 0-indexed basis\\n    }\\n    private int helper(int lane, int i, boolean [][]visited){\\n        if(i==n-2)return 0; //no further jump/movement required, because if u reached (n-2)th position, u can always reach to (n-1)position\\n        if(visited[lane][i])return 1000000; //if this path is already visited\\n        \\n        //store\\n        if(dp[lane][i]!=-1)return dp[lane][i];\\n        \\n        //mark visited\\n        visited[lane][i]=true;\\n        \\n        //move forward when no obstacle in the same lane\\n        if(!matrix[lane][i+1]){\\n            int forward = Integer.MAX_VALUE;\\n            forward = helper(lane,i+1,visited);\\n            \\n            //back-track\\n            visited[lane][i]=false;\\n            return dp[lane][i]=forward;\\n        }\\n        // else jump\\n        else{\\n            //move downward : two possible jumps\\n            int down=Integer.MAX_VALUE;\\n            int ans1 = Integer.MAX_VALUE;\\n            if(lane+1<=2 && !matrix[lane+1][i]){\\n                ans1 = 1+helper(lane+1,i,visited);\\n            }\\n            int ans2 = Integer.MAX_VALUE;\\n            if(lane+2<=2 && !matrix[lane+2][i]){\\n                ans2 = 1+helper(lane+2,i,visited);\\n            }\\n\\n            down = Math.min(ans1,ans2);\\n\\n            //up move : two possible jumps\\n            int up = Integer.MAX_VALUE;\\n            int ans3 = Integer.MAX_VALUE;\\n            if(lane-1>=0 && !matrix[lane-1][i]){\\n                ans3 = 1+helper(lane-1,i,visited);\\n            }\\n            int ans4 = Integer.MAX_VALUE;\\n            if(lane-2>=0 && !matrix[lane-2][i]){\\n                ans4 = 1+helper(lane-2,i,visited);\\n            }\\n\\n            up = Math.min(ans3,ans4);\\n\\n            //back-track\\n            visited[lane][i]=false;\\n            return dp[lane][i] = Math.min(down,up);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//Note: Frog jumps to another lane one and only when no forward movement is possible in the same lane.\\nclass Solution {\\n    boolean [][] matrix;\\n    int n;\\n    int [][] dp;\\n    public int minSideJumps(int[] obstacles) {\\n        n=obstacles.length;\\n        matrix=new boolean[3][n];\\n        \\n        dp=new int [3][n];\\n        for(int [] arr:dp)Arrays.fill(arr,-1);\\n        \\n\\t\\t//I used a matrix of 3*n dimension for my exploration\\n        for(int i=0;i<n;i++){\\n            int val = obstacles[i];\\n            if(val!=0)matrix[val-1][i]=true; //mark obstacled position\\n        }\\n        return helper(1,0,new boolean [3][n]); //lane is counted on 0-indexed basis\\n    }\\n    private int helper(int lane, int i, boolean [][]visited){\\n        if(i==n-2)return 0; //no further jump/movement required, because if u reached (n-2)th position, u can always reach to (n-1)position\\n        if(visited[lane][i])return 1000000; //if this path is already visited\\n        \\n        //store\\n        if(dp[lane][i]!=-1)return dp[lane][i];\\n        \\n        //mark visited\\n        visited[lane][i]=true;\\n        \\n        //move forward when no obstacle in the same lane\\n        if(!matrix[lane][i+1]){\\n            int forward = Integer.MAX_VALUE;\\n            forward = helper(lane,i+1,visited);\\n            \\n            //back-track\\n            visited[lane][i]=false;\\n            return dp[lane][i]=forward;\\n        }\\n        // else jump\\n        else{\\n            //move downward : two possible jumps\\n            int down=Integer.MAX_VALUE;\\n            int ans1 = Integer.MAX_VALUE;\\n            if(lane+1<=2 && !matrix[lane+1][i]){\\n                ans1 = 1+helper(lane+1,i,visited);\\n            }\\n            int ans2 = Integer.MAX_VALUE;\\n            if(lane+2<=2 && !matrix[lane+2][i]){\\n                ans2 = 1+helper(lane+2,i,visited);\\n            }\\n\\n            down = Math.min(ans1,ans2);\\n\\n            //up move : two possible jumps\\n            int up = Integer.MAX_VALUE;\\n            int ans3 = Integer.MAX_VALUE;\\n            if(lane-1>=0 && !matrix[lane-1][i]){\\n                ans3 = 1+helper(lane-1,i,visited);\\n            }\\n            int ans4 = Integer.MAX_VALUE;\\n            if(lane-2>=0 && !matrix[lane-2][i]){\\n                ans4 = 1+helper(lane-2,i,visited);\\n            }\\n\\n            up = Math.min(ans3,ans4);\\n\\n            //back-track\\n            visited[lane][i]=false;\\n            return dp[lane][i] = Math.min(down,up);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152942,
                "title": "python-c-easy-recursive-dp-solution",
                "content": "# Python\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        dp =  [[-1 for _ in range(4)] for j in range(len(obstacles) + 1)]\\n        def go(i,lane):\\n            if i == len(obstacles): return 0\\n            if obstacles[i] == lane: return float(\"inf\")\\n            if dp[i][lane] != -1: return dp[i][lane] \\n            res = go(i + 1, lane)\\n            for j in range(1,4):\\n                if lane == j or obstacles[i] == j: continue\\n                res = min(res , go(i+1,j) + 1)\\n            dp[i][lane] = res\\n            return dp[i][lane]\\n        return go(0,2)\\n```\\n# C++\\n```python\\nclass Solution {\\npublic:\\n    int dp[500005][4];\\n    int solve(vector<int>& obstacles , int i , int lane){\\n        if(i == obstacles.size()) return 0;\\n        if(obstacles[i] == lane) return 1000000000;\\n        if(dp[i][lane] != -1) return dp[i][lane];\\n        int res = solve(obstacles , i + 1, lane);\\n        for(int j = 1 ; j <= 3 ; j++){\\n            if(lane == j or obstacles[i] == j) continue;\\n            res = min(res , solve(obstacles,i+1,j) + 1);            \\n        }\\n        return dp[i][lane] = res;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacles,0,2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        dp =  [[-1 for _ in range(4)] for j in range(len(obstacles) + 1)]\\n        def go(i,lane):\\n            if i == len(obstacles): return 0\\n            if obstacles[i] == lane: return float(\"inf\")\\n            if dp[i][lane] != -1: return dp[i][lane] \\n            res = go(i + 1, lane)\\n            for j in range(1,4):\\n                if lane == j or obstacles[i] == j: continue\\n                res = min(res , go(i+1,j) + 1)\\n            dp[i][lane] = res\\n            return dp[i][lane]\\n        return go(0,2)\\n```\n```python\\nclass Solution {\\npublic:\\n    int dp[500005][4];\\n    int solve(vector<int>& obstacles , int i , int lane){\\n        if(i == obstacles.size()) return 0;\\n        if(obstacles[i] == lane) return 1000000000;\\n        if(dp[i][lane] != -1) return dp[i][lane];\\n        int res = solve(obstacles , i + 1, lane);\\n        for(int j = 1 ; j <= 3 ; j++){\\n            if(lane == j or obstacles[i] == j) continue;\\n            res = min(res , solve(obstacles,i+1,j) + 1);            \\n        }\\n        return dp[i][lane] = res;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(obstacles,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152882,
                "title": "c-simple-recursion-with-memoization",
                "content": "At each obstacle we have can choose to change the lane depending on the conditions.\\n<b>if obstacles[i+1]!==k  and obstacles[i]!=k:</b>\\nExplanation of the above condition:\\nif obstacles is not present in the kth lane at \"i+1\" th position we can jump to that lane (kth lane) but since we making a change in the lane at point i so we have to make sure that  no obstacles is present at the  \"i\" th position in the same lane (kth -> the same lane in which we are planing to jump). <br>\\nIf the kth lane in which are making jump is same as the current lane so no jump is required but if it is different then 1 is added as we made a jump to different lane.\\n\\nRest all  code is simple recursion with memoization of states.\\n\\n// zero based indexing\\nrec(0,2,obstacles); // staring at point 0 in the lane 2 \\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[510000][4];\\n \\n    \\n    int rec(int i,int lane,vector<int>&obstacles)\\n    {\\n     \\n        if(i==obstacles.size()-1)\\n            return 0;\\n        \\n        int &ans=dp[i][lane];\\n        if(ans!=-1)\\n            return ans;\\n       \\n        int temp=INT_MAX;\\n       \\n        for(int k=1;k<=3;k++)\\n        {\\n            if(obstacles[i+1]!=k && obstacles[i]!=k)\\n            {\\n                if(lane==k)\\n                {\\n                    temp=min(temp,rec(i+1,k,obstacles));\\n                }\\n                else\\n                {\\n                    temp=min(temp,1+rec(i+1,k,obstacles));\\n                }\\n            }\\n        }\\n        \\n        ans=temp;\\n        return ans;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=3;j++)\\n            {\\n                \\n                dp[i][j]=-1;\\n                \\n            }\\n        }\\n        \\n        return rec(0,2,obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[510000][4];\\n \\n    \\n    int rec(int i,int lane,vector<int>&obstacles)\\n    {\\n     \\n        if(i==obstacles.size()-1)\\n            return 0;\\n        \\n        int &ans=dp[i][lane];\\n        if(ans!=-1)\\n            return ans;\\n       \\n        int temp=INT_MAX;\\n       \\n        for(int k=1;k<=3;k++)\\n        {\\n            if(obstacles[i+1]!=k && obstacles[i]!=k)\\n            {\\n                if(lane==k)\\n                {\\n                    temp=min(temp,rec(i+1,k,obstacles));\\n                }\\n                else\\n                {\\n                    temp=min(temp,1+rec(i+1,k,obstacles));\\n                }\\n            }\\n        }\\n        \\n        ans=temp;\\n        return ans;\\n    }\\n    \\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=3;j++)\\n            {\\n                \\n                dp[i][j]=-1;\\n                \\n            }\\n        }\\n        \\n        return rec(0,2,obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152802,
                "title": "c-dp-solution-with-explanation",
                "content": "*First, let us discuss the recursive formula:*\\nLet us assume that we are on point i and currently in lane \"curr\".Let the function be f\\n**Base Case:**\\nif i==obstacles.size()-1\\n\\t we simply return 0 since it is given that last point has no obstacles.\\n**Now,**\\n*if (i+1)th point in the curr lane is safe, we will simply move ahead*\\n     thus, we return f(i+1,curr)\\nelse\\n   we have two options( the adjacent lanes).\\n   lets denote answer to be res. lets set res=INT_MAX.\\n   we will check if we can make a side jump to these lanes now ( i.e we look if they are obstacle free at point i). If we are able to perform side jump, we make res=min(res,1+f(i+1,safe adj lane)\\n   So we explore both adjacent lanes and return res.\\n   \\n**Memoization**\\nNow if we draw a computation tree( we can see overlapping subproblems), try it out on paper. Thus, we use memoization.\\n\\n**Time Complexity**\\n\\tO(N * 3) ~ O(N)\\n\\t**Space Complexity**\\n\\tO(N * 3) ~ O(N) ( Not factoring recursion call stack, but that can be worked upon by converting top down code to bottom up code!!)\\n\\n**Code**\\n```\\n\\nint help(int i,int curr,vector<int>&o,vector<vector<int>>&dp)\\n {\\n        if(i==o.size()-1)\\n            return 0;\\n        if(dp[i][curr]!=-1)\\n            return dp[i][curr];\\n        if(o[i+1]!=curr)\\n            return dp[i][curr]=help(i+1,curr,o,dp);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            if(curr!=1 && o[i]!=1)\\n            {\\n                ans=min(ans,1+help(i+1,1,o,dp));\\n            }\\n            if(curr!=2 && o[i]!=2)\\n            {\\n                ans=min(ans,1+help(i+1,2,o,dp));\\n            }\\n            if(curr!=3 && o[i]!=3)\\n            {\\n                ans=min(ans,1+help(i+1,3,o,dp));\\n            }\\n            return dp[i][curr]=ans;\\n        }\\n        \\n        return 0;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size(),vector<int>(4,-1));\\n        return help(0,2,obstacles,dp);\\n    }\\n\\t\\n\\n\\t\\n \\n  \\n\\n\\t\\n",
                "solutionTags": [],
                "code": "*First, let us discuss the recursive formula:*\\nLet us assume that we are on point i and currently in lane \"curr\".Let the function be f\\n**Base Case:**\\nif i==obstacles.size()-1\\n\\t we simply return 0 since it is given that last point has no obstacles.\\n**Now,**\\n*if (i+1)th point in the curr lane is safe, we will simply move ahead*\\n     thus, we return f(i+1,curr)\\nelse\\n   we have two options( the adjacent lanes).\\n   lets denote answer to be res. lets set res=INT_MAX.\\n   we will check if we can make a side jump to these lanes now ( i.e we look if they are obstacle free at point i). If we are able to perform side jump, we make res=min(res,1+f(i+1,safe adj lane)\\n   So we explore both adjacent lanes and return res.\\n   \\n**Memoization**\\nNow if we draw a computation tree( we can see overlapping subproblems), try it out on paper. Thus, we use memoization.\\n\\n**Time Complexity**\\n\\tO(N * 3) ~ O(N)\\n\\t**Space Complexity**\\n\\tO(N * 3) ~ O(N) ( Not factoring recursion call stack, but that can be worked upon by converting top down code to bottom up code!!)\\n\\n**Code**\\n```\\n\\nint help(int i,int curr,vector<int>&o,vector<vector<int>>&dp)\\n {\\n        if(i==o.size()-1)\\n            return 0;\\n        if(dp[i][curr]!=-1)\\n            return dp[i][curr];\\n        if(o[i+1]!=curr)\\n            return dp[i][curr]=help(i+1,curr,o,dp);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            if(curr!=1 && o[i]!=1)\\n            {\\n                ans=min(ans,1+help(i+1,1,o,dp));\\n            }\\n            if(curr!=2 && o[i]!=2)\\n            {\\n                ans=min(ans,1+help(i+1,2,o,dp));\\n            }\\n            if(curr!=3 && o[i]!=3)\\n            {\\n                ans=min(ans,1+help(i+1,3,o,dp));\\n            }\\n            return dp[i][curr]=ans;\\n        }\\n        \\n        return 0;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size(),vector<int>(4,-1));\\n        return help(0,2,obstacles,dp);\\n    }\\n\\t\\n\\n\\t\\n \\n  \\n\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1152798,
                "title": "optimal-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int x=3,n=obs.size(),ans=0;\\n        int arr[4]={1,2,3,5};\\n        for(int i=1;i<n;i++){\\n            if(x%arr[obs[i]]==0){\\n                if(x==arr[obs[i]]){\\n                    ans++;\\n                    x=30/(arr[obs[i]]*arr[obs[i-1]]);\\n                }else\\n                    x/=arr[obs[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n        int x=3,n=obs.size(),ans=0;\\n        int arr[4]={1,2,3,5};\\n        for(int i=1;i<n;i++){\\n            if(x%arr[obs[i]]==0){\\n                if(x==arr[obs[i]]){\\n                    ans++;\\n                    x=30/(arr[obs[i]]*arr[obs[i-1]]);\\n                }else\\n                    x/=arr[obs[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152735,
                "title": "java-very-easy-to-understand-recursion-memoisation-comments-added",
                "content": "This problem can be easily solved by simple recursion\\n\\nEvery time the frog has 2 options :\\n1. move ahead with current lane if no obstacles\\n       for this no side jump is required.\\n\\n2. jump to one of the other lane (if no obstacles in the jumping lane)\\n        for this 1 side jump is required.\\n\\nJust add memoisation to improve on time complexity\\nthat is save the min side jump if from already visited the index, and reuse the min side jump, if frog gets to revisit same index\\n```\\nclass Solution {\\n\\n        public int minSideJumps(int[] obstacle) {\\n            int n = obstacle.length;\\n            memory = new Integer[n][4];\\n            // start with lane = 2, as given in question\\n            return minSideJumps(obstacle, 0, 2);\\n        }\\n\\n        Integer memory[][];\\n\\n        // return the minimum side jump required to reach enc\\n        int minSideJumps(int[] obstacle, int i, int curr_lane) {\\n            //base case: if reached the end position than return 0 (as 0 steps required to reach end)\\n            if (i == obstacle.length - 1) {\\n                return 0;\\n            }\\n\\n            // if we already have calculated min ans for this position, return simply return ans\\n            if (memory[i][curr_lane] != null)\\n                return memory[i][curr_lane];\\n\\n            // initialise with max value\\n            int min = 100000000;\\n            // loop for all the possible lanes to jump(here lane can be: 1, 2, or 3)\\n            for (int lane = 1; lane <= 3; lane++) {\\n\\n                // if frog is already in the current lane, and their is no obstacle move ahead( 0 jumps required here)\\n                if (curr_lane == lane && obstacle[i + 1] != curr_lane) {\\n                    min = Math.min(minSideJumps(obstacle, i + 1, curr_lane), min);\\n                }\\n                // if frog is at different lane, and their is no obstacle in this lane, then jump to this lane(1 jump required here)\\n                else if (obstacle[i] != lane && obstacle[i + 1] != lane) {\\n                    min = Math.min(1 + minSideJumps(obstacle, i + 1, lane), min);\\n                }\\n            }\\n\\n            // save the result for this index in memory\\n            memory[i][curr_lane] = min;\\n\\n            // return the minium jumps required from this index = i to reach end\\n            return min;\\n\\n        }\\n\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n        public int minSideJumps(int[] obstacle) {\\n            int n = obstacle.length;\\n            memory = new Integer[n][4];\\n            // start with lane = 2, as given in question\\n            return minSideJumps(obstacle, 0, 2);\\n        }\\n\\n        Integer memory[][];\\n\\n        // return the minimum side jump required to reach enc\\n        int minSideJumps(int[] obstacle, int i, int curr_lane) {\\n            //base case: if reached the end position than return 0 (as 0 steps required to reach end)\\n            if (i == obstacle.length - 1) {\\n                return 0;\\n            }\\n\\n            // if we already have calculated min ans for this position, return simply return ans\\n            if (memory[i][curr_lane] != null)\\n                return memory[i][curr_lane];\\n\\n            // initialise with max value\\n            int min = 100000000;\\n            // loop for all the possible lanes to jump(here lane can be: 1, 2, or 3)\\n            for (int lane = 1; lane <= 3; lane++) {\\n\\n                // if frog is already in the current lane, and their is no obstacle move ahead( 0 jumps required here)\\n                if (curr_lane == lane && obstacle[i + 1] != curr_lane) {\\n                    min = Math.min(minSideJumps(obstacle, i + 1, curr_lane), min);\\n                }\\n                // if frog is at different lane, and their is no obstacle in this lane, then jump to this lane(1 jump required here)\\n                else if (obstacle[i] != lane && obstacle[i + 1] != lane) {\\n                    min = Math.min(1 + minSideJumps(obstacle, i + 1, lane), min);\\n                }\\n            }\\n\\n            // save the result for this index in memory\\n            memory[i][curr_lane] = min;\\n\\n            // return the minium jumps required from this index = i to reach end\\n            return min;\\n\\n        }\\n\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152728,
                "title": "java-dp-easy-to-understand",
                "content": "`dp[i][j]`  How many sideway jumps at point i and lane j\\n1. If `obstacle[i] == j + 1` means we have obstacle in point i and lane j. We cannot jump to this point, so `dp[i][j] = Integer.MAX_VALUE`\\n2. Else we can reach this point i and lane j.\\n- From the same lane, `dp[i][j] = dp[i - 1][j]` no need for jump\\n- From the other two lanes, `obstacles[i] != (j + 1) % 3 + 1` is to make sure, the obstacle is not front of point i - 1 and lane `(j + 1) % 3`(different from current line). \\nFor example, if we current in point 1 and lane 1, if obstacle is in point 1 and lane 2, we cannot jump directly from point 0 lane 2 to point 1 lane1. We have to route to the other lane 3 to see if it can reach lane 1 or not.\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        int[][] dp = new int[n][3];\\n        for (int[] d : dp) {\\n            Arrays.fill(d, Integer.MAX_VALUE);\\n        }\\n        dp[0][1] = 0;\\n        dp[0][0] = 1;\\n        dp[0][2] = 1;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (obstacles[i] == j + 1) { // cannot reach\\n                    continue;\\n                }\\n                if (dp[i - 1][j] != Integer.MAX_VALUE) { // same lane\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);\\n                }\\n\\t\\t\\t\\t// from other lanes, make sure the point i and lane k, h does not have obstacle\\n                if (dp[i - 1][(j + 1) % 3] != Integer.MAX_VALUE && obstacles[i] != (j + 1) % 3 + 1) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][(j + 1) % 3] + 1);\\n                }\\n                if (dp[i - 1][(j + 2) % 3] != Integer.MAX_VALUE && obstacles[i] != (j + 2) % 3 + 1) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][(j + 2) % 3] + 1);\\n                }\\n            }\\n        }\\n        return Math.min(dp[n - 1][2], Math.min(dp[n - 1][1], dp[n - 1][0]));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int n = obstacles.length;\\n        int[][] dp = new int[n][3];\\n        for (int[] d : dp) {\\n            Arrays.fill(d, Integer.MAX_VALUE);\\n        }\\n        dp[0][1] = 0;\\n        dp[0][0] = 1;\\n        dp[0][2] = 1;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                if (obstacles[i] == j + 1) { // cannot reach\\n                    continue;\\n                }\\n                if (dp[i - 1][j] != Integer.MAX_VALUE) { // same lane\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][j]);\\n                }\\n\\t\\t\\t\\t// from other lanes, make sure the point i and lane k, h does not have obstacle\\n                if (dp[i - 1][(j + 1) % 3] != Integer.MAX_VALUE && obstacles[i] != (j + 1) % 3 + 1) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][(j + 1) % 3] + 1);\\n                }\\n                if (dp[i - 1][(j + 2) % 3] != Integer.MAX_VALUE && obstacles[i] != (j + 2) % 3 + 1) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][(j + 2) % 3] + 1);\\n                }\\n            }\\n        }\\n        return Math.min(dp[n - 1][2], Math.min(dp[n - 1][1], dp[n - 1][0]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152650,
                "title": "java-memoization",
                "content": "```\\nclass Solution {\\n    private int[][] memo;\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int N = obstacles.length;\\n        memo = new int[N][4];\\n        for (int i=0;i<N;i++)\\n        {\\n            Arrays.fill(memo[i], -1);\\n        }\\n\\n        return dfs(obstacles, 2, 0);\\n    }\\n    \\n\\t/*\\n\\t* currIdx = current position in obstacles array\\n\\t* currRow = rowNum i.e 1,2,3\\n\\t*/\\n    private int dfs(int[] obstacles, int currRow, int currIdx)\\n    {\\n        if (memo[currIdx][currRow] != -1)\\n        {\\n            return memo[currIdx][currRow];\\n        }\\n\\n        if (currIdx == obstacles.length - 1)\\n        {\\n            return memo[currIdx][currRow] = 0;\\n        }\\n        \\n        int nextIdx = currIdx + 1;\\n        int minSwaps = Integer.MAX_VALUE;\\n        if (obstacles[nextIdx] == currRow)//obstacle in curr row, cant move further\\n        {\\n            //side swap\\n            for (int row = 1; row <= 3; row++)\\n            {\\n                //there should not be obstacle in other row where jumping\\n                if (row != currRow && obstacles[currIdx] != row)\\n                {\\n                    //stay at same idx but move sideways\\n                   minSwaps = Math.min(minSwaps, 1 + dfs(obstacles, row, currIdx));\\n                }\\n            }\\n        }\\n        else//no obstacle in nextIdx, move ahead in same row\\n        {\\n            minSwaps = dfs(obstacles, currRow, currIdx + 1);\\n        }\\n\\n        return memo[currIdx][currRow] = minSwaps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[][] memo;\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int N = obstacles.length;\\n        memo = new int[N][4];\\n        for (int i=0;i<N;i++)\\n        {\\n            Arrays.fill(memo[i], -1);\\n        }\\n\\n        return dfs(obstacles, 2, 0);\\n    }\\n    \\n\\t/*\\n\\t* currIdx = current position in obstacles array\\n\\t* currRow = rowNum i.e 1,2,3\\n\\t*/\\n    private int dfs(int[] obstacles, int currRow, int currIdx)\\n    {\\n        if (memo[currIdx][currRow] != -1)\\n        {\\n            return memo[currIdx][currRow];\\n        }\\n\\n        if (currIdx == obstacles.length - 1)\\n        {\\n            return memo[currIdx][currRow] = 0;\\n        }\\n        \\n        int nextIdx = currIdx + 1;\\n        int minSwaps = Integer.MAX_VALUE;\\n        if (obstacles[nextIdx] == currRow)//obstacle in curr row, cant move further\\n        {\\n            //side swap\\n            for (int row = 1; row <= 3; row++)\\n            {\\n                //there should not be obstacle in other row where jumping\\n                if (row != currRow && obstacles[currIdx] != row)\\n                {\\n                    //stay at same idx but move sideways\\n                   minSwaps = Math.min(minSwaps, 1 + dfs(obstacles, row, currIdx));\\n                }\\n            }\\n        }\\n        else//no obstacle in nextIdx, move ahead in same row\\n        {\\n            minSwaps = dfs(obstacles, currRow, currIdx + 1);\\n        }\\n\\n        return memo[currIdx][currRow] = minSwaps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152612,
                "title": "from-bt-to-dp-solution",
                "content": "## BT solution\\n\\nFrom frist glance, this issue can be easy solved by BT , the steps can be :\\n- start from lan 2, keep moving until see the block in lan 2\\n- once facing block,  we have 2 choices, jumping to the next 2 lans\\n- start the same process, until reach the end\\n\\ncode  (timeout for some test case):\\n```\\n    public int minSideJumps(int[] obstacles) {\\n        //looks like using BT way to double check\\n        int curLan = 2;\\n        int ret = 0;\\n        int len = obstacles.length;\\n        \\n        return getMinJumps(obstacles, curLan, 0, 0);\\n    }\\n    \\n    \\n\\n    //curLan : 1, 2, 3\\n    //ob[i + 1] : 0, 1, 2, 3\\n    //curIdx : 0 - len - 1\\n    //curJump:\\n    private int getMinJumps(int[] ob, int curLan, int curIdx, int curJump {\\n        int len = ob.length;\\n        if (curIdx == len - 1 || isReachingEnd(ob, curLan, curIdx)) {\\n            return curJump;\\n        }\\n        \\n        int ret = 0;\\n        \\n        if (ob[curIdx + 1] == curLan) {\\n            //need to jump\\n            int nextLan1 = (curLan - 1) % 3 + 2;\\n            int nextLan2 = (curLan - 1) % 3 + 3;\\n            \\n            nextLan1 = nextLan1 > 3 ? nextLan1 % 3 : nextLan1;\\n            nextLan2 = nextLan2 > 3 ? nextLan2 % 3 : nextLan2;\\n            \\n            ret =  Math.min(ob[curIdx] == nextLan1 ? Integer.MAX_VALUE : getMinJumps(ob, nextLan1, curIdx, 1 + curJump),\\n                            ob[curIdx] == nextLan2 ? Integer.MAX_VALUE : getMinJumps(ob, nextLan2, curIdx, 1 + curJump));\\n        } else {\\n            ret = getMinJumps(ob, curLan, curIdx + 1, curJump);\\n        }\\n\\n        return ret;\\n    }\\n    \\n    private boolean isReachingEnd(int[] ob, int curLan, int curIdx) {\\n        int len = ob.length;\\n        for (int i = curIdx; i < len; i++) {\\n            if (ob[i] == curLan) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n\\n\\nThe above solution is much easy to get , normally when we hit Timeout, that means we are repeating the same calculations, so we can use array to save the status, like `int[lan_number][obstacles.length]`, however i cannot get the correct reason due to some reason, so I came to the DP solution:\\n\\n\\n## DP solution\\n\\nThe idea here is using backward method, (lan is 0 based , means 0 -> 1, 1 -> 2, 2-> 3)\\n- dp[0][len - 1] =  dp[1][len - 1] =  dp[1][len - 1] = 0\\n- if the ` obstacles[curIdx]` is the `curLan`, that means this point is not usable, so set the value to `Integer.MAX_VALUE`\\n-  however, if the ` obstacles[curIdx]` is not equals `curLan`, we have 2 choices, either to get the value from the prev step : `dp[curLan][curIdx + 1]` or the other 2 lans. \\n\\t-  the only reason why we need to retrive the current value `dp[curLan][curIdx]` from the other 2 lans is that the prev idx is not usable (`means dp[curLan][curIdx + 1] == MAX_INTEGER`)\\n\\n\\nBe careful about the little trick here:\\n```\\nYou can only get the correct number for dp[curLan][curIdx]  when dp[curLan][curIdx + 1] == MAX_INTEGER \\nafter the other 2 lan\\'s value are determinated, or you will already get 0 (which is the default value of the arry)\\n```\\n\\n\\n```\\n    public int minSideJumps(int[] obstacles) {\\n        int len = obstacles.length;\\n        int[][] dp = new int[3][len];\\n    \\n        for (int i = len - 2; i >= 0; i--) {\\n            int backup = -1;\\n            for (int j = 0; j < 3; j++) {\\n                dp[j][i] = (obstacles[i] == j + 1)\\n                    ? Integer.MAX_VALUE \\n                    : (dp[j][i + 1] == Integer.MAX_VALUE ? -1 : dp[j][i + 1]);\\n                \\n                if (dp[j][i] == -1) {\\n                    backup = j;\\n                }\\n            }\\n            \\n\\t\\t\\t//check back only after the other 2 lan has determinated\\n            if (backup > -1) {\\n                dp[backup][i] = (Math.min(dp[(backup + 1) % 3][i], dp[(backup + 2) % 3][i]) + 1);\\n            }\\n            \\n        }\\n        \\n        return dp[1][0];\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public int minSideJumps(int[] obstacles) {\\n        //looks like using BT way to double check\\n        int curLan = 2;\\n        int ret = 0;\\n        int len = obstacles.length;\\n        \\n        return getMinJumps(obstacles, curLan, 0, 0);\\n    }\\n    \\n    \\n\\n    //curLan : 1, 2, 3\\n    //ob[i + 1] : 0, 1, 2, 3\\n    //curIdx : 0 - len - 1\\n    //curJump:\\n    private int getMinJumps(int[] ob, int curLan, int curIdx, int curJump {\\n        int len = ob.length;\\n        if (curIdx == len - 1 || isReachingEnd(ob, curLan, curIdx)) {\\n            return curJump;\\n        }\\n        \\n        int ret = 0;\\n        \\n        if (ob[curIdx + 1] == curLan) {\\n            //need to jump\\n            int nextLan1 = (curLan - 1) % 3 + 2;\\n            int nextLan2 = (curLan - 1) % 3 + 3;\\n            \\n            nextLan1 = nextLan1 > 3 ? nextLan1 % 3 : nextLan1;\\n            nextLan2 = nextLan2 > 3 ? nextLan2 % 3 : nextLan2;\\n            \\n            ret =  Math.min(ob[curIdx] == nextLan1 ? Integer.MAX_VALUE : getMinJumps(ob, nextLan1, curIdx, 1 + curJump),\\n                            ob[curIdx] == nextLan2 ? Integer.MAX_VALUE : getMinJumps(ob, nextLan2, curIdx, 1 + curJump));\\n        } else {\\n            ret = getMinJumps(ob, curLan, curIdx + 1, curJump);\\n        }\\n\\n        return ret;\\n    }\\n    \\n    private boolean isReachingEnd(int[] ob, int curLan, int curIdx) {\\n        int len = ob.length;\\n        for (int i = curIdx; i < len; i++) {\\n            if (ob[i] == curLan) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\nYou can only get the correct number for dp[curLan][curIdx]  when dp[curLan][curIdx + 1] == MAX_INTEGER \\nafter the other 2 lan\\'s value are determinated, or you will already get 0 (which is the default value of the arry)\\n```\n```\\n    public int minSideJumps(int[] obstacles) {\\n        int len = obstacles.length;\\n        int[][] dp = new int[3][len];\\n    \\n        for (int i = len - 2; i >= 0; i--) {\\n            int backup = -1;\\n            for (int j = 0; j < 3; j++) {\\n                dp[j][i] = (obstacles[i] == j + 1)\\n                    ? Integer.MAX_VALUE \\n                    : (dp[j][i + 1] == Integer.MAX_VALUE ? -1 : dp[j][i + 1]);\\n                \\n                if (dp[j][i] == -1) {\\n                    backup = j;\\n                }\\n            }\\n            \\n\\t\\t\\t//check back only after the other 2 lan has determinated\\n            if (backup > -1) {\\n                dp[backup][i] = (Math.min(dp[(backup + 1) % 3][i], dp[(backup + 2) % 3][i]) + 1);\\n            }\\n            \\n        }\\n        \\n        return dp[1][0];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152592,
                "title": "java-easy-soln-using-memoization",
                "content": "```\\npublic int memo(int[][] dp,int ci,int cl,int[] obstacles,boolean[][] vst){\\n        int n=dp[0].length; \\n        if(ci==(n-1)){\\n            return 0;\\n        }\\n        \\n        if(vst[cl][ci]){return dp[cl][ci];}\\n        int min=Integer.MAX_VALUE;\\n        \\n        int ocl=cl,oci=ci;\\n        vst[cl][ci]=true;\\n        \\n        if(obstacles[ci+1]!=cl){  //move\\n           min=memo(dp,ci+1,cl,obstacles,vst);\\n        }else{\\n            int ct=0;\\n            \\n           while(ct<2){\\n            cl=(cl+1)%4;\\n            if(cl==0){cl=1;}\\n            if(dp[cl][ci]!=-100){  //jump\\n                int ft=(memo(dp,ci,cl,obstacles,vst)); ft+=1;\\n               min=Math.min(min, ft);\\n            }\\n            ct++;\\n            } \\n        }\\n        \\n        cl=ocl;  ci=oci;\\n        dp[cl][ci]=min;\\n        return dp[cl][ci];\\n    }\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int n=obstacles.length;\\n        int[][] dp=new int[4][n];\\n        boolean[][] vst=new boolean[4][n];\\n        \\n        for(int i=0;i<n;i++){\\n            if(obstacles[i]>0){\\n                dp[ obstacles[i] ][i]=-100;\\n            }\\n        }\\n        \\n        return memo(dp,0,2,obstacles,vst);\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int memo(int[][] dp,int ci,int cl,int[] obstacles,boolean[][] vst){\\n        int n=dp[0].length; \\n        if(ci==(n-1)){\\n            return 0;\\n        }\\n        \\n        if(vst[cl][ci]){return dp[cl][ci];}\\n        int min=Integer.MAX_VALUE;\\n        \\n        int ocl=cl,oci=ci;\\n        vst[cl][ci]=true;\\n        \\n        if(obstacles[ci+1]!=cl){  //move\\n           min=memo(dp,ci+1,cl,obstacles,vst);\\n        }else{\\n            int ct=0;\\n            \\n           while(ct<2){\\n            cl=(cl+1)%4;\\n            if(cl==0){cl=1;}\\n            if(dp[cl][ci]!=-100){  //jump\\n                int ft=(memo(dp,ci,cl,obstacles,vst)); ft+=1;\\n               min=Math.min(min, ft);\\n            }\\n            ct++;\\n            } \\n        }\\n        \\n        cl=ocl;  ci=oci;\\n        dp[cl][ci]=min;\\n        return dp[cl][ci];\\n    }\\n    \\n    public int minSideJumps(int[] obstacles) {\\n        int n=obstacles.length;\\n        int[][] dp=new int[4][n];\\n        boolean[][] vst=new boolean[4][n];\\n        \\n        for(int i=0;i<n;i++){\\n            if(obstacles[i]>0){\\n                dp[ obstacles[i] ][i]=-100;\\n            }\\n        }\\n        \\n        return memo(dp,0,2,obstacles,vst);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1152583,
                "title": "python-3-solution-by-greedy-choose",
                "content": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        pos = defaultdict(list)\\n        for i, o in enumerate(obstacles):\\n            if o!=0:\\n                pos[o].append(i)\\n        res = 0\\n        while pos[1] and pos[2] and pos[3]:\\n            temp = min(pos[1][-1], pos[2][-1], pos[3][-1])\\n            while pos[1] and pos[1][-1]>temp+1:\\n                pos[1].pop()\\n            while pos[2] and pos[2][-1]>temp+1:\\n                pos[2].pop()\\n            while pos[3] and pos[3][-1]>temp+1:\\n                pos[3].pop()\\n            res += 1\\n        return res if not pos[2] else res+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        pos = defaultdict(list)\\n        for i, o in enumerate(obstacles):\\n            if o!=0:\\n                pos[o].append(i)\\n        res = 0\\n        while pos[1] and pos[2] and pos[3]:\\n            temp = min(pos[1][-1], pos[2][-1], pos[3][-1])\\n            while pos[1] and pos[1][-1]>temp+1:\\n                pos[1].pop()\\n            while pos[2] and pos[2][-1]>temp+1:\\n                pos[2].pop()\\n            while pos[3] and pos[3][-1]>temp+1:\\n                pos[3].pop()\\n            res += 1\\n        return res if not pos[2] else res+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152568,
                "title": "i-m-getting-a-weird-recursion-limit-for-an-optimized-top-down-dp-solution",
                "content": "Hey guys, I coded this up in like 10 minutes. It passed all the unit tests, but it looks like it has a recursion limit. Which is weird since top down recursion limits have passed before for similar questions. I spend a whole hour debugging it which pissed me off :(\\n\\nAnyone have any input on what went wrong here? It passes 38 tests cases before failing on an input at 500001 test values. The exit conditions are all correct.\\n\\n```\\n\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        minimum= float(\\'inf\\')\\n        \\n        @lru_cache(None)\\n        def minimum_jumps(obstacle_index, current_position):\\n            if obstacles[obstacle_index] == current_position or obstacle_index == len(obstacles): return float(\\'inf\\')\\n            if obstacle_index == len(obstacles)-1: return 0\\n\\n            counts = [float(\\'inf\\'), float(\\'inf\\'),float(\\'inf\\')]\\n            \\n            for i in range(1, 4):\\n                if obstacles[obstacle_index] == i: continue\\n                count = minimum_jumps(obstacle_index+1, i)\\n                if not i == current_position: \\n                    count+=1\\n                counts[i-1] = count\\n            \\n            return min(counts)\\n        \\n        minimum = minimum_jumps(0, 2)\\n        \\n        return minimum",
                "solutionTags": [],
                "code": "Hey guys, I coded this up in like 10 minutes. It passed all the unit tests, but it looks like it has a recursion limit. Which is weird since top down recursion limits have passed before for similar questions. I spend a whole hour debugging it which pissed me off :(\\n\\nAnyone have any input on what went wrong here? It passes 38 tests cases before failing on an input at 500001 test values. The exit conditions are all correct.\\n\\n```\\n\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        minimum= float(\\'inf\\')\\n        \\n        @lru_cache(None)\\n        def minimum_jumps(obstacle_index, current_position):\\n            if obstacles[obstacle_index] == current_position or obstacle_index == len(obstacles): return float(\\'inf\\')\\n            if obstacle_index == len(obstacles)-1: return 0\\n\\n            counts = [float(\\'inf\\'), float(\\'inf\\'),float(\\'inf\\')]\\n            \\n            for i in range(1, 4):\\n                if obstacles[obstacle_index] == i: continue\\n                count = minimum_jumps(obstacle_index+1, i)\\n                if not i == current_position: \\n                    count+=1\\n                counts[i-1] = count\\n            \\n            return min(counts)\\n        \\n        minimum = minimum_jumps(0, 2)\\n        \\n        return minimum",
                "codeTag": "Java"
            },
            {
                "id": 1152560,
                "title": "4-lines-python-o-n-dynamic-programming-with-detailed-explanation-and-readable-code",
                "content": "`dp[i][l]` means from l line of i-th position to the end, how many side jump needed\\ninitialize with all \"inf\"\\n\\n`dp[-1][1 to 3] = 0`\\n\\n**If there\\'s no obstacle at l line of next position, no extra side jump is needed:**\\n    `dp[i][l] = dp[i + 1][l]`\\n\\n**Otherwise we need to select the best side jump target line.**\\n   ` dp[i][l] = min(1 + dp[i + 1][nl] for nl in line 1 to 3 except the cur line and the line with obstacle)`\\n    \\n**Two steps:**\\n        1. from line \\'l\\' at i side jump to line \\'nl\\' at i    **-> +1 side jump**\\n        2. from line \\'nl\\' at i direct jump to line \\'nl\\' at i + 1   **-> +0 side jump**\\n\\nSince only one line has the obstacle at each position, if the cur line at the cur position facing obstacle, then all the other lines could pass directly\\n\\t\\n\\t\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: list[int]) -> int:\\n        n = len(obstacles)\\n \\xA0 \\xA0 \\xA0 \\xA0dp = [[float(\"inf\")] * 4 for _ in range(n - 1)] + [[0] * 4]\\n\\n        for i in range(n - 2, -1, -1):\\n            for l in {1, 2, 3} - {obstacles[i]}:\\n                if obstacles[i + 1] != l:\\n                    dp[i][l] = dp[i + 1][l]\\n                else:\\n                    for nl in {1, 2, 3} - {obstacles[i], l}:\\n                        dp[i][l] = min(dp[i][l], 1 + dp[i + 1][nl])\\n\\n        return dp[0][2]\\n```\\n\\t\\n**Time Complexity:** O(3N) = O(N)\\n**Space complexity:** O(4N) = O(N)\\n\\nReduce space complexity to **O(1)**:\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, obs: list[int]) -> int:\\n        dp = [0] * 4\\n\\n        for i in range(len(obs) - 2, -1, -1):\\n            # for l in {1, 2, 3} - {obs[i], obs[i + 1]}:\\n            #     if obs[i + 1] == l:\\n            #          dp[l] = 1 + min(dp[nl] for nl in {1, 2, 3} - {obs[i], l})\\n            dp[obs[i + 1]] = 1 + min(dp[nl] for nl in {1, 2, 3} - {obs[i], obs[i + 1]})\\n\\n        return dp[2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: list[int]) -> int:\\n        n = len(obstacles)\\n \\xA0 \\xA0 \\xA0 \\xA0dp = [[float(\"inf\")] * 4 for _ in range(n - 1)] + [[0] * 4]\\n\\n        for i in range(n - 2, -1, -1):\\n            for l in {1, 2, 3} - {obstacles[i]}:\\n                if obstacles[i + 1] != l:\\n                    dp[i][l] = dp[i + 1][l]\\n                else:\\n                    for nl in {1, 2, 3} - {obstacles[i], l}:\\n                        dp[i][l] = min(dp[i][l], 1 + dp[i + 1][nl])\\n\\n        return dp[0][2]\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, obs: list[int]) -> int:\\n        dp = [0] * 4\\n\\n        for i in range(len(obs) - 2, -1, -1):\\n            # for l in {1, 2, 3} - {obs[i], obs[i + 1]}:\\n            #     if obs[i + 1] == l:\\n            #          dp[l] = 1 + min(dp[nl] for nl in {1, 2, 3} - {obs[i], l})\\n            dp[obs[i + 1]] = 1 + min(dp[nl] for nl in {1, 2, 3} - {obs[i], obs[i + 1]})\\n\\n        return dp[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152547,
                "title": "python-o-n-straightforward-open-list-with-explanation",
                "content": "* loop once and use openList hash set to keep track of available lanes/options\\n* check next step and remove available options from open list\\n    * if open list is empty increment count and set new openList\\n\\nto set new open list\\n```\\nopenList = set([1, 2, 3]) ^ set([obstacles[i], obstacles[i+1]]) & set([1, 2, 3])\\n```\\n> all options: set([1, 2, 3])\\n> not available: set([obstacles[i], obstacles[i+1]])\\n> & set([1, 2, 3]: to filter out 0\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # init with start lane 2\\n        openList = set([2])\\n        count = 0\\n\\n        for i in range(len(obstacles)-1):\\n            # check next step\\n            if obstacles[i+1] in openList:\\n                openList.remove(obstacles[i+1])\\n                # reset openlist and count\\n                if not openList:\\n                    openList = set([1, 2, 3]) ^ set([obstacles[i], obstacles[i+1]]) & set([1, 2, 3])\\n                    count += 1\\n\\n        return count\\n```\\n\\n> Time: O(n)\\n> Space: O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nopenList = set([1, 2, 3]) ^ set([obstacles[i], obstacles[i+1]]) & set([1, 2, 3])\\n```\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        # init with start lane 2\\n        openList = set([2])\\n        count = 0\\n\\n        for i in range(len(obstacles)-1):\\n            # check next step\\n            if obstacles[i+1] in openList:\\n                openList.remove(obstacles[i+1])\\n                # reset openlist and count\\n                if not openList:\\n                    openList = set([1, 2, 3]) ^ set([obstacles[i], obstacles[i+1]]) & set([1, 2, 3])\\n                    count += 1\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152507,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n      int arr[4];\\n       arr[1]=arr[3]=0;\\n        arr[2]=1;\\n        int ans=0;\\n        int l=0;\\n        int sz=obs.size();\\n        while(l<sz)\\n        {\\n           if(l+1<sz and obs[l+1]>0)\\n           {\\n               int t=obs[l+1];\\n               if(t==1)\\n               {\\n                   if(arr[1])\\n                   {\\n                       if(arr[2] or arr[3])\\n                       {\\n                           arr[1]=0;\\n                       }\\n                       else\\n                       {\\n                           if(obs[l]!=2)\\n                              arr[2]=1;\\n                           if(obs[l]!=3)\\n                            arr[3]=1;\\n                           arr[1]=0;\\n                           ans++;\\n                       }\\n                   }\\n               }\\n               else if(t==2)\\n               {\\n                  if(arr[2])\\n                  {\\n                      if(arr[1] or arr[3])\\n                      {\\n                         arr[2]=0; \\n                      }else\\n                      {\\n                          arr[2]=0;\\n                          if(obs[l]!=1)\\n                            arr[1]=1;\\n                          if(obs[l]!=3)\\n                            arr[3]=1;\\n                          ans++;\\n                      }\\n                  }\\n               }\\n               else\\n               {\\n                   if(arr[3])\\n                   {\\n                       if(arr[2] or arr[1])\\n                       {\\n                         arr[3]=0;  \\n                       }\\n                       else\\n                       {\\n                           if(obs[l]!=1)\\n                              arr[1]=1;\\n                           if(obs[l]!=2)\\n                              arr[2]=1;\\n                           arr[3]=0;\\n                           ans++;\\n                       }\\n                   }\\n               }\\n           }\\n            l++;\\n               \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obs) {\\n      int arr[4];\\n       arr[1]=arr[3]=0;\\n        arr[2]=1;\\n        int ans=0;\\n        int l=0;\\n        int sz=obs.size();\\n        while(l<sz)\\n        {\\n           if(l+1<sz and obs[l+1]>0)\\n           {\\n               int t=obs[l+1];\\n               if(t==1)\\n               {\\n                   if(arr[1])\\n                   {\\n                       if(arr[2] or arr[3])\\n                       {\\n                           arr[1]=0;\\n                       }\\n                       else\\n                       {\\n                           if(obs[l]!=2)\\n                              arr[2]=1;\\n                           if(obs[l]!=3)\\n                            arr[3]=1;\\n                           arr[1]=0;\\n                           ans++;\\n                       }\\n                   }\\n               }\\n               else if(t==2)\\n               {\\n                  if(arr[2])\\n                  {\\n                      if(arr[1] or arr[3])\\n                      {\\n                         arr[2]=0; \\n                      }else\\n                      {\\n                          arr[2]=0;\\n                          if(obs[l]!=1)\\n                            arr[1]=1;\\n                          if(obs[l]!=3)\\n                            arr[3]=1;\\n                          ans++;\\n                      }\\n                  }\\n               }\\n               else\\n               {\\n                   if(arr[3])\\n                   {\\n                       if(arr[2] or arr[1])\\n                       {\\n                         arr[3]=0;  \\n                       }\\n                       else\\n                       {\\n                           if(obs[l]!=1)\\n                              arr[1]=1;\\n                           if(obs[l]!=2)\\n                              arr[2]=1;\\n                           arr[3]=0;\\n                           ans++;\\n                       }\\n                   }\\n               }\\n           }\\n            l++;\\n               \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152428,
                "title": "javascript-tabulation-dp-solution",
                "content": "```javascript\\nvar minSideJumps = function(obstacles) {\\n    // create a dp cache for tabulation\\n    const dp = [...obstacles].map(() => new Array(4).fill(Infinity));\\n    \\n    // initialize the first positions\\n    dp[0][2] = 0;\\n    for (const lane of [1,3]) {\\n        if (obstacles[0] === lane) continue;\\n        dp[0][lane] = 1;\\n    }\\n\\n    // for every index we will do the following\\n    for (let i = 1; i < obstacles.length; i++) {\\n        \\n        // first we find the best way to get to this position from the previous index\\n        for (let nextLane = 1; nextLane <= 3; nextLane++) {\\n            if (obstacles[i] === nextLane) continue;\\n            dp[i][nextLane] = dp[i - 1][nextLane]\\n        }\\n        \\n        // then we find the best way to get to this position from the current index;\\n        for (let nextLane = 1; nextLane <= 3; nextLane++) {\\n            for (let prevLane = 1; prevLane <= 3; prevLane++) {\\n                if (prevLane === nextLane) continue;\\n                if (obstacles[i] === nextLane) continue;\\n                dp[i][nextLane] = Math.min(dp[i][nextLane], dp[i][prevLane] + 1)\\n            }\\n        }\\n    }\\n\\n    // return the best result after reaching the end\\n    return Math.min(...dp[dp.length - 1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar minSideJumps = function(obstacles) {\\n    // create a dp cache for tabulation\\n    const dp = [...obstacles].map(() => new Array(4).fill(Infinity));\\n    \\n    // initialize the first positions\\n    dp[0][2] = 0;\\n    for (const lane of [1,3]) {\\n        if (obstacles[0] === lane) continue;\\n        dp[0][lane] = 1;\\n    }\\n\\n    // for every index we will do the following\\n    for (let i = 1; i < obstacles.length; i++) {\\n        \\n        // first we find the best way to get to this position from the previous index\\n        for (let nextLane = 1; nextLane <= 3; nextLane++) {\\n            if (obstacles[i] === nextLane) continue;\\n            dp[i][nextLane] = dp[i - 1][nextLane]\\n        }\\n        \\n        // then we find the best way to get to this position from the current index;\\n        for (let nextLane = 1; nextLane <= 3; nextLane++) {\\n            for (let prevLane = 1; prevLane <= 3; prevLane++) {\\n                if (prevLane === nextLane) continue;\\n                if (obstacles[i] === nextLane) continue;\\n                dp[i][nextLane] = Math.min(dp[i][nextLane], dp[i][prevLane] + 1)\\n            }\\n        }\\n    }\\n\\n    // return the best result after reaching the end\\n    return Math.min(...dp[dp.length - 1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152426,
                "title": "python-dp-with-3-variables",
                "content": "This is a DP problem that can be solved with constant memory (only 3 variables). Here `x, y, z` represent the minimum cost of reaching lanes 1, 2, and 3 respectively. At the end of the DP, `min(x, y, z)` is the answer.\\n\\nFrom `x, y, z` we create the next step costs as `xy, yn, zn`. If there is an obstacle in the current step, the corresponding cost is simply `inf`. Otherwise we first find the minimum of the three, and then calculate the costs to other two based on this minimum value. While doing so we check if there is an obstacle as if this is the case the cost should remain `inf`.\\n\\nTime: `O(N)`\\nSpace: `O(1)`\\n\\n```python\\nclass Solution:\\n    def minSideJumps(self, obstacles):\\n        n = len(obstacles)\\n     \\t#DP variables, one for each lane\\n        x, y, z = 1, 0, 1\\n        #Bottom-up DP\\n        for i in range(1, n):\\n            #next step\\n            xn, yn, zn = x, y, z\\n            #check obstacles\\n            if obstacles[i] == 1: \\n                xn = math.inf\\n            if obstacles[i] == 2: \\n                yn = math.inf\\n            if obstacles[i] == 3: \\n                zn = math.inf\\n            #update min costs\\n            if xn == min(xn, yn, zn):\\n                if obstacles[i] != 2: yn = min(yn, xn + 1)\\n                if obstacles[i] != 3: zn = min(zn, xn + 1)\\n            elif yn == min(xn, yn, zn):\\n                if obstacles[i] != 1: xn = min(xn, yn + 1)\\n                if obstacles[i] != 3: zn = min(zn, yn + 1)\\n            else:\\n                if obstacles[i] != 1: xn = min(xn, zn + 1)\\n                if obstacles[i] != 2: yn = min(yn, zn + 1)\\n            #update original variables\\n            x, y, z = xn, yn, zn\\n        return min(x, y, z)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSideJumps(self, obstacles):\\n        n = len(obstacles)\\n     \\t#DP variables, one for each lane\\n        x, y, z = 1, 0, 1\\n        #Bottom-up DP\\n        for i in range(1, n):\\n            #next step\\n            xn, yn, zn = x, y, z\\n            #check obstacles\\n            if obstacles[i] == 1: \\n                xn = math.inf\\n            if obstacles[i] == 2: \\n                yn = math.inf\\n            if obstacles[i] == 3: \\n                zn = math.inf\\n            #update min costs\\n            if xn == min(xn, yn, zn):\\n                if obstacles[i] != 2: yn = min(yn, xn + 1)\\n                if obstacles[i] != 3: zn = min(zn, xn + 1)\\n            elif yn == min(xn, yn, zn):\\n                if obstacles[i] != 1: xn = min(xn, yn + 1)\\n                if obstacles[i] != 3: zn = min(zn, yn + 1)\\n            else:\\n                if obstacles[i] != 1: xn = min(xn, zn + 1)\\n                if obstacles[i] != 2: yn = min(yn, zn + 1)\\n            #update original variables\\n            x, y, z = xn, yn, zn\\n        return min(x, y, z)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152421,
                "title": "clean-python-3-bottom-up-dp",
                "content": "Construct path backwards.\\nIf we found there is an obstacle in front of the frog, update side jump from same position.\\nOtherwise the side jump is the same as the next position\\n\\nTime: `O(n)`\\nSpace: `O(n)`\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles) - 1\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(n)]\\n        dp.append([0, 0, 0])\\n        for i in reversed(range(n)):\\n            ob_lane = None\\n            for lane in range(3):\\n                if obstacles[i] == lane + 1: continue\\n                if dp[i+1][lane] == float(\\'inf\\'):\\n                    ob_lane = lane\\n                else:\\n                    dp[i][lane] = dp[i+1][lane]\\n            if ob_lane is not None: dp[i][ob_lane] = min(dp[i]) + 1\\n        return dp[0][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        n = len(obstacles) - 1\\n        dp = [[float(\\'inf\\')] * 3 for _ in range(n)]\\n        dp.append([0, 0, 0])\\n        for i in reversed(range(n)):\\n            ob_lane = None\\n            for lane in range(3):\\n                if obstacles[i] == lane + 1: continue\\n                if dp[i+1][lane] == float(\\'inf\\'):\\n                    ob_lane = lane\\n                else:\\n                    dp[i][lane] = dp[i+1][lane]\\n            if ob_lane is not None: dp[i][ob_lane] = min(dp[i]) + 1\\n        return dp[0][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070318,
                "title": "rust-dynamic-programming-o-1-space",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```rust\\nconst WIDTH: usize = 3;\\n\\nimpl Solution {\\n    pub fn min_side_jumps(vec: Vec<i32>) -> i32 {\\n        let vec = vec.into_iter()\\n            .rev()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        \\n        let mut dp = [Some(usize::MIN); WIDTH];\\n        for obstacle in vec {\\n            let obstacle = obstacle as usize;\\n            if obstacle > 0 {\\n                dp[obstacle - 1] = None; // not possible\\n            }\\n\\n            for ptr in usize::MIN..WIDTH {\\n                if ptr + 1 == obstacle {\\n                    continue;\\n                }\\n\\n                for ptr_next in usize::MIN..WIDTH {\\n                    if let Some(count_next) = dp[ptr_next] {\\n                        dp[ptr] = Some(\\n                            dp[ptr]\\n                                .unwrap_or(usize::MAX)\\n                                .min(count_next + 1)\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n\\n        dp[1].unwrap() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nconst WIDTH: usize = 3;\\n\\nimpl Solution {\\n    pub fn min_side_jumps(vec: Vec<i32>) -> i32 {\\n        let vec = vec.into_iter()\\n            .rev()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        \\n        let mut dp = [Some(usize::MIN); WIDTH];\\n        for obstacle in vec {\\n            let obstacle = obstacle as usize;\\n            if obstacle > 0 {\\n                dp[obstacle - 1] = None; // not possible\\n            }\\n\\n            for ptr in usize::MIN..WIDTH {\\n                if ptr + 1 == obstacle {\\n                    continue;\\n                }\\n\\n                for ptr_next in usize::MIN..WIDTH {\\n                    if let Some(count_next) = dp[ptr_next] {\\n                        dp[ptr] = Some(\\n                            dp[ptr]\\n                                .unwrap_or(usize::MAX)\\n                                .min(count_next + 1)\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n\\n        dp[1].unwrap() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050793,
                "title": "javascript-solution",
                "content": "# Intuition\\nWe can use the dp to solve this question\\n\\n# Approach\\nIncreasing the position by checking the obstacles and keeping the minimum from all the possible path\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} obstacles\\n * @return {number}\\n */\\n// var solve = function(obstacles, lane, pos, dp) {\\n//     if (pos === obstacles.length - 1) {\\n//         return 0;\\n//     }\\n//     // Obstacle on next straight position\\n//     if (dp[lane][pos] !== -1) {\\n//         return dp[lane][pos];\\n//     }\\n//     if (obstacles[pos + 1] !== lane) {\\n//         return solve(obstacles, lane, pos + 1, dp);\\n//     } else {\\n//         let ans = Number.MAX_SAFE_INTEGER;\\n//         for (let i = 1; i <= 3; i++) {\\n//             if (i !== lane && obstacles[pos] !== i) {\\n//                 ans = Math.min(ans, 1 + solve(obstacles, i, pos + 1, dp)); // Updated pos here\\n//             }\\n//         }\\n//         dp[lane][pos] = ans;\\n//         return ans;\\n//     }\\n// };\\n\\n// var minSideJumps = function(obstacles) {\\n//     let dp = Array.from({ length: 4 }, () => Array(obstacles.length).fill(-1));\\n//     return solve(obstacles, 2, 0, dp);\\n// };\\n\\n// var minSideJumps = function(obstacles) {\\n//     let n = obstacles.length;\\n//     let dp = Array.from({ length: 4 }, () => Array(n).fill(Number.MAX_SAFE_INTEGER));\\n    \\n//     // Initialize the last column of dp to 0\\n//     dp[0][n - 1] = 0;\\n//     dp[1][n - 1] = 0;\\n//     dp[2][n - 1] = 0;\\n//     dp[3][n - 1] = 0;\\n\\n//     for (let pos = n - 2; pos >= 0; pos--) {\\n//         for (let lane = 1; lane <= 3; lane++) {\\n//             if (obstacles[pos + 1] !== lane) {\\n//                 dp[lane][pos] = dp[lane][pos + 1];\\n//             } else {\\n//                 let ans = Number.MAX_SAFE_INTEGER;\\n//                 for (let i = 1; i <= 3; i++) {\\n//                     if (i !== lane && obstacles[pos] !== i) {\\n//                         ans = Math.min(ans, 1 + dp[i][pos + 1]);\\n//                     }\\n//                 }\\n//                 dp[lane][pos] = ans;\\n//             }\\n//         }\\n//     }\\n    \\n//     // Fix the return statement\\n//     return Math.min(dp[2][0], Math.min(1 + dp[1][0], 1 + dp[3][0]));\\n// };\\n\\nvar minSideJumps = function(obstacles) { \\nlet n = obstacles.length;\\n    let curr = Array(4).fill(Number.MAX_SAFE_INTEGER)\\n    let next = Array(4).fill(0)\\n\\n    for (let pos = n - 2; pos >= 0; pos--) {\\n        for (let lane = 1; lane <= 3; lane++) {\\n            if (obstacles[pos + 1] !== lane) {\\n                curr[lane] = next[lane]\\n            } else {\\n                let ans = Number.MAX_SAFE_INTEGER;\\n                for (let i = 1; i <= 3; i++) {\\n                    if (i !== lane && obstacles[pos] !== i) {\\n                        ans = Math.min(ans, 1 + next[i]);\\n                    }\\n                }\\n                curr[lane] = ans;\\n                next = curr\\n            }\\n        }\\n    }\\n    return Math.min(next[2], Math.min(1 + next[1], 1 + next[0]));\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} obstacles\\n * @return {number}\\n */\\n// var solve = function(obstacles, lane, pos, dp) {\\n//     if (pos === obstacles.length - 1) {\\n//         return 0;\\n//     }\\n//     // Obstacle on next straight position\\n//     if (dp[lane][pos] !== -1) {\\n//         return dp[lane][pos];\\n//     }\\n//     if (obstacles[pos + 1] !== lane) {\\n//         return solve(obstacles, lane, pos + 1, dp);\\n//     } else {\\n//         let ans = Number.MAX_SAFE_INTEGER;\\n//         for (let i = 1; i <= 3; i++) {\\n//             if (i !== lane && obstacles[pos] !== i) {\\n//                 ans = Math.min(ans, 1 + solve(obstacles, i, pos + 1, dp)); // Updated pos here\\n//             }\\n//         }\\n//         dp[lane][pos] = ans;\\n//         return ans;\\n//     }\\n// };\\n\\n// var minSideJumps = function(obstacles) {\\n//     let dp = Array.from({ length: 4 }, () => Array(obstacles.length).fill(-1));\\n//     return solve(obstacles, 2, 0, dp);\\n// };\\n\\n// var minSideJumps = function(obstacles) {\\n//     let n = obstacles.length;\\n//     let dp = Array.from({ length: 4 }, () => Array(n).fill(Number.MAX_SAFE_INTEGER));\\n    \\n//     // Initialize the last column of dp to 0\\n//     dp[0][n - 1] = 0;\\n//     dp[1][n - 1] = 0;\\n//     dp[2][n - 1] = 0;\\n//     dp[3][n - 1] = 0;\\n\\n//     for (let pos = n - 2; pos >= 0; pos--) {\\n//         for (let lane = 1; lane <= 3; lane++) {\\n//             if (obstacles[pos + 1] !== lane) {\\n//                 dp[lane][pos] = dp[lane][pos + 1];\\n//             } else {\\n//                 let ans = Number.MAX_SAFE_INTEGER;\\n//                 for (let i = 1; i <= 3; i++) {\\n//                     if (i !== lane && obstacles[pos] !== i) {\\n//                         ans = Math.min(ans, 1 + dp[i][pos + 1]);\\n//                     }\\n//                 }\\n//                 dp[lane][pos] = ans;\\n//             }\\n//         }\\n//     }\\n    \\n//     // Fix the return statement\\n//     return Math.min(dp[2][0], Math.min(1 + dp[1][0], 1 + dp[3][0]));\\n// };\\n\\nvar minSideJumps = function(obstacles) { \\nlet n = obstacles.length;\\n    let curr = Array(4).fill(Number.MAX_SAFE_INTEGER)\\n    let next = Array(4).fill(0)\\n\\n    for (let pos = n - 2; pos >= 0; pos--) {\\n        for (let lane = 1; lane <= 3; lane++) {\\n            if (obstacles[pos + 1] !== lane) {\\n                curr[lane] = next[lane]\\n            } else {\\n                let ans = Number.MAX_SAFE_INTEGER;\\n                for (let i = 1; i <= 3; i++) {\\n                    if (i !== lane && obstacles[pos] !== i) {\\n                        ans = Math.min(ans, 1 + next[i]);\\n                    }\\n                }\\n                curr[lane] = ans;\\n                next = curr\\n            }\\n        }\\n    }\\n    return Math.min(next[2], Math.min(1 + next[1], 1 + next[0]));\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050559,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minSideJumps(vector<int>& obstacles) {\\n    constexpr int kInf = 1e6;\\n\\n    // dp[i] := min jump to reach lane i\\n    vector<int> dp{kInf, 1, 0, 1};\\n\\n    for (const int obstacle : obstacles) {\\n      if (obstacle > 0)\\n        dp[obstacle] = kInf;\\n      for (int i = 1; i <= 3; ++i)  // Current\\n        if (i != obstacle)\\n          for (int j = 1; j <= 3; ++j)  // Prev\\n            dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)});\\n    }\\n\\n    return *min_element(dp.begin(), dp.end());\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minSideJumps(vector<int>& obstacles) {\\n    constexpr int kInf = 1e6;\\n\\n    // dp[i] := min jump to reach lane i\\n    vector<int> dp{kInf, 1, 0, 1};\\n\\n    for (const int obstacle : obstacles) {\\n      if (obstacle > 0)\\n        dp[obstacle] = kInf;\\n      for (int i = 1; i <= 3; ++i)  // Current\\n        if (i != obstacle)\\n          for (int j = 1; j <= 3; ++j)  // Prev\\n            dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)});\\n    }\\n\\n    return *min_element(dp.begin(), dp.end());\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043831,
                "title": "python-simple-solution-beats-97-in-time-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe keep track of all possible lanes one can be in, then prune away the lanes that are blocked when obstacles appear. This allows us to avoid having to predict which is the best lane to take.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncurr stores all possible lanes we can take. If we see an obstacle block some option in curr, just remove that from curr.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        curr = {2}\\n        i = 0; n = len(obstacles); ret = 0\\n        while i < n:\\n            obs = {obstacles[i]}\\n            curr = curr.difference(obs)\\n            #No more lanes that aren\\'t blocked\\n            if curr == set():\\n                #Find possible lanes we can take\\n                blockade = {obstacles[i-1], obstacles[i]}\\n                curr = {1,2,3}.difference(blockade)\\n                ret += 1\\n            i += 1\\n        return ret\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, obstacles: List[int]) -> int:\\n        curr = {2}\\n        i = 0; n = len(obstacles); ret = 0\\n        while i < n:\\n            obs = {obstacles[i]}\\n            curr = curr.difference(obs)\\n            #No more lanes that aren\\'t blocked\\n            if curr == set():\\n                #Find possible lanes we can take\\n                blockade = {obstacles[i-1], obstacles[i]}\\n                curr = {1,2,3}.difference(blockade)\\n                ret += 1\\n            i += 1\\n        return ret\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040345,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&obstacles,int currlane ,int currpos, vector<vector<int>>&dp)\\n    {\\n        //base case \\n        int n=obstacles.size()-1;\\n        if(currpos==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[currlane][currpos]!=-1)\\n        {\\n            return dp[currlane][currpos];\\n        }\\n\\n\\n        if(obstacles[currpos+1]!=currlane)\\n\\n        {\\n            return solve(obstacles,currlane,currpos+1,dp);\\n        }\\n        else\\n        {\\n            //sideways\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++)\\n            {   \\n                if(currlane!= i && obstacles[currpos]!=i)\\n                ans=min(ans,1+solve(obstacles,i,currpos,dp));\\n            }\\n            dp[currlane][currpos]=ans;\\n            return dp[currlane][currpos];\\n        }\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n         \\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n         return solve(obstacles,2,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>&obstacles,int currlane ,int currpos, vector<vector<int>>&dp)\\n    {\\n        //base case \\n        int n=obstacles.size()-1;\\n        if(currpos==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[currlane][currpos]!=-1)\\n        {\\n            return dp[currlane][currpos];\\n        }\\n\\n\\n        if(obstacles[currpos+1]!=currlane)\\n\\n        {\\n            return solve(obstacles,currlane,currpos+1,dp);\\n        }\\n        else\\n        {\\n            //sideways\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++)\\n            {   \\n                if(currlane!= i && obstacles[currpos]!=i)\\n                ans=min(ans,1+solve(obstacles,i,currpos,dp));\\n            }\\n            dp[currlane][currpos]=ans;\\n            return dp[currlane][currpos];\\n        }\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n         \\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n         return solve(obstacles,2,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028462,
                "title": "dp-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSideJumps(self, s: List[int]) -> int:\\n        f = float(\\'inf\\')\\n        dp = [[f for i in range(len(s))] for j in range(3)]\\n        dp[0][0] = 1\\n        dp[1][0] = 0\\n        dp[2][0] = 1\\n        n = len(s)\\n        p =1\\n        for i in range(1,n):\\n            t = [1,2,3]\\n            if(s[i] != 0):\\n                t.pop(s[i]-1) \\n            for j in range(3): dp[j][i] = dp[j][i-1] if s[i] != j+1 else f\\n            for j in range(len(t)):\\n                dp[t[j]-1][i] = min(dp[t[j]-1][i], 1+dp[t[j-1]-1][i], 1+dp[t[j-2]-1][i])\\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSideJumps(self, s: List[int]) -> int:\\n        f = float(\\'inf\\')\\n        dp = [[f for i in range(len(s))] for j in range(3)]\\n        dp[0][0] = 1\\n        dp[1][0] = 0\\n        dp[2][0] = 1\\n        n = len(s)\\n        p =1\\n        for i in range(1,n):\\n            t = [1,2,3]\\n            if(s[i] != 0):\\n                t.pop(s[i]-1) \\n            for j in range(3): dp[j][i] = dp[j][i-1] if s[i] != j+1 else f\\n            for j in range(len(t)):\\n                dp[t[j]-1][i] = min(dp[t[j]-1][i], 1+dp[t[j-1]-1][i], 1+dp[t[j-2]-1][i])\\n        return min(dp[0][-1], dp[1][-1], dp[2][-1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027212,
                "title": "runtime-error-can-someone-please-point-out-what-am-i-doing-wrong",
                "content": "```\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==23==ERROR: AddressSanitizer: stack-overflow on address 0x7ffc4321efc0 (pc 0x000000357172 bp 0x7ffc4321f0b0 sp 0x7ffc4321efc0 T0)\\n==23==ABORTING\\n\\nCan someone please point out what am i doing wrong? Getting runtime error at testcase 38th!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static const int inf = 1e9;\\n\\n    int n;\\n\\n    vector<set<int>> v;\\n\\n    pair<int,int> check(int lane) {\\n\\n        pair<int,int> ans;\\n\\n        if(lane == 1) {\\n\\n            ans.first = 1;\\n\\n            ans.second = 2;\\n\\n        } else if(lane == 2) {\\n\\n            ans.first = -1;\\n\\n            ans.second = 1;\\n\\n        } else if(lane == 3) {\\n\\n            ans.first = -1;\\n\\n            ans.second = -2;\\n        }\\n\\n        return ans;\\n    }\\n\\n    int rec(vector<vector<int>>& dp, vector<int>& o, int lane, int level) {\\n\\n        \\n        if(level == n-1)\\n            return 0;\\n\\n        if(dp[lane][level] != -1)\\n            return dp[lane][level];\\n\\n\\n        int ans = inf;\\n\\n        if(!v[lane].count(level+1))\\n            ans = min(ans, rec(dp, o, lane, level+1));\\n\\n        else {\\n\\n            pair<int,int> temp = check(lane);\\n\\n            // cout << \"lane: \" << lane << endl;\\n\\n            // cout << \"Side lane: \" << lane+temp.first << endl;\\n\\n            // cout << \"Side lane: \" << lane+temp.second << endl;\\n\\n            if(!v[lane+temp.first].count(level))\\n                ans = min(ans, 1 + rec(dp, o, lane+temp.first, level));\\n\\n            if(!v[lane+temp.second].count(level))\\n                ans = min(ans, 1 + rec(dp, o, lane+temp.second, level));\\n        }\\n\\n        return dp[lane][level] = ans;\\n    }\\n\\n    int minSideJumps(vector<int>& o) {\\n\\n        n = (int)o.size();\\n\\n        v.resize(4);\\n\\n        // cout << \"n: \" << n << endl;\\n        \\n        for(int i = 0; i < n; ++i) {\\n\\n            if(o[i])\\n                v[o[i]].insert(i);\\n        }\\n\\n        // for(int i = 1; i < 4; ++i) {\\n\\n        //     cout << i << \": \";\\n\\n        //     for(auto el: v[i])\\n        //         cout << el << \" \";\\n\\n        //     cout << endl;\\n        // }\\n\\n        vector<vector<int>> dp(4, vector<int>(n+1, -1));\\n\\n        return rec(dp, o, 2, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==23==ERROR: AddressSanitizer: stack-overflow on address 0x7ffc4321efc0 (pc 0x000000357172 bp 0x7ffc4321f0b0 sp 0x7ffc4321efc0 T0)\\n==23==ABORTING\\n\\nCan someone please point out what am i doing wrong? Getting runtime error at testcase 38th!\\n\\n# Code\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015823,
                "title": "greedy-search",
                "content": "# Intuition\\nLooking into examples, you can notice that if previous step had an obstacle, there is 1 and only 1 allowed step. \\n\\n\\n# Approach\\nMove forward and if there is an obstacle in front and there are more than 1 allowed step, keep moving forward and select the line that allowed to travel the longest distance.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n\\nfunc minSideJumps(obstacles []int) int {\\n\\t// The frog starts in lane 2 at position 0\\n\\tcurr := 2\\n\\tjumps := 0\\n\\n\\tvar search bool\\n\\n\\tfor i := 0; i < len(obstacles); i++ {\\n\\t\\tif !search {\\n\\t\\t\\tif curr == obstacles[i] {\\n\\t\\t\\t\\tjumps++\\n\\t\\t\\t\\tif obstacles[i-1] != 0 {\\n\\t\\t\\t\\t\\tcurr = 6 - obstacles[i-1] - curr // we know the line\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// look for the best line\\n\\t\\t\\t\\t\\tsearch = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif obstacles[i] != 0 && obstacles[i] != curr {\\n\\t\\t\\t\\tcurr = 6 - obstacles[i] - curr\\n\\t\\t\\t\\tsearch = false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn jumps\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc minSideJumps(obstacles []int) int {\\n\\t// The frog starts in lane 2 at position 0\\n\\tcurr := 2\\n\\tjumps := 0\\n\\n\\tvar search bool\\n\\n\\tfor i := 0; i < len(obstacles); i++ {\\n\\t\\tif !search {\\n\\t\\t\\tif curr == obstacles[i] {\\n\\t\\t\\t\\tjumps++\\n\\t\\t\\t\\tif obstacles[i-1] != 0 {\\n\\t\\t\\t\\t\\tcurr = 6 - obstacles[i-1] - curr // we know the line\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// look for the best line\\n\\t\\t\\t\\t\\tsearch = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif obstacles[i] != 0 && obstacles[i] != curr {\\n\\t\\t\\t\\tcurr = 6 - obstacles[i] - curr\\n\\t\\t\\t\\tsearch = false\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn jumps\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012055,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles,int i,int lane,vector<vector<int>>&dp){\\n        if(i >= obstacles.size()-1)\\n            return 0;\\n        if(dp[i][lane] != -1)\\n            return dp[i][lane];\\n        if(obstacles[i+1] != lane)\\n            return solve(obstacles,i+1,lane,dp);\\n        int ans = INT_MAX;\\n        for(int j = 1;j <= 3;j++)\\n            if(j != lane && obstacles[i] != j)\\n                ans = min(ans,1 + solve(obstacles,i,j,dp));\\n        return dp[i][lane] = ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size(),vector<int>(4,-1));\\n        return solve(obstacles,0,2,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obstacles,int i,int lane,vector<vector<int>>&dp){\\n        if(i >= obstacles.size()-1)\\n            return 0;\\n        if(dp[i][lane] != -1)\\n            return dp[i][lane];\\n        if(obstacles[i+1] != lane)\\n            return solve(obstacles,i+1,lane,dp);\\n        int ans = INT_MAX;\\n        for(int j = 1;j <= 3;j++)\\n            if(j != lane && obstacles[i] != j)\\n                ans = min(ans,1 + solve(obstacles,i,j,dp));\\n        return dp[i][lane] = ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(obstacles.size(),vector<int>(4,-1));\\n        return solve(obstacles,0,2,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008437,
                "title": "every-step-explain-with-commented-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int fun(vector<int>& obstacles, int currPos, int currLane,vector<vector<int>>&dp) {\\n        // Base case\\n        int n = obstacles.size() - 1;\\n        if (currPos == n) {\\n            return 0;\\n        }\\n\\n        if(dp[currLane][currPos]!=-1){\\n            return dp[currLane][currPos];\\n        }\\n\\n        // If there\\'s no obstacle in the next position,\\n        // no need to change lanes\\n        if (obstacles[currPos + 1] != currLane) {\\n            return fun(obstacles, currPos + 1, currLane,dp);\\n        } else {\\n            int ans = INT_MAX;\\n            for (int i = 1; i <= 3; i++) {\\n                // Check if it\\'s possible to jump to lane i and\\n                // it\\'s not the current lane\\n                if (obstacles[currPos] != i && currLane != i) {\\n                    int jumps = 1 + fun(obstacles, currPos, i,dp);\\n                    // Jump to lane i\\n                    ans = min(ans, jumps);\\n                }\\n            }\\n            dp[currLane][currPos]=ans;\\n            return dp[currLane][currPos];\\n        }\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return fun(obstacles, 0, 2,dp); \\n        // Start in the middle lane (lane 2)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int fun(vector<int>& obstacles, int currPos, int currLane,vector<vector<int>>&dp) {\\n        // Base case\\n        int n = obstacles.size() - 1;\\n        if (currPos == n) {\\n            return 0;\\n        }\\n\\n        if(dp[currLane][currPos]!=-1){\\n            return dp[currLane][currPos];\\n        }\\n\\n        // If there\\'s no obstacle in the next position,\\n        // no need to change lanes\\n        if (obstacles[currPos + 1] != currLane) {\\n            return fun(obstacles, currPos + 1, currLane,dp);\\n        } else {\\n            int ans = INT_MAX;\\n            for (int i = 1; i <= 3; i++) {\\n                // Check if it\\'s possible to jump to lane i and\\n                // it\\'s not the current lane\\n                if (obstacles[currPos] != i && currLane != i) {\\n                    int jumps = 1 + fun(obstacles, currPos, i,dp);\\n                    // Jump to lane i\\n                    ans = min(ans, jumps);\\n                }\\n            }\\n            dp[currLane][currPos]=ans;\\n            return dp[currLane][currPos];\\n        }\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return fun(obstacles, 0, 2,dp); \\n        // Start in the middle lane (lane 2)\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974549,
                "title": "easy-java-solution-easy-to-understand-memorization-java",
                "content": "The solve function:\\n\\nThis function is a recursive helper function that aims to find the minimum number of side jumps required for the frog to reach the endpoint.\\nIt takes four parameters:\\npos: The current position of the frog on the road.\\ncurr_lane: The current lane of the frog.\\nobstacles: An array representing the obstacles on each lane at different points.\\nmemo: A memoization array used to store already computed solutions to avoid redundant calculations.\\nThe base case is when the frog has reached or passed the endpoint (pos >= obstacles.length or pos == obstacles.length - 1), in which case the function returns 0.\\nBefore performing any calculations, the function checks if the result for the current position and lane is already computed and stored in the memoization array. If it is, the stored result is returned to avoid recomputation.\\nIf the frog can directly jump to the next point without encountering an obstacle in the current lane, the function calculates the result for the next point and returns 0.\\nIf there\\'s an obstacle in the current lane at the next point, the function calculates the minimum number of side jumps needed to traverse the obstacle.\\nFor each possible lane to jump to (different from the current lane) and without any obstacles, the function recursively calculates the number of side jumps needed to reach the same point in the new lane and adds 1 to it (since a side jump is performed).\\nThe minimum of these values is taken as the result for the current position and lane.\\nThe minSideJumps function:\\n\\nThis function serves as the entry point to the solution.\\nIt initializes the current lane to 2 and the starting position to 0.\\nIt also initializes a memoization array with dimensions [obstacles.length][4] (representing the positions and the 3 possible lanes).\\nIt calls the solve function with these initial parameters and returns the computed result.\\n\\n```\\nclass Solution {\\n    public int solve(int pos , int curr_lane,int obstacles[], Integer memo[][]) {\\n        if(pos>=obstacles.length || pos==obstacles.length-1) {\\n            return 0 ;\\n        }\\n        if(memo[pos][curr_lane]!=null) {\\n            return memo[pos][curr_lane] ;\\n        }\\n       int ans = Integer.MAX_VALUE; \\n        if(obstacles[pos+1]!=curr_lane) {\\n            return 0+solve(pos+1,curr_lane,obstacles,memo) ;\\n        }\\n        else {\\n             if(curr_lane==2) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=1) {\\n                    ans1 = 1+solve(pos,1,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=3) {\\n                    ans2 = 1+solve(pos,3,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n                \\n            }\\n            if(curr_lane==1) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=2) {\\n                    ans1 = 1+solve(pos,2,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=3) {\\n                    ans2 = 1+solve(pos,3,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n            }\\n            if(curr_lane==3) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=1) {\\n                    ans1 = 1+solve(pos,1,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=2) {\\n                    ans2 = 1+solve(pos,2,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n            }\\n        }\\n        memo[pos][curr_lane] = ans ;\\n        return ans ;\\n    }\\n    public int minSideJumps(int[] obstacles) {\\n        int curr_lane = 2 ;\\n        int pos = 0; \\n        Integer memo[][] = new Integer[obstacles.length][4] ;\\n        \\n       return solve(pos,curr_lane,obstacles,memo) ;\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int solve(int pos , int curr_lane,int obstacles[], Integer memo[][]) {\\n        if(pos>=obstacles.length || pos==obstacles.length-1) {\\n            return 0 ;\\n        }\\n        if(memo[pos][curr_lane]!=null) {\\n            return memo[pos][curr_lane] ;\\n        }\\n       int ans = Integer.MAX_VALUE; \\n        if(obstacles[pos+1]!=curr_lane) {\\n            return 0+solve(pos+1,curr_lane,obstacles,memo) ;\\n        }\\n        else {\\n             if(curr_lane==2) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=1) {\\n                    ans1 = 1+solve(pos,1,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=3) {\\n                    ans2 = 1+solve(pos,3,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n                \\n            }\\n            if(curr_lane==1) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=2) {\\n                    ans1 = 1+solve(pos,2,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=3) {\\n                    ans2 = 1+solve(pos,3,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n            }\\n            if(curr_lane==3) {\\n                int ans1 = Integer.MAX_VALUE; int ans2 = Integer.MAX_VALUE ;\\n                if(obstacles[pos]!=1) {\\n                    ans1 = 1+solve(pos,1,obstacles,memo) ;\\n                }\\n                if(obstacles[pos]!=2) {\\n                    ans2 = 1+solve(pos,2,obstacles,memo) ;\\n                }\\n                ans = Math.min(ans1,ans2) ;\\n            }\\n        }\\n        memo[pos][curr_lane] = ans ;\\n        return ans ;\\n    }\\n    public int minSideJumps(int[] obstacles) {\\n        int curr_lane = 2 ;\\n        int pos = 0; \\n        Integer memo[][] = new Integer[obstacles.length][4] ;\\n        \\n       return solve(pos,curr_lane,obstacles,memo) ;\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969280,
                "title": "easy-to-understand-recusion-memoization-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2*n)+O(3*n) = recursion*computation + grid making\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(3*n)+O(2*n) = grid + stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int dp[5*100000+5][3];\\n    int n;\\n    int jumps(int index, int lane,vector<vector<int>>&grid){\\n        if(index==n) return 0;\\n        if(dp[index][lane]!=-1) return dp[index][lane];\\n        int ans = 0;\\n        if(grid[index+1][lane]==0){\\n            ans+=jumps(index+1,lane,grid);\\n        } \\n        if(grid[index+1][lane]!=0){\\n                /*\\n                _R_\\n                _F_\\n                */\\n                if(lane == 1){\\n                 if(grid[index][lane-1]==0 && grid[index][lane+1]==0) ans+=min(jumps(index+1,lane+1,grid)+1,jumps(index+1,lane-1,grid)+1);\\n                 else if(grid[index][lane+1]!=0) ans+=1+jumps(index+1,lane-1,grid);\\n                 else if(grid[index][lane-1]!=0) cnt++, ans+=1+jumps(index+1,lane+1,grid);\\n                }\\n                else if(lane==2){\\n                 if(grid[index][lane-1]==0 && grid[index][lane-2]==0) ans+=min(jumps(index+1,lane-1,grid)+1,jumps(index+1,lane-2,grid)+1);\\n                 else if(grid[index][lane-1]!=0) ans+=1+jumps(index+1,lane-2,grid);\\n                 else if(grid[index][lane-2]!=0) cnt++, ans+=1+jumps(index+1,lane-1,grid); \\n\\n                }\\n                else if(lane == 0){\\n                 if(grid[index][lane+1]==0 && grid[index][lane+2]==0) ans+=min(jumps(index+1,lane+1,grid)+1,jumps(index+1,lane+2,grid)+1);\\n                 else if(grid[index][lane+1]!=0) ans+=1+jumps(index+1,lane+2,grid);\\n                 else if(grid[index][lane+2]!=0) ans+=1+jumps(index+1,lane+1,grid);\\n                }\\n        }\\n        return dp[index][lane]=ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        n = obstacles.size();\\n        vector<vector<int>> grid(n,vector<int>(3,0));\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0; i<n; i++){\\n            if(obstacles[i]!=0){\\n                grid[i][obstacles[i]-1] = 1;\\n            }\\n        }\\n\\n        //  for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<3; j++){\\n        //         cout << grid[i][j] << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n\\n        n--;\\n\\n        \\n        return jumps(0,1,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int dp[5*100000+5][3];\\n    int n;\\n    int jumps(int index, int lane,vector<vector<int>>&grid){\\n        if(index==n) return 0;\\n        if(dp[index][lane]!=-1) return dp[index][lane];\\n        int ans = 0;\\n        if(grid[index+1][lane]==0){\\n            ans+=jumps(index+1,lane,grid);\\n        } \\n        if(grid[index+1][lane]!=0){\\n                /*\\n                _R_\\n                _F_\\n                */\\n                if(lane == 1){\\n                 if(grid[index][lane-1]==0 && grid[index][lane+1]==0) ans+=min(jumps(index+1,lane+1,grid)+1,jumps(index+1,lane-1,grid)+1);\\n                 else if(grid[index][lane+1]!=0) ans+=1+jumps(index+1,lane-1,grid);\\n                 else if(grid[index][lane-1]!=0) cnt++, ans+=1+jumps(index+1,lane+1,grid);\\n                }\\n                else if(lane==2){\\n                 if(grid[index][lane-1]==0 && grid[index][lane-2]==0) ans+=min(jumps(index+1,lane-1,grid)+1,jumps(index+1,lane-2,grid)+1);\\n                 else if(grid[index][lane-1]!=0) ans+=1+jumps(index+1,lane-2,grid);\\n                 else if(grid[index][lane-2]!=0) cnt++, ans+=1+jumps(index+1,lane-1,grid); \\n\\n                }\\n                else if(lane == 0){\\n                 if(grid[index][lane+1]==0 && grid[index][lane+2]==0) ans+=min(jumps(index+1,lane+1,grid)+1,jumps(index+1,lane+2,grid)+1);\\n                 else if(grid[index][lane+1]!=0) ans+=1+jumps(index+1,lane+2,grid);\\n                 else if(grid[index][lane+2]!=0) ans+=1+jumps(index+1,lane+1,grid);\\n                }\\n        }\\n        return dp[index][lane]=ans;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        n = obstacles.size();\\n        vector<vector<int>> grid(n,vector<int>(3,0));\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0; i<n; i++){\\n            if(obstacles[i]!=0){\\n                grid[i][obstacles[i]-1] = 1;\\n            }\\n        }\\n\\n        //  for(int i = 0; i<n; i++){\\n        //     for(int j = 0; j<3; j++){\\n        //         cout << grid[i][j] << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n\\n        n--;\\n\\n        \\n        return jumps(0,1,grid);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3959568,
                "title": "use-dynamic-programming",
                "content": "\\n# CPP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>&obstacles,int currlan ,int currpos){\\nint n=obstacles.size()-1;\\nif(currpos==n)\\nreturn 0;\\n if(obstacles[currpos+1]!=currlan){\\n     return solve(obstacles,currlan,currpos+1);\\n }\\n else{\\n     int ans=INT_MAX;\\n     for(int i=1;i<=3;i++)\\n{\\n    if(currlan!=i && obstacles[currpos]!=i)\\nans=min(ans,1+solve(obstacles,i,currpos+1));\\n} \\nreturn ans;\\n}\\n\\n}\\nint solveMem(vector<int>&obstacles,int currlan ,int currpos,vector<vector<int>>dp){\\nint n=obstacles.size()-1;\\nif(currpos==n)\\nreturn 0;\\nif(dp[currlan][currpos]!=-1)\\nreturn dp[currlan][currpos];\\n if(obstacles[currpos+1]!=currlan){\\n     return solveMem(obstacles,currlan,currpos+1,dp);\\n }\\n else{\\n     int ans=INT_MAX;\\n     for(int i=1;i<=3;i++)\\n{\\n    if(currlan!=i && obstacles[currpos]!=i)\\nans=min(ans,1+solveMem(obstacles,i,currpos+1,dp));\\n} \\ndp[currlan][currpos]=ans;\\n\\nreturn dp[currlan][currpos];\\n}\\n\\n}\\n\\nint solveTab(vector<int>&obstacles){\\nint n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),INT_MAX));\\ndp[0][n]=0;\\ndp[1][n]=0;\\ndp[2][n]=0;\\ndp[3][n]=0;\\nfor(int currpos=n-1;currpos>=0;currpos--){\\nfor(int currlan=1;currlan<=3;currlan++){\\n    if(obstacles[currpos+1]!=currlan)\\n      dp[currlan][currpos]=dp[currlan][currpos+1];\\n      else{\\n          int ans=1e9;\\n          for(int i=1;i<=3;i++){\\n              if(currlan!=i && obstacles[currpos]!=i)\\n              ans=min(ans,1+dp[i][currpos+1]);\\n          }\\n          dp[currlan][currpos]=ans;\\n      }\\n}\\n}\\nreturn min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n\\n}\\nint solveSO(vector<int>&obstacles){\\nint n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),INT_MAX));\\nvector<int>curr(4,INT_MAX);\\nvector<int>next(4,INT_MAX);\\nnext[0]=0;\\nnext[1]=0;\\nnext[2]=0;\\nnext[3]=0;\\nfor(int currpos=n-1;currpos>=0;currpos--){\\nfor(int currlan=1;currlan<=3;currlan++){\\n    if(obstacles[currpos+1]!=currlan)\\n      curr[currlan]=next[currlan];\\n      else{\\n          int ans=1e9;\\n          for(int i=1;i<=3;i++){\\n              if(currlan!=i && obstacles[currpos]!=i)\\n              ans=min(ans,1+next[i]);\\n          }\\n          curr[currlan]=ans;\\n      }\\n}\\nnext=curr;\\n}\\nreturn min(next[2],min(1+next[1],1+next[3]));\\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n        // return solve(obstacles,2,0);\\n       // vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n    // return solveMem(obstacles,2,0,dp);\\n    //  return solveTab(obstacles);\\n     return solveSO(obstacles);\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>&obstacles,int currlan ,int currpos){\\nint n=obstacles.size()-1;\\nif(currpos==n)\\nreturn 0;\\n if(obstacles[currpos+1]!=currlan){\\n     return solve(obstacles,currlan,currpos+1);\\n }\\n else{\\n     int ans=INT_MAX;\\n     for(int i=1;i<=3;i++)\\n{\\n    if(currlan!=i && obstacles[currpos]!=i)\\nans=min(ans,1+solve(obstacles,i,currpos+1));\\n} \\nreturn ans;\\n}\\n\\n}\\nint solveMem(vector<int>&obstacles,int currlan ,int currpos,vector<vector<int>>dp){\\nint n=obstacles.size()-1;\\nif(currpos==n)\\nreturn 0;\\nif(dp[currlan][currpos]!=-1)\\nreturn dp[currlan][currpos];\\n if(obstacles[currpos+1]!=currlan){\\n     return solveMem(obstacles,currlan,currpos+1,dp);\\n }\\n else{\\n     int ans=INT_MAX;\\n     for(int i=1;i<=3;i++)\\n{\\n    if(currlan!=i && obstacles[currpos]!=i)\\nans=min(ans,1+solveMem(obstacles,i,currpos+1,dp));\\n} \\ndp[currlan][currpos]=ans;\\n\\nreturn dp[currlan][currpos];\\n}\\n\\n}\\n\\nint solveTab(vector<int>&obstacles){\\nint n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),INT_MAX));\\ndp[0][n]=0;\\ndp[1][n]=0;\\ndp[2][n]=0;\\ndp[3][n]=0;\\nfor(int currpos=n-1;currpos>=0;currpos--){\\nfor(int currlan=1;currlan<=3;currlan++){\\n    if(obstacles[currpos+1]!=currlan)\\n      dp[currlan][currpos]=dp[currlan][currpos+1];\\n      else{\\n          int ans=1e9;\\n          for(int i=1;i<=3;i++){\\n              if(currlan!=i && obstacles[currpos]!=i)\\n              ans=min(ans,1+dp[i][currpos+1]);\\n          }\\n          dp[currlan][currpos]=ans;\\n      }\\n}\\n}\\nreturn min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n\\n}\\nint solveSO(vector<int>&obstacles){\\nint n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),INT_MAX));\\nvector<int>curr(4,INT_MAX);\\nvector<int>next(4,INT_MAX);\\nnext[0]=0;\\nnext[1]=0;\\nnext[2]=0;\\nnext[3]=0;\\nfor(int currpos=n-1;currpos>=0;currpos--){\\nfor(int currlan=1;currlan<=3;currlan++){\\n    if(obstacles[currpos+1]!=currlan)\\n      curr[currlan]=next[currlan];\\n      else{\\n          int ans=1e9;\\n          for(int i=1;i<=3;i++){\\n              if(currlan!=i && obstacles[currpos]!=i)\\n              ans=min(ans,1+next[i]);\\n          }\\n          curr[currlan]=ans;\\n      }\\n}\\nnext=curr;\\n}\\nreturn min(next[2],min(1+next[1],1+next[3]));\\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n        // return solve(obstacles,2,0);\\n       // vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n    // return solveMem(obstacles,2,0,dp);\\n    //  return solveTab(obstacles);\\n     return solveSO(obstacles);\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944941,
                "title": "easy-c-code-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>&obs,int currl,int currp ,vector<vector<int>>&dp){\\n  int n = obs.size()-1;\\n  if(n==currp) return 0;\\n  if(dp[currl][currp] != -1) return dp[currl][currp];\\n  if(obs[currp+1]!=currl){\\n      return solve(obs,currl,currp+1,dp);\\n  }else{\\n      int ans = INT_MAX;\\n      for(int i=1;i<=3;i++){\\n          if(currl !=i && obs[currp] !=i){\\n              ans = min(ans,1+solve(obs,i,currp,dp));\\n          }\\n      }\\n      dp[currl][currp] = ans;\\n      return dp[currl][currp];\\n  }\\n}\\n    int minSideJumps(vector<int>& obs) {\\n        vector<vector<int>>dp(4,vector<int>(obs.size(),-1));\\n        return solve(obs,2,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>&obs,int currl,int currp ,vector<vector<int>>&dp){\\n  int n = obs.size()-1;\\n  if(n==currp) return 0;\\n  if(dp[currl][currp] != -1) return dp[currl][currp];\\n  if(obs[currp+1]!=currl){\\n      return solve(obs,currl,currp+1,dp);\\n  }else{\\n      int ans = INT_MAX;\\n      for(int i=1;i<=3;i++){\\n          if(currl !=i && obs[currp] !=i){\\n              ans = min(ans,1+solve(obs,i,currp,dp));\\n          }\\n      }\\n      dp[currl][currp] = ans;\\n      return dp[currl][currp];\\n  }\\n}\\n    int minSideJumps(vector<int>& obs) {\\n        vector<vector<int>>dp(4,vector<int>(obs.size(),-1));\\n        return solve(obs,2,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913985,
                "title": "can-someone-guide-why-i-am-getting-runtime-error-on-test-case-38",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp(int dist, int lane, vector<vector<int>> &r, vector<vector<int>> &mem){\\n        if(dist == r[0].size()-1)return 0;\\n        if(r[lane][dist+1] == 0){\\n            return dp(dist+1, lane, r, mem);\\n        }\\n\\n        // shift to other lanes\\n\\n        if(mem[lane][dist] != -1)return mem[lane][dist];\\n\\n        // lane 1\\n        int lane1 = (r[0][dist] == 0 && lane != 0) ? (dp(dist, 0, r, mem) + 1) : 1e9;\\n        // lane 2\\n        int lane2 = (r[1][dist] == 0 && lane != 1)  ? (dp(dist, 1, r, mem) + 1) : 1e9;\\n        // lane 3\\n        int lane3 = (r[2][dist] == 0 && lane != 2)  ? (dp(dist, 2, r, mem) + 1): 1e9;\\n\\n        return mem[lane][dist] = min({lane1, lane2, lane3});\\n    }\\n\\n    int minSideJumps(vector<int>& o) {\\n        int n = o.size();\\n        vector<vector<int>> r(3, vector<int> (n, 0));\\n        vector<vector<int>> mem(3, vector<int> (n, -1));\\n        for(int i=0; i<n; i++){\\n            if(o[i] == 0)continue;\\n            else r[o[i]-1][i] = 1;\\n        }\\n\\n        return dp(0,1,r, mem);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp(int dist, int lane, vector<vector<int>> &r, vector<vector<int>> &mem){\\n        if(dist == r[0].size()-1)return 0;\\n        if(r[lane][dist+1] == 0){\\n            return dp(dist+1, lane, r, mem);\\n        }\\n\\n        // shift to other lanes\\n\\n        if(mem[lane][dist] != -1)return mem[lane][dist];\\n\\n        // lane 1\\n        int lane1 = (r[0][dist] == 0 && lane != 0) ? (dp(dist, 0, r, mem) + 1) : 1e9;\\n        // lane 2\\n        int lane2 = (r[1][dist] == 0 && lane != 1)  ? (dp(dist, 1, r, mem) + 1) : 1e9;\\n        // lane 3\\n        int lane3 = (r[2][dist] == 0 && lane != 2)  ? (dp(dist, 2, r, mem) + 1): 1e9;\\n\\n        return mem[lane][dist] = min({lane1, lane2, lane3});\\n    }\\n\\n    int minSideJumps(vector<int>& o) {\\n        int n = o.size();\\n        vector<vector<int>> r(3, vector<int> (n, 0));\\n        vector<vector<int>> mem(3, vector<int> (n, -1));\\n        for(int i=0; i<n; i++){\\n            if(o[i] == 0)continue;\\n            else r[o[i]-1][i] = 1;\\n        }\\n\\n        return dp(0,1,r, mem);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3913024,
                "title": "c-space-optimized-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to reach the end of the lane by minizing side jumps. Hence at each i keep track of number of jumps required to reach lane 1, 2, 3. Note difference between no of jumps between any 2 nodes cannot exceed 1.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI kept 3 variables to keep track of jumps. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& o) {\\n        int n=o.size();\\n        int a=1, b=0, c=1, ta, tb, tc, inf=5*1e5;\\n        if(o[0]==1){\\n            a=inf;\\n        }\\n        if(o[0]==3){\\n            c=inf;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(o[i]==1){\\n                ta=inf;\\n                tb=min(b, c+1);\\n                tc=min(c, b+1);\\n            }else if(o[i]==2){\\n                ta=min(a, c+1);\\n                tb=inf;\\n                tc=min(c, a+1);\\n            }else if(o[i]==3){\\n                ta=min(a, b+1);\\n                tb=min(b, a+1);\\n                tc=inf;\\n            }else{\\n                ta=min(a, min(b+1, c+1));\\n                tb=min(b, min(a+1, c+1));\\n                tc=min(c, min(a+1, b+1));\\n            }\\n            a=ta;b=tb;c=tc;\\n        }\\n        return min(a, min(b, c));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& o) {\\n        int n=o.size();\\n        int a=1, b=0, c=1, ta, tb, tc, inf=5*1e5;\\n        if(o[0]==1){\\n            a=inf;\\n        }\\n        if(o[0]==3){\\n            c=inf;\\n        }\\n        for(int i=1; i<n; i++){\\n            if(o[i]==1){\\n                ta=inf;\\n                tb=min(b, c+1);\\n                tc=min(c, b+1);\\n            }else if(o[i]==2){\\n                ta=min(a, c+1);\\n                tb=inf;\\n                tc=min(c, a+1);\\n            }else if(o[i]==3){\\n                ta=min(a, b+1);\\n                tb=min(b, a+1);\\n                tc=inf;\\n            }else{\\n                ta=min(a, min(b+1, c+1));\\n                tb=min(b, min(a+1, c+1));\\n                tc=min(c, min(a+1, b+1));\\n            }\\n            a=ta;b=tb;c=tc;\\n        }\\n        return min(a, min(b, c));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897223,
                "title": "memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solvemem(vector<int>& obstacles,vector<vector<int>>&dp,int lane,int pos){\\n        //base case\\n        if(pos==obstacles.size()-1)return 0;\\n        if(dp[lane][pos]!=-1)return dp[lane][pos];\\n        //if no obstacle go forward\\n        if(obstacles[pos+1]!=lane)return solvemem(obstacles,dp,lane,pos+1);\\n        //if obstacle present\\n        int ans=INT_MAX;\\n        for(int i=1;i<=3;i++){\\n                if(lane!=i && obstacles[pos]!=i){\\n                    ans=min(ans,1+solvemem(obstacles,dp,i,pos+1));\\n                }\\n            }\\n        \\n        return dp[lane][pos]=ans;\\n\\n    }\\n   \\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(4,vector<int>(n,-1));\\n        return solvemem(obstacles,dp,2,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solvemem(vector<int>& obstacles,vector<vector<int>>&dp,int lane,int pos){\\n        //base case\\n        if(pos==obstacles.size()-1)return 0;\\n        if(dp[lane][pos]!=-1)return dp[lane][pos];\\n        //if no obstacle go forward\\n        if(obstacles[pos+1]!=lane)return solvemem(obstacles,dp,lane,pos+1);\\n        //if obstacle present\\n        int ans=INT_MAX;\\n        for(int i=1;i<=3;i++){\\n                if(lane!=i && obstacles[pos]!=i){\\n                    ans=min(ans,1+solvemem(obstacles,dp,i,pos+1));\\n                }\\n            }\\n        \\n        return dp[lane][pos]=ans;\\n\\n    }\\n   \\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(4,vector<int>(n,-1));\\n        return solvemem(obstacles,dp,2,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873909,
                "title": "i-have-no-fuckin-idea-what-i-have-done",
                "content": "# Intuition\\n- Fuck intuition\\n\\n# Approach\\n- Infinite monkey theorem (Slam you head into the keyboard until the solution is written randomly)\\n\\n# Complexity\\n- Time complexity: The same amount I take to cum\\n\\n- Space complexity: The same size as your mom\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int jumps = 0;\\n        int lane = 2;\\n        int location = 0;\\n        while(location < obstacles.size() - 1){\\n            if(obstacles[location+1] != lane){\\n                location += 1;\\n                continue;\\n            }\\n            if((obstacles[location] == lane+1 || obstacles[location] == lane -1)\\n            && obstacles[location] != 0){\\n                jumps += 1;\\n                lane = 6 - lane - obstacles[location];\\n                location +=1;\\n                continue;\\n            }\\n            if(obstacles[location] != 0){\\n                jumps += 1;\\n                lane = 6 - lane - obstacles[location];\\n                location += 1;\\n                continue;\\n            }\\n            else{\\n                jumps += 1;\\n                int i = location+1;\\n                while(true){\\n                    if(i > obstacles.size() - 1){\\n                        lane = (lane == 3 || lane == 1) ? 2 : 3;\\n                        break;\\n                    }\\n                    if(obstacles[i] != 0 && obstacles[i] != lane){\\n                        lane = 6  - lane - obstacles[i];\\n                        break; \\n                    }\\n                \\n                    i += 1;\\n                }\\n                location += 1;\\n            }\\n        \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int jumps = 0;\\n        int lane = 2;\\n        int location = 0;\\n        while(location < obstacles.size() - 1){\\n            if(obstacles[location+1] != lane){\\n                location += 1;\\n                continue;\\n            }\\n            if((obstacles[location] == lane+1 || obstacles[location] == lane -1)\\n            && obstacles[location] != 0){\\n                jumps += 1;\\n                lane = 6 - lane - obstacles[location];\\n                location +=1;\\n                continue;\\n            }\\n            if(obstacles[location] != 0){\\n                jumps += 1;\\n                lane = 6 - lane - obstacles[location];\\n                location += 1;\\n                continue;\\n            }\\n            else{\\n                jumps += 1;\\n                int i = location+1;\\n                while(true){\\n                    if(i > obstacles.size() - 1){\\n                        lane = (lane == 3 || lane == 1) ? 2 : 3;\\n                        break;\\n                    }\\n                    if(obstacles[i] != 0 && obstacles[i] != lane){\\n                        lane = 6  - lane - obstacles[i];\\n                        break; \\n                    }\\n                \\n                    i += 1;\\n                }\\n                location += 1;\\n            }\\n        \\n        }\\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832352,
                "title": "eazy-c-dp-4-methods-recursion-recursion-memoisation-tabulation-space-optimization",
                "content": "# Intuition\\nJust start your solution using thinking of iterative approach until you reach to comparing answer to adjacent lanes for the smaller output .Here recursion kicks in.\\nThen just basic algorithms of Dynamic programming , keep it rolling.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\nFor Best Case (SO) \\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obs,int currpos,int currLane){\\n        int n=obs.size()-1;\\n        if(currpos==n)\\n        return 0;\\n\\n        int jump=0;\\n        if(obs[currpos+1]!=currLane)\\n        return solve(obs,currpos+1,currLane);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currLane!=i && obs[currpos]!=i)\\n                {\\n                    ans=min(ans,1+solve(obs,currpos,i));\\n                }   \\n            }\\n            return ans;\\n        }\\n    }\\n    int solveMem(vector<int>& obs,int currpos,int currLane,vector<vector<int>>&dp){\\n        int n=obs.size()-1;\\n        if(currpos==n)\\n        return 0;\\n        if(dp[currLane][currpos]!=-1)\\n        return dp[currLane][currpos];\\n\\n        if(obs[currpos+1]!=currLane)\\n        return solveMem(obs,currpos+1,currLane,dp);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currLane!=i && obs[currpos]!=i)\\n                {\\n                    ans=min(ans,1+solveMem(obs,currpos,i,dp));\\n                }  \\n\\n            }\\n            dp[currLane][currpos]=ans;\\n            return dp[currLane][currpos];\\n        }\\n    }\\n\\n    int solveTab(vector<int>&obs){\\n        int n=obs.size()-1;\\n        vector<vector<int>>dp(4,vector<int>(obs.size(),1e9));\\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n\\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int lane=1;lane<=3;lane++){\\n                if(obs[pos+1]!=lane)\\n                dp[lane][pos]=dp[lane][pos+1];\\n                else\\n                {\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(lane!=i && obs[pos]!=i)\\n                        {\\n                            ans=min(ans,1+dp[i][pos+1]);\\n                        }\\n                    }\\n                    dp[lane][pos]=ans;\\n                }\\n            }\\n        }\\n        return min(dp[2][0],min(dp[1][0]+1,dp[3][0]+1));\\n    }\\n\\n    int solveSO(vector<int>&obs){\\n        int n=obs.size()-1;\\n        vector<int>curr(4,1e9);\\n        vector<int>next(4,1e9);\\n\\n        next[0]=0;\\n        next[1]=0;\\n        next[2]=0;\\n        next[3]=0;\\n\\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int lane=1;lane<=3;lane++){\\n                if(obs[pos+1]!=lane)\\n                curr[lane]=next[lane];\\n                else\\n                {\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(lane!=i && obs[pos]!=i)\\n                        {\\n                            ans=min(ans,1+next[i]);\\n                        }\\n                    }\\n                    curr[lane]=ans;\\n                }\\n            }\\n            next=curr;\\n        }\\n        return min(next[2],min(next[1]+1,next[3]+1));\\n    }\\n    int minSideJumps(vector<int>& obs) {\\n        //////Recursion\\n        // return solve(obs,0,2);\\n\\n        //////Memoization\\n        // vector<vector<int>>dp(4,vector<int>(obs.size(),-1));\\n        // return solveMem(obs,0,2,dp);\\n\\n        //////Tabulation\\n        // return solveTab(obs);\\n\\n        //////Space Optimization\\n         return solveSO(obs);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& obs,int currpos,int currLane){\\n        int n=obs.size()-1;\\n        if(currpos==n)\\n        return 0;\\n\\n        int jump=0;\\n        if(obs[currpos+1]!=currLane)\\n        return solve(obs,currpos+1,currLane);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currLane!=i && obs[currpos]!=i)\\n                {\\n                    ans=min(ans,1+solve(obs,currpos,i));\\n                }   \\n            }\\n            return ans;\\n        }\\n    }\\n    int solveMem(vector<int>& obs,int currpos,int currLane,vector<vector<int>>&dp){\\n        int n=obs.size()-1;\\n        if(currpos==n)\\n        return 0;\\n        if(dp[currLane][currpos]!=-1)\\n        return dp[currLane][currpos];\\n\\n        if(obs[currpos+1]!=currLane)\\n        return solveMem(obs,currpos+1,currLane,dp);\\n        else\\n        {\\n            int ans=INT_MAX;\\n            for(int i=1;i<=3;i++){\\n                if(currLane!=i && obs[currpos]!=i)\\n                {\\n                    ans=min(ans,1+solveMem(obs,currpos,i,dp));\\n                }  \\n\\n            }\\n            dp[currLane][currpos]=ans;\\n            return dp[currLane][currpos];\\n        }\\n    }\\n\\n    int solveTab(vector<int>&obs){\\n        int n=obs.size()-1;\\n        vector<vector<int>>dp(4,vector<int>(obs.size(),1e9));\\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n\\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int lane=1;lane<=3;lane++){\\n                if(obs[pos+1]!=lane)\\n                dp[lane][pos]=dp[lane][pos+1];\\n                else\\n                {\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(lane!=i && obs[pos]!=i)\\n                        {\\n                            ans=min(ans,1+dp[i][pos+1]);\\n                        }\\n                    }\\n                    dp[lane][pos]=ans;\\n                }\\n            }\\n        }\\n        return min(dp[2][0],min(dp[1][0]+1,dp[3][0]+1));\\n    }\\n\\n    int solveSO(vector<int>&obs){\\n        int n=obs.size()-1;\\n        vector<int>curr(4,1e9);\\n        vector<int>next(4,1e9);\\n\\n        next[0]=0;\\n        next[1]=0;\\n        next[2]=0;\\n        next[3]=0;\\n\\n        for(int pos=n-1;pos>=0;pos--){\\n            for(int lane=1;lane<=3;lane++){\\n                if(obs[pos+1]!=lane)\\n                curr[lane]=next[lane];\\n                else\\n                {\\n                    int ans=1e9;\\n                    for(int i=1;i<=3;i++){\\n                        if(lane!=i && obs[pos]!=i)\\n                        {\\n                            ans=min(ans,1+next[i]);\\n                        }\\n                    }\\n                    curr[lane]=ans;\\n                }\\n            }\\n            next=curr;\\n        }\\n        return min(next[2],min(next[1]+1,next[3]+1));\\n    }\\n    int minSideJumps(vector<int>& obs) {\\n        //////Recursion\\n        // return solve(obs,0,2);\\n\\n        //////Memoization\\n        // vector<vector<int>>dp(4,vector<int>(obs.size(),-1));\\n        // return solveMem(obs,0,2,dp);\\n\\n        //////Tabulation\\n        // return solveTab(obs);\\n\\n        //////Space Optimization\\n         return solveSO(obs);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824541,
                "title": "c-memorization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>& obstacles, int currlane, int currpos,  vector<vector<int>> &dp){\\n        int n=obstacles.size()-1;\\n        if(currpos==n){\\n            return 0;\\n        }\\n        if(dp[currlane][currpos]!=-1){\\n            return dp[currlane][currpos];\\n        }\\n        if(obstacles[currpos+1]!=currlane){\\n            return solve(obstacles, currlane,currpos+1,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            for(int i=1; i<4; i++){\\n            if(currlane!=i && obstacles[currpos]!=i){\\n                ans=min(ans, 1+ solve(obstacles, i, currpos,dp));\\n            }\\n        }\\n        dp[currlane][currpos]=ans;\\n        return  dp[currlane][currpos];\\n\\n        }\\n\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(4,vector<int>(obstacles.size(),-1));\\n       int ans= solve(obstacles, 2, 0, dp);\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<int>& obstacles, int currlane, int currpos,  vector<vector<int>> &dp){\\n        int n=obstacles.size()-1;\\n        if(currpos==n){\\n            return 0;\\n        }\\n        if(dp[currlane][currpos]!=-1){\\n            return dp[currlane][currpos];\\n        }\\n        if(obstacles[currpos+1]!=currlane){\\n            return solve(obstacles, currlane,currpos+1,dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            for(int i=1; i<4; i++){\\n            if(currlane!=i && obstacles[currpos]!=i){\\n                ans=min(ans, 1+ solve(obstacles, i, currpos,dp));\\n            }\\n        }\\n        dp[currlane][currpos]=ans;\\n        return  dp[currlane][currpos];\\n\\n        }\\n\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(4,vector<int>(obstacles.size(),-1));\\n       int ans= solve(obstacles, 2, 0, dp);\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817719,
                "title": "minimum-sideway-jupm-param-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> tabulation\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// int solve(vector<int>& obstacles,int currlane,int currpos){\\n//     int n=obstacles.size()-1;\\n//     if(currpos==n){\\n//         return 0;\\n//     }\\n//     if(obstacles[currpos+1]!=currlane){\\n//         return solve(obstacles,currlane,currpos+1);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=1;i<=3;i++){\\n//             if(currlane!=i&&obstacles[currpos]!=i){\\n//                 ans=min(ans,1+solve(obstacles,i,currpos));\\n//             }\\n//         }return ans;\\n//     }\\n// }\\n// int param(vector<int>&obstacles,int cl,int cp){\\n//     int n=obstacles.size()-1;\\n//     if(cp==n){\\n//         return 0;\\n//     }\\n//     if(obstacles[cp+1]!=cl){\\n//         return param(obstacles,cl,cp+1);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=0;i<=3;i++){\\n//             if(cl!=i&&obstacles[cp]!=i){\\n//                 ans=min(ans,1+param(obstacles,i,cp));\\n//             }\\n//         }\\n//         return ans;\\n//     }\\n// }\\n// int paramM(vector<int>&obstacles,int cl,int cp,vector<vector<int>>&dp){\\n//     int n=obstacles.size()-1;\\n//     if(cp==n){\\n//         return 0;\\n//     }\\n//     if(dp[cl][cp]!=-1){\\n//         return dp[cl][cp];\\n//     }\\n//     if(obstacles[cp+1]!=cl){\\n//         return paramM(obstacles,cl,cp+1,dp);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=0;i<=3;i++){\\n//             if(cl!=i&&obstacles[cp]!=i){\\n//                 ans=min(ans,1+paramM(obstacles,i,cp,dp));\\n//             }\\n            \\n//         }\\n//         dp[cl][cp]=ans;\\n//         return dp[cl][cp];\\n//     }\\n// }\\nint paramT(vector<int>&obstacles){\\n     int n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),1e9));\\n    dp[0][n]=0;\\n    dp[1][n]=0;\\n    dp[2][n]=0;\\n    dp[3][n]=0;\\n    for(int cp=n-1;cp>=0;cp--){\\n        for(int cl=1;cl<=3;cl++){\\n            if(obstacles[cp+1]!=cl){\\n                dp[cl][cp]=dp[cl][cp+1];\\n        // return param(obstacles,cl,cp+1);\\n    }else{\\n        int ans=INT_MAX;\\n        for(int i=0;i<=3;i++){\\n            if(cl!=i&&obstacles[cp]!=i){\\n                ans=min(ans,1+dp[i][cp+1]);\\n            }\\n        }dp[cl][cp]=ans;\\n        } }}\\n    \\n    return min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n        // vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        // return paramM(obstacles,2,0,dp);\\n        return paramT(obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// int solve(vector<int>& obstacles,int currlane,int currpos){\\n//     int n=obstacles.size()-1;\\n//     if(currpos==n){\\n//         return 0;\\n//     }\\n//     if(obstacles[currpos+1]!=currlane){\\n//         return solve(obstacles,currlane,currpos+1);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=1;i<=3;i++){\\n//             if(currlane!=i&&obstacles[currpos]!=i){\\n//                 ans=min(ans,1+solve(obstacles,i,currpos));\\n//             }\\n//         }return ans;\\n//     }\\n// }\\n// int param(vector<int>&obstacles,int cl,int cp){\\n//     int n=obstacles.size()-1;\\n//     if(cp==n){\\n//         return 0;\\n//     }\\n//     if(obstacles[cp+1]!=cl){\\n//         return param(obstacles,cl,cp+1);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=0;i<=3;i++){\\n//             if(cl!=i&&obstacles[cp]!=i){\\n//                 ans=min(ans,1+param(obstacles,i,cp));\\n//             }\\n//         }\\n//         return ans;\\n//     }\\n// }\\n// int paramM(vector<int>&obstacles,int cl,int cp,vector<vector<int>>&dp){\\n//     int n=obstacles.size()-1;\\n//     if(cp==n){\\n//         return 0;\\n//     }\\n//     if(dp[cl][cp]!=-1){\\n//         return dp[cl][cp];\\n//     }\\n//     if(obstacles[cp+1]!=cl){\\n//         return paramM(obstacles,cl,cp+1,dp);\\n//     }else{\\n//         int ans=INT_MAX;\\n//         for(int i=0;i<=3;i++){\\n//             if(cl!=i&&obstacles[cp]!=i){\\n//                 ans=min(ans,1+paramM(obstacles,i,cp,dp));\\n//             }\\n            \\n//         }\\n//         dp[cl][cp]=ans;\\n//         return dp[cl][cp];\\n//     }\\n// }\\nint paramT(vector<int>&obstacles){\\n     int n=obstacles.size()-1;\\n    vector<vector<int>>dp(4,vector<int>(obstacles.size(),1e9));\\n    dp[0][n]=0;\\n    dp[1][n]=0;\\n    dp[2][n]=0;\\n    dp[3][n]=0;\\n    for(int cp=n-1;cp>=0;cp--){\\n        for(int cl=1;cl<=3;cl++){\\n            if(obstacles[cp+1]!=cl){\\n                dp[cl][cp]=dp[cl][cp+1];\\n        // return param(obstacles,cl,cp+1);\\n    }else{\\n        int ans=INT_MAX;\\n        for(int i=0;i<=3;i++){\\n            if(cl!=i&&obstacles[cp]!=i){\\n                ans=min(ans,1+dp[i][cp+1]);\\n            }\\n        }dp[cl][cp]=ans;\\n        } }}\\n    \\n    return min(dp[2][0],min(1+dp[1][0],1+dp[3][0]));\\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n        // vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        // return paramM(obstacles,2,0,dp);\\n        return paramT(obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810008,
                "title": "simple-cpp-solution-using-recursion-memorization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& obstacles,int lane,int i,vector<vector<int>>& dp){\\n  int n=obstacles.size();\\n  if(i==n-1 && obstacles[i]!=lane){\\n    return 0;\\n  }\\n  int x=INT_MAX;\\n  if(dp[lane][i]!=-1){\\n    return dp[lane][i];\\n  }\\n  if(obstacles[i+1]!=lane){\\n  return solve(obstacles,lane,i+1,dp);\\n  }\\n  else{\\n    for(int j=1;j<=3;j++){\\n      if(j!=lane && obstacles[i]!=j){\\n       int ans=1+solve(obstacles,j,i,dp);\\n       x=min(ans,x);\\n      }\\n    }\\n    \\n  }\\n  return dp[lane][i]=x;\\n  \\n\\n  \\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n      int n=obstacles.size();\\n      int lane=2;\\n      int i=0;\\n      vector<vector<int>> dp(4,vector<int>(n+1,-1));\\n\\n      return solve(obstacles,lane,i,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>& obstacles,int lane,int i,vector<vector<int>>& dp){\\n  int n=obstacles.size();\\n  if(i==n-1 && obstacles[i]!=lane){\\n    return 0;\\n  }\\n  int x=INT_MAX;\\n  if(dp[lane][i]!=-1){\\n    return dp[lane][i];\\n  }\\n  if(obstacles[i+1]!=lane){\\n  return solve(obstacles,lane,i+1,dp);\\n  }\\n  else{\\n    for(int j=1;j<=3;j++){\\n      if(j!=lane && obstacles[i]!=j){\\n       int ans=1+solve(obstacles,j,i,dp);\\n       x=min(ans,x);\\n      }\\n    }\\n    \\n  }\\n  return dp[lane][i]=x;\\n  \\n\\n  \\n}\\n    int minSideJumps(vector<int>& obstacles) {\\n      int n=obstacles.size();\\n      int lane=2;\\n      int i=0;\\n      vector<vector<int>> dp(4,vector<int>(n+1,-1));\\n\\n      return solve(obstacles,lane,i,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799724,
                "title": "c-ease",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[(int)5e5 + 5][4];\\n    int f(vector<int>&o,int pos,int currlane){\\n        if(pos>=o.size())return 0;\\n        if(dp[pos][currlane]!=-1)return dp[pos][currlane];\\n        \\n        if(o[pos]==currlane)return dp[pos][currlane]=(int)1e9;\\n        \\n        int o1=f(o,pos+1,currlane);\\n        \\n        for(int i=1;i<=3;i++){ \\n            if(o[pos]!=i)\\n            o1=min(o1 , f(o,pos+1,i) + (i != currlane) );            \\n        }\\n        return dp[pos][currlane]=o1;\\n    }\\n    \\n    int minSideJumps(vector<int>& o) {\\n        memset(dp,-1,sizeof dp);\\n        return f(o,0,2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[(int)5e5 + 5][4];\\n    int f(vector<int>&o,int pos,int currlane){\\n        if(pos>=o.size())return 0;\\n        if(dp[pos][currlane]!=-1)return dp[pos][currlane];\\n        \\n        if(o[pos]==currlane)return dp[pos][currlane]=(int)1e9;\\n        \\n        int o1=f(o,pos+1,currlane);\\n        \\n        for(int i=1;i<=3;i++){ \\n            if(o[pos]!=i)\\n            o1=min(o1 , f(o,pos+1,i) + (i != currlane) );            \\n        }\\n        return dp[pos][currlane]=o1;\\n    }\\n    \\n    int minSideJumps(vector<int>& o) {\\n        memset(dp,-1,sizeof dp);\\n        return f(o,0,2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773110,
                "title": "easiest-and-the-most-beginner-friendly-code-neatly-written",
                "content": "# Complexity\\n- Time complexity:\\n- o(n*3)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& obstacles, int row, int col) {\\n        int obstaclePosition = obstacles[col];\\n        if (obstaclePosition == row) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int solve(vector<int>& obstacles, int row, int col, vector<vector<int>>& dp) {\\n        if (col == obstacles.size()-1) {\\n            return 0;\\n        }\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n        int val = 1e9;\\n        if (isPossible(obstacles, row, col + 1)) {\\n            int moveAhead = solve(obstacles, row, col + 1, dp);    \\n            val = min(val, moveAhead);\\n        } \\n        else {\\n            for (int i = 1; i <= 3; i++) {\\n                if (isPossible(obstacles, i, col) && i != row) {\\n                    int adjJump = 1 + solve(obstacles, i, col, dp);\\n                    val = min(val, adjJump);\\n                }\\n            }\\n        }\\n        return dp[row][col] =val;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(obstacles.size() + 5, -1));\\n        return solve(obstacles, 2, 0, dp);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& obstacles, int row, int col) {\\n        int obstaclePosition = obstacles[col];\\n        if (obstaclePosition == row) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int solve(vector<int>& obstacles, int row, int col, vector<vector<int>>& dp) {\\n        if (col == obstacles.size()-1) {\\n            return 0;\\n        }\\n        if (dp[row][col] != -1) {\\n            return dp[row][col];\\n        }\\n        int val = 1e9;\\n        if (isPossible(obstacles, row, col + 1)) {\\n            int moveAhead = solve(obstacles, row, col + 1, dp);    \\n            val = min(val, moveAhead);\\n        } \\n        else {\\n            for (int i = 1; i <= 3; i++) {\\n                if (isPossible(obstacles, i, col) && i != row) {\\n                    int adjJump = 1 + solve(obstacles, i, col, dp);\\n                    val = min(val, adjJump);\\n                }\\n            }\\n        }\\n        return dp[row][col] =val;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(obstacles.size() + 5, -1));\\n        return solve(obstacles, 2, 0, dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753762,
                "title": "easily-understandable-all-approaches-rec-mem-tab-space-optimization-in-java",
                "content": "# Intuition\\nRecursion, then memoization, then tabulation and at last space optimization \\n\\n# Approach\\nDifferent from normal DP problems, there is a slight catch in bottom up approach where we added +1 in curr pos to make sure, we access previous value, not the max value of same pos which is not yet updated.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)** // for best case else O(4*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n       // return solve(obstacles, 2, 0);\\n        /*int[][] dp=new int[4][obstacles.length];\\n        for(int i=0;i<=3;i++){\\n            for(int j=0;j<obstacles.length;j++){\\n                //dp[i][j]=-1;\\n                dp[i][j]=Integer.MAX_VALUE;\\n            }\\n        }*/\\n        //return solvemem(obstacles, 2, 0, dp);\\n        //return solvetab(obstacles, dp);\\n        return solvetabSO(obstacles);\\n    }\\n    public static int solve(int[] obstacles, int curr, int pos){\\n        if(pos==obstacles.length || pos==obstacles.length-1){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n            return solve(obstacles, curr, pos+1);\\n        }\\n        else{\\n            ans=Integer.MAX_VALUE;\\n            for(int i=1;i<=3;i++){\\n                if(curr!=i && obstacles[pos]!=i){\\n                    ans=Math.min(ans, 1+solve(obstacles, i, pos));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static int solvemem(int[] obstacles, int curr, int pos, int[][] dp){\\n        if(pos==obstacles.length || pos==obstacles.length-1){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(dp[curr][pos]!=-1){\\n            return dp[curr][pos];\\n        }\\n        if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n            return solvemem(obstacles, curr, pos+1, dp);\\n        }\\n        else{\\n            ans=Integer.MAX_VALUE;\\n            for(int i=1;i<=3;i++){\\n                if(curr!=i && obstacles[pos]!=i){\\n                    ans=Math.min(ans, 1+solvemem(obstacles, i, pos, dp));\\n                }\\n            }\\n        }\\n        dp[curr][pos]=ans;\\n        return dp[curr][pos];\\n    }\\n    public static int solvetab(int[] obstacles, int[][] dp){\\n       int n=obstacles.length;\\n\\n       dp[0][n-1]=0;\\n       dp[1][n-1]=0;\\n       dp[2][n-1]=0;\\n       dp[3][n-1]=0;\\n       for(int pos=n-2; pos>=0; pos--){\\n           for(int curr=1;curr<=3;curr++){\\n              if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n                 dp[curr][pos]= dp[curr][pos+1];\\n                 }\\n              else{\\n                  int ans=Integer.MAX_VALUE;\\n                  for(int i=1;i<=3;i++){\\n                     if(curr!=i && obstacles[pos]!=i){\\n                     ans=Math.min(ans, 1+dp[i][pos+1]);\\n                    }\\n                }\\n                dp[curr][pos]=ans;\\n           }            \\n       }\\n   } \\n   return Math.min(dp[2][0], Math.min(1+dp[1][0], 1+dp[3][0]));\\n}  \\npublic static int solvetabSO(int[] obstacles){\\n       int n=obstacles.length;\\n       int curr[]=new int[4];\\n       int next[]=new int[4];\\n       Arrays.fill(curr, Integer.MAX_VALUE);\\n       Arrays.fill(next, Integer.MAX_VALUE);\\n       next[0]=0;\\n       next[1]=0;\\n       next[2]=0;\\n       next[3]=0;\\n       for(int pos=n-2; pos>=0; pos--){\\n           for(int k=1;k<=3;k++){\\n              if(pos!=obstacles.length-1 && obstacles[pos+1]!=k){\\n                 curr[k]= next[k];\\n                 }\\n              else{\\n                  int ans=Integer.MAX_VALUE;\\n                  for(int i=1;i<=3;i++){\\n                     if(k!=i && obstacles[pos]!=i){\\n                     ans=Math.min(ans, 1+next[i]);\\n                    }\\n                }\\n                curr[k]=ans;\\n           }           \\n       }\\n       next=curr; \\n   } \\n   return Math.min(next[2], Math.min(1+next[1], 1+next[3]));\\n}\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n       // return solve(obstacles, 2, 0);\\n        /*int[][] dp=new int[4][obstacles.length];\\n        for(int i=0;i<=3;i++){\\n            for(int j=0;j<obstacles.length;j++){\\n                //dp[i][j]=-1;\\n                dp[i][j]=Integer.MAX_VALUE;\\n            }\\n        }*/\\n        //return solvemem(obstacles, 2, 0, dp);\\n        //return solvetab(obstacles, dp);\\n        return solvetabSO(obstacles);\\n    }\\n    public static int solve(int[] obstacles, int curr, int pos){\\n        if(pos==obstacles.length || pos==obstacles.length-1){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n            return solve(obstacles, curr, pos+1);\\n        }\\n        else{\\n            ans=Integer.MAX_VALUE;\\n            for(int i=1;i<=3;i++){\\n                if(curr!=i && obstacles[pos]!=i){\\n                    ans=Math.min(ans, 1+solve(obstacles, i, pos));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static int solvemem(int[] obstacles, int curr, int pos, int[][] dp){\\n        if(pos==obstacles.length || pos==obstacles.length-1){\\n            return 0;\\n        }\\n        int ans=0;\\n        if(dp[curr][pos]!=-1){\\n            return dp[curr][pos];\\n        }\\n        if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n            return solvemem(obstacles, curr, pos+1, dp);\\n        }\\n        else{\\n            ans=Integer.MAX_VALUE;\\n            for(int i=1;i<=3;i++){\\n                if(curr!=i && obstacles[pos]!=i){\\n                    ans=Math.min(ans, 1+solvemem(obstacles, i, pos, dp));\\n                }\\n            }\\n        }\\n        dp[curr][pos]=ans;\\n        return dp[curr][pos];\\n    }\\n    public static int solvetab(int[] obstacles, int[][] dp){\\n       int n=obstacles.length;\\n\\n       dp[0][n-1]=0;\\n       dp[1][n-1]=0;\\n       dp[2][n-1]=0;\\n       dp[3][n-1]=0;\\n       for(int pos=n-2; pos>=0; pos--){\\n           for(int curr=1;curr<=3;curr++){\\n              if(pos!=obstacles.length-1 && obstacles[pos+1]!=curr){\\n                 dp[curr][pos]= dp[curr][pos+1];\\n                 }\\n              else{\\n                  int ans=Integer.MAX_VALUE;\\n                  for(int i=1;i<=3;i++){\\n                     if(curr!=i && obstacles[pos]!=i){\\n                     ans=Math.min(ans, 1+dp[i][pos+1]);\\n                    }\\n                }\\n                dp[curr][pos]=ans;\\n           }            \\n       }\\n   } \\n   return Math.min(dp[2][0], Math.min(1+dp[1][0], 1+dp[3][0]));\\n}  \\npublic static int solvetabSO(int[] obstacles){\\n       int n=obstacles.length;\\n       int curr[]=new int[4];\\n       int next[]=new int[4];\\n       Arrays.fill(curr, Integer.MAX_VALUE);\\n       Arrays.fill(next, Integer.MAX_VALUE);\\n       next[0]=0;\\n       next[1]=0;\\n       next[2]=0;\\n       next[3]=0;\\n       for(int pos=n-2; pos>=0; pos--){\\n           for(int k=1;k<=3;k++){\\n              if(pos!=obstacles.length-1 && obstacles[pos+1]!=k){\\n                 curr[k]= next[k];\\n                 }\\n              else{\\n                  int ans=Integer.MAX_VALUE;\\n                  for(int i=1;i<=3;i++){\\n                     if(k!=i && obstacles[pos]!=i){\\n                     ans=Math.min(ans, 1+next[i]);\\n                    }\\n                }\\n                curr[k]=ans;\\n           }           \\n       }\\n       next=curr; \\n   } \\n   return Math.min(next[2], Math.min(1+next[1], 1+next[3]));\\n}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749460,
                "title": "best-solution-of-minimum-sideways-jump",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    memoization\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  2-D DP\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  o(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  o(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n int solve(vector<int>& obstacles,int currlane,int currpos){\\n     // base case\\n     int  n = obstacles.size()-1;\\n     if(currpos==n){\\n         return 0;\\n     }\\n     if(obstacles[currpos+1]!=currlane){\\n        return solve(obstacles,currlane,currpos);\\n     }\\n     else\\n     {\\n        int ans = 1;\\n     for(int i =1;i<=3;i++){\\n\\n         ans = min(ans,1+solve(obstacles,currlane,currpos+1));\\n     }\\n     return ans;\\n     }\\n }\\n  int solvemem(vector<int>& obstacles,int currlane,int currpos,vector<vector<int>>&dp){\\n     // base case\\n     int  n = obstacles.size()-1;\\n     if(currpos==n){\\n         return 0;\\n     }\\n     if(dp[currlane][currpos]!=-1){\\n         return dp[currlane][currpos];\\n     }\\n     if(obstacles[currpos+1]!=currlane){\\n        return solvemem(obstacles,currlane,currpos+1,dp);\\n     }\\n     else\\n     {\\n        int ans = INT_MAX;\\n     for(int i =1;i<=3;i++){\\n         if(currlane!=i && obstacles[currpos]!=i)\\n         ans = min(ans,1+solvemem(obstacles,i,currpos,dp));\\n         \\n     }\\n      dp[currlane][currpos]=ans;\\n     return dp[currlane][currpos];\\n     }\\n }\\n      \\n      \\n \\n    int minSideJumps(vector<int>& obstacles) {\\n        // return solve(obstacles,2,0);\\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return solvemem(obstacles,2,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int solve(vector<int>& obstacles,int currlane,int currpos){\\n     // base case\\n     int  n = obstacles.size()-1;\\n     if(currpos==n){\\n         return 0;\\n     }\\n     if(obstacles[currpos+1]!=currlane){\\n        return solve(obstacles,currlane,currpos);\\n     }\\n     else\\n     {\\n        int ans = 1;\\n     for(int i =1;i<=3;i++){\\n\\n         ans = min(ans,1+solve(obstacles,currlane,currpos+1));\\n     }\\n     return ans;\\n     }\\n }\\n  int solvemem(vector<int>& obstacles,int currlane,int currpos,vector<vector<int>>&dp){\\n     // base case\\n     int  n = obstacles.size()-1;\\n     if(currpos==n){\\n         return 0;\\n     }\\n     if(dp[currlane][currpos]!=-1){\\n         return dp[currlane][currpos];\\n     }\\n     if(obstacles[currpos+1]!=currlane){\\n        return solvemem(obstacles,currlane,currpos+1,dp);\\n     }\\n     else\\n     {\\n        int ans = INT_MAX;\\n     for(int i =1;i<=3;i++){\\n         if(currlane!=i && obstacles[currpos]!=i)\\n         ans = min(ans,1+solvemem(obstacles,i,currpos,dp));\\n         \\n     }\\n      dp[currlane][currpos]=ans;\\n     return dp[currlane][currpos];\\n     }\\n }\\n      \\n      \\n \\n    int minSideJumps(vector<int>& obstacles) {\\n        // return solve(obstacles,2,0);\\n        vector<vector<int>>dp(4,vector<int>(obstacles.size(),-1));\\n        return solvemem(obstacles,2,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740477,
                "title": "easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- dp[i] memorizes the number of mininum side jumps to the cuurent point\\n- dp[i]==INT_MAX if there is a stone (1,2,3)\\n- update the blocked value if  there is no stone (0)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& v) {\\n        vector<int> dp{1,0,1};\\n        int last=0;\\n        for(auto n:v){\\n            if(n==0) {\\n                if(last==0) continue;\\n                dp[(last+2)%3]=1+min(dp[(last+3)%3],dp[(last+4)%3]);\\n                last=0;continue;\\n            }\\n            vector<int> ndp(3);\\n            int i=(n+2)%3, j=(n+3)%3, k=(n+4)%3;\\n            ndp[i]=INT_MAX;\\n            ndp[j]=min(dp[j],dp[k]==INT_MAX?INT_MAX:dp[k]+1);\\n            ndp[k]=min(dp[k],dp[j]==INT_MAX?INT_MAX:dp[j]+1);           \\n            dp=ndp;\\n            last=n;\\n        }\\n        return *min_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& v) {\\n        vector<int> dp{1,0,1};\\n        int last=0;\\n        for(auto n:v){\\n            if(n==0) {\\n                if(last==0) continue;\\n                dp[(last+2)%3]=1+min(dp[(last+3)%3],dp[(last+4)%3]);\\n                last=0;continue;\\n            }\\n            vector<int> ndp(3);\\n            int i=(n+2)%3, j=(n+3)%3, k=(n+4)%3;\\n            ndp[i]=INT_MAX;\\n            ndp[j]=min(dp[j],dp[k]==INT_MAX?INT_MAX:dp[k]+1);\\n            ndp[k]=min(dp[k],dp[j]==INT_MAX?INT_MAX:dp[j]+1);           \\n            dp=ndp;\\n            last=n;\\n        }\\n        return *min_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734836,
                "title": "all-type-of-complexity-sol-in-c-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int index, int lane, vector<int>& obstacles) {\\n        if(index == obstacles.size()-1) return 0;\\n\\n        int ans = INT_MAX;\\n        if(obstacles[index+1] != lane) {\\n            return solve(index+1, lane, obstacles);\\n        }\\n        else {\\n            for(int i=1; i<=3; i++) {\\n                if(lane != i && obstacles[index] != i) {\\n                    ans = min(ans, solve(index, i, obstacles));\\n                }\\n            }\\n        }\\n        return ans + 1;\\n    }\\n\\n    int solveMem(int index, int lane, vector<int>& obstacles, vector<vector<int>> &dp) {\\n        if(index == obstacles.size()-1) return 0;\\n        \\n        if(dp[lane][index] != -1) return dp[lane][index];\\n\\n        if(obstacles[index+1] != lane) {\\n            dp[lane][index] = solveMem(index+1, lane, obstacles, dp);\\n            return dp[lane][index];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=3; i++) {\\n            if(lane != i && obstacles[index] != i) {\\n                ans = min(ans, solveMem(index, i, obstacles, dp));\\n            }\\n        }\\n        dp[lane][index] = ans + 1;\\n        return dp[lane][index];\\n    }\\n\\n    int solveTab(vector<int>& obstacles) {\\n        int n = obstacles.size()-1;\\n        vector<vector<int>> dp(4, vector<int>(n+1, 1e9));\\n\\n        dp[0][n] = 0;\\n        dp[1][n] = 0;\\n        dp[2][n] = 0;\\n        dp[3][n] = 0;\\n\\n        for(int index=n-1; index>=0; index--) {\\n            for(int lane=1; lane<=3; lane++) {\\n                if(obstacles[index+1] != lane) {\\n                    dp[lane][index] = dp[lane][index+1];\\n                }\\n                else {\\n                    int ans = 1e9;\\n                    for(int i=1; i<=3; i++) {\\n                        if(lane != i && obstacles[index] != i) {\\n                            ans = min(ans, 1+dp[i][index+1]);\\n                        }\\n                    }\\n                    dp[lane][index] = ans ;\\n                }\\n            }\\n        }\\n        return min(dp[2][0], min(1+dp[1][0], 1+dp[3][0]) );\\n    }\\n\\n    int solveTabOpt(vector<int>& obstacles) {\\n        int n = obstacles.size()-1;\\n        vector<int> curr(4, 1e9);\\n        vector<int> prev(4, 1e9);\\n        prev[0] = 0;\\n        prev[1] = 0;\\n        prev[2] = 0;\\n        prev[3] = 0;\\n\\n        for(int index=n-1; index>=0; index--) {\\n            for(int lane=1; lane<=3; lane++) {\\n                if(obstacles[index+1] != lane) {\\n                    curr[lane] = prev[lane];\\n                }\\n                else {\\n                    int ans = 1e9;\\n                    for(int i=1; i<=3; i++) {\\n                        if(lane != i && obstacles[index] != i) {\\n                            ans = min(ans, 1+prev[i]);\\n                        }\\n                    }\\n                    curr[lane] = ans ;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return min(prev[2], min(1+prev[1], 1+prev[3]) );\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(n, -1));\\n        return solveTabOpt(obstacles);\\n        return solveTab(obstacles);\\n        return solveMem(0, 2, obstacles, dp);\\n        return solve(0, 2, obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index, int lane, vector<int>& obstacles) {\\n        if(index == obstacles.size()-1) return 0;\\n\\n        int ans = INT_MAX;\\n        if(obstacles[index+1] != lane) {\\n            return solve(index+1, lane, obstacles);\\n        }\\n        else {\\n            for(int i=1; i<=3; i++) {\\n                if(lane != i && obstacles[index] != i) {\\n                    ans = min(ans, solve(index, i, obstacles));\\n                }\\n            }\\n        }\\n        return ans + 1;\\n    }\\n\\n    int solveMem(int index, int lane, vector<int>& obstacles, vector<vector<int>> &dp) {\\n        if(index == obstacles.size()-1) return 0;\\n        \\n        if(dp[lane][index] != -1) return dp[lane][index];\\n\\n        if(obstacles[index+1] != lane) {\\n            dp[lane][index] = solveMem(index+1, lane, obstacles, dp);\\n            return dp[lane][index];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=3; i++) {\\n            if(lane != i && obstacles[index] != i) {\\n                ans = min(ans, solveMem(index, i, obstacles, dp));\\n            }\\n        }\\n        dp[lane][index] = ans + 1;\\n        return dp[lane][index];\\n    }\\n\\n    int solveTab(vector<int>& obstacles) {\\n        int n = obstacles.size()-1;\\n        vector<vector<int>> dp(4, vector<int>(n+1, 1e9));\\n\\n        dp[0][n] = 0;\\n        dp[1][n] = 0;\\n        dp[2][n] = 0;\\n        dp[3][n] = 0;\\n\\n        for(int index=n-1; index>=0; index--) {\\n            for(int lane=1; lane<=3; lane++) {\\n                if(obstacles[index+1] != lane) {\\n                    dp[lane][index] = dp[lane][index+1];\\n                }\\n                else {\\n                    int ans = 1e9;\\n                    for(int i=1; i<=3; i++) {\\n                        if(lane != i && obstacles[index] != i) {\\n                            ans = min(ans, 1+dp[i][index+1]);\\n                        }\\n                    }\\n                    dp[lane][index] = ans ;\\n                }\\n            }\\n        }\\n        return min(dp[2][0], min(1+dp[1][0], 1+dp[3][0]) );\\n    }\\n\\n    int solveTabOpt(vector<int>& obstacles) {\\n        int n = obstacles.size()-1;\\n        vector<int> curr(4, 1e9);\\n        vector<int> prev(4, 1e9);\\n        prev[0] = 0;\\n        prev[1] = 0;\\n        prev[2] = 0;\\n        prev[3] = 0;\\n\\n        for(int index=n-1; index>=0; index--) {\\n            for(int lane=1; lane<=3; lane++) {\\n                if(obstacles[index+1] != lane) {\\n                    curr[lane] = prev[lane];\\n                }\\n                else {\\n                    int ans = 1e9;\\n                    for(int i=1; i<=3; i++) {\\n                        if(lane != i && obstacles[index] != i) {\\n                            ans = min(ans, 1+prev[i]);\\n                        }\\n                    }\\n                    curr[lane] = ans ;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return min(prev[2], min(1+prev[1], 1+prev[3]) );\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(n, -1));\\n        return solveTabOpt(obstacles);\\n        return solveTab(obstacles);\\n        return solveMem(0, 2, obstacles, dp);\\n        return solve(0, 2, obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731948,
                "title": "sol-in-c-language",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int index, int lane, vector<int>& obstacles) {\\n        if(index == obstacles.size()-1) return 0;\\n\\n        int ans = INT_MAX;\\n        if(obstacles[index+1] != lane) {\\n            return solve(index+1, lane, obstacles);\\n        }\\n        else {\\n            for(int i=1; i<=3; i++) {\\n                if(lane != i && obstacles[index] != i) {\\n                    ans = min(ans, solve(index, i, obstacles));\\n                }\\n            }\\n        }\\n        return ans + 1;\\n    }\\n\\n    int solveMem(int index, int lane, vector<int>& obstacles, vector<vector<int>> &dp) {\\n        if(index == obstacles.size()-1) return 0;\\n        \\n        if(dp[lane][index] != -1) return dp[lane][index];\\n\\n        if(obstacles[index+1] != lane) {\\n            dp[lane][index] = solveMem(index+1, lane, obstacles, dp);\\n            return dp[lane][index];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=3; i++) {\\n            if(lane != i && obstacles[index] != i) {\\n                ans = min(ans, solveMem(index, i, obstacles, dp));\\n            }\\n        }\\n        dp[lane][index] = ans + 1;\\n        return dp[lane][index];\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(n, -1));\\n\\n        return solveMem(0, 2, obstacles, dp);\\n        return solve(0, 2, obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int index, int lane, vector<int>& obstacles) {\\n        if(index == obstacles.size()-1) return 0;\\n\\n        int ans = INT_MAX;\\n        if(obstacles[index+1] != lane) {\\n            return solve(index+1, lane, obstacles);\\n        }\\n        else {\\n            for(int i=1; i<=3; i++) {\\n                if(lane != i && obstacles[index] != i) {\\n                    ans = min(ans, solve(index, i, obstacles));\\n                }\\n            }\\n        }\\n        return ans + 1;\\n    }\\n\\n    int solveMem(int index, int lane, vector<int>& obstacles, vector<vector<int>> &dp) {\\n        if(index == obstacles.size()-1) return 0;\\n        \\n        if(dp[lane][index] != -1) return dp[lane][index];\\n\\n        if(obstacles[index+1] != lane) {\\n            dp[lane][index] = solveMem(index+1, lane, obstacles, dp);\\n            return dp[lane][index];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1; i<=3; i++) {\\n            if(lane != i && obstacles[index] != i) {\\n                ans = min(ans, solveMem(index, i, obstacles, dp));\\n            }\\n        }\\n        dp[lane][index] = ans + 1;\\n        return dp[lane][index];\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(4, vector<int>(n, -1));\\n\\n        return solveMem(0, 2, obstacles, dp);\\n        return solve(0, 2, obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720810,
                "title": "begineers-friendly-c-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &obs, int currpos, int currlane, vector<vector<int>> &dp){\\n        if(currpos == obs.size()-1)\\n        return 0;\\n\\n        if(dp[currpos][currlane] != -1)\\n        return dp[currpos][currlane] ;\\n        \\n        int ans = INT_MAX;\\n        if(obs[currpos+1] != currlane)\\n         return dp[currpos][currlane] = solve(obs, currpos+1, currlane, dp);\\n        \\n        else{\\n            for(int i = 1; i <= 3; i++){\\n                if(i != currlane && obs[currpos] != i)\\n                ans = min(ans, 1 + solve(obs, currpos, i, dp));\\n            }\\n        }\\n        return dp[currpos][currlane] = ans;\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int currpos = 0;\\n        int currlane = 2;\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n+1, vector<int>(4, -1));\\n        return solve(obstacles, currpos, currlane, dp);\\n        // return solveTab(obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &obs, int currpos, int currlane, vector<vector<int>> &dp){\\n        if(currpos == obs.size()-1)\\n        return 0;\\n\\n        if(dp[currpos][currlane] != -1)\\n        return dp[currpos][currlane] ;\\n        \\n        int ans = INT_MAX;\\n        if(obs[currpos+1] != currlane)\\n         return dp[currpos][currlane] = solve(obs, currpos+1, currlane, dp);\\n        \\n        else{\\n            for(int i = 1; i <= 3; i++){\\n                if(i != currlane && obs[currpos] != i)\\n                ans = min(ans, 1 + solve(obs, currpos, i, dp));\\n            }\\n        }\\n        return dp[currpos][currlane] = ans;\\n    }\\n\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int currpos = 0;\\n        int currlane = 2;\\n        int n = obstacles.size();\\n        vector<vector<int>> dp(n+1, vector<int>(4, -1));\\n        return solve(obstacles, currpos, currlane, dp);\\n        // return solveTab(obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718080,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(4,vector<int>(obstacles.size(),-1));\\n        return solve(obstacles,2,0,dp);\\n        \\n    }\\n\\n\\n    int solve(vector<int>& obstacles, int currlane,int currpos,vector<vector<int>>& dp)\\n    {\\n        //bc\\n        int n = obstacles.size()-1;\\n        if(currpos==n)\\n        return 0;\\n\\n    if(dp[currlane][currpos]!=-1)\\n    return dp[currlane][currpos];\\n\\n\\n    if(obstacles[currpos+1]!=currlane)\\n    return solve(obstacles,currlane,currpos+1,dp);\\n\\n    else\\n    {\\n        int ans =INT_MAX;\\n        for(int i=1;i<=3;i++)\\n        {\\n            if(currlane !=i && obstacles[currpos]!=i)\\n            ans= min(ans,1+solve(obstacles,i,currpos,dp));\\n        }\\n        dp[currlane][currpos]=ans;\\n        return dp[currlane][currpos];\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(4,vector<int>(obstacles.size(),-1));\\n        return solve(obstacles,2,0,dp);\\n        \\n    }\\n\\n\\n    int solve(vector<int>& obstacles, int currlane,int currpos,vector<vector<int>>& dp)\\n    {\\n        //bc\\n        int n = obstacles.size()-1;\\n        if(currpos==n)\\n        return 0;\\n\\n    if(dp[currlane][currpos]!=-1)\\n    return dp[currlane][currpos];\\n\\n\\n    if(obstacles[currpos+1]!=currlane)\\n    return solve(obstacles,currlane,currpos+1,dp);\\n\\n    else\\n    {\\n        int ans =INT_MAX;\\n        for(int i=1;i<=3;i++)\\n        {\\n            if(currlane !=i && obstacles[currpos]!=i)\\n            ans= min(ans,1+solve(obstacles,i,currpos,dp));\\n        }\\n        dp[currlane][currpos]=ans;\\n        return dp[currlane][currpos];\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717733,
                "title": "c-o-n-time-complexity-o-1-space-complexity-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic programming can be used to solve the problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have provided three solutions of o(n) complexity in which the approach is that we are calculating minimum number of jumps required from 3 lanes by jumping one by one and then storing the minimum value.\\n\\n# Complexity\\n- Time complexity:**O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    //Recursion + memoization \\n    int solve(vector<int>& obstacles, int currLane, int currPos,int n,vector<vector<int>>&dp)\\n    {\\n        if(currPos==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[currLane][currPos]!=-1){\\n            return dp[currLane][currPos];\\n        }\\n        if(obstacles[currPos+1] !=currLane)\\n        {\\n            return solve(obstacles,currLane,currPos+1,n,dp);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=1;i<=3;i++)\\n        {\\n            if(currLane!=i && obstacles[currPos]!=i)\\n            {\\n                int mini=solve(obstacles,i,currPos,n,dp);\\n                ans=min(1+mini,ans);\\n            }\\n        }\\n        dp[currLane][currPos]=ans;\\n\\n        return dp[currLane][currPos];\\n    }\\n\\n    //Tabluation solution\\n    int solveTab(vector<int>& obstacles)\\n    {\\n        int n=obstacles.size()-1;\\n        vector<vector<int>>dp(4, vector<int>(n+1,1e9));\\n\\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n\\n        for(int currPos=n-1;currPos>=0;currPos--)\\n        {\\n            for(int currLane=1;currLane<=3;currLane++)\\n            {\\n                if(obstacles[currPos+1] !=currLane)\\n                {\\n                    dp[currLane][currPos]=dp[currLane][currPos+1];\\n                }\\n                else\\n                {\\n                int ans=1e9;\\n                for(int i=1;i<=3;i++)\\n                {\\n                    if(currLane!=i && obstacles[currPos]!=i)\\n                    {\\n                        ans=min(ans,1+dp[i][currPos+1]);\\n                    }\\n                }\\n                dp[currLane][currPos]=ans;\\n                }        \\n            }\\n        }\\n    return min(dp[2][0],min(1+dp[1][0], 1+dp[3][0]));\\n    }\\n\\n    //0(1) space complexity solution\\n    int spaceOP(vector<int>& obstacles)\\n    {\\n        int n=obstacles.size()-1;\\n        vector<int>curr(4,0);\\n        vector<int>next(4,0);\\n        for(int currPos=n-1;currPos>=0;currPos--)\\n        {\\n            for(int currLane=1;currLane<=3;currLane++)\\n            {\\n                if(obstacles[currPos+1] !=currLane)\\n                {\\n                    curr[currLane]=next[currLane];\\n                }\\n                else\\n                {\\n                int ans=1e9;\\n                for(int i=1;i<=3;i++)\\n                {\\n                    if(currLane!=i && obstacles[currPos]!=i)\\n                    {\\n                        ans=min(ans,1+next[i]);\\n                    }\\n                }\\n                curr[currLane]=ans;\\n                }        \\n            }\\n            next=curr;\\n        }\\n    return min(curr[2],min(1+curr[1], 1+curr[3]));\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles)\\n    {\\n        // int n=obstacles.size()-1;\\n        //  vector<vector<int>>dp(4, vector<int>(n+1,-1));\\n        // int ans=solve(obstacles,2,0,n,dp);\\n        // return ans;\\n\\n        return spaceOP(obstacles);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    //Recursion + memoization \\n    int solve(vector<int>& obstacles, int currLane, int currPos,int n,vector<vector<int>>&dp)\\n    {\\n        if(currPos==n)\\n        {\\n            return 0;\\n        }\\n        if(dp[currLane][currPos]!=-1){\\n            return dp[currLane][currPos];\\n        }\\n        if(obstacles[currPos+1] !=currLane)\\n        {\\n            return solve(obstacles,currLane,currPos+1,n,dp);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=1;i<=3;i++)\\n        {\\n            if(currLane!=i && obstacles[currPos]!=i)\\n            {\\n                int mini=solve(obstacles,i,currPos,n,dp);\\n                ans=min(1+mini,ans);\\n            }\\n        }\\n        dp[currLane][currPos]=ans;\\n\\n        return dp[currLane][currPos];\\n    }\\n\\n    //Tabluation solution\\n    int solveTab(vector<int>& obstacles)\\n    {\\n        int n=obstacles.size()-1;\\n        vector<vector<int>>dp(4, vector<int>(n+1,1e9));\\n\\n        dp[0][n]=0;\\n        dp[1][n]=0;\\n        dp[2][n]=0;\\n        dp[3][n]=0;\\n\\n        for(int currPos=n-1;currPos>=0;currPos--)\\n        {\\n            for(int currLane=1;currLane<=3;currLane++)\\n            {\\n                if(obstacles[currPos+1] !=currLane)\\n                {\\n                    dp[currLane][currPos]=dp[currLane][currPos+1];\\n                }\\n                else\\n                {\\n                int ans=1e9;\\n                for(int i=1;i<=3;i++)\\n                {\\n                    if(currLane!=i && obstacles[currPos]!=i)\\n                    {\\n                        ans=min(ans,1+dp[i][currPos+1]);\\n                    }\\n                }\\n                dp[currLane][currPos]=ans;\\n                }        \\n            }\\n        }\\n    return min(dp[2][0],min(1+dp[1][0], 1+dp[3][0]));\\n    }\\n\\n    //0(1) space complexity solution\\n    int spaceOP(vector<int>& obstacles)\\n    {\\n        int n=obstacles.size()-1;\\n        vector<int>curr(4,0);\\n        vector<int>next(4,0);\\n        for(int currPos=n-1;currPos>=0;currPos--)\\n        {\\n            for(int currLane=1;currLane<=3;currLane++)\\n            {\\n                if(obstacles[currPos+1] !=currLane)\\n                {\\n                    curr[currLane]=next[currLane];\\n                }\\n                else\\n                {\\n                int ans=1e9;\\n                for(int i=1;i<=3;i++)\\n                {\\n                    if(currLane!=i && obstacles[currPos]!=i)\\n                    {\\n                        ans=min(ans,1+next[i]);\\n                    }\\n                }\\n                curr[currLane]=ans;\\n                }        \\n            }\\n            next=curr;\\n        }\\n    return min(curr[2],min(1+curr[1], 1+curr[3]));\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles)\\n    {\\n        // int n=obstacles.size()-1;\\n        //  vector<vector<int>>dp(4, vector<int>(n+1,-1));\\n        // int ans=solve(obstacles,2,0,n,dp);\\n        // return ans;\\n\\n        return spaceOP(obstacles);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706844,
                "title": "recursion-and-memorization-using-dp-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O[n]$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O[n*4]$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minSideJumpsHelper(int i,vector<int>& obstacles,int lane){\\n        if(i>=obstacles.size()-1){\\n            return 0;\\n        }\\n        if(dp[i][lane]!=-1){\\n            return dp[i][lane];\\n        }\\n        int stoneLane=obstacles[i+1];\\n        int currStone=obstacles[i];\\n        int ansSidelane1=INT_MAX-1,ansSidelane2=INT_MAX-1,ansSamelane=INT_MAX-1;\\n        if(stoneLane==lane){\\n            if(lane==1){\\n                // jump to lane 2 and 3\\n                if(lane+1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane+1);\\n                }\\n                if(lane+2!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane+2);\\n                }\\n            }\\n            else if(lane==2){\\n                // jump to lane 1 and 3\\n                if(lane-1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane-1);\\n                }\\n                if(lane+1!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane+1);\\n                }\\n            }\\n            else{\\n                // jump tolane 1 and 2\\n                if(lane-1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane-1);\\n                }\\n                if(lane-2!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane-2);\\n                }\\n            }\\n        }\\n        else{\\n            ansSamelane=minSideJumpsHelper(i+1,obstacles,lane);\\n        }\\n        int ansJumplane=INT_MAX-1;\\n        if(ansSidelane1==INT_MAX-1 && ansSidelane2==INT_MAX-1){\\n            ansJumplane=INT_MAX-1;\\n        }\\n        else{\\n            ansJumplane=1+min(ansSidelane1,ansSidelane2);\\n        }\\n        return dp[i][lane]=min(ansSamelane,ansJumplane);\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        dp=vector<vector<int>> (obstacles.size(), vector<int> (4,-1));\\n        int ans=minSideJumpsHelper(0,obstacles,2);\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int minSideJumpsHelper(int i,vector<int>& obstacles,int lane){\\n        if(i>=obstacles.size()-1){\\n            return 0;\\n        }\\n        if(dp[i][lane]!=-1){\\n            return dp[i][lane];\\n        }\\n        int stoneLane=obstacles[i+1];\\n        int currStone=obstacles[i];\\n        int ansSidelane1=INT_MAX-1,ansSidelane2=INT_MAX-1,ansSamelane=INT_MAX-1;\\n        if(stoneLane==lane){\\n            if(lane==1){\\n                // jump to lane 2 and 3\\n                if(lane+1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane+1);\\n                }\\n                if(lane+2!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane+2);\\n                }\\n            }\\n            else if(lane==2){\\n                // jump to lane 1 and 3\\n                if(lane-1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane-1);\\n                }\\n                if(lane+1!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane+1);\\n                }\\n            }\\n            else{\\n                // jump tolane 1 and 2\\n                if(lane-1!=currStone){\\n                    ansSidelane1=minSideJumpsHelper(i+1,obstacles,lane-1);\\n                }\\n                if(lane-2!=currStone){\\n                    ansSidelane2=minSideJumpsHelper(i+1,obstacles,lane-2);\\n                }\\n            }\\n        }\\n        else{\\n            ansSamelane=minSideJumpsHelper(i+1,obstacles,lane);\\n        }\\n        int ansJumplane=INT_MAX-1;\\n        if(ansSidelane1==INT_MAX-1 && ansSidelane2==INT_MAX-1){\\n            ansJumplane=INT_MAX-1;\\n        }\\n        else{\\n            ansJumplane=1+min(ansSidelane1,ansSidelane2);\\n        }\\n        return dp[i][lane]=min(ansSamelane,ansJumplane);\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        dp=vector<vector<int>> (obstacles.size(), vector<int> (4,-1));\\n        int ans=minSideJumpsHelper(0,obstacles,2);\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705404,
                "title": "easiest-c-memoization-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRead my code\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead my code \\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n    Thoughts\\n    1)We need to find the min no of sideways jumps needed for point just before n point\\n    2)In base case if you are at the destination already then return 0 as no side jumps needed\\n    3)How to perform a small calculation?\\n    ->we need to perform some calculation over obstacles\\n    ->We need to keep track of current lane\\n    ->side jumps are possible only when the lane we are switching to are different from same lane and the lane at that point having stone\\n    ->We have some ways to jump over which we can call recurance and min the answer\\n    ->there can be no case in which we can not take any lane\\n    ->after every side jump perform a +1\\n    */\\n    int solve(vector<int>& obstacles,int i,int walkinglane,vector<vector<int>>& strg){\\n        //If we are at i==n then please tell that we need now 0 side jumps!\\n        if(i==obstacles.size()-1) return 0; \\n        if(strg[i][walkinglane]!=-1) return strg[i][walkinglane];\\n        //If we remain in same lane we need 0 side jumps additionally\\n        int remainInSameLane=(obstacles[i]!=walkinglane)?solve(obstacles,i+1,walkinglane,strg) : INT_MAX;\\n        //We can go to another lane if that lane is not having stones or is our current lane\\n        int goToAnotherLane=INT_MAX;\\n        for(int lane=1;lane<=3;lane++){\\n            if(lane!=obstacles[i-1] && lane!=walkinglane && lane!=obstacles[i]){\\n                goToAnotherLane=min(goToAnotherLane,1+solve(obstacles,i+1,lane,strg));\\n            }\\n        }\\n        int sideJumps=min(remainInSameLane,goToAnotherLane);\\n        return strg[i][walkinglane] = sideJumps;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> strg(obstacles.size()+1,vector<int>(4,-1));\\n        //Keep track of point and the lane\\n        return solve(obstacles,1,2,strg);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n    Thoughts\\n    1)We need to find the min no of sideways jumps needed for point just before n point\\n    2)In base case if you are at the destination already then return 0 as no side jumps needed\\n    3)How to perform a small calculation?\\n    ->we need to perform some calculation over obstacles\\n    ->We need to keep track of current lane\\n    ->side jumps are possible only when the lane we are switching to are different from same lane and the lane at that point having stone\\n    ->We have some ways to jump over which we can call recurance and min the answer\\n    ->there can be no case in which we can not take any lane\\n    ->after every side jump perform a +1\\n    */\\n    int solve(vector<int>& obstacles,int i,int walkinglane,vector<vector<int>>& strg){\\n        //If we are at i==n then please tell that we need now 0 side jumps!\\n        if(i==obstacles.size()-1) return 0; \\n        if(strg[i][walkinglane]!=-1) return strg[i][walkinglane];\\n        //If we remain in same lane we need 0 side jumps additionally\\n        int remainInSameLane=(obstacles[i]!=walkinglane)?solve(obstacles,i+1,walkinglane,strg) : INT_MAX;\\n        //We can go to another lane if that lane is not having stones or is our current lane\\n        int goToAnotherLane=INT_MAX;\\n        for(int lane=1;lane<=3;lane++){\\n            if(lane!=obstacles[i-1] && lane!=walkinglane && lane!=obstacles[i]){\\n                goToAnotherLane=min(goToAnotherLane,1+solve(obstacles,i+1,lane,strg));\\n            }\\n        }\\n        int sideJumps=min(remainInSameLane,goToAnotherLane);\\n        return strg[i][walkinglane] = sideJumps;\\n    }\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> strg(obstacles.size()+1,vector<int>(4,-1));\\n        //Keep track of point and the lane\\n        return solve(obstacles,1,2,strg);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686603,
                "title": "simple-dp-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(vector<int>& obstacles,int i,int j,int n,vector<vector<int>>& dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        if(obstacles[i+1]==0 || obstacles[i+1]!=j){\\n            ans=0+solve(obstacles,i+1,j,n,dp);\\n        }\\n        else if(obstacles[i+1]==j){\\n            if(j==2){\\n              if(obstacles[i]==1) ans+=1+solve(obstacles,i,j+1,n,dp);\\n              else if(obstacles[i]==3) ans+=1+solve(obstacles,i,j-1,n,dp);\\n              else ans+=min(1+solve(obstacles,i,j+1,n,dp),1+solve(obstacles,i,j-1,n,dp));\\n            }\\n            else if(j==1){\\n                if(obstacles[i]==2) ans+=1+solve(obstacles,i,j+2,n,dp);\\n                else if(obstacles[i]==3) ans+=1+solve(obstacles,i,j+1,n,dp);\\n                else ans+=min(1+solve(obstacles,i,j+2,n,dp),1+solve(obstacles,i,j+1,n,dp));\\n            }\\n            else if(j==3){\\n                 if(obstacles[i]==2) ans+=1+solve(obstacles,i,j-2,n,dp);\\n                else if(obstacles[i]==1) ans+=1+solve(obstacles,i,j-1,n,dp);\\n                else ans+=min(1+solve(obstacles,i,j-2,n,dp),1+solve(obstacles,i,j-1,n,dp));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> dp(n,vector<int> (4,-1));\\n        int ans=solve(obstacles,0,2,n,dp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int>& obstacles,int i,int j,int n,vector<vector<int>>& dp){\\n        if(i==n-1) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int ans=0;\\n        if(obstacles[i+1]==0 || obstacles[i+1]!=j){\\n            ans=0+solve(obstacles,i+1,j,n,dp);\\n        }\\n        else if(obstacles[i+1]==j){\\n            if(j==2){\\n              if(obstacles[i]==1) ans+=1+solve(obstacles,i,j+1,n,dp);\\n              else if(obstacles[i]==3) ans+=1+solve(obstacles,i,j-1,n,dp);\\n              else ans+=min(1+solve(obstacles,i,j+1,n,dp),1+solve(obstacles,i,j-1,n,dp));\\n            }\\n            else if(j==1){\\n                if(obstacles[i]==2) ans+=1+solve(obstacles,i,j+2,n,dp);\\n                else if(obstacles[i]==3) ans+=1+solve(obstacles,i,j+1,n,dp);\\n                else ans+=min(1+solve(obstacles,i,j+2,n,dp),1+solve(obstacles,i,j+1,n,dp));\\n            }\\n            else if(j==3){\\n                 if(obstacles[i]==2) ans+=1+solve(obstacles,i,j-2,n,dp);\\n                else if(obstacles[i]==1) ans+=1+solve(obstacles,i,j-1,n,dp);\\n                else ans+=min(1+solve(obstacles,i,j-2,n,dp),1+solve(obstacles,i,j-1,n,dp));\\n            }\\n        }\\n        return dp[i][j]=ans;\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>> dp(n,vector<int> (4,-1));\\n        int ans=solve(obstacles,0,2,n,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679881,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int [][] path=new int[obstacles.length][4];\\n        for(int i=0;i<obstacles.length;i++){\\n            for(int j=0;j<4;j++){\\n                if(obstacles[i]!=0)\\n                {\\n                    path[i][obstacles[i]]=1;\\n                }\\n            }\\n        }\\n        int [][]dp=new int[obstacles.length][4];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<4;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(path,0,obstacles.length-1,2,dp);\\n    }\\n\\n    int solve(int [][]path,int start,int end,int lane,int [][]dp){\\n        if(start==end){\\n            return 0;\\n        }\\n        if(path[start+1][lane]==0){\\n            return solve(path,start+1,end,lane,dp);\\n        }\\n        if(dp[start][lane]!=-1){\\n            return dp[start][lane];\\n        }\\n        else{\\n            if(lane==1){\\n                if(path[start][lane+1]==0 && path[start][lane+2]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane+1,dp),1+solve(path,start,end,lane+2,dp));}\\n                else if(path[start][lane+1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane+1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane+2,dp);\\n                }}\\n            else if(lane==2){\\n                if(path[start][lane-1]==0 && path[start][lane+1]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane-1,dp),1+solve(path,start,end,lane+1,dp));}\\n                else if(path[start][lane-1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane-1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane+1,dp);\\n                }}\\n            else{\\n                if(path[start][lane-1]==0 && path[start][lane-2]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane-1,dp),1+solve(path,start,end,lane-2,dp));}\\n                else if(path[start][lane-1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane-1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane-2,dp);\\n                }\\n    }}\\n}}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minSideJumps(int[] obstacles) {\\n        int [][] path=new int[obstacles.length][4];\\n        for(int i=0;i<obstacles.length;i++){\\n            for(int j=0;j<4;j++){\\n                if(obstacles[i]!=0)\\n                {\\n                    path[i][obstacles[i]]=1;\\n                }\\n            }\\n        }\\n        int [][]dp=new int[obstacles.length][4];\\n        for(int i=0;i<dp.length;i++){\\n            for(int j=0;j<4;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(path,0,obstacles.length-1,2,dp);\\n    }\\n\\n    int solve(int [][]path,int start,int end,int lane,int [][]dp){\\n        if(start==end){\\n            return 0;\\n        }\\n        if(path[start+1][lane]==0){\\n            return solve(path,start+1,end,lane,dp);\\n        }\\n        if(dp[start][lane]!=-1){\\n            return dp[start][lane];\\n        }\\n        else{\\n            if(lane==1){\\n                if(path[start][lane+1]==0 && path[start][lane+2]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane+1,dp),1+solve(path,start,end,lane+2,dp));}\\n                else if(path[start][lane+1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane+1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane+2,dp);\\n                }}\\n            else if(lane==2){\\n                if(path[start][lane-1]==0 && path[start][lane+1]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane-1,dp),1+solve(path,start,end,lane+1,dp));}\\n                else if(path[start][lane-1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane-1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane+1,dp);\\n                }}\\n            else{\\n                if(path[start][lane-1]==0 && path[start][lane-2]==0){\\n                    return dp[start][lane]=Math.min(1+solve(path,start,end,lane-1,dp),1+solve(path,start,end,lane-2,dp));}\\n                else if(path[start][lane-1]==0){\\n                    return dp[start][lane]=1+solve(path,start,end,lane-1,dp);\\n                }\\n                else{\\n                    return dp[start][lane]=1+solve(path,start,end,lane-2,dp);\\n                }\\n    }}\\n}}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640186,
                "title": "dp-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int i,int l,int n,vector<vector<int>>&dp){\\n        if(i>=n-1)return 0;\\n        if(v[i]==l)return 1e8;\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        // when next point is clear\\n        if(v[i+1]!=l)\\n            return dp[i][l] = solve(v,i+1,l,n,dp);\\n\\n        // when next point has an obstacle\\n        if(l==2)\\n            return dp[i][l] = min(1+solve(v,i,3,n,dp),1+solve(v,i,1,n,dp));\\n        else if(l==1) return dp[i][l] = min(1+solve(v,i,2,n,dp),1+solve(v,i,3,n,dp));\\n\\n        else return dp[i][l] = min(1+solve(v,i,2,n,dp),1+solve(v,i,1,n,dp));\\n\\n    }\\n    int minSideJumps(vector<int>& v) {\\n        int n=v.size();\\n        int i=0,l=2;\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return solve(v,i,l,n,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&v,int i,int l,int n,vector<vector<int>>&dp){\\n        if(i>=n-1)return 0;\\n        if(v[i]==l)return 1e8;\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        // when next point is clear\\n        if(v[i+1]!=l)\\n            return dp[i][l] = solve(v,i+1,l,n,dp);\\n\\n        // when next point has an obstacle\\n        if(l==2)\\n            return dp[i][l] = min(1+solve(v,i,3,n,dp),1+solve(v,i,1,n,dp));\\n        else if(l==1) return dp[i][l] = min(1+solve(v,i,2,n,dp),1+solve(v,i,3,n,dp));\\n\\n        else return dp[i][l] = min(1+solve(v,i,2,n,dp),1+solve(v,i,1,n,dp));\\n\\n    }\\n    int minSideJumps(vector<int>& v) {\\n        int n=v.size();\\n        int i=0,l=2;\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return solve(v,i,l,n,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637617,
                "title": "c-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i,int last,int n,vector<int> &obs,vector<vector<int>> &dp ){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i][last]!=-1){\\n            return dp[i][last];\\n        }\\n        \\n        int ans=INT_MAX;\\n        if(obs[i]==0){\\n            ans=min(ans, find(i+1,last,n,obs,dp));\\n        }\\n        else if(obs[i]==last){\\n            for(int it=1;it<=3;it++){\\n                if(last!=it and obs[i-1]!=it){\\n                    ans=min(ans,1+find(i+1,it,n,obs,dp));\\n                }\\n            }\\n        }\\n        else{\\n            ans=min(ans,find(i+1,last,n,obs,dp));\\n        }\\n        return dp[i][last]=ans;\\n       \\n        \\n    }\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return find(1,2,n,obs,dp);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i,int last,int n,vector<int> &obs,vector<vector<int>> &dp ){\\n        if(i>=n-1){\\n            return 0;\\n        }\\n        if(dp[i][last]!=-1){\\n            return dp[i][last];\\n        }\\n        \\n        int ans=INT_MAX;\\n        if(obs[i]==0){\\n            ans=min(ans, find(i+1,last,n,obs,dp));\\n        }\\n        else if(obs[i]==last){\\n            for(int it=1;it<=3;it++){\\n                if(last!=it and obs[i-1]!=it){\\n                    ans=min(ans,1+find(i+1,it,n,obs,dp));\\n                }\\n            }\\n        }\\n        else{\\n            ans=min(ans,find(i+1,last,n,obs,dp));\\n        }\\n        return dp[i][last]=ans;\\n       \\n        \\n    }\\n    int minSideJumps(vector<int>& obs) {\\n        int n=obs.size();\\n        vector<vector<int>> dp(n+1,vector<int>(4,-1));\\n        return find(1,2,n,obs,dp);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629170,
                "title": "simple-solution-by-uisng-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int solve(vector<int>& obs, int pos, int currlane, vector<vector<int>> &dp){\\n        int n=obs.size()-1;\\n        //base case\\n        if(pos==n){\\n            return 0;\\n        }\\n        if(dp[pos][currlane]!=-1){\\n            return dp[pos][currlane];\\n        }\\n        if(obs[pos+1]!=currlane){\\n            return solve(obs, pos+1, currlane, dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            //sideways jump\\n            for(int i=1;i<=3; i++){\\n                if(currlane!=i && obs[pos]!=i){\\n                    ans=min(ans,1+solve(obs,pos,i, dp));\\n                }\\n                dp[pos][currlane]=ans;\\n            }\\n            return dp[pos][currlane];\\n        }\\n\\n\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(obstacles.size(), vector<int>(4,-1));\\n        return solve(obstacles, 0, 2, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    int solve(vector<int>& obs, int pos, int currlane, vector<vector<int>> &dp){\\n        int n=obs.size()-1;\\n        //base case\\n        if(pos==n){\\n            return 0;\\n        }\\n        if(dp[pos][currlane]!=-1){\\n            return dp[pos][currlane];\\n        }\\n        if(obs[pos+1]!=currlane){\\n            return solve(obs, pos+1, currlane, dp);\\n        }\\n        else{\\n            int ans=INT_MAX;\\n            //sideways jump\\n            for(int i=1;i<=3; i++){\\n                if(currlane!=i && obs[pos]!=i){\\n                    ans=min(ans,1+solve(obs,pos,i, dp));\\n                }\\n                dp[pos][currlane]=ans;\\n            }\\n            return dp[pos][currlane];\\n        }\\n\\n\\n    }\\npublic:\\n    int minSideJumps(vector<int>& obstacles) {\\n        vector<vector<int>> dp(obstacles.size(), vector<int>(4,-1));\\n        return solve(obstacles, 0, 2, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575124,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1566660,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1977745,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1992530,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1964380,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1948538,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1945904,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            },
            {
                "id": 1898467,
                "content": [
                    {
                        "username": "yxl136431",
                        "content": "I tried to optimize my python top down dp solution but get either TLE or MLE.\\uFF08lru_cache and memo won\\'t work\\uFF09.\\nThen I changed to bottom up and got accepted.\\nCan anyone share a top down solution that can pass all test cases?\\n"
                    },
                    {
                        "username": "ankur2611",
                        "content": "same happening for me\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "This problem is special and interesting to me as  \\n- This is the first problem I found so far which can use DP, BFS and Dijkstra to solve\\n- This is the first problem I found so fat  that we can use Deque (replace the Priority queue) to implement the Dijkstra to achieve O(V) complexity.\\n\\n**DP**\\nDP state transition can be found here.  \\nHere we only show how to transit from previous point to lane 1 of current point. For lane 2 and lane 3, the idea is the same.\\n![image](https://assets.leetcode.com/users/images/c91e765d-3861-45ae-ba35-e33c5429287a_1618366432.6614845.png)\\n\\nDP code. BFS, standard Dijkstra and improved Dijkstra code can be found in my [medium post](https://jimmy-shen.medium.com/solve-a-problem-by-using-o-n-dijkstra-or-dp-9312f6a6beb6).\\nIf you feel this is helpful. Please unvote so more people will be benefit from this article. Thanks.\\n"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Silly statement. Why can we jump over an obstacle in one direction but not the other? Physics have left the chat..."
                    },
                    {
                        "username": "45_Siddhant",
                        "content": "us bhai"
                    },
                    {
                        "username": "sachinrao1",
                        "content": "The Problem in test case one why ans is two the currect ans is one"
                    },
                    {
                        "username": "dinklegarg7289",
                        "content": "in what cases code gives memory limit exceeded\\n"
                    },
                    {
                        "username": "anandnit",
                        "content": "0,1,2,3,0  MINIMUM JUMP POSSIBLE IS 1 , BUT WHY IT IS GIVING 2 ?? "
                    },
                    {
                        "username": "Anonymous_0120",
                        "content": "Consider the point that the frog is starting from the middle lane at index 0. Frog can not start from any lane."
                    },
                    {
                        "username": "geekyshark",
                        "content": "cool problem"
                    },
                    {
                        "username": "ctlang",
                        "content": "This should be hard.\nIt seems like a straightforward DP problem, but top-down causes stack overflow and bottom-up has very long runtime. Single-pass state table is the most efficient solution but edge cases are much trickier to spot than most medium problems."
                    }
                ]
            }
        ]
    }
]