[
    {
        "title": "Distribute Candies to People",
        "question_content": "We distribute some&nbsp;number of candies, to a row of n =&nbsp;num_people&nbsp;people in the following way:\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give n&nbsp;candies to the last person.\nThen, we go back to the start of the row, giving n&nbsp;+ 1 candies to the first person, n&nbsp;+ 2 candies to the second person, and so on until we give 2 * n&nbsp;candies to the last person.\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies.&nbsp; The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\nReturn an array (of length num_people&nbsp;and sum candies) that represents the final distribution of candies.\n&nbsp;\nExample 1:\n\nInput: candies = 7, num_people = 4\nOutput: [1,2,3,1]\nExplanation:\nOn the first turn, ans[0] += 1, and the array is [1,0,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3,0].\nOn the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1].\n\nExample 2:\n\nInput: candies = 10, num_people = 3\nOutput: [5,2,3]\nExplanation: \nOn the first turn, ans[0] += 1, and the array is [1,0,0].\nOn the second turn, ans[1] += 2, and the array is [1,2,0].\nOn the third turn, ans[2] += 3, and the array is [1,2,3].\nOn the fourth turn, ans[0] += 4, and the final array is [5,2,3].\n\n&nbsp;\nConstraints:\n\n\t1 <= candies <= 10^9\n\t1 <= num_people <= 1000",
        "solutions": [
            {
                "id": 323314,
                "title": "java-python3-easy-code-w-explanation-and-analysis",
                "content": "1. Use `give % num_people` to determine the current index of the people, where `give` is the `give-th` giving of candy;\\n2. Increase each giving amount by 1 till run out of candies.\\n\\n**Java:**\\n```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        for (int give = 0; candies > 0; candies -= give) {\\n            people[give % num_people] +=  Math.min(candies, ++give);\\n        }\\n        return people;\\n    }\\n```\\n----\\n**Python3:**\\n```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        people = num_people * [0]\\n        give = 0\\n        while candies > 0:\\n            people[give % num_people] += min(candies, give + 1)\\n            give += 1\\n            candies -= give\\n        return people\\n```\\n**Analysis:**\\nAssume there are `give` times distribution such that `1 + 2 + ... + give >= candies`. Therefore,\\n`(1 + give) * give / 2 >= candies`, and when `give` is big enough, `(give + 1) * give /2 ~ candies`. We have: \\n```\\n1/2 * give ^ 2 < 1/2 * (give ^ 2 + give)  < 1/ 2 * (give + 1) ^ 2\\n```\\nthen \\n```\\n1/2 * give ^ 2 < candies < 1/ 2 * (give + 1) ^ 2\\n```\\nso\\n```\\ngive < sqrt(2 * candies) ~ O(sqrt(candies))\\n```\\nTime: O(sqrt(candies)), space: O(num_people) - including return array.",
                "solutionTags": [],
                "code": "```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        for (int give = 0; candies > 0; candies -= give) {\\n            people[give % num_people] +=  Math.min(candies, ++give);\\n        }\\n        return people;\\n    }\\n```\n```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        people = num_people * [0]\\n        give = 0\\n        while candies > 0:\\n            people[give % num_people] += min(candies, give + 1)\\n            give += 1\\n            candies -= give\\n        return people\\n```\n```\\n1/2 * give ^ 2 < 1/2 * (give ^ 2 + give)  < 1/ 2 * (give + 1) ^ 2\\n```\n```\\n1/2 * give ^ 2 < candies < 1/ 2 * (give + 1) ^ 2\\n```\n```\\ngive < sqrt(2 * candies) ~ O(sqrt(candies))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323364,
                "title": "java-c-python-math-solution-and-simulation-o-1-to-get-each",
                "content": "# **Solution 1: Math**\\nMath solution, but personally not really like it.\\nTime only `O(1)` to get value for each people, \\nthough `O(n)` for output.\\nAnd strictly speaking, `math.sqrt` also consumes the time.\\n\\n```python\\n    def distributeCandies(self, candies, n):\\n        x = int(math.sqrt(candies * 2 + 0.25) - 0.5)\\n        res = [0] * n\\n        for i in xrange(n):\\n            m = x / n + (x % n > i)\\n            res[i] = m * (i + 1) + m * (m - 1) / 2 * n\\n        res[x % n] += candies - x * (x + 1) / 2\\n        return res\\n```\\n<br>\\n\\n# **Intuition**\\nBrute force of simulation seems to be easy.\\nBut how is the time complexity?\\n<br>\\n\\n# **Solution 2: Explanation**\\nThe `i-th` distribution,\\nwe will distribute `i + 1` candies to `(i % n)`th people.\\nWe just simulate the process of distribution until we ran out of candies.\\n\\n# **Complexity**\\nTime `O(sqrt(candies) + n)`\\nSpace `O(n)` for output\\n\\nThe number of given candies is `i + 1`, which is an increasing sequence.\\nThe total number distributed candies is `c * (c + 1) / 2` until it\\'s bigger than `candies`.\\nSo the time it takes is `O(sqrt(candies))`\\n<br>\\n\\n**Java:**\\n```java\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += Math.min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```python\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        i = 0\\n        while candies > 0:\\n            res[i % n] += min(candies, i + 1)\\n            candies -= i + 1\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n    def distributeCandies(self, candies, n):\\n        x = int(math.sqrt(candies * 2 + 0.25) - 0.5)\\n        res = [0] * n\\n        for i in xrange(n):\\n            m = x / n + (x % n > i)\\n            res[i] = m * (i + 1) + m * (m - 1) / 2 * n\\n        res[x % n] += candies - x * (x + 1) / 2\\n        return res\\n```\n```java\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += Math.min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        for (int i = 0; candies > 0; ++i) {\\n            res[i % n] += min(candies, i + 1);\\n            candies -= i + 1;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        i = 0\\n        while candies > 0:\\n            res[i % n] += min(candies, i + 1)\\n            candies -= i + 1\\n            i += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323298,
                "title": "c-brute-force",
                "content": "I was going down the mathematical path and it felt a bit tricky. Since the problem is \\'Easy\\', I guessed the brute-force should do for the contest.\\n```\\nvector<int> distributeCandies(int c, int num) {\\n  vector<int> res(num);\\n  for (auto i = 0; c > 0; c -= ++i) \\n    res[i % num] += min(i + 1, c);\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> distributeCandies(int c, int num) {\\n  vector<int> res(num);\\n  for (auto i = 0; c > 0; c -= ++i) \\n    res[i % num] += min(i + 1, c);\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796574,
                "title": "python-math-o-k-solution-with-explanation",
                "content": "There are different ways how you can handle this problem, I prefer mathematical way. Let us define `k = num_people` and `n = candies` and try to understand how many candies we need to give to `i`-the person.  \\n\\n| 1    | 2   | 3    | ... | k   |\\n|------|-----|------|-----|-----|\\n| **k+1**  | **k+2** | **k+3**  | **...** | **2k**  |\\n| **...**  | **...** | **...**  | **...** | **...** |\\n| **sk+1** | **...** | **sk+i** |     |     |\\n\\nWe need to find the biggest `s`, such that the sum of numbers before is less or equal to `n`. Let us compute it:\\n\\n**1.** First row: `k(k+1)/2`, sum of arithmetic progression.\\n\\n**2.** Second row: `k(k+1)/2 + k^2`.\\n\\n**3.** Third row:  `k(k+1)/2 + 2*k^2`.\\n...\\n\\n**s-1.** `k(k+1)/2 + (s-1)*k^2`.\\n\\n**s.** `s*k*i + i(i+1)/2`.\\n\\nLet us evaluate this sum and solve quadratic inequality:\\n\\n![image](https://assets.leetcode.com/users/images/d526bc75-9a24-4903-a81f-361ab34dda1b_1597655950.5398853.png)\\n\\n\\nSo, we have root `s = ((-1-2*i) + sqrt(1+8*n))/(2*k)` and we need to find the biggest integer number which is less than `s`, let us define it `t = floor(s)`.\\nNow, how many candies we need to give to this person? It is `i + (k+i) + ... + (sk+i) = i*(t+1) + k*t*(t+1)//2`. Finally, we need to find the last person, who gets the rest of the candies. How we can do it? I evaluate difference `s - floor(s)` and choose the person with the biggest difference.\\n\\n**Complexity**: time and space complexity is `O(k)`, where `k` is number of people. \\n\\n\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        k, n = num_people, candies\\n        alloc = [0]*k\\n        Final = (0, 0)\\n        for i in range(1, k+1):\\n            s = ((-1-2*i) + sqrt(1+8*n))/(2*k)\\n            t = floor(s)\\n            alloc[i-1] = i*(t+1) + k*t*(t+1)//2\\n            Final = max(Final, (s-floor(s), i)) \\n            \\n        alloc[Final[1]-1] += (n - sum(alloc))\\n            \\n        return alloc\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        k, n = num_people, candies\\n        alloc = [0]*k\\n        Final = (0, 0)\\n        for i in range(1, k+1):\\n            s = ((-1-2*i) + sqrt(1+8*n))/(2*k)\\n            t = floor(s)\\n            alloc[i-1] = i*(t+1) + k*t*(t+1)//2\\n            Final = max(Final, (s-floor(s), i)) \\n            \\n        alloc[Final[1]-1] += (n - sum(alloc))\\n            \\n        return alloc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796745,
                "title": "distribute-candies-0-ms-math-heavy-java",
                "content": "Of course, we could do literally what the problem says and simulate the distribution of candy - but as you imagine, this can get really slow when we reach `num_people = 10 ^ 9`.\\n\\nThe other approach is to skip the simulation and calculate the final candy distribution.\\n\\nLet\\'s imagine the candy distribution process for `candies = 10`, and `num_people = 3`:\\n\\nPerson 0 receives 1 piece of candy, Person 1 receives 2 pieces of candy, Person 2 receives 3 pieces of candy then we go back to Person 0 to give them the remaining 4 pieces of candy.\\nSo,\\n```\\n    p[0]  p[1]  p[2]\\n0:   1     2     3   +\\n1:   4\\n----------------\\n     5     2     3\\n```\\n\\nLet\\'s generalise: (`n = num_people`)\\n```\\n              p[0]            p[1]      ...       p[n - 1]\\n-----------------------------------------------------------\\n0:              1               2       ...           n\\n1:            n + 1           n + 2     ...         2 * n\\n...            ...             ...      ...          ... \\nk-1:  (k-1) * n + 1     (k-1)*n + 2     ...         k * n\\n```\\n(Remember this sum `1 + 2 + ... + n = n*(n + 1)/2`. Let\\'s call this as `gauss(n)` - EDIT: sum is `n*(n+1)/2` as user \\'cantbenix\\' said not `n*(n-1)/2` as I had left it before)\\nHow much candy have I distributed up until now? `1 + 2 + 3 + ... k * n = gauss(k * n)`\\nOf course, let\\'s not forget the remaining candy, which wouldn\\'t be enough to finish another row (or distribution cycle):\\n```\\n          k * n + 1       k * n + 2     ...\\n```\\nSo what did I need to do here? I want to find the greatest `k` such that I can do `k` passes of candy distribution \"automatically\". (I\\'ll do the remaining in a \"manual\" `for` loop.)\\nThat is, I need to find the greatest `k` so that `gauss(k * n) <= c`, where `c = candies`.\\nThis means: find greatest k such that `k*n * (k*n + 1) / 2 <= c`\\nWrite it again: \\n`n^2 * k^2 + n * k - 2*c <= 0`\\n\\nEDIT: Added process to obtain `k`.\\n![image](https://assets.leetcode.com/users/images/21103f79-5f58-4e0e-89c8-583395f1c721_1597852489.4983099.png)\\n\\n\\nIn code:\\n```\\nint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n```\\nI have `k`, let\\'s take out our `k` distribution cycles of candy.\\n```\\ncandies -= gauss(k * num_people);\\n```\\n(gauss(n) in code:)\\n```\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```\\n(EDIT: in the last row, second column it should be n*gauss(k-1) + 2*k,  as user \\'Juggernaut12\\' said)\\nNow let\\'s go back to our rows - and add them up:\\n```\\n              p[0]            p[1]             ...       p[n - 1]\\n------------------------------------------------------------------------\\n0:              1                     2        ...           n\\n1:            n + 1                 n + 2      ...         2 * n\\n...            ...                   ...       ...          ... \\nk-1:  (k-1) * n + 1           (k-1)*n + 2      ...         n * n\\n---------------------------------------------------------------------------\\ns: n*gauss(k-1) + 1*k    n*gauss(k-1) + 2*k    ...    n*gauss(k-1) + n*k\\n```\\nIn code:\\n```\\nfor (int i = 0; i < num_people; i++) {\\n\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n}\\n```\\nAll that remains is the last remaining distribution cycle.\\nIn code:\\n```\\nint d = k * num_people + 1;\\nint j = d;\\nfor (; candies - j >= 0; j++) {\\n\\tp[j - d] += j;\\n\\tcandies -= j;\\n}\\n\\nif (candies > 0) {\\n\\tp[j - d] += candies;\\n}\\n```\\n\\nFull solution:\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] p = new int[num_people];\\n\\n\\tint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n\\tcandies -= gauss(k * num_people);\\n\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n\\t}\\n\\n\\tint d = k * num_people + 1;\\n\\tint j = d;\\n\\tfor (; candies - j >= 0; j++) {\\n\\t\\tp[j - d] += j;\\n\\t\\tcandies -= j;\\n\\t}\\n\\n\\tif (candies > 0) {\\n\\t\\tp[j - d] += candies;\\n\\t}\\n\\n\\treturn p;\\n}\\n\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    p[0]  p[1]  p[2]\\n0:   1     2     3   +\\n1:   4\\n----------------\\n     5     2     3\\n```\n```\\n              p[0]            p[1]      ...       p[n - 1]\\n-----------------------------------------------------------\\n0:              1               2       ...           n\\n1:            n + 1           n + 2     ...         2 * n\\n...            ...             ...      ...          ... \\nk-1:  (k-1) * n + 1     (k-1)*n + 2     ...         k * n\\n```\n```\\n          k * n + 1       k * n + 2     ...\\n```\n```\\nint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n```\n```\\ncandies -= gauss(k * num_people);\\n```\n```\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```\n```\\n              p[0]            p[1]             ...       p[n - 1]\\n------------------------------------------------------------------------\\n0:              1                     2        ...           n\\n1:            n + 1                 n + 2      ...         2 * n\\n...            ...                   ...       ...          ... \\nk-1:  (k-1) * n + 1           (k-1)*n + 2      ...         n * n\\n---------------------------------------------------------------------------\\ns: n*gauss(k-1) + 1*k    n*gauss(k-1) + 2*k    ...    n*gauss(k-1) + n*k\\n```\n```\\nfor (int i = 0; i < num_people; i++) {\\n\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n}\\n```\n```\\nint d = k * num_people + 1;\\nint j = d;\\nfor (; candies - j >= 0; j++) {\\n\\tp[j - d] += j;\\n\\tcandies -= j;\\n}\\n\\nif (candies > 0) {\\n\\tp[j - d] += candies;\\n}\\n```\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] p = new int[num_people];\\n\\n\\tint k = (int) Math.floor((Math.sqrt(1 + 8 * (double) candies) - 1) / (double) (2 * num_people));\\n\\tcandies -= gauss(k * num_people);\\n\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\tp[i] += num_people * gauss(k - 1) + k * (i + 1);\\n\\t}\\n\\n\\tint d = k * num_people + 1;\\n\\tint j = d;\\n\\tfor (; candies - j >= 0; j++) {\\n\\t\\tp[j - d] += j;\\n\\t\\tcandies -= j;\\n\\t}\\n\\n\\tif (candies > 0) {\\n\\t\\tp[j - d] += candies;\\n\\t}\\n\\n\\treturn p;\\n}\\n\\nprivate int gauss(int n) {\\n\\treturn n * (n + 1) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324215,
                "title": "java-o-num-people-one-pass-math-solution-solving-quadratic-function",
                "content": "Different solution from the O(sqrt(candies)) one.\\n\\nExplanation:\\n The operation of distributing candies is an Arithmetic Sequence. \\n If we want to get the sum from 1 to n, the formula is` (1+n) * n / 2`.\\n =>` (1+n) * n / 2 = candies => n^2 + n - 2*candies = 0` \\n If the one dimensional quadratic function is like `ax^2 + bx + c = 0` where a, b, c are parameters.\\n There is a formula to solve it which is[ x = (-b (+/-) sqrt(b^2-4\\\\*a\\\\*c)) / (2\\\\*a)](https://en.wikipedia.org/wiki/Quadratic_formula).\\n \\n Based on that, we can know the # of times which the candies are fully distributed where fully means the person get the # of candies which is supposed to distribute, \\n not the leftover.\\n \\n Let\\'s use 3 people as an example,\\n 1       ->  2       ->  3\\n (1+3)-> (2+3)  -> (3 + 3)\\n (1+2\\\\*3) -> (2+2\\\\*3) ->(3+2\\\\*3)\\n ......\\n It is quite obvious that except the first round, the value of each cell of the rest rounds is just the sum of their count at the first round\\n plus the length of the array times the number of rounds(0 based) it goes(Another Arithmetic sequence). Based on the length of the quadratic formula we calculated above, we can calculate the # of rounds, the mod, and the # of candies of the leftover. \\nThe complexity is `O(num_people)`, since we only need to assign value to the return array once.\\n \\n \\n     public int[] distributeCandies(int candies, int num_people) {\\n        int end = (int)((-1 + Math.sqrt(1L+8L*candies)) / 2f);  // Kind of dislike the overflow testcase of this question.\\n        int extra_candies = candies - (1 + end) * end / 2; // Get the leftover for the last distribution.\\n        int rounds = end / num_people;\\n        int rest = end % num_people;\\n        int[] res = new int[num_people];\\n\\t\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\t\\tif (i < rest) {\\n\\t\\t\\t\\tres[i] = (int)((i + 1) * (rounds + 1) + (1 + rounds) * rounds / 2 * num_people);\\n\\t\\t\\t} else if (i == rest) {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people + extra_candies;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people;\\n\\t\\t\\t}\\n\\t\\t}\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Different solution from the O(sqrt(candies)) one.\\n\\nExplanation:\\n The operation of distributing candies is an Arithmetic Sequence. \\n If we want to get the sum from 1 to n, the formula is` (1+n) * n / 2`.\\n =>` (1+n) * n / 2 = candies => n^2 + n - 2*candies = 0` \\n If the one dimensional quadratic function is like `ax^2 + bx + c = 0` where a, b, c are parameters.\\n There is a formula to solve it which is[ x = (-b (+/-) sqrt(b^2-4\\\\*a\\\\*c)) / (2\\\\*a)](https://en.wikipedia.org/wiki/Quadratic_formula).\\n \\n Based on that, we can know the # of times which the candies are fully distributed where fully means the person get the # of candies which is supposed to distribute, \\n not the leftover.\\n \\n Let\\'s use 3 people as an example,\\n 1       ->  2       ->  3\\n (1+3)-> (2+3)  -> (3 + 3)\\n (1+2\\\\*3) -> (2+2\\\\*3) ->(3+2\\\\*3)\\n ......\\n It is quite obvious that except the first round, the value of each cell of the rest rounds is just the sum of their count at the first round\\n plus the length of the array times the number of rounds(0 based) it goes(Another Arithmetic sequence). Based on the length of the quadratic formula we calculated above, we can calculate the # of rounds, the mod, and the # of candies of the leftover. \\nThe complexity is `O(num_people)`, since we only need to assign value to the return array once.\\n \\n \\n     public int[] distributeCandies(int candies, int num_people) {\\n        int end = (int)((-1 + Math.sqrt(1L+8L*candies)) / 2f);  // Kind of dislike the overflow testcase of this question.\\n        int extra_candies = candies - (1 + end) * end / 2; // Get the leftover for the last distribution.\\n        int rounds = end / num_people;\\n        int rest = end % num_people;\\n        int[] res = new int[num_people];\\n\\t\\tfor (int i = 0; i < num_people; i++) {\\n\\t\\t\\tif (i < rest) {\\n\\t\\t\\t\\tres[i] = (int)((i + 1) * (rounds + 1) + (1 + rounds) * rounds / 2 * num_people);\\n\\t\\t\\t} else if (i == rest) {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people + extra_candies;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres[i] = (i + 1) * rounds + (rounds - 1) * rounds / 2 * num_people;\\n\\t\\t\\t}\\n\\t\\t}\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 796969,
                "title": "c-one-pass-solution",
                "content": "candies can be separated into kth consecutive numbers and remains (less than k + 1) which can be represented by \\n\\n![image](https://assets.leetcode.com/users/images/1912f310-2130-4725-a1c5-7bcef2f1749c_1597674695.8112812.png)\\n\\nAfter getting k, we can know how many rounds that all persons get the desire candies are performed.\\n![image](https://assets.leetcode.com/users/images/60f69745-3943-4290-8fb1-8660ac2070a2_1597674738.0373456.png)\\n\\n\\nfor ith person, the total candies that he obtains is \\n\\n![image](https://assets.leetcode.com/users/images/55e53b64-f0b6-415c-b9dd-8ba9de9a6550_1597674766.2962093.png)\\n\\n\\nConvert above into C++ code\\n```C++\\nvector<int> distributeCandies(double candies, int num_people) {\\n\\tvector<int> res(num_people, 0);\\n\\n\\tdouble total = floor((-1 + sqrt(1 + 8 * candies)) / 2);\\n\\tint round = floor(total / num_people);\\n\\n\\tfor (int i = 1; i <= num_people; i++)\\n\\t{\\n\\t\\tint first = i;\\n\\t\\tint last = first + num_people * (round - 1);\\n\\t\\tint inComplete = candies - (num_people+last) * (num_people + last - 1) / 2;\\n\\t\\tres[i - 1] = (first + last) * round / 2 + max(min(last + num_people, inComplete), 0);\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```C++\\nvector<int> distributeCandies(double candies, int num_people) {\\n\\tvector<int> res(num_people, 0);\\n\\n\\tdouble total = floor((-1 + sqrt(1 + 8 * candies)) / 2);\\n\\tint round = floor(total / num_people);\\n\\n\\tfor (int i = 1; i <= num_people; i++)\\n\\t{\\n\\t\\tint first = i;\\n\\t\\tint last = first + num_people * (round - 1);\\n\\t\\tint inComplete = candies - (num_people+last) * (num_people + last - 1) / 2;\\n\\t\\tres[i - 1] = (first + last) * round / 2 + max(min(last + num_people, inComplete), 0);\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796427,
                "title": "easy-to-understand-java-solution-without-complex-math-formulas",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797848,
                "title": "solution-python",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        # create an array of size num_people and initialize it with 0\\n        list_people = [0] * num_people\\n        \\n        # starting value\\n        index = 1\\n        \\n        # iterate until the number of candies are more than 0\\n        while candies > 0:\\n            \\n            # if candies are more than index value, add the index value to the location \\n            if candies > index:\\n                # we are using mod operation by the num_people to locate the index of the array\\n                # we are subtracting by 1 because the array index starts at 0\\n                list_people[(index - 1) % num_people] += index\\n            else:\\n                # if candies are less than index value, add all remaining candies to location\\n                list_people[(index - 1) % num_people] += candies\\n            \\n            # subtract the candies with index values\\n            candies -= index\\n            \\n            # increment the index values\\n            index += 1\\n        \\n        # return the resultant array\\n        return(list_people)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        # create an array of size num_people and initialize it with 0\\n        list_people = [0] * num_people\\n        \\n        # starting value\\n        index = 1\\n        \\n        # iterate until the number of candies are more than 0\\n        while candies > 0:\\n            \\n            # if candies are more than index value, add the index value to the location \\n            if candies > index:\\n                # we are using mod operation by the num_people to locate the index of the array\\n                # we are subtracting by 1 because the array index starts at 0\\n                list_people[(index - 1) % num_people] += index\\n            else:\\n                # if candies are less than index value, add all remaining candies to location\\n                list_people[(index - 1) % num_people] += candies\\n            \\n            # subtract the candies with index values\\n            candies -= index\\n            \\n            # increment the index values\\n            index += 1\\n        \\n        # return the resultant array\\n        return(list_people)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331676,
                "title": "c-0ms-no-math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        int c = 1, i = 0;\\n        \\n        vector<int> result(num_people, 0);\\n        \\n        while(candies) {\\n\\n            int give = min(c, candies);\\n            result[i] += give;\\n            candies -= give;\\n            \\n            c++;\\n            i = (i+1) % num_people; \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        int c = 1, i = 0;\\n        \\n        vector<int> result(num_people, 0);\\n        \\n        while(candies) {\\n\\n            int give = min(c, candies);\\n            result[i] += give;\\n            candies -= give;\\n            \\n            c++;\\n            i = (i+1) % num_people; \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796547,
                "title": "optimal-python-solution-with-clear-explanation-of-idea",
                "content": "Please read with patience for clear understanding - Before proceeding, remember that sum of first n natural numbers is n*(n+1)//2\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n       \\'\\'\\'\\n        Idea: Round number k (starting from 1)\\n              -> give away\\n              (k-1)*n+1 + (k-1)*n+2 + ... + (k-1)*n + n = \\n              (k-1)*n^2 + n*(n+1)/2 candies\\n              \\n        Assume we have completed K full rounds, then K is the largest integer >= 0 with\\n        \\n        K*n*(n+1)/2 + K * (K-1)/2 * n^2 <= candies \\n        \\n        Find K by binary search and then simulate the last round.\\n        \\n        The person at index i gets\\n    \\n        0*n+i+1 + ... + (K-1)*n+i+1 = K*(i+1) + n*K*(K-1)/2 \\n        \\n        candies from rounds 1 to K, plus everything they get on their\\n        last round.\\n        \\n        Important: Allow for the fact that we may not complete a single round.\\n\\n        REVIEW\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        lo, hi = 0, candies\\n        K = 0\\n        while lo <= hi:\\n            k = (lo + hi)//2\\n            if k*(num_people*(num_people+1))//2 + (k*(k-1))//2 * num_people**2 <= candies:\\n                K = k\\n                lo = k + 1\\n            else:\\n                hi = k - 1\\n        result = [(i+1)*K+num_people*(K*(K-1))//2 for i in range(num_people)]\\n        candies -= sum(result)\\n        for i in range(num_people):\\n            add = min(candies, K * num_people + i + 1)\\n            result[i] += add\\n            candies -= add\\n            if candies == 0:\\n                break\\n        return result  \\n\\t\\t```\\nIf you came till here - Please Upvote my effort",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n       \\'\\'\\'\\n        Idea: Round number k (starting from 1)\\n              -> give away\\n              (k-1)*n+1 + (k-1)*n+2 + ... + (k-1)*n + n = \\n              (k-1)*n^2 + n*(n+1)/2 candies\\n              \\n        Assume we have completed K full rounds, then K is the largest integer >= 0 with\\n        \\n        K*n*(n+1)/2 + K * (K-1)/2 * n^2 <= candies \\n        \\n        Find K by binary search and then simulate the last round.\\n        \\n        The person at index i gets\\n    \\n        0*n+i+1 + ... + (K-1)*n+i+1 = K*(i+1) + n*K*(K-1)/2 \\n        \\n        candies from rounds 1 to K, plus everything they get on their\\n        last round.\\n        \\n        Important: Allow for the fact that we may not complete a single round.\\n\\n        REVIEW\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        lo, hi = 0, candies\\n        K = 0\\n        while lo <= hi:\\n            k = (lo + hi)//2\\n            if k*(num_people*(num_people+1))//2 + (k*(k-1))//2 * num_people**2 <= candies:\\n                K = k\\n                lo = k + 1\\n            else:\\n                hi = k - 1\\n        result = [(i+1)*K+num_people*(K*(K-1))//2 for i in range(num_people)]\\n        candies -= sum(result)\\n        for i in range(num_people):\\n            add = min(candies, K * num_people + i + 1)\\n            result[i] += add\\n            candies -= add\\n            if candies == 0:\\n                break\\n        return result  \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1088057,
                "title": "c-0-ms-faster-than-100-00-4-lines-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        for ( int index = 0; candies > 0; ++index, candies -= index )\\n            res[index % num_people] += min(index + 1, candies);\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        for ( int index = 0; candies > 0; ++index, candies -= index )\\n            res[index % num_people] += min(index + 1, candies);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 797184,
                "title": "c-very-performant-linear-approach-explained-100-time-75-space",
                "content": "Alright, I promise I will try to keep the math part to a minimum, but bear with me for that part.\\n\\nAssuming we have 4 people to feed glue + glucose (and diabetes) as in the first example and having a large amount of them, our situation would look like this:\\n\\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\\n\\nCan we spot a pattern here? I would say so: for now let\\'s look at each row and we can see how each one is formed; the initial one comes from the sum of all the first `n` numbers, but we know how to handle this with the Gaussian formula (conveniently abstracted in the `gaussianSum` helper).\\n\\nThe following ones come having each an extra of `n` times `n`, which I stored as `squaredN` times the current iteration (counting from `0`); or, in other words: the first round will be giving out `gaussianSum(n)` candies (we will store this number initially in `partialSum`) and all the following ones will increase said amount by `squaredN`.\\n\\nNow we can have a loop to compute how many full iterations we can run before being left with not enough candy to go for a full round of gluttony and this is not a small advantage!\\n\\nThe whole logic of the first `while` loop is dedicated to that, so that we can have a reliable `countLoop` value which tells us how many full loops we can go [and I am sure you can also set it up as an equation to find them, but I felt uninspired for that and it was more fun this way].\\n\\nNext step, we will fill all the slots with all the candies you can get doing full runs of each row.\\n\\nLooks again at this:\\n\\n```cpp\\n 1   2   3   4\\n 5   6   7   8\\n 9  10  11  12\\n13  14  15  16\\n```\\n\\nBut focus on the columns now: we can see that each one is made of `countLoops` times its position (starting the count from `1`, not from `0`) plus `0` times `n` from the first row, `1` time `n` from the second row, `2` times `n` from the second row and so on - that is to say, `gaussianSum(countLoops - 1)` times `n`.\\n\\nIn our `for` loop we put both thing together and we can get away filling the data of the full runs in linear time once we have `countLoops` properly computed.\\n\\nLast step: we need another `while` loop to finish assigning our sticky bonbon, iterating with `nextValue` initially set to the minimum value between the current amount of `candies` and `countLoops * n + 1` (which would have been the value of the extra candies given to the very first person in the next iteration), going on like that until we have something to give away - ie: at each step we decrease the amount of leftover `candies` by `nextValue`, add the `i`th cell by `nextValue` and increase both `i` and `nextValue` by `1`.\\n\\nAgain linear time :)\\n\\nFinally, we return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops = 0, partialSum = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        while (partialSum <= candies) {\\n            countLoops++;\\n            candies -= partialSum;\\n            partialSum += squaredN;\\n        }\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nWell, in the end I did feel inspired and went on for a more mathematical approach.\\n\\nSticking to the previous example, we know that each full loop is made of the Gaussian sum of all the numbers up to `n` times the number of loops, plus `n` times `n`, AKA `squaredN`, times the sum of all the first `n - 1` numbers (check them looking at the second part of the sequence with `16, 32, 48, ...`). Allow me to repeat the scheme:\\n\\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\\n\\nNow, we can build an equation out of it:\\n\\n```cpp\\ncandies == sumToN * x + (x - 1) * x / 2 * squaredN\\n```\\n\\nWith `x` being the number of full loops we can do (basically `countLoop`, but I guess with `x` it is clearer to see it as an equation).\\n\\nGrouping, we can have\\n\\n```cpp\\n0 == (squaredN / 2) * (x * x) + (sumToN -squaredN / 2) * x - candies;\\n```\\n\\nSo, basically we just need to solve a second degree equation with this coefficients:\\n* `a`: `squaredN / 2`;\\n* `b`: `sumToN -squaredN / 2`;\\n* `c`: `- candies`;\\n* taking only the positive solution (negative loops do not make sense here): `(-b + sqrt(b * b - 4 * a * c)) / (2 * a)`.\\n\\nAnd that works!\\n\\nBut now we have another problem: nothing decreases our `candies` any more!\\n\\nWell, we just have to compute how many we gave away with full loops!\\n\\nGiven that the formula for one cell is (see explanation above) `numberOfNs * n + (i + 1) * (countLoops)`, we just have to compute how much would it be running it from `1` to `n`, but that is relatively easy!\\n\\nDoing some math, we see that the first part is constant, so it would be `numberOfNs * n * n` or, better, `numberOfNs * squaredN`; the second part is basically `countLoops` multiplied the sum of all the numbers from `1` to `n` , so `sumToN * countLoops`.\\n\\nWith that done, we just need to keep our previous logic for the final (partial) pass and we are done :)\\n\\nThe updated code, much faster for larger values of `candies`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops, sumToN = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        float halfSquaredN = squaredN / 2.0, a = halfSquaredN, b = sumToN - halfSquaredN, c = -candies;\\n        countLoops = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // updating candies\\n        candies -= numberOfNs * squaredN + sumToN * countLoops;\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\n```cpp\\n 1   2   3   4\\n 5   6   7   8\\n 9  10  11  12\\n13  14  15  16\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops = 0, partialSum = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        while (partialSum <= candies) {\\n            countLoops++;\\n            candies -= partialSum;\\n            partialSum += squaredN;\\n        }\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\n 1   2   3   4 => 10\\n 5   6   7   8 => 10 + 16\\n 9  10  11  12 => 10 + 32\\n13  14  15  16 => 10 + 48\\n```\n```cpp\\ncandies == sumToN * x + (x - 1) * x / 2 * squaredN\\n```\n```cpp\\n0 == (squaredN / 2) * (x * x) + (sumToN -squaredN / 2) * x - candies;\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int gaussianSum(int n) {\\n        return (n + 1) * n / 2;\\n    }\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n);\\n        // setting up necessary variables\\n        int countLoops, sumToN = gaussianSum(n), squaredN = n * n, numberOfNs, i, nextValue;\\n        // computing how many full loops we can get\\n        float halfSquaredN = squaredN / 2.0, a = halfSquaredN, b = sumToN - halfSquaredN, c = -candies;\\n        countLoops = (-b + sqrt(b * b - 4 * a * c)) / (2 * a);\\n        // filling the vector with the full runs\\n        numberOfNs = gaussianSum(countLoops - 1);\\n        for (i = 0; i < res.size(); i++) res[i] =  numberOfNs * n + (i + 1) * (countLoops);\\n        // updating candies\\n        candies -= numberOfNs * squaredN + sumToN * countLoops;\\n        // adding residual values to each cell as long as we can proceed like that\\n        nextValue = min(candies, countLoops * n + 1);\\n        i = 0;\\n        while (candies) {\\n            candies -= nextValue;\\n            res[i++] += nextValue;\\n            nextValue = min(candies, nextValue + 1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796528,
                "title": "c-simple-explained-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people, 0); // start with zero candies for each person\\n        int i=0;\\n        while (candies > 0) // while there are more candies to distribute\\n        {\\n            res[i%num_people]+=i+1;\\n            candies-=i+1;\\n            i++;\\n        }\\n        if (candies < 0) // if the last person got more than the candies we had left\\n            res[(i-1)%num_people] -= abs(candies);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people, 0); // start with zero candies for each person\\n        int i=0;\\n        while (candies > 0) // while there are more candies to distribute\\n        {\\n            res[i%num_people]+=i+1;\\n            candies-=i+1;\\n            i++;\\n        }\\n        if (candies < 0) // if the last person got more than the candies we had left\\n            res[(i-1)%num_people] -= abs(candies);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323418,
                "title": "python-math-solution-explained-o-n",
                "content": "First check how many complete rounds\\nthen distribute the rest greedy.\\n```\\nclass Solution:\\n    def distributeCandies(self, c: int, n: int) -> List[int]:\\n        k = math.floor((math.sqrt(1+8*c)-1)/2/n)\\n        res = [0 for i in range(n)]\\n        for i in range(n):\\n            res[i] = (i+1+(k-1)*(n)+i+1)*k/2\\n        remain = c - sum(res)\\n        i = 0\\n        cur = k*n+1\\n        while remain >= 0:\\n            res[i] += min(remain,cur)\\n            remain -= cur\\n            \\n            cur += 1\\n            i += 1\\n        return [int(i) for i in res]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, c: int, n: int) -> List[int]:\\n        k = math.floor((math.sqrt(1+8*c)-1)/2/n)\\n        res = [0 for i in range(n)]\\n        for i in range(n):\\n            res[i] = (i+1+(k-1)*(n)+i+1)*k/2\\n        remain = c - sum(res)\\n        i = 0\\n        cur = k*n+1\\n        while remain >= 0:\\n            res[i] += min(remain,cur)\\n            remain -= cur\\n            \\n            cur += 1\\n            i += 1\\n        return [int(i) for i in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361640,
                "title": "java-o-num-people-beats-100-with-detailed-math-explanation",
                "content": "This solution is based on the hint provided in the question. *Give candy to everyone each \"turn\" first [until you can\\'t], then give candy to one person per turn.*\\n\\nFirst, we get the number of turns in which we can distribute candies on every one. For example if we have 21 candies and 3 people. We have 2 turns. In the first turn we give 1, 2, 3 and in the 2nd we give 4, 5, 6. The candies distributed per turn are as follows:\\n\\n1st turn  => 1, 2, 3, ...., n \\n\\n\\t=> 0 * n + 1 + 0 * n + 2 + 0 * n + 3, ..., 0 * n + n\\n\\t\\n2nd turn => n + 1, n + 2, n + 3, ... , n + n \\n\\n\\t=>  1 * n + 1 + 1 * n + 2 + 1 * n + 3, ..., 1 * n + n\\n\\t\\n3rd turn => 2n + 1, 2n + 2, 2n + 3, ...., 2n + n \\n\\n\\t=> 2 * n + 1 + 2 * n + 2 + 2 * n + 3, ..., 2 * n + n\\n\\t\\nkth turn \\n\\n\\t=> (k - 1) * n + 1 + (k - 1) * n + 2 + (k - 1) * n + 3, ..., (k - 1) * n + n\\n\\t\\nThe total number of candies per turn for all people can be described by \\n\\t\\n\\tn * (k - 1) * n + summation of sequence 1, 2, 3, .., n. \\n\\t=> n * (k - 1) * n + (n (n + 1)) / 2.\\n\\nGet the total number of turns by subtracting the total turn candies from the total number of candies.\\n\\n```\\nint turns = 0; // starting at turn 0 instead of doing k - 1\\nint n = num_people;\\nint closedSum = (n * (n + 1)) / 2;\\nint totalTurnSum = closedSum;\\n\\n// Getting total number of possible FULL turns\\nwhile (candies - totalTurnSum >= 0) {\\n\\tcandies -= totalTurnSum;\\n\\t// Setting totalTurnSum for next turn\\n\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n}\\n```\\n\\nThe total number of candies for the ith person for all \"full\" turns can be described by summation of the sequence (k - 1) * n + (k - 1) * (i + 1) (Because the first person (i = 0) starts with 1) over k, where k is the number of turns. \\n\\n\\tsummation of  [ (k - 1) * n + (i + 1) ]  over k from 1 to turns\\n\\t= summation of (k - 1) * n + summation of (i + 1)\\n\\t= n * summation of (k - 1) + (i + 1) summation of 1\\n\\t= n * ((turns - 1) * turns) / 2 +  (i + 1) * turns\\n\\n```\\n// if we have at least 1 full turn\\nif (turns > 0) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tres[i] = n * (turns * (turns - 1)) / 2 + (i + 1) * turns;\\n\\t}\\n}\\n```\\n\\nFor the last incomplete turn we simply distribute the remaining coins. (Similar to this approach by rock https://leetcode.com/problems/distribute-candies-to-people/discuss/323314/JavaPython3-Easy-code-w-explanation-and-analysis.)\\n\\n```\\n// distributing the last incomplete turn\\nint offset = turns * n + 1;\\nfor (int i = 0; i < n && candies > 0; i++) {\\n\\tres[i] += Math.min(candies, offset);\\n\\tcandies -= offset++;\\n}\\n```\\n\\nThis might be an overkill for an easy question. Code modifications, tips and tricks are most welcome! :)\\n\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        if (candies == 0 || num_people == 0) return new int[num_people];\\n        int[] res = new int[num_people];\\n        int turns = 0;  // starting at turn 0 instead of doing k - 1\\n\\t\\tint n = num_people;\\n\\t\\tint closedSum = (n * (n + 1)) / 2;\\n\\t\\tint totalTurnSum = closedSum;\\n\\t\\t// Getting total number of possible FULL turns\\n\\t\\twhile (candies - totalTurnSum >= 0) {\\n\\t\\t\\tcandies -= totalTurnSum;\\n\\t\\t\\t// Setting totalTurnSum for next turn\\n\\t\\t\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n\\t\\t}\\n        // if we have at least 1 full turn\\n        if (turns > 0) {\\n            for (int i = 0; i < n; i++) {\\n                res[i] = n * (turns * (turns - 1)) / 2 +  (i + 1) * turns;\\n            }\\n        }\\n        // distributing the last incomplete turn\\n        int offset = turns * n + 1;\\n        for (int i = 0; i < n && candies > 0; i++) {\\n            res[i] += Math.min(candies, offset);\\n            candies -= offset++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nint turns = 0; // starting at turn 0 instead of doing k - 1\\nint n = num_people;\\nint closedSum = (n * (n + 1)) / 2;\\nint totalTurnSum = closedSum;\\n\\n// Getting total number of possible FULL turns\\nwhile (candies - totalTurnSum >= 0) {\\n\\tcandies -= totalTurnSum;\\n\\t// Setting totalTurnSum for next turn\\n\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n}\\n```\n```\\n// if we have at least 1 full turn\\nif (turns > 0) {\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tres[i] = n * (turns * (turns - 1)) / 2 + (i + 1) * turns;\\n\\t}\\n}\\n```\n```\\n// distributing the last incomplete turn\\nint offset = turns * n + 1;\\nfor (int i = 0; i < n && candies > 0; i++) {\\n\\tres[i] += Math.min(candies, offset);\\n\\tcandies -= offset++;\\n}\\n```\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        if (candies == 0 || num_people == 0) return new int[num_people];\\n        int[] res = new int[num_people];\\n        int turns = 0;  // starting at turn 0 instead of doing k - 1\\n\\t\\tint n = num_people;\\n\\t\\tint closedSum = (n * (n + 1)) / 2;\\n\\t\\tint totalTurnSum = closedSum;\\n\\t\\t// Getting total number of possible FULL turns\\n\\t\\twhile (candies - totalTurnSum >= 0) {\\n\\t\\t\\tcandies -= totalTurnSum;\\n\\t\\t\\t// Setting totalTurnSum for next turn\\n\\t\\t\\ttotalTurnSum = n * (++turns) * n + closedSum;\\n\\t\\t}\\n        // if we have at least 1 full turn\\n        if (turns > 0) {\\n            for (int i = 0; i < n; i++) {\\n                res[i] = n * (turns * (turns - 1)) / 2 +  (i + 1) * turns;\\n            }\\n        }\\n        // distributing the last incomplete turn\\n        int offset = turns * n + 1;\\n        for (int i = 0; i < n && candies > 0; i++) {\\n            res[i] += Math.min(candies, offset);\\n            candies -= offset++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369518,
                "title": "python3-very-easy-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n\\t\\t\\tresult=[0]*num_people\\n\\t\\t\\tcurrentCandies=1\\n\\t\\t\\ti=0\\n\\t\\t\\twhile candies>0:\\n\\t\\t\\t\\tresult[i%num_people]+=min(candies,currentCandies)\\n\\t\\t\\t\\tcandies-=currentCandies\\n\\t\\t\\t\\tcurrentCandies+=1\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn result",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n\\t\\t\\tresult=[0]*num_people\\n\\t\\t\\tcurrentCandies=1\\n\\t\\t\\ti=0\\n\\t\\t\\twhile candies>0:\\n\\t\\t\\t\\tresult[i%num_people]+=min(candies,currentCandies)\\n\\t\\t\\t\\tcandies-=currentCandies\\n\\t\\t\\t\\tcurrentCandies+=1\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 464830,
                "title": "python-simplest-and-easiest-understand-way",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]* num_people\\n        cnt = 1\\n        \\n        while candies > 0:\\n\\n            for i in range(len(ans)):\\n\\n                if candies >= cnt:\\n                    ans[i] += cnt\\n                    candies -= cnt\\n                else:\\n                    ans[i] += candies\\n                    candies = 0\\n                cnt += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]* num_people\\n        cnt = 1\\n        \\n        while candies > 0:\\n\\n            for i in range(len(ans)):\\n\\n                if candies >= cnt:\\n                    ans[i] += cnt\\n                    candies -= cnt\\n                else:\\n                    ans[i] += candies\\n                    candies = 0\\n                cnt += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3405818,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis=[0]*num_people\\n        i=1\\n        j=0\\n        while(candies):\\n            if(candies<i):\\n                lis[j%num_people]+=candies\\n                break\\n            if(candies>=i):\\n                lis[j%num_people]+=i\\n                candies-=i\\n                j+=1\\n                i+=1\\n            \\n        return(lis)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis=[0]*num_people\\n        i=1\\n        j=0\\n        while(candies):\\n            if(candies<i):\\n                lis[j%num_people]+=candies\\n                break\\n            if(candies>=i):\\n                lis[j%num_people]+=i\\n                candies-=i\\n                j+=1\\n                i+=1\\n            \\n        return(lis)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739916,
                "title": "simple-beginner-friendly-approach-java",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n       int[] ans = new int[num_people];\\n        int count = 1;\\n        int i = 0;\\n        while(candies>0){\\n            if(candies<count)\\n                ans[i]=ans[i]+candies;\\n            else\\n                ans[i]=ans[i]+count;\\n            i++;\\n            candies-=count;\\n            count++;\\n            if(i==ans.length)\\n                i=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n       int[] ans = new int[num_people];\\n        int count = 1;\\n        int i = 0;\\n        while(candies>0){\\n            if(candies<count)\\n                ans[i]=ans[i]+candies;\\n            else\\n                ans[i]=ans[i]+count;\\n            i++;\\n            candies-=count;\\n            count++;\\n            if(i==ans.length)\\n                i=0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424125,
                "title": "c-easy-to-understand-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int> ans(num_people);\\n        int loops=0,i=0,curr_candies;\\n       while(candies>0)\\n       {\\n           if(i==num_people)\\n           {\\n              loops++;\\n              i=0;\\n           }  \\n           curr_candies=loops*num_people+i+1;\\n           if(candies-curr_candies<0)\\n           {\\n              ans[i]+=candies;\\n           }\\n           else\\n           ans[i]+=curr_candies;\\n           candies-=curr_candies;\\n           i++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int> ans(num_people);\\n        int loops=0,i=0,curr_candies;\\n       while(candies>0)\\n       {\\n           if(i==num_people)\\n           {\\n              loops++;\\n              i=0;\\n           }  \\n           curr_candies=loops*num_people+i+1;\\n           if(candies-curr_candies<0)\\n           {\\n              ans[i]+=candies;\\n           }\\n           else\\n           ans[i]+=curr_candies;\\n           candies-=curr_candies;\\n           i++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402807,
                "title": "java-solution",
                "content": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[]ans=new int[n];\\n        int i=0;\\n        while(candies>0){\\n            ans[i%n]+=Math.min(i+1,candies);    \\n\\t\\t\\t//doing i%n so that we can some back  again and give candies if there are any\\n            candies-=i+1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[]ans=new int[n];\\n        int i=0;\\n        while(candies>0){\\n            ans[i%n]+=Math.min(i+1,candies);    \\n\\t\\t\\t//doing i%n so that we can some back  again and give candies if there are any\\n            candies-=i+1;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1088053,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        index = 0\\n        while candies > 0:\\n            res[index % num_people] += min(index + 1, candies)\\n            index += 1\\n            candies -= index\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        index = 0\\n        while candies > 0:\\n            res[index % num_people] += min(index + 1, candies)\\n            index += 1\\n            candies -= index\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 797800,
                "title": "java-solution-beats-100-time",
                "content": "Given candies = 40 , num_people = 3.\\n\\nThe distrbution is like the following:\\n```\\n\\t\\t\\tpeople_0  people_1  people_2  \\nrow_0           1         2         3\\nrow_1           4         5         6\\nrow_2           7         8         (4)\\n```\\n\\nThe total number of candies ditrubuted to each people are:\\npeople_0: 1 + 4 + 7\\npeople_1: 2 + 5 + 8\\npeople_2: 3 + 6 + (4)\\n\\nIts indicated that the number of candies each person receives follows arithmetic sequence where the common difference is the 3 (num_people)\\n\\nSo the goals of the problem are to:\\n```\\n1) Find the last number of the distrubition without running out of candies. which is to find 8 in above case.\\n2) Calculate the total number of candies for each people. \\n3) Find the index of the last people who are given the remaining candies after 1), which is 8 % 3 = 2.\\n4) Calcute the number of remaining candies after 1), which is (4) in above case.  (40 - (1+2 ... +8) = 4)\\n```\\n\\nTo calucate 1) \\nWe have to find the max positive integer of N which satifies \\n(1 + N) * N / 2 <= candies   \\n--> \\nN2 + N - 2 * candies <= 0\\n\\nSo N = floor( ![image](https://assets.leetcode.com/users/images/cfcf8b6b-64d2-41b1-9078-adee03d4332f_1597709353.2275171.png)) \\n=  floor(![image](https://assets.leetcode.com/users/images/c6cdb2ef-df45-44f1-97a7-b06f89689cf5_1597709442.058968.png) )\\n=  floor(![image](https://assets.leetcode.com/users/images/b106ad98-d715-4e88-b08b-0d65eec92872_1597709484.9748318.png))\\n\\nTo calcaute 2)\\n```\\ntotal(people_i) = (first_time_candies_given + last_time_candies_given) * times_candies_given / 2;\\n\\n                = (i+1) + ((i+1) + (highest_row-1) * num_people)) * highest_row / 2;\\n\\nFor e.g. \\ntotal(people_0) = ((0+1) + (0+1) + (3-1) * 3)) * 3 /2\\n                = (1 + (1 + 2 * 3)) * 3 / 2 = 12\\n\\ntotal(people_2) = ((2+1) + (2+1) + (2-1) * 3)) * 3 /2\\n                = (3 + (3 + 1 * 3)) * 2 / 2 = 9\\n```\\nTo calcaulte 4) \\n```\\nrenaming_candies = candies - (1 + N) * N /2\\n```\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        \\n        int N = (int) Math.floor(((Math.sqrt(1 + 8 * (long) candies) - 1) / 2));\\n        int[] ans = new int[num_people];\\n        int row = N / num_people;\\n\\t\\t\\n        for(int i = 0; i < N && i < num_people; i++) {\\n            if(i < N % num_people) {\\n                ans[i] = (2 * (i+1) + row * num_people) * (row + 1) / 2;\\n            }\\n            else {\\n                ans[i] = (2 * (i+1) + (row - 1) * num_people) * row / 2;\\n            }\\n        }\\n        \\n\\t\\t// add remaning candies to his total\\n        ans[N % num_people] += candies - N * (N + 1) /2;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTime:O(n)     n->num_people\\nExtra space:O(1)",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\tpeople_0  people_1  people_2  \\nrow_0           1         2         3\\nrow_1           4         5         6\\nrow_2           7         8         (4)\\n```\n```\\n1) Find the last number of the distrubition without running out of candies. which is to find 8 in above case.\\n2) Calculate the total number of candies for each people. \\n3) Find the index of the last people who are given the remaining candies after 1), which is 8 % 3 = 2.\\n4) Calcute the number of remaining candies after 1), which is (4) in above case.  (40 - (1+2 ... +8) = 4)\\n```\n```\\ntotal(people_i) = (first_time_candies_given + last_time_candies_given) * times_candies_given / 2;\\n\\n                = (i+1) + ((i+1) + (highest_row-1) * num_people)) * highest_row / 2;\\n\\nFor e.g. \\ntotal(people_0) = ((0+1) + (0+1) + (3-1) * 3)) * 3 /2\\n                = (1 + (1 + 2 * 3)) * 3 / 2 = 12\\n\\ntotal(people_2) = ((2+1) + (2+1) + (2-1) * 3)) * 3 /2\\n                = (3 + (3 + 1 * 3)) * 2 / 2 = 9\\n```\n```\\nrenaming_candies = candies - (1 + N) * N /2\\n```\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        \\n        int N = (int) Math.floor(((Math.sqrt(1 + 8 * (long) candies) - 1) / 2));\\n        int[] ans = new int[num_people];\\n        int row = N / num_people;\\n\\t\\t\\n        for(int i = 0; i < N && i < num_people; i++) {\\n            if(i < N % num_people) {\\n                ans[i] = (2 * (i+1) + row * num_people) * (row + 1) / 2;\\n            }\\n            else {\\n                ans[i] = (2 * (i+1) + (row - 1) * num_people) * row / 2;\\n            }\\n        }\\n        \\n\\t\\t// add remaning candies to his total\\n        ans[N % num_people] += candies - N * (N + 1) /2;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797248,
                "title": "python-easy-o-sqrt-candies-solution",
                "content": "The idea of my solution is super straightforward. We basically follow the task: we would add 1 to the first cell, 2 to the second, and so on. If we reach the end of the loop we subtracts the list length (=*num_people*) from the iteration counter and keep doing so. How long do we do it? As long as we have more candies than we have to add. So once *i* surpasses *candies* we exit the loop. After that we just have to add the remaining candies to the next cell and that would be it. \\n\\n```\\n        res = [0] * num_people\\n        i, j = 0, 0\\n        i = 0\\n        while candies > i:\\n            res[j] += i + 1\\n            j += 1\\n            i += 1\\n            candies -= i\\n            if j == num_people - 1: j -= num_people\\n        res[j] += candies\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n        res = [0] * num_people\\n        i, j = 0, 0\\n        i = 0\\n        while candies > i:\\n            res[j] += i + 1\\n            j += 1\\n            i += 1\\n            candies -= i\\n            if j == num_people - 1: j -= num_people\\n        res[j] += candies\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796986,
                "title": "javascript-easy-solution",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let finalDistribution = new Array(num_people).fill(0) // [0,0,0,0] //candies=7\\n    let candy =1;\\n    let i = 0;\\n    while(candy < candies){\\n        if(i===num_people) i=0\\n        finalDistribution[i] = finalDistribution[i]+candy;\\n        candies = candies - candy;\\n        candy++;\\n        i++;\\n    }\\n    if(candies > 0){\\n        if(i===num_people) i=0;\\n        finalDistribution[i] = finalDistribution[i] + candies;\\n    }\\n    return finalDistribution\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let finalDistribution = new Array(num_people).fill(0) // [0,0,0,0] //candies=7\\n    let candy =1;\\n    let i = 0;\\n    while(candy < candies){\\n        if(i===num_people) i=0\\n        finalDistribution[i] = finalDistribution[i]+candy;\\n        candies = candies - candy;\\n        candy++;\\n        i++;\\n    }\\n    if(candies > 0){\\n        if(i===num_people) i=0;\\n        finalDistribution[i] = finalDistribution[i] + candies;\\n    }\\n    return finalDistribution\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3773227,
                "title": "faster-than-100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801400,
                "title": "js-o-n-beats-95-easy-to-read",
                "content": "# Intuition\\nIterate over the total amount of candies.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function (c, n) {\\n  let j = 0;\\n  let left = c;\\n  const arr = [];\\n  for (let i = 0; i < n; i++) {\\n    arr[i] = 0;\\n  }\\n  for (let i = 1; i < c + 1; i++) {\\n    if (i > left) {\\n      arr[j] += left;\\n      break;\\n    }\\n    arr[j] += i;\\n    j++;\\n    if (j === n) {\\n      j = 0;\\n    }\\n    left -= i;\\n  }\\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function (c, n) {\\n  let j = 0;\\n  let left = c;\\n  const arr = [];\\n  for (let i = 0; i < n; i++) {\\n    arr[i] = 0;\\n  }\\n  for (let i = 1; i < c + 1; i++) {\\n    if (i > left) {\\n      arr[j] += left;\\n      break;\\n    }\\n    arr[j] += i;\\n    j++;\\n    if (j === n) {\\n      j = 0;\\n    }\\n    left -= i;\\n  }\\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652771,
                "title": "c-super-easy-faster-than-100",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> distributeCandies(int candies, int len) {\\n        int i=0;\\n        int a=1;\\n        vector<int>ans(len,0);\\n       while(1){  \\n           if(candies<a){\\n               ans[i]+=candies;\\n               break;\\n           } \\n           ans[i]+=a;\\n           candies-=a;\\n           i=(i+1)%len;\\n           a++;\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> distributeCandies(int candies, int len) {\\n        int i=0;\\n        int a=1;\\n        vector<int>ans(len,0);\\n       while(1){  \\n           if(candies<a){\\n               ans[i]+=candies;\\n               break;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2641832,
                "title": "js-very-easy-solution",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    const output = new Array(num_people).fill(0);\\n    let cursor = 0;\\n    let count = 1;\\n    \\n    while (candies > 0) {\\n        output[cursor] += (count <= candies ? count : candies);\\n        candies -= count;\\n        count++;\\n        cursor++;\\n        if (cursor === num_people) {\\n            cursor = 0;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    const output = new Array(num_people).fill(0);\\n    let cursor = 0;\\n    let count = 1;\\n    \\n    while (candies > 0) {\\n        output[cursor] += (count <= candies ? count : candies);\\n        candies -= count;\\n        count++;\\n        cursor++;\\n        if (cursor === num_people) {\\n            cursor = 0;\\n        }\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2501941,
                "title": "java-easy-code",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int ans[]=new int[num_people];\\n        int ix=0, gift=1;\\n        while(candies>0){\\n            ix=ix%num_people;\\n            if(gift<=candies){\\n                ans[ix]+=gift;\\n            }else{\\n                ans[ix]+=candies;\\n            }\\n            candies-=gift;\\n            ix++;\\n            gift++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int ans[]=new int[num_people];\\n        int ix=0, gift=1;\\n        while(candies>0){\\n            ix=ix%num_people;\\n            if(gift<=candies){\\n                ans[ix]+=gift;\\n            }else{\\n                ans[ix]+=candies;\\n            }\\n            candies-=gift;\\n            ix++;\\n            gift++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440921,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int n) {\\n\\n\\t\\t\\tvector<int> ans(n, 0);\\n\\n\\t\\t\\tint i = 0, x = 1;\\n\\t\\t\\twhile(candies != 0){\\n\\n\\t\\t\\t\\tif(candies < x){\\n\\t\\t\\t\\t\\tans[i % n] += candies;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans[i % n] += x;\\n\\t\\t\\t\\tcandies -= x;\\n\\n\\t\\t\\t\\tx++;\\n\\t\\t\\t\\ti++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int n) {\\n\\n\\t\\t\\tvector<int> ans(n, 0);\\n\\n\\t\\t\\tint i = 0, x = 1;\\n\\t\\t\\twhile(candies != 0){\\n\\n\\t\\t\\t\\tif(candies < x){\\n\\t\\t\\t\\t\\tans[i % n] += candies;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 985041,
                "title": "python-3-solution-28-36ms",
                "content": "The idea is that:\\n\\nthe candies are distributed as `1,2,3,4,...,n, candies-(n+1)*n/2`, thus we just need to find `n`. Then the problem is easy to deal with.\\n\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        #\\n        res = [0]*num_people\\n        n = int(-1/2+sqrt(4*2*candies+1)/2)  # find n by Vieta\\'s formulas\\n        turns = n//num_people\\n        flattern = list(range(1,n+1))+[candies-n*(n+1)//2]\\n        flattern += (-len(flattern)+(turns+1)*num_people)*[0]\\n        for i in range(turns+1):\\n            res = [m+n for m,n in zip(res,flattern[i*num_people:(i+1)*num_people])]\\n        return res\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        #\\n        res = [0]*num_people\\n        n = int(-1/2+sqrt(4*2*candies+1)/2)  # find n by Vieta\\'s formulas\\n        turns = n//num_people\\n        flattern = list(range(1,n+1))+[candies-n*(n+1)//2]\\n        flattern += (-len(flattern)+(turns+1)*num_people)*[0]\\n        for i in range(turns+1):\\n            res = [m+n for m,n in zip(res,flattern[i*num_people:(i+1)*num_people])]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797425,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        results=[0]*num_people \\n        give=0\\n        totalCandiesGiven=0\\n        left=candies-totalCandiesGiven\\n        \\n        while totalCandiesGiven<candies: \\n\\n            for i in range(len(results)): \\n                \\n                left=candies-totalCandiesGiven    \\n                give+=1\\n                \\n                results[i]= results[i]+give if left>=give else results[i]+left\\n                \\n\\n                totalCandiesGiven+=give\\n                \\n                if totalCandiesGiven>=candies:\\n                    break\\n                \\n                \\n        return results        \\n\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        results=[0]*num_people \\n        give=0\\n        totalCandiesGiven=0\\n        left=candies-totalCandiesGiven\\n        \\n        while totalCandiesGiven<candies: \\n\\n            for i in range(len(results)): \\n                \\n                left=candies-totalCandiesGiven    \\n                give+=1\\n                \\n                results[i]= results[i]+give if left>=give else results[i]+left\\n                \\n\\n                totalCandiesGiven+=give\\n                \\n                if totalCandiesGiven>=candies:\\n                    break\\n                \\n                \\n        return results        \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 796845,
                "title": "distribute-candies-java-o-candies",
                "content": "```\\nclass Solution {\\n\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        int i = 0,j = 1;\\n        while( candies > 0 ){\\n            res[i%n] += j<candies?j:candies;\\n            candies -= j;\\n            j++; i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int[] distributeCandies(int candies, int n) {\\n        int[] res = new int[n];\\n        int i = 0,j = 1;\\n        while( candies > 0 ){\\n            res[i%n] += j<candies?j:candies;\\n            candies -= j;\\n            j++; i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796821,
                "title": "beating-100-simple-c-solution-p",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        int i=1;\\n        while(candies -i>0 && ans.size()<num_people){\\n            ans.push_back(i);\\n            candies-=i;\\n            i++;\\n        }\\n        while(ans.size()<num_people){\\n            ans.push_back(candies);\\n            candies=0;\\n        }\\n        if(candies==0) return ans;\\n        int j=num_people+1;\\n        int k=0;\\n        while(candies>0){\\n            k=k% num_people;\\n            if(candies>j){\\n                ans[k]+=j;\\n                candies-=j;\\n            }\\n            else{\\n                ans[k]+=candies;\\n                break;\\n            }\\n            k++;\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        int i=1;\\n        while(candies -i>0 && ans.size()<num_people){\\n            ans.push_back(i);\\n            candies-=i;\\n            i++;\\n        }\\n        while(ans.size()<num_people){\\n            ans.push_back(candies);\\n            candies=0;\\n        }\\n        if(candies==0) return ans;\\n        int j=num_people+1;\\n        int k=0;\\n        while(candies>0){\\n            k=k% num_people;\\n            if(candies>j){\\n                ans[k]+=j;\\n                candies-=j;\\n            }\\n            else{\\n                ans[k]+=candies;\\n                break;\\n            }\\n            k++;\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796777,
                "title": "typescript-solutions",
                "content": "// Runtime: 76 ms, faster than 48.28% of JavaScript online submissions for Distribute Candies to People.\\n// Memory Usage: 36.6 MB, less than 34.48% of JavaScript online submissions for Distribute Candies to People.\\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const res: number[] = new Array(num_people).fill(0);\\n  let i = 1;\\n  while (candies > 0) {\\n    res[(i - 1) % num_people] += Math.min(i, candies);\\n    candies -= i;\\n    i++;\\n  }\\n  return res;\\n}\\n```\\n\\n// Generating an array with the distributions\\n// Runtime: 72 ms, faster than 68.10% of JavaScript online submissions for Distribute Candies to People.\\n// Memory Usage: 38.1 MB, less than 5.17% of JavaScript online submissions for Distribute Candies to People.\\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const distributions: number[] = [];\\n  let x = 1;\\n  while (candies > 0) {\\n    if (candies >= x) {\\n      candies -= x;\\n      distributions.push(x);\\n    } else {\\n      distributions.push(candies);\\n      candies = 0;\\n    }\\n    x++;\\n  }\\n\\n  const res = new Array(num_people).fill(0);\\n\\n  for (let i = 0; i < num_people; i++) {\\n    for (let j = i; j < distributions.length; j += num_people) {\\n      res[i] += distributions[j];\\n    }\\n  }\\n\\n  return res;\\n}\\n```\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const res: number[] = new Array(num_people).fill(0);\\n  let i = 1;\\n  while (candies > 0) {\\n    res[(i - 1) % num_people] += Math.min(i, candies);\\n    candies -= i;\\n    i++;\\n  }\\n  return res;\\n}\\n```\n```\\nfunction distributeCandies(candies: number, num_people: number): number[] {\\n  const distributions: number[] = [];\\n  let x = 1;\\n  while (candies > 0) {\\n    if (candies >= x) {\\n      candies -= x;\\n      distributions.push(x);\\n    } else {\\n      distributions.push(candies);\\n      candies = 0;\\n    }\\n    x++;\\n  }\\n\\n  const res = new Array(num_people).fill(0);\\n\\n  for (let i = 0; i < num_people; i++) {\\n    for (let j = i; j < distributions.length; j += num_people) {\\n      res[i] += distributions[j];\\n    }\\n  }\\n\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796562,
                "title": "java-think-like-a-human-easy-to-understand-with-explanation-pseudocode",
                "content": "## Analysis\\nThe basic idea is, every time, the number of candies we should distribute is incremented by 1. If we have enough candies, just give him the number he deserved. However, when we give him all we left. \\n\\nIt\\'s simply the same as what we human  deal with this prob.\\n## Explanation\\n- When we have adequate candies to distribute (in the while-loop)\\n\\t- Distribute normally\\n\\t\\t- `thisPpl` gets `thisPplGet` candies\\n\\t\\t- Find out how many candies were distributed in total\\n\\t\\t- Next people = `nextPpl()`\\n\\t\\t- Increment `thisPplGet` by 1\\n- If we don\\'t have enough candies fot `thisPpl`\\n\\t- Give him all we left, aka `candies - curDistributedTotal` candies\\n\\n```Java\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int curDistributedTotal = 0;\\n        int thisPplGet = 1;\\n        int thisPpl = 0;\\n        while(candies - curDistributedTotal >= thisPplGet) {\\n            res[thisPpl] += thisPplGet;\\n            curDistributedTotal += thisPplGet;\\n            thisPpl = nextPpl(num_people, thisPpl);\\n            thisPplGet += 1;\\n        }\\n        res[thisPpl] += candies - curDistributedTotal;\\n        return res;\\n    }\\n    \\n    private static int nextPpl(int num_people, int thisPpl) {\\n        if (thisPpl == num_people - 1) return 0;\\n        return thisPpl + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int curDistributedTotal = 0;\\n        int thisPplGet = 1;\\n        int thisPpl = 0;\\n        while(candies - curDistributedTotal >= thisPplGet) {\\n            res[thisPpl] += thisPplGet;\\n            curDistributedTotal += thisPplGet;\\n            thisPpl = nextPpl(num_people, thisPpl);\\n            thisPplGet += 1;\\n        }\\n        res[thisPpl] += candies - curDistributedTotal;\\n        return res;\\n    }\\n    \\n    private static int nextPpl(int num_people, int thisPpl) {\\n        if (thisPpl == num_people - 1) return 0;\\n        return thisPpl + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796485,
                "title": "c-simple-clear-solution-100-faster-with-explanations",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) \\n    {\\n        vector<int> candiesDistributed(num_people, 0);\\n        int i = 0;\\n        \\n        //while there are still candies to give out\\n        while (candies > 0) \\n        {\\n            //give every person according to his turn (incremented by one every turn)\\n            candiesDistributed[i % num_people] += i + 1;\\n            //update number of candies left\\n            candies -= i + 1;\\n            i++;\\n        }\\n        \\n        //incase we gave an extra candy to last person (so if there are less than 0 candies left we decrement last person\\'s candies otherwise candies = 0 so nothing changes)\\n        candiesDistributed[(i - 1) % num_people] += candies;\\n        \\n        \\n        return candiesDistributed;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) \\n    {\\n        vector<int> candiesDistributed(num_people, 0);\\n        int i = 0;\\n        \\n        //while there are still candies to give out\\n        while (candies > 0) \\n        {\\n            //give every person according to his turn (incremented by one every turn)\\n            candiesDistributed[i % num_people] += i + 1;\\n            //update number of candies left\\n            candies -= i + 1;\\n            i++;\\n        }\\n        \\n        //incase we gave an extra candy to last person (so if there are less than 0 candies left we decrement last person\\'s candies otherwise candies = 0 so nothing changes)\\n        candiesDistributed[(i - 1) % num_people] += candies;\\n        \\n        \\n        return candiesDistributed;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796407,
                "title": "java-1ms-exactly-as-defined-in-problem-statement",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int count = candies;\\n        int[] result = new int[num_people];\\n        int index = 0;\\n        int i = 1;\\n        while(count != 0){\\n            if(i > count){\\n                result[index] += count;\\n                count = 0;\\n            } else{\\n                result[index] += i;\\n                count -= i;\\n            }\\n            \\n            ++i;\\n            index = (index + 1) % num_people;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int count = candies;\\n        int[] result = new int[num_people];\\n        int index = 0;\\n        int i = 1;\\n        while(count != 0){\\n            if(i > count){\\n                result[index] += count;\\n                count = 0;\\n            } else{\\n                result[index] += i;\\n                count -= i;\\n            }\\n            \\n            ++i;\\n            index = (index + 1) % num_people;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752712,
                "title": "c-100-fast",
                "content": "```\\n vector<int> v(num_people,0);\\n        int i=0;\\n        \\n        while(candies  > 0){\\n            \\n            v[i%num_people] += min(candies , i+1);\\n            candies -= i+1;\\n                \\n            i++;\\n        }\\n        \\n        return v;\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n vector<int> v(num_people,0);\\n        int i=0;\\n        \\n        while(candies  > 0){\\n            \\n            v[i%num_people] += min(candies , i+1);\\n            candies -= i+1;\\n                \\n            i++;\\n        }\\n        \\n        return v;\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 749184,
                "title": "java-0ms-beats-100-math-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int sum = (num_people + 1) * num_people / 2;\\n        int k = -1;\\n        int consume = 0;\\n        while (consume < candies) {\\n            k += 1;\\n            consume += k * num_people * num_people + sum;\\n        }\\n        k -= 1;\\n        int[] res = new int[num_people];\\n        int total_candies = candies;\\n        for (int i=1; i<=num_people; i++) {\\n            res[i-1] = (k + 1) * i + k * (k + 1) * num_people / 2;\\n            total_candies -= res[i-1];\\n        }\\n        int idx = 0;\\n        while (total_candies > 0) {\\n            int got = Math.min((k + 1) * num_people + idx + 1, total_candies);\\n            res[idx] += got;\\n            total_candies -= got;\\n            idx ++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nExplanation here:\\nSuppose we can write down the distribution in every round (number n people from 1 to n):\\n```\\n(P for person)\\nP1         P2        P3  ...  Pn\\n-----------------------------------\\n  1         2         3  ...   n\\nn+1       n+2       n+3      n+n\\n2n+1     2n+2      2n+3     2n+n\\n...\\nkn+1     kn+2      kn+3     kn+n\\n(k+1)n +1 ...  (k+1)n +j\\n```\\nHere `k` is the second last round, and we end in `k+1`th round at position `j` (j <= n).\\nSo How many candies does the 1st position get?\\nIt\\'s :\\n```\\nin previous round 0~k\\n(1) + (n + 1) + (2n+1) + ... (kn+1) \\n= (1 + n + 1 + 2n+1 + ... kn+1) \\n= k*(k+1)/2 *n + n * 1\\n\\ndon\\'t forget the last round, it\\'s:\\n(k+1)n +1\\n``` \\nFor other positions you can get similar results. And also you can calculate how many candies you need in each round, it\\'s:\\n```\\n(kn+1) + (kn+2) + ... (kn+n)\\n= k*n*n + (1 + 2 + .. n)\\n= k*n*n+n*(n+1)/2\\n```\\nfor round `k`.\\n\\nThen you can find `k`.\\nSo basically that\\'s all, I found `k` in my code at beginning. After that, I first add all round `0~k` in one loop and add the last round finally.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int sum = (num_people + 1) * num_people / 2;\\n        int k = -1;\\n        int consume = 0;\\n        while (consume < candies) {\\n            k += 1;\\n            consume += k * num_people * num_people + sum;\\n        }\\n        k -= 1;\\n        int[] res = new int[num_people];\\n        int total_candies = candies;\\n        for (int i=1; i<=num_people; i++) {\\n            res[i-1] = (k + 1) * i + k * (k + 1) * num_people / 2;\\n            total_candies -= res[i-1];\\n        }\\n        int idx = 0;\\n        while (total_candies > 0) {\\n            int got = Math.min((k + 1) * num_people + idx + 1, total_candies);\\n            res[idx] += got;\\n            total_candies -= got;\\n            idx ++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\n(P for person)\\nP1         P2        P3  ...  Pn\\n-----------------------------------\\n  1         2         3  ...   n\\nn+1       n+2       n+3      n+n\\n2n+1     2n+2      2n+3     2n+n\\n...\\nkn+1     kn+2      kn+3     kn+n\\n(k+1)n +1 ...  (k+1)n +j\\n```\n```\\nin previous round 0~k\\n(1) + (n + 1) + (2n+1) + ... (kn+1) \\n= (1 + n + 1 + 2n+1 + ... kn+1) \\n= k*(k+1)/2 *n + n * 1\\n\\ndon\\'t forget the last round, it\\'s:\\n(k+1)n +1\\n```\n```\\n(kn+1) + (kn+2) + ... (kn+n)\\n= k*n*n + (1 + 2 + .. n)\\n= k*n*n+n*(n+1)/2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712708,
                "title": "java-clean-code-solution-1-ms-time-90-faster",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int[] distributeCandies (int candies, int num_people) {\\n \\n\\t\\tint[] ans = new int[num_people];\\n\\t\\t\\n\\t\\tfor (int i = 0, k = 0; candies != 0; i++) {\\n\\t\\t\\tif (k >= candies) {\\n\\t\\t\\t\\tans[i % num_people] += candies;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans[i % num_people] += ++k;\\n\\t\\t\\tcandies -= k;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n \\nTime Complexity: O(N) \\nwhere N = Number of Candies\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int[] distributeCandies (int candies, int num_people) {\\n \\n\\t\\tint[] ans = new int[num_people];\\n\\t\\t\\n\\t\\tfor (int i = 0, k = 0; candies != 0; i++) {\\n\\t\\t\\tif (k >= candies) {\\n\\t\\t\\t\\tans[i % num_people] += candies;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tans[i % num_people] += ++k;\\n\\t\\t\\tcandies -= k;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn ans;\\n\\t}\\n}\\n \\nTime Complexity: O(N) \\nwhere N = Number of Candies\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527087,
                "title": "java",
                "content": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        \\n        int turn = 1;\\n        int index = 0;\\n        while(candies != 0)\\n        {\\n            int candiesToGive = Math.min(candies,turn++);\\n            res[index++%num_people] += candiesToGive;\\n            candies -= candiesToGive;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        \\n        int turn = 1;\\n        int index = 0;\\n        while(candies != 0)\\n        {\\n            int candiesToGive = Math.min(candies,turn++);\\n            res[index++%num_people] += candiesToGive;\\n            candies -= candiesToGive;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 502605,
                "title": "javascript-solution-48ms",
                "content": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n  let arr = new Array(num_people).fill(0);\\n  let countCycle = 0;\\n\\n  for (let i = 0; candies > 0; i++) {\\n    if (i === arr.length) {\\n      i = 0;\\n      countCycle += arr.length;\\n    }\\n    \\n    if (candies < (i + 1) + countCycle) {\\n      arr[i] += candies;\\n      break;\\n    }\\n    \\n    arr[i] += i + 1 + countCycle;\\n    candies -= (i + 1 + countCycle);\\n  }\\n  \\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n  let arr = new Array(num_people).fill(0);\\n  let countCycle = 0;\\n\\n  for (let i = 0; candies > 0; i++) {\\n    if (i === arr.length) {\\n      i = 0;\\n      countCycle += arr.length;\\n    }\\n    \\n    if (candies < (i + 1) + countCycle) {\\n      arr[i] += candies;\\n      break;\\n    }\\n    \\n    arr[i] += i + 1 + countCycle;\\n    candies -= (i + 1 + countCycle);\\n  }\\n  \\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 439535,
                "title": "java-mathematical-solution-beats-100-time-and-100-space",
                "content": "The initial while loop in the code can be avoided by solving a quadratic equation which will give you the number of rows where all the n people can get candies.\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[] ans = new int[n];\\n        int i = 0;\\n        int sum = 0;\\n        \\n        while(true){\\n            int t = ((int)Math.pow(n, 2) * i) + (n * (n + 1))/2;\\n            if(sum + t > candies) break;\\n            sum += t;\\n            i++;\\n        }\\n        \\n        i--;\\n        \\n        for(int j = 0; j < n; j++){\\n            ans[j] = (i + 1) * (j + 1) + (i * n * (i + 1))/2; \\n        }\\n        \\n        i++;\\n        \\n        candies -= sum;\\n        int start = n * i + 1;\\n        int j = 0;\\n        while(candies >= start){\\n            ans[j] += start;\\n            candies -= start;\\n            start++;\\n            j++;\\n        }\\n        \\n        if(candies > 0) ans[j] += candies;\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int n) {\\n        \\n        int[] ans = new int[n];\\n        int i = 0;\\n        int sum = 0;\\n        \\n        while(true){\\n            int t = ((int)Math.pow(n, 2) * i) + (n * (n + 1))/2;\\n            if(sum + t > candies) break;\\n            sum += t;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 435169,
                "title": "java-0ms-100-solution-with-comments",
                "content": "Lets say we have x people, then distribution will look like:\\n1         2         3         4          ... x            total amount of candies is sum from 1 to x\\n1 + x   2 + x   3 + x   4 + x   ... x + x     \\n1 + 2x 2 + 2x 3 + 2x 4 + 2x ... x + 2x\\neach next round we are giving same amount of candies, from 1 to x, but + amount of candies we gave to last person in previous round, which is x for 1st round, which is equal to people amount. So we are giving addiotionally num_people candies num_people times comparing to previous round. It means we can cound how many candies we will distribute during full rounds!\\n\\n```class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] result = new int[num_people];\\n        int amount = num_people * (num_people + 1) / 2; // sum from 1 to num_people, amount of candies for 1st round\\n        int rounds = 0;\\n        //counting rounds and amount of candies which left after all full rounds\\n        while(candies >= amount) {\\n            rounds++;\\n            candies -= amount;\\n            amount += num_people * num_people; //increase amount of candies, required for next round\\n        }\\n        \\n        for(int i = 0; i < num_people; i++) {\\n\\t\\t\\t//counting amount of candies, distributed to i-th person during full rounds. Lets say we have 4 rounds for 4 people. \\n\\t\\t\\t//1st will get 1 + 5 + 9 + 13, 2nd 2 + 6 + 10 + 14 and so on.\\n\\t\\t\\t//So its sum of N (which is rounds amount) numbers, statring from person number (i + 1) with step = num_people\\n\\t\\t\\t//Formula is  (2 * 1st + step * (N - 1) ) * N / 2\\n            result[i] = (2 * i + 2 + num_people * (rounds - 1)) * rounds / 2; \\n\\t\\t\\t\\n\\t\\t\\t//if we have more candies - counting how many we need to give to current person and taking this amount from candies \\n\\t\\t\\t//or all candies if we have not enough left\\n            if(candies > 0) {\\n                int n = 1 + i + num_people * rounds;\\n                n = candies < n ? candies : n;\\n                result[i] += n;\\n                candies -= n;\\n            }\\n        }\\n        return result;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] result = new int[num_people];\\n        int amount = num_people * (num_people + 1) / 2; // sum from 1 to num_people, amount of candies for 1st round\\n        int rounds = 0;\\n        //counting rounds and amount of candies which left after all full rounds\\n        while(candies >= amount) {\\n            rounds++;\\n            candies -= amount;\\n            amount += num_people * num_people; //increase amount of candies, required for next round\\n        }\\n        \\n        for(int i = 0; i < num_people; i++) {\\n\\t\\t\\t//counting amount of candies, distributed to i-th person during full rounds. Lets say we have 4 rounds for 4 people. \\n\\t\\t\\t//1st will get 1 + 5 + 9 + 13, 2nd 2 + 6 + 10 + 14 and so on.\\n\\t\\t\\t//So its sum of N (which is rounds amount) numbers, statring from person number (i + 1) with step = num_people\\n\\t\\t\\t//Formula is  (2 * 1st + step * (N - 1) ) * N / 2\\n            result[i] = (2 * i + 2 + num_people * (rounds - 1)) * rounds / 2; \\n\\t\\t\\t\\n\\t\\t\\t//if we have more candies - counting how many we need to give to current person and taking this amount from candies \\n\\t\\t\\t//or all candies if we have not enough left\\n            if(candies > 0) {\\n                int n = 1 + i + num_people * rounds;\\n                n = candies < n ? candies : n;\\n                result[i] += n;\\n                candies -= n;\\n            }\\n        }\\n        return result;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 431245,
                "title": "python3-simple-solution-no-modulo-beats-91",
                "content": "```class Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = num_people * [0]\\n        index = 0\\n        increment = 0\\n        \\n        while candies > 0:\\n            take_away = min(candies, increment + 1)\\n            \\n            distribution[index] += take_away\\n            \\n            candies -= take_away\\n            increment += 1\\n            index += 1\\n            \\n            if index == num_people:\\n                index = 0\\n        \\n        return distribution\\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = num_people * [0]\\n        index = 0\\n        increment = 0\\n        \\n        while candies > 0:\\n            take_away = min(candies, increment + 1)\\n            \\n            distribution[index] += take_away\\n            \\n            candies -= take_away\\n            increment += 1\\n            index += 1\\n            \\n            if index == num_people:\\n                index = 0\\n        \\n        return distribution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416033,
                "title": "python3-3-solution-3-lines-99-16",
                "content": "**Method 1** A simulation-based solution is as below (21.55%), in which we assign candies to people according to the rule given by the problem and stop when we run out of candies. \\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans = [0]*num_people\\n        i = 0\\n        while candies > 0: \\n            i += 1\\n            ans[(i-1)%num_people] += min(i, candies)\\n            candies -= i\\n        return ans \\n```\\n**Method 2** The above simulation can be implemented in a more Pythonic fashion (3-line & 99.16%)\\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        n = int(0.5*(-1 + sqrt(1 + 8*candies)))\\n        numbers = list(range(1, n+1)) + [candies - n*(n+1)//2]\\n        return [sum(numbers[i::num_people]) for i in range(num_people)]\\n```\\n**Method 3** Mathematics (95.99%). Given number of candies and people, one can compute mathematically how many candies are assigned to each people. \\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        k = int(0.5*(-1 + sqrt(1 + 8*candies))) #length of arithmetic series\\n        m, n = divmod(k, num_people)\\n        \\n        ans = [0]*num_people \\n        for i in range(num_people):\\n            if i == n: m -= 1\\n            ans[i] = (m+1)*(i+1) + m*(m+1)*num_people//2\\n        ans[n] += candies - k*(k+1)//2\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans = [0]*num_people\\n        i = 0\\n        while candies > 0: \\n            i += 1\\n            ans[(i-1)%num_people] += min(i, candies)\\n            candies -= i\\n        return ans \\n```\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        n = int(0.5*(-1 + sqrt(1 + 8*candies)))\\n        numbers = list(range(1, n+1)) + [candies - n*(n+1)//2]\\n        return [sum(numbers[i::num_people]) for i in range(num_people)]\\n```\n```\\nfrom math import sqrt \\n\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        k = int(0.5*(-1 + sqrt(1 + 8*candies))) #length of arithmetic series\\n        m, n = divmod(k, num_people)\\n        \\n        ans = [0]*num_people \\n        for i in range(num_people):\\n            if i == n: m -= 1\\n            ans[i] = (m+1)*(i+1) + m*(m+1)*num_people//2\\n        ans[n] += candies - k*(k+1)//2\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 326992,
                "title": "golang-simple-solution-with-self-explanation-beat-100",
                "content": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tvar res []int = make([]int,num_people)\\n\\tvar cnt int = 1\\n\\tfor candies > cnt{\\n\\t\\tres[(cnt - 1) % num_people] += cnt\\n\\t\\tcandies -= cnt\\n\\t\\tcnt++\\n\\t}\\n\\tres[(cnt - 1) % num_people] += candies\\n\\treturn res\\n}",
                "solutionTags": [],
                "code": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tvar res []int = make([]int,num_people)\\n\\tvar cnt int = 1\\n\\tfor candies > cnt{\\n\\t\\tres[(cnt - 1) % num_people] += cnt\\n\\t\\tcandies -= cnt\\n\\t\\tcnt++\\n\\t}\\n\\tres[(cnt - 1) % num_people] += candies\\n\\treturn res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 325281,
                "title": "python-8-20ms-math-with-explanation",
                "content": "For each **full round**, we give candies to every person, it consumes:\\nn(n+1)/2 + 0nn *for the 1st round*\\nn(n+1)/2 + 1nn *for the 2nd round*\\nn(n+1)/2 + 2nn *for the 3rd round*\\n...\\nWe first count that for the given candies, how many **full rounds** we can do.\\nThen we do all the **full rounds** at one time:\\nFor the person with index i, it consumes:\\n(i+1 + 0) + (i+1 + n) + ... + (i+1+ (k-1)n) = (i+1)k + k(k-1)n/2\\n\\nAfter this, the candies left are not enough to do another **full round**. Then, we enter the new round with the first person receiving 1 + kn candies.\\nFrom here, we just distribute  i+1 + kn candies to person with index i when we have enough candies.\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        k, s, res = 0, 0, [0 for x in range(n)]\\n\\t\\t# count how many full rounds we can do\\n        while s + n*(n+1)/2 + k*n*n < candies:\\n            s += n*(n+1)/2 + k*n*n\\n            k += 1\\n\\t\\t# do all full rounds at one time\\n        if k > 0:\\n            for i in range(len(res)):\\n                res[i] = (i+1)*k + k*(k-1)*n/2\\n                candies -= res[i]\\n        i = 0\\n\\t\\t# distribute the candies left\\n        while candies > 0:\\n            if candies > i+1 + k*n:\\n                res[i] += i+1 + k*n\\n                candies -= i+1 + k*n\\n            else:\\n                res[i] += candies\\n                break\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        k, s, res = 0, 0, [0 for x in range(n)]\\n\\t\\t# count how many full rounds we can do\\n        while s + n*(n+1)/2 + k*n*n < candies:\\n            s += n*(n+1)/2 + k*n*n\\n            k += 1\\n\\t\\t# do all full rounds at one time\\n        if k > 0:\\n            for i in range(len(res)):\\n                res[i] = (i+1)*k + k*(k-1)*n/2\\n                candies -= res[i]\\n        i = 0\\n\\t\\t# distribute the candies left\\n        while candies > 0:\\n            if candies > i+1 + k*n:\\n                res[i] += i+1 + k*n\\n                candies -= i+1 + k*n\\n            else:\\n                res[i] += candies\\n                break\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324809,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[]res=new int[num_people];\\n        int c=1;\\n        while (candies>0){\\n            for (int i=0;i<num_people;i++)\\n            {\\n                if (candies<c){\\n                    res[i]+=candies;\\n                    return res;\\n                } else {\\n\\t\\t\\t\\t\\tres[i]+=candies>c?c:candies;\\n\\t\\t\\t\\t\\tcandies-=c;\\n\\t\\t\\t\\t\\tc++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[]res=new int[num_people];\\n        int c=1;\\n        while (candies>0){\\n            for (int i=0;i<num_people;i++)\\n            {\\n                if (candies<c){\\n                    res[i]+=candies;\\n                    return res;\\n                } else {\\n\\t\\t\\t\\t\\tres[i]+=candies>c?c:candies;\\n\\t\\t\\t\\t\\tcandies-=c;\\n\\t\\t\\t\\t\\tc++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324250,
                "title": "fastest-math-solution-in-python-o-num-people",
                "content": "1. Find the smallest `n` such that `n * (n + 1) / 2 >= candles`\\n2. Find how many rounds we need to loop through num_people\\n3. Find out what\\'s the last index to fill\\n4. Fill into the result array according to the rounds and start index\\n\\nReference: https://en.wikipedia.org/wiki/Arithmetic_progression#Sum\\n\\n```\\ndef distributeCandies(self, candies, num_people):\\n        res = [0] * num_people\\n\\t\\t\\n\\t\\t# Find the smallest n\\n        n = math.floor(math.sqrt(candies * 2))\\n        if n * (n + 1) < candies * 2:\\n            n += 1\\n\\t\\t\\n\\t\\t# How many rounds we need to loop through num_people\\n        if n % num_people == 0:\\n            rounds = n // num_people \\n        else:\\n            rounds = n // num_people + 1\\n\\t\\t\\n\\t\\t# The last index to fill\\n        last = int(n % num_people - 1)\\n        edge = last\\n        if edge < 0:\\n            edge += num_people\\n\\t\\t\\n        for i in range(edge):\\n            res[i] = int((2*i + 2 + num_people * rounds - num_people) * rounds / 2\\n            candies -= res[i]\\n        for i in range(edge + 1, len(res)):\\n            res[i] = int((2*i + 2 + num_people * (rounds - 1) - num_people) * (rounds - 1) / 2)\\n            candies -= res[i]\\n        res[last] = candies\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef distributeCandies(self, candies, num_people):\\n        res = [0] * num_people\\n\\t\\t\\n\\t\\t# Find the smallest n\\n        n = math.floor(math.sqrt(candies * 2))\\n        if n * (n + 1) < candies * 2:\\n            n += 1\\n\\t\\t\\n\\t\\t# How many rounds we need to loop through num_people\\n        if n % num_people == 0:\\n            rounds = n // num_people \\n        else:\\n            rounds = n // num_people + 1\\n\\t\\t\\n\\t\\t# The last index to fill\\n        last = int(n % num_people - 1)\\n        edge = last\\n        if edge < 0:\\n            edge += num_people\\n\\t\\t\\n        for i in range(edge):\\n            res[i] = int((2*i + 2 + num_people * rounds - num_people) * rounds / 2\\n            candies -= res[i]\\n        for i in range(edge + 1, len(res)):\\n            res[i] = int((2*i + 2 + num_people * (rounds - 1) - num_people) * (rounds - 1) / 2)\\n            candies -= res[i]\\n        res[last] = candies\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323409,
                "title": "javascript-python3-c-brute-force",
                "content": "**Synopsis:**\\n\\nLet `candy` be a monotonically increasing value, starting at `1` which denotes the maximum amount of candies we can currently take.  Take `candy` until all `k` candies have been exhausted.\\n\\n---\\n\\n*Javascript*\\n```\\nlet distributeCandies = (k, N, candy = 0) => {\\n    let ans = Array(N).fill(0);\\n    while (k) {\\n        for (let i = 0; i < N; ++i) {\\n            let take = Math.min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n            ans[i] += take, k -= take;\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def distributeCandies(self, k: int, N: int, candy = 1) -> List[int]:\\n        ans = [0] * N\\n        while k:\\n            for i in range(N):\\n                take = min(candy, k)  # \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take\\n                k -= take\\n                candy += 1\\n        return ans\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector< int >;\\n    VI distributeCandies(int k, int N, int candy = 0){\\n        VI ans(N);\\n        while (k) {\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto take = min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take, k -= take;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet distributeCandies = (k, N, candy = 0) => {\\n    let ans = Array(N).fill(0);\\n    while (k) {\\n        for (let i = 0; i < N; ++i) {\\n            let take = Math.min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n            ans[i] += take, k -= take;\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def distributeCandies(self, k: int, N: int, candy = 1) -> List[int]:\\n        ans = [0] * N\\n        while k:\\n            for i in range(N):\\n                take = min(candy, k)  # \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take\\n                k -= take\\n                candy += 1\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector< int >;\\n    VI distributeCandies(int k, int N, int candy = 0){\\n        VI ans(N);\\n        while (k) {\\n            for (auto i{ 0 }; i < N; ++i) {\\n                auto take = min(++candy, k);  // \\u2B50\\uFE0F take candy (not exceeding available k candies)\\n                ans[i] += take, k -= take;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323313,
                "title": "c-brute-force-just-as-the-logic-asks-for-it",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n, 0);\\n        int loop = 0; //use a loop variable to track the number of times it comes back to start\\n        while(candies > 0){\\n            for(int i=0; i<n; i++){\\n                int toGive = i+1 + loop*n;\\n                if(candies < toGive){\\n\\t\\t\\t\\t\\t// if not enough candies left then assign all of them to current person\\n                    res[i] += candies;\\n                    candies = 0;\\n                    break;\\n                }else{\\n                    res[i] += toGive;\\n                    candies -= toGive;\\n                }\\n            }\\n            loop++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int n) {\\n        vector<int> res(n, 0);\\n        int loop = 0; //use a loop variable to track the number of times it comes back to start\\n        while(candies > 0){\\n            for(int i=0; i<n; i++){\\n                int toGive = i+1 + loop*n;\\n                if(candies < toGive){\\n\\t\\t\\t\\t\\t// if not enough candies left then assign all of them to current person\\n                    res[i] += candies;\\n                    candies = 0;\\n                    break;\\n                }else{\\n                    res[i] += toGive;\\n                    candies -= toGive;\\n                }\\n            }\\n            loop++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773226,
                "title": "faster-than-100-beats-java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int k) {\\n        int ary[]=new int[k];\\n        int val=1;\\n        int indexstore=0;\\n        int sum=0;\\n        int count=0;\\n  while(candies>0) // Travels ary Untile Your canie not finish\\n  {\\n      for(int i=0;i<k;i++)\\n      {\\n          candies-=val;\\n          if(candies>=0)\\n          {\\n          ary[i]+=val;\\n          if(candies==0) // If your candi finish stop and break loop\\n          {\\n              break;\\n\\n          }\\n          }\\n          else\\n          {\\n              ary[i]+=val+candies;\\n              indexstore=i;\\n              break;\\n          }\\n          val++;\\n      }\\n      count++;\\n  }\\n  if(indexstore!=0 && indexstore!=k-1 && count==0) // when your candi finish but pepole who have not even one canie give them o candie\\n  {\\n        for (int i = indexstore; i < k; i++) {\\n                ary[i] = 0;\\n            }\\n  }\\n  return ary;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439758,
                "title": "c-for-dumbs-100-faster",
                "content": "\\n\\n# Approach\\nInitially the program only wants to give some candy to each person, the website would inform the number of candiess to distribute and the number of people.\\n\\nIn the initial distribution the first person should receive only one candy, the second person should receive one more than the first one and after all the people have earned the candies, it would start another distribution loop in the same way until there is no more candies.\\n\\nThe last person would only receive all the candy avaliable in case there is no candy necessary to fulfill the formula. **n+1**\\n\\nin my solution the distributions will happen until there is no more candies\\n```\\nwhile(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n```\\n**y** represents the number of candies to each pearson that would increase aways by one, in this way the number of candies will always  decrease too by **y** to analyse how many candies remain. And if there is no more candies to fulfill the formula, the last person will receive all the rest of the candies.\\n\\n**res**[0] represents the number of candies that the first person would receive and candies represents the total of cadies that remain to be destributed.\\n\\n**If you like please upvote**\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#include <stdlib.h>\\n#include <stdio.h>\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\n    *returnSize = num_people;\\n    int x[num_people];\\n    int y = 1;\\n    int *res=(int*)calloc(num_people,sizeof(int));\\n    while(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n    }\\n    return res;\\n}\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Simulation"
                ],
                "code": "```\\nwhile(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n```\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#include <stdlib.h>\\n#include <stdio.h>\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\n    *returnSize = num_people;\\n    int x[num_people];\\n    int y = 1;\\n    int *res=(int*)calloc(num_people,sizeof(int));\\n    while(candies != 0){\\n        for(int i = 0; i < num_people;  i++){\\n            if(candies < y){\\n                y =  candies;\\n            }\\n            res[i] = res[i] + y;\\n            candies = candies - y;\\n            y++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3159155,
                "title": "python3-easy-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis,i=num_people*[0],1\\n        while candies>=i:\\n            lis[(i-1)%num_people]+=i\\n            candies-=i\\n            i+=1\\n        if candies>0:    \\n            lis[(i-1)%num_people]+=candies\\n        return lis\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        lis,i=num_people*[0],1\\n        while candies>=i:\\n            lis[(i-1)%num_people]+=i\\n            candies-=i\\n            i+=1\\n        if candies>0:    \\n            lis[(i-1)%num_people]+=candies\\n        return lis\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001605,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = [0 for i in range(num_people)]\\n        i = 0\\n        j = 1\\n        while candies > 0:\\n            if i == len(arr):\\n                i = 0\\n            if candies >= j:\\n                arr[i] += j\\n                candies -= j\\n                j += 1\\n            else:\\n                arr[i] += candies\\n                break\\n            i += 1\\n        return arr\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = [0 for i in range(num_people)]\\n        i = 0\\n        j = 1\\n        while candies > 0:\\n            if i == len(arr):\\n                i = 0\\n            if candies >= j:\\n                arr[i] += j\\n                candies -= j\\n                j += 1\\n            else:\\n                arr[i] += candies\\n                break\\n            i += 1\\n        return arr\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885846,
                "title": "java-runtime-1-ms-beats-97-31-memory-39-9-mb-beats-91-94",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] rs = new int[num_people];\\n        int index = 1;\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                if (candies == 0) break;\\n                index = candies > index ? index : candies;\\n                rs[i] += index;\\n                candies -= index++;\\n            }\\n        }\\n\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] rs = new int[num_people];\\n        int index = 1;\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                if (candies == 0) break;\\n                index = candies > index ? index : candies;\\n                rs[i] += index;\\n                candies -= index++;\\n            }\\n        }\\n\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848458,
                "title": "java-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] arr = new int[num_people];\\n        \\n        int currCandyCount = 1;\\n        \\n        while(candies > 0) {\\n            for(int i = 0; i<num_people; i++) {\\n                if(candies >= currCandyCount) { // check if we have enough candies to distribute next\\n                    arr[i]+= currCandyCount;\\n                    candies -=currCandyCount;\\n                    currCandyCount++;\\n                } else { // we don\\'t have enough candies to distribute\\n                    arr[i] += candies; // distribute whatever is remaining\\n                    candies = 0; // set to 0 so it exits the while loop\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838299,
                "title": "java-brute-force-solution-explained",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int c, int n) {\\n        int[] arr = new int[n];\\n        int idx = 0;\\n        while (c > 0) {\\n            //[idx++ % n] - means that I find index of array to add\\n            //and then increment this index\\n            //Math.min(idx, c) - is used because in the end when we have candies left less than we need to add, then just add minimum number\\n            arr[idx++ % n] += Math.min(idx, c);\\n\\n            //during loop we need to substract given number of candies\\n            //above from all number of candies left\\n            //if this number is negative, then just 0 left.\\n            c = Math.max(c - idx, 0);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int c, int n) {\\n        int[] arr = new int[n];\\n        int idx = 0;\\n        while (c > 0) {\\n            //[idx++ % n] - means that I find index of array to add\\n            //and then increment this index\\n            //Math.min(idx, c) - is used because in the end when we have candies left less than we need to add, then just add minimum number\\n            arr[idx++ % n] += Math.min(idx, c);\\n\\n            //during loop we need to substract given number of candies\\n            //above from all number of candies left\\n            //if this number is negative, then just 0 left.\\n            c = Math.max(c - idx, 0);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780239,
                "title": "java-98-beats-just-one-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distributeCandies(int n, int num_people) {\\n        int[] nums = new int[num_people];\\n        int i=0;\\n        int givenCandies=0;\\n        int candies=1;\\n        while(true){\\n            if(i==num_people) i=0;\\n            if(givenCandies+candies<=n){\\n                nums[i++]+=candies++;\\n                givenCandies+=candies-1;\\n            }else{\\n                nums[i]+=n-givenCandies;\\n                break;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int n, int num_people) {\\n        int[] nums = new int[num_people];\\n        int i=0;\\n        int givenCandies=0;\\n        int candies=1;\\n        while(true){\\n            if(i==num_people) i=0;\\n            if(givenCandies+candies<=n){\\n                nums[i++]+=candies++;\\n                givenCandies+=candies-1;\\n            }else{\\n                nums[i]+=n-givenCandies;\\n                break;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378857,
                "title": "java-faster-than-98-users",
                "content": "```\\nint ans[]=new int[people];\\n        int curr=1;\\n        int rem=candies;\\n        while(rem>0){\\n            for(int i=0;i<people;i=(i+1)%people){\\n                if(rem<=curr){\\n                    ans[i]+=rem;\\n                    rem=0;\\n                    break;\\n                }\\n                else{\\n                    ans[i]+=curr;\\n                    rem=rem-curr;\\n                    curr++;\\n                }\\n            }\\n        }\\n        return ans;```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint ans[]=new int[people];\\n        int curr=1;\\n        int rem=candies;\\n        while(rem>0){\\n            for(int i=0;i<people;i=(i+1)%people){\\n                if(rem<=curr){\\n                    ans[i]+=rem;\\n                    rem=0;\\n                    break;\\n                }\\n                else{\\n                    ans[i]+=curr;\\n                    rem=rem-curr;\\n                    curr++;\\n                }\\n            }\\n        }\\n        return ans;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2217899,
                "title": "c-easy-problem",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int t, int np) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans(np,0);\\n\\t\\t\\tint i=1;\\n\\t\\t\\tfor(int j=0;j<np;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(t<=i)  \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans[j]+=t;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[j]+=i;\\n\\t\\t\\t\\tt-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tif(j==np-1) j=-1;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int t, int np) \\n\\t\\t{\\n\\t\\t\\tvector<int> ans(np,0);\\n\\t\\t\\tint i=1;\\n\\t\\t\\tfor(int j=0;j<np;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(t<=i)  \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tans[j]+=t;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2114146,
                "title": "easy-java-2ms",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] ans=new int[num_people];\\n        int k=0;\\n        while(candies>0){\\n            ans[k%num_people]+=Math.min(k+1,candies);\\n            candies-=Math.min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] ans=new int[num_people];\\n        int k=0;\\n        while(candies>0){\\n            ans[k%num_people]+=Math.min(k+1,candies);\\n            candies-=Math.min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098819,
                "title": "c-0ms-beats-100",
                "content": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>ans(num_people,0);\\n        int k=0;\\n        while(candies)\\n        {\\n            ans[k%num_people]+=min(k+1,candies);\\n                candies-=min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>ans(num_people,0);\\n        int k=0;\\n        while(candies)\\n        {\\n            ans[k%num_people]+=min(k+1,candies);\\n                candies-=min(k+1,candies);\\n            k++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081337,
                "title": "java-solution",
                "content": "```java \\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] a = new int[num_people];\\n        int i=0;\\n        int c=1;\\n        while(candies>0)\\n        {\\n            if(candies>=c)\\n            {\\n                candies-=c;\\n               a[i%a.length]+=c++;\\n            }\\n            else\\n            {\\n                a[i%a.length]+=candies;\\n                candies=0;\\n            }\\n            i++;\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] a = new int[num_people];\\n        int i=0;\\n        int c=1;\\n        while(candies>0)\\n        {\\n            if(candies>=c)\\n            {\\n                candies-=c;\\n               a[i%a.length]+=c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1966144,
                "title": "easy-java-solution-95-faster-easy-understanding-approach",
                "content": "# JAVA Solution | 95% faster | Easy friendly understanding :)\\n1. While we have given less candies than the ones we had at the beginning (`while(total < candies){}`)\\n2. Use `count % num_people == 0` to determine the current index of the people.\\n3. Remeber to leave a like! ;) \\n\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];        //Initialize the array of people\\n        int toGiveCandie = 1, count = 0, total = 0;    \\n        while(total < candies){                 //While the total candies given is fewer than the candies we have...\\n            if(count % num_people == 0){        //This is to \\'reset\\' de counter to 0 when we reach the last person.\\n                count = 0;\\n            }\\n            if(total + toGiveCandie <= candies){  \\n                //If the number of candies we have already given plus the candies we are \\n                // going to give are less or equal than the total candies...\\n                res[count] += toGiveCandie;     //We add the candies to the array (give the candie to the person)\\n                total += toGiveCandie;          //We update the candies we have given\\n                toGiveCandie++;                 //To the next person we will give one more candie\\n            }else{\\n                //If we don\\'t have the enough candies, we just give the candies left\\n                res[count] += candies-total;    \\n                total += candies-total;\\n                toGiveCandie++;\\n            }\\n            count++;\\n        }\\n        return res;                            //We return the filled array\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];        //Initialize the array of people\\n        int toGiveCandie = 1, count = 0, total = 0;    \\n        while(total < candies){                 //While the total candies given is fewer than the candies we have...\\n            if(count % num_people == 0){        //This is to \\'reset\\' de counter to 0 when we reach the last person.\\n                count = 0;\\n            }\\n            if(total + toGiveCandie <= candies){  \\n                //If the number of candies we have already given plus the candies we are \\n                // going to give are less or equal than the total candies...\\n                res[count] += toGiveCandie;     //We add the candies to the array (give the candie to the person)\\n                total += toGiveCandie;          //We update the candies we have given\\n                toGiveCandie++;                 //To the next person we will give one more candie\\n            }else{\\n                //If we don\\'t have the enough candies, we just give the candies left\\n                res[count] += candies-total;    \\n                total += candies-total;\\n                toGiveCandie++;\\n            }\\n            count++;\\n        }\\n        return res;                            //We return the filled array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944613,
                "title": "c-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int npeople) {\\n        vector<int>ans(npeople,0);\\n        int i=0,n=1;\\n        while(candies>0){\\n            i = i%npeople;\\n            ans[i]= ans[i]+min(candies,n);\\n            candies-=n;\\n            n++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int npeople) {\\n        vector<int>ans(npeople,0);\\n        int i=0,n=1;\\n        while(candies>0){\\n            i = i%npeople;\\n            ans[i]= ans[i]+min(candies,n);\\n            candies-=n;\\n            n++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896445,
                "title": "python-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        dist = 1\\n        pos = 0\\n        while candies > 0:\\n            if pos == num_people:\\n                pos = 0\\n            if candies < dist:\\n                res[pos] += candies\\n                return res\\n            res[pos] += dist\\n            candies -= dist\\n            dist += 1\\n            pos += 1\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        dist = 1\\n        pos = 0\\n        while candies > 0:\\n            if pos == num_people:\\n                pos = 0\\n            if candies < dist:\\n                res[pos] += candies\\n                return res\\n            res[pos] += dist\\n            candies -= dist\\n            dist += 1\\n            pos += 1\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1878038,
                "title": "easier-efficient-javascript-solution",
                "content": "/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let arr = new Array(num_people).fill(0), j = 1, sum = 1, i = 0;\\n    while (sum < candies) {\\n        i = i%num_people;\\n        arr[i] += j;\\n        i++;\\n        j++;\\n        sum += j;\\n    }\\n\\t//handling last remaining candy\\n    arr[i%num_people] += candies - (sum - j);\\n    return arr;\\n};",
                "solutionTags": [],
                "code": "/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let arr = new Array(num_people).fill(0), j = 1, sum = 1, i = 0;\\n    while (sum < candies) {\\n        i = i%num_people;\\n        arr[i] += j;\\n        i++;\\n        j++;\\n        sum += j;\\n    }\\n\\t//handling last remaining candy\\n    arr[i%num_people] += candies - (sum - j);\\n    return arr;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1827308,
                "title": "java-3-liner-explained",
                "content": "**Idea:** Keep distributing the candies in increment of 1 until they run out. Wrap around the array using `% numPeople` and take min to avoid giving more candies than left\\n>**T/S:** O(sqrt(candies))/O(numPeople)\\n```\\npublic int[] distributeCandies(int candies, int numPeople) {\\n\\tvar distribution = new int[numPeople];\\n\\tfor (var i = 0; candies > 0; candies -= ++i)\\n\\t\\tdistribution[i % numPeople] += Math.min(candies, i + 1);\\n\\treturn distribution;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] distributeCandies(int candies, int numPeople) {\\n\\tvar distribution = new int[numPeople];\\n\\tfor (var i = 0; candies > 0; candies -= ++i)\\n\\t\\tdistribution[i % numPeople] += Math.min(candies, i + 1);\\n\\treturn distribution;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807566,
                "title": "c",
                "content": "**4 lines Code\\uD83D\\uDE2E:- \\n\\nstep 1: initalization index i=0, and add = every element adds to the next indexs 1 to n\\n\\nstep 2: iterate while --> cand is not equal to zero.\\n\\nstep  3:  every element is add to evry index by incrementing +1, and remove the elements from cand that are add to an array.\\n\\nstep 4: if iterator \\'i\\'==n them we need  to create circular array from like i=i%n;\\nfor eg: 0,1,2,3,4--->after 4 it again go near index i=0 --> 0,1,2,3,4,0,1,2,3,4.... so on.\\n\\n\\ncode: -\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int cand, int n) {\\n        \\n        int i=0,add=1;\\n        vector<int> arr(n);\\n        while(cand>0){\\n            \\n            arr[i]+=min(add,cand);\\n            cand-=add;\\n            add+=1;\\n            i=(i+1)%n;  \\n        }\\n        return arr;\\n        \\n    }\\n};\\n\\n Thanks please Vote!!\\uD83D\\uDE43\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int cand, int n) {\\n        \\n        int i=0,add=1;\\n        vector<int> arr(n);\\n        while(cand>0){\\n            \\n            arr[i]+=min(add,cand);\\n            cand-=add;\\n            add+=1;\\n            i=(i+1)%n;  \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1692289,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> arr;\\n        for(int i=0; i<num_people;i++){\\n            arr.push_back(0);\\n        }\\n        int giv=1,i=0;\\n        while(candies!=0){\\n            if(giv>=candies){\\n                arr[i%num_people]+=candies;\\n                candies=0;\\n            }\\n            else{\\n                arr[i%num_people]+= giv;\\n                candies=candies-giv;\\n                giv=giv+ 1;                \\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> arr;\\n        for(int i=0; i<num_people;i++){\\n            arr.push_back(0);\\n        }\\n        int giv=1,i=0;\\n        while(candies!=0){\\n            if(giv>=candies){\\n                arr[i%num_people]+=candies;\\n                candies=0;\\n            }\\n            else{\\n                arr[i%num_people]+= giv;\\n                candies=candies-giv;\\n                giv=giv+ 1;                \\n            }\\n            i++;\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579712,
                "title": "python-3-solution",
                "content": "```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        \\n        i, candy = 0, 1\\n        while candies > 0:\\n            res[i] += min(candies, candy)\\n            candies -= candy\\n            candy += 1\\n            i = (i + 1) % num_people\\n            \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        \\n        i, candy = 0, 1\\n        while candies > 0:\\n            res[i] += min(candies, candy)\\n            candies -= candy\\n            candy += 1\\n            i = (i + 1) % num_people\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481631,
                "title": "simple-solution-4-lines-without-break-statements",
                "content": "```\\nvar distributeCandies = function (candies, num_people) {\\n    let people = new Array(num_people).fill(0);\\n    for (let index = 0; candies > 0; index++) {\\n        const res = Math.min(index + 1, candies); // if candies is less take only rem ones\\n        people[index % people.length] += res // rotate array and add value to cureent array index\\n        candies = candies - res; //sub candies\\n    }\\n    return people;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distributeCandies = function (candies, num_people) {\\n    let people = new Array(num_people).fill(0);\\n    for (let index = 0; candies > 0; index++) {\\n        const res = Math.min(index + 1, candies); // if candies is less take only rem ones\\n        people[index % people.length] += res // rotate array and add value to cureent array index\\n        candies = candies - res; //sub candies\\n    }\\n    return people;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472818,
                "title": "python-easy-to-understand-code-o-n",
                "content": "**Time: O(N)\\nSpace: O(1)**\\n\\n\\n```\\nres=[0 for i in range (num_people)]\\n        val=1\\n        i=0\\n        while(candies>0):\\n            res[i]+=val\\n            i+=1\\n            candies-=val\\n            val+=1\\n            if i==(num_people):\\n                i=0\\n            if val>candies:\\n                val=candies\\n                res[i]+=val\\n                candies=0\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nres=[0 for i in range (num_people)]\\n        val=1\\n        i=0\\n        while(candies>0):\\n            res[i]+=val\\n            i+=1\\n            candies-=val\\n            val+=1\\n            if i==(num_people):\\n                i=0\\n            if val>candies:\\n                val=candies\\n                res[i]+=val\\n                candies=0\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1387311,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret;\\n        int j=1;\\n        for(int i=0;i<num_people;i++) {\\n            if(j<=candies) {\\n                ret.push_back(j);\\n                candies-=j;\\n                j++;\\n            }\\n            else  {\\n                ret.push_back(candies);\\n                candies=0;\\n            }\\n        }\\n        int i=0;\\n        while(candies>0) {\\n            if(j<=candies) {\\n                ret[i]+=j;\\n                candies-=j;\\n                i++;\\n                j++;\\n                if(i==num_people) i=0;\\n            }\\n            else {\\n                ret[i]+=candies;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret;\\n        int j=1;\\n        for(int i=0;i<num_people;i++) {\\n            if(j<=candies) {\\n                ret.push_back(j);\\n                candies-=j;\\n                j++;\\n            }\\n            else  {\\n                ret.push_back(candies);\\n                candies=0;\\n            }\\n        }\\n        int i=0;\\n        while(candies>0) {\\n            if(j<=candies) {\\n                ret[i]+=j;\\n                candies-=j;\\n                i++;\\n                j++;\\n                if(i==num_people) i=0;\\n            }\\n            else {\\n                ret[i]+=candies;\\n                break;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324110,
                "title": "simple-c-code-easy-to-understand-0ms-runtime-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> v(num_people,0);\\n        int j=1;\\n        while(candies>0){\\n                v[(j-1)%num_people]+=min(j,candies);\\n                candies-=j;\\n                j++;\\n        }\\n    return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> v(num_people,0);\\n        int j=1;\\n        while(candies>0){\\n                v[(j-1)%num_people]+=min(j,candies);\\n                candies-=j;\\n                j++;\\n        }\\n    return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287989,
                "title": "easy-java-o-n-soln",
                "content": "Do give an upvote if you liked it!\\n```\\npublic int[] distributeCandies(int c, int p) {\\n        int arr[]=new int[p];\\n        int ind = 0;\\n        int k = 1;\\n        while(c>0){\\n            if(c>k)\\n                arr[ind%p]+=k;\\n            else\\n                arr[ind%p]+=c;\\n            ind++;\\n            c=c-k;\\n            k++;\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int c, int p) {\\n        int arr[]=new int[p];\\n        int ind = 0;\\n        int k = 1;\\n        while(c>0){\\n            if(c>k)\\n                arr[ind%p]+=k;\\n            else\\n                arr[ind%p]+=c;\\n            ind++;\\n            c=c-k;\\n            k++;\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1264310,
                "title": "python-3-100-fast-used-math",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = 0\\n        iteration = 0\\n        past_distribution = 0\\n        \\n        while distribution <= candies:\\n            past_distribution = distribution\\n            iteration += 1\\n            distribution = ((num_people*iteration)*(num_people * iteration + 1))//2\\n            \\n        candies -= past_distribution\\n        ans = []\\n        for i in range(num_people):\\n            x = iteration-1\\n            ith_candies = (i+1)*(x) + (num_people*x*(x-1))//2\\n            \\n            if candies > 0:\\n                new_candy = (i+1) + ((iteration-1)*num_people)\\n                new_candies = min(candies, new_candy)\\n                ith_candies += new_candies\\n                candies -= new_candies\\n            ans.append(ith_candies)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        distribution = 0\\n        iteration = 0\\n        past_distribution = 0\\n        \\n        while distribution <= candies:\\n            past_distribution = distribution\\n            iteration += 1\\n            distribution = ((num_people*iteration)*(num_people * iteration + 1))//2\\n            \\n        candies -= past_distribution\\n        ans = []\\n        for i in range(num_people):\\n            x = iteration-1\\n            ith_candies = (i+1)*(x) + (num_people*x*(x-1))//2\\n            \\n            if candies > 0:\\n                new_candy = (i+1) + ((iteration-1)*num_people)\\n                new_candies = min(candies, new_candy)\\n                ith_candies += new_candies\\n                candies -= new_candies\\n            ans.append(ith_candies)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252681,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\nvar distributeCandies = function(candies, num_people) {\\n  \\n   let res =Array(num_people).fill(0) ,i=0 , j =1;\\n \\n    while(candies>0)\\n    {    \\n        if(i==num_people)\\n        {\\n            i=0;\\n        }\\n        res[i]+=candies>=j? j :candies;\\n        candies-=j\\n        i++;   \\n        j++;\\n    }\\n    \\n    return res;\\n};",
                "solutionTags": [],
                "code": "\\nvar distributeCandies = function(candies, num_people) {\\n  \\n   let res =Array(num_people).fill(0) ,i=0 , j =1;\\n \\n    while(candies>0)\\n    {    \\n        if(i==num_people)\\n        {\\n            i=0;\\n        }\\n        res[i]+=candies>=j? j :candies;\\n        candies-=j\\n        i++;   \\n        j++;\\n    }\\n    \\n    return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1240670,
                "title": "java-bruteforce",
                "content": "```\\nclass Solution \\n{\\n    public int[] distributeCandies(int candies, int num_people) \\n    {\\n        int i = 0 , candy = 1 ;\\n        int[] a = new int[num_people] ;\\n        while( candies > 0 )\\n        {\\n            if( candy > candies )\\n            {\\n                a[i] += candies ;\\n            }\\n            else\\n            {\\n                a[i] += candy ;\\n                i++ ;\\n            }\\n            candies = candies - candy ;\\n            candy++ ;\\n            if( i == num_people )\\n            {\\n                i = 0 ;\\n            }\\n        }\\n        return a ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] distributeCandies(int candies, int num_people) \\n    {\\n        int i = 0 , candy = 1 ;\\n        int[] a = new int[num_people] ;\\n        while( candies > 0 )\\n        {\\n            if( candy > candies )\\n            {\\n                a[i] += candies ;\\n            }\\n            else\\n            {\\n                a[i] += candy ;\\n                i++ ;\\n            }\\n            candies = candies - candy ;\\n            candy++ ;\\n            if( i == num_people )\\n            {\\n                i = 0 ;\\n            }\\n        }\\n        return a ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132765,
                "title": "c-o-n-100-fast-time-gauss-summation",
                "content": "```\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        auto iters = 0;  //count how many full cycles we can get\\n        auto sum = 0; //sum of each cycle\\n        auto count = 1; // start value of 1st human in cycle\\n        if(num_people == 1){\\n            return {candies}; \\n        }\\n        sum = (num_people*(count+num_people))/2; //compute first sum of candies for the 1st cycle\\n        while(candies >= sum){ // while we can give candies for each people in cycle, count it and residual of candies\\n            candies -= sum;\\n            count += num_people;\\n            sum = (num_people*(2*count+num_people-1))/2; // sum of all candies from count to N+count\\n            iters++; // if we in while loop, that means we can make a cycle\\n        }\\n        vector<int> res(num_people, 0); // create our final result vector\\n        auto extra = count; //last value for the fisrt human in cycle that we shoul bring\\n        for(auto i = 0; i < num_people; ++i){\\n            if(iters > 0) // if we have full cycles\\n                res[i] = ((i+1)*iters + num_people*(iters-1)*iters/2); //compute sum of all candies for Ith person that can be given from cycles\\n            if(candies >= (extra)){ //if we have extra candies after cycles computing, lets add them\\n                res[i] += extra;\\n                candies -= extra;\\n                ++extra;\\n                \\n            }\\n            else if(candies > 0){\\n                res[i] += candies;\\n                candies = 0;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        auto iters = 0;  //count how many full cycles we can get\\n        auto sum = 0; //sum of each cycle\\n        auto count = 1; // start value of 1st human in cycle\\n        if(num_people == 1){\\n            return {candies}; \\n        }\\n        sum = (num_people*(count+num_people))/2; //compute first sum of candies for the 1st cycle\\n        while(candies >= sum){ // while we can give candies for each people in cycle, count it and residual of candies\\n            candies -= sum;\\n            count += num_people;\\n            sum = (num_people*(2*count+num_people-1))/2; // sum of all candies from count to N+count\\n            iters++; // if we in while loop, that means we can make a cycle\\n        }\\n        vector<int> res(num_people, 0); // create our final result vector\\n        auto extra = count; //last value for the fisrt human in cycle that we shoul bring\\n        for(auto i = 0; i < num_people; ++i){\\n            if(iters > 0) // if we have full cycles\\n                res[i] = ((i+1)*iters + num_people*(iters-1)*iters/2); //compute sum of all candies for Ith person that can be given from cycles\\n            if(candies >= (extra)){ //if we have extra candies after cycles computing, lets add them\\n                res[i] += extra;\\n                candies -= extra;\\n                ++extra;\\n                \\n            }\\n            else if(candies > 0){\\n                res[i] += candies;\\n                candies = 0;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132441,
                "title": "c-100-fast-intuitive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num) {\\n        vector<int> arr(num,0);\\n        \\n        int i=0;\\n        int count=1;\\n\\n        while(candies>0){\\n               arr[i%num]+=min(count,candies);\\n               candies-=count;    \\n               count++;\\n               i++;\\n        }\\n        \\n        return arr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num) {\\n        vector<int> arr(num,0);\\n        \\n        int i=0;\\n        int count=1;\\n\\n        while(candies>0){\\n               arr[i%num]+=min(count,candies);\\n               candies-=count;    \\n               count++;\\n               i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1063785,
                "title": "easy-brute-force-o-sqrt-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n = num_people;\\n        vector<int> ans(n,0);\\n        int i=0,j=1;\\n        while(candies > 0){\\n        \\n            if(candies > j)\\n                ans[(i+n)%n] += j;\\n            else\\n                ans[(i+n)%n] += candies;\\n                \\n            candies -= j;\\n            i++,j++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n = num_people;\\n        vector<int> ans(n,0);\\n        int i=0,j=1;\\n        while(candies > 0){\\n        \\n            if(candies > j)\\n                ans[(i+n)%n] += j;\\n            else\\n                ans[(i+n)%n] += candies;\\n                \\n            candies -= j;\\n            i++,j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1041303,
                "title": "0ms-time-complexity-o-num-people-space-complexity-o-num-people",
                "content": "Brute force approach giving one candy to first position, two to second etc and looping around until you run out of candy is quick and easy to code but has complexity O(Sqrt(candies)). The limits suggest max number of people is 1000, but max number of candies can be 1,000,000,000 so potentially 30 times as much work! This makes an O(num_people) time algorithm attractive.\\nThe brute force algorithm will take O(Sqrt(candies)) time because there are a quadratic number of steps as explained in the O(num_people) based time.\\n\\nI noticed that the number of candies given out in X steps is given by the sum of the arithmetic progression - **Sum = (n/2)(a+l)**.\\nStep of progression is 1. First step is 1 and number of steps is steps and last value in progression is steps.\\nSo **total candies given out in steps = (steps/2)(1+steps)**.\\nThis gives a quadratic equation in terms of candies\\n**(steps^2)/2 + steps/2 - candies = 0**\\nGiven that we know candies we can solve for steps using general quadratic equation - **x = (-b+sqrt(b^2-4ac))/2a**.\\n**steps = (-(1/2) + sqrt((-1/2)^2-4(1/2)(-candies))/2(1/2)**\\nGiven the number of steps this gives the number of steps where all the candies were given out.\\nFrom this I can calculate the number of complete rounds where everybody got their full complement of candy.\\nFrom this I can calculate the number of candies for each person again based on sum of arithmetic progression (this time step is num_people and intial value is person number)\\nFinally I can calculate the number of candies not handed out in steps and this remainder will be added to the last person to receive candies.\\n\\n**Time Complexity is O(num_people)** and **Space Complexity is O(num_people)**\\n\\nHere is annotated code.\\n\\nIf this helps you please remember to upvote :-) Thank You!\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n\\t\\t// Space O(N)\\n        int[] result = new int[num_people];\\n        // Total candies given out for n steps = n/2(1+n) = (n^2+n)/2 <= candies\\n        // n^2/2+n/2-candies = 0;\\n        // Solving for n = (-1/2)+sqrt(1/4+2candies)\\n        int steps = (int)(Math.sqrt(2*candies+1/4) - 1.0/2);\\n        int rounds = (steps) / num_people;\\n        int partial = steps % num_people;\\n        // System.out.println(\"steps \"+steps);\\n        // System.out.println(\"rounds \"+rounds);\\n        // System.out.println(\"partial \"+partial);\\n        // System.out.println(\"given \"+(steps*(1+steps)/2));\\n\\t\\t// Tiem complexity O(N)\\n        for (int i=0; i<num_people; i++) {\\n            result[i] = rounds*(i+i+2+(rounds-1)*num_people)/2;\\n            if (i < partial)\\n                result[i] += rounds*num_people + i + 1;\\n            // System.out.printf(\"round[%d]=%d\\\\n\", i, result[i]);\\n            if (i == partial)\\n                result[i] += candies - steps*(1+steps)/2;\\n        }\\n        // Brute Force\\n        /*\\n        int share = 1;\\n        int n = 0;\\n        while (candies > 0) {\\n            int amount = Math.min(candies, share++);\\n            result[n++] += amount;\\n            candies -= amount;\\n            n %= num_people;\\n        }\\n        */\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n\\t\\t// Space O(N)\\n        int[] result = new int[num_people];\\n        // Total candies given out for n steps = n/2(1+n) = (n^2+n)/2 <= candies\\n        // n^2/2+n/2-candies = 0;\\n        // Solving for n = (-1/2)+sqrt(1/4+2candies)\\n        int steps = (int)(Math.sqrt(2*candies+1/4) - 1.0/2);\\n        int rounds = (steps) / num_people;\\n        int partial = steps % num_people;\\n        // System.out.println(\"steps \"+steps);\\n        // System.out.println(\"rounds \"+rounds);\\n        // System.out.println(\"partial \"+partial);\\n        // System.out.println(\"given \"+(steps*(1+steps)/2));\\n\\t\\t// Tiem complexity O(N)\\n        for (int i=0; i<num_people; i++) {\\n            result[i] = rounds*(i+i+2+(rounds-1)*num_people)/2;\\n            if (i < partial)\\n                result[i] += rounds*num_people + i + 1;\\n            // System.out.printf(\"round[%d]=%d\\\\n\", i, result[i]);\\n            if (i == partial)\\n                result[i] += candies - steps*(1+steps)/2;\\n        }\\n        // Brute Force\\n        /*\\n        int share = 1;\\n        int n = 0;\\n        while (candies > 0) {\\n            int amount = Math.min(candies, share++);\\n            result[n++] += amount;\\n            candies -= amount;\\n            n %= num_people;\\n        }\\n        */\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038560,
                "title": "surprisingly-fast-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int candie = 1;\\n        auto guy = ret.begin();\\n        while(candies)\\n        {\\n            candie = min(candie, candies); // get at most whatever candie is left\\n            candies -= candie;  // take out candie\\n            *guy += candie; // give it to guy\\n            \\n            guy++; // go to next guy\\n            if (guy == ret.end()) guy = ret.begin();  // loop back if needed\\n            candie++; // increase amount by one\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int candie = 1;\\n        auto guy = ret.begin();\\n        while(candies)\\n        {\\n            candie = min(candie, candies); // get at most whatever candie is left\\n            candies -= candie;  // take out candie\\n            *guy += candie; // give it to guy\\n            \\n            guy++; // go to next guy\\n            if (guy == ret.end()) guy = ret.begin();  // loop back if needed\\n            candie++; // increase amount by one\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000334,
                "title": "java-solution-faster-than-91-97-with-explanation",
                "content": "This is a pretty simple solution that checks whether the number of candies is greater than or equal to counter, if so then add that to the persons number of candies and subtract counter from candies to show how many candies are left. Else it adds the number of candies to the persons number of candies and makes candies equal to zero to break out of the loop and return.\\n\\n```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] numCandies = new int[num_people];\\n\\tint people  = 0;\\n\\tint counter = 1;\\n\\twhile (candies > 0){\\n\\t\\tif (candies >= counter){\\n\\t\\t\\tnumCandies[people] += counter;\\n\\t\\t\\tcandies -= counter;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnumCandies[people] += candies;\\n\\t\\t\\tcandies = 0;\\n\\t\\t}\\n\\t\\tif (people == num_people - 1){\\n\\t\\t\\tpeople = -1;\\n\\t\\t}\\n\\t\\tpeople++;\\n\\t\\tcounter ++;\\n\\t}\\n\\treturn numCandies;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint[] numCandies = new int[num_people];\\n\\tint people  = 0;\\n\\tint counter = 1;\\n\\twhile (candies > 0){\\n\\t\\tif (candies >= counter){\\n\\t\\t\\tnumCandies[people] += counter;\\n\\t\\t\\tcandies -= counter;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnumCandies[people] += candies;\\n\\t\\t\\tcandies = 0;\\n\\t\\t}\\n\\t\\tif (people == num_people - 1){\\n\\t\\t\\tpeople = -1;\\n\\t\\t}\\n\\t\\tpeople++;\\n\\t\\tcounter ++;\\n\\t}\\n\\treturn numCandies;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 979990,
                "title": "python-distribute-one-by-one",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        cand = 1\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cand >= candies:\\n                    res[i] += candies\\n                    candies = 0\\n                    break\\n                else:\\n                    res[i] += cand\\n                    candies -= cand\\n                    cand += 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        cand = 1\\n        while candies > 0:\\n            for i in range(num_people):\\n                if cand >= candies:\\n                    res[i] += candies\\n                    candies = 0\\n                    break\\n                else:\\n                    res[i] += cand\\n                    candies -= cand\\n                    cand += 1\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 949648,
                "title": "c-beats-100-using-ap-series",
                "content": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        \\n        int sum=0;\\n        int i=1;\\n        while(sum+i<=candies)\\n        {\\n            sum+=i;\\n            if(sum+i+1>candies)\\n                break;\\n            i++;\\n        }\\n       \\n        \\n        int row=i/num_people;\\n        \\n        int d=num_people;\\n        int l=0;\\n        int curr=0;\\n        for(int i=0;i<num_people;i++)\\n        {\\n            int a=i+1;\\n            l=a+(row-1)*d;\\n            int s=((a+l)*row)/2;\\n            ans.push_back(s);\\n            curr+=s;\\n            \\n        }\\n        \\n        if(curr<candies)\\n        {\\n            l++;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(curr+l<=candies)\\n                {\\n                    ans[i]=ans[i]+l;\\n                    curr+=l;\\n                }\\n                else\\n                {\\n                    ans[i]=ans[i]+candies-curr;\\n                    break;\\n                }\\n                l++;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans;\\n        \\n        int sum=0;\\n        int i=1;\\n        while(sum+i<=candies)\\n        {\\n            sum+=i;\\n            if(sum+i+1>candies)\\n                break;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 929706,
                "title": "c-faster-than-100-people-neatly-written",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>v(num_people);\\n        int cur=0,sum=0;\\n        for(int i=1;i!=0;i++){\\n            v[cur]+=i;\\n            sum+=i;\\n            if(sum==candies)\\n                break;\\n            else if(sum>candies){\\n                v[cur] -= i;\\n                sum-=i;\\n                v[cur]+=candies-sum;\\n                break;\\n            }\\n            cur++;\\n            cur = cur%num_people;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int>v(num_people);\\n        int cur=0,sum=0;\\n        for(int i=1;i!=0;i++){\\n            v[cur]+=i;\\n            sum+=i;\\n            if(sum==candies)\\n                break;\\n            else if(sum>candies){\\n                v[cur] -= i;\\n                sum-=i;\\n                v[cur]+=candies-sum;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 926177,
                "title": "easy-python-3",
                "content": "\\tclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans=[0]*num_people\\n        i=0\\n        while candies>0:\\n            if candies>(i+1):\\n                ans[i%num_people]+=i+1\\n                         \\n            else:\\n                ans[i%num_people]+=candies\\n                \\n            candies-=(i+1)\\n            i+=1\\n            \\n        return ans",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        ans=[0]*num_people\\n        i=0\\n        while candies>0:\\n            if candies>(i+1):\\n                ans[i%num_people]+=i+1\\n                         \\n            else:\\n                ans[i%num_people]+=candies\\n                \\n            candies-=(i+1)\\n            i+=1\\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 908015,
                "title": "easy-way-explanation-every-step",
                "content": "#  idea is  you increasing 1 candy for every person until nth person and when your reach last person comeback first.\\n# and put candy whatever gives last person +1 if not enough candy then gives whatever remaining\\n# if 4 person and candy 92\\n\\n# 1 + 2+ 3+  4     ---- first time\\n# 5 + 6+ 7+ 8----- second time\\n# 9 + 10+ 11+ 12  -----thrid time till here 91\\n# 13+1(this place he maximum can gets 14 but not enough canndy)\\n# ----- fourth time\\n# sum of all time candy gets one person  [(1+5+9+13),(2+6+10+1),(3+7+11+0)(4+8+12+0)]\\n# Explanation Bellow  another example example\\n```\\nYour input\\n100\\n8\\nstdout\\n(\\'person=\\', 1, \\'candies gets=\\', 1)\\n[1, 0, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 2)\\n[1, 2, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 3)\\n[1, 2, 3, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 4)\\n[1, 2, 3, 4, 0, 0, 0, 0]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 5)\\n[1, 2, 3, 4, 5, 0, 0, 0]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 6)\\n[1, 2, 3, 4, 5, 6, 0, 0]\\n\\n(\\'person=\\', 7, \\'candies gets=\\', 7)\\n[1, 2, 3, 4, 5, 6, 7, 0]\\n\\n(\\'person=\\', 8, \\'candies gets=\\', 8)\\n[1, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 1, \\'candies gets=\\', 9)\\n[10, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 10)\\n[10, 12, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 11)\\n[10, 12, 14, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 12)\\n[10, 12, 14, 16, 5, 6, 7, 8]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 13)\\n[10, 12, 14, 16, 18, 6, 7, 8]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 9)\\n[10, 12, 14, 16, 18, 15, 7, 8]\\n\\nOutput\\n[10,12,14,16,18,15,7,8]\\nExpected\\n[10,12,14,16,18,15,7,8]\\n\\n\\n\\n\\n```\\n```\\n\\nclass Solution(object):\\n    def distributeCandies(self, can, n):\\n        \"\"\"\\n        :type candies: int\\n        :type num_people: int\\n        :rtype: List[int]\\n        \"\"\"\\n        re=[0 for i in range(n)]\\n        i=1\\n        while can>0:\\n        \\n          re[(i-1)%n]+=min(i,can)\\n\\t\\t  \\n          can,i=can-i,i+1\\n          \\n        return re\\n      \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nYour input\\n100\\n8\\nstdout\\n(\\'person=\\', 1, \\'candies gets=\\', 1)\\n[1, 0, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 2)\\n[1, 2, 0, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 3)\\n[1, 2, 3, 0, 0, 0, 0, 0]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 4)\\n[1, 2, 3, 4, 0, 0, 0, 0]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 5)\\n[1, 2, 3, 4, 5, 0, 0, 0]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 6)\\n[1, 2, 3, 4, 5, 6, 0, 0]\\n\\n(\\'person=\\', 7, \\'candies gets=\\', 7)\\n[1, 2, 3, 4, 5, 6, 7, 0]\\n\\n(\\'person=\\', 8, \\'candies gets=\\', 8)\\n[1, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 1, \\'candies gets=\\', 9)\\n[10, 2, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 2, \\'candies gets=\\', 10)\\n[10, 12, 3, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 3, \\'candies gets=\\', 11)\\n[10, 12, 14, 4, 5, 6, 7, 8]\\n\\n(\\'person=\\', 4, \\'candies gets=\\', 12)\\n[10, 12, 14, 16, 5, 6, 7, 8]\\n\\n(\\'person=\\', 5, \\'candies gets=\\', 13)\\n[10, 12, 14, 16, 18, 6, 7, 8]\\n\\n(\\'person=\\', 6, \\'candies gets=\\', 9)\\n[10, 12, 14, 16, 18, 15, 7, 8]\\n\\nOutput\\n[10,12,14,16,18,15,7,8]\\nExpected\\n[10,12,14,16,18,15,7,8]\\n\\n\\n\\n\\n```\n```\\n\\nclass Solution(object):\\n    def distributeCandies(self, can, n):\\n        \"\"\"\\n        :type candies: int\\n        :type num_people: int\\n        :rtype: List[int]\\n        \"\"\"\\n        re=[0 for i in range(n)]\\n        i=1\\n        while can>0:\\n        \\n          re[(i-1)%n]+=min(i,can)\\n\\t\\t  \\n          can,i=can-i,i+1\\n          \\n        return re\\n      \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870584,
                "title": "simple-c-solution-100-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int num_people) {\\n\\t\\t\\tvector<int> v(num_people,0);\\n\\t\\t\\tint i = 1;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile(candies > 0){\\n\\t\\t\\t\\tv[j%num_people] += min(candies,i);\\n\\t\\t\\t\\tcandies-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n        \\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> distributeCandies(int candies, int num_people) {\\n\\t\\t\\tvector<int> v(num_people,0);\\n\\t\\t\\tint i = 1;\\n\\t\\t\\tint j = 0;\\n\\t\\t\\twhile(candies > 0){\\n\\t\\t\\t\\tv[j%num_people] += min(candies,i);\\n\\t\\t\\t\\tcandies-=i;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 869907,
                "title": "swift-solution-readability-performance-92",
                "content": "I would prefer my solution for readability than those weird modulo formula. It\\'s dumb in my opinion to use the solution. Not everyone knows that.\\n\\n```\\nclass Solution {\\n    func distributeCandies(_ candies: Int, _ num_people: Int) -> [Int] {\\n        \\n        var result: [Int] = Array(repeating: 0, count: num_people)\\n        var candies = candies\\n        var currentIndex = 0\\n        var currentGive = 1\\n        \\n        while candies > 0 {\\n            if candies > currentGive {\\n                result[currentIndex] += currentGive\\n                candies -= currentGive\\n                currentGive += 1\\n            } else {\\n                result[currentIndex] += candies\\n                candies = 0\\n            }\\n            currentIndex = currentIndex < num_people - 1 ? currentIndex + 1 : 0\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distributeCandies(_ candies: Int, _ num_people: Int) -> [Int] {\\n        \\n        var result: [Int] = Array(repeating: 0, count: num_people)\\n        var candies = candies\\n        var currentIndex = 0\\n        var currentGive = 1\\n        \\n        while candies > 0 {\\n            if candies > currentGive {\\n                result[currentIndex] += currentGive\\n                candies -= currentGive\\n                currentGive += 1\\n            } else {\\n                result[currentIndex] += candies\\n                candies = 0\\n            }\\n            currentIndex = currentIndex < num_people - 1 ? currentIndex + 1 : 0\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839218,
                "title": "javascript-mathematical-solution",
                "content": "##### Amortized Analysis\\n\\nTIme Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n---\\n##### Code\\n---\\n```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nconst seriesSum = n => (n * (n+1))/2;\\n\\nconst binarySearch = (low, high, candies) => {\\n  while(low < high) {\\n    let mid = (low + high) >> 1;\\n    let sum = seriesSum(mid);\\n    if( sum == candies ) {\\n      return mid;\\n    } else if (sum < candies) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n  return high;\\n}\\nvar distributeCandies = function(candies, num_people) {\\n  // find how many time it is possible to circle back\\n  let round = binarySearch(0, 1e5, candies) / num_people >> 0;\\n  // find the extra andies\\n  let extra = candies - seriesSum(round * num_people);\\n  let answer = Array(num_people).fill(0); \\n  // first person will get  n * (r*(r+1))/2 + r + 1 candies, where n = num_people and r = round - 1\\n  answer[0] = Math.max(0, num_people * seriesSum(round - 1) + round);\\n  let candiesLeft = candies - answer[0];\\n  for(let i = 1; i < num_people; i++) {\\n\\t // every one will get exactly **r** candies more than the previous persion\\n    answer[i] = Math.min(answer[i - 1] + round, candiesLeft);\\n    candiesLeft -= answer[i];\\n  }\\n  // distribute the extra candies\\n  for(let i = 0; i < num_people && extra > 0; i++) {\\n\\t // everyone will get n * r + i + 1 extra candies. where n = num_people, r =round, i is the position of the persion (0 indexed)\\n    let exCandies = Math.min(num_people * round + i + 1 , extra);\\n    answer[i] += exCandies\\n    extra -= exCandies;\\n  }\\n  return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nconst seriesSum = n => (n * (n+1))/2;\\n\\nconst binarySearch = (low, high, candies) => {\\n  while(low < high) {\\n    let mid = (low + high) >> 1;\\n    let sum = seriesSum(mid);\\n    if( sum == candies ) {\\n      return mid;\\n    } else if (sum < candies) {\\n      low = mid + 1;\\n    } else {\\n      high = mid - 1;\\n    }\\n  }\\n  return high;\\n}\\nvar distributeCandies = function(candies, num_people) {\\n  // find how many time it is possible to circle back\\n  let round = binarySearch(0, 1e5, candies) / num_people >> 0;\\n  // find the extra andies\\n  let extra = candies - seriesSum(round * num_people);\\n  let answer = Array(num_people).fill(0); \\n  // first person will get  n * (r*(r+1))/2 + r + 1 candies, where n = num_people and r = round - 1\\n  answer[0] = Math.max(0, num_people * seriesSum(round - 1) + round);\\n  let candiesLeft = candies - answer[0];\\n  for(let i = 1; i < num_people; i++) {\\n\\t // every one will get exactly **r** candies more than the previous persion\\n    answer[i] = Math.min(answer[i - 1] + round, candiesLeft);\\n    candiesLeft -= answer[i];\\n  }\\n  // distribute the extra candies\\n  for(let i = 0; i < num_people && extra > 0; i++) {\\n\\t // everyone will get n * r + i + 1 extra candies. where n = num_people, r =round, i is the position of the persion (0 indexed)\\n    let exCandies = Math.min(num_people * round + i + 1 , extra);\\n    answer[i] += exCandies\\n    extra -= exCandies;\\n  }\\n  return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798651,
                "title": "c-best-in-time-complexity-o-log-candies-simple-binary-search-easy-explain",
                "content": "**Binary Search**\\n* Apply simple binary search to  find the number of how many times candies can be distributed continuosly.\\n* \\n![image](https://assets.leetcode.com/users/images/9bdfc860-e8b2-45b2-a9df-d7177004c7fd_1597749409.8828528.png)\\n\\n```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n=num_people;\\n        vector<int> v(n);\\n     int left=1;\\n        int right=sqrt(INT_MAX)-1,mid;\\n      while(left<=right)\\n      {\\n            mid=(left+right)/2;\\n        if((mid*(mid+1))/2<candies)\\n        {\\n            left=mid+1;\\n            \\n        }\\n          else if((mid*(mid+1))/2> candies)\\n              right=mid-1;\\n          else\\n              break;\\n          \\n      }\\n     if((mid*(mid+1))/2>candies)\\n         mid--;\\n        \\n    int k=mid/n;\\n        candies-=(k*n*(k*n+1))/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]=(i+1)*(k) + ((k-1)*(k)/2)*n+min(candies,k*n+i+1);\\n            candies-=min(candies,k*n+i+1);\\n        }\\n        \\n  //  v.pb(mid);\\n        return v;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        int n=num_people;\\n        vector<int> v(n);\\n     int left=1;\\n        int right=sqrt(INT_MAX)-1,mid;\\n      while(left<=right)\\n      {\\n            mid=(left+right)/2;\\n        if((mid*(mid+1))/2<candies)\\n        {\\n            left=mid+1;\\n            \\n        }\\n          else if((mid*(mid+1))/2> candies)\\n              right=mid-1;\\n          else\\n              break;\\n          \\n      }\\n     if((mid*(mid+1))/2>candies)\\n         mid--;\\n        \\n    int k=mid/n;\\n        candies-=(k*n*(k*n+1))/2;\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]=(i+1)*(k) + ((k-1)*(k)/2)*n+min(candies,k*n+i+1);\\n            candies-=min(candies,k*n+i+1);\\n        }\\n        \\n  //  v.pb(mid);\\n        return v;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798038,
                "title": "simple-c-solution",
                "content": "Please comment for any doubt\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        if (num_people==0 or candies==0)\\n            return {};\\n        if(num_people==1)\\n            return {candies};\\n        vector<int> res(num_people,0);\\n        int i=1;\\n        int ind=0;\\n        while (candies>0)\\n        {\\n            res[ind]+=min(i,candies);\\n            candies-=i;\\n            i+=1;\\n            ind=(ind+1)%num_people;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        if (num_people==0 or candies==0)\\n            return {};\\n        if(num_people==1)\\n            return {candies};\\n        vector<int> res(num_people,0);\\n        int i=1;\\n        int ind=0;\\n        while (candies>0)\\n        {\\n            res[ind]+=min(i,candies);\\n            candies-=i;\\n            i+=1;\\n            ind=(ind+1)%num_people;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798037,
                "title": "distribute-candies-to-people-python-simplest-solution-28-ms-faster-than-98-59-of-python3",
                "content": "```\\ndef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        counter  = 1\\n        result = [0] * num_people\\n        \\n        while candies :\\n            index = (counter - 1) % num_people\\n            if candies - counter >= 0:\\n                result[index] += counter\\n                candies -= counter\\n            else :\\n                result[index] += candies\\n                candies = 0\\n                \\n            counter += 1\\n        \\n        return result \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        counter  = 1\\n        result = [0] * num_people\\n        \\n        while candies :\\n            index = (counter - 1) % num_people\\n            if candies - counter >= 0:\\n                result[index] += counter\\n                candies -= counter\\n            else :\\n                result[index] += candies\\n                candies = 0\\n                \\n            counter += 1\\n        \\n        return result \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 797716,
                "title": "beats-100-using-formula-for-sum-of-series",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int j = (int) ((-1 + Math.sqrt(1 + (long) 8 * candies)) / 2);\\n        \\n        int leftovercandies = candies - (j * (j + 1) / 2);\\n        \\n        int[] ans = new int[num_people];\\n        \\n        int r = j / num_people - 1;\\n        \\n        for (int i = 0; i < num_people; i++) {\\n            ans[i] = (r + 1) * (i + 1) + num_people * (r * (r + 1)) / 2;\\n        }\\n        \\n        for (int i = 0; i < j % num_people; i++) {\\n            ans[i] += (r + 1) * num_people + i + 1;\\n        }\\n        \\n        ans[j % num_people] += leftovercandies;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nUse quadratic formula to find mininum j such that j * (j + 1) / 2 = num_candies.\\n\\nCalculate leftover candies for last person (when no longer enough candy to continue pattern) using candies - j * (j + 1) / 2.\\n\\nCalculate r (number of full rounds of distributing candy), and subtract 1 to use 0 indexing.\\n\\nWrite out the numbers on a sheet of paper, and you can see that the numbers down each column (with each round on top of each other) and you see that the numbers down each column is also a series, so we can use a formula to directly calculate the candies after r full rounds for each person.\\n\\nAnother loop for the final, possible non-full round, (starts at index i and ends at j % num_people.\\n\\nAdd leftover candies to final person.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int j = (int) ((-1 + Math.sqrt(1 + (long) 8 * candies)) / 2);\\n        \\n        int leftovercandies = candies - (j * (j + 1) / 2);\\n        \\n        int[] ans = new int[num_people];\\n        \\n        int r = j / num_people - 1;\\n        \\n        for (int i = 0; i < num_people; i++) {\\n            ans[i] = (r + 1) * (i + 1) + num_people * (r * (r + 1)) / 2;\\n        }\\n        \\n        for (int i = 0; i < j % num_people; i++) {\\n            ans[i] += (r + 1) * num_people + i + 1;\\n        }\\n        \\n        ans[j % num_people] += leftovercandies;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797508,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int []res = new int[num_people];\\n        \\n        int counter = 1;\\n        int currentPerson = 0;\\n        while(candies >= 0) {\\n            res[currentPerson] += (counter < candies) ? counter: candies;\\n            candies -= counter++;\\n            currentPerson = (currentPerson + 1)%num_people;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int []res = new int[num_people];\\n        \\n        int counter = 1;\\n        int currentPerson = 0;\\n        while(candies >= 0) {\\n            res[currentPerson] += (counter < candies) ? counter: candies;\\n            candies -= counter++;\\n            currentPerson = (currentPerson + 1)%num_people;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 797055,
                "title": "simple-loop-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        int candyCount = 1;\\n        while(candies>0){\\n            \\n                for(int i = 0 ; i < num_people; ++i){\\n                    if(candyCount<=candies){\\n                        people[i]+=candyCount;\\n                        candies-=candyCount;\\n                        ++candyCount;\\n                    }else{\\n                        people[i]+=candies;\\n                        candies=0;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n            \\n        }\\n        return people;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] people = new int[num_people];\\n        int candyCount = 1;\\n        while(candies>0){\\n            \\n                for(int i = 0 ; i < num_people; ++i){\\n                    if(candyCount<=candies){\\n                        people[i]+=candyCount;\\n                        candies-=candyCount;\\n                        ++candyCount;\\n                    }else{\\n                        people[i]+=candies;\\n                        candies=0;\\n\\t\\t\\t\\t\\t\\tbreak;\\n                    }\\n                }\\n            \\n        }\\n        return people;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796909,
                "title": "java-one-go-o-num-people-math",
                "content": "I have tried to represent the formula in hand-written.\\n**Caution : bad hand-writing ahead**\\n![image](https://assets.leetcode.com/users/images/61bfada6-bc5c-4a70-8dee-261a1afe598d_1597671597.664236.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f8282f08-f5ba-4609-9c92-68f45751701f_1597671574.2589667.png)\\n\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int c, int num_people) {\\n        int [] p = new int[num_people];\\n        int candiesRemaining = c;\\n        // x*(x+1)/2 = c\\n        double x = (-1 + Math.sqrt(1+(double)8*c))/2;\\n        // x = k*n + r;\\n        int k = ((int)x)/num_people;\\n        int r = ((int)x)%num_people;\\n        for(int i=0;i<num_people;i++){\\n            if(i<r){\\n                p[i] = (k+1)*(i+1) + num_people*(k)*(k+1)/2;\\n            }\\n            else{\\n                p[i] = (k)*(i+1) + num_people*(k)*(k-1)/2;\\n            }\\n            candiesRemaining-=p[i];\\n        }\\n        p[r] += candiesRemaining;\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int c, int num_people) {\\n        int [] p = new int[num_people];\\n        int candiesRemaining = c;\\n        // x*(x+1)/2 = c\\n        double x = (-1 + Math.sqrt(1+(double)8*c))/2;\\n        // x = k*n + r;\\n        int k = ((int)x)/num_people;\\n        int r = ((int)x)%num_people;\\n        for(int i=0;i<num_people;i++){\\n            if(i<r){\\n                p[i] = (k+1)*(i+1) + num_people*(k)*(k+1)/2;\\n            }\\n            else{\\n                p[i] = (k)*(i+1) + num_people*(k)*(k-1)/2;\\n            }\\n            candiesRemaining-=p[i];\\n        }\\n        p[r] += candiesRemaining;\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796903,
                "title": "single-pass-o-num-people-i-e-o-n-explained-java-beats-100-solutions-0ms",
                "content": "We can think of distributing candies to people standing in an infinite row and later arrange them in\\n\\nWe will first find out how many times we can give as many candies to people as many they can take at that particular chance. Lets denote this number as ```n```.\\n{For eg.- if there are 2 people and 9 candies, we can give required candies 3 times (so n=3). 1 candy to first person (1), then 2 candies to second person (2), then 3 candies to first person (3). Now we have 3 candies left (```extra```) but second person requires 4 candies.}\\n\\n```candies = n*(n+1)/2 + extra```\\n```candies - extra = n*(n+1)/2```\\ntherefore,``` n*n + n - 2*(candies -extra) = 0```\\nSolving this equation for n ( I am using [Quadratic Formula](https://en.wikipedia.org/wiki/Quadratic_formula) here) we can get n as:\\n```n = (-1 \\xB1 \\u221A(1-4 * (-2) * (candies-extra)) )/2```\\nWe can ignore the negative root, because the number of candies cannot be negative.\\nAlso, we are interested to find the maximum number for which candies are sufficient, so we can strike off extra. \\nThis gives us ```n = (-1 + \\u221A(1+(8 * candies)) )/2```\\nWe will use floor value (integer value) of n because number of candies cannot be a fraction here.\\n\\nLets represent number of passes in which everyone gets the maximum number of candies they can get as ```passes```, then:\\n```passes = n/num_people```  {passes = 1, in case of above example, because in second pass/iteration, second person could not get required number of candies}\\nNow, the candies remaining after ```passes``` passes/iteration , ```rem``` equals number of candies distributed in ```passes``` passes/iteration subtracte from total candies, ```candies```\\n```rem = candies - passes*num_people*(passes*num_people+1)/2```\\n\\nFor each person, we can get the number of candies that he/she receives as the sum of an Arithmetic Progression in ```passes``` iterations + the candies he/she will receive in the final iteration (if any).\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int n = ((int)Math.sqrt(1+8*(long)candies) - 1)/2;\\n        int passes = n/num_people;\\n        int rem = candies - passes*num_people*(passes*num_people+1)/2;\\n        for(int i=0; i<num_people; i++)\\n        {\\n            int remAdd = Math.min(rem, passes*num_people + i+1);\\n            rem -= remAdd;\\n            res[i] = passes*(2*(i+1) + (passes-1)*num_people)/2 + remAdd;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```n```\n```extra```\n```candies = n*(n+1)/2 + extra```\n```candies - extra = n*(n+1)/2```\n``` n*n + n - 2*(candies -extra) = 0```\n```n = (-1 \\xB1 \\u221A(1-4 * (-2) * (candies-extra)) )/2```\n```n = (-1 + \\u221A(1+(8 * candies)) )/2```\n```passes```\n```passes = n/num_people```\n```passes```\n```rem```\n```passes```\n```candies```\n```rem = candies - passes*num_people*(passes*num_people+1)/2```\n```passes```\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int n = ((int)Math.sqrt(1+8*(long)candies) - 1)/2;\\n        int passes = n/num_people;\\n        int rem = candies - passes*num_people*(passes*num_people+1)/2;\\n        for(int i=0; i<num_people; i++)\\n        {\\n            int remAdd = Math.min(rem, passes*num_people + i+1);\\n            rem -= remAdd;\\n            res[i] = passes*(2*(i+1) + (passes-1)*num_people)/2 + remAdd;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796823,
                "title": "java-distribute-candies-to-people-beats-100-time-o-n-space-o-1",
                "content": "```\\npublic class DistributeCandiestoPeople {\\n\\n    public int[] distributeCandies(int candies, int num_people) {\\n        long candiesLong=candies;\\n        // TO calculate nearest n for  the Summation of n natural number that is the candies\\n        //candies=n(n+1)/2\\n        double nearestSummation= ((Math.sqrt(((8*candiesLong)+1))-1)/2);\\n        //Levels are the levels downwards that need to be summed up vertically\\n        //if data is aligned vertically that is nearestSummation % num_people ==0 the data is summed up vertically for all the levels\\n        //if it is not then the levels summed up vertically is done till second last level after that\\n        //the data is added manually with left over candies and the n th addition to the n % num_people\\n        int levels;\\n\\n        if(Math.floor(nearestSummation)==nearestSummation)\\n            levels=  (((int)nearestSummation)/num_people);\\n        else {\\n            nearestSummation=Math.floor(nearestSummation);\\n            levels = (((int) nearestSummation ) / num_people);\\n        }\\n\\n        int sumbase=1;\\n        for(int i=1;i<=levels-1;i++){\\n            sumbase=sumbase+num_people*i+1;\\n        }\\n\\n        if(nearestSummation<num_people)\\n            levels=1;\\n        int[] arr =new int[num_people];\\n        for(int i=0;i<num_people && candies>0;i++){\\n            arr[i]=sumbase<candies?sumbase:candies;\\n            sumbase=sumbase+levels;\\n            candies-=arr[i];\\n        }\\n       //sumbase resetted as the n th addition on the array\\n        sumbase=num_people*levels+1;\\n        //n++ th addition for ever consecutive person till the candies run out and last person gets all the remaining candy\\n        levels=1;\\n        //Does not execute if candies are finished\\n        for(int i=0;i<num_people && candies>0;i++){\\n            int tempAlot=sumbase<candies?sumbase:candies;\\n            arr[i]+=tempAlot;\\n            sumbase=sumbase+levels;\\n            candies-=tempAlot;\\n        }\\n\\n        return arr;\\n    }\\n\\n    public static void main(String[] args) {\\n        DistributeCandiestoPeople distributeCandiestoPeople= new DistributeCandiestoPeople();\\n        int[] arr= distributeCandiestoPeople.distributeCandies(1000000000,1000);\\n        for(int x:arr)\\n            System.out.println(x);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class DistributeCandiestoPeople {\\n\\n    public int[] distributeCandies(int candies, int num_people) {\\n        long candiesLong=candies;\\n        // TO calculate nearest n for  the Summation of n natural number that is the candies\\n        //candies=n(n+1)/2\\n        double nearestSummation= ((Math.sqrt(((8*candiesLong)+1))-1)/2);\\n        //Levels are the levels downwards that need to be summed up vertically\\n        //if data is aligned vertically that is nearestSummation % num_people ==0 the data is summed up vertically for all the levels\\n        //if it is not then the levels summed up vertically is done till second last level after that\\n        //the data is added manually with left over candies and the n th addition to the n % num_people\\n        int levels;\\n\\n        if(Math.floor(nearestSummation)==nearestSummation)\\n            levels=  (((int)nearestSummation)/num_people);\\n        else {\\n            nearestSummation=Math.floor(nearestSummation);\\n            levels = (((int) nearestSummation ) / num_people);\\n        }\\n\\n        int sumbase=1;\\n        for(int i=1;i<=levels-1;i++){\\n            sumbase=sumbase+num_people*i+1;\\n        }\\n\\n        if(nearestSummation<num_people)\\n            levels=1;\\n        int[] arr =new int[num_people];\\n        for(int i=0;i<num_people && candies>0;i++){\\n            arr[i]=sumbase<candies?sumbase:candies;\\n            sumbase=sumbase+levels;\\n            candies-=arr[i];\\n        }\\n       //sumbase resetted as the n th addition on the array\\n        sumbase=num_people*levels+1;\\n        //n++ th addition for ever consecutive person till the candies run out and last person gets all the remaining candy\\n        levels=1;\\n        //Does not execute if candies are finished\\n        for(int i=0;i<num_people && candies>0;i++){\\n            int tempAlot=sumbase<candies?sumbase:candies;\\n            arr[i]+=tempAlot;\\n            sumbase=sumbase+levels;\\n            candies-=tempAlot;\\n        }\\n\\n        return arr;\\n    }\\n\\n    public static void main(String[] args) {\\n        DistributeCandiestoPeople distributeCandiestoPeople= new DistributeCandiestoPeople();\\n        int[] arr= distributeCandiestoPeople.distributeCandies(1000000000,1000);\\n        for(int x:arr)\\n            System.out.println(x);\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796753,
                "title": "my-o-sqrt-candies-solution-using-ap-formula-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n\\t/*\\n\\tget the last number of arithmetic progression (AP) that can be made by candies\\n\\te.g if candies = 7, n = 3, i.e AP will be 1 2 3\\n\\tthe equation to get n is => n/2 * (n + 1) = candies\\n\\t=> n * (n + 1) = 2 * candies\\n\\t=> n^2 + n = 2 * candies\\n\\t=> (n + 0.5)^2 - 0.25 = 2 * candies\\n\\t=> (n + 0.5)^2 = 2 * candies + 0.25\\n\\t=> n + 0.5 = sqrt(2 * candies + 0.25)\\n\\t=> n = sqrt(2 * candies + 0.25) - 0.5\\n\\tafter that we will distribute each number of the AP to the poeple till we reach last person, then we will give the last person the remainder of the candies \\n\\t*/\\n        int n = sqrt(2*candies + 0.25) - 0.5;\\n        vector<int> ans(num_people);\\n        \\n        int idx = 0;\\n\\t// loop on each number of AP and distribute it to the current person\\n        for (int i = 1; i <= n; i++) {\\n            ans[idx] += i;\\n            candies -= i;\\n\\t    /* make addition with mod to return to the first person in case of idx = num_people, i.e we reach after last person so we return back to first person\\n\\t    this is equal to => idx++; if (idx == num_people) idx = 0;\\n            */\\n            idx = (idx + 1) % num_people;\\n        }\\n\\t// give last person the remainder of candies if exists\\n        ans[idx] += candies;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n\\t/*\\n\\tget the last number of arithmetic progression (AP) that can be made by candies\\n\\te.g if candies = 7, n = 3, i.e AP will be 1 2 3\\n\\tthe equation to get n is => n/2 * (n + 1) = candies\\n\\t=> n * (n + 1) = 2 * candies\\n\\t=> n^2 + n = 2 * candies\\n\\t=> (n + 0.5)^2 - 0.25 = 2 * candies\\n\\t=> (n + 0.5)^2 = 2 * candies + 0.25\\n\\t=> n + 0.5 = sqrt(2 * candies + 0.25)\\n\\t=> n = sqrt(2 * candies + 0.25) - 0.5\\n\\tafter that we will distribute each number of the AP to the poeple till we reach last person, then we will give the last person the remainder of the candies \\n\\t*/\\n        int n = sqrt(2*candies + 0.25) - 0.5;\\n        vector<int> ans(num_people);\\n        \\n        int idx = 0;\\n\\t// loop on each number of AP and distribute it to the current person\\n        for (int i = 1; i <= n; i++) {\\n            ans[idx] += i;\\n            candies -= i;\\n\\t    /* make addition with mod to return to the first person in case of idx = num_people, i.e we reach after last person so we return back to first person\\n\\t    this is equal to => idx++; if (idx == num_people) idx = 0;\\n            */\\n            idx = (idx + 1) % num_people;\\n        }\\n\\t// give last person the remainder of candies if exists\\n        ans[idx] += candies;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796717,
                "title": "python-sol-by-simulation-w-comment",
                "content": "Python sol by simulation\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, num_people):\\n\\n\\n        n = num_people\\n        \\n        # candies distribution for each person\\n        result = [0] * n\\n         \\n        c = 0\\n        while candies > 0:\\n            \\n            # candies may be not enough on last round, therefore compute min(candies, c+1)\\n            result[c % n] += min(candies, c+1)\\n            \\n            # add one more candies for next person\\n            c += 1\\n            \\n            # update total number of candies\\n            candies -= c\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, num_people):\\n\\n\\n        n = num_people\\n        \\n        # candies distribution for each person\\n        result = [0] * n\\n         \\n        c = 0\\n        while candies > 0:\\n            \\n            # candies may be not enough on last round, therefore compute min(candies, c+1)\\n            result[c % n] += min(candies, c+1)\\n            \\n            # add one more candies for next person\\n            c += 1\\n            \\n            # update total number of candies\\n            candies -= c\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796537,
                "title": "distribute-candies-c-clear-100",
                "content": "Maybe not the most concise, but very easy to understand.\\nJust do literally what the description says.\\n```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> distributed(num_people);\\n        int candiesToGive = 1, i = 0;\\n\\t\\t// While there are remaining candies, increment the number of candies to give\\n        while (candies > 0) {\\n            if (i >= num_people) i = 0; // Reset index when we pass the last person\\n            distributed[i++] += min(candiesToGive, candies); // The amount of candies for the next person. Min of remaining or required to give\\n            candies -= candiesToGive++; // Reduce remaining candies\\n        }\\n        return distributed;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> distributed(num_people);\\n        int candiesToGive = 1, i = 0;\\n\\t\\t// While there are remaining candies, increment the number of candies to give\\n        while (candies > 0) {\\n            if (i >= num_people) i = 0; // Reset index when we pass the last person\\n            distributed[i++] += min(candiesToGive, candies); // The amount of candies for the next person. Min of remaining or required to give\\n            candies -= candiesToGive++; // Reduce remaining candies\\n        }\\n        return distributed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796449,
                "title": "simple-optimised-c-solution-with-o-num-people-complexity",
                "content": "/*this is the best solution with simple mathematics.\\nmake a matrix like this suppose three people and 28 candies\\n[1,2,3]\\n[4,5,6]\\n[7,0,0]\\nwill be distributed in this manner now to understand how we calcuate this sum 1+4+7 for people 1 and 2+5 for people 2 and 3+6 for people 3*/\\n/* the 1+4+7 notice it sum of first 3 terms with common difference as number of people and terms as t+rem if(rem!=0) for t and rem check the code how we calculate them and for sum of first t terms check the loop*/\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int>ans(num_people,0);\\n        if(candies==0) return ans;\\n        int num=1,s=1;\\n        while(s<=candies){\\n            num++;\\n            s+=num;\\n        }\\n        num--;\\n        int t=num/num_people;\\n        int rem=num%num_people;\\n        int rem1=rem;\\n        for(int i=1;i<=num_people;i++){\\n            int no_of_terms=t;\\n            if(rem!=0){\\n                no_of_terms++;\\n                rem--;\\n            }\\n            int sum1=no_of_terms*(2*i+(no_of_terms-1)*num_people);\\n            sum1/=2;\\n            candies-=sum1;\\n            ans[i-1]=sum1;\\n        }\\n        /*this step is for suppose canidies instead of 28 they are 30 then remaining 2 candies will go to \\n        people 2 and sum will be 2+5+2 for people 2 as mentioned in question*/\\n        ans[rem1]+=candies;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n       vector<int>ans(num_people,0);\\n        if(candies==0) return ans;\\n        int num=1,s=1;\\n        while(s<=candies){\\n            num++;\\n            s+=num;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 796441,
                "title": "c-intuitive-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people);\\n        \\n        for (int i = 0, round = 0; candies > 0;) {\\n            int distribute = round * num_people + i + 1;\\n            \\n            if (candies >= distribute) {\\n                candies -= distribute;\\n                ans[i] += distribute;\\n            } else {\\n                ans[i] += candies;\\n                candies = 0;\\n            }\\n            \\n            if (++i >= num_people) {\\n                i = 0;\\n                ++round;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people);\\n        \\n        for (int i = 0, round = 0; candies > 0;) {\\n            int distribute = round * num_people + i + 1;\\n            \\n            if (candies >= distribute) {\\n                candies -= distribute;\\n                ans[i] += distribute;\\n            } else {\\n                ans[i] += candies;\\n                candies = 0;\\n            }\\n            \\n            if (++i >= num_people) {\\n                i = 0;\\n                ++round;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796414,
                "title": "c-o-num-people-log-candies-solution",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(ll candies, ll num_people) {\\n        ll l = 0LL, r = 1e5 + 1LL, no_of_iterations = 0, ls_exp;\\n        while(l <= r){\\n            ll mid = (l + r) >> 1;\\n            ll exp = ((num_people * num_people * mid * (mid - 1LL)) + \\n                     (mid * num_people * (num_people + 1LL)) ) >> 1;\\n            if(exp <= candies){\\n                l = mid + 1LL;\\n                no_of_iterations = mid;\\n                ls_exp = exp;\\n            }\\n            else{\\n                r = mid - 1LL;\\n            }\\n        }\\n        vector<int> ans(num_people);\\n        candies -= ls_exp;\\n        ll com_term = (no_of_iterations * (no_of_iterations - 1LL) * num_people ) >> 1;\\n        for(ll i = 0LL; i < num_people; i ++){\\n            ll expected = ((no_of_iterations * num_people) + (i + 1LL)), add;\\n            if(expected <= candies){\\n                candies -= expected;\\n                add = expected;\\n            }\\n            else{\\n                add = candies;\\n                candies = 0LL;\\n            }\\n            ans[i] = com_term + (no_of_iterations * (i + 1LL)) + add;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(ll candies, ll num_people) {\\n        ll l = 0LL, r = 1e5 + 1LL, no_of_iterations = 0, ls_exp;\\n        while(l <= r){\\n            ll mid = (l + r) >> 1;\\n            ll exp = ((num_people * num_people * mid * (mid - 1LL)) + \\n                     (mid * num_people * (num_people + 1LL)) ) >> 1;\\n            if(exp <= candies){\\n                l = mid + 1LL;\\n                no_of_iterations = mid;\\n                ls_exp = exp;\\n            }\\n            else{\\n                r = mid - 1LL;\\n            }\\n        }\\n        vector<int> ans(num_people);\\n        candies -= ls_exp;\\n        ll com_term = (no_of_iterations * (no_of_iterations - 1LL) * num_people ) >> 1;\\n        for(ll i = 0LL; i < num_people; i ++){\\n            ll expected = ((no_of_iterations * num_people) + (i + 1LL)), add;\\n            if(expected <= candies){\\n                candies -= expected;\\n                add = expected;\\n            }\\n            else{\\n                add = candies;\\n                candies = 0LL;\\n            }\\n            ans[i] = com_term + (no_of_iterations * (i + 1LL)) + add;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796408,
                "title": "my-0ms-c-solution-easy-to-understand",
                "content": "```\\n    static vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people, 0);\\n        int i = 0;\\n        while (candies > 0) {\\n            ans[i % num_people] += i + 1;\\n            candies -= i + 1;\\n            ++i;\\n        }\\n        \\n        if (candies < 0) { //Fix for giving too many candies to last person\\n            ans[(i - 1) % num_people] += candies;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n    static vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ans(num_people, 0);\\n        int i = 0;\\n        while (candies > 0) {\\n            ans[i % num_people] += i + 1;\\n            candies -= i + 1;\\n            ++i;\\n        }\\n        \\n        if (candies < 0) { //Fix for giving too many candies to last person\\n            ans[(i - 1) % num_people] += candies;\\n        }\\n        \\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 796403,
                "title": "0-ms-c-solution-distribute-candies-to-people",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> l;\\n        int turn=1;\\n        for(int i=0;i<num_people;i++){\\n            l.push_back(0);    \\n        }\\n        while(candies>0){\\n            for(int i=0;i<num_people;i++){\\n                if(turn<candies){\\n                    l[i]+=turn;\\n                    candies-=turn;\\n                    turn+=1;\\n                }\\n                else if(candies>0){\\n                    l[i]+=candies;\\n                    candies-=candies;\\n                    break;\\n                }                \\n            }\\n        }\\n    return(l);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector <int> l;\\n        int turn=1;\\n        for(int i=0;i<num_people;i++){\\n            l.push_back(0);    \\n        }\\n        while(candies>0){\\n            for(int i=0;i<num_people;i++){\\n                if(turn<candies){\\n                    l[i]+=turn;\\n                    candies-=turn;\\n                    turn+=1;\\n                }\\n                else if(candies>0){\\n                    l[i]+=candies;\\n                    candies-=candies;\\n                    break;\\n                }                \\n            }\\n        }\\n    return(l);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788026,
                "title": "ruby-solution-while-loop-and-get-index-of-person-by-modulo-operation",
                "content": "##### Leetcode: 1103. Distribute Candies to People.\\n\\nCreate loop that iterates until there more than zero candies and two variables amount of candies to give and index, index grows on each iteration and amount grows too. To get index of person to add amount of candies modulo operation could be implemented or rest of division index variable by number of people. In each iteration delete amount from candies. If there less candies than amount for gift give all the rest of candies to a person.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1103. Distribute Candies to People.\\n# https://leetcode.com/problems/distribute-candies-to-people/\\n# Runtime: 36 ms, faster than 85.71% of Ruby online submissions for Distribute Candies to People.\\n# Memory Usage: 9.7 MB, less than 14.29% of Ruby online submissions for Distribute Candies to People.\\n# @param {Integer} candies\\n# @param {Integer} num_people\\n# @return {Integer[]}\\ndef distribute_candies(candies, num_people)\\n    arr = Array.new(num_people,0)\\n    i,amount = 0,1\\n    while candies > 0\\n        if amount <= candies\\n            arr[i%num_people] += amount\\n            candies -= amount\\n            amount += 1\\n        else\\n            arr[i%num_people] += candies\\n            candies = 0\\n        end\\n        i += 1\\n    end\\n    arr\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1103. Distribute Candies to People.\\n# https://leetcode.com/problems/distribute-candies-to-people/\\n# Runtime: 36 ms, faster than 85.71% of Ruby online submissions for Distribute Candies to People.\\n# Memory Usage: 9.7 MB, less than 14.29% of Ruby online submissions for Distribute Candies to People.\\n# @param {Integer} candies\\n# @param {Integer} num_people\\n# @return {Integer[]}\\ndef distribute_candies(candies, num_people)\\n    arr = Array.new(num_people,0)\\n    i,amount = 0,1\\n    while candies > 0\\n        if amount <= candies\\n            arr[i%num_people] += amount\\n            candies -= amount\\n            amount += 1\\n        else\\n            arr[i%num_people] += candies\\n            candies = 0\\n        end\\n        i += 1\\n    end\\n    arr\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 694657,
                "title": "rust-simulate-distribute-processing-0ms",
                "content": "```Rust\\nimpl Solution {\\n    pub fn distribute_candies(candies: i32, num_people: i32) -> Vec<i32> {\\n        let mut res = vec![0; num_people as usize];\\n        let mut i = 0;\\n        let mut candies = candies;\\n        \\'outer: loop {\\n            for x in res.iter_mut() {\\n                i += 1;\\n                if candies < i {\\n                    *x += candies;\\n                    break \\'outer;\\n                } else {\\n                    candies -= i;\\n                    *x += i\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn distribute_candies(candies: i32, num_people: i32) -> Vec<i32> {\\n        let mut res = vec![0; num_people as usize];\\n        let mut i = 0;\\n        let mut candies = candies;\\n        \\'outer: loop {\\n            for x in res.iter_mut() {\\n                i += 1;\\n                if candies < i {\\n                    *x += candies;\\n                    break \\'outer;\\n                } else {\\n                    candies -= i;\\n                    *x += i\\n                }\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670471,
                "title": "c-solution",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\nint* ret_array = malloc(num_people * sizeof(int));\\nint count, person;\\nfor (count=0; count<num_people; count++) ret_array[count]=0;\\ncount=1;\\nperson=0;\\n*returnSize = num_people;\\n    \\n// Loop until all candies gone, adding one to what\\'s given to each,\\n// and resetting person back to 0 when you\\'ve gone through all of them.\\nwhile (true) {\\n    if (candies<=0) return ret_array;\\n    if (count>candies) count=candies;\\n    ret_array[person++] += count;\\n    candies -= count++;\\n    if (person==num_people) person=0;\\n}\\nreturn -1; // We should never get here, though\\n}\\n",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* distributeCandies(int candies, int num_people, int* returnSize){\\nint* ret_array = malloc(num_people * sizeof(int));\\nint count, person;\\nfor (count=0; count<num_people; count++) ret_array[count]=0;\\ncount=1;\\nperson=0;\\n*returnSize = num_people;\\n    \\n// Loop until all candies gone, adding one to what\\'s given to each,\\n// and resetting person back to 0 when you\\'ve gone through all of them.\\nwhile (true) {\\n    if (candies<=0) return ret_array;\\n    if (count>candies) count=candies;\\n    ret_array[person++] += count;\\n    candies -= count++;\\n    if (person==num_people) person=0;\\n}\\nreturn -1; // We should never get here, though\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 659367,
                "title": "python3-28ms-beats-98-easy-iteration-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        num = 1\\n        while candies > 0:\\n        \\tfor i in range(num_people):\\n        \\t\\tres[i] += num\\n        \\t\\tcandies -= num\\n        \\t\\tif candies <= 0:\\n        \\t\\t\\tres[i] -= abs(candies)\\n        \\t\\t\\tbreak\\n        \\t\\tnum += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        num = 1\\n        while candies > 0:\\n        \\tfor i in range(num_people):\\n        \\t\\tres[i] += num\\n        \\t\\tcandies -= num\\n        \\t\\tif candies <= 0:\\n        \\t\\t\\tres[i] -= abs(candies)\\n        \\t\\t\\tbreak\\n        \\t\\tnum += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629995,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let i = 0;\\n    let ans = new Array(num_people).fill(0);\\n    while(candies - i > 0) {\\n        ans[i % num_people] += i+1;\\n        i++;\\n        candies -= i;\\n    }\\n    ans[i % num_people] += candies;\\n    return ans;\\n};",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} candies\\n * @param {number} num_people\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, num_people) {\\n    let i = 0;\\n    let ans = new Array(num_people).fill(0);\\n    while(candies - i > 0) {\\n        ans[i % num_people] += i+1;\\n        i++;\\n        candies -= i;\\n    }\\n    ans[i % num_people] += candies;\\n    return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 585008,
                "title": "c-one-loop-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int c, int n) {\\n        vector<int> ans(n);\\n        for (int i=1; c > 0; ++i){\\n            ans[(i-1)%n] += min(i, c);\\n            c -= i;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int c, int n) {\\n        vector<int> ans(n);\\n        for (int i=1; c > 0; ++i){\\n            ans[(i-1)%n] += min(i, c);\\n            c -= i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 529674,
                "title": "python3-easy-to-understand-time-81-memory-100",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        n = 1\\n        while candies:\\n            for i in range(num_people):\\n                res[i] += n\\n                candies -= n\\n                if candies < 0:\\n                    res[i] -= n\\n                    res[i] += n + candies\\n                    return res\\n            \\n                n += 1\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        res = [0] * num_people\\n        n = 1\\n        while candies:\\n            for i in range(num_people):\\n                res[i] += n\\n                candies -= n\\n                if candies < 0:\\n                    res[i] -= n\\n                    res[i] += n + candies\\n                    return res\\n            \\n                n += 1\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487953,
                "title": "python-3-purely-math-98-100-super-fast",
                "content": "The math algorithm is:\\n1, find how many rows are fully filled (1 row means rounds of having candies distributed for everyone)\\n2, distribute the residue candies in a round:\\ncompute how many people can still get routine number\\nthere is one guy who can\\'t get routine number\\nothers have no candies\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        full_row = int((-1 + math.sqrt(8*candies+1))/2/num_people)\\n        res = candies - full_row*num_people*(1+full_row*num_people)//2\\n        out = [j * full_row + (full_row-1) * full_row // 2 * num_people for j in range(1,num_people+1)]\\n        if res:\\n            full_col = int((-2*num_people*full_row-1+math.sqrt((2*num_people*full_row+1)**2 + 8*res))/2)\\n            res = res - (1+full_col)*full_col//2 - num_people * full_row * full_col\\n            out = [out[j-1] + j+ full_row * num_people for j in range(1,full_col+1)] + \\\\\\n                    [out[full_col]+res] + out[full_col+1:]      \\n        return out\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        full_row = int((-1 + math.sqrt(8*candies+1))/2/num_people)\\n        res = candies - full_row*num_people*(1+full_row*num_people)//2\\n        out = [j * full_row + (full_row-1) * full_row // 2 * num_people for j in range(1,num_people+1)]\\n        if res:\\n            full_col = int((-2*num_people*full_row-1+math.sqrt((2*num_people*full_row+1)**2 + 8*res))/2)\\n            res = res - (1+full_col)*full_col//2 - num_people * full_row * full_col\\n            out = [out[j-1] + j+ full_row * num_people for j in range(1,full_col+1)] + \\\\\\n                    [out[full_col]+res] + out[full_col+1:]      \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487353,
                "title": "without-min",
                "content": "Brute force but without the `min` call in every iteration. Instead, add the final (non-positive) number of cookies to the last person who got some. So a little less brute :-)\\n```\\npublic int[] distributeCandies(int c, int n) {\\n    int[] p = new int[n];\\n    int i = 0;\\n    while (c > 0) {\\n        p[i % n] += ++i;\\n        c -= i;\\n    }\\n    p[--i % n] += c;\\n    return p;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int c, int n) {\\n    int[] p = new int[n];\\n    int i = 0;\\n    while (c > 0) {\\n        p[i % n] += ++i;\\n        c -= i;\\n    }\\n    p[--i % n] += c;\\n    return p;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478235,
                "title": "easy-understandable-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        long int sum=0;\\n        vector < int > v(num_people,0);\\n        bool status=1;\\n        int  count=1;\\n        \\n        while(status)\\n        {\\n            for(int i=0;i<v.size();i++)\\n            {\\n                \\n            if(count+sum>candies)\\n            {\\n                v[i]+=candies-sum;\\n                status=0;\\n                break;\\n            }\\n                \\n                v[i]+=count;\\n                sum+=count++;\\n                \\n            }      \\n        }\\n        \\n        \\n        return v;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        \\n        long int sum=0;\\n        vector < int > v(num_people,0);\\n        bool status=1;\\n        int  count=1;\\n        \\n        while(status)\\n        {\\n            for(int i=0;i<v.size();i++)\\n            {\\n                \\n            if(count+sum>candies)\\n            {\\n                v[i]+=candies-sum;\\n                status=0;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 456045,
                "title": "c-time-o-n-space-o-n",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> distributeCandies(int candies, \\n                                  int num_people) \\n    {\\n        vector<int> result(num_people, 0);\\n        \\n        int index = 0;        \\n        int count = 1;\\n        int sum = 0;\\n\\n        while(true)\\n        {             \\n            result[index] += count;\\n            \\n            // Keep accumulating the sum with the current count,\\n            // then update the counter.\\n            sum += (count++);\\n            \\n            // rotate index.\\n            index = (index +1) %num_people;\\n            \\n            // current accumulated sum cannot be bigger than the total candies\\n            // after adding the next counter value. No more next round if it is bigger.\\n            if((sum +count) >candies)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Add the remaining candies to the last person.\\n        result[index] += (candies -sum);\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> distributeCandies(int candies, \\n                                  int num_people) \\n    {\\n        vector<int> result(num_people, 0);\\n        \\n        int index = 0;        \\n        int count = 1;\\n        int sum = 0;\\n\\n        while(true)\\n        {             \\n            result[index] += count;\\n            \\n            // Keep accumulating the sum with the current count,\\n            // then update the counter.\\n            sum += (count++);\\n            \\n            // rotate index.\\n            index = (index +1) %num_people;\\n            \\n            // current accumulated sum cannot be bigger than the total candies\\n            // after adding the next counter value. No more next round if it is bigger.\\n            if((sum +count) >candies)\\n            {\\n                break;\\n            }\\n        }\\n        \\n        // Add the remaining candies to the last person.\\n        result[index] += (candies -sum);\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440742,
                "title": "java-faster-than-92-solution-with-comments",
                "content": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint i = 0;\\n\\tint j = 1;\\n\\tint[] arr = new int[num_people];\\n\\n\\twhile (candies > 0) {\\n\\t\\t// distribute candies and update values\\n\\t\\tarr[i++] += j;\\n\\t\\tcandies -= j;\\n\\n\\t\\t// check if we need to start from the first\\n\\t\\tif (i > num_people - 1)\\n\\t\\t\\ti = 0;\\n\\n\\t\\t// check if we have enough candies to increment j\\n\\t\\t// otherwise, assign remaining candies to j\\n\\t\\tj = (j + 1 <= candies) ? j + 1 : candies;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] distributeCandies(int candies, int num_people) {\\n\\tint i = 0;\\n\\tint j = 1;\\n\\tint[] arr = new int[num_people];\\n\\n\\twhile (candies > 0) {\\n\\t\\t// distribute candies and update values\\n\\t\\tarr[i++] += j;\\n\\t\\tcandies -= j;\\n\\n\\t\\t// check if we need to start from the first\\n\\t\\tif (i > num_people - 1)\\n\\t\\t\\ti = 0;\\n\\n\\t\\t// check if we have enough candies to increment j\\n\\t\\t// otherwise, assign remaining candies to j\\n\\t\\tj = (j + 1 <= candies) ? j + 1 : candies;\\n\\t}\\n\\treturn arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399925,
                "title": "c-4ms-faster-than-64-38-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int sum=0,i=1;\\n        while((sum+i)<=candies){\\n            ret[(i-1)%num_people] += i;\\n            sum+=i;\\n            ++i;\\n        }\\n        if(sum!=candies)\\n            ret[(i-1)%num_people]+= candies-sum;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> ret(num_people);\\n        int sum=0,i=1;\\n        while((sum+i)<=candies){\\n            ret[(i-1)%num_people] += i;\\n            sum+=i;\\n            ++i;\\n        }\\n        if(sum!=candies)\\n            ret[(i-1)%num_people]+= candies-sum;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394765,
                "title": "javascript-simple-beats-86",
                "content": "```\\nlet op = new Array(num_people).fill(0), i = 0, c = 1\\n\\nwhile (candies > 0) {\\n\\tif (candies <= c) c = candies\\n\\top[i] += c\\n\\tcandies -= c\\n\\ti = (i + 1) % num_people\\n\\tc++\\n}\\n\\nreturn op\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet op = new Array(num_people).fill(0), i = 0, c = 1\\n\\nwhile (candies > 0) {\\n\\tif (candies <= c) c = candies\\n\\top[i] += c\\n\\tcandies -= c\\n\\ti = (i + 1) % num_people\\n\\tc++\\n}\\n\\nreturn op\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383068,
                "title": "python-sum-of-n-numbers-with-binary-search-with-thought-process",
                "content": "So the idea is:\\n1. Find how many times we can distribute the candies to all `num_people` i.e.\\n\\t```python\\n\\tgc = 0 # Start with zeroth round\\n\\ttarget = (num_people * (num_people+1))//2 # Number of candies required for zeroth round \\n\\twhile target <= candies:\\n\\t\\tfor i in range(num_people):\\n\\t\\t\\tres[i] += (gc * num_people) + (i + 1)\\n\\n\\t\\tgc += 1\\n\\t\\tcandies -= target\\n\\t\\t# Now for next round the target will change e.g.\\n\\t\\t# For n = 3, for first round distribution, we need (n*(n+1))/2\\n\\t\\t# but for second round, every person will need n i.e. 3 extra candies, so overall n**2 extra candies\\n\\t\\ttarget += num_people ** 2\\n\\t```\\n2. Now, after step one, we will be left with candies which can\\'t be distributed equally to all n people, so the idea to to use binary search to find the index till when we can continue distributing the required amout of candies. Once we have that index, we can distribute the candies till `i`th person in required fashion and give remaining candies to the `(i+1)`th person. i.e.\\n\\t```\\n\\tif candies:\\n            offset = num_people * gc # We need this offset to indicated that we in some xth distribution round and we need this much extra candies for each person in comparison of zeroth round.\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n\\t```\\n\\t\\nFull Soultion here:\\n```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        gc = 0\\n        res = [0] * num_people\\n        \\n        def binarySearch(l, r, candies, offset):\\n            while l <= r:\\n                mid = (l + r)//2\\n                \\n                n_sum = (mid * (mid+1))//2\\n                n_sum += offset * mid\\n                if n_sum == candies:\\n                    return mid\\n                elif n_sum < candies:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            \\n            return l\\n        \\n        target = (num_people * (num_people+1))//2 \\n        while target <= candies:\\n            for i in range(num_people):\\n                res[i] += (gc * num_people) + (i + 1)\\n                \\n            gc += 1\\n            candies -= target\\n            target += num_people * num_people\\n\\n        if candies:\\n            offset = num_people * gc\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Search"
                ],
                "code": "```python\\n\\tgc = 0 # Start with zeroth round\\n\\ttarget = (num_people * (num_people+1))//2 # Number of candies required for zeroth round \\n\\twhile target <= candies:\\n\\t\\tfor i in range(num_people):\\n\\t\\t\\tres[i] += (gc * num_people) + (i + 1)\\n\\n\\t\\tgc += 1\\n\\t\\tcandies -= target\\n\\t\\t# Now for next round the target will change e.g.\\n\\t\\t# For n = 3, for first round distribution, we need (n*(n+1))/2\\n\\t\\t# but for second round, every person will need n i.e. 3 extra candies, so overall n**2 extra candies\\n\\t\\ttarget += num_people ** 2\\n\\t```\n```\\n\\tif candies:\\n            offset = num_people * gc # We need this offset to indicated that we in some xth distribution round and we need this much extra candies for each person in comparison of zeroth round.\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n\\t```\n```python\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        gc = 0\\n        res = [0] * num_people\\n        \\n        def binarySearch(l, r, candies, offset):\\n            while l <= r:\\n                mid = (l + r)//2\\n                \\n                n_sum = (mid * (mid+1))//2\\n                n_sum += offset * mid\\n                if n_sum == candies:\\n                    return mid\\n                elif n_sum < candies:\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n            \\n            return l\\n        \\n        target = (num_people * (num_people+1))//2 \\n        while target <= candies:\\n            for i in range(num_people):\\n                res[i] += (gc * num_people) + (i + 1)\\n                \\n            gc += 1\\n            candies -= target\\n            target += num_people * num_people\\n\\n        if candies:\\n            offset = num_people * gc\\n            r = binarySearch(0, num_people, candies, offset)\\n            for i in range(r):\\n                curr = offset + (i + 1)\\n                res[i] += curr\\n                candies -= curr\\n                \\n            if candies:\\n                res[i] += candies\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380564,
                "title": "easy-concise-c-solution-0ms-beats-100",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Distribute Candies to People.\\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Distribute Candies to People.\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        \\n        vector<int> res(num_people, 0);\\n        int i = 0;\\n        int k = 1;\\n        \\n        while(candies > 0)\\n        {\\n            if(candies < k)\\n            {\\n                res[i] += candies;\\n                break;\\n            }\\n            \\n            res[i] += k;\\n            candies -= k;\\n            \\n            if(i == num_people-1)\\n                i = 0;\\n            else\\n                i++;\\n            k++;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Distribute Candies to People.\\nMemory Usage: 8.5 MB, less than 100.00% of C++ online submissions for Distribute Candies to People.\\n\\n```\\nvector<int> distributeCandies(int candies, int num_people) {\\n        \\n        vector<int> res(num_people, 0);\\n        int i = 0;\\n        int k = 1;\\n        \\n        while(candies > 0)\\n        {\\n            if(candies < k)\\n            {\\n                res[i] += candies;\\n                break;\\n            }\\n            \\n            res[i] += k;\\n            candies -= k;\\n            \\n            if(i == num_people-1)\\n                i = 0;\\n            else\\n                i++;\\n            k++;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 374940,
                "title": "java-1ms-quick-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int i = 0;\\n        int count = 1;\\n        while (candies > 0){\\n            res[i] += Math.min(count, candies);\\n            candies -= count;\\n            count++;\\n            i++;\\n            i = i % num_people;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int i = 0;\\n        int count = 1;\\n        while (candies > 0){\\n            res[i] += Math.min(count, candies);\\n            candies -= count;\\n            count++;\\n            i++;\\n            i = i % num_people;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361961,
                "title": "golang-beginner-solution",
                "content": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tresult := make([]int, num_people)\\n\\tpidx := 0\\n\\tctr := 1\\n\\tfor candies > 0 {\\n\\t\\t// fmt.Println(pidx, candies, ctr)\\n\\t\\tif pidx == num_people {\\n\\t\\t\\tpidx = 0\\n\\t\\t}\\n\\t\\tif candies < ctr {\\n\\t\\t\\tresult[pidx] += candies\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tresult[pidx] += ctr\\n\\t\\tcandies -= ctr\\n\\t\\tctr++\\n\\t\\tpidx++\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distributeCandies(candies int, num_people int) []int {\\n\\tresult := make([]int, num_people)\\n\\tpidx := 0\\n\\tctr := 1\\n\\tfor candies > 0 {\\n\\t\\t// fmt.Println(pidx, candies, ctr)\\n\\t\\tif pidx == num_people {\\n\\t\\t\\tpidx = 0\\n\\t\\t}\\n\\t\\tif candies < ctr {\\n\\t\\t\\tresult[pidx] += candies\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tresult[pidx] += ctr\\n\\t\\tcandies -= ctr\\n\\t\\tctr++\\n\\t\\tpidx++\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358972,
                "title": "kotlin-runtime-148-ms-memory-usage-31-8-mb",
                "content": "```\\nfun distributeCandies(candies: Int, num_people: Int): IntArray {\\n    val distrArray = IntArray(num_people)\\n    var accumulator = 0 // candies accumulator per person\\n    var index = 0   // distribution index\\n    var mCandies = candies // val can\\'t be reassigned\\n\\n    while (mCandies > accumulator++) {\\n        distrArray[index++ % num_people] += accumulator // ensure index is in num_people scope using mod\\n        mCandies -= accumulator\\n    }\\n    return if (mCandies > 0) {\\n        distrArray[index % num_people] += mCandies\\n        distrArray\\n    } else distrArray\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun distributeCandies(candies: Int, num_people: Int): IntArray {\\n    val distrArray = IntArray(num_people)\\n    var accumulator = 0 // candies accumulator per person\\n    var index = 0   // distribution index\\n    var mCandies = candies // val can\\'t be reassigned\\n\\n    while (mCandies > accumulator++) {\\n        distrArray[index++ % num_people] += accumulator // ensure index is in num_people scope using mod\\n        mCandies -= accumulator\\n    }\\n    return if (mCandies > 0) {\\n        distrArray[index % num_people] += mCandies\\n        distrArray\\n    } else distrArray\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325796,
                "title": "javascript-solution-understandable",
                "content": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let result = new Array(num_people).fill(0);\\n    for(let give=0; candies>0; candies-=give){\\n        result[give%num_people] += Math.min(candies, ++give);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar distributeCandies = function(candies, num_people) {\\n    let result = new Array(num_people).fill(0);\\n    for(let give=0; candies>0; candies-=give){\\n        result[give%num_people] += Math.min(candies, ++give);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 325345,
                "title": "two-python-solutions-brute-force-and-mathematical",
                "content": "Brute Force: just translate the problem into code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        idx, cur, total = 0, 1, 0;\\n        res = [0] * num_people;\\n        while(total + cur <= candies):\\n            res[idx] += cur;\\n            idx = (idx + 1) % num_people;\\n            total += cur;\\n            cur += 1;\\n        if(total != candies): res[idx] += (candies - total);\\n        return res;\\n```\\n\\nMathematical: calculate how many turns the index will be iterated through\\n```\\nimport math;\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        res = [0] * num_people;\\n        tact_num = int((math.sqrt(1 + 8 * candies) - 1) / 2);\\n        tact_turn = tact_num // num_people;\\n        total = (1 + tact_num) * tact_num // 2;\\n        for i in range(num_people):\\n            turn = tact_turn + 1 if(tact_num % num_people > i) else tact_turn;\\n            res[i] = int((i + 1) * turn + 0.5 * turn * (turn - 1) * num_people);\\n        res[tact_num % num_people] += (candies - total);\\n        return res;\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        idx, cur, total = 0, 1, 0;\\n        res = [0] * num_people;\\n        while(total + cur <= candies):\\n            res[idx] += cur;\\n            idx = (idx + 1) % num_people;\\n            total += cur;\\n            cur += 1;\\n        if(total != candies): res[idx] += (candies - total);\\n        return res;\\n```\n```\\nimport math;\\nclass Solution:\\n    def distributeCandies(self, candies, num_people):\\n        res = [0] * num_people;\\n        tact_num = int((math.sqrt(1 + 8 * candies) - 1) / 2);\\n        tact_turn = tact_num // num_people;\\n        total = (1 + tact_num) * tact_num // 2;\\n        for i in range(num_people):\\n            turn = tact_turn + 1 if(tact_num % num_people > i) else tact_turn;\\n            res[i] = int((i + 1) * turn + 0.5 * turn * (turn - 1) * num_people);\\n        res[tact_num % num_people] += (candies - total);\\n        return res;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325108,
                "title": "java-0ms-o-n-solution-using-gauss-formula",
                "content": "Here is a solution that uses Gauss\\' formula for calculating sum of a series.\\nShould take O(2*num_people) time.\\n\\n```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] r = new int[num_people];\\n        \\n\\t\\t// find number of people that could get candies if just kept handing them over to new person each time\\n        int x = (int)Math.round((1. + Math.sqrt(1. + 4. * candies)) / 2.);\\n\\t\\t\\n\\t\\t// find number of full passes we can do over array of num_people\\n        int fullRows = x / num_people;\\n        \\n\\t\\t// for each person in the array give them all the candies they can get when only doing full array passes\\n        for (int i = 0; i < num_people; i++) {\\n            r[i] = (fullRows * (2 * (i + 1) + (fullRows - 1) * num_people)) / 2;\\n        }\\n        \\n\\t\\t// how many candie giving actions were just performed if we did those separately without summing\\n        int dist_pos = fullRows * num_people;\\n        \\n\\t\\t// calculate remaining candies to be distributed\\n        candies -= dist_pos*(dist_pos + 1) / 2;\\n        \\n\\t\\t// figure out the number of candies that we gave to last person\\n        int last = fullRows > 0 ? (r[num_people - 1] - ((fullRows - 1) * (2 * (num_people) + (fullRows - 2) * num_people)) / 2) : 0;\\n\\n\\t\\t// distribute all the remaining candies\\n\\t\\t// need while here because there can be less candies than we would usually give to a person\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                int n = Math.min(candies, last + 1);\\n\\n                if (n == 0) {\\n                    break;\\n                }\\n\\n                candies -= n;\\n                r[i] += n;\\n                last++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] r = new int[num_people];\\n        \\n\\t\\t// find number of people that could get candies if just kept handing them over to new person each time\\n        int x = (int)Math.round((1. + Math.sqrt(1. + 4. * candies)) / 2.);\\n\\t\\t\\n\\t\\t// find number of full passes we can do over array of num_people\\n        int fullRows = x / num_people;\\n        \\n\\t\\t// for each person in the array give them all the candies they can get when only doing full array passes\\n        for (int i = 0; i < num_people; i++) {\\n            r[i] = (fullRows * (2 * (i + 1) + (fullRows - 1) * num_people)) / 2;\\n        }\\n        \\n\\t\\t// how many candie giving actions were just performed if we did those separately without summing\\n        int dist_pos = fullRows * num_people;\\n        \\n\\t\\t// calculate remaining candies to be distributed\\n        candies -= dist_pos*(dist_pos + 1) / 2;\\n        \\n\\t\\t// figure out the number of candies that we gave to last person\\n        int last = fullRows > 0 ? (r[num_people - 1] - ((fullRows - 1) * (2 * (num_people) + (fullRows - 2) * num_people)) / 2) : 0;\\n\\n\\t\\t// distribute all the remaining candies\\n\\t\\t// need while here because there can be less candies than we would usually give to a person\\n        while (candies > 0) {\\n            for (int i = 0; i < num_people; i++) {\\n                int n = Math.min(candies, last + 1);\\n\\n                if (n == 0) {\\n                    break;\\n                }\\n\\n                candies -= n;\\n                r[i] += n;\\n                last++;\\n            }\\n        }\\n\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324770,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        li, i = [0] * n, 1\\n        while candies > 0: \\n            li[(i-1)%n] += min(i, candies)\\n            candies, i = candies-i, i+1\\n        return li\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        li, i = [0] * n, 1\\n        while candies > 0: \\n            li[(i-1)%n] += min(i, candies)\\n            candies, i = candies-i, i+1\\n        return li\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324101,
                "title": "faster-than-100-and-memory-less-than-100-python-simple-solution",
                "content": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]*num_people\\n        i = 0\\n        k = 1\\n        while True:\\n        \\n            if candies-k <= 0:\\n                ans[i] += candies\\n                break\\n            else:\\n                ans[i] += k\\n                candies -= k\\n                k+=1\\n                i+=1\\n                if i == num_people:\\n                    i = 0\\n                    \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        \\n        ans = [0]*num_people\\n        i = 0\\n        k = 1\\n        while True:\\n        \\n            if candies-k <= 0:\\n                ans[i] += candies\\n                break\\n            else:\\n                ans[i] += k\\n                candies -= k\\n                k+=1\\n                i+=1\\n                if i == num_people:\\n                    i = 0\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324057,
                "title": "java-simulation-o-sqrt-n-beats-100",
                "content": "We are simulating each step of distribution. For each iteration increment the number of candies to give to a next person and also calculate the index of that person in the array. Lastly decrement number of candies left by number of candies we gave.\\nComplexities: time is O(sqrt(candies)) - on each step the number of candies left will be decreasing proportional to sqrt(). Space - O(1) - just few state variables, am excluding resulting array from analysis. \\n```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int idx = 0;\\n        int c = 1;\\n        \\n        while(candies > 0) {\\n            //num of candies to distribute on this step. Need to check if we have enough, otherwise\\n            //use the remainder of candies\\n            res[idx] += (c < candies) ? c : candies;\\n            //next person - need to start from 0 if it was a last one\\n            idx = (idx == num_people - 1) ? 0 : idx + 1;\\n            //decrement number of candies left\\n            candies -= c++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\n    public int[] distributeCandies(int candies, int num_people) {\\n        int[] res = new int[num_people];\\n        int idx = 0;\\n        int c = 1;\\n        \\n        while(candies > 0) {\\n            //num of candies to distribute on this step. Need to check if we have enough, otherwise\\n            //use the remainder of candies\\n            res[idx] += (c < candies) ? c : candies;\\n            //next person - need to start from 0 if it was a last one\\n            idx = (idx == num_people - 1) ? 0 : idx + 1;\\n            //decrement number of candies left\\n            candies -= c++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 324015,
                "title": "simple-and-and-efficient-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {        \\n        int[] distribution = new int[num_people];\\n        int current = 1;\\n        while(candies > 0){\\n            for(int i = 0; i < num_people; i++){\\n                if(candies - current >= 0){\\n                    distribution[i] += current;\\n                    candies = candies - current;\\n                    current += 1;\\n                }\\n                else if(candies > 0){\\n                    distribution[i] += candies;\\n                    candies -= candies;                    \\n                }\\n                else break;                \\n            }                \\n        }\\n        return distribution;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] distributeCandies(int candies, int num_people) {        \\n        int[] distribution = new int[num_people];\\n        int current = 1;\\n        while(candies > 0){\\n            for(int i = 0; i < num_people; i++){\\n                if(candies - current >= 0){\\n                    distribution[i] += current;\\n                    candies = candies - current;\\n                    current += 1;\\n                }\\n                else if(candies > 0){\\n                    distribution[i] += candies;\\n                    candies -= candies;                    \\n                }\\n                else break;                \\n            }                \\n        }\\n        return distribution;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323872,
                "title": "0ms-go-solution",
                "content": "func distributeCandies(candies int, num_people int) []int {\\n\\tif num_people <= 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tvar out = make([]int, num_people)\\n\\n\\tif candies <= 0 {\\n\\t\\treturn out\\n\\t}\\n\\n\\tvar equ bool\\n\\tvar N = num_people\\n\\tvar count = 1\\n\\tvar flag = 1\\n\\tvar a, b int\\n\\tfor {\\n\\t\\tfmt.Println((N + count) * num_people / 2)\\n\\t\\tif (N+count)*num_people/2 > candies {\\n\\t\\t\\tequ = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif (N+count)*num_people/2 == candies {\\n\\t\\t\\tequ = true\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tflag++\\n\\t\\ta, b = count, N\\n\\t\\tcount = count + (flag-1)*num_people + 1\\n\\t\\tN = N + (flag-1)*num_people + num_people\\n\\t}\\n\\n\\tif !equ && a != 0 {\\n\\t\\tflag--\\n\\t}\\n\\tif a == 0 || equ {\\n\\t\\ta, b = count, N\\n\\t}\\n\\n\\tvar can = candies\\n\\tvar i = 0\\n\\tvar k = a\\n\\n\\tfor i < num_people {\\n\\t\\tif k <= can {\\n\\t\\t\\tout[i] = k\\n\\t\\t}\\n\\t\\tif k > can {\\n\\t\\t\\tout[i] = can\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tcan -= k\\n\\t\\tk += flag\\n\\t\\ti++\\n\\t}\\n\\n\\tif can <= 0 && (equ == true || flag == 1) {\\n\\t\\tfmt.Println(out)\\n\\t\\treturn out\\n\\t}\\n\\n\\tcan = candies - (a+b)*num_people/2\\n\\ti = 0\\n\\n\\tci := count - out[0]\\n\\tfor can >= 0 {\\n\\t\\tif can <= ci {\\n\\t\\t\\tout[i] += can\\n\\t\\t}\\n\\t\\tif can > ci {\\n\\t\\t\\tout[i] += ci\\n\\t\\t}\\n\\t\\ti++\\n\\t\\tcan -= ci\\n\\t\\tci++\\n\\t}\\n\\n\\tfmt.Println(out)\\n\\treturn out\\n}",
                "solutionTags": [],
                "code": "func distributeCandies(candies int, num_people int) []int {\\n\\tif num_people <= 0 {\\n\\t\\treturn []int{}\\n\\t}\\n\\n\\tvar out = make([]int, num_people)\\n\\n\\tif candies <= 0 {\\n\\t\\treturn out\\n\\t}\\n\\n\\tvar equ bool\\n\\tvar N = num_people\\n\\tvar count = 1\\n\\tvar flag = 1\\n\\tvar a, b int\\n\\tfor {\\n\\t\\tfmt.Println((N + count) * num_people / 2)\\n\\t\\tif (N+count)*num_people/2 > candies {\\n\\t\\t\\tequ = false\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif (N+count)*num_people/2 == candies {\\n\\t\\t\\tequ = true\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tflag++\\n\\t\\ta, b = count, N\\n\\t\\tcount = count + (flag-1)*num_people + 1\\n\\t\\tN = N + (flag-1)*num_people + num_people\\n\\t}\\n\\n\\tif !equ && a != 0 {\\n\\t\\tflag--\\n\\t}\\n\\tif a == 0 || equ {\\n\\t\\ta, b = count, N\\n\\t}\\n\\n\\tvar can = candies\\n\\tvar i = 0\\n\\tvar k = a\\n\\n\\tfor i < num_people {\\n\\t\\tif k <= can {\\n\\t\\t\\tout[i] = k\\n\\t\\t}\\n\\t\\tif k > can {\\n\\t\\t\\tout[i] = can\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tcan -= k\\n\\t\\tk += flag\\n\\t\\ti++\\n\\t}\\n\\n\\tif can <= 0 && (equ == true || flag == 1) {\\n\\t\\tfmt.Println(out)\\n\\t\\treturn out\\n\\t}\\n\\n\\tcan = candies - (a+b)*num_people/2\\n\\ti = 0\\n\\n\\tci := count - out[0]\\n\\tfor can >= 0 {\\n\\t\\tif can <= ci {\\n\\t\\t\\tout[i] += can\\n\\t\\t}\\n\\t\\tif can > ci {\\n\\t\\t\\tout[i] += ci\\n\\t\\t}\\n\\t\\ti++\\n\\t\\tcan -= ci\\n\\t\\tci++\\n\\t}\\n\\n\\tfmt.Println(out)\\n\\treturn out\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 323722,
                "title": "javascript-100-time-100-space-not-brute-force",
                "content": "This approach attempts to reduce the number of iterations required by brute force for large candy counts. I\\'d like to compare the complexity with the brute froce approach, but I\\'m not certain what the complexity of this algorithm is due to the first loop - it depends on the ratio of candies to people. The last two loops are O(people).\\n\\n```javascript\\n/**\\n * @param {number} candies The number of candies to distribute.\\n * @param {number} p The number of people to receive candies.\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, p) {\\n  let numFullRows = 0;\\n  \\n  /**\\n   * Determine the number of full rows. This is\\n   * done by calculating the number of candies\\n   * required by n rows. When the required number\\n   * of candies is greater than the number of\\n   * candies we have, the loop is exited and we\\n   * know the number of full rows is one less than\\n   * the number of full rows from the last\\n   * iteration of the loop (hence --numFullRows).\\n   */\\n  let max = 0;\\n  let k = 0;\\n  while (max <= candies) {\\n    ++numFullRows;\\n    max = p * k * p + numFullRows * ((p * (p + 1)) / 2);\\n    k += numFullRows;\\n  }\\n  --numFullRows;\\n  \\n  /**\\n   * Now that the number of full rows is known,\\n   * it can be calculated that each person is\\n   * guaranteed to receive a certain number of\\n   * candies. I\\'ll call this amount \"base\".\\n   * Calculating it now, instead of for every\\n   * person, will save a little time in the next\\n   * loop.\\n   */\\n  let base = 0;\\n  for (let i = 1; i < numFullRows; ++i) {\\n    base += i * p;\\n  }\\n  \\n  /**\\n   * Initialize the result array with all\\n   * completed rows. For each i = 1 ... p,\\n   * this is: base + i * numFullRows.\\n   *\\n   * This loop is not combined with the last loop\\n   * because the last loop needs an accurate count\\n   * of remaining candies for the (potentially)\\n   * partial last row.\\n   */\\n  let result = [];\\n  for (let i = 1; i <= p; ++i) {\\n    let count = base + i * numFullRows;\\n    candies -= count;\\n    result.push(count);\\n  }\\n  \\n  /**\\n   * Fill in the remaining number of candies\\n   * from left to right. The number of candies\\n   * to give the i-th person during the n-th\\n   * pass is: 1 + (p * (n - 1)) + i. numFullRows\\n   * already represents n - 1, so we use it\\n   * instead.\\n   */\\n  let i = 0;\\n  while (candies > 0) {\\n    let top = 1 + (p * numFullRows) + i;\\n    if (top > candies) top = candies;\\n    result[i++] += top;\\n    candies -= top;\\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number} candies The number of candies to distribute.\\n * @param {number} p The number of people to receive candies.\\n * @return {number[]}\\n */\\nvar distributeCandies = function(candies, p) {\\n  let numFullRows = 0;\\n  \\n  /**\\n   * Determine the number of full rows. This is\\n   * done by calculating the number of candies\\n   * required by n rows. When the required number\\n   * of candies is greater than the number of\\n   * candies we have, the loop is exited and we\\n   * know the number of full rows is one less than\\n   * the number of full rows from the last\\n   * iteration of the loop (hence --numFullRows).\\n   */\\n  let max = 0;\\n  let k = 0;\\n  while (max <= candies) {\\n    ++numFullRows;\\n    max = p * k * p + numFullRows * ((p * (p + 1)) / 2);\\n    k += numFullRows;\\n  }\\n  --numFullRows;\\n  \\n  /**\\n   * Now that the number of full rows is known,\\n   * it can be calculated that each person is\\n   * guaranteed to receive a certain number of\\n   * candies. I\\'ll call this amount \"base\".\\n   * Calculating it now, instead of for every\\n   * person, will save a little time in the next\\n   * loop.\\n   */\\n  let base = 0;\\n  for (let i = 1; i < numFullRows; ++i) {\\n    base += i * p;\\n  }\\n  \\n  /**\\n   * Initialize the result array with all\\n   * completed rows. For each i = 1 ... p,\\n   * this is: base + i * numFullRows.\\n   *\\n   * This loop is not combined with the last loop\\n   * because the last loop needs an accurate count\\n   * of remaining candies for the (potentially)\\n   * partial last row.\\n   */\\n  let result = [];\\n  for (let i = 1; i <= p; ++i) {\\n    let count = base + i * numFullRows;\\n    candies -= count;\\n    result.push(count);\\n  }\\n  \\n  /**\\n   * Fill in the remaining number of candies\\n   * from left to right. The number of candies\\n   * to give the i-th person during the n-th\\n   * pass is: 1 + (p * (n - 1)) + i. numFullRows\\n   * already represents n - 1, so we use it\\n   * instead.\\n   */\\n  let i = 0;\\n  while (candies > 0) {\\n    let top = 1 + (p * numFullRows) + i;\\n    if (top > candies) top = candies;\\n    result[i++] += top;\\n    candies -= top;\\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323534,
                "title": "c-binary-search-solution-0-ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        if(candies < 0 || num_people<=0){\\n            return res;\\n        }\\n        long long int l = 0, r = 100000;\\n        long long int ans=0;\\n        while(l<=r){\\n            long long int m = (l+r)/2;\\n            long long int sum = m*num_people;\\n            sum=sum*(sum+1)/2;\\n            if(sum>candies){\\n                r=m-1;\\n            }\\n            else{\\n                ans=m;\\n                l=m+1;\\n            }\\n        }\\n        for(int i=0;i<num_people;i++){\\n            long long int temp = ans*(2*(i+1)+(ans-1)*num_people)/2;\\n            res[i]=temp;\\n        }\\n        long long int rem = ans*num_people;\\n        rem = rem*(rem+1)/2;\\n        rem = candies - rem;\\n        for(int i=0;i<num_people and rem>0;i++){\\n            res[i] += min((ans)*num_people+(i+1), rem);\\n            rem-=(ans)*num_people+(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> res(num_people);\\n        if(candies < 0 || num_people<=0){\\n            return res;\\n        }\\n        long long int l = 0, r = 100000;\\n        long long int ans=0;\\n        while(l<=r){\\n            long long int m = (l+r)/2;\\n            long long int sum = m*num_people;\\n            sum=sum*(sum+1)/2;\\n            if(sum>candies){\\n                r=m-1;\\n            }\\n            else{\\n                ans=m;\\n                l=m+1;\\n            }\\n        }\\n        for(int i=0;i<num_people;i++){\\n            long long int temp = ans*(2*(i+1)+(ans-1)*num_people)/2;\\n            res[i]=temp;\\n        }\\n        long long int rem = ans*num_people;\\n        rem = rem*(rem+1)/2;\\n        rem = candies - rem;\\n        for(int i=0;i<num_people and rem>0;i++){\\n            res[i] += min((ans)*num_people+(i+1), rem);\\n            rem-=(ans)*num_people+(i+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323384,
                "title": "straightforward-python-solution",
                "content": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = num_people * [0]\\n        i = 0\\n        while candies > 0:\\n            if candies >= i + 1:\\n                arr[i % num_people] += i + 1\\n                candies -= i + 1\\n            else:\\n                arr[i % num_people] += candies\\n                break\\n            i += 1\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        arr = num_people * [0]\\n        i = 0\\n        while candies > 0:\\n            if candies >= i + 1:\\n                arr[i % num_people] += i + 1\\n                candies -= i + 1\\n            else:\\n                arr[i % num_people] += candies\\n                break\\n            i += 1\\n        return arr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 323319,
                "title": "python-math-faster-than-brute-force-and-sqrt-candies",
                "content": "We first calculate how many (maximum) `turns` can we hand out candies such that every people get candies in this turn.\\nThen if we still have candies, give them out starting from the first person.\\n\\nThe time complexity is faster than brute force.\\n`T(brute_force) = O(#gives_out) = O(#people * #turns)`\\n`T(math_solution) = O(#turns + #people) > T(brute_force)`\\n\\nThe time complexity of brute force can also be denoted as `sqrt(#candies)` because `O(#candies) = O(1 + 2 + ... + #gives_out) = O(#gives_out^2)`.\\n\\n```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        base = (1 + n) * n / 2\\n        total = turns = 0\\n        while total + base < candies:\\n            total += base\\n            base += n * n\\n            turns += 1\\n\\t\\tfor i in xrange(len(res)):\\n\\t\\t\\tres[i] = turns * (i + 1) + n * (turns - 1) * turns / 2\\n        k = turns * n\\n        i = 0\\n        distributed = sum(res)\\n        while distributed < candies:\\n            k += 1\\n            res[i] += min(k, candies - distributed)\\n            distributed += k\\n            i += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def distributeCandies(self, candies, n):\\n        res = [0] * n\\n        base = (1 + n) * n / 2\\n        total = turns = 0\\n        while total + base < candies:\\n            total += base\\n            base += n * n\\n            turns += 1\\n\\t\\tfor i in xrange(len(res)):\\n\\t\\t\\tres[i] = turns * (i + 1) + n * (turns - 1) * turns / 2\\n        k = turns * n\\n        i = 0\\n        distributed = sum(res)\\n        while distributed < candies:\\n            k += 1\\n            res[i] += min(k, candies - distributed)\\n            distributed += k\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323316,
                "title": "c-share-my-solution-time-complexity-is-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> r(num_people,0);\\n        int idx=0;\\n        while(candies>0){\\n            if(candies-idx-1<0)\\n                r[idx%num_people]+=candies,candies=0;\\n            else\\n                r[idx%num_people]+=idx+1,candies-=idx+1;\\n            idx++;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> distributeCandies(int candies, int num_people) {\\n        vector<int> r(num_people,0);\\n        int idx=0;\\n        while(candies>0){\\n            if(candies-idx-1<0)\\n                r[idx%num_people]+=candies,candies=0;\\n            else\\n                r[idx%num_people]+=idx+1,candies-=idx+1;\\n            idx++;\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323296,
                "title": "python-brute-force-simulation",
                "content": "In a brute force way, distribute the candies to each person in round robin fashion.\\n\\n```\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        res = [0] * n\\n        i = 0\\n        cur = 1\\n        while candies >= cur:\\n            res[i] += cur\\n            candies -= cur\\n            cur += 1\\n            i = (i + 1) % n\\n        res[i] += candies\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def distributeCandies(self, candies: int, n: int) -> List[int]:\\n        res = [0] * n\\n        i = 0\\n        cur = 1\\n        while candies >= cur:\\n            res[i] += cur\\n            candies -= cur\\n            cur += 1\\n            i = (i + 1) % n\\n        res[i] += candies\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4096589,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] DistributeCandies(int candies, int num_people) {\\n        int i=1,k=0,j=0;\\n        int[] result=new int[num_people];\\n        while(k+i<candies){\\n            for(j=0;(k+i)<candies && j<num_people;j++){\\n                result[j]+= i;\\n                k+=i;\\n                i++;\\n            }\\n        }\\n        if(j==num_people)\\n            j=0;\\n\\n        result[j] += candies-k;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] DistributeCandies(int candies, int num_people) {\\n        int i=1,k=0,j=0;\\n        int[] result=new int[num_people];\\n        while(k+i<candies){\\n            for(j=0;(k+i)<candies && j<num_people;j++){\\n                result[j]+= i;\\n                k+=i;\\n                i++;\\n            }\\n        }\\n        if(j==num_people)\\n            j=0;\\n\\n        result[j] += candies-k;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096283,
                "title": "beats-99-8-percent-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        child = [0]*num_people\\n        index = 0\\n        candy = 1\\n        while candies >0:\\n            if candies < candy :\\n                candy = candies\\n            child[index] += candy \\n            candies -= candy\\n            candy +=1\\n            index +=1\\n            if index  == num_people:\\n                index = 0\\n        return child\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\\n        child = [0]*num_people\\n        index = 0\\n        candy = 1\\n        while candies >0:\\n            if candies < candy :\\n                candy = candies\\n            child[index] += candy \\n            candies -= candy\\n            candy +=1\\n            index +=1\\n            if index  == num_people:\\n                index = 0\\n        return child\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572836,
                "content": [
                    {
                        "username": "Han6431",
                        "content": "**Pure math problem. If we get the math behind, we get the solution.**\\n1) By the total number of candies, we know how many distributions of candices we will have for people: 1 + 2 + 3 + ... = number of candies. Here, the number of distributions is the number of natural numbers on the left of the equation. (Use the formula (1+n)*n/2 = number of candies. The n might not be an integer. If so, it means there are remain candies for the last person. Let m be the floor number of n, and we can use m and the total number of candies to calculate the remain candies for the last person.)\\n2) With the number of distributions, we can calculate how many rounds we will have. (Each round means going through all people once). Use integer division of number of distributions on number of people, we have the number of rounds.\\n3) Use mode calculation we can get the number of distributions for the last incomplete round. \\n4) Don\\'t forget to add the remain candies to the last person.\\n\\nWith these numbers calculated, for each person in the list, we can directly calculate the number of candies there."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = [0] * num_people\\n\\ti = 0\\n\\twhile candies >= 0:\\n\\t\\tresult[i % num_people] += min(i + 1, candies)\\n\\t\\ti += 1\\n\\t\\tcandies -= i\\n\\treturn result"
                    }
                ]
            },
            {
                "id": 1574846,
                "content": [
                    {
                        "username": "Han6431",
                        "content": "**Pure math problem. If we get the math behind, we get the solution.**\\n1) By the total number of candies, we know how many distributions of candices we will have for people: 1 + 2 + 3 + ... = number of candies. Here, the number of distributions is the number of natural numbers on the left of the equation. (Use the formula (1+n)*n/2 = number of candies. The n might not be an integer. If so, it means there are remain candies for the last person. Let m be the floor number of n, and we can use m and the total number of candies to calculate the remain candies for the last person.)\\n2) With the number of distributions, we can calculate how many rounds we will have. (Each round means going through all people once). Use integer division of number of distributions on number of people, we have the number of rounds.\\n3) Use mode calculation we can get the number of distributions for the last incomplete round. \\n4) Don\\'t forget to add the remain candies to the last person.\\n\\nWith these numbers calculated, for each person in the list, we can directly calculate the number of candies there."
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tresult = [0] * num_people\\n\\ti = 0\\n\\twhile candies >= 0:\\n\\t\\tresult[i % num_people] += min(i + 1, candies)\\n\\t\\ti += 1\\n\\t\\tcandies -= i\\n\\treturn result"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Unhappy Friends",
        "question_content": "<p>You are given a list of&nbsp;<code>preferences</code>&nbsp;for&nbsp;<code>n</code>&nbsp;friends, where <code>n</code> is always <strong>even</strong>.</p>\n\n<p>For each person <code>i</code>,&nbsp;<code>preferences[i]</code>&nbsp;contains&nbsp;a list of friends&nbsp;<strong>sorted</strong> in the <strong>order of preference</strong>. In other words, a friend earlier in the list is more preferred than a friend later in the list.&nbsp;Friends in&nbsp;each list are&nbsp;denoted by integers from <code>0</code> to <code>n-1</code>.</p>\n\n<p>All the friends are divided into pairs.&nbsp;The pairings are&nbsp;given in a list&nbsp;<code>pairs</code>,&nbsp;where <code>pairs[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> denotes <code>x<sub>i</sub></code>&nbsp;is paired with <code>y<sub>i</sub></code> and <code>y<sub>i</sub></code> is paired with <code>x<sub>i</sub></code>.</p>\n\n<p>However, this pairing may cause some of the friends to be unhappy.&nbsp;A friend <code>x</code>&nbsp;is unhappy if <code>x</code>&nbsp;is paired with <code>y</code>&nbsp;and there exists a friend <code>u</code>&nbsp;who&nbsp;is paired with <code>v</code>&nbsp;but:</p>\n\n<ul>\n\t<li><code>x</code>&nbsp;prefers <code>u</code>&nbsp;over <code>y</code>,&nbsp;and</li>\n\t<li><code>u</code>&nbsp;prefers <code>x</code>&nbsp;over <code>v</code>.</li>\n</ul>\n\n<p>Return <em>the number of unhappy friends</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nFriend 1 is unhappy because:\n- 1 is paired with 0 but prefers 3 over 0, and\n- 3 prefers 1 over 2.\nFriend 3 is unhappy because:\n- 3 is paired with 2 but prefers 1 over 2, and\n- 1 prefers 3 over 0.\nFriends 0 and 2 are happy.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Both friends 0 and 1 are happy.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 500</code></li>\n\t<li><code>n</code>&nbsp;is even.</li>\n\t<li><code>preferences.length&nbsp;== n</code></li>\n\t<li><code>preferences[i].length&nbsp;== n - 1</code></li>\n\t<li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li>\n\t<li><code>preferences[i]</code>&nbsp;does not contain <code>i</code>.</li>\n\t<li>All values in&nbsp;<code>preferences[i]</code>&nbsp;are unique.</li>\n\t<li><code>pairs.length&nbsp;== n/2</code></li>\n\t<li><code>pairs[i].length&nbsp;== 2</code></li>\n\t<li><code>x<sub>i</sub> != y<sub>i</sub></code></li>\n\t<li><code>0 &lt;= x<sub>i</sub>, y<sub>i</sub>&nbsp;&lt;= n - 1</code></li>\n\t<li>Each person is contained in <strong>exactly one</strong> pair.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 843929,
                "title": "what-a-bad-question",
                "content": "First of all, it took me a long long time to understand the question, I think Leetcode should hire a better problem writer! \\n\\nSecondly, even you figured out what to do, it pretty much feels like \"**if you try to solve this by a fantasy algorithm, then you will fail this. Because the most time efficient way is brutal force. (BEEP)**\"\\n\\nLast but not least, **I am definitely an \"unhappy friend\" with this question.** Does anyone feel the same?\\n\\n```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[] map = new int[n];\\n        for(int[] pair: pairs){ // Keep record of current matches.\\n            map[pair[0]] = pair[1];\\n            map[pair[1]] = pair[0];\\n        }\\n        int res = 0;\\n\\t\\t\\n        Map<Integer, Integer>[] prefer = new Map[n]; // O(1) to fetch the index from the preference array. \\n         \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n-1; j++){\\n                if(prefer[i] == null) prefer[i] = new HashMap<>();\\n                prefer[i].put(preferences[i][j], j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j : preferences[i]){\\n                if(prefer[j].get(i) < prefer[j].get(map[j]) \\n\\t\\t\\t\\t\\t&& prefer[i].get(map[i]) > prefer[i].get(j)){ // Based on the definition of \"unhappy\"...\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n\\t    return res;\\n```",
                "solutionTags": [],
                "code": "```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[] map = new int[n];\\n        for(int[] pair: pairs){ // Keep record of current matches.\\n            map[pair[0]] = pair[1];\\n            map[pair[1]] = pair[0];\\n        }\\n        int res = 0;\\n\\t\\t\\n        Map<Integer, Integer>[] prefer = new Map[n]; // O(1) to fetch the index from the preference array. \\n         \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n-1; j++){\\n                if(prefer[i] == null) prefer[i] = new HashMap<>();\\n                prefer[i].put(preferences[i][j], j);\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j : preferences[i]){\\n                if(prefer[j].get(i) < prefer[j].get(map[j]) \\n\\t\\t\\t\\t\\t&& prefer[i].get(map[i]) > prefer[i].get(j)){ // Based on the definition of \"unhappy\"...\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n\\t    return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844105,
                "title": "python-clean-solution",
                "content": "Create dictionary using each friend as keys and a list of people they are closer to than the person they are paired with as values. This can be done using index.\\n\\nThen use nested for loop to find when people are on each other\\'s list.\\n\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        dd = {}\\n        \\n        for i,x in pairs:\\n            dd[i] = preferences[i][:preferences[i].index(x)]\\n            dd[x] = preferences[x][:preferences[x].index(i)]\\n        \\n        ans = 0\\n            \\n        for i in dd:\\n            for x in dd[i]:\\n                if i in dd[x]:\\n                    ans += 1\\n                    break\\n        \\n        return ans\\n                            \\n                            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        dd = {}\\n        \\n        for i,x in pairs:\\n            dd[i] = preferences[i][:preferences[i].index(x)]\\n            dd[x] = preferences[x][:preferences[x].index(i)]\\n        \\n        ans = 0\\n            \\n        for i in dd:\\n            for x in dd[i]:\\n                if i in dd[x]:\\n                    ans += 1\\n                    break\\n        \\n        return ans\\n                            \\n                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 843928,
                "title": "o-n-2-store-preferences-at-the-beginning",
                "content": "Well, I understand the frustration. The problem could have been certainly be worded better.\\n\\nImportant thing to note:\\n**When**\\n`x` prefers `u` over `y`, and\\n`u` prefers `x` over `v`,\\n**Then**\\nBoth `x` and `u` are unhappy.\\nNOT just `x`.\\n\\nThe problem statement mentions that `x` is unhappy. We have to figure out that `u` is also unhappy.\\n\\n--\\n\\nYou have to try each pair with every other pair to identify the unhappiness. That leads to O(n^2) complexity already. So how do we optimize the inner operation to constant time so that the overall complexity remains O(n^2)?\\n\\nTo know whether `x` prefers `y` over `z`, we need to know their positions in `x`s list.\\nIf you want to find the position of `y` in `x`s list, you might have to search the entire list and get the index. Similarly for `z`.\\nThis would be O(n) and solution will become O(n^3) which will lead to TLE.\\n\\nHence, we first store the position of each friend in every other friends\\' list, in a map at the beginning.\\n\\n\\n```\\nclass Solution {\\n\\n    // To efficiently know whether a person x prefers a person y or a person z, wouldn\\'t \\n    // it be better to have that information ready?\\n    // We store the index of each person in every other person\\'s list in a map at the beginning.\\n    \\n    // `positions[i][j]` should be read as position of i in the list of j is positions[i][j].\\n    unordered_map<int, unordered_map<int, int>> positions;\\n    \\n    unordered_set<int> unhappy; // Stores unhappy people. In the end, we will return it\\'s size.\\npublic:\\n    void checkHappiness(int x, int y, int u, int v) {\\n        if (positions[u][x] < positions[y][x] &&\\n            positions[x][u] < positions[v][u]) {\\n            unhappy.insert(x);\\n            unhappy.insert(u);\\n        }\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<n-1; j++) {\\n                positions[preferences[i][j]][i] = j;\\n            }\\n        }\\n        int n = pairs.size();\\n        for (int i=0; i<n-1; i++) {\\n            for (int j=i+1; j<n; j++) {\\n                int x = pairs[i][0], y = pairs[i][1], u = pairs[j][0], v = pairs[j][1];\\n                checkHappiness(x, y, u, v); // If x prefers u over y,  and u prefers x over v\\n                checkHappiness(x, y, v, u); // If x prefers v over y,  and v prefers x over u\\n                checkHappiness(y, x, u, v); // If y prefers u over x,  and u prefers y over v\\n                checkHappiness(y, x, v, u); // If y prefers v over x,  and v prefers y over u\\n            }\\n        }\\n        \\n        return unhappy.size();\\n    }\\n};\\n```\\n\\n**Some of my other posts**\\n1. Leetcode 1584: https://leetcode.com/problems/min-cost-to-connect-all-points/discuss/844270\\n2. Leetcode 1583: https://leetcode.com/problems/count-unhappy-friends/discuss/843928\\n3. Leetcode 1579: https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/discuss/831506\\n4. Leetcode 1578: https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/discuss/831533\\n5. Leetcode 1577: https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831548\\n6. Leetcode 1553: https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794075\\n7. Leetcode 1545: https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/discuss/781105\\n8. Leetcode 1536: https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/discuss/768076\\n9. Leetcode 1535: https://leetcode.com/problems/find-the-winner-of-an-array-game/discuss/767958\\n10. Leetcode 1534: https://leetcode.com/problems/count-good-triplets/discuss/768170\\n11. Leetcode 1529: https://leetcode.com/problems/bulb-switcher-iv/discuss/755939\\n12. Leetcode 1503: https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/discuss/720313\\n13. Leetcode 1488: https://leetcode.com/problems/avoid-flood-in-the-city/discuss/697687\\n14. Leetcode 1487: https://leetcode.com/problems/making-file-names-unique/discuss/719962\\n15. Leetcode 1472: https://leetcode.com/problems/design-browser-history/discuss/674486\\n16. Leetcode 1471: https://leetcode.com/problems/the-k-strongest-values-in-an-array/discuss/674346\\n17. Leetcode 1466: https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/discuss/661710\\n18. Leetcode 1465: https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/discuss/661995\\n19. Leetcode 1458: https://leetcode.com/problems/max-dot-product-of-two-subsequences/discuss/648528\\n20. Leetcode 1443: https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/discuss/623673\\n21. Leetcode 1436: https://leetcode.com/problems/destination-city/discuss/609874\\n22. Leetcode 1424: https://leetcode.com/problems/diagonal-traverse-ii/discuss/597741\\n23. Leetcode 1423: https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/discuss/597825\\n24. Leetcode 1419: https://leetcode.com/problems/minimum-number-of-frogs-croaking/discuss/586653",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    // To efficiently know whether a person x prefers a person y or a person z, wouldn\\'t \\n    // it be better to have that information ready?\\n    // We store the index of each person in every other person\\'s list in a map at the beginning.\\n    \\n    // `positions[i][j]` should be read as position of i in the list of j is positions[i][j].\\n    unordered_map<int, unordered_map<int, int>> positions;\\n    \\n    unordered_set<int> unhappy; // Stores unhappy people. In the end, we will return it\\'s size.\\npublic:\\n    void checkHappiness(int x, int y, int u, int v) {\\n        if (positions[u][x] < positions[y][x] &&\\n            positions[x][u] < positions[v][u]) {\\n            unhappy.insert(x);\\n            unhappy.insert(u);\\n        }\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<n-1; j++) {\\n                positions[preferences[i][j]][i] = j;\\n            }\\n        }\\n        int n = pairs.size();\\n        for (int i=0; i<n-1; i++) {\\n            for (int j=i+1; j<n; j++) {\\n                int x = pairs[i][0], y = pairs[i][1], u = pairs[j][0], v = pairs[j][1];\\n                checkHappiness(x, y, u, v); // If x prefers u over y,  and u prefers x over v\\n                checkHappiness(x, y, v, u); // If x prefers v over y,  and v prefers x over u\\n                checkHappiness(y, x, u, v); // If y prefers u over x,  and u prefers y over v\\n                checkHappiness(y, x, v, u); // If y prefers v over x,  and v prefers y over u\\n            }\\n        }\\n        \\n        return unhappy.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844089,
                "title": "c-easy-explanation-for-a-bad-framed-question",
                "content": "The question was framed a little unclear for most of us to understand but here we go.\\n\\nExaplaination of the question\\n\\n\\tFollowing statement of question can be explained better.\\n\\tHowever, this pairing may cause some of the friends to be unhappy. \\n\\tA friend x is unhappy if x is paired with y and there exists a friend \\n\\tu who is paired with v but:\\n\\n\\tx prefers u over y, and\\n\\tu prefers x over v.\\n\\t\\n\\tTake Example as :\\n\\t\\n\\tn = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\\n\\t\\n\\t\\n\\tTake pair [0,2]\\n\\tx-y == 0-2\\n\\t\\n\\t0 prefers 1 and 3 over 2 (YES WE NEED TO CONSIDER 1 AND 3 BOTH :) )\\n\\tNow check for 1 as well as 3\\n\\tNow if any of 1 or 3 preferes 0 over 2 then we have a unhappy friend.\\n\\tsince 3 prefers 0 over two we have a unhappy friend\\n\\tthough we see 1 prefers 2 over zero\\n\\tPS: most of us thought just to check for 1st preference of 0 and there is where this\\'\\n\\tquestions explanation was misunderstood.\\'\\n\\t\\n\\t\\n\\tIf you still have any doubt please raise them in comment section I will do my best to make the question clear.\\n\\t\\nBelow is the exaplantion of code:\\n\\t\\t\\n\\tFor every friend map his/her preferences\\n\\tNow calculate the distance between the pairs that are made.\\n\\t\\n\\tNow main code:\\n\\tLoop over every friend\\n\\t1. Check if matched prefrence is lower\\n\\t2. If not then loop over thier preferences and see if the any his/her higher preference is \\n\\talso matched to some lower preference, If yes increment the count unhappy.\\n\\t\\nHere is the code for refrence:\\nHappy Coding :)\\n\\n```\\nint unhappyFriends(int n, vector<vector<int>> &pref, vector<vector<int>> &pairs)\\n{\\n    vector<unordered_map<int, int>> mp(n);\\n    vector<int> distance(n);\\n    for (int i = 0; i < n; ++i)\\n    {\\n        int prefsize = pref[i].size();\\n        for (int j = 0; j < prefsize; ++j)\\n            mp[i][pref[i][j]] = j;\\n    }\\n\\n    for (auto &p : pairs)\\n    {\\n        distance[p[0]] = mp[p[0]][p[1]];\\n        distance[p[1]] = mp[p[1]][p[0]];\\n    }\\n    int unhappy = 0;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < distance[i]; ++j)\\n        {\\n            int x = pref[i][j];\\n            for (int k = 0; k < distance[x]; ++k)\\n            {\\n                if (i == pref[x][k])\\n                {\\n                    unhappy++;\\n                    j = k = n;\\n                }\\n            }\\n        }\\n    }\\n    return unhappy;\\n}\\n```\\n\\nComplexity Analysis\\n\\t\\t\\n\\tTime : O(n^3)\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint unhappyFriends(int n, vector<vector<int>> &pref, vector<vector<int>> &pairs)\\n{\\n    vector<unordered_map<int, int>> mp(n);\\n    vector<int> distance(n);\\n    for (int i = 0; i < n; ++i)\\n    {\\n        int prefsize = pref[i].size();\\n        for (int j = 0; j < prefsize; ++j)\\n            mp[i][pref[i][j]] = j;\\n    }\\n\\n    for (auto &p : pairs)\\n    {\\n        distance[p[0]] = mp[p[0]][p[1]];\\n        distance[p[1]] = mp[p[1]][p[0]];\\n    }\\n    int unhappy = 0;\\n    for (int i = 0; i < n; ++i)\\n    {\\n        for (int j = 0; j < distance[i]; ++j)\\n        {\\n            int x = pref[i][j];\\n            for (int k = 0; k < distance[x]; ++k)\\n            {\\n                if (i == pref[x][k])\\n                {\\n                    unhappy++;\\n                    j = k = n;\\n                }\\n            }\\n        }\\n    }\\n    return unhappy;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843967,
                "title": "java-brutal-force-loops",
                "content": "```\\n    public int unhappyFriends(int n, int[][] ps, int[][] pairs) {\\n        int res = 0, pair[] = new int[n];\\n        Set<Integer> set = new HashSet<>();\\n        for (int[] p : pairs) {\\n            pair[p[0]] = p[1];\\n            pair[p[1]] = p[0];\\n        }\\n        for (int[] p : pairs) {\\n            for (int x : p) {\\n                for (int u : ps[x]) {\\n                    if (u == pair[x]) break; // count before y;\\n                    for (int x0 : ps[u]) {\\n                        if (x0 == pair[u]) break; // count before v;\\n                        if (x0 == x) {   // find x;\\n                            set.add(x);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int unhappyFriends(int n, int[][] ps, int[][] pairs) {\\n        int res = 0, pair[] = new int[n];\\n        Set<Integer> set = new HashSet<>();\\n        for (int[] p : pairs) {\\n            pair[p[0]] = p[1];\\n            pair[p[1]] = p[0];\\n        }\\n        for (int[] p : pairs) {\\n            for (int x : p) {\\n                for (int u : ps[x]) {\\n                    if (u == pair[x]) break; // count before y;\\n                    for (int x0 : ps[u]) {\\n                        if (x0 == pair[u]) break; // count before v;\\n                        if (x0 == x) {   // find x;\\n                            set.add(x);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return set.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843963,
                "title": "c-friend-distance",
                "content": "For each person, calculate the \"friend distance\" - how far the person he or she is paired with in the friend list.\\n\\nThen, you can go through each person, and all friends that are closer (compared to the \"friend distance\").\\n\\n```cpp\\nint unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n    vector<unordered_map<int, int>> m(n);\\n    vector<int> dist(n);\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j < pref[i].size(); ++j)\\n            m[i][pref[i][j]] = j;\\n    }\\n    for (auto &p : pairs) {\\n        dist[p[0]] = m[p[0]][p[1]];\\n        dist[p[1]] = m[p[1]][p[0]];\\n    }\\n    int res = 0;\\n    for (int i = 0; i < n; ++i) {\\n        for (int d = 0; d < dist[i]; ++d) {\\n            int j = pref[i][d];\\n            for (int d1 = 0; d1 < dist[j]; ++d1) {\\n                if (i == pref[j][d1]) {\\n                    ++res;\\n                    d = d1 = n;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n    vector<unordered_map<int, int>> m(n);\\n    vector<int> dist(n);\\n    for (int i = 0; i < n; ++i) {\\n        for (int j = 0; j < pref[i].size(); ++j)\\n            m[i][pref[i][j]] = j;\\n    }\\n    for (auto &p : pairs) {\\n        dist[p[0]] = m[p[0]][p[1]];\\n        dist[p[1]] = m[p[1]][p[0]];\\n    }\\n    int res = 0;\\n    for (int i = 0; i < n; ++i) {\\n        for (int d = 0; d < dist[i]; ++d) {\\n            int j = pref[i][d];\\n            for (int d1 = 0; d1 < dist[j]; ++d1) {\\n                if (i == pref[j][d1]) {\\n                    ++res;\\n                    d = d1 = n;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890091,
                "title": "python-make-you-happy-with-clean-and-concise-solution",
                "content": "The problem description is not very clear. Please find below clean, concise and self explanatory code. \\nTime Complexity: O(n^2). Space Complexity: O(n^2)\\nIncluding comments in the code for better understanding. Kindly upvote if you like the solution.\\n\\n\\t\\t#Map to get pair mapping\\n        pairMap = defaultdict(int)\\n        #To get preference of person i with person j in O(1)\\n        prefer = {}\\n        \\n        #Populating pairMap\\n        for p1,p2 in pairs:\\n            pairMap[p1] = p2\\n            pairMap[p2] = p1\\n        \\n         #Populating prefer Map\\n        for i in range(len(preferences)):\\n            for j in range(n-1):\\n                if i not in prefer:\\n                    prefer[i] = {}\\n                prefer[i][preferences[i][j]] = j\\n        \\n        #Looping through preferences again to find if person i is unhappy\\n        res = 0\\n        for i in range(len(preferences)):\\n            for j in range(n-1):\\n                x = i\\n                y = pairMap[x]\\n                u = preferences[x][j]\\n                v = pairMap[u]\\n                if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\\n                    res+=1\\n                    break\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "The problem description is not very clear. Please find below clean, concise and self explanatory code. \\nTime Complexity: O(n^2). Space Complexity: O(n^2)\\nIncluding comments in the code for better understanding. Kindly upvote if you like the solution.\\n\\n\\t\\t#Map to get pair mapping\\n        pairMap = defaultdict(int)\\n        #To get preference of person i with person j in O(1)\\n        prefer = {}\\n        \\n        #Populating pairMap\\n        for p1,p2 in pairs:\\n            pairMap[p1] = p2\\n            pairMap[p2] = p1\\n        \\n         #Populating prefer Map\\n        for i in range(len(preferences)):\\n            for j in range(n-1):\\n                if i not in prefer:\\n                    prefer[i] = {}\\n                prefer[i][preferences[i][j]] = j\\n        \\n        #Looping through preferences again to find if person i is unhappy\\n        res = 0\\n        for i in range(len(preferences)):\\n            for j in range(n-1):\\n                x = i\\n                y = pairMap[x]\\n                u = preferences[x][j]\\n                v = pairMap[u]\\n                if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\\n                    res+=1\\n                    break\\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 843968,
                "title": "java-1-ms-faster-than-100-00-stable-matching-code-with-explanation-supper-easy-to-understand",
                "content": "\\t/*\\n    idea:\\n        1. for each person in the pair, check this person\\'s prefered mate \"a\", and \"a\"\\'s priority\\n    */\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int res=0;\\n        HashMap<Integer, Integer> map = buildHashMap(pairs);\\n        for(int[] pair : pairs){\\n            //check both people in pair\\n            if(isHappy(pair[0], pair[1], preferences, map)!=-1){\\n                res+=1; //unhappy pair\\n            }\\n            if(isHappy(pair[1], pair[0], preferences, map)!=-1){\\n                res+=1; //unhappy pair\\n            }            \\n        }\\n        return res;\\n    }\\n    \\n    //check if this person is happy\\n    //happy returns -1; unhappy return pair\\'s ID\\n    /*\\n    unhappy:\\n        x prefers u over y, and\\n        u prefers x over v.\\n    */\\n    private int isHappy(int person, int curMate, int[][] preferences, HashMap<Integer, Integer> map){\\n        \\n        //sorted mates: \\n        for(int mate : preferences[person]){            \\n            if(mate == curMate) return -1; //best it can be for this person\\n            //x prefers u over y: check this mate\\'s preference\\n            //Now: check if: u prefers x over v.\\n            int matesCurMate = map.get(mate);\\n            for(int matesMate : preferences[mate]){\\n                if(matesMate==person){\\n                    //unstable matching\\n                    return mate;\\n                }else if(matesMate == matesCurMate){\\n                    //stable matching for this mate\\n                    break;\\n                }\\n            }\\n        }\\n        //happy as it is\\n        return -1;\\n    }\\n    \\n    //helper to build bijection mapping\\n    private HashMap<Integer, Integer> buildHashMap(int[][] pairs){\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int[] pair : pairs){\\n            map.put(pair[0],pair[1]);\\n            map.put(pair[1],pair[0]);\\n        }\\n        return map;\\n    }",
                "solutionTags": [],
                "code": "\\t/*\\n    idea:\\n        1. for each person in the pair, check this person\\'s prefered mate \"a\", and \"a\"\\'s priority\\n    */\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int res=0;\\n        HashMap<Integer, Integer> map = buildHashMap(pairs);\\n        for(int[] pair : pairs){\\n            //check both people in pair\\n            if(isHappy(pair[0], pair[1], preferences, map)!=-1){\\n                res+=1; //unhappy pair\\n            }\\n            if(isHappy(pair[1], pair[0], preferences, map)!=-1){\\n                res+=1; //unhappy pair\\n            }            \\n        }\\n        return res;\\n    }\\n    \\n    //check if this person is happy\\n    //happy returns -1; unhappy return pair\\'s ID\\n    /*\\n    unhappy:\\n        x prefers u over y, and\\n        u prefers x over v.\\n    */\\n    private int isHappy(int person, int curMate, int[][] preferences, HashMap<Integer, Integer> map){\\n        \\n        //sorted mates: \\n        for(int mate : preferences[person]){            \\n            if(mate == curMate) return -1; //best it can be for this person\\n            //x prefers u over y: check this mate\\'s preference\\n            //Now: check if: u prefers x over v.\\n            int matesCurMate = map.get(mate);\\n            for(int matesMate : preferences[mate]){\\n                if(matesMate==person){\\n                    //unstable matching\\n                    return mate;\\n                }else if(matesMate == matesCurMate){\\n                    //stable matching for this mate\\n                    break;\\n                }\\n            }\\n        }\\n        //happy as it is\\n        return -1;\\n    }\\n    \\n    //helper to build bijection mapping\\n    private HashMap<Integer, Integer> buildHashMap(int[][] pairs){\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int[] pair : pairs){\\n            map.put(pair[0],pair[1]);\\n            map.put(pair[1],pair[0]);\\n        }\\n        return map;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 844024,
                "title": "c-best-solution-beats-100-runtime-75-less-space-self-explanatory",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>> &p, vector<vector<int>> &pairs)\\n    {\\n        int res = 0, d,v, count;\\n        vector<int> pairing(n);\\n        vector<vector<int>> friends(n, vector<int>(n));\\n\\t\\t\\n        for (int i = 0; i < p.size(); ++i)\\n            for (int j = 0; j < p[i].size(); ++j)\\n                friends[i][p[i][j]] = j;\\n\\n        for (auto &it : pairs)\\n            pairing[it[0]] = it[1], pairing[it[1]] = it[0];\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            count = 0;\\n            for (int j = 0; j < n; ++j)\\n                if (j != i && j != pairing[i])\\n                {\\n                    d = pairing[i], v = pairing[j];\\n                    if (friends[i][j] < friends[i][d] && friends[j][i] < friends[j][v])\\n                        count = 1;\\n                }\\n            res += count;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>> &p, vector<vector<int>> &pairs)\\n    {\\n        int res = 0, d,v, count;\\n        vector<int> pairing(n);\\n        vector<vector<int>> friends(n, vector<int>(n));\\n\\t\\t\\n        for (int i = 0; i < p.size(); ++i)\\n            for (int j = 0; j < p[i].size(); ++j)\\n                friends[i][p[i][j]] = j;\\n\\n        for (auto &it : pairs)\\n            pairing[it[0]] = it[1], pairing[it[1]] = it[0];\\n\\n        for (int i = 0; i < n; ++i)\\n        {\\n            count = 0;\\n            for (int j = 0; j < n; ++j)\\n                if (j != i && j != pairing[i])\\n                {\\n                    d = pairing[i], v = pairing[j];\\n                    if (friends[i][j] < friends[i][d] && friends[j][i] < friends[j][v])\\n                        count = 1;\\n                }\\n            res += count;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844348,
                "title": "simple-c-solution-100-time-efficient-100-memory-efficent-explained-commented",
                "content": "consider example-->\\n n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\\n \\n consider for 0->\\niterate through its pref until we reach its current assigned pair i.e. [ ] (to iterate)\\nas we see see 0 is set with its first pref no need to check further;\\n\\nconsider 1->\\n->iterate through its pref ,[3, 2, 0], until we reach its current assigned pair i.e. [3, 2],  (to iterate)\\n->check for value in this such that if there exist a pair  such that it is pair with some one else but has 1 as pref ;\\n->so lets start with 3 its pref are [1, 2, 0],iterate through it until we reach 3\\'s assigned pair i.e. [1] (to iterate)\\n\\nnow you may see that 3 is paired with 2 but we can be set with 1(current i) for better happiness.\\n\\nconsider->2\\n2 is set with 3 and its his first pref so no iteration.\\n\\nconsider 3->\\n->iterate through its pref ,[1, 2, 0], until we reach its current assigned pair i.e. [1],  (to iterate)\\n->check for value in this such that if there exist a pair  such that it is pair with with some one else but has 3 as pref ;\\n->so lets start with 1 its pref are [3,2,0],iterate through it until we reach 1\\'s assigned pair i.e. [3] (to iterate)\\n\\nnow you may see that 1 is paired with 0 but we  can  set with 3(current i) for better happiness.\\n\\n\\n \\n \\n\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& prs) {\\n        vector<int>v(n);\\n        for(vector<int>vx:prs)//store the current assigned pair\\n        {\\n            v[vx[0]]=vx[1];\\n            v[vx[1]]=vx[0];\\n        }\\n        int res=0;  //to store result\\n        for(int i=0;i<n;i++)    //start from 0 iterate through every point\\n        {\\n            int x=0;\\n            for(int j=0;j<pref[i].size();j++)    // iterate through its pref.\\n            {\\n                if(pref[i][j]==v[i])break; // if we reach current assigned value then i is happy no need to check further\\n                \\n                for(int k=0;k<pref[pref[i][j]].size();k++)  //iterate through pref. of pref[i][j] to check if we reach i before reaching assigned value of pref[i][j]  \\n                {\\n                    if(pref[pref[i][j]][k]==i) // if we reach i for any value in pref list before its assigned we find its unhappy couple.  \\n                    {x++;break;}\\n                    if(pref[pref[i][j]][k]==v[pref[i][j]]) // if we reach assigned pair before reaching i the this value in pref of i is happy \\n                        break;\\n                }\\n                if(x)break;  //we find a pair for i no need to check further\\n            }\\n             res+=x; // increment the result \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& prs) {\\n        vector<int>v(n);\\n        for(vector<int>vx:prs)//store the current assigned pair\\n        {\\n            v[vx[0]]=vx[1];\\n            v[vx[1]]=vx[0];\\n        }\\n        int res=0;  //to store result\\n        for(int i=0;i<n;i++)    //start from 0 iterate through every point\\n        {\\n            int x=0;\\n            for(int j=0;j<pref[i].size();j++)    // iterate through its pref.\\n            {\\n                if(pref[i][j]==v[i])break; // if we reach current assigned value then i is happy no need to check further\\n                \\n                for(int k=0;k<pref[pref[i][j]].size();k++)  //iterate through pref. of pref[i][j] to check if we reach i before reaching assigned value of pref[i][j]  \\n                {\\n                    if(pref[pref[i][j]][k]==i) // if we reach i for any value in pref list before its assigned we find its unhappy couple.  \\n                    {x++;break;}\\n                    if(pref[pref[i][j]][k]==v[pref[i][j]]) // if we reach assigned pair before reaching i the this value in pref of i is happy \\n                        break;\\n                }\\n                if(x)break;  //we find a pair for i no need to check further\\n            }\\n             res+=x; // increment the result \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843947,
                "title": "javascript-hashmap",
                "content": "1. build the happyMap the record the rank of happiness\\nex: \\nInput: `n = 4`, preferences = `[[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]]`, pairs = `[[0, 1], [2, 3]]`\\nOutput: 2\\n`p1 - p2 - rank`\\n`0 - 1 - 0`\\n`1 - 0 - 2`\\n`2 - 3 - 0`\\n`3 - 2 - 1`\\n`==> happyMap: [0, 2, 0, 1]`\\n\\n2. Check each person. If there is one higher rank person who prefer to be partnered with him/her, `unhappy++`\\n\\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let happyMap = new Array(n);\\n    for (let [i, j] of pairs) {\\n        happyMap[i] = preferences[i].indexOf(j);\\n        happyMap[j] = preferences[j].indexOf(i);\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < happyMap[i]; j++) {\\n            let partner = preferences[i][j];\\n            if (preferences[partner].indexOf(i) < happyMap[partner]) {\\n                unhappy++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "1. build the happyMap the record the rank of happiness\\nex: \\nInput: `n = 4`, preferences = `[[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]]`, pairs = `[[0, 1], [2, 3]]`\\nOutput: 2\\n`p1 - p2 - rank`\\n`0 - 1 - 0`\\n`1 - 0 - 2`\\n`2 - 3 - 0`\\n`3 - 2 - 1`\\n`==> happyMap: [0, 2, 0, 1]`\\n\\n2. Check each person. If there is one higher rank person who prefer to be partnered with him/her, `unhappy++`\\n\\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let happyMap = new Array(n);\\n    for (let [i, j] of pairs) {\\n        happyMap[i] = preferences[i].indexOf(j);\\n        happyMap[j] = preferences[j].indexOf(i);\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < happyMap[i]; j++) {\\n            let partner = preferences[i][j];\\n            if (preferences[partner].indexOf(i) < happyMap[partner]) {\\n                unhappy++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 844542,
                "title": "4ms-java-solution",
                "content": "Looks like the fastest java solution according to the submissions page. Did a simple optimization -\\nReduce the number of compares by starting the second loop from i+1 instead of 0(like in the other solutions) because according to the unhappy friend definition, friends will be unhappy in pairs.\\n\\nBelow is the code. Do comment if you find any issues with the code.\\n\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] prefMap = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n-1; j++) {\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        int a,b,prefA,prefB,prefEle1,prefEle2,ele1,ele2;\\n        int count = 0;\\n        boolean[] flags = new boolean[n];\\n        for (int i = 0; i < pairs.length; i++) {\\n            a = pairs[i][0];\\n            b = pairs[i][1];\\n            prefB = prefMap[a][b];\\n            prefA = prefMap[b][a];\\n            for (int j = i+1; j < pairs.length; j++) {\\n                ele1 = pairs[j][0];\\n                ele2 = pairs[j][1];\\n                prefEle2 = prefMap[ele1][ele2];\\n                prefEle1 = prefMap[ele2][ele1];\\n      \\n                if (prefB > prefMap[a][ele1] && prefEle2 > prefMap[ele1][a]) {\\n                    flags[a] = true;\\n                    flags[ele1] = true;\\n                }\\n                if (prefB > prefMap[a][ele2] && prefEle1 > prefMap[ele2][a]) {\\n                    flags[a] = true;\\n                    flags[ele2] = true;\\n                }\\n                \\n                if (prefA > prefMap[b][ele1] && prefEle2 > prefMap[ele1][b]) {\\n                    flags[b] = true;\\n                    flags[ele1] = true;\\n                }\\n                if (prefA > prefMap[b][ele2] && prefEle1 > prefMap[ele2][b]) {\\n                    flags[b] = true;\\n                    flags[ele2] = true;\\n                }\\n            }\\n            \\n        }\\n        \\n        for (boolean flag : flags) {\\n            if (flag) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] prefMap = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n-1; j++) {\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        int a,b,prefA,prefB,prefEle1,prefEle2,ele1,ele2;\\n        int count = 0;\\n        boolean[] flags = new boolean[n];\\n        for (int i = 0; i < pairs.length; i++) {\\n            a = pairs[i][0];\\n            b = pairs[i][1];\\n            prefB = prefMap[a][b];\\n            prefA = prefMap[b][a];\\n            for (int j = i+1; j < pairs.length; j++) {\\n                ele1 = pairs[j][0];\\n                ele2 = pairs[j][1];\\n                prefEle2 = prefMap[ele1][ele2];\\n                prefEle1 = prefMap[ele2][ele1];\\n      \\n                if (prefB > prefMap[a][ele1] && prefEle2 > prefMap[ele1][a]) {\\n                    flags[a] = true;\\n                    flags[ele1] = true;\\n                }\\n                if (prefB > prefMap[a][ele2] && prefEle1 > prefMap[ele2][a]) {\\n                    flags[a] = true;\\n                    flags[ele2] = true;\\n                }\\n                \\n                if (prefA > prefMap[b][ele1] && prefEle2 > prefMap[ele1][b]) {\\n                    flags[b] = true;\\n                    flags[ele1] = true;\\n                }\\n                if (prefA > prefMap[b][ele2] && prefEle1 > prefMap[ele2][b]) {\\n                    flags[b] = true;\\n                    flags[ele2] = true;\\n                }\\n            }\\n            \\n        }\\n        \\n        for (boolean flag : flags) {\\n            if (flag) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843937,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairht, int f, int you){\\n        bool isTrue=false;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(preferences[you][i]==pairht[you]) break;\\n            \\n            if(preferences[you][i]==f)\\n                isTrue=true;\\n        }\\n        \\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> pairht(n);\\n        for(vector<int> pair : pairs){\\n            pairht[pair[0]]=pair[1];\\n            pairht[pair[1]]=pair[0];\\n        }\\n        \\n        int result=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(preferences[i][j]==pairht[i]) break;\\n                \\n                if(check(n, preferences, pairht, i, preferences[i][j])){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairht, int f, int you){\\n        bool isTrue=false;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(preferences[you][i]==pairht[you]) break;\\n            \\n            if(preferences[you][i]==f)\\n                isTrue=true;\\n        }\\n        \\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> pairht(n);\\n        for(vector<int> pair : pairs){\\n            pairht[pair[0]]=pair[1];\\n            pairht[pair[1]]=pair[0];\\n        }\\n        \\n        int result=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(preferences[i][j]==pairht[i]) break;\\n                \\n                if(check(n, preferences, pairht, i, preferences[i][j])){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004812,
                "title": "easiest-solution-dictionary-and-array",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        d = {}\\n        count = 0\\n        \\n        for x,y in pairs:\\n            d[x] = list(preferences[x][:preferences[x].index(y)])\\n            d[y] = list(preferences[y][:preferences[y].index(x)])\\n            \\n       \\n        for x, arr in d.items():\\n            for z in arr:\\n                if x in d[z]:\\n                    count+=1\\n                    break\\n                    \\n        return count\\n            \\n            \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        d = {}\\n        count = 0\\n        \\n        for x,y in pairs:\\n            d[x] = list(preferences[x][:preferences[x].index(y)])\\n            d[y] = list(preferences[y][:preferences[y].index(x)])\\n            \\n       \\n        for x, arr in d.items():\\n            for z in arr:\\n                if x in d[z]:\\n                    count+=1\\n                    break\\n                    \\n        return count\\n            \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 847400,
                "title": "java-simple-o-n-solution",
                "content": "We do not need to construct graph. Just iterate input `pairs` array and do what is asked in the problem. To simplify lookup we can store data in `Adjacency matrix`. This implies O(n\\xB2) time complexity and O(n\\xB2) space. We can reduce space to O(n) and use O(n\\xB3) time\\n\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] matrix = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                matrix[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        boolean[] unhappy = new boolean[n];\\n        for (int i = 0; i + i < n; i++) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n            \\n            for (int j = 0; j + j < n; j++) {\\n                if (i == j) continue;\\n                \\n                int u = pairs[j][0], v = pairs[j][1];\\n                if (matrix[x][u] < matrix[x][y] && matrix[u][x] < matrix[u][v]\\n                 || matrix[x][v] < matrix[x][y] && matrix[v][x] < matrix[v][u]) unhappy[x] = true;\\n                if (matrix[y][u] < matrix[y][x] && matrix[u][y] < matrix[u][v]\\n                 || matrix[y][v] < matrix[y][x] && matrix[v][y] < matrix[v][u]) unhappy[y] = true;\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < n; i++) if (unhappy[i]) answer++;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] matrix = new int[n][n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                matrix[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        boolean[] unhappy = new boolean[n];\\n        for (int i = 0; i + i < n; i++) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n            \\n            for (int j = 0; j + j < n; j++) {\\n                if (i == j) continue;\\n                \\n                int u = pairs[j][0], v = pairs[j][1];\\n                if (matrix[x][u] < matrix[x][y] && matrix[u][x] < matrix[u][v]\\n                 || matrix[x][v] < matrix[x][y] && matrix[v][x] < matrix[v][u]) unhappy[x] = true;\\n                if (matrix[y][u] < matrix[y][x] && matrix[u][y] < matrix[u][v]\\n                 || matrix[y][v] < matrix[y][x] && matrix[v][y] < matrix[v][u]) unhappy[y] = true;\\n            }\\n        }\\n        \\n        int answer = 0;\\n        for (int i = 0; i < n; i++) if (unhappy[i]) answer++;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844244,
                "title": "python-short-fast-98-easy-to-understand",
                "content": "In the first step, we form list of sets *better*: for each person, who is better than the current friend in the pair.\\nIn the second step, we go over all pairs of the people to see if they are simultaneously better than their current friends in the pair.\\n\\nThat is it.\\n\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        better=[set() for i in range(n)]\\n        for p1, p2 in pairs:\\n            better[p1]=set(pref[p1][:pref[p1].index(p2)])     \\n            better[p2]=set(pref[p2][:pref[p2].index(p1)])\\n            \\n        unhappy=0\\n        for i in range(n):\\n            if any(i in better[j] for j in better[i]): unhappy += 1\\n                \\n        return unhappy\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        better=[set() for i in range(n)]\\n        for p1, p2 in pairs:\\n            better[p1]=set(pref[p1][:pref[p1].index(p2)])     \\n            better[p2]=set(pref[p2][:pref[p2].index(p1)])\\n            \\n        unhappy=0\\n        for i in range(n):\\n            if any(i in better[j] for j in better[i]): unhappy += 1\\n                \\n        return unhappy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831941,
                "title": "python-solution-easy-to-read-logic-in-the-question",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # Do I prefer someone over you? \\n        # Do they prefer me back over thier person?\\n        # check who my partner is \\n        # Check where I ranked them \\n        # for anyone who ranked earlier than my current partner \\n        # did they rank me earlier than thier current partner? if so I am unhappy\\n        \\n        pairingDict = {}\\n        for i in pairs:\\n            pairingDict[i[0]] = i[1]\\n            pairingDict[i[1]] = i[0]\\n        \\n        def unhappy(main,partner):\\n            #checks if main is unhappy with partner\\n            partnerIndex = preferences[main].index(partner)\\n            if partnerIndex == 0: \\n                return False\\n            partnerIndex -= 1\\n            while partnerIndex >= 0:\\n                better = preferences[main][partnerIndex]\\n                betterPartner = pairingDict[better]\\n                #does better rank me higher then thier current partner? \\n                if preferences[better].index(betterPartner) > preferences[better].index(main):\\n                    return True\\n                partnerIndex -= 1\\n                   \\n        unhappyCount = 0\\n        if len(pairs) == 1:\\n            return 0 \\n        for i in pairs:\\n            # is i[0] unhappy?\\n            if unhappy(i[0],i[1]):\\n                unhappyCount +=1 \\n            if unhappy(i[1],i[0]):\\n                unhappyCount +=1 \\n        return unhappyCount\\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # Do I prefer someone over you? \\n        # Do they prefer me back over thier person?\\n        # check who my partner is \\n        # Check where I ranked them \\n        # for anyone who ranked earlier than my current partner \\n        # did they rank me earlier than thier current partner? if so I am unhappy\\n        \\n        pairingDict = {}\\n        for i in pairs:\\n            pairingDict[i[0]] = i[1]\\n            pairingDict[i[1]] = i[0]\\n        \\n        def unhappy(main,partner):\\n            #checks if main is unhappy with partner\\n            partnerIndex = preferences[main].index(partner)\\n            if partnerIndex == 0: \\n                return False\\n            partnerIndex -= 1\\n            while partnerIndex >= 0:\\n                better = preferences[main][partnerIndex]\\n                betterPartner = pairingDict[better]\\n                #does better rank me higher then thier current partner? \\n                if preferences[better].index(betterPartner) > preferences[better].index(main):\\n                    return True\\n                partnerIndex -= 1\\n                   \\n        unhappyCount = 0\\n        if len(pairs) == 1:\\n            return 0 \\n        for i in pairs:\\n            # is i[0] unhappy?\\n            if unhappy(i[0],i[1]):\\n                unhappyCount +=1 \\n            if unhappy(i[1],i[0]):\\n                unhappyCount +=1 \\n        return unhappyCount\\n            \\n            \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 844016,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\t\\t\\tif n==2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\thash={}\\n\\t\\t\\tunhappy=0\\n\\t\\t\\tfor i in pairs:\\n\\t\\t\\t\\thash[i[0]]=i[1]\\n\\t\\t\\t\\thash[i[1]]=i[0]\\n\\t\\t\\tfor i in range(len(preferences)):\\n\\t\\t\\t\\tpairedwith=hash[i]\\n\\t\\t\\t\\ttemp=preferences[i][:preferences[i].index(pairedwith)]\\n\\t\\t\\t\\tif len(temp)==0:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tfor j in temp:\\n\\t\\t\\t\\t\\tif preferences[j].index(i)<preferences[j].index(hash[j]):\\n\\t\\t\\t\\t\\t\\tunhappy+=1\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn unhappy",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\t\\t\\tif n==2:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\thash={}",
                "codeTag": "Java"
            },
            {
                "id": 843939,
                "title": "a-few-solutions",
                "content": "We can use a `\\uD83D\\uDDFA` map `m` to store the `k`<sup>th</sup> preference per `i`<sup>th</sup> friend for O(1) lookups per comparison, ie. the `i`<sup>th</sup> friends\\'s preference for the `j`<sup>th</sup> friend is stored in `m[i][j]`.  And we can use another `\\uD83D\\uDDFA` map `adj` to store adjacent pairs.  Increment the count `cnt` each time we find an `i`,`j` pair where the `i`<sup>th</sup> friend prefers the `j`<sup>th</sup> friend over the `i`<sup>th</sup> friend\\'s adjacent pair and the `j`<sup>th</sup> friend prefers the `i`<sup>th</sup> friend over the `j`<sup>th</sup> friend\\'s adjacent pair.\\n\\n**Note:** Thanks to @andrewquartey for the optimization to make this code more concise \\n\\n---\\n\\n*Javascript*\\n```\\nlet unhappyFriends = (N, pref, pairs, adj = new Map(), cnt = 0) => {\\n    pairs.forEach(([i, j]) => {\\n        adj.set(i, j);\\n        adj.set(j, i);\\n    });\\n    let m = [...Array(N)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0, k = N; j < pref[i].length; ++j, --k)\\n            m[i][pref[i][j]] = k;                     // k-th order of preference (highest preference on the left, lowest preference on the right)\\n    for (let i = 0; i < N; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            if (i == j)\\n                continue;\\n            if (m[i][j] > m[i][adj.get(i)] &&         // i prefers j over i\\'s adjacent pair\\n                m[j][i] > m[j][adj.get(j)]) {         // j prefers i over j\\'s adjacent pair\\n                ++cnt;\\n                break;                                // \\uD83C\\uDFAF i-th unhappy friend found\\n            }\\n        }\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def unhappyFriends(self, N: int, pref: List[List[int]], pairs: List[List[int]], cnt = 0) -> int:\\n        adj = {}\\n        for i, j in pairs:\\n            adj[i] = j\\n            adj[j] = i\\n        m = [[0] * N for _ in range(N)]\\n        for i in range(N):\\n            k = N\\n            for j in range(len(pref[i])):\\n                m[i][pref[i][j]] = k; k -= 1   # k-th order of preference (highest preference on the left, lowest preference on the right)\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                if m[i][j] > m[i][adj[i]] and m[j][i] > m[j][adj[j]]:  # i prefers j over i\\'s adjacent pair and j prefers i over j\\'s adjacent pair\\n                    cnt += 1\\n                    break                      # \\uD83C\\uDFAF i-th unhappy friend found\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, int>;\\n    int unhappyFriends(int N, VVI& pref, VVI& pairs, Map adj = {}, int cnt = 0) {\\n        for (auto& pair: pairs) {\\n            auto [i, j] = tie(pair[0], pair[1]);\\n            adj[i] = j;\\n            adj[j] = i;\\n        }\\n        VVI m(N, VI(N));\\n        for (auto i{ 0 }; i < pref.size(); ++i)\\n            for (auto j{ 0 }, k{ N }; j < pref[i].size(); ++j, --k)\\n                m[i][pref[i][j]] = k;                 // k-th order of preference (highest preference on the left, lowest preference on the right)\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                if (i == j)\\n                    continue;\\n                if (m[i][j] > m[i][adj[i]] &&         // i prefers j over i\\'s adjacent pair\\n                    m[j][i] > m[j][adj[j]]) {         // j prefers i over j\\'s adjacent pair\\n                    ++cnt;\\n                    break;                            // \\uD83C\\uDFAF i-th unhappy friend found\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet unhappyFriends = (N, pref, pairs, adj = new Map(), cnt = 0) => {\\n    pairs.forEach(([i, j]) => {\\n        adj.set(i, j);\\n        adj.set(j, i);\\n    });\\n    let m = [...Array(N)].map(_ => Array(N).fill(0));\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0, k = N; j < pref[i].length; ++j, --k)\\n            m[i][pref[i][j]] = k;                     // k-th order of preference (highest preference on the left, lowest preference on the right)\\n    for (let i = 0; i < N; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            if (i == j)\\n                continue;\\n            if (m[i][j] > m[i][adj.get(i)] &&         // i prefers j over i\\'s adjacent pair\\n                m[j][i] > m[j][adj.get(j)]) {         // j prefers i over j\\'s adjacent pair\\n                ++cnt;\\n                break;                                // \\uD83C\\uDFAF i-th unhappy friend found\\n            }\\n        }\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def unhappyFriends(self, N: int, pref: List[List[int]], pairs: List[List[int]], cnt = 0) -> int:\\n        adj = {}\\n        for i, j in pairs:\\n            adj[i] = j\\n            adj[j] = i\\n        m = [[0] * N for _ in range(N)]\\n        for i in range(N):\\n            k = N\\n            for j in range(len(pref[i])):\\n                m[i][pref[i][j]] = k; k -= 1   # k-th order of preference (highest preference on the left, lowest preference on the right)\\n        for i in range(N):\\n            for j in range(N):\\n                if i == j:\\n                    continue\\n                if m[i][j] > m[i][adj[i]] and m[j][i] > m[j][adj[j]]:  # i prefers j over i\\'s adjacent pair and j prefers i over j\\'s adjacent pair\\n                    cnt += 1\\n                    break                      # \\uD83C\\uDFAF i-th unhappy friend found\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Map = unordered_map<int, int>;\\n    int unhappyFriends(int N, VVI& pref, VVI& pairs, Map adj = {}, int cnt = 0) {\\n        for (auto& pair: pairs) {\\n            auto [i, j] = tie(pair[0], pair[1]);\\n            adj[i] = j;\\n            adj[j] = i;\\n        }\\n        VVI m(N, VI(N));\\n        for (auto i{ 0 }; i < pref.size(); ++i)\\n            for (auto j{ 0 }, k{ N }; j < pref[i].size(); ++j, --k)\\n                m[i][pref[i][j]] = k;                 // k-th order of preference (highest preference on the left, lowest preference on the right)\\n        for (auto i{ 0 }; i < N; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                if (i == j)\\n                    continue;\\n                if (m[i][j] > m[i][adj[i]] &&         // i prefers j over i\\'s adjacent pair\\n                    m[j][i] > m[j][adj[j]]) {         // j prefers i over j\\'s adjacent pair\\n                    ++cnt;\\n                    break;                            // \\uD83C\\uDFAF i-th unhappy friend found\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766612,
                "title": "python-3-4-lines-w-explanation-t-m-95-71",
                "content": "Here\\'s how the code works:\\n\\nWe initialize a defaultdict`sc`, which will store the preferred friends for each pair `u` and friend `v` in the pairs.\\n\\nWe iterate [u, v] in the pairs list. For each pair in`pairs`, we assign the preferred friends before`u`and `v` to `sc[u]` and `sc[v]` respectively. The preferred friends are determined by taking a slice of the preferences list for the respective friend up to the index where the other friend is found. This allows easy comparison of preferences.\\n\\nAfter processing all pairs, we iterate over each friend `u`, checking whether there exists a friend `v` in `sc[u]` (i.e., `u` prefers `v`) such that `u` is also present in the preferred friends of `v` (i.e., v`prefers `u` over their current pairing). We check whether any friend in `sc[u]` satisfies this condition.\\n\\nWe return the count of`True`values, which represents the number of unhappy friends.  --*ChatGPT*\\n```\\nclass Solution:\\n\\tdef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n\\t\\tsc = defaultdict()\\n\\n\\t\\tfor u,v in pairs:\\n\\t\\t\\t\\n\\t\\t\\tsc[u],sc[v] = (preferences[u][:preferences[u].index(v)],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t preferences[v][:preferences[v].index(u)])\\n\\t\\t\\t\\n\\t\\treturn sum(any(u in sc[v] for v in sc[u]) for u in range(n))\\n```\\n[https://leetcode.com/problems/count-unhappy-friends/submissions/994728034/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), in which *N* ~`n`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n\\t\\tsc = defaultdict()\\n\\n\\t\\tfor u,v in pairs:\\n\\t\\t\\t\\n\\t\\t\\tsc[u],sc[v] = (preferences[u][:preferences[u].index(v)],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t preferences[v][:preferences[v].index(u)])\\n\\t\\t\\t\\n\\t\\treturn sum(any(u in sc[v] for v in sc[u]) for u in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693627,
                "title": "easy-c-solution-simple-explanation-only-array-concepts-used",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isUnhappy(int n, vector<vector<int>>& pref, vector<int> pairing, int f, int person){\\n        bool isTrue=false;\\n        for(int i=0; i<n-1; i++){ \\n            if(pref[person][i]==pairing[person])   break;\\n            if(pref[person][i]==f)     isTrue=true;\\n        }\\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n        vector<int> pairing(n); \\n        for(vector<int> pair : pairs){ // Pair the friend with their given paired person\\n            pairing[pair[0]]=pair[1];\\n            pairing[pair[1]]=pair[0];\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(pref[i][j]==pairing[i])   break; // If the friend is paired with their prefered person then break since they are not unhappy\\n                if(isUnhappy(n, pref, pairing, i, pref[i][j])){ // If friend is not paired with their most prefered person, check if they are unhappy\\n                    ans++; // If unhappy then increment ans\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUnhappy(int n, vector<vector<int>>& pref, vector<int> pairing, int f, int person){\\n        bool isTrue=false;\\n        for(int i=0; i<n-1; i++){ \\n            if(pref[person][i]==pairing[person])   break;\\n            if(pref[person][i]==f)     isTrue=true;\\n        }\\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n        vector<int> pairing(n); \\n        for(vector<int> pair : pairs){ // Pair the friend with their given paired person\\n            pairing[pair[0]]=pair[1];\\n            pairing[pair[1]]=pair[0];\\n        }\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(pref[i][j]==pairing[i])   break; // If the friend is paired with their prefered person then break since they are not unhappy\\n                if(isUnhappy(n, pref, pairing, i, pref[i][j])){ // If friend is not paired with their most prefered person, check if they are unhappy\\n                    ans++; // If unhappy then increment ans\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780521,
                "title": "python-easy-explained-99-fast",
                "content": "As per the explanation we got to understand that we first have to make somthing that holds people with their priorities and whats better than a DICT to do so . \\nSo we can say as per the first example friend have a preferece:\\n0 : 1,2,3\\n1 : 3,2,0\\n2 : 3,1,0\\n3 : 1,2,0\\n\\nAnd given pairs are  = [[0, 1], [2, 3]]\\n0 is happy, because 1 is the first preferece\\n1 is unhappy, because 3 is its prior preference,\\n2 is happy because 3 is its first preference\\n3 is also unhappy because 1 is its preferece ans\\n\\nSo the total count of unhappy friends are 2\\n\\nStep1: for each, we should check wehther they have a prior preference than the current pair\\n        use a dictionary:\\n        {\\n            0: [ ],1: [3],2: [ ],3: [1]\\n        }\\n  Step2:  then we start the iteration, for each key, if the key appear in the dict[value],\\n        which suggest, the key and the value all have an another prefered choice, then we should\\n        add the result by 1 at last just return res\\n```\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        priority = {}\\n\\t\\t#making priority dictonary\\n        for p1, p2 in pairs:\\n            priority[p1] = preferences[p1][:preferences[p1].index(p2)]\\n            priority[p2] = preferences[p2][:preferences[p2].index(p1)]\\n        #start the iteration\\n        res = 0 #act as a counter for unhappy friends\\n        for p1 in priority:\\n            for p2 in priority[p1]:\\n                if p1 in priority[p2]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        priority = {}\\n\\t\\t#making priority dictonary\\n        for p1, p2 in pairs:\\n            priority[p1] = preferences[p1][:preferences[p1].index(p2)]\\n            priority[p2] = preferences[p2][:preferences[p2].index(p1)]\\n        #start the iteration\\n        res = 0 #act as a counter for unhappy friends\\n        for p1 in priority:\\n            for p2 in priority[p1]:\\n                if p1 in priority[p2]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345920,
                "title": "success-details-runtime-394-ms-faster-than-99-40-of-python3-online-submissions-vimla-kushwaha",
                "content": "![image](https://assets.leetcode.com/users/images/7907ab0b-1d01-44a1-96ad-cf5e1009cf74_1659012539.3602684.png)\\n**Best possible solution from me**\\nif you found any doubt .., feel free to ask in comment section\\nkeep smiling seep learning\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        dd = {}\\n        \\n        for i,x in pairs:\\n            dd[i] = preferences[i][:preferences[i].index(x)]\\n            dd[x] = preferences[x][:preferences[x].index(i)]\\n        \\n        ans = 0\\n            \\n        for i in dd:\\n            for x in dd[i]:\\n                if i in dd[x]:\\n                    ans += 1\\n                    break\\n        \\n        return ans\\n```\\n**upote** if it helped you out somehow !1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        dd = {}\\n        \\n        for i,x in pairs:\\n            dd[i] = preferences[i][:preferences[i].index(x)]\\n            dd[x] = preferences[x][:preferences[x].index(i)]\\n        \\n        ans = 0\\n            \\n        for i in dd:\\n            for x in dd[i]:\\n                if i in dd[x]:\\n                    ans += 1\\n                    break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095791,
                "title": "java-o-n-2-with-explanation",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // Store each person\\'s pairing at first. (quickly check in next step) \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < pairs.length; i++) {\\n            map.put(pairs[i][0], pairs[i][1]);\\n            map.put(pairs[i][1], pairs[i][0]);\\n        }\\n        \\n        int unhappy = 0;\\n        // traverse from the first person\\n        for (int i = 0; i < n; i++) {\\n            \\n            // find x who this person paired with and what\\'s this person\\'s preference\\n            int pairedWith = map.get(i);\\n            int[] preferedList = preferences[i];\\n            \\n\\t\\t\\tfor (int j = 0; j < preferedList.length; j++) {\\n\\t\\t\\t\\tif (preferedList[j] == pairedWith) break;\\n\\n\\t\\t\\t\\t// find the better choice for x and who this better choice paired.\\n\\t\\t\\t\\tint betterChoice = preferedList[j];\\n\\t\\t\\t\\tint betterChoicePaired = map.get(betterChoice);\\n\\n\\t\\t\\t\\t// compare the priority between this better choice paired person and the person i.\\n\\t\\t\\t\\tint btcPairedIndex = 0;\\n\\t\\t\\t\\tint iIndex = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < preferences[betterChoice].length; k++) {\\n\\t\\t\\t\\t\\tif (preferences[betterChoice][k] == betterChoicePaired) {\\n\\t\\t\\t\\t\\t\\tbtcPairedIndex = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (preferences[betterChoice][k] == i) {\\n\\t\\t\\t\\t\\t\\tiIndex = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if we find person i has high priority than this better choice paired, this person i is unhappy and continue with the next person.\\n\\t\\t\\t\\tif (iIndex < btcPairedIndex) {\\n\\t\\t\\t\\t\\tunhappy += 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            \\n        }\\n        return unhappy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // Store each person\\'s pairing at first. (quickly check in next step) \\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < pairs.length; i++) {\\n            map.put(pairs[i][0], pairs[i][1]);\\n            map.put(pairs[i][1], pairs[i][0]);\\n        }\\n        \\n        int unhappy = 0;\\n        // traverse from the first person\\n        for (int i = 0; i < n; i++) {\\n            \\n            // find x who this person paired with and what\\'s this person\\'s preference\\n            int pairedWith = map.get(i);\\n            int[] preferedList = preferences[i];\\n            \\n\\t\\t\\tfor (int j = 0; j < preferedList.length; j++) {\\n\\t\\t\\t\\tif (preferedList[j] == pairedWith) break;\\n\\n\\t\\t\\t\\t// find the better choice for x and who this better choice paired.\\n\\t\\t\\t\\tint betterChoice = preferedList[j];\\n\\t\\t\\t\\tint betterChoicePaired = map.get(betterChoice);\\n\\n\\t\\t\\t\\t// compare the priority between this better choice paired person and the person i.\\n\\t\\t\\t\\tint btcPairedIndex = 0;\\n\\t\\t\\t\\tint iIndex = 0;\\n\\t\\t\\t\\tfor (int k = 0; k < preferences[betterChoice].length; k++) {\\n\\t\\t\\t\\t\\tif (preferences[betterChoice][k] == betterChoicePaired) {\\n\\t\\t\\t\\t\\t\\tbtcPairedIndex = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (preferences[betterChoice][k] == i) {\\n\\t\\t\\t\\t\\t\\tiIndex = k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if we find person i has high priority than this better choice paired, this person i is unhappy and continue with the next person.\\n\\t\\t\\t\\tif (iIndex < btcPairedIndex) {\\n\\t\\t\\t\\t\\tunhappy += 1;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            \\n        }\\n        return unhappy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247070,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p,vector<vector<int>>& pairs)\\n    {\\n         vector<vector<int> >map(n+1,vector<int>(n+1,0));\\n         for(int i=0;i<p.size();i++)\\n         {\\n             for(int j=0;j<p[i].size();j++)\\n             {\\n                 map[i][p[i][j]]=n-j;\\n             }\\n         }\\n         \\n        int size=pairs.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            pairs.push_back({pairs[i][1],pairs[i][0]});\\n        }\\n        \\n        vector<int>happy(n+1,1);\\n        \\n        for(int i=0;i<pairs.size()-1;i++)\\n        {\\n            for(int j=i+1;j<pairs.size();j++)\\n            {\\n                      \\n                int x=pairs[i][0];\\n                int y=pairs[i][1];\\n                int u=pairs[j][0];\\n                int v=pairs[j][1];\\n            \\n                if(map[x][u]>map[x][y]&&map[u][x]>map[u][v])\\n                {\\n                    happy[x]=0;\\n                    happy[u]=0;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(happy[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p,vector<vector<int>>& pairs)\\n    {\\n         vector<vector<int> >map(n+1,vector<int>(n+1,0));\\n         for(int i=0;i<p.size();i++)\\n         {\\n             for(int j=0;j<p[i].size();j++)\\n             {\\n                 map[i][p[i][j]]=n-j;\\n             }\\n         }\\n         \\n        int size=pairs.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            pairs.push_back({pairs[i][1],pairs[i][0]});\\n        }\\n        \\n        vector<int>happy(n+1,1);\\n        \\n        for(int i=0;i<pairs.size()-1;i++)\\n        {\\n            for(int j=i+1;j<pairs.size();j++)\\n            {\\n                      \\n                int x=pairs[i][0];\\n                int y=pairs[i][1];\\n                int u=pairs[j][0];\\n                int v=pairs[j][1];\\n            \\n                if(map[x][u]>map[x][y]&&map[u][x]>map[u][v])\\n                {\\n                    happy[x]=0;\\n                    happy[u]=0;\\n                }\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(happy[i]==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119675,
                "title": "c-short-solution-with-a-story-to-explain",
                "content": "**The love story:**\\n* Didn\\'t play any smart tricks.\\n* Only added a linear storage to make it easier to find everybody\\'s partner. Look up in county record office to find out who is married to who is way too painful. We just want everybody tell us who they married.\\n* After that it is pretty much textbook story: a grumpy husband found out his dream lover actually loves him better than her husband. This make the him very unhappy.\\n* Be careful if the grumpy husband got several dream lovers who loves him more. Even though he is unhappier, we still count him once. We got to break two level loops as soon as we found out he is unhappy.\\n* I suppose we could build a look up map of prefered lovers (before spouse) using unordered_set for everybody. That makes the look up step faster but will definitely use more memory.\\n```\\n  int unhappyFriends(int n, const vector<vector<int>> & preferences, const vector<vector<int>> & pairs) {\\n    vector<int> partner(n);\\n    for (const auto & vec : pairs) {\\n      partner[vec[0]] = vec[1];\\n      partner[vec[1]] = vec[0];\\n    }\\n\\n    int ret = 0;\\n    for (int i=0; i<n; ++i) {\\n      for (const int & pref : preferences[i]) {\\n        bool unhappy = false;\\n        if (pref == partner[i])\\n          break;\\n        for (const int & prefPref : preferences[pref]) {\\n          if (prefPref == i) {\\n            unhappy = true;\\n            break;\\n          }\\n          if (prefPref == partner[pref])\\n            break;\\n        }\\n        if (unhappy) {\\n          ++ret;\\n          break;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int unhappyFriends(int n, const vector<vector<int>> & preferences, const vector<vector<int>> & pairs) {\\n    vector<int> partner(n);\\n    for (const auto & vec : pairs) {\\n      partner[vec[0]] = vec[1];\\n      partner[vec[1]] = vec[0];\\n    }\\n\\n    int ret = 0;\\n    for (int i=0; i<n; ++i) {\\n      for (const int & pref : preferences[i]) {\\n        bool unhappy = false;\\n        if (pref == partner[i])\\n          break;\\n        for (const int & prefPref : preferences[pref]) {\\n          if (prefPref == i) {\\n            unhappy = true;\\n            break;\\n          }\\n          if (prefPref == partner[pref])\\n            break;\\n        }\\n        if (unhappy) {\\n          ++ret;\\n          break;\\n        }\\n      }\\n    }\\n    return ret;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103620,
                "title": "readable-python-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        def find_preferred_friends(x: int) -> List[int]:\\n            \"\"\"\\n            Returns friends of x that have a higher preference than partner.\\n            \"\"\"\\n\\t\\t\\tpartner = partners[x]  # Find the partner of x.\\n            x_friends = friend_prefs[x]  # Find all the friends of x.\\n            partner_ranking = x_friends[partner]  # Get the partner\\'s ranking amongst those friends.\\n            return list(x_friends)[:partner_ranking]  # Return all friends with a preferred lower ranking.\\n\\n        def is_unhappy(x: int) -> bool:\\n            \"\"\"\\n            Returns True if person x is unhappy, otherwise False.\\n            \"\"\"\\n            # Find the partner for person x.\\n            partner = partners[x]  \\n            # Find the friends that person x prefers more than this partner.\\n            preferred_friends = find_preferred_friends(x)  \\n            # A friend is unhappy with their partner if there is another friend with a higher preference \\n            # and that friend prefers them over their partner.\\n            return any(friend_prefs[friend][x] <= friend_prefs[friend][partners[friend]] \\n                       for friend in preferred_friends)\\n\\n        # Create dictionary to lookup friend preference for any person.\\n        friend_prefs = {\\n            person: {friend: pref for pref, friend in enumerate(friends)}\\n            for person, friends in enumerate(preferences)\\n        }\\n\\t\\t# Example:\\n\\t\\t# {0: {1: 0, 3: 1, 2: 2},\\n\\t    #  1: {2: 0, 3: 1, 0: 2},\\n\\t    #  2: {1: 0, 3: 1, 0: 2},\\n\\t    #  3: {0: 0, 2: 1, 1: 2}}\\n \\n        # Create dictionary to find anyone\\'s partner.\\n        partners = {}\\n        for x, y in pairs:\\n            partners[x] = y\\n            partners[y] = x\\n        \\n\\t\\t# Count and return the number of unhappy people.\\n        return sum(is_unhappy(person) for person in range(n))\\n```\\n\\t\\t\\nI used a nested dictionary comprehension to easily find the preference order of any person\\'s friend in `O(1)` time. The solution itself has `O(n^2)` time complexity, because one first iterates over every person and then iterates over that person\\'s friends.  Space complexity is also `O(n^2)` in the worst case where each person is friends with everyone else (`n` people, each with `n - 1` friends).\\n\\nSimilarly, a dictionary is created to easily find a person\\'s partner.\\n\\nThe function `find_preferred_friends` will, for any given person, return a list of all friends preferred to their partner.\\n\\nThe function `is_unhappy` determines if there is any friend with a higher preference (higher preference meaning a lower ranking) who prefers them over that friend\\'s partner.\\n<ul><li> `friend_prefs[friend][x]` returns how `x` is ranked by their friend in terms of preference.</li>\\n<li> `friend_prefs[friend][partners[friend]]` returns the ranking of that friend\\'s partner.</li></ul>\\n\\n\\nThese two rankings are then compared.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        def find_preferred_friends(x: int) -> List[int]:\\n            \"\"\"\\n            Returns friends of x that have a higher preference than partner.\\n            \"\"\"\\n\\t\\t\\tpartner = partners[x]  # Find the partner of x.\\n            x_friends = friend_prefs[x]  # Find all the friends of x.\\n            partner_ranking = x_friends[partner]  # Get the partner\\'s ranking amongst those friends.\\n            return list(x_friends)[:partner_ranking]  # Return all friends with a preferred lower ranking.\\n\\n        def is_unhappy(x: int) -> bool:\\n            \"\"\"\\n            Returns True if person x is unhappy, otherwise False.\\n            \"\"\"\\n            # Find the partner for person x.\\n            partner = partners[x]  \\n            # Find the friends that person x prefers more than this partner.\\n            preferred_friends = find_preferred_friends(x)  \\n            # A friend is unhappy with their partner if there is another friend with a higher preference \\n            # and that friend prefers them over their partner.\\n            return any(friend_prefs[friend][x] <= friend_prefs[friend][partners[friend]] \\n                       for friend in preferred_friends)\\n\\n        # Create dictionary to lookup friend preference for any person.\\n        friend_prefs = {\\n            person: {friend: pref for pref, friend in enumerate(friends)}\\n            for person, friends in enumerate(preferences)\\n        }\\n\\t\\t# Example:\\n\\t\\t# {0: {1: 0, 3: 1, 2: 2},\\n\\t    #  1: {2: 0, 3: 1, 0: 2},\\n\\t    #  2: {1: 0, 3: 1, 0: 2},\\n\\t    #  3: {0: 0, 2: 1, 1: 2}}\\n \\n        # Create dictionary to find anyone\\'s partner.\\n        partners = {}\\n        for x, y in pairs:\\n            partners[x] = y\\n            partners[y] = x\\n        \\n\\t\\t# Count and return the number of unhappy people.\\n        return sum(is_unhappy(person) for person in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1010654,
                "title": "java-using-hashmap-with-explanation",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        /*  \\n            create a two way mapping for pairs for quick lookup\\n            create a map of preferences\\n            for each friend check if unhappy\\n        */\\n        final Map<Integer, Integer> pairMap = new HashMap<>();\\n        final Map<Integer, Map<Integer, Integer>> preferenceMap = new HashMap<>();\\n        \\n        for(int[] pair : pairs) {\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        \\n        for(int i = 0; i < preferences.length; i++) {\\n            preferenceMap.put(i, new HashMap<>());\\n            for(int j = 0; j < preferences[0].length; j++) {\\n                preferenceMap.get(i).put(preferences[i][j], j);\\n            }        \\n        }\\n        int unHappyCount = 0;\\n        for(int[] pair : pairs) {\\n            int p1 = pair[0];\\n            int p2 = pair[1];\\n            \\n            if( ! isHappy(p1, p2, preferences, pairMap, preferenceMap)) {\\n                unHappyCount++;\\n            }\\n            if( ! isHappy(p2, p1, preferences, pairMap, preferenceMap)) {\\n                unHappyCount++;\\n            }\\n        }\\n        return unHappyCount;\\n    }\\n    \\n    private boolean isHappy(int p1, int p2, int[][] preferences, Map<Integer, Integer> pairs, \\n                            Map<Integer, Map<Integer, Integer>> preferenceMap) {\\n        \\n        int[] pref = preferences[p1];\\n        if(pref[0] != p2) {\\n            \\n            int index = preferenceMap.get(p1).get(p2);\\n            /* \\n                for all the friends that are more preferred than the current paired friend\\n                see if there is any friend that prefers p1 over his pair\\n            */\\n            for(int i = 0; i < index; i++) {\\n                int friend = pref[i];    \\n                int friendPair = pairs.get(friend);\\n                 \\n                if(preferenceMap.get(p1).get(friend) < preferenceMap.get(p1).get(p2)\\n                    && preferenceMap.get(friend).get(p1) < preferenceMap.get(friend).get(friendPair)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        /*  \\n            create a two way mapping for pairs for quick lookup\\n            create a map of preferences\\n            for each friend check if unhappy\\n        */\\n        final Map<Integer, Integer> pairMap = new HashMap<>();\\n        final Map<Integer, Map<Integer, Integer>> preferenceMap = new HashMap<>();\\n        \\n        for(int[] pair : pairs) {\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        \\n        for(int i = 0; i < preferences.length; i++) {\\n            preferenceMap.put(i, new HashMap<>());\\n            for(int j = 0; j < preferences[0].length; j++) {\\n                preferenceMap.get(i).put(preferences[i][j], j);\\n            }        \\n        }\\n        int unHappyCount = 0;\\n        for(int[] pair : pairs) {\\n            int p1 = pair[0];\\n            int p2 = pair[1];\\n            \\n            if( ! isHappy(p1, p2, preferences, pairMap, preferenceMap)) {\\n                unHappyCount++;\\n            }\\n            if( ! isHappy(p2, p1, preferences, pairMap, preferenceMap)) {\\n                unHappyCount++;\\n            }\\n        }\\n        return unHappyCount;\\n    }\\n    \\n    private boolean isHappy(int p1, int p2, int[][] preferences, Map<Integer, Integer> pairs, \\n                            Map<Integer, Map<Integer, Integer>> preferenceMap) {\\n        \\n        int[] pref = preferences[p1];\\n        if(pref[0] != p2) {\\n            \\n            int index = preferenceMap.get(p1).get(p2);\\n            /* \\n                for all the friends that are more preferred than the current paired friend\\n                see if there is any friend that prefers p1 over his pair\\n            */\\n            for(int i = 0; i < index; i++) {\\n                int friend = pref[i];    \\n                int friendPair = pairs.get(friend);\\n                 \\n                if(preferenceMap.get(p1).get(friend) < preferenceMap.get(p1).get(p2)\\n                    && preferenceMap.get(friend).get(p1) < preferenceMap.get(friend).get(friendPair)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992926,
                "title": "directed-graph-visual-explanation-python",
                "content": "\\n***TL;DR***  build a directed graph of unhappy pairings and then count number of vertices that have bidirectional paths. This count is the number of unhappy friends.\\n\\n(expalantion + visual below) \\n\\n```python\\ndef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\t# build directed graph of unhappy pairs\\n\\tgraph = defaultdict(set)\\n\\tfor (u, v) in pairs:\\n\\t\\tfor pref in preferences[u]:\\n\\t\\t\\tif pref == v:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tgraph[u].add(pref)\\n\\n\\t\\tfor pref in preferences[v]:\\n\\t\\t\\tif pref == u:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tgraph[v].add(pref)\\n\\n\\tunhappy = 0\\n\\t# counts vertices that have a bidirectional path \\n\\tfor node in list(graph.keys()):\\n\\t\\tfor pref in list(graph[node]):\\n\\t\\t\\tif node in graph[pref]:\\n\\t\\t\\t\\tunhappy += 1\\n\\t\\t\\t\\tbreak\\n\\treturn unhappy        \\n```\\n### Overview \\n\\nAn unhappy friend is defined as a friend that cannot be paired with some desired friend. The goal is to count the number of unhappy friends.\\n\\n***Given Input***\\n* a list of desired pairings ```pairs``` of friends i\\n* a list of friends ```preferences``` along with predefined ordering in which friend ```i``` must be paired ```peferences[i]```\\n\\ninitially it seems (from the examples given) that trying all pairs and seeing if they match the predefined ordering is sufficient. \\n\\n```\\nInput: n = 4, \\npreferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], \\npairs = [[0, 1], [2, 3]]\\noutput: 2 \\n```\\n\\n***Figure 1***\\n\\n![image](https://assets.leetcode.com/users/images/a07e581a-93eb-443d-8f74-a73b4d6d40fa_1609273549.5380957.png)\\n\\nwalking through all given examples it would seem that, we have found a valid solution. the code would be trivial. \\n\\n```python\\ndef unhappy(n, pairs, preferences):\\n\\tunhappy = 0\\n\\tfor i, j in enumerate(preferences):\\n\\t\\tif preferences[i][0] != j: unhappy += 1 \\n\\t\\tif preferences[j][0] != i: unhappy += 1 \\n\\t\\t\\n\\treturn unhappy \\n``` \\nhowever the given examples are misleading. Observe for a pair ```(u, v)```\\n```\\nn = 4 \\npreferences = [[1,3,2],[2,3,0],[1,0,3],[1,0,2]] \\npairs = [[2,1],[3,0]]\\noutput: 0 \\n```\\n***Figure 2***\\n![image](https://assets.leetcode.com/users/images/940b083d-4b6e-4a05-957d-bf216adafef8_1609273959.3754416.png)\\n\\n\\nour previous logic has failed us. This is because, after forming a happy pair with a friend ```i``` , friend ```i``` and its counter part friend ```j``` are no longer in consideration, because each friend can only be paired once.  \\n\\nnotice the only avenue to a correct solution is the following \\n\\n\\n***Figure 3***\\n![image](https://assets.leetcode.com/users/images/773a63ca-2b7e-425e-a022-a92bc45458fb_1609273607.48063.png)\\n\\n\\nNotice that by removing a friend from consideration (like in the diagram above) makes it possible for other happy pairs to be formed. \\n\\n* However there could be ***any number of friends*** in the way of forming a happy pair and it is impossible to know this in advance with the current approach\\n\\n* Additionally it may be the case that friends in the way of a happy pairing are not removed from consideration  (imagine if friend ```1``` in diagram did not have a happy pairing) \\n\\nThus a different approach is needed. \\n\\nif we construct a directed graph of friends that are blocking us from forming happy pairings we get a birds eye of view of the obstacles in the way of forming happy pairs.\\n\\n![image](https://assets.leetcode.com/users/images/ff71dbb7-b8c8-4c4f-bf33-adcb9e352497_1609212681.0740116.png)\\n\\nrecall in ***Figures 2 & 3*** friend ```1``` was in the way of forming the happy pair (3,0) for both friend ```3``` and friend ```0```. thus the graph has directed edges from ```0 to 1``` and ```3 to 1```.\\n\\n### Counting Unhappy Friends\\n\\nFor a ***happy pair*** ```(u, v)```  a friend ```u``` ***can*** be paired with a friend ```t``` in the predefined ordering for ```u``` that is equivalent to ```v```  ***or*** a friend ```v``` ***can*** be paired with a friend ```s``` in the predefined ordering for ```v``` that is equivalent to ```u```. either way a happy pair has been formed. the order in which this happy pair is formed is irrelevalnt. \\n \\nGiven a ***happy pair*** ```(t, u)``` an ***unhappy pair*** ```(t, s)```,  is defined as, the following. a  friend ```t``` is  be paired with a friend ```s``` in the predefined ordering for ```t``` that is ***not*** equivalent to ```u```  ***and*** a friend ```s``` is  be paired with friend ```t``` that also exists in the predefined ordering for ```s```.  \\n\\nthe key insight is ```t``` fails to form a ***happy pair*** with ```s``` and ```s``` fails to form a ***happy pair*** with ```t```\\n\\nwe record failed friend pair orderings as directed edges between verticies (friends) in a graph. According to the above logic if a directed edge exists from ```t``` to``` s```and a directed edge exists from ```s``` to ```t``` (forming a bidirectional path between ```t``` and ```s```) then friend ```t``` and friend ```s```  are ***unhappy***.\\n\\n\\ntherefore count the number of bidirectional paths in the directed graph just construted to get the number of unhappy friends, \\n\\n```\\nInput: n = 4\\npreferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]]\\npairs = [[1, 3], [0, 2]]\\nOutput: 4\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8dbdc348-1a6c-4a0b-8496-1c710d42e991_1609278893.1305532.png)\\n\\n\\nnotice that ```4``` different vertices have bi-directional paths to another vertex. if we count all these verticies we get the number of unhappy friends.\\n\\n### Additional Thoughts \\n\\ni wrote this post as i had a very difficult time understanding the why behind any solutions in the disscussion section. i could understand the code, but i had no idea why it was correct. my hopes with this post was to provide readers with the why and make up for the lack of an official leetcode solution article. \\n\\nAdditionally this question is ***hard to read*** and the examples given in the problem statement are misleading. \\n\\n* Adding this example to the problem statement would greatly improve the readability of this question. \\n\\n```\\nn = 4 \\npreferences = [[1,3,2],[2,3,0],[1,0,3],[1,0,2]] \\npairs = [[2,1],[3,0]]\\noutput: 0 \\n```\\nlastly in my opinion, this question should be labeled as ***Hard***, the solution itself is not difficult to implement, but the reasoning required to get a valid solution is rather difficult.\\n\\n[code courtesy of OldeElk](https://leetcode.com/problems/count-unhappy-friends/discuss/855428/Python-Directed-graph-linking-nodes-with-unmatched-preferred-friends-then-count-bi-directions)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```python\\ndef unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\t# build directed graph of unhappy pairs\\n\\tgraph = defaultdict(set)\\n\\tfor (u, v) in pairs:\\n\\t\\tfor pref in preferences[u]:\\n\\t\\t\\tif pref == v:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tgraph[u].add(pref)\\n\\n\\t\\tfor pref in preferences[v]:\\n\\t\\t\\tif pref == u:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\tgraph[v].add(pref)\\n\\n\\tunhappy = 0\\n\\t# counts vertices that have a bidirectional path \\n\\tfor node in list(graph.keys()):\\n\\t\\tfor pref in list(graph[node]):\\n\\t\\t\\tif node in graph[pref]:\\n\\t\\t\\t\\tunhappy += 1\\n\\t\\t\\t\\tbreak\\n\\treturn unhappy        \\n```\n```pairs```\n```preferences```\n```i```\n```peferences[i]```\n```\\nInput: n = 4, \\npreferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], \\npairs = [[0, 1], [2, 3]]\\noutput: 2 \\n```\n```python\\ndef unhappy(n, pairs, preferences):\\n\\tunhappy = 0\\n\\tfor i, j in enumerate(preferences):\\n\\t\\tif preferences[i][0] != j: unhappy += 1 \\n\\t\\tif preferences[j][0] != i: unhappy += 1 \\n\\t\\t\\n\\treturn unhappy \\n```\n```(u, v)```\n```\\nn = 4 \\npreferences = [[1,3,2],[2,3,0],[1,0,3],[1,0,2]] \\npairs = [[2,1],[3,0]]\\noutput: 0 \\n```\n```i```\n```i```\n```j```\n```1```\n```1```\n```3```\n```0```\n```0 to 1```\n```3 to 1```\n```(u, v)```\n```u```\n```t```\n```u```\n```v```\n```v```\n```s```\n```v```\n```u```\n```(t, u)```\n```(t, s)```\n```t```\n```s```\n```t```\n```u```\n```s```\n```t```\n```s```\n```t```\n```s```\n```s```\n```t```\n```t```\n``` s```\n```s```\n```t```\n```t```\n```s```\n```t```\n```s```\n```\\nInput: n = 4\\npreferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]]\\npairs = [[1, 3], [0, 2]]\\nOutput: 4\\n```\n```4```\n```\\nn = 4 \\npreferences = [[1,3,2],[2,3,0],[1,0,3],[1,0,2]] \\npairs = [[2,1],[3,0]]\\noutput: 0 \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 845417,
                "title": "nobel-prize-winning-stable-marriage-problem-simpler-code-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        vector<vector<int>> pref(n, vector<int>(n, 0));\\n        //.  x has a better choice in u and u has a better choice in x\\n        //   [------------------Stable Marriage Problem --------------]\\n        //    u |         |\\n        //   ---|         | x\\n        //.   * |         |----    \\n        //   ---|         | *\\n        //    y | x       | *\\n        //   -------  ---------\\n        //      |       u | v \\n        //      |         |\\n        for (int i = 0; i < pairs.size(); i++) {\\n            m[pairs[i][0]] = pairs[i][1];\\n            m[pairs[i][1]] = pairs[i][0];\\n        }\\n        for (int x = 0; x < n; x++) {\\n            for (int pos = 0; pos < p[x].size(); pos++) {\\n                int u = p[x][pos];\\n                pref[x][u] = pos;\\n            }\\n        }\\n        set<int> res;\\n        for (auto &pr: m) {\\n            int x = pr.first, y = pr.second;\\n            // for u, a pref of x ahead of y, is there a pref x ahead of it\\'s pair, v?\\n            for (int i = 0; i < pref[x][y]; i++) {\\n                int u = p[x][i], v = m[u];\\n                if (pref[u][x] < pref[u][v]) {\\n                    res.insert(u); res.insert(x);\\n                }\\n            }\\n        }\\n        return res.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        vector<vector<int>> pref(n, vector<int>(n, 0));\\n        //.  x has a better choice in u and u has a better choice in x\\n        //   [------------------Stable Marriage Problem --------------]\\n        //    u |         |\\n        //   ---|         | x\\n        //.   * |         |----    \\n        //   ---|         | *\\n        //    y | x       | *\\n        //   -------  ---------\\n        //      |       u | v \\n        //      |         |\\n        for (int i = 0; i < pairs.size(); i++) {\\n            m[pairs[i][0]] = pairs[i][1];\\n            m[pairs[i][1]] = pairs[i][0];\\n        }\\n        for (int x = 0; x < n; x++) {\\n            for (int pos = 0; pos < p[x].size(); pos++) {\\n                int u = p[x][pos];\\n                pref[x][u] = pos;\\n            }\\n        }\\n        set<int> res;\\n        for (auto &pr: m) {\\n            int x = pr.first, y = pr.second;\\n            // for u, a pref of x ahead of y, is there a pref x ahead of it\\'s pair, v?\\n            for (int i = 0; i < pref[x][y]; i++) {\\n                int u = p[x][i], v = m[u];\\n                if (pref[u][x] < pref[u][v]) {\\n                    res.insert(u); res.insert(x);\\n                }\\n            }\\n        }\\n        return res.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793465,
                "title": "python3-using-dictionary-of-sets",
                "content": "class Solution:\\n\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        maps = {}\\n        for x,y in pairs:\\n            maps[x] = set(preferences[x][:preferences[x].index(y)])\\n            maps[y] = set(preferences[y][:preferences[y].index(x)])\\n            \\n        res = 0\\n        \\n        for x in maps:\\n            for y in maps[x]:\\n                if x in maps[y]:\\n                    res+=1\\n                    break\\n                    \\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        maps = {}",
                "codeTag": "Java"
            },
            {
                "id": 1917128,
                "title": "java-solution",
                "content": "STEP 1: store current assigned partners in array\\n\\nSTEP 2: store in hashmap for each person, the partners they PREFERRED over their assigned partner. For example, if person 1 has a preference list of (2,5,3) and was ASSIGNED 3, then they prefer 2 and 5 over 3. Therefore, we store 1 as the key and <2,5> as the value in our hashmap.\\n\\nSTEP3: A person is unhappy if they prefer someone else and that someone else ALSO prefers them. We can count this quantity by iterating over each person in the hashmap which represented the people they prefer over their asigned and check if they also prefer them. By the example above, we\\'ll look at person 1 who prefers <2,5> over their current partner, iterate over person 2 and 5 to check if they also prefer person 1. If so, increment number of unhappy people and break to continue onto the next person.\\n\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // fill assigned O(N)\\n        int[] assigned = new int[n];\\n        for (int[] p : pairs) {\\n            assigned[p[0]] = p[1];\\n            assigned[p[1]] = p[0];\\n        }\\n        \\n        // store preferred over current\\n        Map<Integer,Set<Integer>> preferred = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            Set<Integer> before = new HashSet<>();\\n            int currPartner = assigned[i];\\n            for (int p : preferences[i]) {\\n                if (p == currPartner) {\\n                    break;\\n                }\\n                before.add(p);\\n            }\\n            preferred.put(i, before);\\n        }\\n        \\n        // count unhappy\\n        int unhappy = 0;\\n        for (int i=0; i<n; i++) {\\n            for (int p : preferred.get(i)) {\\n                if (preferred.get(p).contains(i)) {\\n                    unhappy++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // fill assigned O(N)\\n        int[] assigned = new int[n];\\n        for (int[] p : pairs) {\\n            assigned[p[0]] = p[1];\\n            assigned[p[1]] = p[0];\\n        }\\n        \\n        // store preferred over current\\n        Map<Integer,Set<Integer>> preferred = new HashMap<>();\\n        for (int i=0; i<n; i++) {\\n            Set<Integer> before = new HashSet<>();\\n            int currPartner = assigned[i];\\n            for (int p : preferences[i]) {\\n                if (p == currPartner) {\\n                    break;\\n                }\\n                before.add(p);\\n            }\\n            preferred.put(i, before);\\n        }\\n        \\n        // count unhappy\\n        int unhappy = 0;\\n        for (int i=0; i<n; i++) {\\n            for (int p : preferred.get(i)) {\\n                if (preferred.get(p).contains(i)) {\\n                    unhappy++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163188,
                "title": "javascript-hashmap",
                "content": "```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    /*\\n        create a hashMap with the preferences for a faster look ups,\\n        traverse through pairs and compare, increment the count if current\\n        friend ranks some other friend higher than his pair and that other friend\\n        ranks current higher than his pair\\n    */\\n    let happyMap = new Map();\\n    for (let pair of pairs) {\\n        happyMap.set(pair[0], pair[1]);\\n        happyMap.set(pair[1], pair[0]);\\n    }\\n    \\n    let ranks = new Map();\\n    for (let i = 0; i < n; i ++) {\\n        ranks.set(i, new Map());\\n        for (let j = 0; j < n - 1; j ++) {\\n            ranks.get(i).set(preferences[i][j], j);\\n        }\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i ++) {\\n        let pair = happyMap.get(i);\\n        let preference = ranks.get(i).get(pair);\\n        if (preference === 0) continue;\\n        for (let j = 0; j < n - 1; j ++) {\\n            let currFriend = preferences[i][j];\\n            let friendPair = happyMap.get(currFriend);\\n            let friendPreference = ranks.get(currFriend).get(friendPair);\\n            if (ranks.get(i).get(currFriend) < preference &&\\n                ranks.get(currFriend).get(i) < friendPreference) {\\n                unhappy ++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    /*\\n        create a hashMap with the preferences for a faster look ups,\\n        traverse through pairs and compare, increment the count if current\\n        friend ranks some other friend higher than his pair and that other friend\\n        ranks current higher than his pair\\n    */\\n    let happyMap = new Map();\\n    for (let pair of pairs) {\\n        happyMap.set(pair[0], pair[1]);\\n        happyMap.set(pair[1], pair[0]);\\n    }\\n    \\n    let ranks = new Map();\\n    for (let i = 0; i < n; i ++) {\\n        ranks.set(i, new Map());\\n        for (let j = 0; j < n - 1; j ++) {\\n            ranks.get(i).set(preferences[i][j], j);\\n        }\\n    }\\n    \\n    let unhappy = 0;\\n    for (let i = 0; i < n; i ++) {\\n        let pair = happyMap.get(i);\\n        let preference = ranks.get(i).get(pair);\\n        if (preference === 0) continue;\\n        for (let j = 0; j < n - 1; j ++) {\\n            let currFriend = preferences[i][j];\\n            let friendPair = happyMap.get(currFriend);\\n            let friendPreference = ranks.get(currFriend).get(friendPair);\\n            if (ranks.get(i).get(currFriend) < preference &&\\n                ranks.get(currFriend).get(i) < friendPreference) {\\n                unhappy ++;\\n                break;\\n            }\\n        }\\n    }\\n    \\n    return unhappy;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1073085,
                "title": "c-i-m-unhappy-if-my-gf-loves-me-more-than-her-bf",
                "content": "Suppose Amy loves me more than her boyfriend. Amy is not with me and I love Amy than my girlfriend. So I am unhappy:(\\n* All we have to do is to check the If the girls I love more than my current girlfriend love me more than their boyfriend.\\n* If there is any girl loves me more than her mate ( It is technically impossible for me:/ ) I would be unhappy:(\\n* Assuming unordered_map provides constant time access, my solution is O(n^2) since we are checking preferences array for each n person [n*(n-1) in worst case].\\n\\n```\\nclass Solution {\\npublic:\\n    bool isHappy(int curr,vector<int>&mates,vector<unordered_map<int,int>>&dudes,vector<vector<int>>&preferences,int n){\\n        int i = 0;\\n        while(preferences[curr][i]!=mates[curr]){\\n            int lovedMore = preferences[curr][i];\\n            if(dudes[lovedMore][curr]>dudes[lovedMore][mates[lovedMore]]){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>&pairs){\\n        int result = 0;\\n        vector<unordered_map<int,int>>dudes(n);\\n        vector<int>mates(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                dudes[i][preferences[i][j]] = n-j;\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            mates[pairs[i][0]] = pairs[i][1];\\n            mates[pairs[i][1]] = pairs[i][0];\\n        }\\n        for(int i=0;i<n/2;i++){\\n            if(isHappy(pairs[i][0],mates,dudes,preferences,n)==false){result++;}\\n            if(isHappy(pairs[i][1],mates,dudes,preferences,n)==false){result++;}\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isHappy(int curr,vector<int>&mates,vector<unordered_map<int,int>>&dudes,vector<vector<int>>&preferences,int n){\\n        int i = 0;\\n        while(preferences[curr][i]!=mates[curr]){\\n            int lovedMore = preferences[curr][i];\\n            if(dudes[lovedMore][curr]>dudes[lovedMore][mates[lovedMore]]){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>&pairs){\\n        int result = 0;\\n        vector<unordered_map<int,int>>dudes(n);\\n        vector<int>mates(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                dudes[i][preferences[i][j]] = n-j;\\n            }\\n        }\\n        for(int i=0;i<n/2;i++){\\n            mates[pairs[i][0]] = pairs[i][1];\\n            mates[pairs[i][1]] = pairs[i][0];\\n        }\\n        for(int i=0;i<n/2;i++){\\n            if(isHappy(pairs[i][0],mates,dudes,preferences,n)==false){result++;}\\n            if(isHappy(pairs[i][1],mates,dudes,preferences,n)==false){result++;}\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887100,
                "title": "python3-straightforward-solution-count-unhappy-friends",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ranks = {}\\n        for person, pref in enumerate(preferences):\\n            ranks[person] = defaultdict(lambda: n)\\n            for rank, peer in enumerate(pref):\\n                ranks[person][peer] = rank\\n        partner = {}        \\n        for p1, p2 in pairs:\\n            partner[p1] = p2\\n            partner[p2] = p1\\n        ans = 0\\n        for p1, p2 in pairs:\\n            for peer in preferences[p1]:\\n                if (ranks[p1][peer] < ranks[p1][p2] and\\n                    ranks[peer][p1] < ranks[peer][partner[peer]]):\\n                    ans += 1\\n                    break\\n            for peer in preferences[p2]:\\n                if (ranks[p2][peer] < ranks[p2][p1] and\\n                    ranks[peer][p2] < ranks[peer][partner[peer]]):\\n                    ans += 1\\n                    break\\n        return ans  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ranks = {}\\n        for person, pref in enumerate(preferences):\\n            ranks[person] = defaultdict(lambda: n)\\n            for rank, peer in enumerate(pref):\\n                ranks[person][peer] = rank\\n        partner = {}        \\n        for p1, p2 in pairs:\\n            partner[p1] = p2\\n            partner[p2] = p1\\n        ans = 0\\n        for p1, p2 in pairs:\\n            for peer in preferences[p1]:\\n                if (ranks[p1][peer] < ranks[p1][p2] and\\n                    ranks[peer][p1] < ranks[peer][partner[peer]]):\\n                    ans += 1\\n                    break\\n            for peer in preferences[p2]:\\n                if (ranks[p2][peer] < ranks[p2][p1] and\\n                    ranks[peer][p2] < ranks[peer][partner[peer]]):\\n                    ans += 1\\n                    break\\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 855428,
                "title": "python-directed-graph-linking-nodes-with-unmatched-preferred-friends-then-count-bi-directions",
                "content": "Construct a directed graph linking the node with their unmatched preferred friends, then count nodes with bi-connections.\\n\\nNote that we are counting the # of unhappy nodes, but not # of unhappy pairs. So that even one node can be paired with multiple others to be unhappy, we only count them once.\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def unhappyFriends(self, n, preferences, pairs):\\n        \"\"\"\\n        :type n: int\\n        :type preferences: List[List[int]]\\n        :type pairs: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(set)\\n        for (u, v) in pairs:\\n            for pref in preferences[u]:\\n                if pref == v:\\n                    break\\n                graph[u].add(pref)\\n            for pref in preferences[v]:\\n                if pref == u:\\n                    break\\n                graph[v].add(pref)\\n        \\n        rst = 0\\n        for node in graph.keys():\\n            for pref in list(graph[node]):\\n                if node in graph[pref]:\\n                    rst += 1\\n                    break\\n        return rst\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def unhappyFriends(self, n, preferences, pairs):\\n        \"\"\"\\n        :type n: int\\n        :type preferences: List[List[int]]\\n        :type pairs: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(set)\\n        for (u, v) in pairs:\\n            for pref in preferences[u]:\\n                if pref == v:\\n                    break\\n                graph[u].add(pref)\\n            for pref in preferences[v]:\\n                if pref == u:\\n                    break\\n                graph[v].add(pref)\\n        \\n        rst = 0\\n        for node in graph.keys():\\n            for pref in list(graph[node]):\\n                if node in graph[pref]:\\n                    rst += 1\\n                    break\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844264,
                "title": "python3-n-2-time-straight-forward-mapping-and-comparing",
                "content": "```\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:      \\n        r=[[None]*n for _ in range(n)]\\n        # r[a][b]: for a, the rank of b\\n        for a,others_for_a in enumerate(preferences):\\n            for rank,b in enumerate(others_for_a):\\n                r[a][b]=rank\\n        unhappy_people=set()        \\n        def unhappy(a,b,c,d):\\n            if r[a][c]<r[a][b] and r[c][a]<r[c][d]:\\n                unhappy_people.add(a)\\n                unhappy_people.add(c)\\n        for i,pair1 in enumerate(pairs):\\n            for pair2 in pairs[i+1::]:\\n                a,b=pair1\\n                c,d=pair2\\n                unhappy(a,b,c,d)\\n                unhappy(b,a,c,d)\\n                unhappy(a,b,d,c)\\n                unhappy(b,a,d,c)\\n        return len(unhappy_people)\\n```",
                "solutionTags": [],
                "code": "```\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:      \\n        r=[[None]*n for _ in range(n)]\\n        # r[a][b]: for a, the rank of b\\n        for a,others_for_a in enumerate(preferences):\\n            for rank,b in enumerate(others_for_a):\\n                r[a][b]=rank\\n        unhappy_people=set()        \\n        def unhappy(a,b,c,d):\\n            if r[a][c]<r[a][b] and r[c][a]<r[c][d]:\\n                unhappy_people.add(a)\\n                unhappy_people.add(c)\\n        for i,pair1 in enumerate(pairs):\\n            for pair2 in pairs[i+1::]:\\n                a,b=pair1\\n                c,d=pair2\\n                unhappy(a,b,c,d)\\n                unhappy(b,a,c,d)\\n                unhappy(a,b,d,c)\\n                unhappy(b,a,d,c)\\n        return len(unhappy_people)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 844207,
                "title": "c-simple-fast-worst-case-o-n-2-100-84ms-24mb-using-bitset",
                "content": "The theory is simple:\\nfor each person `x`, we mark [all friends in his preferences list that prior to the person actually paired] in the check list, so later the friends will check if they prefer `x` than the person they are paired. If they do, we mark both people unhappy.\\n\\n```cpp\\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n    bitset<500> unhappy{0};\\n    vector<bitset<500>> checkList(n);\\n    array<pair<int, int>, 2> thisPair;\\n    for (auto &p : pairs) {\\n        thisPair[0] = {p[0], p[1]}, thisPair[1] = {p[1], p[0]};\\n        for (auto [a, b] : thisPair) {\\n            for (int f : preferences[a]) {\\n                if (f == b) break;\\n                checkList[f].set(a);\\n                if (checkList[a][f])\\n                    unhappy.set(a), unhappy.set(f);\\n            }\\n        }\\n    }\\n    return unhappy.count();\\n}\\n```\\n\\nTime complexity:\\nFor each person (n people), we check his preference list (lenghth n) until the paired person, so the worst case is O(n<sup>2</sup>)\\nSpace:\\nIt looks like O(n), but since n <= 500, it\\'s actually >= O(n<sup>2</sup>) (but much less than other solutions, bitset<500> is only 64 bytes)\\nIf we can use something like `boost::dynamic_bitset`, then O(n<sup>2</sup>)\\n",
                "solutionTags": [],
                "code": "```cpp\\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n    bitset<500> unhappy{0};\\n    vector<bitset<500>> checkList(n);\\n    array<pair<int, int>, 2> thisPair;\\n    for (auto &p : pairs) {\\n        thisPair[0] = {p[0], p[1]}, thisPair[1] = {p[1], p[0]};\\n        for (auto [a, b] : thisPair) {\\n            for (int f : preferences[a]) {\\n                if (f == b) break;\\n                checkList[f].set(a);\\n                if (checkList[a][f])\\n                    unhappy.set(a), unhappy.set(f);\\n            }\\n        }\\n    }\\n    return unhappy.count();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844051,
                "title": "python3-brute-force-solution",
                "content": "Spent more time in understanding question instead of coding.\\n> Each person is contained in exactly one pair. \\n\\nis important.\\n> A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\\nx prefers u over y, and\\nu prefers x over v.\\n\\nfor each person x, he has only one pair y. So we can get y from f that is a dict record pairs.\\n\\'x prefers u over y\\' means u is in preferences[x] before y.\\nwe get u, and we get v from `f[u]`,\\nthen we judge whether x before v in preferences[u].\\n\\n```python\\n    def unhappyFriends(self, n: int, pres: List[List[int]], pairs: List[List[int]]) -> int:\\n        f = collections.defaultdict(int)\\n        ans = 0\\n        for u, v in pairs:\\n            f[u] = v\\n            f[v] = u\\n        \\n        def count(x):\\n            y = f[x]\\n            for u in pres[x]:\\n                if u == y:\\n                    break\\n                for pre in pres[u]:\\n                    if pre == f[u]:\\n                        break\\n                    if pre == x:\\n                        return 1\\n            return 0\\n        \\n        return sum(count(i) for i in range(n))\\n```",
                "solutionTags": [],
                "code": "```python\\n    def unhappyFriends(self, n: int, pres: List[List[int]], pairs: List[List[int]]) -> int:\\n        f = collections.defaultdict(int)\\n        ans = 0\\n        for u, v in pairs:\\n            f[u] = v\\n            f[v] = u\\n        \\n        def count(x):\\n            y = f[x]\\n            for u in pres[x]:\\n                if u == y:\\n                    break\\n                for pre in pres[u]:\\n                    if pre == f[u]:\\n                        break\\n                    if pre == x:\\n                        return 1\\n            return 0\\n        \\n        return sum(count(i) for i in range(n))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 844034,
                "title": "python-3-brutal-force-hash-table-o-n-2-explanations",
                "content": "### Explanation\\n- Given (a, b) & (c, d) there are only for possibilities, simply list them all\\n\\t- a & c prefer each other\\n\\t- a & d prefer each other\\n\\t- b & c prefer each other\\n\\t- b & d prefer each other\\n- Since we need to check index of each other to find out the preference, it\\'s better to use a **hash table** to store these information. I used a `defaultdict of defaultdict`, you can use matrix I believe.\\n- Assuming everyone is happy initially, if we found out someone is not happy, mark it\\n- At the very end, sum up all unhappy person\\n### Implementation\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        idx_table = collections.defaultdict(lambda: collections.defaultdict(int))\\n        for i in range(n):\\n            for idx, person in enumerate(preferences[i]): idx_table[i][person] = idx\\n                \\n        unhappy = [0] * n\\n        for i in range(n//2):\\n            a, b = pairs[i]\\n            b_a_idx, a_b_idx = idx_table[b][a], idx_table[a][b]\\n            for j in range(i+1, n//2):\\n                c, d = pairs[j]\\n                \\n                c_a_idx = idx_table[c][a]\\n                c_b_idx = idx_table[c][b]\\n                c_d_idx = idx_table[c][d]\\n                \\n                d_a_idx = idx_table[d][a] \\n                d_b_idx = idx_table[d][b] \\n                d_c_idx = idx_table[d][c] \\n                \\n                a_c_idx = idx_table[a][c] \\n                a_d_idx = idx_table[a][d] \\n                \\n                b_c_idx = idx_table[b][c] \\n                b_d_idx = idx_table[b][d] \\n                \\n                if c_a_idx < c_d_idx and a_c_idx < a_b_idx: unhappy[a] = unhappy[c] = 1 # a & c prefer each other\\n                if d_a_idx < d_c_idx and a_d_idx < a_b_idx: unhappy[a] = unhappy[d] = 1 # a & d prefer each other\\n                if c_b_idx < c_d_idx and b_c_idx < b_a_idx: unhappy[b] = unhappy[c] = 1 # b & c prefer each other\\n                if d_b_idx < d_c_idx and b_d_idx < b_a_idx: unhappy[b] = unhappy[d] = 1 # b & d prefer each other\\n        return sum(unhappy)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        idx_table = collections.defaultdict(lambda: collections.defaultdict(int))\\n        for i in range(n):\\n            for idx, person in enumerate(preferences[i]): idx_table[i][person] = idx\\n                \\n        unhappy = [0] * n\\n        for i in range(n//2):\\n            a, b = pairs[i]\\n            b_a_idx, a_b_idx = idx_table[b][a], idx_table[a][b]\\n            for j in range(i+1, n//2):\\n                c, d = pairs[j]\\n                \\n                c_a_idx = idx_table[c][a]\\n                c_b_idx = idx_table[c][b]\\n                c_d_idx = idx_table[c][d]\\n                \\n                d_a_idx = idx_table[d][a] \\n                d_b_idx = idx_table[d][b] \\n                d_c_idx = idx_table[d][c] \\n                \\n                a_c_idx = idx_table[a][c] \\n                a_d_idx = idx_table[a][d] \\n                \\n                b_c_idx = idx_table[b][c] \\n                b_d_idx = idx_table[b][d] \\n                \\n                if c_a_idx < c_d_idx and a_c_idx < a_b_idx: unhappy[a] = unhappy[c] = 1 # a & c prefer each other\\n                if d_a_idx < d_c_idx and a_d_idx < a_b_idx: unhappy[a] = unhappy[d] = 1 # a & d prefer each other\\n                if c_b_idx < c_d_idx and b_c_idx < b_a_idx: unhappy[b] = unhappy[c] = 1 # b & c prefer each other\\n                if d_b_idx < d_c_idx and b_d_idx < b_a_idx: unhappy[b] = unhappy[d] = 1 # b & d prefer each other\\n        return sum(unhappy)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127271,
                "title": "optimal-rust-approach",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$ ?\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn unhappy_friends(n: i32, prefs: Vec<Vec<i32>>, pairs: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let (prefs, pairs) = (Self::pref_up(&prefs, n), Self::pair_up(pairs, n));\\n        let mut ans = 0;\\n        // If x prefers u over y and u prefers x over v\\n        for a in 0..n {\\n            // a lovers\\n            if (0..n).any(|v| prefs[a][v] < prefs[a][pairs[a]] && prefs[v][a] < prefs[v][pairs[v]])\\n            {\\n                ans += 1;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn pref_up(prefs: &Vec<Vec<i32>>, n: usize) -> Vec<Vec<usize>> {\\n        let mut ans = vec![vec![n; n]; n];\\n        for (num, pref) in prefs.into_iter().enumerate() {\\n            for (pos, &fav) in pref.into_iter().enumerate() {\\n                ans[num][fav as usize] = pos;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn pair_up(pairs: Vec<Vec<i32>>, n: usize) -> Vec<usize> {\\n        let mut ans = vec![n; n];\\n        for pair in pairs {\\n            let (a, b) = (pair[0] as usize, pair[1] as usize);\\n            ans[a] = b;\\n            ans[b] = a;\\n        }\\n        ans\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn unhappy_friends(n: i32, prefs: Vec<Vec<i32>>, pairs: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;\\n        let (prefs, pairs) = (Self::pref_up(&prefs, n), Self::pair_up(pairs, n));\\n        let mut ans = 0;\\n        // If x prefers u over y and u prefers x over v\\n        for a in 0..n {\\n            // a lovers\\n            if (0..n).any(|v| prefs[a][v] < prefs[a][pairs[a]] && prefs[v][a] < prefs[v][pairs[v]])\\n            {\\n                ans += 1;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn pref_up(prefs: &Vec<Vec<i32>>, n: usize) -> Vec<Vec<usize>> {\\n        let mut ans = vec![vec![n; n]; n];\\n        for (num, pref) in prefs.into_iter().enumerate() {\\n            for (pos, &fav) in pref.into_iter().enumerate() {\\n                ans[num][fav as usize] = pos;\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn pair_up(pairs: Vec<Vec<i32>>, n: usize) -> Vec<usize> {\\n        let mut ans = vec![n; n];\\n        for pair in pairs {\\n            let (a, b) = (pair[0] as usize, pair[1] as usize);\\n            ans[a] = b;\\n            ans[b] = a;\\n        }\\n        ans\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2145532,
                "title": "python3-adjacency-matrix-o-n-2-time-o-n-2-space",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        adjMat = [[None] * n for _ in range(n)]\\n        prs = [None]*n\\n        unhappy = 0\\n        \\n        for f1, prefs in enumerate(preferences):\\n            for rank, f2 in enumerate(prefs):\\n                adjMat[f1][f2] = rank\\n                \\n        for f1,f2 in pairs:\\n            prs[f1], prs[f2] = f2, f1\\n            \\n        for f1 in range(n):\\n            for f3 in preferences[f1][:adjMat[f1][prs[f1]]]:\\n                if adjMat[f3][f1] < adjMat[f3][prs[f3]]:\\n                    unhappy += 1\\n                    break\\n                    \\n        return unhappy\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        adjMat = [[None] * n for _ in range(n)]\\n        prs = [None]*n\\n        unhappy = 0\\n        \\n        for f1, prefs in enumerate(preferences):\\n            for rank, f2 in enumerate(prefs):\\n                adjMat[f1][f2] = rank\\n                \\n        for f1,f2 in pairs:\\n            prs[f1], prs[f2] = f2, f1\\n            \\n        for f1 in range(n):\\n            for f3 in preferences[f1][:adjMat[f1][prs[f1]]]:\\n                if adjMat[f3][f1] < adjMat[f3][prs[f3]]:\\n                    unhappy += 1\\n                    break\\n                    \\n        return unhappy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100360,
                "title": "java-solution-3ms",
                "content": "Time: O(n\\xB2) Space: O(n\\xB2)\\n```\\nclass Solution {\\n  public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    int[][] rankings = new int[n][n]; // smaller the value, higher the preference\\n    int[] pairedWith = new int[n];\\n    for (int i = 0; i < n; i++) {\\n      for (int rank = 0; rank < n - 1; rank++) {\\n        int j = preferences[i][rank];\\n        rankings[i][j] = rank; // person \"i\" views person \"j\" with rank\\n      }\\n    }\\n    int unhappy = 0;\\n    for (int[] pair : pairs) {\\n      int a = pair[0], b = pair[1];\\n      pairedWith[a] = b;\\n      pairedWith[b] = a;\\n    }\\n    for (int a = 0; a < n; a++) {\\n      // \"a\" prefers someone else\\n      if (rankings[a][pairedWith[a]] != 0) {\\n        for (int b = 0; b < n; b++) {\\n          // \"b\" prefers to be with \"a\" over their current partner\\n          // \"a\" prefers to be with \"b\" over their current partner\\n          if (b != a\\n              && rankings[b][a] < rankings[b][pairedWith[b]]\\n              && rankings[a][b] < rankings[a][pairedWith[a]]) {\\n            unhappy++;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return unhappy;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    int[][] rankings = new int[n][n]; // smaller the value, higher the preference\\n    int[] pairedWith = new int[n];\\n    for (int i = 0; i < n; i++) {\\n      for (int rank = 0; rank < n - 1; rank++) {\\n        int j = preferences[i][rank];\\n        rankings[i][j] = rank; // person \"i\" views person \"j\" with rank\\n      }\\n    }\\n    int unhappy = 0;\\n    for (int[] pair : pairs) {\\n      int a = pair[0], b = pair[1];\\n      pairedWith[a] = b;\\n      pairedWith[b] = a;\\n    }\\n    for (int a = 0; a < n; a++) {\\n      // \"a\" prefers someone else\\n      if (rankings[a][pairedWith[a]] != 0) {\\n        for (int b = 0; b < n; b++) {\\n          // \"b\" prefers to be with \"a\" over their current partner\\n          // \"a\" prefers to be with \"b\" over their current partner\\n          if (b != a\\n              && rankings[b][a] < rankings[b][pairedWith[b]]\\n              && rankings[a][b] < rankings[a][pairedWith[a]]) {\\n            unhappy++;\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return unhappy;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866713,
                "title": "count-unhappy-friends-tc-o-n-2",
                "content": "The Solution is bit unconventional but it works.It took me a while to understand this question and solve it so here how it goes.\\n* I use list and hashMap to get the quick index of the value presenent preference that we are searching for.\\n* we need to find wheather a person in the pair is happy or not. so for that we need to get the index of the rank of his partner in his preference `int subIdx = list.get(main).indexOf(sub); ` this line bascially does that.\\n* once we get the index of his partner then we need to go from his `partner index - 1` to 0 to search an value such that the rank of person that we are searching for should be less then the that values pair\\'s rank and below code does that.\\n```\\n            int pairIdx = list.get(pat).indexOf(patPair);\\n            int mainIdx = list.get(pat).indexOf(main);\\n            \\n            if(mainIdx < pairIdx)\\n                return true;\\n```\\n\\nI know this seems confusing .. just give it some time and think about it.\\n\\n**Full Solution**\\n```\\nclass Solution {\\n    List<List<Integer>> list;\\n    HashMap<Integer,Integer> map;\\n    \\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i[] : preferences){\\n            List<Integer> temp = new ArrayList<>();\\n            for(int j : i)\\n                temp.add(j);\\n            list.add(temp);\\n        }\\n        \\n        for(int i[] : pairs) {\\n            map.put(i[0],i[1]);\\n            map.put(i[1],i[0]);\\n        }\\n        \\n        for(int i[] : pairs){\\n            if(isUnhappy(i[0],i[1]))\\n                count++;\\n            if(isUnhappy(i[1],i[0]))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean isUnhappy(int main,int sub){\\n        int subIdx = list.get(main).indexOf(sub);\\n        if(subIdx == 0)\\n            return false;\\n        \\n        subIdx -= 1;\\n        \\n        while(subIdx >= 0) {\\n            int pat = list.get(main).get(subIdx);\\n            int patPair = map.get(pat);\\n            \\n            int pairIdx = list.get(pat).indexOf(patPair);\\n            int mainIdx = list.get(pat).indexOf(main);\\n            \\n            if(mainIdx < pairIdx)\\n                return true;\\n            subIdx--;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nsolution inspired from - https://leetcode.com/problems/count-unhappy-friends/discuss/1831941/Python-Solution-Easy-to-Read-logic-in-the-question",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n            int pairIdx = list.get(pat).indexOf(patPair);\\n            int mainIdx = list.get(pat).indexOf(main);\\n            \\n            if(mainIdx < pairIdx)\\n                return true;\\n```\n```\\nclass Solution {\\n    List<List<Integer>> list;\\n    HashMap<Integer,Integer> map;\\n    \\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        list = new ArrayList<>();\\n        map = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i[] : preferences){\\n            List<Integer> temp = new ArrayList<>();\\n            for(int j : i)\\n                temp.add(j);\\n            list.add(temp);\\n        }\\n        \\n        for(int i[] : pairs) {\\n            map.put(i[0],i[1]);\\n            map.put(i[1],i[0]);\\n        }\\n        \\n        for(int i[] : pairs){\\n            if(isUnhappy(i[0],i[1]))\\n                count++;\\n            if(isUnhappy(i[1],i[0]))\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean isUnhappy(int main,int sub){\\n        int subIdx = list.get(main).indexOf(sub);\\n        if(subIdx == 0)\\n            return false;\\n        \\n        subIdx -= 1;\\n        \\n        while(subIdx >= 0) {\\n            int pat = list.get(main).get(subIdx);\\n            int patPair = map.get(pat);\\n            \\n            int pairIdx = list.get(pat).indexOf(patPair);\\n            int mainIdx = list.get(pat).indexOf(main);\\n            \\n            if(mainIdx < pairIdx)\\n                return true;\\n            subIdx--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665119,
                "title": "java-2-solutions-both-o-n-2-but-one-sol-is-better-than-other-in-run-time-explained",
                "content": "Solution 1: \\n// We create a map of mapping between each person \\'i\\' and his/her preferences so that look up becomes O(1)\\n// Then we go through all the all the persons preferences and find if they are paired with whom they wanted or not\\n\\n// TC : O(N^2)\\n// SC : O(N ^ 2)\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n       int[] givenPairing = new int[n];\\n        for(int[] pair: pairs) { // Keep record of current matches.\\n            givenPairing[pair[0]] = pair[1];\\n            givenPairing[pair[1]] = pair[0];\\n        }\\n        int res = 0;\\n\\t\\t\\n        // key -> person i; value -> map(key -> person j, value -> importance of person j for i (lesser is more important))\\n        Map<Integer, Integer>[] prefer = new Map[n]; // O(1) to fetch the index from the preference array. \\n         \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n-1; j++){\\n                if(prefer[i] == null) prefer[i] = new HashMap<>();\\n                prefer[i].put(preferences[i][j], j); // \\'i\\' prefers \\'j\\' and preference value of \\'j\\' for \\'i\\' is \\'j\\'\\n            }\\n        }\\n\\n        // The \\'if\\' condition checks 2 things\\n        // 1. if preference of \\'i\\' for \\'j\\' is lower value (meaning higher) than the preference of given pairing for \\'j\\'\\n        // 2. if preference of \\'j\\' for \\'i\\' is lower value (meaning higher) than the preference of given pairing for \\'i\\'\\n        // If above 2 conditions are true, it means that the friends are unhappy\\n        for(int i = 0; i < n; i++) { // read for all persons \\'i\\'\\n            for(int j : preferences[i]) { // given preferences for \\'i\\'(in order)\\n                if(prefer[j].get(i) < prefer[j].get(givenPairing[j]) \\n\\t\\t\\t\\t\\t&& prefer[i].get(j) < prefer[i].get(givenPairing[i])) { // Based on the definition of \"unhappy\"...\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n\\t    return res; \\n    }\\n}\\n```\\nSolution 2 : This has better run time time Solution 1\\n// TC : O(N^2)\\n// SC : O(N^2)\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] close = new int[n][n]; // 2D mapping for person \\'i\\' preferences (lower is better)\\n        for (int i = 0; i < preferences.length; i++) {\\n            for (int j = 0; j < preferences[i].length; j++) {\\n                close[i][preferences[i][j]] = j; // \\'i\\' prefers \\'j\\' with preference value \\'j\\' (lower is better)\\n            }\\n        }\\n        \\n        int[] mates = new int[n];\\n        for (int[] pair : pairs) {\\n            mates[pair[0]] = pair[1];\\n            mates[pair[1]] = pair[0];\\n        }\\n        \\n        int ans = 0;\\n        for (int x = 0; x < n; x++) { // for all persons \\'i\\'\\n            int y = mates[x]; // find given mate for \\'x\\'\\n            \\n            for (int u : preferences[x]) { // find preferences for \\'x\\'\\n                if (y == u) break; // if the mate for \\'x\\' is same its preference, x is HAPPY so break (no need to look further)\\n                \\n                int v = mates[u]; // find given mate for x\\'s preferences\\n                if (close[u][x] < close[u][v]) { // if the person \\'u\\' prefers \\'x\\' but is paired with \\'v\\' then he is UNHAPPY\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n       int[] givenPairing = new int[n];\\n        for(int[] pair: pairs) { // Keep record of current matches.\\n            givenPairing[pair[0]] = pair[1];\\n            givenPairing[pair[1]] = pair[0];\\n        }\\n        int res = 0;\\n\\t\\t\\n        // key -> person i; value -> map(key -> person j, value -> importance of person j for i (lesser is more important))\\n        Map<Integer, Integer>[] prefer = new Map[n]; // O(1) to fetch the index from the preference array. \\n         \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n-1; j++){\\n                if(prefer[i] == null) prefer[i] = new HashMap<>();\\n                prefer[i].put(preferences[i][j], j); // \\'i\\' prefers \\'j\\' and preference value of \\'j\\' for \\'i\\' is \\'j\\'\\n            }\\n        }\\n\\n        // The \\'if\\' condition checks 2 things\\n        // 1. if preference of \\'i\\' for \\'j\\' is lower value (meaning higher) than the preference of given pairing for \\'j\\'\\n        // 2. if preference of \\'j\\' for \\'i\\' is lower value (meaning higher) than the preference of given pairing for \\'i\\'\\n        // If above 2 conditions are true, it means that the friends are unhappy\\n        for(int i = 0; i < n; i++) { // read for all persons \\'i\\'\\n            for(int j : preferences[i]) { // given preferences for \\'i\\'(in order)\\n                if(prefer[j].get(i) < prefer[j].get(givenPairing[j]) \\n\\t\\t\\t\\t\\t&& prefer[i].get(j) < prefer[i].get(givenPairing[i])) { // Based on the definition of \"unhappy\"...\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n\\t    return res; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] close = new int[n][n]; // 2D mapping for person \\'i\\' preferences (lower is better)\\n        for (int i = 0; i < preferences.length; i++) {\\n            for (int j = 0; j < preferences[i].length; j++) {\\n                close[i][preferences[i][j]] = j; // \\'i\\' prefers \\'j\\' with preference value \\'j\\' (lower is better)\\n            }\\n        }\\n        \\n        int[] mates = new int[n];\\n        for (int[] pair : pairs) {\\n            mates[pair[0]] = pair[1];\\n            mates[pair[1]] = pair[0];\\n        }\\n        \\n        int ans = 0;\\n        for (int x = 0; x < n; x++) { // for all persons \\'i\\'\\n            int y = mates[x]; // find given mate for \\'x\\'\\n            \\n            for (int u : preferences[x]) { // find preferences for \\'x\\'\\n                if (y == u) break; // if the mate for \\'x\\' is same its preference, x is HAPPY so break (no need to look further)\\n                \\n                int v = mates[u]; // find given mate for x\\'s preferences\\n                if (close[u][x] < close[u][v]) { // if the person \\'u\\' prefers \\'x\\' but is paired with \\'v\\' then he is UNHAPPY\\n                    ans++;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610975,
                "title": "python-concise-answer",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        rank = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            rank[i][i] = float(\\'inf\\')\\n            for dist, j in enumerate(preferences[i]):\\n                rank[i][j] = dist + 1\\n               \\n        adjList = collections.defaultdict()\\n        for x, y in pairs:\\n            adjList[x] = y\\n            adjList[y] = x\\n            \\n        unhappy = 0\\n        for x, y in adjList.items():\\n            if rank[x][y] == 1:\\n                continue\\n                \\n            chosen = y\\n\\t\\t\\t# iterate only for all preferences before y\\n\\t\\t\\tend = preferences[x].index(y)\\n            for u in preferences[x][:end]:\\n                if rank[u][x] < rank[u][adjList[u]]:\\n                    chosen = u\\n                    break\\n            if chosen != y:\\n                unhappy += 1\\n        return unhappy\\n                \\n                    \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        rank = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            rank[i][i] = float(\\'inf\\')\\n            for dist, j in enumerate(preferences[i]):\\n                rank[i][j] = dist + 1\\n               \\n        adjList = collections.defaultdict()\\n        for x, y in pairs:\\n            adjList[x] = y\\n            adjList[y] = x\\n            \\n        unhappy = 0\\n        for x, y in adjList.items():\\n            if rank[x][y] == 1:\\n                continue\\n                \\n            chosen = y\\n\\t\\t\\t# iterate only for all preferences before y\\n\\t\\t\\tend = preferences[x].index(y)\\n            for u in preferences[x][:end]:\\n                if rank[u][x] < rank[u][adjList[u]]:\\n                    chosen = u\\n                    break\\n            if chosen != y:\\n                unhappy += 1\\n        return unhappy\\n                \\n                    \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572444,
                "title": "o-n-2-python-verbose",
                "content": "https://github.com/paulonteri/data-structures-and-algorithms\\n\\n---\\n\\nRead through the actual code to understand better\\n\\n```\\n\"\"\" \\nn - even\\n[\\n0 [1, 3, 2], u\\n1 [2, 3, 0],\\n2 [1, 3, 0],\\n3 [0, 2, 1]\\n], \\n \\npairs = [[1, 3], [0, 2]]\\n\\n{ \\n1:3,\\n3:1,\\n0:2,\\n2:0\\n}\\n\\n\\n# # x unhappy\\n\\tx -> y\\n\\tu -> v\\nif there exists such a condition\\n\\tx -> u (x prefers u than what it currently has)\\n\\tu -> x (prefers x than what it has)\\n\\n\\n- count = 0\\n- store the preferences in a dict/list:\\n    { \\n    x1: { u1: pref_u1, u2: pref_u2 }\\n    x2: { u1: pref_u1, u2: pref_u2 }\\n    }\\n- store the friendships in a dict/list:\\n    {\\n    x1:u1,\\n    u1:x1\\n    }\\n- for each x in the pairings:\\n    - if not with the highest priority friend\\n        - if can_get_higher_prio(x):\\n            count += 1\\n\\n            \\ncan_get_higher_prio(x):\\n    - check if for all the higher priority friends u1, u2, u2\\n        - any of them is matched with a friend they prefer less than x \\n\\nhttps://www.notion.so/paulonteri/_Object-Oriented-Analysis-and-Design-1a01887a9271475da7b3cd3f4efc9e0d#3b876eef896b482ea279ebdfbd918590\\n\"\"\"\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]):\\n        count = 0\\n\\n        pref_lookup = [{} for _ in range(n)]\\n        friendships_lookup = [-1 for _ in range(n)]\\n\\n        # store the preferences in a dict\\n        for person, preferences_list in enumerate(preferences):\\n            for priority, other_person in enumerate(preferences_list):\\n                pref_lookup[person][other_person] = priority\\n        # store the friendships in a dict\\n        for x, y in pairs:\\n            friendships_lookup[x] = y\\n            friendships_lookup[y] = x\\n\\n        for person, paired_with in enumerate(friendships_lookup):\\n            if pref_lookup[person][paired_with] == 0:\\n                continue\\n            if self.can_get_higher_prio(pref_lookup, friendships_lookup, person, paired_with):\\n                count += 1\\n\\n        return count\\n\\n    def can_get_higher_prio(self, pref_lookup, friendships_lookup, person, paired_with):\\n        \"\"\" \\n        - check if for all the higher priority friends u1, u2, u2 of person\\n            - if any of them is matched with a friend they prefer less than x:\\n                - return True\\n        - return False\\n        \"\"\"\\n\\n        for other_friend in pref_lookup[person]:\\n            # other_friend is of a lower priority\\n            if pref_lookup[person][other_friend] > pref_lookup[person][paired_with]:\\n                continue\\n            # person is not under other_friend\\'s priorities\\n            if person not in pref_lookup[other_friend]:\\n                continue\\n\\n            # check other_friend\\'s preference with person vs preference with who they were paired with\\n            pref_w_person = pref_lookup[other_friend][person]\\n            pref_w_paired_with = pref_lookup[other_friend][friendships_lookup[other_friend]]\\n\\n            if pref_w_paired_with > pref_w_person:\\n                return True\\n\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\" \\nn - even\\n[\\n0 [1, 3, 2], u\\n1 [2, 3, 0],\\n2 [1, 3, 0],\\n3 [0, 2, 1]\\n], \\n \\npairs = [[1, 3], [0, 2]]\\n\\n{ \\n1:3,\\n3:1,\\n0:2,\\n2:0\\n}\\n\\n\\n# # x unhappy\\n\\tx -> y\\n\\tu -> v\\nif there exists such a condition\\n\\tx -> u (x prefers u than what it currently has)\\n\\tu -> x (prefers x than what it has)\\n\\n\\n- count = 0\\n- store the preferences in a dict/list:\\n    { \\n    x1: { u1: pref_u1, u2: pref_u2 }\\n    x2: { u1: pref_u1, u2: pref_u2 }\\n    }\\n- store the friendships in a dict/list:\\n    {\\n    x1:u1,\\n    u1:x1\\n    }\\n- for each x in the pairings:\\n    - if not with the highest priority friend\\n        - if can_get_higher_prio(x):\\n            count += 1\\n\\n            \\ncan_get_higher_prio(x):\\n    - check if for all the higher priority friends u1, u2, u2\\n        - any of them is matched with a friend they prefer less than x \\n\\nhttps://www.notion.so/paulonteri/_Object-Oriented-Analysis-and-Design-1a01887a9271475da7b3cd3f4efc9e0d#3b876eef896b482ea279ebdfbd918590\\n\"\"\"\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]):\\n        count = 0\\n\\n        pref_lookup = [{} for _ in range(n)]\\n        friendships_lookup = [-1 for _ in range(n)]\\n\\n        # store the preferences in a dict\\n        for person, preferences_list in enumerate(preferences):\\n            for priority, other_person in enumerate(preferences_list):\\n                pref_lookup[person][other_person] = priority\\n        # store the friendships in a dict\\n        for x, y in pairs:\\n            friendships_lookup[x] = y\\n            friendships_lookup[y] = x\\n\\n        for person, paired_with in enumerate(friendships_lookup):\\n            if pref_lookup[person][paired_with] == 0:\\n                continue\\n            if self.can_get_higher_prio(pref_lookup, friendships_lookup, person, paired_with):\\n                count += 1\\n\\n        return count\\n\\n    def can_get_higher_prio(self, pref_lookup, friendships_lookup, person, paired_with):\\n        \"\"\" \\n        - check if for all the higher priority friends u1, u2, u2 of person\\n            - if any of them is matched with a friend they prefer less than x:\\n                - return True\\n        - return False\\n        \"\"\"\\n\\n        for other_friend in pref_lookup[person]:\\n            # other_friend is of a lower priority\\n            if pref_lookup[person][other_friend] > pref_lookup[person][paired_with]:\\n                continue\\n            # person is not under other_friend\\'s priorities\\n            if person not in pref_lookup[other_friend]:\\n                continue\\n\\n            # check other_friend\\'s preference with person vs preference with who they were paired with\\n            pref_w_person = pref_lookup[other_friend][person]\\n            pref_w_paired_with = pref_lookup[other_friend][friendships_lookup[other_friend]]\\n\\n            if pref_w_paired_with > pref_w_person:\\n                return True\\n\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507697,
                "title": "nice-question-c-is-this-question-used-for-testing-english-reading",
                "content": "I think this questions is like:\\n\"x and u are real love. They prefered each other than thier current wife or husband, but they have to marry another man/woman, who is y and v.\"\\n\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, unordered_map<int, int>> maps;\\n        for(int i = 0;i<preferences.size();i++)\\n        {\\n            for(int j = 0;j<preferences[i].size();j++)\\n            {\\n\\t\\t\\t// preferences[i].size() - j means preference\\n                maps[i][preferences[i][j]] = preferences[i].size() - j;\\n            }\\n        }\\n        int res = 0;\\n        unordered_map<int, int> dist;\\n        for(int i = 0;i<pairs.size();i++)\\n        {\\n            dist[pairs[i][0]] = pairs[i][1]; \\n            dist[pairs[i][1]] = pairs[i][0]; \\n        }\\n        for(int i = 0;i<n;i++){\\n            int x = i, y = dist[i];\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(j == x || j == y) continue;\\n                int u = j, v = dist[u];\\n\\t\\t\\t\\t// Don\\'t try to understand the question, just do what it asked......\\n                if(maps[x][u] > maps[x][y]&&maps[u][x] > maps[u][v]) \\n                {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, unordered_map<int, int>> maps;\\n        for(int i = 0;i<preferences.size();i++)\\n        {\\n            for(int j = 0;j<preferences[i].size();j++)\\n            {\\n\\t\\t\\t// preferences[i].size() - j means preference\\n                maps[i][preferences[i][j]] = preferences[i].size() - j;\\n            }\\n        }\\n        int res = 0;\\n        unordered_map<int, int> dist;\\n        for(int i = 0;i<pairs.size();i++)\\n        {\\n            dist[pairs[i][0]] = pairs[i][1]; \\n            dist[pairs[i][1]] = pairs[i][0]; \\n        }\\n        for(int i = 0;i<n;i++){\\n            int x = i, y = dist[i];\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(j == x || j == y) continue;\\n                int u = j, v = dist[u];\\n\\t\\t\\t\\t// Don\\'t try to understand the question, just do what it asked......\\n                if(maps[x][u] > maps[x][y]&&maps[u][x] > maps[u][v]) \\n                {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353615,
                "title": "c-beats-100-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, unordered_set<int>> morePreferred;\\n        \\n        //Adding all friends a person prefers more than their pair\\n        for(int i=0; i<pairs.size(); i++)\\n        {\\n            int first = pairs[i][0], second = pairs[i][1];\\n            \\n            //adding all friends that occur before alloted pair in preference list\\n            for(int j=0; j<preferences[first].size(); j++)\\n            {\\n                if(preferences[first][j] == second)\\n                    break;\\n                morePreferred[first].insert(preferences[first][j]);\\n            }\\n            \\n            for(int j=0; j<preferences[second].size(); j++)\\n            {\\n                if(preferences[second][j] == first)\\n                    break;\\n                morePreferred[second].insert(preferences[second][j]);\\n            }\\n        }\\n        \\n        int unhappy = 0;\\n        \\n        for(auto it = morePreferred.begin(); it != morePreferred.end(); it++)\\n        {\\n            unordered_set<int> morePref = it->second;\\n            \\n            //traversing all more preffered friends for a person\\n            for(auto it1 = morePref.begin(); it1 != morePref.end(); it1++)\\n            {\\n                //cout<<*it1<<endl;\\n                if(morePreferred.find(*it1) == morePreferred.end())\\n                    continue;\\n                //if their more preferred person also prefers them more than their partner\\n                if(morePreferred[*it1].find(it->first) != morePreferred[*it1].end())\\n                {\\n                    unhappy++;\\n                    break; // count unhappy person only once\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, unordered_set<int>> morePreferred;\\n        \\n        //Adding all friends a person prefers more than their pair\\n        for(int i=0; i<pairs.size(); i++)\\n        {\\n            int first = pairs[i][0], second = pairs[i][1];\\n            \\n            //adding all friends that occur before alloted pair in preference list\\n            for(int j=0; j<preferences[first].size(); j++)\\n            {\\n                if(preferences[first][j] == second)\\n                    break;\\n                morePreferred[first].insert(preferences[first][j]);\\n            }\\n            \\n            for(int j=0; j<preferences[second].size(); j++)\\n            {\\n                if(preferences[second][j] == first)\\n                    break;\\n                morePreferred[second].insert(preferences[second][j]);\\n            }\\n        }\\n        \\n        int unhappy = 0;\\n        \\n        for(auto it = morePreferred.begin(); it != morePreferred.end(); it++)\\n        {\\n            unordered_set<int> morePref = it->second;\\n            \\n            //traversing all more preffered friends for a person\\n            for(auto it1 = morePref.begin(); it1 != morePref.end(); it1++)\\n            {\\n                //cout<<*it1<<endl;\\n                if(morePreferred.find(*it1) == morePreferred.end())\\n                    continue;\\n                //if their more preferred person also prefers them more than their partner\\n                if(morePreferred[*it1].find(it->first) != morePreferred[*it1].end())\\n                {\\n                    unhappy++;\\n                    break; // count unhappy person only once\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1325617,
                "title": "13-line-simple-clean-python",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        likemore = {}\\n        for a,b in pairs:\\n            likemore[a] = set(preferences[a][:preferences[a].index(b)])\\n            likemore[b] = set(preferences[b][:preferences[b].index(a)])\\n        unhappy = set()\\n        for i in range(n):\\n            for j in range(i):\\n                if(i in likemore[j] and j in likemore[i]):\\n                    unhappy.add(i)\\n                    unhappy.add(j)\\n        return len(unhappy)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        likemore = {}\\n        for a,b in pairs:\\n            likemore[a] = set(preferences[a][:preferences[a].index(b)])\\n            likemore[b] = set(preferences[b][:preferences[b].index(a)])\\n        unhappy = set()\\n        for i in range(n):\\n            for j in range(i):\\n                if(i in likemore[j] and j in likemore[i]):\\n                    unhappy.add(i)\\n                    unhappy.add(j)\\n        return len(unhappy)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229402,
                "title": "c-o-n-2-solution-using-map-and-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        //Logic: make an unordered_map of people who I prefer over my partner(make sure not to include the current partner)\\n        //Unhappy when : I\\'m in someone\\'s preference set and also that someone is in my preference set, so we both are unhappy\\n        \\n        if(preferences.empty() || pairs.empty())return 0;\\n        \\n        unordered_map <int, unordered_set<int>> preferenceMap;\\n        \\n        for(auto p : pairs)\\n        {\\n            int x = p[0];\\n            int y = p[1];\\n            unordered_set<int> subVec;\\n            \\n            for(int i =0; i < preferences[x].size(); i++)\\n            {\\n                if(preferences[x][i] == y)break;\\n                subVec.insert(preferences[x][i]);\\n            }\\n            \\n            preferenceMap[x] = subVec;\\n            \\n            unordered_set<int> subVec1;\\n            \\n             for(int i =0; i < preferences[y].size(); i++)\\n            {\\n                if(preferences[y][i] == x)break;\\n                subVec1.insert(preferences[y][i]);\\n            }\\n            \\n            preferenceMap[y] = subVec1;\\n            \\n        }\\n        \\n        int res = 0;\\n        for(auto x : preferenceMap)\\n        {\\n            for(auto y : x.second)\\n            {\\n                if(preferenceMap[y].find(x.first) != preferenceMap[y].end())\\n                {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        //Logic: make an unordered_map of people who I prefer over my partner(make sure not to include the current partner)\\n        //Unhappy when : I\\'m in someone\\'s preference set and also that someone is in my preference set, so we both are unhappy\\n        \\n        if(preferences.empty() || pairs.empty())return 0;\\n        \\n        unordered_map <int, unordered_set<int>> preferenceMap;\\n        \\n        for(auto p : pairs)\\n        {\\n            int x = p[0];\\n            int y = p[1];\\n            unordered_set<int> subVec;\\n            \\n            for(int i =0; i < preferences[x].size(); i++)\\n            {\\n                if(preferences[x][i] == y)break;\\n                subVec.insert(preferences[x][i]);\\n            }\\n            \\n            preferenceMap[x] = subVec;\\n            \\n            unordered_set<int> subVec1;\\n            \\n             for(int i =0; i < preferences[y].size(); i++)\\n            {\\n                if(preferences[y][i] == x)break;\\n                subVec1.insert(preferences[y][i]);\\n            }\\n            \\n            preferenceMap[y] = subVec1;\\n            \\n        }\\n        \\n        int res = 0;\\n        for(auto x : preferenceMap)\\n        {\\n            for(auto y : x.second)\\n            {\\n                if(preferenceMap[y].find(x.first) != preferenceMap[y].end())\\n                {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077300,
                "title": "c-create-preference-matrix-and-pair-array-first",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int res = 0;\\n        // mat[i][j]: for friend i, the preference level of friend j, i.e. the index of j in preferences[i]\\n        // use mat to check preference (index) between i&j and use preferences to check friends\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n - 1; ++j) {\\n                int p = preferences[i][j];\\n                mat[i][p] = j;\\n            }\\n        }\\n        // pairsVec[i]: the paired friend of friend i\\n        vector<int> pairsVec(n);\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n            pairsVec[x] = y;\\n            pairsVec[y] = x;\\n        }\\n        // iterate all the friends of x with preference higher than y, to check if any of them also has higher preference for x\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            for (int j = 0; j < 2; ++j) {\\n                int x = pairs[i][j], y = pairs[i][1 - j];\\n                int xPref = mat[x][y];\\n                for (int k = 0; k < xPref; ++k) {\\n                    int u = preferences[x][k], v = pairsVec[u];\\n                    if (mat[u][x] < mat[u][v]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n// T: O(N^2)\\n// S: O(N^2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int res = 0;\\n        // mat[i][j]: for friend i, the preference level of friend j, i.e. the index of j in preferences[i]\\n        // use mat to check preference (index) between i&j and use preferences to check friends\\n        vector<vector<int>> mat(n, vector<int>(n));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n - 1; ++j) {\\n                int p = preferences[i][j];\\n                mat[i][p] = j;\\n            }\\n        }\\n        // pairsVec[i]: the paired friend of friend i\\n        vector<int> pairsVec(n);\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n            pairsVec[x] = y;\\n            pairsVec[y] = x;\\n        }\\n        // iterate all the friends of x with preference higher than y, to check if any of them also has higher preference for x\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            for (int j = 0; j < 2; ++j) {\\n                int x = pairs[i][j], y = pairs[i][1 - j];\\n                int xPref = mat[x][y];\\n                for (int k = 0; k < xPref; ++k) {\\n                    int u = preferences[x][k], v = pairsVec[u];\\n                    if (mat[u][x] < mat[u][v]) {\\n                        res++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n// T: O(N^2)\\n// S: O(N^2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076202,
                "title": "c-easy-self-explanatory-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) \\n    {\\n        if(!n)\\n            return 0;\\n     \\n        int prefMap[n][n];\\n        int pairMap[n];\\n        \\n        //what is the preference value of j\\'th person wrt i\\'th person\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n-1; j++)\\n            {\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        //who is paired with whom\\n        for(int i=0; i<n/2; i++)\\n        {\\n            pairMap[pairs[i][0]] = pairs[i][1];\\n            pairMap[pairs[i][1]] = pairs[i][0];\\n        }\\n        \\n        bool unhappy[n];\\n        memset(unhappy, false, sizeof(unhappy));\\n        \\n        //Check each person if he is unhappy\\n        for(int i=0; i<n; i++)\\n        {\\n            if(unhappy[i]) continue;\\n            \\n            int currPerson = i;\\n            int pairedPerson = pairMap[currPerson];\\n            int pairedPersonPref = prefMap[currPerson][pairedPerson];\\n            \\n            for(int j=0; j<n; j++)\\n            {\\n                if(currPerson!=j && pairedPerson!=j)\\n                {\\n                    int possiblePerson = j;\\n                    int possiblePref = prefMap[currPerson][j];\\n                    \\n                    if(possiblePref < pairedPersonPref)\\n                    {\\n                        int possiblePairedPerson = pairMap[possiblePerson];\\n                        int possiblePairedPersonPref = prefMap[possiblePerson][possiblePairedPerson];\\n                        \\n                        if(possiblePairedPersonPref>prefMap[possiblePerson][currPerson])\\n                        {\\n                            unhappy[currPerson] = unhappy[possiblePerson] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(bool unhappyPerson : unhappy)\\n            count+=(unhappyPerson ? 1 : 0);\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) \\n    {\\n        if(!n)\\n            return 0;\\n     \\n        int prefMap[n][n];\\n        int pairMap[n];\\n        \\n        //what is the preference value of j\\'th person wrt i\\'th person\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n-1; j++)\\n            {\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        //who is paired with whom\\n        for(int i=0; i<n/2; i++)\\n        {\\n            pairMap[pairs[i][0]] = pairs[i][1];\\n            pairMap[pairs[i][1]] = pairs[i][0];\\n        }\\n        \\n        bool unhappy[n];\\n        memset(unhappy, false, sizeof(unhappy));\\n        \\n        //Check each person if he is unhappy\\n        for(int i=0; i<n; i++)\\n        {\\n            if(unhappy[i]) continue;\\n            \\n            int currPerson = i;\\n            int pairedPerson = pairMap[currPerson];\\n            int pairedPersonPref = prefMap[currPerson][pairedPerson];\\n            \\n            for(int j=0; j<n; j++)\\n            {\\n                if(currPerson!=j && pairedPerson!=j)\\n                {\\n                    int possiblePerson = j;\\n                    int possiblePref = prefMap[currPerson][j];\\n                    \\n                    if(possiblePref < pairedPersonPref)\\n                    {\\n                        int possiblePairedPerson = pairMap[possiblePerson];\\n                        int possiblePairedPersonPref = prefMap[possiblePerson][possiblePairedPerson];\\n                        \\n                        if(possiblePairedPersonPref>prefMap[possiblePerson][currPerson])\\n                        {\\n                            unhappy[currPerson] = unhappy[possiblePerson] = true;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        for(bool unhappyPerson : unhappy)\\n            count+=(unhappyPerson ? 1 : 0);\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967317,
                "title": "python-easy-to-understand-w-explanation",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        72% faster O(n^2), 44% less mem O(n) - 12/10/20\\n        \"\"\"\\n        # keep track of people & their paired partner\\n        seen_pairs = {}\\n        for pair in pairs:\\n            seen_pairs[pair[0]] = pair[1]\\n            seen_pairs[pair[1]] = pair[0]\\n        \\n        # keep track of people that would rather prefer someone else over their current partner\\n        more_preferred = {}\\n        for i in range(len(preferences)):\\n            for preference in preferences[i]:\\n                if preference == seen_pairs[i]:\\n                    break\\n                if i not in more_preferred:\\n                    more_preferred[i] = []\\n                more_preferred[i].append(preference)\\n        \\n        # if both person in more_preferred feel same way abt each other, increment unhappy\\n        unhappy = 0 \\n        for person, preferences in more_preferred.items():\\n            for friend in preferences:\\n                if friend in more_preferred and person in more_preferred[friend]:\\n                    unhappy += 1\\n                    # don\\'t remove anything, just keep for next check\\n                    break\\n                    \\n        return unhappy\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        72% faster O(n^2), 44% less mem O(n) - 12/10/20\\n        \"\"\"\\n        # keep track of people & their paired partner\\n        seen_pairs = {}\\n        for pair in pairs:\\n            seen_pairs[pair[0]] = pair[1]\\n            seen_pairs[pair[1]] = pair[0]\\n        \\n        # keep track of people that would rather prefer someone else over their current partner\\n        more_preferred = {}\\n        for i in range(len(preferences)):\\n            for preference in preferences[i]:\\n                if preference == seen_pairs[i]:\\n                    break\\n                if i not in more_preferred:\\n                    more_preferred[i] = []\\n                more_preferred[i].append(preference)\\n        \\n        # if both person in more_preferred feel same way abt each other, increment unhappy\\n        unhappy = 0 \\n        for person, preferences in more_preferred.items():\\n            for friend in preferences:\\n                if friend in more_preferred and person in more_preferred[friend]:\\n                    unhappy += 1\\n                    # don\\'t remove anything, just keep for next check\\n                    break\\n                    \\n        return unhappy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939392,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int[] pair : pairs){\\n            map.put(pair[0], pair[1]);\\n            map.put(pair[1], pair[0]);\\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            int x = entry.getKey();\\n            int y = entry.getValue();\\n            if(unhappy(preferences, x, y, map)){\\n                count++;\\n            }\\n            \\n            \\n        }\\n        return count;\\n    }\\n    \\n    private boolean unhappy(int[][] preference, int x, int y, Map<Integer, Integer> map){\\n        //base case\\n       if(preference[x][0] == y){\\n           return false;\\n       }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < preference[x].length; i++){\\n            if(preference[x][i] == y){\\n                break;\\n            }\\n            list.add(preference[x][i]);\\n        }\\n        //get list of prefer\\n        for(int u : list){\\n            int v = map.get(u);\\n            int index1 = -1;\\n            int index2 = -1;\\n            for(int i = 0; i < preference[u].length; i++){\\n                if(preference[u][i] == v){\\n                    index1 = i;\\n                }\\n                if(preference[u][i] == x){\\n                    index2 = i;\\n                }\\n                if(index1 !=- 1 && index2 != -1){\\n                    break;\\n                }\\n            }\\n            \\n            if(index1 >=0 && index2 >= 0 && index1 > index2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int[] pair : pairs){\\n            map.put(pair[0], pair[1]);\\n            map.put(pair[1], pair[0]);\\n        }\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            int x = entry.getKey();\\n            int y = entry.getValue();\\n            if(unhappy(preferences, x, y, map)){\\n                count++;\\n            }\\n            \\n            \\n        }\\n        return count;\\n    }\\n    \\n    private boolean unhappy(int[][] preference, int x, int y, Map<Integer, Integer> map){\\n        //base case\\n       if(preference[x][0] == y){\\n           return false;\\n       }\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < preference[x].length; i++){\\n            if(preference[x][i] == y){\\n                break;\\n            }\\n            list.add(preference[x][i]);\\n        }\\n        //get list of prefer\\n        for(int u : list){\\n            int v = map.get(u);\\n            int index1 = -1;\\n            int index2 = -1;\\n            for(int i = 0; i < preference[u].length; i++){\\n                if(preference[u][i] == v){\\n                    index1 = i;\\n                }\\n                if(preference[u][i] == x){\\n                    index2 = i;\\n                }\\n                if(index1 !=- 1 && index2 != -1){\\n                    break;\\n                }\\n            }\\n            \\n            if(index1 >=0 && index2 >= 0 && index1 > index2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937234,
                "title": "3-line-python",
                "content": "I guess the point is seeing the time complexity is at least N square, so settle for brutal force.\\n\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        paired = {u:v for x, y in pairs for u, v in [[x,y],[y,x]]}\\n        betterPair = {i:set(preferences[i][:preferences[i].index(paired[i])]) for i in range(n)}\\n        return sum(int(any(x in betterPair[y] for y in betterPair[x])) for x in range(n))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        paired = {u:v for x, y in pairs for u, v in [[x,y],[y,x]]}\\n        betterPair = {i:set(preferences[i][:preferences[i].index(paired[i])]) for i in range(n)}\\n        return sum(int(any(x in betterPair[y] for y in betterPair[x])) for x in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 918243,
                "title": "c-simple-o-n-2-solution",
                "content": "```\\n\\tint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        int like[n][n];\\n        int partner[n];\\n        \\n        for(int x=0;x<n;x++){\\n            for(int i=0;i+1<n;i++){\\n                like[x][preferences[x][i]]=i;\\n            }\\n        }\\n        \\n        for(auto& i:pairs){\\n            partner[i[0]]=i[1];\\n            partner[i[1]]=i[0];\\n        }\\n        \\n        int ans=0;\\n        for(int x=0;x<n;x++){\\n            \\n            bool happy=true;\\n            for(int i=0;happy&&i+1<n&&preferences[x][i]!=partner[x];i++){\\n                int u=preferences[x][i];                \\n                if(like[u][x] < like[u][partner[u]]){\\n                    \\n                    ans++;\\n                    happy=false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        int like[n][n];\\n        int partner[n];\\n        \\n        for(int x=0;x<n;x++){\\n            for(int i=0;i+1<n;i++){\\n                like[x][preferences[x][i]]=i;\\n            }\\n        }\\n        \\n        for(auto& i:pairs){\\n            partner[i[0]]=i[1];\\n            partner[i[1]]=i[0];\\n        }\\n        \\n        int ans=0;\\n        for(int x=0;x<n;x++){\\n            \\n            bool happy=true;\\n            for(int i=0;happy&&i+1<n&&preferences[x][i]!=partner[x];i++){\\n                int u=preferences[x][i];                \\n                if(like[u][x] < like[u][partner[u]]){\\n                    \\n                    ans++;\\n                    happy=false;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 896429,
                "title": "python-clear-explanation-for-fast-and-pythonic-solution",
                "content": "The approach is as follows:\\n1. Go through the pairs and find the `wanted_friends` based on the given preferences. This is done in linear fashion\\n2. Go through each person if `wanted_friends` and check if the curr person is wanted as well.\\n\\nNote: I consider this pythonic because i use `takewhile` which is a very useful function (along with `dropwhile`) that you can find in itertools. \\n\\n```python\\nimport collections, itertools\\nclass Solution:\\n    # 364 ms, 99.79%. Time: O(N^2). Space: O(N^2)\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        wanted_friends = collections.defaultdict(set)\\n        for p1, p2 in pairs:\\n\\t\\t\\t# in Layman\\'s terms, take every number until we find p in the preferences (linear fashion)\\n            wanted_friends[p1] = set(itertools.takewhile(lambda p: p!=p2 , preferences[p1]))\\n            wanted_friends[p2] = set(itertools.takewhile(lambda p: p!=p1 , preferences[p2]))\\n        \\n\\t\\t# For the given example, we will have wanted_friends as follows:\\n\\t\\t# {0: set(), 1: {2, 3}, 2: set(), 3: {1}}\\n\\t\\t# This means, 0 and 2 are happy, 1 wants 2 or 3, and 3 wants 1. \\n\\t\\t\\n        unhappy_friends = 0\\n        for curr, people in wanted_friends.items():\\n            if any(curr in wanted_friends[person] for person in people):\\n                unhappy_friends += 1\\n        return unhappy_friends\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nimport collections, itertools\\nclass Solution:\\n    # 364 ms, 99.79%. Time: O(N^2). Space: O(N^2)\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \\n        wanted_friends = collections.defaultdict(set)\\n        for p1, p2 in pairs:\\n\\t\\t\\t# in Layman\\'s terms, take every number until we find p in the preferences (linear fashion)\\n            wanted_friends[p1] = set(itertools.takewhile(lambda p: p!=p2 , preferences[p1]))\\n            wanted_friends[p2] = set(itertools.takewhile(lambda p: p!=p1 , preferences[p2]))\\n        \\n\\t\\t# For the given example, we will have wanted_friends as follows:\\n\\t\\t# {0: set(), 1: {2, 3}, 2: set(), 3: {1}}\\n\\t\\t# This means, 0 and 2 are happy, 1 wants 2 or 3, and 3 wants 1. \\n\\t\\t\\n        unhappy_friends = 0\\n        for curr, people in wanted_friends.items():\\n            if any(curr in wanted_friends[person] for person in people):\\n                unhappy_friends += 1\\n        return unhappy_friends\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887810,
                "title": "java-standard-solution-with-rank-matrix-and-hashmap-for-pairs",
                "content": "Runtime: **3 ms**, faster than **85.34%** of Java online submissions for Count Unhappy Friends.\\nMemory Usage: **59.2 MB**, less than **5.40%** of Java online submissions for Count Unhappy Friends.\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        //Prepare matrix ranks: n - max, n-2 - min\\n        int[][] rank=new int[n][n];\\n        for(int i=0;i<n;i++){\\n            int[] pref=preferences[i];\\n            for(int j=0;j<n-1;j++){\\n                rank[i][pref[j]]=n-j;\\n            }//~~\\n        }//~\\n        \\n        //Prepare pMap - map of pairs\\n        HashMap<Integer,Integer> pMap=new HashMap<Integer,Integer>();\\n        \\n        for(int[] p:pairs){\\n            pMap.put(p[0],p[1]);\\n            pMap.put(p[1],p[0]);\\n        }//~\\n        \\n        //Search and count unhappy\\n        int count=0;\\n        \\n        for(int[] p:pairs){\\n            boolean wasP0=false,wasP1=false;\\n            for(int j=0;j<n;j++){\\n                //By p[0]\\n                if(rank[p[0]][j]>rank[p[0]][p[1]]&&!wasP0){\\n                   int k=pMap.get(j); \\n                   wasP0=rank[j][k]<rank[j][p[0]]; \\n                   count=wasP0?count+1:count; \\n                }\\n                //By p[1]\\n                if(rank[p[1]][j]>rank[p[1]][p[0]]&&!wasP1){\\n                   int k=pMap.get(j); \\n                   wasP1=rank[j][k]<rank[j][p[1]]; \\n                   count=wasP1?count+1:count; \\n                }\\n                if(wasP0&&wasP1)\\n                   break; \\n            }//~~          \\n        }//~\\n                \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        //Prepare matrix ranks: n - max, n-2 - min\\n        int[][] rank=new int[n][n];\\n        for(int i=0;i<n;i++){\\n            int[] pref=preferences[i];\\n            for(int j=0;j<n-1;j++){\\n                rank[i][pref[j]]=n-j;\\n            }//~~\\n        }//~\\n        \\n        //Prepare pMap - map of pairs\\n        HashMap<Integer,Integer> pMap=new HashMap<Integer,Integer>();\\n        \\n        for(int[] p:pairs){\\n            pMap.put(p[0],p[1]);\\n            pMap.put(p[1],p[0]);\\n        }//~\\n        \\n        //Search and count unhappy\\n        int count=0;\\n        \\n        for(int[] p:pairs){\\n            boolean wasP0=false,wasP1=false;\\n            for(int j=0;j<n;j++){\\n                //By p[0]\\n                if(rank[p[0]][j]>rank[p[0]][p[1]]&&!wasP0){\\n                   int k=pMap.get(j); \\n                   wasP0=rank[j][k]<rank[j][p[0]]; \\n                   count=wasP0?count+1:count; \\n                }\\n                //By p[1]\\n                if(rank[p[1]][j]>rank[p[1]][p[0]]&&!wasP1){\\n                   int k=pMap.get(j); \\n                   wasP1=rank[j][k]<rank[j][p[1]]; \\n                   count=wasP1?count+1:count; \\n                }\\n                if(wasP0&&wasP1)\\n                   break; \\n            }//~~          \\n        }//~\\n                \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874309,
                "title": "c-concise",
                "content": "```\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<vector<int>> vv;\\n        vector<bool> vUnhappy(n);\\n        for(auto& v:preferences){\\n            vector<int> dis(n,0);\\n            for(int i=0;i<v.size();i++) dis[v[i]] = i+1;\\n            vv.emplace_back(move(dis));\\n        }\\n        \\n        auto countUnhappy = [&](int x, int y, int u, int v){\\n            if(vv[x][y] > vv[x][u] && vv[u][v] > vv[u][x]) vUnhappy[x] = vUnhappy[u] = true;};\\n        \\n        \\n        for(int i=0;i<pairs.size();i++) for(int j=0;j<i;j++){\\n            int x=pairs[i][0], y=pairs[i][1], u=pairs[j][0], v=pairs[j][1];\\n            countUnhappy(x,y,u,v);\\n            countUnhappy(y,x,u,v);\\n            countUnhappy(x,y,v,u);\\n            countUnhappy(y,x,v,u);            \\n        }\\n        return count(vUnhappy.begin(), vUnhappy.end(), true);\\n    }",
                "solutionTags": [],
                "code": "```\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<vector<int>> vv;\\n        vector<bool> vUnhappy(n);\\n        for(auto& v:preferences){\\n            vector<int> dis(n,0);\\n            for(int i=0;i<v.size();i++) dis[v[i]] = i+1;\\n            vv.emplace_back(move(dis));\\n        }\\n        \\n        auto countUnhappy = [&](int x, int y, int u, int v){\\n            if(vv[x][y] > vv[x][u] && vv[u][v] > vv[u][x]) vUnhappy[x] = vUnhappy[u] = true;};\\n        \\n        \\n        for(int i=0;i<pairs.size();i++) for(int j=0;j<i;j++){\\n            int x=pairs[i][0], y=pairs[i][1], u=pairs[j][0], v=pairs[j][1];\\n            countUnhappy(x,y,u,v);\\n            countUnhappy(y,x,u,v);\\n            countUnhappy(x,y,v,u);\\n            countUnhappy(y,x,v,u);            \\n        }\\n        return count(vUnhappy.begin(), vUnhappy.end(), true);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 845690,
                "title": "java-brute-force-3ms",
                "content": "```\\nclass Solution {\\n    int length;\\n    public boolean isUnhappy(int num,Map<Integer, Integer>m,int[][] preferences){\\n        int fri = m.get(num); int index = -1; int pref = -1;int a = -1, b = -1;\\n        for(int i = length-2; i >= 0; i--){\\n            if(preferences[num][i] == fri && i == 0){return false;}\\n            else if(preferences[num][i] == fri){\\n                index = i; break;\\n            }\\n        }\\n        for(int i = index-1; i >= 0; i--){\\n            a = -1; b = -1;\\n            pref = preferences[num][i];\\n            int tmp = m.get(pref);\\n            for(int j = length-2; j >=0; j--){\\n                if(preferences[pref][j] == tmp){\\n                    a = j;\\n                }\\n                else if(preferences[pref][j] == num){\\n                    b = j;\\n                }\\n                if(b < a){return true;}\\n            }\\n        }\\n        return false;\\n    }\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        length = n;\\n        Map<Integer, Integer> m = new HashMap<>();\\n        int res = 0;\\n        for(int[] a : pairs){\\n            m.put(a[0],a[1]);\\n            m.put(a[1],a[0]);\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(isUnhappy(i,m,preferences)) res++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int length;\\n    public boolean isUnhappy(int num,Map<Integer, Integer>m,int[][] preferences){\\n        int fri = m.get(num); int index = -1; int pref = -1;int a = -1, b = -1;\\n        for(int i = length-2; i >= 0; i--){\\n            if(preferences[num][i] == fri && i == 0){return false;}",
                "codeTag": "Java"
            },
            {
                "id": 845503,
                "title": "easy-to-understand-quadratic-solution-with-comments",
                "content": "Use a two-dimensional array `rank` to look up how people rank each other in terms of their preferences.\\n\\n```\\nclass Solution {  \\npublic:\\n  // quadratic in n\\n  int unhappyFriends(int n, vector<vector<int>>& preferences, \\n                     vector<vector<int>>& pairs) {\\n    int ans = 0, rank[n][n], pair[n];\\n\\t\\n\\t// initialize rank array\\n    for (int x = 0; x < n; x++) {\\n      for (int i = 0; i < preferences[x].size(); i++) \\n        rank[x][preferences[x][i]] = n - i;  \\n\\t\\t// because preferences[x][i] ranks higher than \\n\\t\\t// preferences[x][i+1] as per the problem statement\\n    }\\n\\t\\n\\t// initialize pair array\\n    for (auto& v : pairs) {\\n      pair[v[0]] = v[1];\\n      pair[v[1]] = v[0];\\n    }\\n\\t\\n\\t// check if there exists a person u which person x prefers to his pair y, \\n\\t// and which prefers x to his pair\\n    for (int x = 0; x < n; x++) {\\n      int y = pair[x];\\n      for (auto it = begin(preferences[x]); *it != y; it++) {\\n        int u = *it;\\n        if (rank[u][x] > rank[u][pair[u]]) {\\n          ans++;\\n          break;\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\npublic:\\n  // quadratic in n\\n  int unhappyFriends(int n, vector<vector<int>>& preferences, \\n                     vector<vector<int>>& pairs) {\\n    int ans = 0, rank[n][n], pair[n];\\n\\t\\n\\t// initialize rank array\\n    for (int x = 0; x < n; x++) {\\n      for (int i = 0; i < preferences[x].size(); i++) \\n        rank[x][preferences[x][i]] = n - i;  \\n\\t\\t// because preferences[x][i] ranks higher than \\n\\t\\t// preferences[x][i+1] as per the problem statement\\n    }\\n\\t\\n\\t// initialize pair array\\n    for (auto& v : pairs) {\\n      pair[v[0]] = v[1];\\n      pair[v[1]] = v[0];\\n    }\\n\\t\\n\\t// check if there exists a person u which person x prefers to his pair y, \\n\\t// and which prefers x to his pair\\n    for (int x = 0; x < n; x++) {\\n      int y = pair[x];\\n      for (auto it = begin(preferences[x]); *it != y; it++) {\\n        int u = *it;\\n        if (rank[u][x] > rank[u][pair[u]]) {\\n          ans++;\\n          break;\\n        }\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845420,
                "title": "create-matrix-for-mutual-likes",
                "content": "```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // First need to create a matrix or list of map to demonstrate \\n        // how they like each other in terms of friend priority\\n        int[][] mat = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                mat[i][preferences[i][j]] = j;\\n            }\\n        }\\n        //System.out.println(Arrays.deepToString(mat));\\n        \\n        \\n        // the current pair mapping\\n        int[] curmap = new int[n];\\n        for (int[] pair : pairs) {\\n            curmap[pair[0]] = pair[1];\\n            curmap[pair[1]] = pair[0];\\n        }\\n        \\n        int res = 0;\\n        Set<Integer> set = new HashSet<>(); // Can be redundant.\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j) continue;\\n                // how i likes j VS how i likes current match\\n                // how j likes i VS how j likes current match\\n                if (mat[i][j] < mat[i][curmap[i]] &&\\n                    mat[j][i] < mat[j][curmap[j]] ) {\\n                    set.add(i);\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        \\n        return set.size();\\n    }\\n\\t\\n// \\u6211\\u53F8\\u7684\\u9898\\u76EE\\u4ECE\\u6765\\u4E0D\\u8003graph\\u91CC\\u7684fancy\\u7B97\\u6CD5\\uFF0C\\u4F46\\u7279\\u522B\\u559C\\u6B22\\u8003\\u7C7B\\u4F3C\\u8FD9\\u9898\\u8FD9\\u79CD\\u590D\\u6742\\u7684\\u76F8\\u4E92\\u7ED5\\u6765\\u7ED5\\u53BB\\u7684array, list, map\\u57FA\\u7840\\u6570\\u636E\\u7ED3\\u6784\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        // First need to create a matrix or list of map to demonstrate \\n        // how they like each other in terms of friend priority\\n        int[][] mat = new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n - 1; j++) {\\n                mat[i][preferences[i][j]] = j;\\n            }\\n        }\\n        //System.out.println(Arrays.deepToString(mat));\\n        \\n        \\n        // the current pair mapping\\n        int[] curmap = new int[n];\\n        for (int[] pair : pairs) {\\n            curmap[pair[0]] = pair[1];\\n            curmap[pair[1]] = pair[0];\\n        }\\n        \\n        int res = 0;\\n        Set<Integer> set = new HashSet<>(); // Can be redundant.\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (i == j) continue;\\n                // how i likes j VS how i likes current match\\n                // how j likes i VS how j likes current match\\n                if (mat[i][j] < mat[i][curmap[i]] &&\\n                    mat[j][i] < mat[j][curmap[j]] ) {\\n                    set.add(i);\\n                    set.add(j);\\n                }\\n            }\\n        }\\n        \\n        return set.size();\\n    }\\n\\t\\n// \\u6211\\u53F8\\u7684\\u9898\\u76EE\\u4ECE\\u6765\\u4E0D\\u8003graph\\u91CC\\u7684fancy\\u7B97\\u6CD5\\uFF0C\\u4F46\\u7279\\u522B\\u559C\\u6B22\\u8003\\u7C7B\\u4F3C\\u8FD9\\u9898\\u8FD9\\u79CD\\u590D\\u6742\\u7684\\u76F8\\u4E92\\u7ED5\\u6765\\u7ED5\\u53BB\\u7684array, list, map\\u57FA\\u7840\\u6570\\u636E\\u7ED3\\u6784\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 844827,
                "title": "python-solution-with-comments",
                "content": "\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ans = 0\\n        d ={}\\n\\t\\t#pair map for easy reference to the member in the same pair\\n        for pair in pairs:\\n            d[pair[0]]=d.get(pair[0],pair[1])\\n            d[pair[1]]=d.get(pair[1],pair[0])\\n            \\n        for p in range(n): \\n\\t\\t#iterate each person(p)\\n            t = d[p]\\n            t_idx = preferences[p].index(t)\\n            for other in preferences[p][:t_idx]:\\n\\t\\t\\t#iterate every other(other) on person(p)\\'s preference list in front of team/pair member(t)\\n                if preferences[other].index(p)<preferences[other].index(d[other]):\\n\\t\\t\\t\\t#compare the preference ranking of p and other\\'s current pairing(d[other]) on other\\'s preference list\\n                    ans +=1\\n                    break\\n        return ans\\n                \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ans = 0\\n        d ={}\\n\\t\\t#pair map for easy reference to the member in the same pair\\n        for pair in pairs:\\n            d[pair[0]]=d.get(pair[0],pair[1])\\n            d[pair[1]]=d.get(pair[1],pair[0])\\n            \\n        for p in range(n): \\n\\t\\t#iterate each person(p)\\n            t = d[p]\\n            t_idx = preferences[p].index(t)\\n            for other in preferences[p][:t_idx]:\\n\\t\\t\\t#iterate every other(other) on person(p)\\'s preference list in front of team/pair member(t)\\n                if preferences[other].index(p)<preferences[other].index(d[other]):\\n\\t\\t\\t\\t#compare the preference ranking of p and other\\'s current pairing(d[other]) on other\\'s preference list\\n                    ans +=1\\n                    break\\n        return ans\\n                \\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 844692,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        cand = defaultdict(int)\\n        for i in range(len(pairs)):\\n            pair = pairs[i]\\n            x = 1\\n            for p in pair:\\n                prefOfP = preferences[p]\\n                if(pair[x]!=prefOfP[0]):\\n                    cand[p] = pair[x]\\n                x = 0\\n        res = 0\\n        unhappyFraands = set()\\n        for pers in cand.keys():\\n            if(pers not in unhappyFraands):\\n                prefOfPers =  preferences[pers]\\n                currFrnd = cand[pers]\\n                i = 0\\n                found = False\\n                while(prefOfPers[i]!=currFrnd and found==False):\\n                    possFrnd = prefOfPers[i]\\n                    if(possFrnd in cand):\\n                        possFrndPref = preferences[possFrnd]\\n                        currFrndOfPossFrnd = cand[possFrnd]\\n                        j = 0\\n                        while(possFrndPref[j]!=currFrndOfPossFrnd):\\n                            if(possFrndPref[j] == pers):\\n                                if(possFrnd not in unhappyFraands):\\n                                    res+=2\\n                                else:\\n                                    res+=1\\n                                unhappyFraands.add(possFrnd)\\n                                unhappyFraands.add(pers)\\n                                found = True\\n                                break\\n                            j+=1\\n                    i+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        cand = defaultdict(int)\\n        for i in range(len(pairs)):\\n            pair = pairs[i]\\n            x = 1\\n            for p in pair:\\n                prefOfP = preferences[p]\\n                if(pair[x]!=prefOfP[0]):\\n                    cand[p] = pair[x]\\n                x = 0\\n        res = 0\\n        unhappyFraands = set()\\n        for pers in cand.keys():\\n            if(pers not in unhappyFraands):\\n                prefOfPers =  preferences[pers]\\n                currFrnd = cand[pers]\\n                i = 0\\n                found = False\\n                while(prefOfPers[i]!=currFrnd and found==False):\\n                    possFrnd = prefOfPers[i]\\n                    if(possFrnd in cand):\\n                        possFrndPref = preferences[possFrnd]\\n                        currFrndOfPossFrnd = cand[possFrnd]\\n                        j = 0\\n                        while(possFrndPref[j]!=currFrndOfPossFrnd):\\n                            if(possFrndPref[j] == pers):\\n                                if(possFrnd not in unhappyFraands):\\n                                    res+=2\\n                                else:\\n                                    res+=1\\n                                unhappyFraands.add(possFrnd)\\n                                unhappyFraands.add(pers)\\n                                found = True\\n                                break\\n                            j+=1\\n                    i+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844668,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], pairs: List[List[int]]) -> int:\\n        res = set()\\n        \\n\\t\\t# helper function to check for happiness\\n        def checkHappiness(x,y,u,v):\\n             if rank[x][u] < rank[x][y] and rank[u][x] < rank[u][v]:\\n                res.add(x)\\n                res.add(u)\\n\\t\\t\\t\\t\\n\\t\\t# store the pref with index accordingly in map\\n        rank = [{v:i for i,v in enumerate(row)} for row in pref] \\n        \\n        for i in range(n//2):\\n            x, y = pairs[i]\\n            for j in range(i+1, n//2):\\n                    u,v = pairs[j]\\n\\t\\t\\t\\t\\t# loop through permutations of pairs\\n                    checkHappiness(x, y, u, v)\\n                    checkHappiness(y, x, u, v)\\n                    checkHappiness(x, y, v, u)\\n                    checkHappiness(y, x, v, u)\\n                    \\n        return len(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], pairs: List[List[int]]) -> int:\\n        res = set()\\n        \\n\\t\\t# helper function to check for happiness\\n        def checkHappiness(x,y,u,v):\\n             if rank[x][u] < rank[x][y] and rank[u][x] < rank[u][v]:\\n                res.add(x)\\n                res.add(u)\\n\\t\\t\\t\\t\\n\\t\\t# store the pref with index accordingly in map\\n        rank = [{v:i for i,v in enumerate(row)} for row in pref] \\n        \\n        for i in range(n//2):\\n            x, y = pairs[i]\\n            for j in range(i+1, n//2):\\n                    u,v = pairs[j]\\n\\t\\t\\t\\t\\t# loop through permutations of pairs\\n                    checkHappiness(x, y, u, v)\\n                    checkHappiness(y, x, u, v)\\n                    checkHappiness(x, y, v, u)\\n                    checkHappiness(y, x, v, u)\\n                    \\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844579,
                "title": "1ms-100-faster-java-solution-brute-force-using-hashmap-well-commented-easy-to-understand",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Count Unhappy Friends.\\nMemory Usage: 60.2 MB, less than 80.00% of Java online submissions for Count Unhappy Friends.\\n\\nLet me know in the comment if you are having any doubts.\\n\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count=0;\\n        HashMap<Integer,Integer> pmap=new HashMap<>();\\n        \\n        // make hashmap for pair\\n        for(int i=0;i<pairs.length;i++){\\n            pmap.put(pairs[i][0],pairs[i][1]);\\n            pmap.put(pairs[i][1],pairs[i][0]);\\n        }\\n        \\n        // loop on all the elements and check if its Unhappy\\n        for(int i=0;i<n;i++){\\n                if(isUnhappy(i,pmap,preferences))\\n                    count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean isUnhappy(int n,HashMap<Integer,Integer> pmap,int[][] preferences){\\n        //pair\\n        int p=pmap.get(n);\\n        //arr\\n        int[] arr=preferences[n];\\n        //index of pair element in the array\\n        int pp=index(arr,p);\\n        \\n        if(pp==0) return false;\\n        \\n        // loop on all the favourable elements\\n        for(int i=0;i<pp;i++){\\n            \\n            //favourable to given no \\n            int fav=arr[i];\\n            \\n            // pair of favourable element\\n            int fp=pmap.get(fav);\\n            \\n            // arr of favourable element\\n            int[] fa = preferences[fav];\\n            \\n            //index of pair of favourable element in the favourable array\\n            int fpp = index(fa,fp);\\n            \\n            //index of curr element in the favourable array\\n            int fcp = index(fa,n);\\n            \\n            // if curr index< index of pair of favourable : curr is unhappy\\n            if(fcp<fpp){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int index(int[] pref,int val){\\n        for(int i=0;i<pref.length;i++){\\n            if(pref[i]==val){\\n                return i;\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count=0;\\n        HashMap<Integer,Integer> pmap=new HashMap<>();\\n        \\n        // make hashmap for pair\\n        for(int i=0;i<pairs.length;i++){\\n            pmap.put(pairs[i][0],pairs[i][1]);\\n            pmap.put(pairs[i][1],pairs[i][0]);\\n        }\\n        \\n        // loop on all the elements and check if its Unhappy\\n        for(int i=0;i<n;i++){\\n                if(isUnhappy(i,pmap,preferences))\\n                    count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private boolean isUnhappy(int n,HashMap<Integer,Integer> pmap,int[][] preferences){\\n        //pair\\n        int p=pmap.get(n);\\n        //arr\\n        int[] arr=preferences[n];\\n        //index of pair element in the array\\n        int pp=index(arr,p);\\n        \\n        if(pp==0) return false;\\n        \\n        // loop on all the favourable elements\\n        for(int i=0;i<pp;i++){\\n            \\n            //favourable to given no \\n            int fav=arr[i];\\n            \\n            // pair of favourable element\\n            int fp=pmap.get(fav);\\n            \\n            // arr of favourable element\\n            int[] fa = preferences[fav];\\n            \\n            //index of pair of favourable element in the favourable array\\n            int fpp = index(fa,fp);\\n            \\n            //index of curr element in the favourable array\\n            int fcp = index(fa,n);\\n            \\n            // if curr index< index of pair of favourable : curr is unhappy\\n            if(fcp<fpp){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int index(int[] pref,int val){\\n        for(int i=0;i<pref.length;i++){\\n            if(pref[i]==val){\\n                return i;\\n            }\\n        }\\n        return Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844275,
                "title": "c-100-faster-o-n-2-time",
                "content": "Current pair [x, y]\\n\\nlet say preferences for **x** is [...**u**...**y**...]  so check for all possible **u** before **y** which are preferable than **y**.\\n\\nNow for each **u** check for pair [u, v] where preferences for **u** is [...**x**...**v**...]  so check does x comes before (more preferable than) v in O(1) time.\\n\\n\\nDo the same for y by just replacing y with x.\\n\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        vector<vector<int>> prefer(n, vector<int>(n, 0));\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<preferences[i].size(); ++j){\\n                prefer[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        vector<int> map(n, 0);\\n        for(auto &p : pairs){\\n            map[p[0]] = p[1];\\n            map[p[1]] = p[0];\\n        }\\n        \\n        int unhappy = 0;\\n        \\n        for(auto &p : pairs){\\n            int x = p[0], y = p[1];\\n            \\n            // check for x\\n            for(int i=0; i<preferences[x].size(); ++i){\\n                int u = preferences[x][i];\\n                int v = map[u];\\n                \\n                if(u == y) break;\\n                if(prefer[u][x] < prefer[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n            \\n            // Same check for y (just replace x with y in previous for loop)\\n            for(int i=0; i<preferences[y].size(); ++i){\\n                int u = preferences[y][i];\\n                int v = map[u];\\n                \\n                if(u == x) break;\\n                if(prefer[u][y] < prefer[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n        vector<vector<int>> prefer(n, vector<int>(n, 0));\\n        for(int i=0; i<n; ++i){\\n            for(int j=0; j<preferences[i].size(); ++j){\\n                prefer[i][preferences[i][j]] = j;\\n            }\\n        }\\n        \\n        vector<int> map(n, 0);\\n        for(auto &p : pairs){\\n            map[p[0]] = p[1];\\n            map[p[1]] = p[0];\\n        }\\n        \\n        int unhappy = 0;\\n        \\n        for(auto &p : pairs){\\n            int x = p[0], y = p[1];\\n            \\n            // check for x\\n            for(int i=0; i<preferences[x].size(); ++i){\\n                int u = preferences[x][i];\\n                int v = map[u];\\n                \\n                if(u == y) break;\\n                if(prefer[u][x] < prefer[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n            \\n            // Same check for y (just replace x with y in previous for loop)\\n            for(int i=0; i<preferences[y].size(); ++i){\\n                int u = preferences[y][i];\\n                int v = map[u];\\n                \\n                if(u == x) break;\\n                if(prefer[u][y] < prefer[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844176,
                "title": "working-java-solution-shows-faster-than-100",
                "content": "```\\nclass Solution {\\n    \\n    // check whether the current element has more priority in the \"in\" subarray. If any other case return true\\n    boolean check(int[][] preferences,HashMap<Integer,Integer> hm,int cur,int in){\\n        int inPair = hm.get(in); \\n        for(int i=0;i<preferences[in].length;i++){\\n            int a = preferences[in][i];\\n            if(a == cur){\\n                return false;\\n            }else if(a == inPair){\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n       \\n        //Keep all the mappings in a hashMap\\n        HashMap<Integer,Integer> hm = new HashMap<>(); \\n        for(int i=0;i<pairs.length;i++){\\n          hm.put(pairs[i][0],pairs[i][1]);\\n          hm.put(pairs[i][1],pairs[i][0]);\\n        }\\n        \\n        //iterate through all hashmap entries. equivalent to checking each of entries in pairs\\n        for(int i : hm.keySet()){\\n            int givenPair = hm.get(i);\\n            int wantedPair = preferences[i][0];\\n            //If it is not paired with top priority choice, check whether it has got best priority pair possible, if not then increment count\\n            if(wantedPair != givenPair){\\n                for(int j=0; preferences[i][j]!=givenPair;j++){\\n                   boolean b = check(preferences,hm,i,preferences[i][j]); \\n                                    \\n                   if(!b){\\n                     count++;\\n                     break;  \\n                   } \\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // check whether the current element has more priority in the \"in\" subarray. If any other case return true\\n    boolean check(int[][] preferences,HashMap<Integer,Integer> hm,int cur,int in){\\n        int inPair = hm.get(in); \\n        for(int i=0;i<preferences[in].length;i++){\\n            int a = preferences[in][i];\\n            if(a == cur){\\n                return false;\\n            }else if(a == inPair){\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n       \\n        //Keep all the mappings in a hashMap\\n        HashMap<Integer,Integer> hm = new HashMap<>(); \\n        for(int i=0;i<pairs.length;i++){\\n          hm.put(pairs[i][0],pairs[i][1]);\\n          hm.put(pairs[i][1],pairs[i][0]);\\n        }\\n        \\n        //iterate through all hashmap entries. equivalent to checking each of entries in pairs\\n        for(int i : hm.keySet()){\\n            int givenPair = hm.get(i);\\n            int wantedPair = preferences[i][0];\\n            //If it is not paired with top priority choice, check whether it has got best priority pair possible, if not then increment count\\n            if(wantedPair != givenPair){\\n                for(int j=0; preferences[i][j]!=givenPair;j++){\\n                   boolean b = check(preferences,hm,i,preferences[i][j]); \\n                                    \\n                   if(!b){\\n                     count++;\\n                     break;  \\n                   } \\n                }\\n            }\\n            \\n            \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844147,
                "title": "easy-understand-java-o-n-2-with-thought-process",
                "content": "The Key is  how to check \"x prefers u over y\" for each x from 0 to n-1;\\n\\nI need know y, so I need a hashmap; (x ,y)\\nI need know for x, If u is before y in preferences[x], so I need a matrix which rank[x][u] means index of u in preferences[x]\\nthen, x prefers u over y --->  rank[x][u]< rank[x][y]\\n\\nnow, I am happy.\\n\\n```\\npublic int unhappyFriends(int n, int[][] prefs, int[][] pairs) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[][] rank = new int[n][n]; \\n        for(int[] p : pairs){\\n            int p1 =p[0];\\n            int p2 =p[1];\\n            for(int i =0; i<n-1; ++i){\\n                int fri1 = prefs[p1][i];\\n                int fri2 = prefs[p2][i];\\n                rank[p1][fri1]=i;\\n                rank[p2][fri2]=i;\\n            }\\n            map.put(p1, p2);\\n            map.put(p2, p1);\\n        }\\n        int ans =0;\\n        for(int i=0; i<n;++i){\\n            if(!isHappy(prefs, map, i, rank)) ++ans;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isHappy(int[][] prefs, HashMap<Integer, Integer> map, int x, int[][] rank){\\n\\n        int y = map.get(x);\\n        for(int u : prefs[x]){\\n            if(u ==y) break; // if meet pair friend, end check\\n            else{\\n\\t\\t\\t\\t// definition of unhappy\\n                int v = map.get(u);\\n                if(rank[x][u]<rank[x][y] && rank[u][x]<rank[u][v])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int unhappyFriends(int n, int[][] prefs, int[][] pairs) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[][] rank = new int[n][n]; \\n        for(int[] p : pairs){\\n            int p1 =p[0];\\n            int p2 =p[1];\\n            for(int i =0; i<n-1; ++i){\\n                int fri1 = prefs[p1][i];\\n                int fri2 = prefs[p2][i];\\n                rank[p1][fri1]=i;\\n                rank[p2][fri2]=i;\\n            }\\n            map.put(p1, p2);\\n            map.put(p2, p1);\\n        }\\n        int ans =0;\\n        for(int i=0; i<n;++i){\\n            if(!isHappy(prefs, map, i, rank)) ++ans;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isHappy(int[][] prefs, HashMap<Integer, Integer> map, int x, int[][] rank){\\n\\n        int y = map.get(x);\\n        for(int u : prefs[x]){\\n            if(u ==y) break; // if meet pair friend, end check\\n            else{\\n\\t\\t\\t\\t// definition of unhappy\\n                int v = map.get(u);\\n                if(rank[x][u]<rank[x][y] && rank[u][x]<rank[u][v])\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036487,
                "title": "c-distance-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> pair_map;\\n        int res = 0;\\n        for(auto p: pairs) {\\n            pair_map[p[0]] = p[1];\\n            pair_map[p[1]] = p[0];\\n        }\\n        unordered_map<string, int> distmap;\\n        for(int i = 0 ; i < preferences.size(); i++) {\\n            for(int j = 0 ; j < preferences[i].size(); j++) {\\n                distmap[to_string(i)+\"_\"+to_string(preferences[i][j])] = j;\\n            }\\n        }\\n        for(int x = 0 ; x < n; x++) {\\n            int y = pair_map[x];\\n            for(int u = 0; u < n; u++) {\\n                if(x == u )\\n                    continue;\\n                int v = pair_map[u];\\n                string dist1  = to_string(x)+\"_\"+to_string(y);\\n                string dist2  = to_string(x)+\"_\"+to_string(u);\\n                string dist3  = to_string(u)+\"_\"+to_string(v);\\n                string dist4  = to_string(u)+\"_\"+to_string(x);\\n                if(distmap[dist1] > distmap[dist2] and distmap[dist3] > distmap[dist4]) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> pair_map;\\n        int res = 0;\\n        for(auto p: pairs) {\\n            pair_map[p[0]] = p[1];\\n            pair_map[p[1]] = p[0];\\n        }\\n        unordered_map<string, int> distmap;\\n        for(int i = 0 ; i < preferences.size(); i++) {\\n            for(int j = 0 ; j < preferences[i].size(); j++) {\\n                distmap[to_string(i)+\"_\"+to_string(preferences[i][j])] = j;\\n            }\\n        }\\n        for(int x = 0 ; x < n; x++) {\\n            int y = pair_map[x];\\n            for(int u = 0; u < n; u++) {\\n                if(x == u )\\n                    continue;\\n                int v = pair_map[u];\\n                string dist1  = to_string(x)+\"_\"+to_string(y);\\n                string dist2  = to_string(x)+\"_\"+to_string(u);\\n                string dist3  = to_string(u)+\"_\"+to_string(v);\\n                string dist4  = to_string(u)+\"_\"+to_string(x);\\n                if(distmap[dist1] > distmap[dist2] and distmap[dist3] > distmap[dist4]) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007424,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\nfor two pair (a,b) and (c,d) there can be four posibilities a prefers c (vise-versa) or a prefers d (vise-versa) or b prefers c (vise-versa) or b prefers d.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck for each possible combinations of pair.\\n\\n# Complexity\\n- Time complexity:\\ncomplexity will be O(n(n-1))=O(n^2)\\n\\n- Space complexity:\\n  O(n(n-1))=O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n     vector<vector<int>>pref(n,vector<int>(n,0));\\n     for(int i=0;i<n;i++){\\n         for(int j=0;j<n-1;j++){\\n             int k=preferences[i][j];\\n             pref[i][k]=j;\\n         }\\n     }\\n     \\n     vector<int> dp(n,0);\\n     for(int i=0;i<pairs.size();i++){\\n         int a=pairs[i][0],b=pairs[i][1];\\n        for(int j=i+1;j<pairs.size();j++){\\n            int c=pairs[j][0],d=pairs[j][1];\\n            // a prefers c over b and c prefers a over d add a,c\\n            if(pref[a][c]< pref[a][b] && pref[c][a]<pref[c][d]){\\n                dp[a]=1;\\n                dp[c]=1;\\n            }\\n            // a prefers d over c and d prefers a over c add a,d\\n             if(pref[a][d]< pref[a][b] && pref[d][a]<pref[d][c]){\\n               dp[a]=1;\\n               dp[d]=1;\\n            }\\n            // b prefers c over a and c prefers b over d add b,c\\n             if(pref[b][c]< pref[b][a] && pref[c][b]<pref[c][d]){\\n                dp[b]=1;\\n                dp[c]=1;\\n            }\\n            // b prefers d over a and d prefers b over c add b,d\\n             if(pref[b][d]< pref[b][a] && pref[d][b]<pref[d][c]){\\n                dp[b]=1;\\n                dp[d]=1;\\n            }\\n\\n        }\\n     } \\n<!-- count no of unhappy friends -->\\n     int count=0;\\n     for(int i : dp)count+=i;\\n     return count;  \\n     \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n     vector<vector<int>>pref(n,vector<int>(n,0));\\n     for(int i=0;i<n;i++){\\n         for(int j=0;j<n-1;j++){\\n             int k=preferences[i][j];\\n             pref[i][k]=j;\\n         }\\n     }\\n     \\n     vector<int> dp(n,0);\\n     for(int i=0;i<pairs.size();i++){\\n         int a=pairs[i][0],b=pairs[i][1];\\n        for(int j=i+1;j<pairs.size();j++){\\n            int c=pairs[j][0],d=pairs[j][1];\\n            // a prefers c over b and c prefers a over d add a,c\\n            if(pref[a][c]< pref[a][b] && pref[c][a]<pref[c][d]){\\n                dp[a]=1;\\n                dp[c]=1;\\n            }\\n            // a prefers d over c and d prefers a over c add a,d\\n             if(pref[a][d]< pref[a][b] && pref[d][a]<pref[d][c]){\\n               dp[a]=1;\\n               dp[d]=1;\\n            }\\n            // b prefers c over a and c prefers b over d add b,c\\n             if(pref[b][c]< pref[b][a] && pref[c][b]<pref[c][d]){\\n                dp[b]=1;\\n                dp[c]=1;\\n            }\\n            // b prefers d over a and d prefers b over c add b,d\\n             if(pref[b][d]< pref[b][a] && pref[d][b]<pref[d][c]){\\n                dp[b]=1;\\n                dp[d]=1;\\n            }\\n\\n        }\\n     } \\n<!-- count no of unhappy friends -->\\n     int count=0;\\n     for(int i : dp)count+=i;\\n     return count;  \\n     \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973072,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        /**\\n        Create a prefMap that contains pref matrix, which is the friendship relationship\\n        Create an array which the index and value has mapping relationship for pairs\\n        From the relationship we can find that, the \"u\" is the key to connect relationship with x, y, and v\\n        Therefore, we iterate from 0 to N(i), assume each value from prefMap is \"u\", and if we are able to find a real \"u\", means i is unhappy, if not, means i is happy.\\n         */\\n        if (preferences == null || pairs == null) {\\n            return 0;\\n        }\\n\\n        Map<Integer, Map<Integer, Integer>> prefMap = new HashMap<>();\\n        for (int i = 0 ; i < n; i++) {\\n            prefMap.putIfAbsent(i, new HashMap<>());\\n            for (int j = 0; j < n - 1; j++) {\\n                prefMap.get(i).put(preferences[i][j], j);\\n            }\\n        }\\n\\n        int[] pairArr = new int[n];\\n        for (int[] pair : pairs) {\\n            pairArr[pair[0]] = pair[1];\\n            pairArr[pair[1]] = pair[0];\\n        }\\n\\n        int count = 0;\\n        for (int x = 0; x < n; x++) {\\n            int y = pairArr[x];\\n\\n            for (int u : preferences[x]) {\\n                int yIndex = prefMap.get(x).get(y);\\n                int uIndex = prefMap.get(x).get(u);\\n                int xIndex = prefMap.get(u).get(x);\\n                int vIndex = prefMap.get(u).get(pairArr[u]);\\n                if (uIndex < yIndex && xIndex < vIndex) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        /**\\n        Create a prefMap that contains pref matrix, which is the friendship relationship\\n        Create an array which the index and value has mapping relationship for pairs\\n        From the relationship we can find that, the \"u\" is the key to connect relationship with x, y, and v\\n        Therefore, we iterate from 0 to N(i), assume each value from prefMap is \"u\", and if we are able to find a real \"u\", means i is unhappy, if not, means i is happy.\\n         */\\n        if (preferences == null || pairs == null) {\\n            return 0;\\n        }\\n\\n        Map<Integer, Map<Integer, Integer>> prefMap = new HashMap<>();\\n        for (int i = 0 ; i < n; i++) {\\n            prefMap.putIfAbsent(i, new HashMap<>());\\n            for (int j = 0; j < n - 1; j++) {\\n                prefMap.get(i).put(preferences[i][j], j);\\n            }\\n        }\\n\\n        int[] pairArr = new int[n];\\n        for (int[] pair : pairs) {\\n            pairArr[pair[0]] = pair[1];\\n            pairArr[pair[1]] = pair[0];\\n        }\\n\\n        int count = 0;\\n        for (int x = 0; x < n; x++) {\\n            int y = pairArr[x];\\n\\n            for (int u : preferences[x]) {\\n                int yIndex = prefMap.get(x).get(y);\\n                int uIndex = prefMap.get(x).get(u);\\n                int xIndex = prefMap.get(u).get(x);\\n                int vIndex = prefMap.get(u).get(pairArr[u]);\\n                if (uIndex < yIndex && xIndex < vIndex) {\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966166,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    const preferencesMap = pairs.reduce((map, [x, y]) => {\\n        map.set(x, preferences[x].indexOf(y));\\n        map.set(y, preferences[y].indexOf(x));\\n        return map;\\n    }, new Map());\\n    let result = 0;\\n\\n    for (let friend = 0; friend < n; friend++) {\\n        const preference = preferencesMap.get(friend);\\n\\n        for (let index = 0; index < preference; index++) {\\n            const partner = preferences[friend][index];\\n\\n            if (preferences[partner].indexOf(friend) < preferencesMap.get(partner)) {\\n                result += 1;\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    const preferencesMap = pairs.reduce((map, [x, y]) => {\\n        map.set(x, preferences[x].indexOf(y));\\n        map.set(y, preferences[y].indexOf(x));\\n        return map;\\n    }, new Map());\\n    let result = 0;\\n\\n    for (let friend = 0; friend < n; friend++) {\\n        const preference = preferencesMap.get(friend);\\n\\n        for (let index = 0; index < preference; index++) {\\n            const partner = preferences[friend][index];\\n\\n            if (preferences[partner].indexOf(friend) < preferencesMap.get(partner)) {\\n                result += 1;\\n                break;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850217,
                "title": "a-linear-time-space-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two observations:\\n1) Mapping friends to preference levels allows us to quickly answer for each person A and friends B and C - does A prefer B to C?\\n2) Given a person A and its mate B, we know which of A\\' friends could potentially cause it to be unhappy - the ones appearing before B in the preference order (i.e., the ones that A preferes to B). From this point, it\\'s a straightforward check for those friends, their mates, and their mates preference level, compared to A\\'s.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, since the first and second loops iterate over the arguments and construct alternative representation for fast access, employing constant-time mapping. The third loop essentially scans the preference data again and uses constant time mappings to check whether a violation of the happiness criterion occurrs.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, since the maps essentially duplicate the data in the inputs arguments, representing it in a way that allows fast access.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        // For each person, maintain a preference level (number between 0 and n-1) for each of its friends.\\n        // A lower number means it is preferred more.\\n        unordered_map<int, vector<int>> person_to_friend_preferences;\\n        for (int person = 0; person < preferences.size(); ++person) {\\n            const vector<int>& friends = preferences[person];\\n            vector<int>& friend_to_pref = person_to_friend_preferences[person];\\n            if (friend_to_pref.size() == 0) {\\n                friend_to_pref.resize(n);\\n            }\\n            for (int preference = 0; preference < friends.size(); ++preference) {\\n                friend_to_pref[friends[preference]] = preference;\\n            }            \\n        }\\n        // Remember who is paired with whom.\\n        vector<int> paired_with(preferences.size());\\n        for (vector<int>& pair : pairs) {\\n            paired_with[pair[0]] = pair[1];\\n            paired_with[pair[1]] = pair[0];\\n        }\\n\\n        int unhappy = 0;\\n        // Check whether a person is unhappy.\\n        for (int person = 0; person < preferences.size(); ++person) {\\n            const int mate = paired_with[person];\\n            const int mate_pref = person_to_friend_preferences[person][mate];\\n            // Scan the person\\'s friends who it prefers better that the one she is paired with (mate),\\n            // since those are the only ones who may cause it to be unhappy (depending on their mating).\\n            const vector<int>& friends = preferences[person];\\n            for (int friend_pref = 0; friend_pref < mate_pref; ++friend_pref) {\\n                const int person_friend = friends[friend_pref];\\n                const int friends_mate = paired_with[person_friend];\\n                // If that friend\\'s mate it prefers less than \\'person\\', we found a violating pair.\\n                if (person_to_friend_preferences[person_friend][person] < person_to_friend_preferences[person_friend][friends_mate]) {\\n                    ++unhappy;\\n                    break; // One evidence of unhappiness is enough.\\n                }\\n            }\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        // For each person, maintain a preference level (number between 0 and n-1) for each of its friends.\\n        // A lower number means it is preferred more.\\n        unordered_map<int, vector<int>> person_to_friend_preferences;\\n        for (int person = 0; person < preferences.size(); ++person) {\\n            const vector<int>& friends = preferences[person];\\n            vector<int>& friend_to_pref = person_to_friend_preferences[person];\\n            if (friend_to_pref.size() == 0) {\\n                friend_to_pref.resize(n);\\n            }\\n            for (int preference = 0; preference < friends.size(); ++preference) {\\n                friend_to_pref[friends[preference]] = preference;\\n            }            \\n        }\\n        // Remember who is paired with whom.\\n        vector<int> paired_with(preferences.size());\\n        for (vector<int>& pair : pairs) {\\n            paired_with[pair[0]] = pair[1];\\n            paired_with[pair[1]] = pair[0];\\n        }\\n\\n        int unhappy = 0;\\n        // Check whether a person is unhappy.\\n        for (int person = 0; person < preferences.size(); ++person) {\\n            const int mate = paired_with[person];\\n            const int mate_pref = person_to_friend_preferences[person][mate];\\n            // Scan the person\\'s friends who it prefers better that the one she is paired with (mate),\\n            // since those are the only ones who may cause it to be unhappy (depending on their mating).\\n            const vector<int>& friends = preferences[person];\\n            for (int friend_pref = 0; friend_pref < mate_pref; ++friend_pref) {\\n                const int person_friend = friends[friend_pref];\\n                const int friends_mate = paired_with[person_friend];\\n                // If that friend\\'s mate it prefers less than \\'person\\', we found a violating pair.\\n                if (person_to_friend_preferences[person_friend][person] < person_to_friend_preferences[person_friend][friends_mate]) {\\n                    ++unhappy;\\n                    break; // One evidence of unhappiness is enough.\\n                }\\n            }\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836507,
                "title": "python3-simulation",
                "content": "# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d = {}\\n        p = {}\\n        for idx,e in enumerate(preferences):\\n            d[idx] = e\\n        c = set()\\n        for x,y in pairs:\\n            p[x] = y\\n            p[y] = x\\n        for i in range(n):\\n            team = p[i]\\n            temp = []\\n            for m in d[i]:\\n                if m == team:\\n                    break\\n                temp.append(m)\\n            for k in temp:\\n                if d[k].index(i) < d[k].index(p[k]):\\n                    c.add(i)\\n\\n        return len(c)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d = {}\\n        p = {}\\n        for idx,e in enumerate(preferences):\\n            d[idx] = e\\n        c = set()\\n        for x,y in pairs:\\n            p[x] = y\\n            p[y] = x\\n        for i in range(n):\\n            team = p[i]\\n            temp = []\\n            for m in d[i]:\\n                if m == team:\\n                    break\\n                temp.append(m)\\n            for k in temp:\\n                if d[k].index(i) < d[k].index(p[k]):\\n                    c.add(i)\\n\\n        return len(c)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804003,
                "title": "unhappy-friends-t-o-n-2-s-o-n-2",
                "content": "# Intuition\\n#iterate over pairs (partners)\\n#identify the list of friends that each person prefers over their partner\\n#check whether the prefered person also prefers me backwards\\n#if yes, increment the count as I am unhappy\\n#break the inner loop to avoid double counting my unhappiness\\n\\n# Complexity\\n#T=O(n^2),S=O(n^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d, p = {}, preferences\\n        #T=O(n^2),S=O(n^2) in thw worst case\\n        for x,y in pairs:\\n            d[x] = set(p[x][:p[x].index(y)])\\n            d[y] = set(p[y][:p[y].index(x)])\\n        \\n        res = 0\\n        #T=O(n^2) because dict lookups are O(1)\\n        for x in d:\\n            for y in d[x]:\\n                if x in d[y]:\\n                    res += 1\\n                    break\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d, p = {}, preferences\\n        #T=O(n^2),S=O(n^2) in thw worst case\\n        for x,y in pairs:\\n            d[x] = set(p[x][:p[x].index(y)])\\n            d[y] = set(p[y][:p[y].index(x)])\\n        \\n        res = 0\\n        #T=O(n^2) because dict lookups are O(1)\\n        for x in d:\\n            for y in d[x]:\\n                if x in d[y]:\\n                    res += 1\\n                    break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601613,
                "title": "python-intuitive",
                "content": "# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        partner = {}\\n\\n        for a, b in pairs:\\n            partner[a] = b\\n            partner[b] = a\\n\\n        table = collections.defaultdict(dict)\\n\\n        for person, p in enumerate(preferences):\\n            for rank, friend in enumerate(p):\\n                table[person][friend] = rank\\n\\n\\n        sad = collections.defaultdict(bool)\\n\\n\\n        for person in range(n):\\n            for other in range(person + 1, n):\\n                if partner[person] == other:\\n                    continue\\n                \\n                if table[person][other] < table[person][partner[person]] and table[other][person] < table[other][partner[other]]:\\n                    sad[person] = True\\n                    sad[other] = True\\n        print(sad)\\n\\n        return sum([1 for b in sad.values() if b == True])\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        partner = {}\\n\\n        for a, b in pairs:\\n            partner[a] = b\\n            partner[b] = a\\n\\n        table = collections.defaultdict(dict)\\n\\n        for person, p in enumerate(preferences):\\n            for rank, friend in enumerate(p):\\n                table[person][friend] = rank\\n\\n\\n        sad = collections.defaultdict(bool)\\n\\n\\n        for person in range(n):\\n            for other in range(person + 1, n):\\n                if partner[person] == other:\\n                    continue\\n                \\n                if table[person][other] < table[person][partner[person]] and table[other][person] < table[other][partner[other]]:\\n                    sad[person] = True\\n                    sad[other] = True\\n        print(sad)\\n\\n        return sum([1 for b in sad.values() if b == True])\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590869,
                "title": "js-code-with-heavy-commenting",
                "content": "This problem gives me a headache\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\n\\n// N is always even. Number of friends.\\n// Preferences is a list sorted in order of preference. \\n// friends are repped from 0 to n-1\\n// ------- UNHAPPY FRIENDS ------\\n// A person is unhappy if there is a friend in a different pairing\\n// AND that friend has to prefer them back over the person they are paired with.\\n// If the feeling isn\\'t mutual, then it wont be considered a un happy friend\\n\\nvar unhappyFriends = function(n, preferences, pairs) {\\n   \\n\\n    // We create a hashMap to map out every person as the key and their current partner as the value.\\n    let pairedWith = {}\\n\\n\\n    // We loop through the pairings Array to fill in our hashMap.\\n    // We use deconstruction to access the elements in each sub array.\\n    for (let [i, j] of pairs) {\\n        pairedWith[i] = j\\n        pairedWith[j] = i\\n    }\\n    // After the above code, our hashMap looks something like this:\\n    // pairedWith = {  \\n    //                  person: partner\\n    //                  0 : 1\\n    //                  1 : 0\\n    //                  2 : 3\\n    //                  3 : 2\\n    //                          }\\n\\n\\n    // Create a unhappy counter that we increment when finding friends that wanted each other but got other people.\\n    let unhappyCount = 0\\n\\n\\n    // Now we iterate through each \\'person\\' in n.\\n    for (let person = 0; person < n; person++) {\\n        // We want to search through each person\\'s preference list to view missed opportunities of more favorible pairings.\\n        // Our iteration begins at index 0 of their preferrence list. AKA we start with each person MOST preferred friend.\\n        // We want to stop iterating before the index of the person they are already partnered with!\\n        // This is because everyone after our current partner is assumed to be less favorable. Lists are sorted per description!!!!\\n        for (let prefIndex = 0; prefIndex < preferences[person].indexOf(pairedWith[person]); prefIndex++) {\\n            // We create a variable to store the current more preferred partner that we are evaluating.\\n            // Notice here we key into our preferences list, then key into our person\\'s list (that is...the person from our outter for loop).\\n            // Then we use the \\'prefIndex\\' to key into the more preferred partner.\\n            let morePreferredPartner = preferences[person][prefIndex]\\n\\n\\n            // We want to see how our more preferred partner feels (or \\'ranks\\' I guess you could say) about us in comparison with their current\\n            // partners ranking!\\n            // Comparison Logic: A lower index on a preferred list is a more favorible person.\\n            // If our index on a more preferred partner\\'s list is LOWER/LESS THAN their current partners index. They preferred us and are unhappy\\n            // that they did not get us. Obviously the feeling is mutual because if we didn\\'t prefer them over our current partner, we wouldn\\'t be\\n            // evaluating them right now. Thus that makes us both unhappy\\n            if (preferences[morePreferredPartner].indexOf(person) < preferences[morePreferredPartner].indexOf(pairedWith[morePreferredPartner])) {\\n                // Since we are iterating over each person, we only increment unhappy by one. \\\\\\n                // When we begin to evaluate our more preferred partner, the code will show that we were also favored them and thus increase the\\n                // unhappy count again then.\\n                unhappyCount++\\n\\n\\n                // It is very important that we add this break to prevent duplicate increments!!!!!!\\n                break;\\n            }\\n\\n\\n        }\\n    }\\n\\n\\n    // Return count\\n    return unhappyCount\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\n\\n// N is always even. Number of friends.\\n// Preferences is a list sorted in order of preference. \\n// friends are repped from 0 to n-1\\n// ------- UNHAPPY FRIENDS ------\\n// A person is unhappy if there is a friend in a different pairing\\n// AND that friend has to prefer them back over the person they are paired with.\\n// If the feeling isn\\'t mutual, then it wont be considered a un happy friend\\n\\nvar unhappyFriends = function(n, preferences, pairs) {\\n   \\n\\n    // We create a hashMap to map out every person as the key and their current partner as the value.\\n    let pairedWith = {}\\n\\n\\n    // We loop through the pairings Array to fill in our hashMap.\\n    // We use deconstruction to access the elements in each sub array.\\n    for (let [i, j] of pairs) {\\n        pairedWith[i] = j\\n        pairedWith[j] = i\\n    }\\n    // After the above code, our hashMap looks something like this:\\n    // pairedWith = {  \\n    //                  person: partner\\n    //                  0 : 1\\n    //                  1 : 0\\n    //                  2 : 3\\n    //                  3 : 2\\n    //                          }\\n\\n\\n    // Create a unhappy counter that we increment when finding friends that wanted each other but got other people.\\n    let unhappyCount = 0\\n\\n\\n    // Now we iterate through each \\'person\\' in n.\\n    for (let person = 0; person < n; person++) {\\n        // We want to search through each person\\'s preference list to view missed opportunities of more favorible pairings.\\n        // Our iteration begins at index 0 of their preferrence list. AKA we start with each person MOST preferred friend.\\n        // We want to stop iterating before the index of the person they are already partnered with!\\n        // This is because everyone after our current partner is assumed to be less favorable. Lists are sorted per description!!!!\\n        for (let prefIndex = 0; prefIndex < preferences[person].indexOf(pairedWith[person]); prefIndex++) {\\n            // We create a variable to store the current more preferred partner that we are evaluating.\\n            // Notice here we key into our preferences list, then key into our person\\'s list (that is...the person from our outter for loop).\\n            // Then we use the \\'prefIndex\\' to key into the more preferred partner.\\n            let morePreferredPartner = preferences[person][prefIndex]\\n\\n\\n            // We want to see how our more preferred partner feels (or \\'ranks\\' I guess you could say) about us in comparison with their current\\n            // partners ranking!\\n            // Comparison Logic: A lower index on a preferred list is a more favorible person.\\n            // If our index on a more preferred partner\\'s list is LOWER/LESS THAN their current partners index. They preferred us and are unhappy\\n            // that they did not get us. Obviously the feeling is mutual because if we didn\\'t prefer them over our current partner, we wouldn\\'t be\\n            // evaluating them right now. Thus that makes us both unhappy\\n            if (preferences[morePreferredPartner].indexOf(person) < preferences[morePreferredPartner].indexOf(pairedWith[morePreferredPartner])) {\\n                // Since we are iterating over each person, we only increment unhappy by one. \\\\\\n                // When we begin to evaluate our more preferred partner, the code will show that we were also favored them and thus increase the\\n                // unhappy count again then.\\n                unhappyCount++\\n\\n\\n                // It is very important that we add this break to prevent duplicate increments!!!!!!\\n                break;\\n            }\\n\\n\\n        }\\n    }\\n\\n\\n    // Return count\\n    return unhappyCount\\n\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3563112,
                "title": "easy-o-n-2-optimal-solution-simple-and-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we look through the preference list of `x` and find its pair `y`, then all elements *before* `y` is considered `more_preferred` by `x`.\\n\\nUse $x \\\\rightarrow y$ to represent that `y` is `more_preferred` by `x` then we have:\\n$$x \\\\rightarrow y \\\\land y \\\\rightarrow x \\\\Rightarrow\\n x \\\\in U \\\\land y \\\\in U$$ where $U$ is the set of unhappy friends.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe build the set of `more_preferred` for everyone and then check whether each person is unhappy.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N^2)$$\\n\\n# Code\\n```\\nbool Contains(const unordered_set<int>& s, int x) {\\n  return s.find(x) != s.end();\\n}\\n\\nclass Solution {\\npublic:\\n  int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n    vector<unordered_set<int>> more_preferred(n);\\n    for (const vector<int>& pair : pairs) {\\n      int x = pair[0];\\n      int y = pair[1];\\n      const vector<int>& px = preferences[x];\\n      const vector<int>& py = preferences[y];\\n      more_preferred[x].insert(px.begin(), std::find(px.begin(), px.end(), y));\\n      more_preferred[y].insert(py.begin(), std::find(py.begin(), py.end(), x));\\n    }\\n    int count = 0;\\n    for (int i = 0; i < n; ++i) {\\n      for (int j : more_preferred[i]) {\\n        if (Contains(more_preferred[j], i)) {\\n          ++count;\\n          break;\\n        }\\n      }\\n    }\\n    return count;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nbool Contains(const unordered_set<int>& s, int x) {\\n  return s.find(x) != s.end();\\n}\\n\\nclass Solution {\\npublic:\\n  int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n    vector<unordered_set<int>> more_preferred(n);\\n    for (const vector<int>& pair : pairs) {\\n      int x = pair[0];\\n      int y = pair[1];\\n      const vector<int>& px = preferences[x];\\n      const vector<int>& py = preferences[y];\\n      more_preferred[x].insert(px.begin(), std::find(px.begin(), px.end(), y));\\n      more_preferred[y].insert(py.begin(), std::find(py.begin(), py.end(), x));\\n    }\\n    int count = 0;\\n    for (int i = 0; i < n; ++i) {\\n      for (int j : more_preferred[i]) {\\n        if (Contains(more_preferred[j], i)) {\\n          ++count;\\n          break;\\n        }\\n      }\\n    }\\n    return count;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464060,
                "title": "easy-to-understand-java-solution-with-hashset-and-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private int findIndex(int[] arr, int elem) {\\n        for(int i = 0; i < arr.length; ++i) {\\n            if(arr[i] == elem)\\n                return i;\\n        }\\n        return -1; //shouldnt happen as we have full pref list for each person\\n    }\\n\\n    private boolean isPersonHighPri(int[] prefsFOP, int pairedWith, int person) {\\n        for(int friend : prefsFOP) {\\n            if(friend == person)\\n                return true;\\n            else if (friend == pairedWith)\\n                return false; \\n        }    \\n            return true; //shouldnt happen as we have full pref list for each person\\n    }\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Integer> pM = new HashMap<>();\\n        Set<Integer> unHappy = new HashSet<>();\\n        for (int[] pair : pairs) {\\n            pM.put(pair[0], pair[1]);\\n            pM.put(pair[1], pair[0]);\\n        }  \\n        for(int person : pM.keySet()) {\\n            if(unHappy.contains(person))\\n                continue;\\n            int other = pM.get(person);\\n            int[] prefsPerson = preferences[person];\\n            int idxOther = findIndex(prefsPerson, other);\\n            if(idxOther == 0) { //means person\\'s first choice, person is happy\\n                continue;\\n            }\\n            else { //go from 0 to idxOther-1, and for each \"other\", check if 1. friend is in their list && they are paired with someone whos priority is less than friend\\'s\\'\\n                for (int i = 0; i < idxOther; ++i) {\\n                    int friendOfPerson = prefsPerson[i];\\n                    int[] prefsFOP = preferences[friendOfPerson];\\n                    int pairedWith = pM.get(friendOfPerson);\\n                    boolean personIsHighPri = isPersonHighPri(prefsFOP, pairedWith, person);\\n                    if(personIsHighPri) {\\n                        unHappy.add(person);\\n                        unHappy.add(friendOfPerson);\\n                        break;\\n                    }\\n                } \\n            }\\n        }  \\n        return unHappy.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private int findIndex(int[] arr, int elem) {\\n        for(int i = 0; i < arr.length; ++i) {\\n            if(arr[i] == elem)\\n                return i;\\n        }\\n        return -1; //shouldnt happen as we have full pref list for each person\\n    }\\n\\n    private boolean isPersonHighPri(int[] prefsFOP, int pairedWith, int person) {\\n        for(int friend : prefsFOP) {\\n            if(friend == person)\\n                return true;\\n            else if (friend == pairedWith)\\n                return false; \\n        }    \\n            return true; //shouldnt happen as we have full pref list for each person\\n    }\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Integer> pM = new HashMap<>();\\n        Set<Integer> unHappy = new HashSet<>();\\n        for (int[] pair : pairs) {\\n            pM.put(pair[0], pair[1]);\\n            pM.put(pair[1], pair[0]);\\n        }  \\n        for(int person : pM.keySet()) {\\n            if(unHappy.contains(person))\\n                continue;\\n            int other = pM.get(person);\\n            int[] prefsPerson = preferences[person];\\n            int idxOther = findIndex(prefsPerson, other);\\n            if(idxOther == 0) { //means person\\'s first choice, person is happy\\n                continue;\\n            }\\n            else { //go from 0 to idxOther-1, and for each \"other\", check if 1. friend is in their list && they are paired with someone whos priority is less than friend\\'s\\'\\n                for (int i = 0; i < idxOther; ++i) {\\n                    int friendOfPerson = prefsPerson[i];\\n                    int[] prefsFOP = preferences[friendOfPerson];\\n                    int pairedWith = pM.get(friendOfPerson);\\n                    boolean personIsHighPri = isPersonHighPri(prefsFOP, pairedWith, person);\\n                    if(personIsHighPri) {\\n                        unHappy.add(person);\\n                        unHappy.add(friendOfPerson);\\n                        break;\\n                    }\\n                } \\n            }\\n        }  \\n        return unHappy.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454050,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairht, int f, int you){\\n        bool isTrue=false;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(preferences[you][i]==pairht[you]) break;\\n            \\n            if(preferences[you][i]==f)\\n                isTrue=true;\\n        }\\n        \\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> pairht(n);\\n        for(vector<int> pair : pairs){\\n            pairht[pair[0]]=pair[1];\\n            pairht[pair[1]]=pair[0];\\n        }\\n        \\n        int result=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(preferences[i][j]==pairht[i]) break;\\n                \\n                if(check(n, preferences, pairht, i, preferences[i][j])){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairht, int f, int you){\\n        bool isTrue=false;\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(preferences[you][i]==pairht[you]) break;\\n            \\n            if(preferences[you][i]==f)\\n                isTrue=true;\\n        }\\n        \\n        return isTrue;\\n    }\\n    \\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> pairht(n);\\n        for(vector<int> pair : pairs){\\n            pairht[pair[0]]=pair[1];\\n            pairht[pair[1]]=pair[0];\\n        }\\n        \\n        int result=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n-1; j++){\\n                if(preferences[i][j]==pairht[i]) break;\\n                \\n                if(check(n, preferences, pairht, i, preferences[i][j])){\\n                    result++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406485,
                "title": "java-soln-detailed-description",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int numUnHappyFriends = 0;\\n        int[][] rank = new int[n][n];\\n        // rank[i][j] holds how highly friend \\u2018i\\' views \\u2018j\\u2019. \\n        // 0 -> highest, n - 1 -> lowest\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n - 1; j++) {\\n                rank[i][preferences[i][j]] = j; \\n            }\\n        }\\n        \\n        for(int i = 0; i < n/2; i++) {\\n            // A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\\n            int x = pairs[i][0], y = pairs[i][1];\\n            for(int j = 0; j < n/2; j++) {\\n                // x prefers u over y, and\\n                // u prefers x over v.\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if(x != u && rank[x][u] < rank[x][y] && rank[u][x] < rank[u][v]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n                \\n                // x prefers v over y, and\\n                // v prefers x over u.\\n                if(x != v && rank[x][v] < rank[x][y] && rank[v][x] < rank[v][u]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n            }\\n            \\n            for(int j = 0; j < n/2; j++) {\\n                // y prefers u over x, and\\n                // u prefers y over v.\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if(y != u && rank[y][u] < rank[y][x] && rank[u][y] < rank[u][v]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n                \\n                // y prefers v over x, and\\n                // v prefers y over u.\\n                if(y != v && rank[y][v] < rank[y][x] && rank[v][y] < rank[v][u]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return numUnHappyFriends;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int numUnHappyFriends = 0;\\n        int[][] rank = new int[n][n];\\n        // rank[i][j] holds how highly friend \\u2018i\\' views \\u2018j\\u2019. \\n        // 0 -> highest, n - 1 -> lowest\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n - 1; j++) {\\n                rank[i][preferences[i][j]] = j; \\n            }\\n        }\\n        \\n        for(int i = 0; i < n/2; i++) {\\n            // A friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\\n            int x = pairs[i][0], y = pairs[i][1];\\n            for(int j = 0; j < n/2; j++) {\\n                // x prefers u over y, and\\n                // u prefers x over v.\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if(x != u && rank[x][u] < rank[x][y] && rank[u][x] < rank[u][v]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n                \\n                // x prefers v over y, and\\n                // v prefers x over u.\\n                if(x != v && rank[x][v] < rank[x][y] && rank[v][x] < rank[v][u]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n            }\\n            \\n            for(int j = 0; j < n/2; j++) {\\n                // y prefers u over x, and\\n                // u prefers y over v.\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if(y != u && rank[y][u] < rank[y][x] && rank[u][y] < rank[u][v]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n                \\n                // y prefers v over x, and\\n                // v prefers y over u.\\n                if(y != v && rank[y][v] < rank[y][x] && rank[v][y] < rank[v][u]) {\\n                    numUnHappyFriends++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return numUnHappyFriends;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391260,
                "title": "javascript-solution-with-diagrams",
                "content": "# The graph is always greener...\\n\\nThe problem can be simplified by describing an \"unhappy friend\" as a friend who prefers a friend who mutually prefers them. We can simplify this problem with a weighted, undirected graph representation of all friends. The weights represent the \"ranks\" each friend gives the other friend, from 0 to n - 1. \\n\\nBy coloring each paired edge red, relatively more expensive edges blue, and cheaper edges green, we can find that the answer is simplified to the number of mutually green edges (both friends rank each other higher than their current pairing).\\n\\nBy creating a map containing all friends with cheaper edges than their current pairing, we can easily identify unhappy friends as friends that both have each other as one of their \"better matches\".\\n\\nFriend Ranks\\n![preferences](https://assets.leetcode.com/users/images/12854c6b-4c38-4f39-81d9-a50ad1d2811f_1680888286.31621.png)\\nFriend Graph\\n![friend-graph](https://assets.leetcode.com/users/images/9736068f-168c-4d76-a2e7-21b5fa22e446_1680889475.8226116.png)\\n\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\n \\nconst unhappyFriends = function(n, preferences, pairs) {\\n  const map = new Array(n);\\n  const unhappyFriends = new Set();\\n  // create map of [friend] : [better matches]\\n  for (const [ friendA, friendB ] of pairs) {\\n      findBetterMatches(friendA, friendB, preferences[friendA]);\\n      findBetterMatches(friendB, friendA, preferences[friendB]);\\n  }\\n  // if two friends are mutually better matches for each other, both are unhappy\\n  for (const [friend, betterMatches] of map.entries()) {\\n    for (const match of betterMatches.values()) {\\n      if (map[match].has(friend)) {\\n        unhappyFriends.add(friend);\\n        unhappyFriends.add(match);\\n      }\\n    }\\n  }\\n  return unhappyFriends.size;\\n\\n  function findBetterMatches(friend, pairedFriend, friendPrefs) {\\n    const betterMatches = new Set();\\n    for (let rank = 0; rank < friendPrefs.length; rank++) {\\n      // create set of friends preferred over paired friend\\n      if (friendPrefs[rank] === pairedFriend) break;\\n      betterMatches.add(friendPrefs[rank]);\\n    };\\n    map[friend] = betterMatches;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\n \\nconst unhappyFriends = function(n, preferences, pairs) {\\n  const map = new Array(n);\\n  const unhappyFriends = new Set();\\n  // create map of [friend] : [better matches]\\n  for (const [ friendA, friendB ] of pairs) {\\n      findBetterMatches(friendA, friendB, preferences[friendA]);\\n      findBetterMatches(friendB, friendA, preferences[friendB]);\\n  }\\n  // if two friends are mutually better matches for each other, both are unhappy\\n  for (const [friend, betterMatches] of map.entries()) {\\n    for (const match of betterMatches.values()) {\\n      if (map[match].has(friend)) {\\n        unhappyFriends.add(friend);\\n        unhappyFriends.add(match);\\n      }\\n    }\\n  }\\n  return unhappyFriends.size;\\n\\n  function findBetterMatches(friend, pairedFriend, friendPrefs) {\\n    const betterMatches = new Set();\\n    for (let rank = 0; rank < friendPrefs.length; rank++) {\\n      // create set of friends preferred over paired friend\\n      if (friendPrefs[rank] === pairedFriend) break;\\n      betterMatches.add(friendPrefs[rank]);\\n    };\\n    map[friend] = betterMatches;\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382024,
                "title": "brute-force-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int UnhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        if (n ==2)\\n            return 0;\\n        int[][] prefMap = new int[n][];\\n        int[] map = new int[n];\\n        for(int i = 0; i < n;i++){\\n            prefMap[i] = new int[n];\\n            for(int j =0; j < n - 1; j++){\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        int count = 0;\\n\\n        foreach(int[] pair in pairs){\\n            map[pair[0]] = pair[1];\\n            map[pair[1]] = pair[0];\\n        }\\n\\n        for(int i = 0; i < n;i++){\\n            if(prefMap[i][map[i]] != 0){\\n                for(int j = 0; j < n; j++){\\n                    if(i != j && prefMap[i][j] < prefMap[i][map[i]] && prefMap[j][i] < prefMap[j][map[j]]){\\n                        count++;\\n                        break; // break out since we know i is unhappy\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int UnhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        if (n ==2)\\n            return 0;\\n        int[][] prefMap = new int[n][];\\n        int[] map = new int[n];\\n        for(int i = 0; i < n;i++){\\n            prefMap[i] = new int[n];\\n            for(int j =0; j < n - 1; j++){\\n                prefMap[i][preferences[i][j]] = j;\\n            }\\n        }\\n        int count = 0;\\n\\n        foreach(int[] pair in pairs){\\n            map[pair[0]] = pair[1];\\n            map[pair[1]] = pair[0];\\n        }\\n\\n        for(int i = 0; i < n;i++){\\n            if(prefMap[i][map[i]] != 0){\\n                for(int j = 0; j < n; j++){\\n                    if(i != j && prefMap[i][j] < prefMap[i][map[i]] && prefMap[j][i] < prefMap[j][map[j]]){\\n                        count++;\\n                        break; // break out since we know i is unhappy\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363549,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOnce you figure out what the question is asking and how to organize the pairings inside of a map its pretty straightforward, otherwise this question can be very confusing. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        int[] pairings = new int[n];\\n        for(int[] pair : pairs){\\n            pairings[pair[0]] = pair[1];\\n            pairings[pair[1]] = pair[0];\\n        }\\n        HashMap<Integer,HashMap<Integer,Integer>> prefers = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n - 1; j++){\\n                int friend = preferences[i][j];\\n                prefers.putIfAbsent(i,new HashMap<>());\\n                prefers.get(i).put(friend,j);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j : preferences[i]){\\n                if(prefers.get(i).get(j) < prefers.get(i).get(pairings[i]) && prefers.get(j).get(i) < prefers.get(j).get(pairings[j])){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        int[] pairings = new int[n];\\n        for(int[] pair : pairs){\\n            pairings[pair[0]] = pair[1];\\n            pairings[pair[1]] = pair[0];\\n        }\\n        HashMap<Integer,HashMap<Integer,Integer>> prefers = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n - 1; j++){\\n                int friend = preferences[i][j];\\n                prefers.putIfAbsent(i,new HashMap<>());\\n                prefers.get(i).put(friend,j);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j : preferences[i]){\\n                if(prefers.get(i).get(j) < prefers.get(i).get(pairings[i]) && prefers.get(j).get(i) < prefers.get(j).get(pairings[j])){\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362669,
                "title": "hashing-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) \\n    {\\n        int p=pairs.size();\\n        map<int,int> m;\\n        for(int x=0; x<p; x++)\\n        {\\n            m[pairs[x][0]]=pairs[x][1];\\n            m[pairs[x][1]]=pairs[x][0];\\n        }\\n        int unhappy=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            vector<int> p=preferences[x]; // 1 2 0\\n            int pairedWith=m[x]; // 2\\n            int u=0;\\n            for(auto it: p)\\n            {\\n                if(it==pairedWith) break;\\n                vector<int> p2=preferences[it]; // 3 2 0\\n                int pairedWith2=m[it]; // 0\\n                for(auto it2: p2)\\n                {\\n                    if(it2==pairedWith2) break;\\n                    if(it2==x)\\n                    {\\n                        u=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(u) unhappy++;\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) \\n    {\\n        int p=pairs.size();\\n        map<int,int> m;\\n        for(int x=0; x<p; x++)\\n        {\\n            m[pairs[x][0]]=pairs[x][1];\\n            m[pairs[x][1]]=pairs[x][0];\\n        }\\n        int unhappy=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            vector<int> p=preferences[x]; // 1 2 0\\n            int pairedWith=m[x]; // 2\\n            int u=0;\\n            for(auto it: p)\\n            {\\n                if(it==pairedWith) break;\\n                vector<int> p2=preferences[it]; // 3 2 0\\n                int pairedWith2=m[it]; // 0\\n                for(auto it2: p2)\\n                {\\n                    if(it2==pairedWith2) break;\\n                    if(it2==x)\\n                    {\\n                        u=1;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(u) unhappy++;\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361126,
                "title": "java-solution-let-s-simply-translate-the-question-into-if-x-u-x-y-u-x-u-v",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDirect translation from problem description to code.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nif (x[u] < x[y] && u[x] < u[v]) {\\n  unhappy[x] = true;\\n  unhappy[u] = true;\\n}\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] friend = new int[n][n]; // build friend mapping: f[i] -> [f1_v, f2_v, ... fn-1_v]\\n        for (int i = 0; i < n; i++) {\\n            int[] value = friend[i];\\n            // the smaller a friend\\'s value, the more this friend is prefered\\n            for (int k = 0; k < n - 1; k++) {\\n                value[preferences[i][k]] = k + 1;\\n            }\\n        }\\n\\n        boolean[] unhappy = new boolean[n];\\n        for (int i = 0; i < n / 2; i++) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n\\n            for (int j = i + 1; j < n / 2; j++) {\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if (unhappy[x] && unhappy[y] && unhappy[u] && unhappy[v]) {\\n                    continue;\\n                }\\n\\n                if (friend[x][u] < friend[x][y] && friend[u][x] < friend[u][v]) {\\n                    unhappy[x] = true;\\n                    unhappy[u] = true;\\n                }\\n\\n                if (friend[x][v] < friend[x][y] && friend[v][x] < friend[v][u]) {\\n                    unhappy[x] = true;\\n                    unhappy[v] = true;\\n                }\\n\\n                if (friend[y][u] < friend[y][x] && friend[u][y] < friend[u][v]) {\\n                    unhappy[y] = true;\\n                    unhappy[u] = true;\\n                }\\n\\n                if (friend[y][v] < friend[y][x] && friend[v][y] < friend[v][u]) {\\n                    unhappy[y] = true;\\n                    unhappy[v] = true;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (boolean b : unhappy) {\\n            if (b) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nif (x[u] < x[y] && u[x] < u[v]) {\\n  unhappy[x] = true;\\n  unhappy[u] = true;\\n}\\n```\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] friend = new int[n][n]; // build friend mapping: f[i] -> [f1_v, f2_v, ... fn-1_v]\\n        for (int i = 0; i < n; i++) {\\n            int[] value = friend[i];\\n            // the smaller a friend\\'s value, the more this friend is prefered\\n            for (int k = 0; k < n - 1; k++) {\\n                value[preferences[i][k]] = k + 1;\\n            }\\n        }\\n\\n        boolean[] unhappy = new boolean[n];\\n        for (int i = 0; i < n / 2; i++) {\\n            int x = pairs[i][0], y = pairs[i][1];\\n\\n            for (int j = i + 1; j < n / 2; j++) {\\n                int u = pairs[j][0], v = pairs[j][1];\\n                if (unhappy[x] && unhappy[y] && unhappy[u] && unhappy[v]) {\\n                    continue;\\n                }\\n\\n                if (friend[x][u] < friend[x][y] && friend[u][x] < friend[u][v]) {\\n                    unhappy[x] = true;\\n                    unhappy[u] = true;\\n                }\\n\\n                if (friend[x][v] < friend[x][y] && friend[v][x] < friend[v][u]) {\\n                    unhappy[x] = true;\\n                    unhappy[v] = true;\\n                }\\n\\n                if (friend[y][u] < friend[y][x] && friend[u][y] < friend[u][v]) {\\n                    unhappy[y] = true;\\n                    unhappy[u] = true;\\n                }\\n\\n                if (friend[y][v] < friend[y][x] && friend[v][y] < friend[v][u]) {\\n                    unhappy[y] = true;\\n                    unhappy[v] = true;\\n                }\\n            }\\n        }\\n\\n        int count = 0;\\n        for (boolean b : unhappy) {\\n            if (b) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338333,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int ret = 0 ;\\n        unordered_map<int, int>match ; //mathch\\n        vector<vector<int>>score(n, vector<int>(n)) ;\\n        for(auto p : pairs){\\n            match[p[0]] = p[1] ;\\n            match[p[1]] = p[0] ;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0 ; j <n-1; j++){\\n                int nxt = preferences[i][j] ;\\n                score[i][nxt] = n-j ;\\n            }\\n        }\\n\\n        for(int x = 0; x < n; x++){\\n            int y = match[x] ;\\n            for(int j =0; j < n-1; j++){\\n                if(preferences[x][j] == y)\\n                    break ;\\n                int u = preferences[x][j] ;\\n                int v= match[u] ;\\n                if(score[u][x] > score[u][v]){\\n                    ret ++;\\n                    break ;\\n                }                    \\n            }\\n\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int ret = 0 ;\\n        unordered_map<int, int>match ; //mathch\\n        vector<vector<int>>score(n, vector<int>(n)) ;\\n        for(auto p : pairs){\\n            match[p[0]] = p[1] ;\\n            match[p[1]] = p[0] ;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0 ; j <n-1; j++){\\n                int nxt = preferences[i][j] ;\\n                score[i][nxt] = n-j ;\\n            }\\n        }\\n\\n        for(int x = 0; x < n; x++){\\n            int y = match[x] ;\\n            for(int j =0; j < n-1; j++){\\n                if(preferences[x][j] == y)\\n                    break ;\\n                int u = preferences[x][j] ;\\n                int v= match[u] ;\\n                if(score[u][x] > score[u][v]){\\n                    ret ++;\\n                    break ;\\n                }                    \\n            }\\n\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293667,
                "title": "c-just-check-if-a-friend-prefers-someone-else-than-the-paired-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI get stuck when an interviewer asks about the $$O(N^2)$$. Denying the possibility that interviewer wouldn\\'t ask me $$O(N^2)$$ and there must be faster solution and that\\'s the key to win the interview, but can not find better solution.\\n\\nAnyways, it\\'s about simply checking the condition the problem states.\\n\\nThe \\'prefersOver\\' function here does that. It checks if the friend \\'f\\' prefers \\'f1\\' rather than (expected, paired) \\'f2\\'.\\n\\nJust to speed up checking if the preference for a given friend, I use the sorted table \\'orderedpreferences\\'.\\n\\nThat\\'s it.\\n\\nI found that most of friends here tried this approach. \\nI hope someone give better than $$O(N^2)$$ approach.\\n\\nThis maybe a good question to check how soon an interviewee come back from freeze state and have balls to write N^2 approach.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool prefersOver(vector<vector<int>> &orderedpreferences, \\n        int f, int f1, int f2){\\n        int pref1 = orderedpreferences[f][f1];\\n        int pref2 = orderedpreferences[f][f2];\\n        return pref1<pref2;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> paired(n);\\n        vector<vector<int>> orderedpreferences(n, vector<int>(n, -1));\\n        for(auto &p : pairs){\\n            paired[p[0]]=p[1];\\n            paired[p[1]]=p[0];\\n        }\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<preferences[i].size(); j++)\\n                orderedpreferences[i][ preferences[i][j] ] = j;\\n\\n        vector<bool> unhappy(n);\\n        for(int fr=0; fr<n; fr++){\\n            for(int f2 : preferences[fr]){\\n                if(f2==paired[fr]) break;\\n                if(prefersOver(orderedpreferences, f2, fr, paired[f2]))\\n                    unhappy[fr]=true;\\n            }\\n        }\\n        int count=0;\\n        for(bool b : unhappy) count+=b;\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prefersOver(vector<vector<int>> &orderedpreferences, \\n        int f, int f1, int f2){\\n        int pref1 = orderedpreferences[f][f1];\\n        int pref2 = orderedpreferences[f][f2];\\n        return pref1<pref2;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> paired(n);\\n        vector<vector<int>> orderedpreferences(n, vector<int>(n, -1));\\n        for(auto &p : pairs){\\n            paired[p[0]]=p[1];\\n            paired[p[1]]=p[0];\\n        }\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<preferences[i].size(); j++)\\n                orderedpreferences[i][ preferences[i][j] ] = j;\\n\\n        vector<bool> unhappy(n);\\n        for(int fr=0; fr<n; fr++){\\n            for(int f2 : preferences[fr]){\\n                if(f2==paired[fr]) break;\\n                if(prefersOver(orderedpreferences, f2, fr, paired[f2]))\\n                    unhappy[fr]=true;\\n            }\\n        }\\n        int count=0;\\n        for(bool b : unhappy) count+=b;\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261646,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func unhappyFriends(_ n: Int, _ pr: [[Int]], _ pa: [[Int]]) -> Int {\\n        \\n        var ws = Array(repeating: Array(repeating: Int.max, count: n), count: n)\\n        var res = 0\\n\\n        let ps = pa.reduce(into: Array(repeating: 0, count: n)) {\\n            $0[$1[0]] = $1[1]\\n            $0[$1[1]] = $1[0]\\n        }\\n\\n        func check(_ x: Int, _ y: Int) -> Bool {\\n            for u in ws[x].indices\\n                where ws[x][u] < ws[x][y] {\\n                    guard ws[u][x] > ws[u][ps[u]] else { return true }\\n                }\\n            return false\\n        }\\n\\n        for i in pr.indices {\\n            for j in pr[i].indices {\\n                ws[i][pr[i][j]] = j\\n            }\\n        }\\n\\n        for p in pa {\\n            if check(p[0], p[1]) { res += 1 }\\n            if check(p[1], p[0]) { res += 1 }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func unhappyFriends(_ n: Int, _ pr: [[Int]], _ pa: [[Int]]) -> Int {\\n        \\n        var ws = Array(repeating: Array(repeating: Int.max, count: n), count: n)\\n        var res = 0\\n\\n        let ps = pa.reduce(into: Array(repeating: 0, count: n)) {\\n            $0[$1[0]] = $1[1]\\n            $0[$1[1]] = $1[0]\\n        }\\n\\n        func check(_ x: Int, _ y: Int) -> Bool {\\n            for u in ws[x].indices\\n                where ws[x][u] < ws[x][y] {\\n                    guard ws[u][x] > ws[u][ps[u]] else { return true }\\n                }\\n            return false\\n        }\\n\\n        for i in pr.indices {\\n            for j in pr[i].indices {\\n                ws[i][pr[i][j]] = j\\n            }\\n        }\\n\\n        for p in pa {\\n            if check(p[0], p[1]) { res += 1 }\\n            if check(p[1], p[0]) { res += 1 }\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3232253,
                "title": "python-slower-but-easier-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        lookup = defaultdict(dict)\\n        for idx, preference in enumerate(preferences):\\n            for idx2, friend in enumerate(preference):\\n                lookup[idx][friend] = idx2\\n\\n        unhappy = set()\\n\\n        for (x, y), (u, v) in itertools.combinations(pairs, 2):\\n            if lookup[x][u] < lookup[x][y] and lookup[u][x] < lookup[u][v]:\\n                unhappy.add(x)\\n                unhappy.add(u)\\n\\n            if lookup[x][v] < lookup[x][y] and lookup[v][x] < lookup[v][u]:\\n                unhappy.add(x)\\n                unhappy.add(v)\\n\\n            if lookup[y][v] < lookup[y][x] and lookup[v][y] < lookup[v][u]:\\n                unhappy.add(y)\\n                unhappy.add(v)\\n\\n            if lookup[y][u] < lookup[y][x] and lookup[u][y] < lookup[u][v]:\\n                unhappy.add(y)\\n                unhappy.add(u)\\n\\n        return len(unhappy)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        lookup = defaultdict(dict)\\n        for idx, preference in enumerate(preferences):\\n            for idx2, friend in enumerate(preference):\\n                lookup[idx][friend] = idx2\\n\\n        unhappy = set()\\n\\n        for (x, y), (u, v) in itertools.combinations(pairs, 2):\\n            if lookup[x][u] < lookup[x][y] and lookup[u][x] < lookup[u][v]:\\n                unhappy.add(x)\\n                unhappy.add(u)\\n\\n            if lookup[x][v] < lookup[x][y] and lookup[v][x] < lookup[v][u]:\\n                unhappy.add(x)\\n                unhappy.add(v)\\n\\n            if lookup[y][v] < lookup[y][x] and lookup[v][y] < lookup[v][u]:\\n                unhappy.add(y)\\n                unhappy.add(v)\\n\\n            if lookup[y][u] < lookup[y][x] and lookup[u][y] < lookup[u][v]:\\n                unhappy.add(y)\\n                unhappy.add(u)\\n\\n        return len(unhappy)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228704,
                "title": "java-1ms-beats-100-uses-hashmap-to-store-pairs",
                "content": "# Intuition\\nStores pair of friends in a hashMap and calculates for each friend if they are unhappy  \\n\\n# Approach\\nSelf-explanatory - follow comments\\n\\n# Complexity\\n- Time complexity:\\nGoes through prefernces array for each friend - O(n^2)\\n\\n- Space complexity:\\nMap storing friendship for each friend - O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, Integer> pairMap;\\n    int[][] preferences;\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        this.preferences = preferences;\\n        this.pairMap = new HashMap<>();\\n\\n        int unhappy = 0;\\n\\n        for (int[] pair: pairs) {\\n            // Add each pair of frienship to map\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n\\n        for (int[] pair: pairs) {\\n            int x = pair[0];\\n            int y = pair[1];   \\n\\n            // for each pair x-y check if x is unhappy and if y is unhappy\\n            if (isUnhappy(x, preferences[x])) {\\n                unhappy++;\\n            }\\n            if (isUnhappy(y, preferences[y])) {\\n                unhappy++;\\n            }\\n        }\\n\\n        return unhappy;\\n        \\n    }\\n\\n    private boolean isUnhappy(int x, int[] prefx) {\\n        boolean unhappy = false;\\n        int y = pairMap.get(x);\\n\\n        /**\\n        * (1st condition)\\n        * Iterates through preferences array of x till it finds y\\n        * Friends after y are not to be considered since they have\\n        * low preference than orginal pairing i.e. x is happy with y\\n        */\\n    \\n        for (int u: prefx) {\\n            if (u != y && !unhappy) {\\n\\n                /**\\n                * (2nd condition)\\n                * For each u (friend with higher preference than y)\\n                * checks if v (the friend u is paired with) has higher\\n                * index than x in preference array of u which means\\n                * u prefers x over v\\n                */\\n \\n                if (indexOf(preferences[u], x) < indexOf(preferences[u], pairMap.get(u))) {\\n                    unhappy = true;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        return unhappy;\\n    }\\n\\n    // Gets index of value in arr\\n    private int indexOf(int[] arr, int value) {\\n        for (int i=0 ; i<arr.length ; i++) {\\n            if (arr[i] == value) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> pairMap;\\n    int[][] preferences;\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        this.preferences = preferences;\\n        this.pairMap = new HashMap<>();\\n\\n        int unhappy = 0;\\n\\n        for (int[] pair: pairs) {\\n            // Add each pair of frienship to map\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n\\n        for (int[] pair: pairs) {\\n            int x = pair[0];\\n            int y = pair[1];   \\n\\n            // for each pair x-y check if x is unhappy and if y is unhappy\\n            if (isUnhappy(x, preferences[x])) {\\n                unhappy++;\\n            }\\n            if (isUnhappy(y, preferences[y])) {\\n                unhappy++;\\n            }\\n        }\\n\\n        return unhappy;\\n        \\n    }\\n\\n    private boolean isUnhappy(int x, int[] prefx) {\\n        boolean unhappy = false;\\n        int y = pairMap.get(x);\\n\\n        /**\\n        * (1st condition)\\n        * Iterates through preferences array of x till it finds y\\n        * Friends after y are not to be considered since they have\\n        * low preference than orginal pairing i.e. x is happy with y\\n        */\\n    \\n        for (int u: prefx) {\\n            if (u != y && !unhappy) {\\n\\n                /**\\n                * (2nd condition)\\n                * For each u (friend with higher preference than y)\\n                * checks if v (the friend u is paired with) has higher\\n                * index than x in preference array of u which means\\n                * u prefers x over v\\n                */\\n \\n                if (indexOf(preferences[u], x) < indexOf(preferences[u], pairMap.get(u))) {\\n                    unhappy = true;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        return unhappy;\\n    }\\n\\n    // Gets index of value in arr\\n    private int indexOf(int[] arr, int value) {\\n        for (int i=0 ; i<arr.length ; i++) {\\n            if (arr[i] == value) {\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221869,
                "title": "simple-c-solution-time-waste-qn-leetcode-must-be-on-w-ed",
                "content": "// These Type Of Qn Are Just Time Waste... I\\'ll Not Suggest Anyone To Waste Too Much Time On These Qustions //\\n\\n# Code 1 (98% Beat In RunTime And 100% Beat In Space)\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        for(int i=0;i<pairs.size();i++){\\n            m[pairs[i][0]]=pairs[i][1];\\n            m[pairs[i][1]]=pairs[i][0];\\n        }\\n        int ans=0;\\n        for(auto x: m){\\n            bool fl=false;\\n            for(auto y: preferences[x.first]){\\n                if(y==x.second) break;\\n                if(m.find(y)!=m.end()){\\n                    for(auto z: preferences[y]){\\n                        if(z==m[y]) break;\\n                        if(z==x.first){\\n                            ans++;\\n                            fl=true;\\n                            // cout<<x.first<<\" \"<<y<<\"/\";\\n                            break;\\n                        }\\n                    }\\n                    if(fl) break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code 2 (89% Beat In RunTime And 96% Beat In Space)\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        for(auto x: pairs){\\n            m[x[0]]=x[1];\\n            m[x[1]]=x[0];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            bool fl=false;\\n            for(auto x: preferences[i]){\\n                if(x==m[i]) break;\\n                for(auto y: preferences[x]){\\n                    if(y==m[x]) break;\\n                    if(y==i){\\n                        ans++;\\n                        fl=true;\\n                        // cout<<i<<\" \"<<x<<\"/\";\\n                        break;\\n                    }\\n                }\\n                if(fl) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        for(int i=0;i<pairs.size();i++){\\n            m[pairs[i][0]]=pairs[i][1];\\n            m[pairs[i][1]]=pairs[i][0];\\n        }\\n        int ans=0;\\n        for(auto x: m){\\n            bool fl=false;\\n            for(auto y: preferences[x.first]){\\n                if(y==x.second) break;\\n                if(m.find(y)!=m.end()){\\n                    for(auto z: preferences[y]){\\n                        if(z==m[y]) break;\\n                        if(z==x.first){\\n                            ans++;\\n                            fl=true;\\n                            // cout<<x.first<<\" \"<<y<<\"/\";\\n                            break;\\n                        }\\n                    }\\n                    if(fl) break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> m;\\n        for(auto x: pairs){\\n            m[x[0]]=x[1];\\n            m[x[1]]=x[0];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            bool fl=false;\\n            for(auto x: preferences[i]){\\n                if(x==m[i]) break;\\n                for(auto y: preferences[x]){\\n                    if(y==m[x]) break;\\n                    if(y==i){\\n                        ans++;\\n                        fl=true;\\n                        // cout<<i<<\" \"<<x<<\"/\";\\n                        break;\\n                    }\\n                }\\n                if(fl) break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3215802,
                "title": "beats-100-easy-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n\\n      int count=0;\\n\\n      boolean func2(int number1,int number2,HashMap<Integer,Integer>mp,int[][]preferences){\\n\\n      int num=mp.get(number1);\\n\\n      for(int i=0;i<preferences[number1].length;i++){\\n          if(num==preferences[number1][i])return false;\\n          else if(number2==preferences[number1][i])return true;\\n      }\\n\\n      return true;\\n\\n      }\\n\\n    void func1(int num,int end,HashMap<Integer,Integer>mp,int[][]preferences,int[][]pairs){\\n\\n    int[]temp=preferences[num];\\n\\n    for(int i=0;i<temp.length&&temp[i]!=end;i++){\\n    if(func2(temp[i],num,mp,preferences)){\\n        count++;\\n        return;\\n    }\\n    }\\n\\n    }\\n\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n    for(int i=0;i<pairs.length;i++){\\n    mp.put(pairs[i][0],pairs[i][1]);\\n    mp.put(pairs[i][1],pairs[i][0]);\\n    }\\n    for(int i=0;i<pairs.length;i++){\\n    func1(pairs[i][0],pairs[i][1],mp,preferences,pairs);\\n    func1(pairs[i][1],pairs[i][0],mp,preferences,pairs);\\n    }\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n\\n      int count=0;\\n\\n      boolean func2(int number1,int number2,HashMap<Integer,Integer>mp,int[][]preferences){\\n\\n      int num=mp.get(number1);\\n\\n      for(int i=0;i<preferences[number1].length;i++){\\n          if(num==preferences[number1][i])return false;\\n          else if(number2==preferences[number1][i])return true;\\n      }\\n\\n      return true;\\n\\n      }\\n\\n    void func1(int num,int end,HashMap<Integer,Integer>mp,int[][]preferences,int[][]pairs){\\n\\n    int[]temp=preferences[num];\\n\\n    for(int i=0;i<temp.length&&temp[i]!=end;i++){\\n    if(func2(temp[i],num,mp,preferences)){\\n        count++;\\n        return;\\n    }\\n    }\\n\\n    }\\n\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n    HashMap<Integer,Integer>mp=new HashMap<>();\\n    for(int i=0;i<pairs.length;i++){\\n    mp.put(pairs[i][0],pairs[i][1]);\\n    mp.put(pairs[i][1],pairs[i][0]);\\n    }\\n    for(int i=0;i<pairs.length;i++){\\n    func1(pairs[i][0],pairs[i][1],mp,preferences,pairs);\\n    func1(pairs[i][1],pairs[i][0],mp,preferences,pairs);\\n    }\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207831,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ranking = defaultdict(lambda: defaultdict(int))\\n        \\n        for x, friends in enumerate(preferences):\\n            for rank, u in enumerate(friends):\\n                ranking[x][u] = rank\\n        \\n        pairmap = {}\\n        for x, y in pairs:\\n            pairmap[x] = y\\n            pairmap[y] = x\\n        \\n        res = 0\\n        for x, friends in enumerate(preferences):\\n            y = pairmap[x]\\n            for u in friends:\\n                v = pairmap[u]\\n                if ranking[x][u] < ranking[x][y] and ranking[u][x] < ranking[u][v]:\\n                    res += 1\\n                    break\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        ranking = defaultdict(lambda: defaultdict(int))\\n        \\n        for x, friends in enumerate(preferences):\\n            for rank, u in enumerate(friends):\\n                ranking[x][u] = rank\\n        \\n        pairmap = {}\\n        for x, y in pairs:\\n            pairmap[x] = y\\n            pairmap[y] = x\\n        \\n        res = 0\\n        for x, friends in enumerate(preferences):\\n            y = pairmap[x]\\n            for u in friends:\\n                v = pairmap[u]\\n                if ranking[x][u] < ranking[x][y] and ranking[u][x] < ranking[u][v]:\\n                    res += 1\\n                    break\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168108,
                "title": "swift",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    var dict: [Int: Int] = [:]\\n    var distances: [[Int]: Int] = [:]\\n\\n    var unhappy: Set<Int> = []\\n\\n    func unhappyFriends(_ n: Int, _ preferences: [[Int]], _ pairs: [[Int]]) -> Int {\\n\\n        for i in 0..<n {\\n            let person = i\\n            let personIPreferences = preferences[i]\\n            for j in 0..<personIPreferences.count {\\n                distances[[i, personIPreferences[j]]] = j\\n            }\\n        }\\n        \\n        for pair in pairs {\\n            let x = pair[0]\\n            let y = pair[1]\\n            dict[x, default: 0] = y\\n            dict[y, default: 0] = x\\n        }\\n\\n        for pair in pairs {\\n            checkPair(pair[0], pair[1], preferences, pairs)\\n            checkPair(pair[1], pair[0], preferences, pairs)\\n        }\\n\\n        return unhappy.count\\n    }\\n\\n    func checkPair(_ x: Int, _ y: Int, _ preferences: [[Int]], _ pairs: [[Int]])  {\\n\\n        let preferencesX = preferences[x]\\n            for u in preferencesX {\\n                if distances[[x, u]]! < distances[[x, y]]! {\\n                    let v = dict[u, default: 0]\\n                    let preferencesU = preferences[u]\\n                    \\n                    // potentialy check in loop\\n                    if distances[[u, x]]! < distances[[u, v]]!  { // check disatnce between two\\n                        unhappy.insert(x)\\n                    }\\n                }\\n        }  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    var dict: [Int: Int] = [:]\\n    var distances: [[Int]: Int] = [:]\\n\\n    var unhappy: Set<Int> = []\\n\\n    func unhappyFriends(_ n: Int, _ preferences: [[Int]], _ pairs: [[Int]]) -> Int {\\n\\n        for i in 0..<n {\\n            let person = i\\n            let personIPreferences = preferences[i]\\n            for j in 0..<personIPreferences.count {\\n                distances[[i, personIPreferences[j]]] = j\\n            }\\n        }\\n        \\n        for pair in pairs {\\n            let x = pair[0]\\n            let y = pair[1]\\n            dict[x, default: 0] = y\\n            dict[y, default: 0] = x\\n        }\\n\\n        for pair in pairs {\\n            checkPair(pair[0], pair[1], preferences, pairs)\\n            checkPair(pair[1], pair[0], preferences, pairs)\\n        }\\n\\n        return unhappy.count\\n    }\\n\\n    func checkPair(_ x: Int, _ y: Int, _ preferences: [[Int]], _ pairs: [[Int]])  {\\n\\n        let preferencesX = preferences[x]\\n            for u in preferencesX {\\n                if distances[[x, u]]! < distances[[x, y]]! {\\n                    let v = dict[u, default: 0]\\n                    let preferencesU = preferences[u]\\n                    \\n                    // potentialy check in loop\\n                    if distances[[u, x]]! < distances[[u, v]]!  { // check disatnce between two\\n                        unhappy.insert(x)\\n                    }\\n                }\\n        }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148056,
                "title": "using-index-and-dictionary-to-solve-python3",
                "content": "# Intuition\\nUsing index to find the unhappy and dictionary to solve\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        if n == 2:\\n            return 0\\n        unhappy = 0\\n        pair = {}\\n\\n        for i in pairs:\\n            pair[i[0]] = i[1]\\n            pair[i[1]] = i[0]\\n        \\n        for person in pair.keys():\\n            curr_pair = pair[person] #0\\n            pref = preferences[person] #[3,2,0]\\n            currp_index = pref.index(curr_pair) #0 ->2\\n            if currp_index != 0:\\n                for i in range(currp_index): #loop through [3,2,0]\\n                    temp_pref= pref[i] #3\\n                    temp_pair = pair[temp_pref] #2\\n                    index_temp_pair = preferences[temp_pref].index(temp_pair) #index of 2 -> 1\\n                    person_index = preferences[temp_pref].index(person) #index of 1 -> 0\\n                    if person_index < index_temp_pair:\\n                        unhappy +=1\\n                        break \\n        return unhappy\\n                    \\n\\n\\n                \\n            \\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        if n == 2:\\n            return 0\\n        unhappy = 0\\n        pair = {}\\n\\n        for i in pairs:\\n            pair[i[0]] = i[1]\\n            pair[i[1]] = i[0]\\n        \\n        for person in pair.keys():\\n            curr_pair = pair[person] #0\\n            pref = preferences[person] #[3,2,0]\\n            currp_index = pref.index(curr_pair) #0 ->2\\n            if currp_index != 0:\\n                for i in range(currp_index): #loop through [3,2,0]\\n                    temp_pref= pref[i] #3\\n                    temp_pair = pair[temp_pref] #2\\n                    index_temp_pair = preferences[temp_pref].index(temp_pair) #index of 2 -> 1\\n                    person_index = preferences[temp_pref].index(person) #index of 1 -> 0\\n                    if person_index < index_temp_pair:\\n                        unhappy +=1\\n                        break \\n        return unhappy\\n                    \\n\\n\\n                \\n            \\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124257,
                "title": "40ms-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse a topological sort approach. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, I will use a topological sort approach. This approach involves creating a directed graph of the friends, where each node is a friend and each edge is a preference. Then, the problem can be solved by looping through each friend and checking if any of their more preferred friends have a partner who is less preferred than them. If so, the friend is unhappy and can be added to the unhappy count.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<vector<int>> order(n, vector<int>(n));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n - 1; ++j) {\\n                order[i][preferences[i][j]] = j;\\n            }\\n        }\\n        vector<int> pairings(n);\\n        for (auto& pair : pairs) {\\n            pairings[pair[0]] = pair[1];\\n            pairings[pair[1]] = pair[0];\\n        }\\n        int unhappy = 0;\\n        for (int x = 0; x < n; ++x) {\\n            int y = pairings[x];\\n            int index = order[x][y];\\n            for (int i = 0; i < index; ++i) {\\n                int u = preferences[x][i];\\n                int v = pairings[u];\\n                if (order[u][x] < order[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<vector<int>> order(n, vector<int>(n));\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < n - 1; ++j) {\\n                order[i][preferences[i][j]] = j;\\n            }\\n        }\\n        vector<int> pairings(n);\\n        for (auto& pair : pairs) {\\n            pairings[pair[0]] = pair[1];\\n            pairings[pair[1]] = pair[0];\\n        }\\n        int unhappy = 0;\\n        for (int x = 0; x < n; ++x) {\\n            int y = pairings[x];\\n            int index = order[x][y];\\n            for (int i = 0; i < index; ++i) {\\n                int u = preferences[x][i];\\n                int v = pairings[u];\\n                if (order[u][x] < order[u][v]) {\\n                    ++unhappy;\\n                    break;\\n                }\\n            }\\n        }\\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3124255,
                "title": "python3-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this problem is to find the number of unhappy friends in a given group. The two main parameters we have to consider are the preferences and the pairings of the friends. We need to find out which pairings make the friends unhappy. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA brute force approach to this problem would be to compare each pair of friends with each other and check if they are unhappy with their current pairing. However, this would have a time complexity of $$O(n^2)$$ and is not optimal. \\n\\nA better approach would be to create an order of preference for each friend, using the given preferences. Then, we can iterate through each pair of friends and compare their current pairing with the order of preference. If the current pairing is not lower in the order of preference than any other friend, then the pair is happy. Otherwise, the pair is unhappy and we can increment the count of unhappy friends. This approach has a time complexity of $$O(n)$$ and a space complexity of $$O(n^2)$$.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        order = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n - 1):\\n                order[i][preferences[i][j]] = j\\n                \\n        pairings = [0] * n\\n        for x, y in pairs:\\n            pairings[x] = y\\n            pairings[y] = x\\n            \\n        unhappy = 0\\n        for x in range(n):\\n            y = pairings[x]\\n            index = order[x][y]\\n            for i in range(index):\\n                u = preferences[x][i]\\n                v = pairings[u]\\n                if order[u][x] < order[u][v]:\\n                    unhappy += 1\\n                    break\\n                    \\n        return unhappy\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        order = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n - 1):\\n                order[i][preferences[i][j]] = j\\n                \\n        pairings = [0] * n\\n        for x, y in pairs:\\n            pairings[x] = y\\n            pairings[y] = x\\n            \\n        unhappy = 0\\n        for x in range(n):\\n            y = pairings[x]\\n            index = order[x][y]\\n            for i in range(index):\\n                u = preferences[x][i]\\n                v = pairings[u]\\n                if order[u][x] < order[u][v]:\\n                    unhappy += 1\\n                    break\\n                    \\n        return unhappy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123422,
                "title": "c-short-easy-understand-time-fast-than-95-space-smaller-than-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> rec;\\n        int res = 0;\\n        for(auto it:pairs){\\n            rec[it[0]] = it[1];\\n            rec[it[1]] = it[0];\\n        }\\n        for(int i=0;i<n;i++){\\n            int index = find(preferences[i].begin(), preferences[i].end(), rec[i]) - preferences[i].begin();\\n            for(int j=0;j<index;j++){\\n                int pair_index = find(preferences[preferences[i][j]].begin(), preferences[preferences[i][j]].end(), rec[preferences[i][j]]) - preferences[preferences[i][j]].begin();\\n                int comp_index = find(preferences[preferences[i][j]].begin(), preferences[preferences[i][j]].end(), i) - preferences[preferences[i][j]].begin();\\n                if(comp_index < pair_index){\\n                    res += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_map<int, int> rec;\\n        int res = 0;\\n        for(auto it:pairs){\\n            rec[it[0]] = it[1];\\n            rec[it[1]] = it[0];\\n        }\\n        for(int i=0;i<n;i++){\\n            int index = find(preferences[i].begin(), preferences[i].end(), rec[i]) - preferences[i].begin();\\n            for(int j=0;j<index;j++){\\n                int pair_index = find(preferences[preferences[i][j]].begin(), preferences[preferences[i][j]].end(), rec[preferences[i][j]]) - preferences[preferences[i][j]].begin();\\n                int comp_index = find(preferences[preferences[i][j]].begin(), preferences[preferences[i][j]].end(), i) - preferences[preferences[i][j]].begin();\\n                if(comp_index < pair_index){\\n                    res += 1;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112093,
                "title": "python-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        for every number `x`, find its pair numbers\\' preference list and see if there are elements with the higher priority than the number `x` itself; \\n        if yes, we need to further check the preference list of those numbers and see if `x` is in it\\n\\n        # example 1:\\n        {\\n            0: []\\n            1: [3, 2]\\n            2: []\\n            3: [1]\\n        }\\n        \"\"\"\\n        hmap = {}\\n        for n1, n2 in pairs:\\n            hmap[n1] = preferences[n1][:preferences[n1].index(n2)]\\n            hmap[n2] = preferences[n2][:preferences[n2].index(n1)]\\n\\n        res = 0\\n        for k in hmap:\\n            for pref_before_parnter in hmap[k]:\\n                if k in hmap[pref_before_parnter]:\\n                    res += 1\\n                    break\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        for every number `x`, find its pair numbers\\' preference list and see if there are elements with the higher priority than the number `x` itself; \\n        if yes, we need to further check the preference list of those numbers and see if `x` is in it\\n\\n        # example 1:\\n        {\\n            0: []\\n            1: [3, 2]\\n            2: []\\n            3: [1]\\n        }\\n        \"\"\"\\n        hmap = {}\\n        for n1, n2 in pairs:\\n            hmap[n1] = preferences[n1][:preferences[n1].index(n2)]\\n            hmap[n2] = preferences[n2][:preferences[n2].index(n1)]\\n\\n        res = 0\\n        for k in hmap:\\n            for pref_before_parnter in hmap[k]:\\n                if k in hmap[pref_before_parnter]:\\n                    res += 1\\n                    break\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066039,
                "title": "easy-to-understand-c-o-n-2-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBuild a pref_vec that holds the order of preference for each person.\\nBuild a partners vector that holds each person\\'s partner.\\n\\nLoop through the pairs list to examine each person\\'s preference and use the \"unhappy\" logic to find out the result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        // A 2D list that holds the preference order of between friends\\n        vector<vector<int>> pref_vec(n, vector<int>(n, n));\\n        // A 1D list that holds partner pairs\\n        vector<int> partners(n, -1);\\n\\n        // Build the pref_vec by inserting the order number,\\n        // smaller the number is, the more preferable\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n-1; j++) {\\n                int pref_friend = preferences[i][j];\\n                pref_vec[i][pref_friend] = j;\\n            }\\n        }\\n\\n        // Build the partners vector\\n        for (auto& pair_ : pairs) {\\n            partners[pair_[0]] = pair_[1];\\n            partners[pair_[1]] = pair_[0];\\n        }\\n\\n        int ans = 0;\\n        // Loop through each pair and check the preferences\\n        for (auto& pair_ : pairs) {\\n            int f1 = pair_[0], f2 = pair_[1];\\n\\n            // Friend preference for f1:\\n            for (int f_ : preferences[f1]) {\\n                int f_partner = partners[f_];\\n                // The logic explained in this question:\\n                // If f1 prefers f_ more than f2, and f_ prefers f1 more than f_\\'s partner,\\n                // then ans++\\n                if (pref_vec[f1][f_] < pref_vec[f1][f2] && pref_vec[f_][f1] < pref_vec[f_][f_partner]) {\\n                    ans++;\\n                    break;\\n                } else if (f_ == f2) {\\n                    break;\\n                }\\n            }\\n\\n            // Friend preference for f2:\\n            for (int f_ : preferences[f2]) {\\n                int f_partner = partners[f_];\\n                // The logic explained in this question:\\n                // If f2 prefers f_ more than f1, and f_ prefers f2 more than f_\\'s partner,\\n                // then ans++\\n                if (pref_vec[f2][f_] < pref_vec[f2][f1] && pref_vec[f_][f2] < pref_vec[f_][f_partner]) {\\n                    ans++;\\n                    break;\\n                } else if (f_ == f1) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: O(n^2), a nested for loop is required\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2), size of pref_vec is n x n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        // A 2D list that holds the preference order of between friends\\n        vector<vector<int>> pref_vec(n, vector<int>(n, n));\\n        // A 1D list that holds partner pairs\\n        vector<int> partners(n, -1);\\n\\n        // Build the pref_vec by inserting the order number,\\n        // smaller the number is, the more preferable\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n-1; j++) {\\n                int pref_friend = preferences[i][j];\\n                pref_vec[i][pref_friend] = j;\\n            }\\n        }\\n\\n        // Build the partners vector\\n        for (auto& pair_ : pairs) {\\n            partners[pair_[0]] = pair_[1];\\n            partners[pair_[1]] = pair_[0];\\n        }\\n\\n        int ans = 0;\\n        // Loop through each pair and check the preferences\\n        for (auto& pair_ : pairs) {\\n            int f1 = pair_[0], f2 = pair_[1];\\n\\n            // Friend preference for f1:\\n            for (int f_ : preferences[f1]) {\\n                int f_partner = partners[f_];\\n                // The logic explained in this question:\\n                // If f1 prefers f_ more than f2, and f_ prefers f1 more than f_\\'s partner,\\n                // then ans++\\n                if (pref_vec[f1][f_] < pref_vec[f1][f2] && pref_vec[f_][f1] < pref_vec[f_][f_partner]) {\\n                    ans++;\\n                    break;\\n                } else if (f_ == f2) {\\n                    break;\\n                }\\n            }\\n\\n            // Friend preference for f2:\\n            for (int f_ : preferences[f2]) {\\n                int f_partner = partners[f_];\\n                // The logic explained in this question:\\n                // If f2 prefers f_ more than f1, and f_ prefers f2 more than f_\\'s partner,\\n                // then ans++\\n                if (pref_vec[f2][f_] < pref_vec[f2][f1] && pref_vec[f_][f2] < pref_vec[f_][f_partner]) {\\n                    ans++;\\n                    break;\\n                } else if (f_ == f1) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017641,
                "title": "c-beats-95-n-2-solution-tough-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Claryfing Questions:\\n    //  If someone is paired with a \\'neutrel\\' friend , is that person still unhappy?\\n    //  Does it make someone happy only if they are paired with their favorite person?\\n    //  What is one person is paired with their favorite person, but that fav person doesnt see\\n    //  the other person as their favorite person.\\n    bool check_if_unhappy(const vector<vector<int>>& preferences, const std::vector<int> lookup_table,int mate, int me)\\n    {\\n        for(int curr_pref = 0; curr_pref < preferences.size(); curr_pref++)\\n        {\\n            if(preferences[me][curr_pref] == lookup_table[me]) break;\\n            \\n            if(preferences[me][curr_pref] == mate) return true;\\n         \\n        }\\n\\n\\n       return false;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n    int num_of_unhappy_friends = 0;\\n    vector<int> match_lookup(n);\\n\\n    // This shows who got paired up with who.\\n    // easily indexed into for later. (inverse lookup table)\\n    for (const auto pair : pairs) {\\n      const int x = pair[0];\\n      const int y = pair[1];\\n      match_lookup[x] = y;\\n      match_lookup[y] = x;\\n    }\\n\\n    // Go over ever persons preferences\\n    for(int  i = 0 ; i < preferences.size(); i++)\\n    {\\n      for(int j = 0 ; j < preferences[0].size(); j++)\\n      {\\n          // if the current element in preferences list \\n          //  has a matching preference in the lookup table\\n          // this friend is not unhappy.\\n          if(preferences[i][j] == match_lookup[i]) break;\\n\\n          // If not then we have to check to see if we are really unhappy.\\n          if(check_if_unhappy(preferences, match_lookup, i, preferences[i][j]))\\n          {\\n            num_of_unhappy_friends++;\\n            break;\\n          }\\n\\n      }\\n    }\\n\\n  \\n    return num_of_unhappy_friends;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Claryfing Questions:\\n    //  If someone is paired with a \\'neutrel\\' friend , is that person still unhappy?\\n    //  Does it make someone happy only if they are paired with their favorite person?\\n    //  What is one person is paired with their favorite person, but that fav person doesnt see\\n    //  the other person as their favorite person.\\n    bool check_if_unhappy(const vector<vector<int>>& preferences, const std::vector<int> lookup_table,int mate, int me)\\n    {\\n        for(int curr_pref = 0; curr_pref < preferences.size(); curr_pref++)\\n        {\\n            if(preferences[me][curr_pref] == lookup_table[me]) break;\\n            \\n            if(preferences[me][curr_pref] == mate) return true;\\n         \\n        }\\n\\n\\n       return false;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n    int num_of_unhappy_friends = 0;\\n    vector<int> match_lookup(n);\\n\\n    // This shows who got paired up with who.\\n    // easily indexed into for later. (inverse lookup table)\\n    for (const auto pair : pairs) {\\n      const int x = pair[0];\\n      const int y = pair[1];\\n      match_lookup[x] = y;\\n      match_lookup[y] = x;\\n    }\\n\\n    // Go over ever persons preferences\\n    for(int  i = 0 ; i < preferences.size(); i++)\\n    {\\n      for(int j = 0 ; j < preferences[0].size(); j++)\\n      {\\n          // if the current element in preferences list \\n          //  has a matching preference in the lookup table\\n          // this friend is not unhappy.\\n          if(preferences[i][j] == match_lookup[i]) break;\\n\\n          // If not then we have to check to see if we are really unhappy.\\n          if(check_if_unhappy(preferences, match_lookup, i, preferences[i][j]))\\n          {\\n            num_of_unhappy_friends++;\\n            break;\\n          }\\n\\n      }\\n    }\\n\\n  \\n    return num_of_unhappy_friends;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017640,
                "title": "c-beats-95-n-2-solution-tough-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // Claryfing Questions:\\n    //  If someone is paired with a \\'neutrel\\' friend , is that person still unhappy?\\n    //  Does it make someone happy only if they are paired with their favorite person?\\n    //  What is one person is paired with their favorite person, but that fav person doesnt see\\n    //  the other person as their favorite person.\\n    bool check_if_unhappy(const vector<vector<int>>& preferences, const std::vector<int> lookup_table,int mate, int me)\\n    {\\n        for(int curr_pref = 0; curr_pref < preferences.size(); curr_pref++)\\n        {\\n            if(preferences[me][curr_pref] == lookup_table[me]) break;\\n            \\n            if(preferences[me][curr_pref] == mate) return true;\\n         \\n        }\\n\\n\\n       return false;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n    int num_of_unhappy_friends = 0;\\n    vector<int> match_lookup(n);\\n\\n    // This shows who got paired up with who.\\n    // easily indexed into for later. (inverse lookup table)\\n    for (const auto pair : pairs) {\\n      const int x = pair[0];\\n      const int y = pair[1];\\n      match_lookup[x] = y;\\n      match_lookup[y] = x;\\n    }\\n\\n    // Go over ever persons preferences\\n    for(int  i = 0 ; i < preferences.size(); i++)\\n    {\\n      for(int j = 0 ; j < preferences[0].size(); j++)\\n      {\\n          // if the current element in preferences list \\n          //  has a matching preference in the lookup table\\n          // this friend is not unhappy.\\n          if(preferences[i][j] == match_lookup[i]) break;\\n\\n          // If not then we have to check to see if we are really unhappy.\\n          if(check_if_unhappy(preferences, match_lookup, i, preferences[i][j]))\\n          {\\n            num_of_unhappy_friends++;\\n            break;\\n          }\\n\\n      }\\n    }\\n\\n  \\n    return num_of_unhappy_friends;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // Claryfing Questions:\\n    //  If someone is paired with a \\'neutrel\\' friend , is that person still unhappy?\\n    //  Does it make someone happy only if they are paired with their favorite person?\\n    //  What is one person is paired with their favorite person, but that fav person doesnt see\\n    //  the other person as their favorite person.\\n    bool check_if_unhappy(const vector<vector<int>>& preferences, const std::vector<int> lookup_table,int mate, int me)\\n    {\\n        for(int curr_pref = 0; curr_pref < preferences.size(); curr_pref++)\\n        {\\n            if(preferences[me][curr_pref] == lookup_table[me]) break;\\n            \\n            if(preferences[me][curr_pref] == mate) return true;\\n         \\n        }\\n\\n\\n       return false;\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        \\n    int num_of_unhappy_friends = 0;\\n    vector<int> match_lookup(n);\\n\\n    // This shows who got paired up with who.\\n    // easily indexed into for later. (inverse lookup table)\\n    for (const auto pair : pairs) {\\n      const int x = pair[0];\\n      const int y = pair[1];\\n      match_lookup[x] = y;\\n      match_lookup[y] = x;\\n    }\\n\\n    // Go over ever persons preferences\\n    for(int  i = 0 ; i < preferences.size(); i++)\\n    {\\n      for(int j = 0 ; j < preferences[0].size(); j++)\\n      {\\n          // if the current element in preferences list \\n          //  has a matching preference in the lookup table\\n          // this friend is not unhappy.\\n          if(preferences[i][j] == match_lookup[i]) break;\\n\\n          // If not then we have to check to see if we are really unhappy.\\n          if(check_if_unhappy(preferences, match_lookup, i, preferences[i][j]))\\n          {\\n            num_of_unhappy_friends++;\\n            break;\\n          }\\n\\n      }\\n    }\\n\\n  \\n    return num_of_unhappy_friends;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972055,
                "title": "python-3-beats-88-n-2-ish",
                "content": "\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        #Mark preferce of parters #O(n^2)\\n        prefs = {}\\n        for pair in pairs: #O(n)\\n            #find index/pref of partner; O(n)\\n            x = pair[0]\\n            y = pair[1]\\n\\n            xpref = preferences[x].index(y)\\n            ypref = preferences[y].index(x)\\n            #Save prefence of partner\\n            #Save all freinds with a higher prefrence than partner\\n            prefs[x] = (xpref,  preferences[x][:xpref])\\n            prefs[y] = (ypref, preferences[y][:ypref])\\n\\n\\n        #Sort highest first (meaning the most dissatisfied are first) #O(Nlogn)\\n        prefs = dict(sorted(prefs.items(), reverse=True,  key=lambda item: item[1][0])) \\n\\n        #list of friends from most to least disasisfied\\n        unclassified = list(map(lambda x: x[0], prefs.items()))\\n        unhappy = set({})\\n\\n        #repeat until all freinds are classified #O(n^3)\\n        while len(unclassified)>0: #O(n)\\n            x = unclassified[0]\\n            search = prefs[x][1]\\n            xpref = prefs[x][0]\\n            # for each friend that is higher ranking than current partner\\n            for y in search: #O(n)\\n                ypref = prefs[y][0]\\n                ysearch = prefs[y][1]\\n            # if x is also higher ranking than current partner both are unhappy\\n                if x in ysearch: #O(n)\\n                    unhappy.add(x)\\n                    unhappy.add(y)\\n                    if y in unclassified: #O(n)\\n                        unclassified.remove(y)\\n            unclassified.remove(x)\\n        return len(unhappy)\\n                \\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n\\n        #Mark preferce of parters #O(n^2)\\n        prefs = {}\\n        for pair in pairs: #O(n)\\n            #find index/pref of partner; O(n)\\n            x = pair[0]\\n            y = pair[1]\\n\\n            xpref = preferences[x].index(y)\\n            ypref = preferences[y].index(x)\\n            #Save prefence of partner\\n            #Save all freinds with a higher prefrence than partner\\n            prefs[x] = (xpref,  preferences[x][:xpref])\\n            prefs[y] = (ypref, preferences[y][:ypref])\\n\\n\\n        #Sort highest first (meaning the most dissatisfied are first) #O(Nlogn)\\n        prefs = dict(sorted(prefs.items(), reverse=True,  key=lambda item: item[1][0])) \\n\\n        #list of friends from most to least disasisfied\\n        unclassified = list(map(lambda x: x[0], prefs.items()))\\n        unhappy = set({})\\n\\n        #repeat until all freinds are classified #O(n^3)\\n        while len(unclassified)>0: #O(n)\\n            x = unclassified[0]\\n            search = prefs[x][1]\\n            xpref = prefs[x][0]\\n            # for each friend that is higher ranking than current partner\\n            for y in search: #O(n)\\n                ypref = prefs[y][0]\\n                ysearch = prefs[y][1]\\n            # if x is also higher ranking than current partner both are unhappy\\n                if x in ysearch: #O(n)\\n                    unhappy.add(x)\\n                    unhappy.add(y)\\n                    if y in unclassified: #O(n)\\n                        unclassified.remove(y)\\n            unclassified.remove(x)\\n        return len(unhappy)\\n                \\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943733,
                "title": "c-solution-straightforward-and-readable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    std::vector<int> GetHappier(vector<int> &pref, int paired) {\\n        return {pref.begin(), std::find(pref.begin(), pref.end(), paired)};\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n\\n        int nFriends = preferences.size();\\n\\n        int countUnhappy = 0;\\n\\n        vector<int> mHappier[nFriends];\\n\\n        // Identify and limit to preferences that would make each friend happier\\n        for( auto pair : pairs) { \\n            int p1 = pair.at(0), p2 = pair.at(1);\\n\\n            mHappier[p1] = GetHappier(preferences.at(p1), p2);\\n            mHappier[p2] = GetHappier(preferences.at(p2), p1);\\n        }\\n\\n        // For each friend, see if other friend also would prefer this friend\\n        for( int i = 0; i < nFriends; ++i) {\\n            for( int &o : mHappier[i]){\\n                auto &other = mHappier[o];\\n                if( std::find(other.begin(), other.end(), i) != other.end() ) {\\n                    ++countUnhappy;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return countUnhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> GetHappier(vector<int> &pref, int paired) {\\n        return {pref.begin(), std::find(pref.begin(), pref.end(), paired)};\\n    }\\n\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n\\n        int nFriends = preferences.size();\\n\\n        int countUnhappy = 0;\\n\\n        vector<int> mHappier[nFriends];\\n\\n        // Identify and limit to preferences that would make each friend happier\\n        for( auto pair : pairs) { \\n            int p1 = pair.at(0), p2 = pair.at(1);\\n\\n            mHappier[p1] = GetHappier(preferences.at(p1), p2);\\n            mHappier[p2] = GetHappier(preferences.at(p2), p1);\\n        }\\n\\n        // For each friend, see if other friend also would prefer this friend\\n        for( int i = 0; i < nFriends; ++i) {\\n            for( int &o : mHappier[i]){\\n                auto &other = mHappier[o];\\n                if( std::find(other.begin(), other.end(), i) != other.end() ) {\\n                    ++countUnhappy;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return countUnhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880611,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d = [defaultdict(lambda:float(\\'inf\\')) for _ in range(n)]\\n        for i in range(n):\\n            for k, j in enumerate(preferences[i]):\\n                d[i][j] = k\\n        def prefer(c, a, b):\\n            return d[c][a] < d[c][b]\\n        res = 0\\n        for x,y in pairs:\\n            for u,v in pairs:\\n                if prefer(x, u, y) and prefer(u, x, v) or prefer(x, v, y) and prefer(v, x, u):\\n                    res += 1\\n                    break\\n            for u,v in pairs:\\n                if prefer(y, v, x) and prefer(v, y, u) or prefer(y, u, x) and prefer(u, y, v):\\n                    res += 1\\n                    break\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        d = [defaultdict(lambda:float(\\'inf\\')) for _ in range(n)]\\n        for i in range(n):\\n            for k, j in enumerate(preferences[i]):\\n                d[i][j] = k\\n        def prefer(c, a, b):\\n            return d[c][a] < d[c][b]\\n        res = 0\\n        for x,y in pairs:\\n            for u,v in pairs:\\n                if prefer(x, u, y) and prefer(u, x, v) or prefer(x, v, y) and prefer(v, x, u):\\n                    res += 1\\n                    break\\n            for u,v in pairs:\\n                if prefer(y, v, x) and prefer(v, y, u) or prefer(y, u, x) and prefer(u, y, v):\\n                    res += 1\\n                    break\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2871115,
                "title": "java-solution-a-funny-explanation-of-the-problem",
                "content": "A funny explanation of the problem: \\n\\nHow to decide the happiness of yourself and your pair:\\n\\nIf you end up with your best friend as your partner, you are happy, end of story. \\n\\nIf not, your current partner is not your best friend, you then go exam what other possible partner you can have.\\nYou go through your preference list [f1, f2, f3, f4, f5...]. You want f1, but f1 don\\'t want you, she has a partner better than you (earlier in her preference list); then you check f2, f2 don\\'t want you too... finally, you either find someone prefer you better than her current partner then be unhappy; or you find your current partner is your best choice and be happy.\\n\\nYour partner do the same exam for her preference list. \\n\\n```\\n//O(nn), O(n)\\nclass Solution {\\n    Map<Integer, Integer> partner = null;\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Set<Integer> unhappy = new HashSet<>();\\n        partner = new HashMap<>();\\n        for(int[] pair : pairs) {\\n            partner.put(pair[0], pair[1]);\\n            partner.put(pair[1], pair[0]);\\n        }\\n        \\n        for(int[] pair : pairs) {\\n            int a = pair[0];\\n            int b = pair[1];\\n            \\n            if(!isHappy(preferences, a, b)) {\\n                unhappy.add(a);\\n            }\\n            \\n            if(!isHappy(preferences, b, a)) {\\n                unhappy.add(b);\\n            }\\n        }\\n        return unhappy.size();\\n        \\n    }\\n    \\n    boolean isHappy(int[][] preferences, int a, int b) {\\n        int bestFriend = preferences[a][0];\\n        if(bestFriend != b) {\\n            for(int lover : preferences[a]) {\\n                if(lover == b) {\\n                    return true;\\n                } \\n                if(!isLoverHappy(preferences[lover], a, partner.get(lover))) {\\n                    return false;\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    boolean isLoverHappy(int[] pref, int me, int he) {\\n        for(int friend : pref) {\\n            if(friend == me) {\\n                return false;\\n            }\\n            if(friend == he) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//O(nn), O(n)\\nclass Solution {\\n    Map<Integer, Integer> partner = null;\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Set<Integer> unhappy = new HashSet<>();\\n        partner = new HashMap<>();\\n        for(int[] pair : pairs) {\\n            partner.put(pair[0], pair[1]);\\n            partner.put(pair[1], pair[0]);\\n        }\\n        \\n        for(int[] pair : pairs) {\\n            int a = pair[0];\\n            int b = pair[1];\\n            \\n            if(!isHappy(preferences, a, b)) {\\n                unhappy.add(a);\\n            }\\n            \\n            if(!isHappy(preferences, b, a)) {\\n                unhappy.add(b);\\n            }\\n        }\\n        return unhappy.size();\\n        \\n    }\\n    \\n    boolean isHappy(int[][] preferences, int a, int b) {\\n        int bestFriend = preferences[a][0];\\n        if(bestFriend != b) {\\n            for(int lover : preferences[a]) {\\n                if(lover == b) {\\n                    return true;\\n                } \\n                if(!isLoverHappy(preferences[lover], a, partner.get(lover))) {\\n                    return false;\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    boolean isLoverHappy(int[] pref, int me, int he) {\\n        for(int friend : pref) {\\n            if(friend == me) {\\n                return false;\\n            }\\n            if(friend == he) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867840,
                "title": "daily-leetcode-challenge-day-28",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    thoughts:\\n    the questions is not very clear, \\n    We have a bunch of people here, and the preferences[i] tells\\n    me who this i-th person connected, and its in order of \\n    preference.\\n    [[friend_2_idx, firend_3_idx...], [friend_1_idx,...],...]\\n        ^                                 ^\\n    friend_1\\'s circle,                  friend_2\\'s circle\\n    And since we all have our own preferences, their might be\\n    unhappiness between friends because\\n    firend1 and friend_2 are pairs, while friend_10, and friend_5\\n    are pairs\\n    that firend_1 prefers firend_10 over friend_2\\n    while firend_10 prefers friend_1 over friend_5\\n    Oh ok it feels like a relationship problem.\\n    since it sounds like a graph of paired ones and we need to \\n    visit all of their connected nodes. I want to create \\n    it with a adj_list using dictionary.\\n\\n    Then we put in the preference order for the paired ones\\n    So later when we compare we can have direct access.\\n    preference_map[i][j] means the preference order of i toward j\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        \\n        \"\"\"\\n        adj = {}\\n        for i, j in pairs:\\n            adj[i] = j\\n            adj[j] = i\\n        preference_map = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            k = n\\n            for j in range(len(preferences[i])):\\n                preference_map[i][preferences[i][j]] = k; \\n                k -= 1   # k-th order of preference (highest preference on the left, lowest preference on the right)\\n        count = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j:\\n                    continue\\n                if preference_map[i][j] > preference_map[i][adj[i]] and preference_map[j][i] > preference_map[j][adj[j]]:  # i prefers j over i\\'s adjacent pair and j prefers i over j\\'s adjacent pair\\n                    count += 1\\n                    break                      # \\\\U0001f3af i-th unhappy friend found\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        \"\"\"\\n        \\n        \"\"\"\\n        adj = {}\\n        for i, j in pairs:\\n            adj[i] = j\\n            adj[j] = i\\n        preference_map = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            k = n\\n            for j in range(len(preferences[i])):\\n                preference_map[i][preferences[i][j]] = k; \\n                k -= 1   # k-th order of preference (highest preference on the left, lowest preference on the right)\\n        count = 0\\n        for i in range(n):\\n            for j in range(n):\\n                if i == j:\\n                    continue\\n                if preference_map[i][j] > preference_map[i][adj[i]] and preference_map[j][i] > preference_map[j][adj[j]]:  # i prefers j over i\\'s adjacent pair and j prefers i over j\\'s adjacent pair\\n                    count += 1\\n                    break                      # \\\\U0001f3af i-th unhappy friend found\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867248,
                "title": "c-brute-force-friend-checks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    //returns true if the you does not have pairing as preferred\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairMap, int f, int you){\\n        for(int j=0; j < n-1; j++){\\n\\n            if(preferences[you][j] == pairMap[you])\\n                break;\\n            \\n             if(preferences[you][j] == f)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int unhappy = 0;\\n        \\n        vector<int> pairMap(n, -1); //pairing map\\n        for(auto p: pairs){\\n            pairMap[p[0]] = p[1];\\n            pairMap[p[1]] = p[0];\\n        }\\n\\n        //loop over each person and within .. loop over the preferences\\n        //In each case until the preference is not pairing, then check the same for the pairing\\n        //In check, we see if the pairing has same situation as this friend.\\n        for(int i=0; i < n; ++i){\\n\\n            for(int j=0; j < n-1; j++){\\n\\n                if(preferences[i][j] == pairMap[i])\\n                    break;\\n\\n                if(check(n, preferences, pairMap, i, preferences[i][j])){\\n                    unhappy++;\\n                    break;\\n                }\\n            }\\n\\n\\n        }\\n       \\n        \\n\\n        return unhappy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    //returns true if the you does not have pairing as preferred\\n    bool check(int n, vector<vector<int>>& preferences, vector<int> pairMap, int f, int you){\\n        for(int j=0; j < n-1; j++){\\n\\n            if(preferences[you][j] == pairMap[you])\\n                break;\\n            \\n             if(preferences[you][j] == f)\\n                return true;\\n        }\\n\\n        return false;\\n    }\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        int unhappy = 0;\\n        \\n        vector<int> pairMap(n, -1); //pairing map\\n        for(auto p: pairs){\\n            pairMap[p[0]] = p[1];\\n            pairMap[p[1]] = p[0];\\n        }\\n\\n        //loop over each person and within .. loop over the preferences\\n        //In each case until the preference is not pairing, then check the same for the pairing\\n        //In check, we see if the pairing has same situation as this friend.\\n        for(int i=0; i < n; ++i){\\n\\n            for(int j=0; j < n-1; j++){\\n\\n                if(preferences[i][j] == pairMap[i])\\n                    break;\\n\\n                if(check(n, preferences, pairMap, i, preferences[i][j])){\\n                    unhappy++;\\n                    break;\\n                }\\n            }\\n\\n\\n        }\\n       \\n        \\n\\n        return unhappy;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851864,
                "title": "python-solution-o-n2",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        hashmap = {}\\n        for pair in pairs:\\n            person_one = pair[0]\\n            person_two = pair[1]\\n            pref_one = preferences[person_one]\\n            i = 0\\n            person_one_preferee = []\\n            while i < len(pref_one) and pref_one[i] != person_two:\\n                person_one_preferee.append(pref_one[i])\\n                i += 1\\n            hashmap[person_one] = person_one_preferee\\n            \\n            pref_two = preferences[person_two]\\n            i = 0\\n            person_two_preferee = []\\n            while i < len(pref_two) and pref_two[i] != person_one:\\n                person_two_preferee.append(pref_two[i])\\n                i += 1\\n            hashmap[person_two] = person_two_preferee\\n        print(hashmap)\\n        \\n        count = 0\\n        for person, preferee_list in hashmap.items():\\n            for preferee in preferee_list:\\n                if person in hashmap[preferee]:\\n                    count += 1\\n                    break\\n        return count",
                "solutionTags": [],
                "code": "class Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        hashmap = {}",
                "codeTag": "Java"
            },
            {
                "id": 2851810,
                "title": "golang-map-better-candidates-and-check-condition",
                "content": "```go\\nfunc unhappyFriends(n int, preferences [][]int, pairs [][]int) int {\\n  // Let\\'s make a pair map for easier access of pairs\\n  pairMap := make(map[int]int)\\n  for _, pair := range pairs {\\n    pairMap[pair[0]] = pair[1]\\n    pairMap[pair[1]] = pair[0]\\n  }\\n  // Let\\'s compute the better candidates for each person than their current pair\\n  better := make([]map[int]bool, n)\\n  for i := 0; i < n; i++ {\\n    better[i] = make(map[int]bool)\\n    for j := 0; j < len(preferences[i]) && preferences[i][j] != pairMap[i]; j++ {\\n      better[i][preferences[i][j]] = true\\n    }\\n  }\\n  var res int\\n  // Now we\\'ll go through everyone and find if any of them are unhappy\\n  for i := 0; i < n; i++ {\\n    for b := range better[i] {\\n      // i prefers b over his current pair and b prefers i over his current pair\\n      if better[b][i] {\\n        res++\\n        break\\n      }     \\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc unhappyFriends(n int, preferences [][]int, pairs [][]int) int {\\n  // Let\\'s make a pair map for easier access of pairs\\n  pairMap := make(map[int]int)\\n  for _, pair := range pairs {\\n    pairMap[pair[0]] = pair[1]\\n    pairMap[pair[1]] = pair[0]\\n  }\\n  // Let\\'s compute the better candidates for each person than their current pair\\n  better := make([]map[int]bool, n)\\n  for i := 0; i < n; i++ {\\n    better[i] = make(map[int]bool)\\n    for j := 0; j < len(preferences[i]) && preferences[i][j] != pairMap[i]; j++ {\\n      better[i][preferences[i][j]] = true\\n    }\\n  }\\n  var res int\\n  // Now we\\'ll go through everyone and find if any of them are unhappy\\n  for i := 0; i < n; i++ {\\n    for b := range better[i] {\\n      // i prefers b over his current pair and b prefers i over his current pair\\n      if better[b][i] {\\n        res++\\n        break\\n      }     \\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2845736,
                "title": "python-o-n-3-follow-the-rules-word-by-word",
                "content": "# Intuition\\nThere is a O(n^2) solution but I want to show this intuitive O(n^3) solution by just following the rules stated in the question.\\n# Approach\\nCreate a dictionary of pairs for easy lookup. Then follow the question logic word by word.\\n# Complexity\\n- Time complexity:\\nO(n * m^2) where n is the number of people and m is the max length of betterFriends per person. In otherwords (n^3).\\n\\n- Space complexity:\\nO(n) for the dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # iterate through the pairs\\n        # add pairs to d: d[x] = y, d[y] = x\\n        # check each pair x, y in preferences to see if\\n        # for friends in preferences[x][:indexy]:\\n        #    check the condition\\n\\n        pd = {}\\n        for x, y in pairs:\\n            pd[x] = y\\n            pd[y] = x\\n\\n        unhappy = 0\\n        for x in pd.keys():\\n            y = pd[x]\\n            indexy = preferences[x].index(y)\\n            betterFriends = preferences[x][:indexy]\\n\\n            for u in betterFriends:\\n                v = pd[u]\\n                indexv = preferences[u].index(v)\\n\\n                if x in preferences[u][:indexv]:\\n                    unhappy += 1\\n                    break\\n\\n        return unhappy\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # iterate through the pairs\\n        # add pairs to d: d[x] = y, d[y] = x\\n        # check each pair x, y in preferences to see if\\n        # for friends in preferences[x][:indexy]:\\n        #    check the condition\\n\\n        pd = {}\\n        for x, y in pairs:\\n            pd[x] = y\\n            pd[y] = x\\n\\n        unhappy = 0\\n        for x in pd.keys():\\n            y = pd[x]\\n            indexy = preferences[x].index(y)\\n            betterFriends = preferences[x][:indexy]\\n\\n            for u in betterFriends:\\n                v = pd[u]\\n                indexv = preferences[u].index(v)\\n\\n                if x in preferences[u][:indexv]:\\n                    unhappy += 1\\n                    break\\n\\n        return unhappy\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843519,
                "title": "java-easy-solution-with-a-pair-map-and-array-of-preferences-map",
                "content": "Prepare a pairmap to chek if a value exist as a pair for easy look up. \\nCreate array of maps to store preferences array with their index as key for easy order look up.  \\n```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Integer> pairMap = new HashMap<>();\\n        List<Map<Integer, Integer>> preMap = new ArrayList<>();\\n        for(int[] pair: pairs){\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        for(int[] pref: preferences){\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for(int i=0;i<pref.length;i++){\\n                map.put(pref[i], i);\\n            }\\n            preMap.add(map);\\n        }\\n        int result = 0;\\n        for(int[] pair : pairs){\\n            int x = pair[0];\\n            int y = pair[1];\\n            \\n            if(preferences[x][0] !=y){\\n                if(unhappy(preferences[x], x,y, pairMap, preMap)) result++;\\n            }\\n            \\n            if(preferences[y][0] !=x){\\n                if(unhappy(preferences[y], y,x, pairMap, preMap)) result++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    boolean unhappy(int[] preference, int x, int y, Map<Integer, Integer> pairMap, List<Map<Integer, Integer>> preMap){\\n        for(int i=0;i<preMap.get(x).get(y);i++){ //3,2\\n            //preference[i] 3,2\\n            //pairMap.get(preference[i] [1,2,0] and [3,1,0]\\n            if(pairMap.containsKey(preference[i])){ // 3, 2\\n                Map<Integer, Integer> temp = preMap.get(preference[i]); //1,2,0\\n                if(temp.containsKey(x) &&\\n                   temp.containsKey(pairMap.get(preference[i])) &&\\n                   temp.get(x)<temp.get(pairMap.get(preference[i]))\\n                  )\\n                \\n                return true;\\n            }  \\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        Map<Integer, Integer> pairMap = new HashMap<>();\\n        List<Map<Integer, Integer>> preMap = new ArrayList<>();\\n        for(int[] pair: pairs){\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        for(int[] pref: preferences){\\n            Map<Integer, Integer> map = new HashMap<>();\\n            for(int i=0;i<pref.length;i++){\\n                map.put(pref[i], i);\\n            }\\n            preMap.add(map);\\n        }\\n        int result = 0;\\n        for(int[] pair : pairs){\\n            int x = pair[0];\\n            int y = pair[1];\\n            \\n            if(preferences[x][0] !=y){\\n                if(unhappy(preferences[x], x,y, pairMap, preMap)) result++;\\n            }\\n            \\n            if(preferences[y][0] !=x){\\n                if(unhappy(preferences[y], y,x, pairMap, preMap)) result++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    boolean unhappy(int[] preference, int x, int y, Map<Integer, Integer> pairMap, List<Map<Integer, Integer>> preMap){\\n        for(int i=0;i<preMap.get(x).get(y);i++){ //3,2\\n            //preference[i] 3,2\\n            //pairMap.get(preference[i] [1,2,0] and [3,1,0]\\n            if(pairMap.containsKey(preference[i])){ // 3, 2\\n                Map<Integer, Integer> temp = preMap.get(preference[i]); //1,2,0\\n                if(temp.containsKey(x) &&\\n                   temp.containsKey(pairMap.get(preference[i])) &&\\n                   temp.get(x)<temp.get(pairMap.get(preference[i]))\\n                  )\\n                \\n                return true;\\n            }  \\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808618,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\nSince n is small, we can use a solution with time complexity of O(n^3) to solve this problem. Therefore, we just need to solve it manually by:\\n- Check if there is any i exisitng such that i stand before y in preferences[x], if not, ignore and check the next one\\n- Check if x stand before iPair (current partner of i) in preferences[u]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        HashMap<Integer, Integer> pairMap = new HashMap<>();\\n        for(int[] pair : pairs){\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        int result = 0;\\n        for(int[] pair : pairs){\\n            if(isUnhappy(pair[0], pairMap, preferences, n)){\\n                result++;\\n            }\\n            if(isUnhappy(pair[1], pairMap, preferences, n)){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean isUnhappy(int curr, HashMap<Integer, Integer> pairMap, int[][] preferences, int n){\\n        // Condition 1: u stand before y in preferences[x]\\n        // Condition 2: x stand before v in preferecens[u]\\n        int currPair = pairMap.get(curr);\\n        for(int i = 0; i < n; i++){\\n            if(i == curr || i == currPair){\\n                continue;\\n            }\\n            // Consider i, whether or not i stand before currPair\\n            int index1 = -1; //Index of i\\n            int index2 = -1; //Index of currPair\\n            for(int j = 0; j < n - 1; j++){\\n                if(preferences[curr][j] == i){\\n                    index1 = j;\\n                }\\n                if(preferences[curr][j] == currPair){\\n                    index2 = j;\\n                }\\n            }\\n            // There is no other person that curr prefer than the current one\\n            // Curr prefer currPair over i\\n            if(index1 > index2){\\n                continue;\\n            }\\n            // Continue if index1 > index2\\n            // Check if index of curr  > index of iPair\\n            int index3 = -1; //Index of curr\\n            int index4 = -1; //Index of iPair\\n            int iPair = pairMap.get(i);\\n            \\n            for(int j = 0; j < n - 1; j++){\\n                if(preferences[i][j] == curr){\\n                    index3 = j;\\n                }\\n                if(preferences[i][j] == iPair){\\n                    index4 = j;\\n                }\\n            }\\n            // i prefer iPair over curr\\n            if(index3 > index4){\\n                continue;\\n            }\\n            // Found a pair that index3 < index4 && index1 < index2\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        HashMap<Integer, Integer> pairMap = new HashMap<>();\\n        for(int[] pair : pairs){\\n            pairMap.put(pair[0], pair[1]);\\n            pairMap.put(pair[1], pair[0]);\\n        }\\n        int result = 0;\\n        for(int[] pair : pairs){\\n            if(isUnhappy(pair[0], pairMap, preferences, n)){\\n                result++;\\n            }\\n            if(isUnhappy(pair[1], pairMap, preferences, n)){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    public boolean isUnhappy(int curr, HashMap<Integer, Integer> pairMap, int[][] preferences, int n){\\n        // Condition 1: u stand before y in preferences[x]\\n        // Condition 2: x stand before v in preferecens[u]\\n        int currPair = pairMap.get(curr);\\n        for(int i = 0; i < n; i++){\\n            if(i == curr || i == currPair){\\n                continue;\\n            }\\n            // Consider i, whether or not i stand before currPair\\n            int index1 = -1; //Index of i\\n            int index2 = -1; //Index of currPair\\n            for(int j = 0; j < n - 1; j++){\\n                if(preferences[curr][j] == i){\\n                    index1 = j;\\n                }\\n                if(preferences[curr][j] == currPair){\\n                    index2 = j;\\n                }\\n            }\\n            // There is no other person that curr prefer than the current one\\n            // Curr prefer currPair over i\\n            if(index1 > index2){\\n                continue;\\n            }\\n            // Continue if index1 > index2\\n            // Check if index of curr  > index of iPair\\n            int index3 = -1; //Index of curr\\n            int index4 = -1; //Index of iPair\\n            int iPair = pairMap.get(i);\\n            \\n            for(int j = 0; j < n - 1; j++){\\n                if(preferences[i][j] == curr){\\n                    index3 = j;\\n                }\\n                if(preferences[i][j] == iPair){\\n                    index4 = j;\\n                }\\n            }\\n            // i prefer iPair over curr\\n            if(index3 > index4){\\n                continue;\\n            }\\n            // Found a pair that index3 < index4 && index1 < index2\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776531,
                "title": "java-with-comments-to-help-the-logic",
                "content": "```\\n\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        //build given matching from pairs\\n        int matching[] = new int[n];\\n        for (int[] pair : pairs){\\n            matching[pair[0]] = pair[1];\\n            matching[pair[1]] = pair[0];\\n        }\\n        \\n        //mapping preferences to order\\n        int order[][] = new int[n][n];\\n        for (int i = 0; i < n; i++){\\n            for (int j =0; j < n - 1; j++){\\n                // no self preference hence j runs to n -1\\n                int pref = preferences[i][j];\\n                order[i][pref] = j;\\n            }\\n        }\\n        \\n        \\n        int unHappyCount = 0;\\n        \\n        for (int x = 0; x < n; x++){\\n            //get x\\'s match say y\\n            int y = matching[x];\\n            //get x pref to y from order\\n            int idx = order[x][y];\\n            \\n            //for each u before y from x preference list,\\n            \\n            for (int i = 0; i < idx; i++){\\n                int u = preferences[x][i];\\n                //get u\\'s current matching\\n                int v = matching[u];\\n                // check u, v order is higher that u,x order.\\n                // preference with x.\\n                if (order[u][v] > order[u][x]){\\n                    unHappyCount+=1;\\n                    break;\\n                }\\n            }\\n        }\\n        return unHappyCount;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        //build given matching from pairs\\n        int matching[] = new int[n];\\n        for (int[] pair : pairs){\\n            matching[pair[0]] = pair[1];\\n            matching[pair[1]] = pair[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2761202,
                "title": "java-clean-code-w-named-variables-to-represent-friends-i-e-alice-bob",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int numUnhappy = 0;\\n        HashMap<Integer,int[]> friendMap = new HashMap<>();\\n        HashMap<Integer,Integer> pair = new HashMap<>();\\n        for(int i = 0; i<preferences.length; i++){\\n            int[] rankings = new int[n];\\n            int counter = n;\\n            for(int friend : preferences[i]){\\n                rankings[friend] = counter;\\n                counter--;\\n            }\\n            friendMap.put(i,rankings);\\n        }\\n        for(int[] i : pairs){\\n            pair.put(i[0],i[1]);\\n            pair.put(i[1],i[0]);\\n        }\\n        \\n\\n        //System.out.println(pair.toString());\\n        for(int alice : pair.keySet()){\\n            int bob = pair.get(alice);\\n            int aRateB = friendMap.get(alice)[bob];\\n            for(int eve = 0; eve<friendMap.get(alice).length; eve++){\\n                int aRateE = friendMap.get(alice)[eve];\\n                if(aRateE>aRateB){\\n                    int john = pair.get(eve);\\n                    int eRateJ = friendMap.get(eve)[john];\\n                    int eRateA = friendMap.get(eve)[alice];\\n                    if(eRateA>eRateJ){\\n                        numUnhappy+=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return numUnhappy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int numUnhappy = 0;\\n        HashMap<Integer,int[]> friendMap = new HashMap<>();\\n        HashMap<Integer,Integer> pair = new HashMap<>();\\n        for(int i = 0; i<preferences.length; i++){\\n            int[] rankings = new int[n];\\n            int counter = n;\\n            for(int friend : preferences[i]){\\n                rankings[friend] = counter;\\n                counter--;\\n            }\\n            friendMap.put(i,rankings);\\n        }\\n        for(int[] i : pairs){\\n            pair.put(i[0],i[1]);\\n            pair.put(i[1],i[0]);\\n        }\\n        \\n\\n        //System.out.println(pair.toString());\\n        for(int alice : pair.keySet()){\\n            int bob = pair.get(alice);\\n            int aRateB = friendMap.get(alice)[bob];\\n            for(int eve = 0; eve<friendMap.get(alice).length; eve++){\\n                int aRateE = friendMap.get(alice)[eve];\\n                if(aRateE>aRateB){\\n                    int john = pair.get(eve);\\n                    int eRateJ = friendMap.get(eve)[john];\\n                    int eRateA = friendMap.get(eve)[alice];\\n                    if(eRateA>eRateJ){\\n                        numUnhappy+=1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return numUnhappy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2747479,
                "title": "clean-code-python-o-n-2",
                "content": "\\n```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], prs: List[List[int]]) -> int:\\n        \\n        \\n        result = 0\\n        \\n        preferences = defaultdict(list)\\n        pairs = defaultdict(int)\\n        \\n        for index,value in enumerate(pref):\\n            preferences[index] = value\\n            \\n        for a,b in prs:\\n            pairs[a] = b\\n            pairs[b] = a\\n        \\n        for key,value in preferences.items():\\n            \\n            for char in value:\\n                if pairs[key] == char:\\n                    break\\n                    \\n                indexOfKey = preferences[char].index(key)\\n                indexOfPair = preferences[char].index(pairs[char])\\n                \\n                if indexOfPair > indexOfKey:\\n                    result += 1\\n                    break\\n                    \\n        return result\\n```\\nThe above solution is O(N^3),  to replace the O(N) extra time and make it O(N^2) we can just build a hasmap to get the index. (Since it\\'s the .index() functions thats causing the O(N) extra time)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, pref: List[List[int]], prs: List[List[int]]) -> int:\\n        \\n        \\n        result = 0\\n        \\n        preferences = defaultdict(list)\\n        pairs = defaultdict(int)\\n        \\n        for index,value in enumerate(pref):\\n            preferences[index] = value\\n            \\n        for a,b in prs:\\n            pairs[a] = b\\n            pairs[b] = a\\n        \\n        for key,value in preferences.items():\\n            \\n            for char in value:\\n                if pairs[key] == char:\\n                    break\\n                    \\n                indexOfKey = preferences[char].index(key)\\n                indexOfPair = preferences[char].index(pairs[char])\\n                \\n                if indexOfPair > indexOfKey:\\n                    result += 1\\n                    break\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703808,
                "title": "python-solution",
                "content": "```\\ndef unhappyFriends(self, n: int, pres: List[List[int]], pairs: List[List[int]]) -> int:\\n\\tscore, ans = {}, 0\\n\\tfor u,v in pairs:\\n\\t\\ti = pres[u].index(v)\\n\\t\\tscore[u] = set(pres[u][:i])\\n\\t\\ti = pres[v].index(u)\\n\\t\\tscore[v] = set(pres[v][:i])\\n\\tfor u in score:\\n\\t\\tans += any(u in score[v] for v in score[u])\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef unhappyFriends(self, n: int, pres: List[List[int]], pairs: List[List[int]]) -> int:\\n\\tscore, ans = {}, 0\\n\\tfor u,v in pairs:\\n\\t\\ti = pres[u].index(v)\\n\\t\\tscore[u] = set(pres[u][:i])\\n\\t\\ti = pres[v].index(u)\\n\\t\\tscore[v] = set(pres[v][:i])\\n\\tfor u in score:\\n\\t\\tans += any(u in score[v] for v in score[u])\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2697873,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn unhappy_friends(n: i32, preferences: Vec<Vec<i32>>, pairs: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;    \\n        let mut memo = vec![0;n];\\n        for arr in &pairs {\\n            let a = arr[0] as usize;\\n            let b = arr[1] as usize;\\n            memo[a] = b;\\n            memo[b] = a;\\n        }\\n\\n        let mut result = 0;\\n        for arr in pairs {\\n            let a = arr[0] as usize;\\n            let b = arr[1] as usize;\\n            \\n            let mut flag = false;\\n            for &u in &preferences[a] {\\n                let u = u as usize;\\n                if u == b { break }\\n\\n                let v = memo[u];\\n                for &candidate in &preferences[u] {\\n                    let candidate = candidate as usize;\\n                    if candidate == a {\\n                        flag = true;\\n                        break\\n                    } else if candidate == v {\\n                        break\\n                    }\\n                }\\n\\n                if flag {\\n                    result += 1;\\n                    break\\n                }\\n            }\\n\\n            let mut flag = false;\\n            for &u in &preferences[b] {\\n                let u = u as usize;\\n                if u == a { break }\\n\\n                let v = memo[u];\\n                for &candidate in &preferences[u] {\\n                    let candidate = candidate as usize;\\n                    if candidate == b {\\n                        flag = true;\\n                        break\\n                    } else if candidate == v {\\n                        break\\n                    }\\n                }\\n\\n                if flag {\\n                    result += 1;\\n                    break\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn unhappy_friends(n: i32, preferences: Vec<Vec<i32>>, pairs: Vec<Vec<i32>>) -> i32 {\\n        let n = n as usize;    \\n        let mut memo = vec![0;n];\\n        for arr in &pairs {\\n            let a = arr[0] as usize;\\n            let b = arr[1] as usize;\\n            memo[a] = b;\\n            memo[b] = a;\\n        }\\n\\n        let mut result = 0;\\n        for arr in pairs {\\n            let a = arr[0] as usize;\\n            let b = arr[1] as usize;\\n            \\n            let mut flag = false;\\n            for &u in &preferences[a] {\\n                let u = u as usize;\\n                if u == b { break }\\n\\n                let v = memo[u];\\n                for &candidate in &preferences[u] {\\n                    let candidate = candidate as usize;\\n                    if candidate == a {\\n                        flag = true;\\n                        break\\n                    } else if candidate == v {\\n                        break\\n                    }\\n                }\\n\\n                if flag {\\n                    result += 1;\\n                    break\\n                }\\n            }\\n\\n            let mut flag = false;\\n            for &u in &preferences[b] {\\n                let u = u as usize;\\n                if u == a { break }\\n\\n                let v = memo[u];\\n                for &candidate in &preferences[u] {\\n                    let candidate = candidate as usize;\\n                    if candidate == b {\\n                        flag = true;\\n                        break\\n                    } else if candidate == v {\\n                        break\\n                    }\\n                }\\n\\n                if flag {\\n                    result += 1;\\n                    break\\n                }\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2687726,
                "title": "python-easy-explanantion",
                "content": "Reference to `@rahulanandydav2000` with more explanation.\\n```\\n\"\"\"\\nfriend have a preferece:\\n0 : 1,2,3\\n1 : 3,2,0\\n2 : 3,1,0\\n3 : 1,2,0\\n\\npairs = [[0, 1], [2, 3]]\\n0 is happy, because 1 is the first preferece\\n1 is unhappy, because 3 is its prior preference, and 3 is also unhappy because 1 is its preferece\\n\\nAlgorithm:\\n    -> for each, we should check wehther they have a prior preference than the current pair\\n    -> if yes, then what they are? \\n        use a dictionary:\\n        {\\n            0: []\\n            1: [3]\\n            2: []\\n            3: [1]\\n        }\\n    -> then we start the iteration, for each key, if the key appear in the dict[value],\\n        which suggest, the key and the value all have an another prefered choice, then we should\\n        add the result by 1\\n    -> retutn res\\n\"\"\"\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # check whether there is a prior preference\\n        prior_preference = {}\\n        for p1, p2 in pairs:\\n            prior_preference[p1] = preferences[p1][:preferences[p1].index(p2)]\\n            prior_preference[p2] = preferences[p2][:preferences[p2].index(p1)]\\n        # start the iteration:\\n        res = 0\\n        for p1 in prior_preference:\\n            for p2 in prior_preference[p1]:\\n                if p1 in prior_preference[p2]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nfriend have a preferece:\\n0 : 1,2,3\\n1 : 3,2,0\\n2 : 3,1,0\\n3 : 1,2,0\\n\\npairs = [[0, 1], [2, 3]]\\n0 is happy, because 1 is the first preferece\\n1 is unhappy, because 3 is its prior preference, and 3 is also unhappy because 1 is its preferece\\n\\nAlgorithm:\\n    -> for each, we should check wehther they have a prior preference than the current pair\\n    -> if yes, then what they are? \\n        use a dictionary:\\n        {\\n            0: []\\n            1: [3]\\n            2: []\\n            3: [1]\\n        }\\n    -> then we start the iteration, for each key, if the key appear in the dict[value],\\n        which suggest, the key and the value all have an another prefered choice, then we should\\n        add the result by 1\\n    -> retutn res\\n\"\"\"\\n\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        # check whether there is a prior preference\\n        prior_preference = {}\\n        for p1, p2 in pairs:\\n            prior_preference[p1] = preferences[p1][:preferences[p1].index(p2)]\\n            prior_preference[p2] = preferences[p2][:preferences[p2].index(p1)]\\n        # start the iteration:\\n        res = 0\\n        for p1 in prior_preference:\\n            for p2 in prior_preference[p1]:\\n                if p1 in prior_preference[p2]:\\n                    res += 1\\n                    break\\n        return res\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625036,
                "title": "",
                "content": "x prefers u over y, and\\nu prefers x over v.\\n\\n\\u5927\\u610F\\u5C31\\u662F\\uFF1A\\nx \\u6CA1 pair \\u5230\\u4ED6\\u4F18\\u5148\\u60F3 pair \\u7684 (x \\u5374 pair \\u5230\\u4E86\\u4E0D\\u4F18\\u5148\\u7684)\\nx \\u4F18\\u5148\\u60F3 pair \\u7684\\u4E5F pair\\u4E86\\u6BD4 x \\u5DEE\\u7684\\n\\nx \\u5F88\\u96BE\\u53D7\\uFF0C\\u56E0\\u4E3A x \\u7231\\u7684 u \\u6CA1\\u548C\\u4ED6 pair\\nu \\u4E5F\\u5F88\\u96BE\\u53D7\\uFF0C\\u56E0\\u4E3A u \\u60F3\\u548C x pair\\uFF0C\\u4F46\\u5374\\u548C v pair\\u4E86\\n\\n\\u6240\\u4EE5 x \\u4E0D\\u9AD8\\u5174\\n```\\nif orders[x][u] < orders[x][y] && orders[u][x] < orders[u][v]\\nthen x is unhappy\\norders[i][j] \\u4EE3\\u8868i\\u5BF9j\\u7684prefer\\u7A0B\\u5EA6\\uFF08\\u8D8A\\u5C0F\\u8D8Aprefer\\uFF09\\n```\\n",
                "solutionTags": [],
                "code": "```\\nif orders[x][u] < orders[x][y] && orders[u][x] < orders[u][v]\\nthen x is unhappy\\norders[i][j] \\u4EE3\\u8868i\\u5BF9j\\u7684prefer\\u7A0B\\u5EA6\\uFF08\\u8D8A\\u5C0F\\u8D8Aprefer\\uFF09\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580540,
                "title": "why-so-many-dislikes-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p, vector<vector<int>>& pairs) {\\n        \\n        vector<vector<int>> rev(n,vector<int>(n,-1));\\n        \\n        for(int i=0;i<p.size();i++)\\n        {\\n            for(int j=0;j<p[i].size();j++)\\n            {\\n                rev[i][p[i][j]]=j;\\n            }\\n        }\\n        \\n        unordered_set<int> unhappy;\\n        \\n        int res=0;\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            \\n            for(int j=0;j<pairs.size();j++)\\n            {\\n                if(i==j)\\n                    continue;\\n            \\n                int u=pairs[j][0];\\n                int v=pairs[j][1];\\n                \\n                //Assume x is unhappy \\n                    \\n                if(rev[x][u]<rev[x][y] && rev[u][x] < rev[u][v]  || rev[x][v]<rev[x][y] && rev[v][x]<rev[v][u])\\n                   unhappy.insert(x);\\n                \\n                 if(rev[y][u]<rev[y][x] && rev[u][y] < rev[u][v]  || rev[y][v]<rev[y][x] && rev[v][y]<rev[v][u])\\n                   unhappy.insert(y);\\n                    \\n                \\n            }\\n        }\\n        \\n        return unhappy.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& p, vector<vector<int>>& pairs) {\\n        \\n        vector<vector<int>> rev(n,vector<int>(n,-1));\\n        \\n        for(int i=0;i<p.size();i++)\\n        {\\n            for(int j=0;j<p[i].size();j++)\\n            {\\n                rev[i][p[i][j]]=j;\\n            }\\n        }\\n        \\n        unordered_set<int> unhappy;\\n        \\n        int res=0;\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            \\n            for(int j=0;j<pairs.size();j++)\\n            {\\n                if(i==j)\\n                    continue;\\n            \\n                int u=pairs[j][0];\\n                int v=pairs[j][1];\\n                \\n                //Assume x is unhappy \\n                    \\n                if(rev[x][u]<rev[x][y] && rev[u][x] < rev[u][v]  || rev[x][v]<rev[x][y] && rev[v][x]<rev[v][u])\\n                   unhappy.insert(x);\\n                \\n                 if(rev[y][u]<rev[y][x] && rev[u][y] < rev[u][v]  || rev[y][v]<rev[y][x] && rev[v][y]<rev[v][u])\\n                   unhappy.insert(y);\\n                    \\n                \\n            }\\n        }\\n        \\n        return unhappy.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562780,
                "title": "java-solution-faster-than-97-with-less-memory-usage",
                "content": "\\n```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        int[] pairArr = new int[n];\\n        int[] prefPriority = new int[n];\\n        // make candidate and its pair\\n        for (int[] pair : pairs){\\n            pairArr[pair[0]] = pair[1];\\n            pairArr[pair[1]] = pair[0];\\n        }\\n        \\n        for (int currCandidate = 0; currCandidate < n; currCandidate++){\\n            int[] candidatePref = preferences[currCandidate];\\n            prefPriority[currCandidate] = findPriority(candidatePref, pairArr[currCandidate]);\\n        }\\n        \\n        for (int i = 0; i < n; i++){\\n            if (prefPriority[i] > 0 && candidateIsUnhappy(preferences, i, prefPriority[i], prefPriority)){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    public int findPriority (int[] candidatePref, int candidate){\\n\\n        for (int i = 0; i < candidatePref.length - 1; i++){\\n            if (candidatePref[i] == candidate){\\n                return i;\\n            }\\n        }\\n        return candidatePref.length - 1;\\n    }\\n    // those who enter this check are potentially unhappy\\n    public boolean candidateIsUnhappy(int[][] preferences, int candidate, int priority, int[] prefPriority){\\n        int[] candidatePref = preferences[candidate];\\n        for (int i = 0; i < priority; i++){\\n            int checkCandidate = candidatePref[i];\\n            // if checkCandidate is matched with less preferred candidate, means both candidates are unhappy, return true\\n            if (findPriority(preferences[checkCandidate], candidate) < prefPriority[checkCandidate]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int count = 0;\\n        int[] pairArr = new int[n];\\n        int[] prefPriority = new int[n];\\n        // make candidate and its pair\\n        for (int[] pair : pairs){\\n            pairArr[pair[0]] = pair[1];\\n            pairArr[pair[1]] = pair[0];\\n        }\\n        \\n        for (int currCandidate = 0; currCandidate < n; currCandidate++){\\n            int[] candidatePref = preferences[currCandidate];\\n            prefPriority[currCandidate] = findPriority(candidatePref, pairArr[currCandidate]);\\n        }\\n        \\n        for (int i = 0; i < n; i++){\\n            if (prefPriority[i] > 0 && candidateIsUnhappy(preferences, i, prefPriority[i], prefPriority)){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    public int findPriority (int[] candidatePref, int candidate){\\n\\n        for (int i = 0; i < candidatePref.length - 1; i++){\\n            if (candidatePref[i] == candidate){\\n                return i;\\n            }\\n        }\\n        return candidatePref.length - 1;\\n    }\\n    // those who enter this check are potentially unhappy\\n    public boolean candidateIsUnhappy(int[][] preferences, int candidate, int priority, int[] prefPriority){\\n        int[] candidatePref = preferences[candidate];\\n        for (int i = 0; i < priority; i++){\\n            int checkCandidate = candidatePref[i];\\n            // if checkCandidate is matched with less preferred candidate, means both candidates are unhappy, return true\\n            if (findPriority(preferences[checkCandidate], candidate) < prefPriority[checkCandidate]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560529,
                "title": "java-solution-faster-than-70",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        HashMap<Integer, Integer> pairing = new HashMap<>();\\n        int[][] rank = new int[n][n];\\n        for (int[] pair: pairs){\\n            pairing.put(pair[0], pair[1]);\\n            pairing.put(pair[1], pair[0]);\\n        }\\n        \\n        for (int i=0; i<preferences.length; ++i){\\n            int[] friends = preferences[i];\\n            \\n            for (int j=0; j<friends.length; ++j){\\n                int friend = friends[j];\\n                if (i == friend){\\n                    rank[i][friend] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n                \\n                rank[i][friend] = j;\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for (int key: pairing.keySet()){\\n            int currentRank = rank[key][pairing.get(key)];\\n            if (currentRank == 0) continue;\\n            int[] friends = preferences[key];\\n            \\n            for (int friend:friends){\\n                if (pairing.get(key) == friend) break;\\n                \\n                if (!pairing.containsKey(friend)) continue;\\n                \\n                int aff1 = rank[friend][key];\\n                int aff2 = rank[friend][pairing.get(friend)];\\n                \\n                if (aff1 < aff2){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        HashMap<Integer, Integer> pairing = new HashMap<>();\\n        int[][] rank = new int[n][n];\\n        for (int[] pair: pairs){\\n            pairing.put(pair[0], pair[1]);\\n            pairing.put(pair[1], pair[0]);\\n        }\\n        \\n        for (int i=0; i<preferences.length; ++i){\\n            int[] friends = preferences[i];\\n            \\n            for (int j=0; j<friends.length; ++j){\\n                int friend = friends[j];\\n                if (i == friend){\\n                    rank[i][friend] = Integer.MAX_VALUE;\\n                    continue;\\n                }\\n                \\n                rank[i][friend] = j;\\n            }\\n        }\\n        \\n        int cnt = 0;\\n        for (int key: pairing.keySet()){\\n            int currentRank = rank[key][pairing.get(key)];\\n            if (currentRank == 0) continue;\\n            int[] friends = preferences[key];\\n            \\n            for (int friend:friends){\\n                if (pairing.get(key) == friend) break;\\n                \\n                if (!pairing.containsKey(friend)) continue;\\n                \\n                int aff1 = rank[friend][key];\\n                int aff2 = rank[friend][pairing.get(friend)];\\n                \\n                if (aff1 < aff2){\\n                    cnt++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554651,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        for a, b in pairs:\\n            i, j = preferences[a].index(b), preferences[b].index(a)\\n            preferences[a], preferences[b] = set(preferences[a][:i]), set(preferences[b][:j])\\n        res = 0\\n        for i, p in enumerate(preferences):\\n            if any(i in preferences[j] for j in p):\\n                res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        for a, b in pairs:\\n            i, j = preferences[a].index(b), preferences[b].index(a)\\n            preferences[a], preferences[b] = set(preferences[a][:i]), set(preferences[b][:j])\\n        res = 0\\n        for i, p in enumerate(preferences):\\n            if any(i in preferences[j] for j in p):\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2527657,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    const matrix = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = new Array(n);\\n        matrix[i][i] = null;\\n        preferences[i].map((y, rank) => matrix[i][y] = rank);\\n        \\n    }\\n    \\n    let pairData = {};\\n    for (const [x,y] of pairs) {\\n        pairData[x] = y;\\n        pairData[y] = x;\\n    }\\n    \\n    const unhappy = new Set();\\n    \\n    \\n    for (let x = 0; x < n; x++) {\\n        if (unhappy.has(x)) {\\n            continue;\\n        }\\n        const y = pairData[x];\\n        \\n        for (const u of preferences[x]) {\\n            if (u === y) {\\n                break;\\n            }\\n            \\n            // x prefers u over y\\n            \\n            let uPreferX = false;\\n            for (const v of preferences[u]) {\\n                if (v === pairData[u]) {\\n                    break;\\n                }\\n                if (v === x) {\\n                    // u prefers x over v\\n                    unhappy.add(x);\\n                    unhappy.add(u);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return unhappy.size;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    const matrix = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        matrix[i] = new Array(n);\\n        matrix[i][i] = null;\\n        preferences[i].map((y, rank) => matrix[i][y] = rank);\\n        \\n    }\\n    \\n    let pairData = {};\\n    for (const [x,y] of pairs) {\\n        pairData[x] = y;\\n        pairData[y] = x;\\n    }\\n    \\n    const unhappy = new Set();\\n    \\n    \\n    for (let x = 0; x < n; x++) {\\n        if (unhappy.has(x)) {\\n            continue;\\n        }\\n        const y = pairData[x];\\n        \\n        for (const u of preferences[x]) {\\n            if (u === y) {\\n                break;\\n            }\\n            \\n            // x prefers u over y\\n            \\n            let uPreferX = false;\\n            for (const v of preferences[u]) {\\n                if (v === pairData[u]) {\\n                    break;\\n                }\\n                if (v === x) {\\n                    // u prefers x over v\\n                    unhappy.add(x);\\n                    unhappy.add(u);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return unhappy.size;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2519329,
                "title": "well-written-codes-can-run-faster-c-50-70ms",
                "content": "```\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> v(n);\\n        for(vector<int> &p : pairs){\\n            v[p[0]] = p[1];\\n            v[p[1]] = p[0];\\n        }\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int x = 0;\\n            for(int j : preferences[i]){\\n                if(j == v[i]) break;\\n                for(int k : preferences[j]){\\n                    if(k == i){\\n                        x++;\\n                        break;\\n                    }\\n                    if(k == v[j]) break;\\n                }\\n                if(x) break;\\n            }\\n            res += x;\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        vector<int> v(n);\\n        for(vector<int> &p : pairs){\\n            v[p[0]] = p[1];\\n            v[p[1]] = p[0];\\n        }\\n        int res = 0;\\n        for(int i = 0; i < n; i++){\\n            int x = 0;\\n            for(int j : preferences[i]){\\n                if(j == v[i]) break;\\n                for(int k : preferences[j]){\\n                    if(k == i){\\n                        x++;\\n                        break;\\n                    }\\n                    if(k == v[j]) break;\\n                }\\n                if(x) break;\\n            }\\n            res += x;\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481647,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        int count=0;\\n        for(int i=0;i<pairs.length;i++)\\n        {\\n            h.put(pairs[i][0],pairs[i][1]);\\n            h.put(pairs[i][1],pairs[i][0]);\\n            \\n        }\\n        for(int i=0;i<pairs.length;i++)\\n        {\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            for(int j=0;j<preferences[x].length;j++)\\n            {\\n                if(preferences[x][j]==y)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int flag=0;\\n                    int u=preferences[x][j];\\n                    int v=h.get(u);\\n                    for(int k=0;k<preferences[u].length;k++)\\n                    {\\n                        if(preferences[u][k]==v)\\n                        {\\n                            break;\\n                        }\\n                        else if(preferences[u][k]==x)\\n                        {\\n                            flag=1;\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            /*****************************************************/\\n             x=pairs[i][1];\\n             y=pairs[i][0];\\n            for(int j=0;j<preferences[x].length;j++)\\n            {\\n                if(preferences[x][j]==y)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int flag=0;\\n                    int u=preferences[x][j];\\n                    int v=h.get(u);\\n                    for(int k=0;k<preferences[u].length;k++)\\n                    {\\n                        if(preferences[u][k]==v)\\n                        {\\n                            break;\\n                        }\\n                        else if(preferences[u][k]==x)\\n                        {\\n                            flag=1;\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        HashMap<Integer,Integer> h=new HashMap<Integer,Integer>();\\n        int count=0;\\n        for(int i=0;i<pairs.length;i++)\\n        {\\n            h.put(pairs[i][0],pairs[i][1]);\\n            h.put(pairs[i][1],pairs[i][0]);\\n            \\n        }\\n        for(int i=0;i<pairs.length;i++)\\n        {\\n            int x=pairs[i][0];\\n            int y=pairs[i][1];\\n            for(int j=0;j<preferences[x].length;j++)\\n            {\\n                if(preferences[x][j]==y)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int flag=0;\\n                    int u=preferences[x][j];\\n                    int v=h.get(u);\\n                    for(int k=0;k<preferences[u].length;k++)\\n                    {\\n                        if(preferences[u][k]==v)\\n                        {\\n                            break;\\n                        }\\n                        else if(preferences[u][k]==x)\\n                        {\\n                            flag=1;\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            /*****************************************************/\\n             x=pairs[i][1];\\n             y=pairs[i][0];\\n            for(int j=0;j<preferences[x].length;j++)\\n            {\\n                if(preferences[x][j]==y)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    int flag=0;\\n                    int u=preferences[x][j];\\n                    int v=h.get(u);\\n                    for(int k=0;k<preferences[u].length;k++)\\n                    {\\n                        if(preferences[u][k]==v)\\n                        {\\n                            break;\\n                        }\\n                        else if(preferences[u][k]==x)\\n                        {\\n                            flag=1;\\n                            count++;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458292,
                "title": "javascript-readable-and-efficient-solution-with-comment",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let pairedWith = {}\\n    let unhappy = 0\\n    // let\\'s use a map to quickly check for paired people\\n    for (let p of pairs) {\\n        pairedWith[p[0]] = p[1]\\n        pairedWith[p[1]] = p[0]\\n    }\\n    for (let person = 0; person < n; person++) {\\n        // a for loop to check every people\\n        for (let index = 0; index < preferences[person].indexOf(pairedWith[person]); index++) {\\n            // for Mike, we go through everyone that Mike prefers more\\n            let morePrefered = preferences[person][index]\\n             // check if Joey also prefer Mike more than her current pair\\n            if (preferences[morePrefered].indexOf(person) < preferences[morePrefered].indexOf(pairedWith[morePrefered])) {\\n                unhappy++\\n                // found one, break to avoid duplication\\n                break\\n            }\\n        }\\n    }\\n    return unhappy\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} preferences\\n * @param {number[][]} pairs\\n * @return {number}\\n */\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let pairedWith = {}\\n    let unhappy = 0\\n    // let\\'s use a map to quickly check for paired people\\n    for (let p of pairs) {\\n        pairedWith[p[0]] = p[1]\\n        pairedWith[p[1]] = p[0]\\n    }\\n    for (let person = 0; person < n; person++) {\\n        // a for loop to check every people\\n        for (let index = 0; index < preferences[person].indexOf(pairedWith[person]); index++) {\\n            // for Mike, we go through everyone that Mike prefers more\\n            let morePrefered = preferences[person][index]\\n             // check if Joey also prefer Mike more than her current pair\\n            if (preferences[morePrefered].indexOf(person) < preferences[morePrefered].indexOf(pairedWith[morePrefered])) {\\n                unhappy++\\n                // found one, break to avoid duplication\\n                break\\n            }\\n        }\\n    }\\n    return unhappy\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426529,
                "title": "python-easy-to-read-and-organized",
                "content": "```\\n def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        pairsDict = {}\\n        for f1, f2 in pairs:\\n            pairsDict[f1] = f2\\n            pairsDict[f2] = f1\\n        \\n        pref = [n*[0] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if j in preferences[i]:\\n                    pref[i][j] = preferences[i].index(j)\\n                else:\\n                    pref[i][j] = inf\\n\\n        count = 0\\n        for i in range(n):\\n            for j in range(n):\\n                x = i\\n                y = pairsDict[x]\\n                u = j \\n                v = pairsDict[u]\\n                if pref[x][u] < pref[x][y] and pref[u][x] < pref[u][v]:                    \\n                    count+=1\\n                    break\\n        \\n        return count\\n",
                "solutionTags": [],
                "code": "```\\n def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        pairsDict = {}\\n        for f1, f2 in pairs:\\n            pairsDict[f1] = f2\\n            pairsDict[f2] = f1\\n        \\n        pref = [n*[0] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if j in preferences[i]:\\n                    pref[i][j] = preferences[i].index(j)\\n                else:\\n                    pref[i][j] = inf\\n\\n        count = 0\\n        for i in range(n):\\n            for j in range(n):\\n                x = i\\n                y = pairsDict[x]\\n                u = j \\n                v = pairsDict[u]\\n                if pref[x][u] < pref[x][y] and pref[u][x] < pref[u][v]:                    \\n                    count+=1\\n                    break\\n        \\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2416879,
                "title": "java-time-o-n-2-space-o-n",
                "content": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[] lookup = toLookup(n, pairs);\\n        sortInPlace(n, preferences, lookup);\\n        return solve(n, preferences);        \\n    }\\n    \\n    private int solve(int n, int[][] preferences) {\\n        int[] counters = new int[n];\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; preferences[i][j] < Integer.MAX_VALUE; ++j) {\\n                int k = preferences[i][j]; // the other friend\\n                while (preferences[k][counters[k]] < i) {\\n                    ++counters[k];\\n                }\\n                if (preferences[k][counters[k]] == i) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void sortInPlace(int n, int[][] preferences, int[] lookup) {\\n        for (int i = 0; i < n; ++i) {\\n            boolean[] buckets = new boolean[n];\\n            for (int k = 0; preferences[i][k] != lookup[i]; ++k) {\\n                buckets[preferences[i][k]] = true;\\n            }\\n            int j = 0;\\n            for (int k = 0;  k < n; ++k) {\\n                if (buckets[k]) {\\n                    preferences[i][j++] = k;\\n                }\\n            }\\n            preferences[i][j] = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    private int[] toLookup(int n, int[][] pairs) {\\n        int[] lookup = new int[n];\\n        for (int i = 0; i < pairs.length; ++i) {\\n            lookup[pairs[i][0]] = pairs[i][1];\\n            lookup[pairs[i][1]] = pairs[i][0];\\n        }\\n        return lookup;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[] lookup = toLookup(n, pairs);\\n        sortInPlace(n, preferences, lookup);\\n        return solve(n, preferences);        \\n    }\\n    \\n    private int solve(int n, int[][] preferences) {\\n        int[] counters = new int[n];\\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; preferences[i][j] < Integer.MAX_VALUE; ++j) {\\n                int k = preferences[i][j]; // the other friend\\n                while (preferences[k][counters[k]] < i) {\\n                    ++counters[k];\\n                }\\n                if (preferences[k][counters[k]] == i) {\\n                    ++ans;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void sortInPlace(int n, int[][] preferences, int[] lookup) {\\n        for (int i = 0; i < n; ++i) {\\n            boolean[] buckets = new boolean[n];\\n            for (int k = 0; preferences[i][k] != lookup[i]; ++k) {\\n                buckets[preferences[i][k]] = true;\\n            }\\n            int j = 0;\\n            for (int k = 0;  k < n; ++k) {\\n                if (buckets[k]) {\\n                    preferences[i][j++] = k;\\n                }\\n            }\\n            preferences[i][j] = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    private int[] toLookup(int n, int[][] pairs) {\\n        int[] lookup = new int[n];\\n        for (int i = 0; i < pairs.length; ++i) {\\n            lookup[pairs[i][0]] = pairs[i][1];\\n            lookup[pairs[i][1]] = pairs[i][0];\\n        }\\n        return lookup;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337741,
                "title": "python-3-o-n-2-brute-force-intuitive",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        hashmap = {}\\n        for i in range(len(preferences)):\\n            hashmap[i] = {}\\n            for j in range(len(preferences[i])):\\n                hashmap[i][preferences[i][j]]= j\\n        \\n        print(hashmap)\\n        unhappy = set()\\n        for i in range(len(pairs)):\\n            x = pairs[i][0]\\n            y = pairs[i][1]\\n            for j in range(i+1,len(pairs)):\\n               \\n                a = pairs[j][0] \\n                b= pairs[j][1]\\n                if (hashmap[x][y]>hashmap[x][a] and hashmap[a][b]>hashmap[a][x]):\\n                    unhappy.add(x)\\n                    unhappy.add(a)\\n                if (hashmap[x][y]>hashmap[x][b] and hashmap[b][a]>hashmap[b][x]):\\n                    unhappy.add(x)\\n                    unhappy.add(b)\\n                \\n                if (hashmap[y][x]>hashmap[y][a] and hashmap[a][b]>hashmap[a][y]):\\n                    unhappy.add(y)\\n                    unhappy.add(a)\\n                \\n                if (hashmap[y][x]>hashmap[y][b] and hashmap[b][a] > hashmap[b][y]):\\n                    unhappy.add(y)\\n                    unhappy.add(b)\\n        return len(unhappy)             \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        hashmap = {}\\n        for i in range(len(preferences)):\\n            hashmap[i] = {}\\n            for j in range(len(preferences[i])):\\n                hashmap[i][preferences[i][j]]= j\\n        \\n        print(hashmap)\\n        unhappy = set()\\n        for i in range(len(pairs)):\\n            x = pairs[i][0]\\n            y = pairs[i][1]\\n            for j in range(i+1,len(pairs)):\\n               \\n                a = pairs[j][0] \\n                b= pairs[j][1]\\n                if (hashmap[x][y]>hashmap[x][a] and hashmap[a][b]>hashmap[a][x]):\\n                    unhappy.add(x)\\n                    unhappy.add(a)\\n                if (hashmap[x][y]>hashmap[x][b] and hashmap[b][a]>hashmap[b][x]):\\n                    unhappy.add(x)\\n                    unhappy.add(b)\\n                \\n                if (hashmap[y][x]>hashmap[y][a] and hashmap[a][b]>hashmap[a][y]):\\n                    unhappy.add(y)\\n                    unhappy.add(a)\\n                \\n                if (hashmap[y][x]>hashmap[y][b] and hashmap[b][a] > hashmap[b][y]):\\n                    unhappy.add(y)\\n                    unhappy.add(b)\\n        return len(unhappy)             \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253782,
                "title": "c-brute-force",
                "content": "* Run time is pretty high as it is pure Brute Force But it is accepted by leetcode.\\n\\n![image](https://assets.leetcode.com/users/images/0e0b6fd7-59eb-4fcf-af11-296d738f3d7d_1657264714.2963495.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool check(int x , int y , int u , int v ,int n , vector<vector<int>>& pref){\\n        int id_x = 0 , id_y = 0 , id_u = 0  , id_v = 0 ;\\n        //check indices of (y and u) in pref[x] ;\\n        for(int i = 0 ; i < n - 1; ++i ){\\n            if(pref[x][i] == y) id_y = i ;\\n            if(pref[x][i] == u) id_u = i ;\\n        }\\n        \\n        //check indices of (v and x) in pref[u] ;\\n        for(int i = 0 ; i < n - 1 ; ++i ){\\n            if(pref[u][i] == v) id_v = i ;\\n            if(pref[u][i] == x) id_x = i ;\\n        }\\n        \\n        return (id_x < id_v and id_u < id_y) ;\\n    }\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_set<int> unhappy ;\\n        for(int i = 0 ; i < pairs.size() ; ++i ){\\n            for(int j = i + 1; j < pairs.size() ; ++j){\\n                int x = pairs[i][0] , y = pairs[i][1] , u = pairs[j][0] , v = pairs[j][1] ;\\n                // x prefers u over y and u preferes x over v \\n                if(check(x,y,u,v,n,preferences)) unhappy.insert(x), unhappy.insert(u) ;\\n                // x prefers v over y and v prefers x over u \\n                if(check(x,y,v,u,n,preferences)) unhappy.insert(x) , unhappy.insert(v) ;\\n                // y prefers u over x and u prefers y over v\\n                if(check(y,x,u,v,n,preferences)) unhappy.insert(y) , unhappy.insert(u) ;\\n                // y prefers v over x and v prefers y over u \\n                if(check(y,x,v,u,n,preferences)) unhappy.insert(y) , unhappy.insert(v) ;\\n            }\\n        }\\n        return unhappy.size() ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x , int y , int u , int v ,int n , vector<vector<int>>& pref){\\n        int id_x = 0 , id_y = 0 , id_u = 0  , id_v = 0 ;\\n        //check indices of (y and u) in pref[x] ;\\n        for(int i = 0 ; i < n - 1; ++i ){\\n            if(pref[x][i] == y) id_y = i ;\\n            if(pref[x][i] == u) id_u = i ;\\n        }\\n        \\n        //check indices of (v and x) in pref[u] ;\\n        for(int i = 0 ; i < n - 1 ; ++i ){\\n            if(pref[u][i] == v) id_v = i ;\\n            if(pref[u][i] == x) id_x = i ;\\n        }\\n        \\n        return (id_x < id_v and id_u < id_y) ;\\n    }\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        unordered_set<int> unhappy ;\\n        for(int i = 0 ; i < pairs.size() ; ++i ){\\n            for(int j = i + 1; j < pairs.size() ; ++j){\\n                int x = pairs[i][0] , y = pairs[i][1] , u = pairs[j][0] , v = pairs[j][1] ;\\n                // x prefers u over y and u preferes x over v \\n                if(check(x,y,u,v,n,preferences)) unhappy.insert(x), unhappy.insert(u) ;\\n                // x prefers v over y and v prefers x over u \\n                if(check(x,y,v,u,n,preferences)) unhappy.insert(x) , unhappy.insert(v) ;\\n                // y prefers u over x and u prefers y over v\\n                if(check(y,x,u,v,n,preferences)) unhappy.insert(y) , unhappy.insert(u) ;\\n                // y prefers v over x and v prefers y over u \\n                if(check(y,x,v,u,n,preferences)) unhappy.insert(y) , unhappy.insert(v) ;\\n            }\\n        }\\n        return unhappy.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002608,
                "title": "javascript-hashmap-mock-graph-211ms",
                "content": "problems not hard, the tricky thing is to make sure what is x, y, u, v, and the relationship between these, and use index compare to check over\\n```\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\nconst packUG_Set = (g, edges) => { for (const [u, v] of edges) { g[u].add(v); g[v].add(u); } };\\nconst counter_ui = (a_or_s) => { let m = new Map(); for (let i = 0; i < a_or_s.length; i++) m.set(a_or_s[i], i); return m; }\\n\\nconst unhappyFriends = (n, preferences, pairs) => {\\n    // happy array to record the state of each node[0, n - 1], pair graph used to find u and v paired\\n    let happy = Array(n).fill(true), pairG = initializeGraphSet(n);\\n    packUG_Set(pairG, pairs);\\n    preferences = preferences.map(a => counter_ui(a)) // convert each preference from array to {node: index} for easier checking over, just index smaller\\n    for (const [x, y] of pairs) {\\n        checkUnhappy(happy, preferences, pairG, x, y); // check if x is unhappy\\n        checkUnhappy(happy, preferences, pairG, y, x); // check if y is unhappy\\n    }\\n    return happy.filter(h => !h).length; // get unhappy count\\n};\\n\\nconst checkUnhappy = (happy, preferences, pairG, x, y) => {\\n    let mx = preferences[x];\\n    for (const [u, iu] of mx) {\\n        if (mx.has(y)) { // x has u and y\\n            if (iu < mx.get(y)) { // u over y\\n                let mu = preferences[u];\\n                if (mu.has(x)) {\\n                    for (const v of pairG[u]) { // u pair with v\\n                        if (mu.has(v) && mu.get(x) < mu.get(v)) { // u has x and v, x over v\\n                            happy[x] = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nconst initializeGraphSet = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push(new Set()); } return g; };\\nconst packUG_Set = (g, edges) => { for (const [u, v] of edges) { g[u].add(v); g[v].add(u); } };\\nconst counter_ui = (a_or_s) => { let m = new Map(); for (let i = 0; i < a_or_s.length; i++) m.set(a_or_s[i], i); return m; }\\n\\nconst unhappyFriends = (n, preferences, pairs) => {\\n    // happy array to record the state of each node[0, n - 1], pair graph used to find u and v paired\\n    let happy = Array(n).fill(true), pairG = initializeGraphSet(n);\\n    packUG_Set(pairG, pairs);\\n    preferences = preferences.map(a => counter_ui(a)) // convert each preference from array to {node: index} for easier checking over, just index smaller\\n    for (const [x, y] of pairs) {\\n        checkUnhappy(happy, preferences, pairG, x, y); // check if x is unhappy\\n        checkUnhappy(happy, preferences, pairG, y, x); // check if y is unhappy\\n    }\\n    return happy.filter(h => !h).length; // get unhappy count\\n};\\n\\nconst checkUnhappy = (happy, preferences, pairG, x, y) => {\\n    let mx = preferences[x];\\n    for (const [u, iu] of mx) {\\n        if (mx.has(y)) { // x has u and y\\n            if (iu < mx.get(y)) { // u over y\\n                let mu = preferences[u];\\n                if (mu.has(x)) {\\n                    for (const v of pairG[u]) { // u pair with v\\n                        if (mu.has(v) && mu.get(x) < mu.get(v)) { // u has x and v, x over v\\n                            happy[x] = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929789,
                "title": "easy-and-readable-javascript",
                "content": "pseudocode:\\n```\\nfor each x (0..n):\\n\\tget their preferences (xPrefs) before the one they are assigned to (assigned[x])\\n\\tfor each xPref:\\n\\t\\tget their preferences (uPrefs) before the one they are assigned to (assigned[u])\\n\\t\\t\\tif x does not exist in this list:\\n\\t\\t\\t\\tcount += 1 (x is unhappy)\\n```\\n\\t\\njavascript:\\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let assigned = {}\\n    let count = 0\\n    \\n    for(let pair of pairs){\\n        let [x, y] = pair\\n        assigned[x] = y\\n        assigned[y] = x\\n    }\\n    \\n    for(let x=0; x<n; x++){\\n        let xLimit = preferences[x].indexOf(assigned[x.toString()])\\n        let xPrefs = preferences[x].slice(0, xLimit)\\n        \\n        for(let u of xPrefs){\\n            let uLimit = preferences[u].indexOf(assigned[u.toString()])\\n            let uPrefs = preferences[u].slice(0, uLimit)\\n            \\n            if(uPrefs.includes(x)){\\n                count += 1\\n                break\\n            }\\n        }\\n    }\\n    \\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor each x (0..n):\\n\\tget their preferences (xPrefs) before the one they are assigned to (assigned[x])\\n\\tfor each xPref:\\n\\t\\tget their preferences (uPrefs) before the one they are assigned to (assigned[u])\\n\\t\\t\\tif x does not exist in this list:\\n\\t\\t\\t\\tcount += 1 (x is unhappy)\\n```\n```\\nvar unhappyFriends = function(n, preferences, pairs) {\\n    let assigned = {}\\n    let count = 0\\n    \\n    for(let pair of pairs){\\n        let [x, y] = pair\\n        assigned[x] = y\\n        assigned[y] = x\\n    }\\n    \\n    for(let x=0; x<n; x++){\\n        let xLimit = preferences[x].indexOf(assigned[x.toString()])\\n        let xPrefs = preferences[x].slice(0, xLimit)\\n        \\n        for(let u of xPrefs){\\n            let uLimit = preferences[u].indexOf(assigned[u.toString()])\\n            let uPrefs = preferences[u].slice(0, uLimit)\\n            \\n            if(uPrefs.includes(x)){\\n                count += 1\\n                break\\n            }\\n        }\\n    }\\n    \\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916026,
                "title": "c-fast-and-memory-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pre, vector<vector<int>>& pairs) {\\n        vector<vector<int>> v(n,vector<int>(n));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                v[i][pre[i][j]] = n-1-j;\\n            }\\n        }\\n        int ans = 0;\\n        vector<int> mp(n);\\n        for(auto p:pairs){\\n            mp[p[0]] = p[1];\\n            mp[p[1]] = p[0];\\n        }\\n        for(auto p:pairs){\\n            int x = p[0], y = p[1];\\n            int z = v[x][y];\\n            for(int i=0;i<n;i++) {\\n                if(v[x][i]>z){\\n                    int pp = mp[i];\\n                    if(v[i][x]>v[i][pp]) {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n            z = v[y][x];\\n            for(int i=0;i<n;i++) {\\n                if(v[y][i]>z){\\n                    int pp = mp[i];\\n                    if(v[i][y]>v[i][pp]) {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pre, vector<vector<int>>& pairs) {\\n        vector<vector<int>> v(n,vector<int>(n));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                v[i][pre[i][j]] = n-1-j;\\n            }\\n        }\\n        int ans = 0;\\n        vector<int> mp(n);\\n        for(auto p:pairs){\\n            mp[p[0]] = p[1];\\n            mp[p[1]] = p[0];\\n        }\\n        for(auto p:pairs){\\n            int x = p[0], y = p[1];\\n            int z = v[x][y];\\n            for(int i=0;i<n;i++) {\\n                if(v[x][i]>z){\\n                    int pp = mp[i];\\n                    if(v[i][x]>v[i][pp]) {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n            z = v[y][x];\\n            for(int i=0;i<n;i++) {\\n                if(v[y][i]>z){\\n                    int pp = mp[i];\\n                    if(v[i][y]>v[i][pp]) {\\n                        ans++;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877380,
                "title": "java-concise-bruteforce-o-n-2",
                "content": "1. Transform the preferences information into rank so that we can query how much x likes y by checking `rank[x][y]`.\\n2. Use bitset or hashset or mark unhappy people. \\n\\n**Solution**\\n```Java\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] rank = new int[n][n];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n - 1; j++){\\n                rank[i][preferences[i][j]] = j;\\n            }\\n        }\\n\\n        BitSet bit = new BitSet(n);\\n        for (int i = 0; i < n / 2; i++){\\n            for (int j = 0; j < n / 2; j++){\\n                for (int k = 0; k < 2 && i != j; k++){\\n                    for (int w = 0; w < 2; w++){\\n                        int xy = rank[pairs[i][k]][pairs[i][1 - k]];\\n                        int xu = rank[pairs[i][k]][pairs[j][w]];\\n                        int uv = rank[pairs[j][w]][pairs[j][1 - w]];\\n                        int ux = rank[pairs[j][w]][pairs[i][k]];\\n                        if (xu < xy && ux < uv){ // condition required.\\n                            bit.set(pairs[i][k]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return bit.cardinality();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int[][] rank = new int[n][n];\\n        for (int i = 0; i < n; i++){\\n            for (int j = 0; j < n - 1; j++){\\n                rank[i][preferences[i][j]] = j;\\n            }\\n        }\\n\\n        BitSet bit = new BitSet(n);\\n        for (int i = 0; i < n / 2; i++){\\n            for (int j = 0; j < n / 2; j++){\\n                for (int k = 0; k < 2 && i != j; k++){\\n                    for (int w = 0; w < 2; w++){\\n                        int xy = rank[pairs[i][k]][pairs[i][1 - k]];\\n                        int xu = rank[pairs[i][k]][pairs[j][w]];\\n                        int uv = rank[pairs[j][w]][pairs[j][1 - w]];\\n                        int ux = rank[pairs[j][w]][pairs[i][k]];\\n                        if (xu < xy && ux < uv){ // condition required.\\n                            bit.set(pairs[i][k]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return bit.cardinality();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852946,
                "title": "best-map-solution-o-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isUn(int x,int y,int u,int v, unordered_map<int,unordered_map<int,int>> &mp)\\n    {\\n                int x_u = mp[x][u];\\n                if(x_u==0) x_u = INT_MAX;\\n                \\n                int x_y = mp[x][y];\\n                if(x_y==0) x_y = INT_MAX;\\n                \\n                int u_x = mp[u][x];\\n                if(u_x==0) u_x = INT_MAX;\\n                \\n                int u_v = mp[u][v];\\n                if(u_v==0) u_v = INT_MAX;\\n                \\n                return (x_u < x_y && u_x < u_v);         \\n    }\\n    int unhappyFriends(int n, vector<vector<int>> &pref, vector<vector<int>> &p) {\\n        \\n        unordered_map<int,unordered_map<int,int>> mp;    // man -> { friend -> pref_no }\\n        for(int i = 0;i<pref.size();i++)            \\n        {            \\n            for(int j = 0;j<pref[i].size();j++)\\n            {\\n                int frd = pref[i][j];\\n                mp[i][frd] = j+1;       \\n            }\\n        }\\n        for(int i = 0;i<p.size();i++)      // store the pair-mate using {idx=-1} saved space\\n        {\\n            int x = p[i][0];\\n            int y = p[i][1];\\n            mp[x][-1] = y;\\n            mp[y][-1] = x;\\n        }\\n        int ct = 0;\\n        for(int x = 0;x<n;x++)              //  O(n*n) time complexity\\n        {\\n            bool isU = false;            \\n            int y = mp[x][-1];                \\n            for(auto it1:mp[x])  // scan past friends of x \\n            {\\n                int u = it1.first;                \\n                int v = mp[u][-1];\\n                if(isUn(x,y,u,v,mp))\\n                {       \\n                    isU = true;break;\\n                }\\n            }\\n            if(isU) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isUn(int x,int y,int u,int v, unordered_map<int,unordered_map<int,int>> &mp)\\n    {\\n                int x_u = mp[x][u];\\n                if(x_u==0) x_u = INT_MAX;\\n                \\n                int x_y = mp[x][y];\\n                if(x_y==0) x_y = INT_MAX;\\n                \\n                int u_x = mp[u][x];\\n                if(u_x==0) u_x = INT_MAX;\\n                \\n                int u_v = mp[u][v];\\n                if(u_v==0) u_v = INT_MAX;\\n                \\n                return (x_u < x_y && u_x < u_v);         \\n    }\\n    int unhappyFriends(int n, vector<vector<int>> &pref, vector<vector<int>> &p) {\\n        \\n        unordered_map<int,unordered_map<int,int>> mp;    // man -> { friend -> pref_no }\\n        for(int i = 0;i<pref.size();i++)            \\n        {            \\n            for(int j = 0;j<pref[i].size();j++)\\n            {\\n                int frd = pref[i][j];\\n                mp[i][frd] = j+1;       \\n            }\\n        }\\n        for(int i = 0;i<p.size();i++)      // store the pair-mate using {idx=-1} saved space\\n        {\\n            int x = p[i][0];\\n            int y = p[i][1];\\n            mp[x][-1] = y;\\n            mp[y][-1] = x;\\n        }\\n        int ct = 0;\\n        for(int x = 0;x<n;x++)              //  O(n*n) time complexity\\n        {\\n            bool isU = false;            \\n            int y = mp[x][-1];                \\n            for(auto it1:mp[x])  // scan past friends of x \\n            {\\n                int u = it1.first;                \\n                int v = mp[u][-1];\\n                if(isUn(x,y,u,v,mp))\\n                {       \\n                    isU = true;break;\\n                }\\n            }\\n            if(isU) ct++;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843125,
                "title": "simple-java-solution",
                "content": "class Solution {\\n    \\n\\tpublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        \\n        for(int [] e: pairs){\\n            \\n            int x=e[0];\\n            int y=e[1];\\n            \\n            map.put(x,y);\\n            map.put(y,x);\\n            \\n        }\\n        \\n        int count=0;\\n        \\n        for(int []e: pairs){\\n            \\n           \\n            for(int x: e){\\n                int g=count;\\n                for(int j=0;j<preferences[x].length;j++){\\n                    if(preferences[x][j]==map.get(x)){\\n                        break;\\n                    }\\n\\n                    int u=preferences[x][j];\\n\\n                    if(map.containsKey(u)){\\n\\n                        for(int k=0;k<preferences[u].length;k++){\\n                            if(preferences[u][k]==x){\\n                                count++;\\n                                break;\\n                            }\\n                            if(preferences[u][k]==map.get(u))\\n                                break;\\n                        }\\n\\n                    }\\n                    \\n                    if(g<count)\\n                        break;\\n                }\\n            }           \\n        }\\n \\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int unhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        \\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        \\n        for(int [] e: pairs){\\n            \\n            int x=e[0];\\n            int y=e[1];\\n            \\n            map.put(x,y);\\n            map.put(y,x);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1835975,
                "title": "what-s-wrong-in-this",
                "content": "Can anyone help me out finding out what is the error in this?\\nwhy it\\'s failing for the follwing test case:\\n\\n**14\\n[[10,9,2,11,1,8,12,4,3,13,6,7,5],[8,12,6,10,9,3,7,13,0,5,4,2,11],[0,11,10,9,4,8,3,12,1,6,5,13,7],[12,10,7,11,4,5,8,2,6,9,0,13,1],[7,0,9,5,12,13,1,2,10,6,11,3,8],[8,12,7,13,10,6,4,3,2,11,0,1,9],[13,5,11,8,7,1,4,12,9,10,3,2,0],[11,12,3,13,4,5,6,9,1,8,2,0,10],[5,1,2,6,13,3,7,11,4,9,10,12,0],[10,11,1,3,12,2,8,7,4,5,6,0,13],[5,4,12,11,7,3,13,1,2,9,8,0,6],[2,4,3,8,5,0,7,12,13,9,6,1,10],[11,0,6,10,9,3,1,4,2,8,7,13,5],[0,4,11,8,6,9,2,12,1,7,10,3,5]]\\n[[11,8],[7,2],[1,9],[10,4],[5,12],[0,13],[3,6]]**\\n\\n```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> umap;\\n        int res = 0;\\n        \\n        for(auto pair : pairs) {\\n            int x = pair[0], y = pair[1];\\n            for(int u : pref[x]) {\\n                if(u == y)\\n                    break;\\n                umap[x].push_back(u);\\n            }\\n            \\n            x = pair[1], y = pair[0];\\n            for(int u : pref[x]) {\\n                if(u == y)\\n                    break;\\n                umap[x].push_back(u);\\n            }\\n        }\\n        \\n        for(auto it = umap.begin(); it != umap.end(); ++it) {\\n            int me = it->first;\\n            vector<int> prefrees = it->second;\\n            \\n            for(int p : prefrees) {\\n                vector<int> v = umap[p];\\n                if(find(v.begin(), v.end(), me) != v.end()) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& pref, vector<vector<int>>& pairs) {\\n        unordered_map<int, vector<int>> umap;\\n        int res = 0;\\n        \\n        for(auto pair : pairs) {\\n            int x = pair[0], y = pair[1];\\n            for(int u : pref[x]) {\\n                if(u == y)\\n                    break;\\n                umap[x].push_back(u);\\n            }\\n            \\n            x = pair[1], y = pair[0];\\n            for(int u : pref[x]) {\\n                if(u == y)\\n                    break;\\n                umap[x].push_back(u);\\n            }\\n        }\\n        \\n        for(auto it = umap.begin(); it != umap.end(); ++it) {\\n            int me = it->first;\\n            vector<int> prefrees = it->second;\\n            \\n            for(int p : prefrees) {\\n                vector<int> v = umap[p];\\n                if(find(v.begin(), v.end(), me) != v.end()) {\\n                    res++;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825049,
                "title": "o-n-2-or-o-n-m-solution-using-arrays-and-hashset",
                "content": "- This approach is similar to brute force approach but I tried to improve it by storing preferences in beginning.\\n- Please read comments in code to understance code\\n- Time Time Complexity :-  O(n * (m + m)) \\u21D2 O(n*m) (where n is number of friends and m is more preferred friends over friend2) (m can be n-2 at max) **(Please suggest if calculation is not correct)**\\n- Space Complexity :-  O(n*n) + O(n) \\u21D2 O(n*n)\\n- please suggest corrections if any\\n\\n```\\nclass Solution {\\n    //In this code => x = friend1\\n    //and y = friend2\\n    \\n    //This will store [i,j] => k, for friend i, jth preference will be k\\n    int[][] friendPreference = null;\\n    \\n    //This will store index of pair in which ith friend is present\\n    int[] presentInPair = null;\\n    \\n    public int unhappyFriends(int numberOfFriends, int[][] preferences, int[][] pairs) {\\n        presentInPair = new int[numberOfFriends];\\n        for(int i=0;i<pairs.length;i++){\\n            presentInPair[pairs[i][0]] = i;\\n            presentInPair[pairs[i][1]] = i;\\n        }\\n        \\n        friendPreference = new int[numberOfFriends][numberOfFriends];\\n        for(int i=0;i<numberOfFriends;i++){\\n            int[] oneFriendPreference = preferences[i];\\n            int j=0;\\n            for(int friend : oneFriendPreference){\\n                friendPreference[i][friend] = j;\\n                j++;\\n            }\\n        }\\n        \\n        Set<Integer> unHappySet = new HashSet<>();\\n        \\n        for(int i=0;i<pairs.length;i++){\\n            int friend1 = pairs[i][0];\\n            int friend2 = pairs[i][1];\\n            \\n            //for 0th element => This code block will check if friend1 prefers any friend u over friend2 and also we need to check u prefers friend1 over v\\n            if(!unHappySet.contains(friend1)){\\n                int indexIffriend1unhappy = isFriendUnHappy(friend1,friend2,preferences,pairs);\\n                if(indexIffriend1unhappy != -1)\\n                {\\n                    //Both friends are unhappy so add both in set\\n                    unHappySet.add(friend1);\\n                    unHappySet.add(indexIffriend1unhappy);\\n                }\\n            }\\n            \\n            \\n            //for 0th element => This code block will check if friend2 prefers any friend u over friend1 and also we need to check u prefers friend2 over v\\n            if(!unHappySet.contains(friend2)){\\n                    int indexIffriend2unhappy = isFriendUnHappy(friend2,friend1,preferences,pairs);\\n            if(indexIffriend2unhappy != -1)\\n            {\\n                //Both friends are unhappy so add both in set\\n                unHappySet.add(friend2);\\n                unHappySet.add(indexIffriend2unhappy);\\n            }   \\n            }\\n            \\n        }\\n        \\n        return unHappySet.size();\\n    }\\n    \\n    private int isFriendUnHappy(int friend1, int friend2,int[][] preferences, int[][] pairs){\\n            //preference index of friend1 & friend2\\n            int prefrenceIndex = friendPreference[friend1][friend2];\\n        \\n            //friend1\\'s all preferences\\n            int[] friend1preferences = preferences[friend1];\\n        \\n            if(prefrenceIndex != 0){\\n                //check for all prefernces where preference < prefrenceIndex(preference of friend2)\\n                for(int i=0;i<prefrenceIndex;i++){\\n                    //index of friend which is at ith preference for friend1\\n                    int u = friend1preferences[i];\\n                    \\n                    //find pair in which above friend is present\\n                    int pairIndexOfFriendAtI = presentInPair[u];\\n                    int[] pairFriendAtI = pairs[pairIndexOfFriendAtI];\\n                    \\n                    //Find corresponding friend in pair of u\\n                    int v = pairFriendAtI[0] != u ? pairFriendAtI[0] : pairFriendAtI[1];\\n\\n                    //u should prefer friend1 over v(preference value should be lower)\\n                    if(friendPreference[u][v] >\\n                       friendPreference[u][friend1])\\n                        //return u that means friend1 prefers u over friend2 and u preferes friend1 over v\\n                        return u;\\n                    \\n                }\\n            }\\n            \\n            return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //In this code => x = friend1\\n    //and y = friend2\\n    \\n    //This will store [i,j] => k, for friend i, jth preference will be k\\n    int[][] friendPreference = null;\\n    \\n    //This will store index of pair in which ith friend is present\\n    int[] presentInPair = null;\\n    \\n    public int unhappyFriends(int numberOfFriends, int[][] preferences, int[][] pairs) {\\n        presentInPair = new int[numberOfFriends];\\n        for(int i=0;i<pairs.length;i++){\\n            presentInPair[pairs[i][0]] = i;\\n            presentInPair[pairs[i][1]] = i;\\n        }\\n        \\n        friendPreference = new int[numberOfFriends][numberOfFriends];\\n        for(int i=0;i<numberOfFriends;i++){\\n            int[] oneFriendPreference = preferences[i];\\n            int j=0;\\n            for(int friend : oneFriendPreference){\\n                friendPreference[i][friend] = j;\\n                j++;\\n            }\\n        }\\n        \\n        Set<Integer> unHappySet = new HashSet<>();\\n        \\n        for(int i=0;i<pairs.length;i++){\\n            int friend1 = pairs[i][0];\\n            int friend2 = pairs[i][1];\\n            \\n            //for 0th element => This code block will check if friend1 prefers any friend u over friend2 and also we need to check u prefers friend1 over v\\n            if(!unHappySet.contains(friend1)){\\n                int indexIffriend1unhappy = isFriendUnHappy(friend1,friend2,preferences,pairs);\\n                if(indexIffriend1unhappy != -1)\\n                {\\n                    //Both friends are unhappy so add both in set\\n                    unHappySet.add(friend1);\\n                    unHappySet.add(indexIffriend1unhappy);\\n                }\\n            }\\n            \\n            \\n            //for 0th element => This code block will check if friend2 prefers any friend u over friend1 and also we need to check u prefers friend2 over v\\n            if(!unHappySet.contains(friend2)){\\n                    int indexIffriend2unhappy = isFriendUnHappy(friend2,friend1,preferences,pairs);\\n            if(indexIffriend2unhappy != -1)\\n            {\\n                //Both friends are unhappy so add both in set\\n                unHappySet.add(friend2);\\n                unHappySet.add(indexIffriend2unhappy);\\n            }   \\n            }\\n            \\n        }\\n        \\n        return unHappySet.size();\\n    }\\n    \\n    private int isFriendUnHappy(int friend1, int friend2,int[][] preferences, int[][] pairs){\\n            //preference index of friend1 & friend2\\n            int prefrenceIndex = friendPreference[friend1][friend2];\\n        \\n            //friend1\\'s all preferences\\n            int[] friend1preferences = preferences[friend1];\\n        \\n            if(prefrenceIndex != 0){\\n                //check for all prefernces where preference < prefrenceIndex(preference of friend2)\\n                for(int i=0;i<prefrenceIndex;i++){\\n                    //index of friend which is at ith preference for friend1\\n                    int u = friend1preferences[i];\\n                    \\n                    //find pair in which above friend is present\\n                    int pairIndexOfFriendAtI = presentInPair[u];\\n                    int[] pairFriendAtI = pairs[pairIndexOfFriendAtI];\\n                    \\n                    //Find corresponding friend in pair of u\\n                    int v = pairFriendAtI[0] != u ? pairFriendAtI[0] : pairFriendAtI[1];\\n\\n                    //u should prefer friend1 over v(preference value should be lower)\\n                    if(friendPreference[u][v] >\\n                       friendPreference[u][friend1])\\n                        //return u that means friend1 prefers u over friend2 and u preferes friend1 over v\\n                        return u;\\n                    \\n                }\\n            }\\n            \\n            return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818918,
                "title": "c-o-n-2-easiest-solution-no-confusion",
                "content": "```\\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n\\tvector<int> pair(n); // pair[i] = Friend with which \\'i\\'th friend has been paired \\n\\tvector<vector<int>> pref(n, vector<int>(n, 0)); //pref[i][j] = Preference of \\'j\\'th friend for ith friend\\n\\tfor(auto &x : pairs) {\\n\\t\\tpair[x[0]] = x[1];\\n\\t\\tpair[x[1]] = x[0];\\n\\t}\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n-1; j++) {\\n\\t\\t\\tpref[i][preferences[i][j]] = n-j;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\t// For each friend \\'i\\', check if another friend \\'j\\' satisfies the condition for him (i) being unhappy\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tbool flag = false;\\n\\t\\tfor(int j = 0; j<n && !flag; j++) {\\n\\t\\t\\tif(j == i) continue;\\n\\t\\t\\tif(pref[i][pair[i]] < pref[i][j] && pref[j][pair[j]] < pref[j][i]) flag = true; \\n\\t\\t}\\n\\t\\tif(flag) res++; // If, for any friend \\'j\\', the condition satisfies => \\'i\\'th friend is unhappy\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n\\tvector<int> pair(n); // pair[i] = Friend with which \\'i\\'th friend has been paired \\n\\tvector<vector<int>> pref(n, vector<int>(n, 0)); //pref[i][j] = Preference of \\'j\\'th friend for ith friend\\n\\tfor(auto &x : pairs) {\\n\\t\\tpair[x[0]] = x[1];\\n\\t\\tpair[x[1]] = x[0];\\n\\t}\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tfor(int j = 0; j<n-1; j++) {\\n\\t\\t\\tpref[i][preferences[i][j]] = n-j;\\n\\t\\t}\\n\\t}\\n\\n\\tint res = 0;\\n\\t// For each friend \\'i\\', check if another friend \\'j\\' satisfies the condition for him (i) being unhappy\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tbool flag = false;\\n\\t\\tfor(int j = 0; j<n && !flag; j++) {\\n\\t\\t\\tif(j == i) continue;\\n\\t\\t\\tif(pref[i][pair[i]] < pref[i][j] && pref[j][pair[j]] < pref[j][i]) flag = true; \\n\\t\\t}\\n\\t\\tif(flag) res++; // If, for any friend \\'j\\', the condition satisfies => \\'i\\'th friend is unhappy\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1769658,
                "title": "straight-forward-python-just-following-the-logic-in-question",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        pairs_dict = {}\\n        for p in pairs:\\n            pairs_dict[p[0]] = p[1]\\n            pairs_dict[p[1]] = p[0]\\n        result = 0\\n        for x in range(n):\\n            y = pairs_dict[x]\\n            for u in range(n):\\n                if x == u:\\n                    continue\\n                v = pairs_dict[u]\\n                if preferences[x].index(u) < preferences[x].index(y) and preferences[u].index(x) < preferences[u].index(v):\\n                    result += 1\\n                    break\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        pairs_dict = {}\\n        for p in pairs:\\n            pairs_dict[p[0]] = p[1]\\n            pairs_dict[p[1]] = p[0]\\n        result = 0\\n        for x in range(n):\\n            y = pairs_dict[x]\\n            for u in range(n):\\n                if x == u:\\n                    continue\\n                v = pairs_dict[u]\\n                if preferences[x].index(u) < preferences[x].index(y) and preferences[u].index(x) < preferences[u].index(v):\\n                    result += 1\\n                    break\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759999,
                "title": "simple-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preference, vector<vector<int>>& pair) {\\n     unordered_map<int,vector<int>>mp;                    // hashing to access prefernce value of each friend for any person x in O(1)\\n        vector<int>t(n,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                t[preference[i][j]]=j;\\n            }\\n            mp[i]=t;\\n        }\\n        unordered_map<int,int> paired_friend;                 // hashing to access paired friend in O(1);\\n        for(int i=0;i<n/2;i++){\\n            paired_friend[pair[i][0]]=pair[i][1];\\n            paired_friend[pair[i][1]]=pair[i][0];\\n        }\\n        \\n        vector<int>person_state(n,0);\\n        int ans=0;\\n        for(auto it: paired_friend){\\n            int a=it.first, b=it.second, b_prefrence_for_a=mp[a][b];\\n            if(person_state[a]==0){                          //if person is unhappy no need to check\\n                for(int i=b_prefrence_for_a-1;i>=0;i--){    \\n// if we find lower preference friend for person \\'a\\' who also paired\\n//with  higher preference friend than person \\'a\\', then both unhappy\\n                    int x=preference[a][i];\\n                    int x_pair=paired_friend[x];\\n                    if(mp[x][a]<mp[x][x_pair]){\\n                    person_state[x]=1;person_state[a]=1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            ans+=person_state[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unhappyFriends(int n, vector<vector<int>>& preference, vector<vector<int>>& pair) {\\n     unordered_map<int,vector<int>>mp;                    // hashing to access prefernce value of each friend for any person x in O(1)\\n        vector<int>t(n,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n-1;j++){\\n                t[preference[i][j]]=j;\\n            }\\n            mp[i]=t;\\n        }\\n        unordered_map<int,int> paired_friend;                 // hashing to access paired friend in O(1);\\n        for(int i=0;i<n/2;i++){\\n            paired_friend[pair[i][0]]=pair[i][1];\\n            paired_friend[pair[i][1]]=pair[i][0];\\n        }\\n        \\n        vector<int>person_state(n,0);\\n        int ans=0;\\n        for(auto it: paired_friend){\\n            int a=it.first, b=it.second, b_prefrence_for_a=mp[a][b];\\n            if(person_state[a]==0){                          //if person is unhappy no need to check\\n                for(int i=b_prefrence_for_a-1;i>=0;i--){    \\n// if we find lower preference friend for person \\'a\\' who also paired\\n//with  higher preference friend than person \\'a\\', then both unhappy\\n                    int x=preference[a][i];\\n                    int x_pair=paired_friend[x];\\n                    if(mp[x][a]<mp[x][x_pair]){\\n                    person_state[x]=1;person_state[a]=1;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            ans+=person_state[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752609,
                "title": "c-tc-n-2-mc-n-2-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\nprivate:\\n    // MC: O(n^2) => In the worst case, everyfriend will be in the prior preferences set.\\n    int numOfFriends;\\n    vector<set<int>> priorPrefSet;\\n    vector<vector<int>> preferences;\\n    vector<vector<int>> pairs;\\n    \\npublic:\\n    // TC: O(n^2) => for each person, we traverse its friend list\\n    void createPriorPrefSet() {\\n        priorPrefSet.resize(numOfFriends);\\n        for (auto pair: pairs) {\\n            int first = pair[0];\\n            int second = pair[1];\\n            for (int i = 0; i < preferences[first].size(); i++) {\\n                if (preferences[first][i] == second)   \\n                    break;\\n                priorPrefSet[first].insert(preferences[first][i]);\\n            }\\n            for (int i = 0; i < preferences[second].size(); i++) {\\n                if (preferences[second][i] == first)\\n                    break;\\n                priorPrefSet[second].insert(preferences[second][i]);\\n            }\\n        }\\n    }\\n    \\n    // TC: O(n^2) => for each person, we traverse its prior preferences set\\n    int countUnhappyFriends() {\\n        int cnt = 0;\\n        for (int i = 0; i < numOfFriends; i++) {\\n            for (auto priorFriend: priorPrefSet[i]) {\\n                if (priorPrefSet[priorFriend].count(i) > 0) {\\n                    cnt++;\\n                    break;  // Finding one is enough\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    /* Main idea is that for each person, we create a set that contain person\\'s friends whose\\n    priority is over the person\\'s current pair. Then for each such friends we check\\n    whether they also includdes current person. If so, there is a new unhappy friends.\\n    */\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        this->numOfFriends = n;\\n        this->preferences = preferences;\\n        this->pairs = pairs;\\n        \\n        createPriorPrefSet();\\n        return countUnhappyFriends();\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    // MC: O(n^2) => In the worst case, everyfriend will be in the prior preferences set.\\n    int numOfFriends;\\n    vector<set<int>> priorPrefSet;\\n    vector<vector<int>> preferences;\\n    vector<vector<int>> pairs;\\n    \\npublic:\\n    // TC: O(n^2) => for each person, we traverse its friend list\\n    void createPriorPrefSet() {\\n        priorPrefSet.resize(numOfFriends);\\n        for (auto pair: pairs) {\\n            int first = pair[0];\\n            int second = pair[1];\\n            for (int i = 0; i < preferences[first].size(); i++) {\\n                if (preferences[first][i] == second)   \\n                    break;\\n                priorPrefSet[first].insert(preferences[first][i]);\\n            }\\n            for (int i = 0; i < preferences[second].size(); i++) {\\n                if (preferences[second][i] == first)\\n                    break;\\n                priorPrefSet[second].insert(preferences[second][i]);\\n            }\\n        }\\n    }\\n    \\n    // TC: O(n^2) => for each person, we traverse its prior preferences set\\n    int countUnhappyFriends() {\\n        int cnt = 0;\\n        for (int i = 0; i < numOfFriends; i++) {\\n            for (auto priorFriend: priorPrefSet[i]) {\\n                if (priorPrefSet[priorFriend].count(i) > 0) {\\n                    cnt++;\\n                    break;  // Finding one is enough\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    /* Main idea is that for each person, we create a set that contain person\\'s friends whose\\n    priority is over the person\\'s current pair. Then for each such friends we check\\n    whether they also includdes current person. If so, there is a new unhappy friends.\\n    */\\n    int unhappyFriends(int n, vector<vector<int>>& preferences, vector<vector<int>>& pairs) {\\n        this->numOfFriends = n;\\n        this->preferences = preferences;\\n        this->pairs = pairs;\\n        \\n        createPriorPrefSet();\\n        return countUnhappyFriends();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740295,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func unhappyFriends(_ n: Int, _ preferences: [[Int]], _ pairs: [[Int]]) -> Int {\\n        var preferenceTable = Array(repeating: Array(repeating: 0, count: n), count: n)\\n\\n        for (row, preference) in preferences.enumerated() {\\n            for (prefrenceId, col) in preference.enumerated() {\\n                preferenceTable[row][col] = prefrenceId + 1\\n            }\\n        }\\n\\n        var result = Set<Int>()\\n\\n        for firstPair in pairs {\\n            let (x, y) = (firstPair[0], firstPair[1])\\n\\n            for secPair in pairs {\\n                if firstPair != secPair {\\n                    let (u, v) = (secPair[0], secPair[1])\\n\\n                    if preferenceTable[x][u] < preferenceTable[x][y]\\n                        && preferenceTable[u][x] < preferenceTable[u][v]\\n                        || preferenceTable[x][v] < preferenceTable[x][y]\\n                        && preferenceTable[v][x] < preferenceTable[v][u]{\\n                        result.insert(x)\\n                    }\\n\\n                    if preferenceTable[y][u] < preferenceTable[y][x]\\n                        && preferenceTable[u][y] < preferenceTable[u][v]\\n                        || preferenceTable[y][v] < preferenceTable[y][x]\\n                        && preferenceTable[v][y] < preferenceTable[v][u]{\\n                        result.insert(y)\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func unhappyFriends(_ n: Int, _ preferences: [[Int]], _ pairs: [[Int]]) -> Int {\\n        var preferenceTable = Array(repeating: Array(repeating: 0, count: n), count: n)\\n\\n        for (row, preference) in preferences.enumerated() {\\n            for (prefrenceId, col) in preference.enumerated() {\\n                preferenceTable[row][col] = prefrenceId + 1\\n            }\\n        }\\n\\n        var result = Set<Int>()\\n\\n        for firstPair in pairs {\\n            let (x, y) = (firstPair[0], firstPair[1])\\n\\n            for secPair in pairs {\\n                if firstPair != secPair {\\n                    let (u, v) = (secPair[0], secPair[1])\\n\\n                    if preferenceTable[x][u] < preferenceTable[x][y]\\n                        && preferenceTable[u][x] < preferenceTable[u][v]\\n                        || preferenceTable[x][v] < preferenceTable[x][y]\\n                        && preferenceTable[v][x] < preferenceTable[v][u]{\\n                        result.insert(x)\\n                    }\\n\\n                    if preferenceTable[y][u] < preferenceTable[y][x]\\n                        && preferenceTable[u][y] < preferenceTable[u][v]\\n                        || preferenceTable[y][v] < preferenceTable[y][x]\\n                        && preferenceTable[v][y] < preferenceTable[v][u]{\\n                        result.insert(y)\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738947,
                "title": "c-solution-using-dictionary",
                "content": "```\\npublic class Solution {\\n    public int UnhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int uh = 0;\\n        Dictionary<int,int> paired = new Dictionary<int,int>();\\n        \\n        foreach(var pair in pairs)\\n        {\\n            paired.Add(pair[0], pair[1]);\\n            paired.Add(pair[1], pair[0]);\\n        }\\n        foreach(var pair in pairs)\\n        {\\n            int[] first = preferences[pair[0]];\\n            int[] second = preferences[pair[1]];\\n            \\n            int i = 0;\\n            while(first[i] != pair[1])\\n            {\\n                if(PrefersSameWay(preferences[first[i]], pair[0], paired[first[i]]))\\n                {\\n                    uh++;\\n                    break;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            while(second[i] != pair[0])\\n            {\\n                if(PrefersSameWay(preferences[second[i]], pair[1], paired[second[i]]))\\n                {\\n                    uh++;\\n                    break;\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        return uh;\\n    }\\n    \\n    private bool PrefersSameWay(int[] arr, int a, int b)\\n    {\\n        foreach(int i in arr)\\n        {\\n            if(i == a)\\n                return true;\\n            if(i == b)\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int UnhappyFriends(int n, int[][] preferences, int[][] pairs) {\\n        int uh = 0;\\n        Dictionary<int,int> paired = new Dictionary<int,int>();\\n        \\n        foreach(var pair in pairs)\\n        {\\n            paired.Add(pair[0], pair[1]);\\n            paired.Add(pair[1], pair[0]);\\n        }\\n        foreach(var pair in pairs)\\n        {\\n            int[] first = preferences[pair[0]];\\n            int[] second = preferences[pair[1]];\\n            \\n            int i = 0;\\n            while(first[i] != pair[1])\\n            {\\n                if(PrefersSameWay(preferences[first[i]], pair[0], paired[first[i]]))\\n                {\\n                    uh++;\\n                    break;\\n                }\\n                i++;\\n            }\\n            i = 0;\\n            while(second[i] != pair[0])\\n            {\\n                if(PrefersSameWay(preferences[second[i]], pair[1], paired[second[i]]))\\n                {\\n                    uh++;\\n                    break;\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        return uh;\\n    }\\n    \\n    private bool PrefersSameWay(int[] arr, int a, int b)\\n    {\\n        foreach(int i in arr)\\n        {\\n            if(i == a)\\n                return true;\\n            if(i == b)\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698547,
                "title": "python-hashmap",
                "content": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        #convert pairs in undirected graph\\n        #mapping any of A to B with the preference ranking\\n        #for each pair, find another pair meet the conditions, add it to the result and continue with next pair\\n\\t\\t#O(n^2) time and space\\n        \\n        \\n        pairsmap = {}\\n        for x, y in pairs:\\n            pairsmap[x] = y\\n            pairsmap[y] = x\\n            \\n        rank = defaultdict(lambda: defaultdict(int))\\n        for i in range(n):\\n            for j in range(len(preferences[i])):\\n                rank[i][preferences[i][j]] = j\\n        \\n        res = 0\\n        for x, y in pairsmap.items():\\n            for u in range(n):\\n                v = pairsmap[u]\\n                if u == x:\\n                    continue\\n                if rank[x][u] < rank[x][y] and rank[u][x] < rank[u][v]:\\n                    res += 1\\n                    break\\n        \\n        return res\\n            \\n            \\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unhappyFriends(self, n: int, preferences: List[List[int]], pairs: List[List[int]]) -> int:\\n        #convert pairs in undirected graph\\n        #mapping any of A to B with the preference ranking\\n        #for each pair, find another pair meet the conditions, add it to the result and continue with next pair\\n\\t\\t#O(n^2) time and space\\n        \\n        \\n        pairsmap = {}\\n        for x, y in pairs:\\n            pairsmap[x] = y\\n            pairsmap[y] = x\\n            \\n        rank = defaultdict(lambda: defaultdict(int))\\n        for i in range(n):\\n            for j in range(len(preferences[i])):\\n                rank[i][preferences[i][j]] = j\\n        \\n        res = 0\\n        for x, y in pairsmap.items():\\n            for u in range(n):\\n                v = pairsmap[u]\\n                if u == x:\\n                    continue\\n                if rank[x][u] < rank[x][y] and rank[u][x] < rank[u][v]:\\n                    res += 1\\n                    break\\n        \\n        return res\\n            \\n            \\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567600,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1574398,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1765280,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1901501,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1875276,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1761121,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1978112,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1710995,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 2058569,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 2058286,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1567600,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1574398,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1765280,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1901501,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1875276,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1761121,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1978112,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 1710995,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 2058569,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            },
            {
                "id": 2058286,
                "content": [
                    {
                        "username": "strommj",
                        "content": "It says the output should be 0, but it is 2."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "how?"
                    },
                    {
                        "username": "jingjing_334",
                        "content": "Had to use failed test case to reverse engineer the problem description. It\\'s a waste of time."
                    },
                    {
                        "username": "aakash_abhishek",
                        "content": "Why Bloomberg tagged questions are so hard to understand"
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "because their goal is to confuse you, not test your knowledge of coding!!!"
                    },
                    {
                        "username": "mo1ok",
                        "content": "I have no idea how the preference array works in this question. Are these preferences for individual friends, or are the preferences supposed to be aggregrated on the whole?\n\nIn the first example, there are two preference arrays:\n[1, 2, 3]\n[3, 2, 0]\n\nSo is 3 a preferred to 2, or is 3 inferior to 2? It makes no sense. Who ever wrote this question needs to get their head checked.\n\n\nEdit: after struggling with it, not mentioned in the problem is that the index of the preference list is relevant. So The preferences are the indivdual preferences of the friends - [1, 2, 3] at index 0 is the preference of friend 0."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Bad mood, bad problem. :("
                    },
                    {
                        "username": "mission_2023",
                        "content": "wtf"
                    },
                    {
                        "username": "harshhhhhhhhhh",
                        "content": "language is too much confusing."
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain this question?"
                    },
                    {
                        "username": "matthanwork",
                        "content": "You are given pairs of people. Each person has preferences as to who they would want to be partnered with. \\nPerson1 is paired with Person2. Person1 is unhappy if he prefers someone more than Person2 AND another person that he prefers more than Person2 is paired with someone who likes Person1 more than their current partner"
                    },
                    {
                        "username": "hammeramr",
                        "content": "I don't understand all the hate - the description was extremely clear - dense but clear - just read this line a few timea thats all you need\n\n```\nA friend x is unhappy if x is paired with y and there exists a friend u who is paired with v but:\n\nx prefers u over y\nu prefers x over v\n```\n\nAnother way to think of it is\n\n\"X is unhappy if x is not paired with their first preference AND there exists another person who was not paired with x but prefers x over their current pairing\""
                    },
                    {
                        "username": "Lewis0511",
                        "content": "Here comes another unhappy friend. "
                    }
                ]
            }
        ]
    }
]