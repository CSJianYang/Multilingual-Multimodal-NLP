[
    {
        "title": "Cycle Length Queries in a Tree",
        "question_content": "You are given an integer n. There is a complete binary tree with 2n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2n - 1 - 1] has two children where:\n\n\tThe left node has the value 2 * val, and\n\tThe right node has the value 2 * val + 1.\n\nYou are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem:\n\n\tAdd an edge between the nodes with values ai and bi.\n\tFind the length of the cycle in the graph.\n\tRemove the added edge between nodes with values ai and bi.\n\nNote that:\n\n\tA cycle is a path that starts and ends at the same node, and each edge in the path is visited only once.\n\tThe length of a cycle is the number of edges visited in the cycle.\n\tThere could be multiple edges between two nodes in the tree after adding the edge of the query.\n\nReturn an array answer of length m where answer[i] is the answer to the ith query.\n&nbsp;\nExample 1:\n\nInput: n = 3, queries = [[5,3],[4,7],[2,3]]\nOutput: [4,5,3]\nExplanation: The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query.\n- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query.\n- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge.\n\nExample 2:\n\nInput: n = 2, queries = [[1,2]]\nOutput: [2]\nExplanation: The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.\n\n&nbsp;\nConstraints:\n\n\t2 <= n <= 30\n\tm == queries.length\n\t1 <= m <= 105\n\tqueries[i].length == 2\n\t1 <= ai, bi <= 2n - 1\n\tai != bi",
        "solutions": [
            {
                "id": 2923489,
                "title": "java-c-python-lowest-common-ancestor",
                "content": "# **Intuition**\\nAdd an edge between `ai` and `bi`\\nand find the parents of `ai` and `bi`.\\nThe two path will meet at the common ancestor with biggest value.\\n\\nThe key to this problem is to find the **Lowest Common Ancestor**\\n<br>\\n\\n# **Explanation**\\nThe left node has the value `2 * val`, and\\nThe right node has the value `2 * val + 1`.\\n\\nthis means, no matter a node is left or right child,\\nits parent is `val / 2`.\\n\\nFor query `x` and `y`, we try to find their common ancestor.\\nIf `x != y`, we hadn\\'t found yet.\\nSo we let the bigger node go up:\\nif `x > y, x = x / 2`,\\nif `x < y, y = y / 2`,\\nand this take on step.\\nWe continue to do this until `x == y`.\\n\\nThe cycle length is the number of steps plus 1.\\n<br>\\n\\n# **Complexity**\\nFor each query:\\nTime `O(logX + logY)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int m = queries.length, res[] = new int[m];\\n        for (int i = 0; i < m; ++i) {\\n            res[i]++;\\n            int x = queries[i][0], y = queries[i][1];\\n            while (x != y) {\\n                if (x > y)\\n                    x /= 2;\\n                else\\n                    y /= 2;\\n                res[i]++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> res(m, 1);\\n        for (int i = 0; i < m; ++i) {\\n            int x = queries[i][0], y = queries[i][1];\\n            while (x != y) {\\n                if (x > y)\\n                    x /= 2;\\n                else\\n                    y /= 2;\\n                res[i]++;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def cycleLengthQueries(self, n, queries):\\n        res = []\\n        for x,y in queries:\\n            res.append(1)\\n            while x != y:\\n                x, y = min(x, y), max(x, y) // 2\\n                res[-1] += 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int m = queries.length, res[] = new int[m];\\n        for (int i = 0; i < m; ++i) {\\n            res[i]++;\\n            int x = queries[i][0], y = queries[i][1];\\n            while (x != y) {\\n                if (x > y)\\n                    x /= 2;\\n                else\\n                    y /= 2;\\n                res[i]++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> res(m, 1);\\n        for (int i = 0; i < m; ++i) {\\n            int x = queries[i][0], y = queries[i][1];\\n            while (x != y) {\\n                if (x > y)\\n                    x /= 2;\\n                else\\n                    y /= 2;\\n                res[i]++;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def cycleLengthQueries(self, n, queries):\\n        res = []\\n        for x,y in queries:\\n            res.append(1)\\n            while x != y:\\n                x, y = min(x, y), max(x, y) // 2\\n                res[-1] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2923470,
                "title": "lca",
                "content": "The cycle includes edges from both nodes to their lowest common ancestor. \\n\\n## Improved LCA\\nAll values on a level are smaller than values on the next level. \\n\\nWe can use this fact to catch both values to the same level.\\n\\n**C++**\\n```cpp\\nvector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n    vector<int> res;\\n    for (auto &q : queries) {\\n        int a = q[0], b = q[1], cnt = 1;\\n        while (a != b) {\\n            if (a < b)\\n                swap(a, b);\\n            a /= 2;\\n            ++cnt;\\n        }\\n        res.push_back(cnt);\\n    }\\n    return res;\\n}\\n```\\n\\n## LCA\\nTraverse from each node to the root by dividing the value by 2.\\n\\nRemove common nodes from both pathes.\\n\\n**C++**\\n```cpp\\nvector<int> getPath(int n) {\\n    vector<int> path;\\n    for (; n > 0; n /= 2)\\n        path.push_back(n);\\n    return path;\\n}\\nvector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n    vector<int> res;\\n    for (auto &q : queries) {\\n        auto p1 = getPath(q[0]), p2 = getPath(q[1]);\\n        while (!p1.empty() && !p2.empty() && p1.back() == p2.back()) {\\n            p1.pop_back();\\n            p2.pop_back();\\n        }\\n        res.push_back(1 + p1.size() + p2.size());\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n    vector<int> res;\\n    for (auto &q : queries) {\\n        int a = q[0], b = q[1], cnt = 1;\\n        while (a != b) {\\n            if (a < b)\\n                swap(a, b);\\n            a /= 2;\\n            ++cnt;\\n        }\\n        res.push_back(cnt);\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> getPath(int n) {\\n    vector<int> path;\\n    for (; n > 0; n /= 2)\\n        path.push_back(n);\\n    return path;\\n}\\nvector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n    vector<int> res;\\n    for (auto &q : queries) {\\n        auto p1 = getPath(q[0]), p2 = getPath(q[1]);\\n        while (!p1.empty() && !p2.empty() && p1.back() == p2.back()) {\\n            p1.pop_back();\\n            p2.pop_back();\\n        }\\n        res.push_back(1 + p1.size() + p2.size());\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924188,
                "title": "very-simple-solution",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto q: queries){\\n            int t = 0, i = q[0], j = q[1];\\n            while(i != j){\\n                if(i > j) i = i/2;\\n                else j = j/2;\\n                t++;\\n            }\\n            ans.push_back(t+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto q: queries){\\n            int t = 0, i = q[0], j = q[1];\\n            while(i != j){\\n                if(i > j) i = i/2;\\n                else j = j/2;\\n                t++;\\n            }\\n            ans.push_back(t+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923484,
                "title": "python-sum-of-distances-to-lca-1-two-solutions",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs finding a *Least Common Ancestor*. Time complexity is logarithmic: **O(logN)**. Space complexity is constant: **O(1)**. \\n****\\n\\n**Python #1.** Find distances from each node to the root using logs, then subtract twice the distance from root to the LCA.\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        cycles = []\\n\\t\\t\\n        for q1, q2 in queries:\\n            c = int(log2(q1)) + int(log2(q2)) + 1\\n            while q1 != q2:\\n                q1, q2 = min(q1, q2), max(q1, q2) // 2\\n            cycles.append(c - 2*int(log2(q1)))\\n        \\n        return cycles\\n```\\n\\n**Python #2.** Find distances to the LCA directly.\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        cycles = []\\n\\t\\t\\n        for q1, q2 in queries:\\n            c = 1\\n            while q1 != q2: \\n                q1, q2 = min(q1, q2), max(q1, q2) // 2\\n                c += 1\\n            cycles.append(c)\\n        \\n        return cycles\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        cycles = []\\n\\t\\t\\n        for q1, q2 in queries:\\n            c = int(log2(q1)) + int(log2(q2)) + 1\\n            while q1 != q2:\\n                q1, q2 = min(q1, q2), max(q1, q2) // 2\\n            cycles.append(c - 2*int(log2(q1)))\\n        \\n        return cycles\\n```\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        cycles = []\\n\\t\\t\\n        for q1, q2 in queries:\\n            c = 1\\n            while q1 != q2: \\n                q1, q2 = min(q1, q2), max(q1, q2) // 2\\n                c += 1\\n            cycles.append(c)\\n        \\n        return cycles\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923504,
                "title": "simple-and-very-short-solution",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the distance between two nodes and add 1 with it to find the answer.\\n\\nNow how do we find the distance? We can just pull each node up till they meet. As the the tree is a binary tree we can complete the task in logarithmic time.\\n\\nAt each step we will pull the node with higher value. As described in the problem the parent of any node with value <b>u</b> will be <b>floor(u/2)</b>\\n\\n\\n# Complexity\\n- Time complexity: O(mlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int>ans;\\n        for(auto&u:q){\\n            int a = u[0], b = u[1];\\n            int d = 0;\\n            while(a!=b){\\n                if(b>a) b/=2;\\n                else a/=2;\\n                d++;\\n            }\\n            ans.push_back(d+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int>ans;\\n        for(auto&u:q){\\n            int a = u[0], b = u[1];\\n            int d = 0;\\n            while(a!=b){\\n                if(b>a) b/=2;\\n                else a/=2;\\n                d++;\\n            }\\n            ans.push_back(d+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415515,
                "title": "python-3-9-lines-w-brief-explanation-t-m-81-91",
                "content": "Here\\'s the plan:\\n- The parent of node`n`is `n//2`. \\n- Given two query nodes`a`and`b`, we can select the larger of`a`or`b`and int-divide it by two in each step. We count these steps, and we stop when `a`and`b`are equal.\\n- We initialize the step count`moves`as 1 to account for the edge between the nodes given in the query.\\n\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n\\n        for a, b in queries:\\n            moves = 1\\n\\n            while a != b:\\n                if a > b: a//= 2\\n                else    : b//= 2\\n\\n                moves+= 1\\n\\n            ans.append(moves)  \\n              \\n        return ans\\n```\\n[https://leetcode.com/problems/cycle-length-queries-in-a-tree/submissions/862015999/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*log*N*) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n\\n        for a, b in queries:\\n            moves = 1\\n\\n            while a != b:\\n                if a > b: a//= 2\\n                else    : b//= 2\\n\\n                moves+= 1\\n\\n            ans.append(moves)  \\n              \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923871,
                "title": "c-lca-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> ans;\\n        for (auto &q : queries) {\\n            vector<int> path1 =findpath(q[0]), path2 =findpath(q[1]);\\n\\n            while (!path1.empty() && !path2.empty() && path1.back() == path2.back()) {\\n                path1.pop_back();\\n                path2.pop_back();\\n            }\\n            ans.push_back( 1+path1.size()+path2.size() );\\n        }\\n        return ans;\\n    }\\n    vector<int> findpath(int n) {\\n        vector<int> v;\\n        for ( ;n>0; n/=2)\\n            v.push_back(n);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> ans;\\n        for (auto &q : queries) {\\n            vector<int> path1 =findpath(q[0]), path2 =findpath(q[1]);\\n\\n            while (!path1.empty() && !path2.empty() && path1.back() == path2.back()) {\\n                path1.pop_back();\\n                path2.pop_back();\\n            }\\n            ans.push_back( 1+path1.size()+path2.size() );\\n        }\\n        return ans;\\n    }\\n    vector<int> findpath(int n) {\\n        vector<int> v;\\n        for ( ;n>0; n/=2)\\n            v.push_back(n);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923480,
                "title": "c-lca-o-qn-explained",
                "content": "# Important Properties\\n- There\\'s only one path in Tree between $u$ and $v$.\\n- The Height of complete binary tree is $O(\\\\log{2^n}) = O(n)$.\\n- The Parent of a node $u$ is $\\\\lfloor \\\\frac{u}{2} \\\\rfloor$.\\n- The Depth of a node $u$ is $\\\\lfloor \\\\log_2{u} \\\\rfloor$.\\n\\n# Approach\\n1. Find the LCA (Lowest Common Ancestor): $O(n)$\\n    - Find the Depth of $u$ and $v$\\n    - If $D(u) \\\\ne D(v)$, then the deeper one starts climbing up until $D(u) \\\\ne D(v)$\\n    - If $u = v$, then $u\\\\ (\\\\text{or }v)$ is the LCA\\n    - Otherwise, two nodes start climbing up until $D(u) = D(v)$, then the node them stop is the LCA\\n2. Sum up the length of path from both nodes to LCA: $O(1)$\\n3. $+1$ for the added edge and you got the answer: $O(1)$\\n\\n![image.png](https://assets.leetcode.com/users/images/1cc7be78-877f-4717-b080-3809cd41a7b7_1671338240.8391933.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: $O(QN)$\\n- Space complexity: $O(N)$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> answer;\\n        for ( auto& q : queries ) {\\n            int u = q[0], v = q[1];\\n            \\n            // Find the Depth of u and v\\n            int du = log2(u), dv = log2(v);\\n            int len = 0;\\n            \\n            // Deeper node climbing up\\n            if ( du != dv ) {\\n                if ( du > dv ) {\\n                    swap(du, dv);\\n                    swap(u, v);\\n                }\\n                len += dv-du;\\n                for ( int i=0; i<dv-du; ++i ) {\\n                    v >>= 1;\\n                }\\n            }\\n            \\n            // Both nodes climbing up until equal\\n            while ( u != v ) {\\n                u >>= 1;\\n                v >>= 1;\\n                len += 2;\\n            }\\n            \\n            // + 1 for the added edge forming a cycle\\n            answer.emplace_back(len + 1);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> answer;\\n        for ( auto& q : queries ) {\\n            int u = q[0], v = q[1];\\n            \\n            // Find the Depth of u and v\\n            int du = log2(u), dv = log2(v);\\n            int len = 0;\\n            \\n            // Deeper node climbing up\\n            if ( du != dv ) {\\n                if ( du > dv ) {\\n                    swap(du, dv);\\n                    swap(u, v);\\n                }\\n                len += dv-du;\\n                for ( int i=0; i<dv-du; ++i ) {\\n                    v >>= 1;\\n                }\\n            }\\n            \\n            // Both nodes climbing up until equal\\n            while ( u != v ) {\\n                u >>= 1;\\n                v >>= 1;\\n                len += 2;\\n            }\\n            \\n            // + 1 for the added edge forming a cycle\\n            answer.emplace_back(len + 1);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561640,
                "title": "c-very-simple",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int c;\\n        for(auto &i: queries){\\n            c = 1;//an edge already exits between i[0] and i[1]\\n            while(i[0] != i[1]){//while i[0] != i[1] than there is no end point of end points\\n                if(i[0]>i[1]){\\n                    i[0] >>= 1;\\n                }else{\\n                    i[1] >>= 1;\\n                }\\n                c++;\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int c;\\n        for(auto &i: queries){\\n            c = 1;//an edge already exits between i[0] and i[1]\\n            while(i[0] != i[1]){//while i[0] != i[1] than there is no end point of end points\\n                if(i[0]>i[1]){\\n                    i[0] >>= 1;\\n                }else{\\n                    i[1] >>= 1;\\n                }\\n                c++;\\n            }\\n            ans.push_back(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923632,
                "title": "python-lowest-common-ancestor",
                "content": "To paraphrase: \"What is the distance between two nodes?\"\\n\\nIn order to find distance between two nodes  we need the following information:\\n1. Distance between the first node and the root\\n2. Distance between the second node and the root\\n3. Distance between their LCA and the root\\n\\nTo answer p.1 and p.2 it\\'s enough for us to know depth of node. Since it\\'s a complete binary tree and nodes IDs are always increasing we can just take log base 2\\n\\nFor p.3 we need to find LCA of two nodes first. For this, consider two cases:\\n\\nFirst case is when two nodes are on the same level, here we just need to move the nodes \"up\" by dividing by two until their values are equal\\n![image](https://assets.leetcode.com/users/images/22d4a7c2-7506-4c5c-86cb-b7ac45326f7f_1671337104.926273.png)\\n\\nSecond case is when two nodes are not on the same level. Here we need to equalize depths of the nodes such that first case is applicable.\\n![image](https://assets.leetcode.com/users/images/21cd4c0e-92a3-4141-b63b-e5697c34c638_1671390431.244221.png)\\n\\n\\n\\n\\nTo answer the queries we need the formula:\\n``` Distance between two nodes = Distance from first node to the root  + Distance from second node to the root - 2 * Distance from LCA to the root + 1```\\nWhy -2 * Distance from LCA to the root?\\nConsider this case, see how we are double counting distance of LCA twice? To get the actual distance between two nodes we need to substract this distance twice (see green path)\\n![image](https://assets.leetcode.com/users/images/2b52416f-83ee-4fb8-b4b3-6684242801de_1671338555.16374.png)\\n\\nTime Complexity : ```O(logN * Q)``` , where Q is a length of queries\\nSpace Complexity : ```O(1)```\\n\\n\\nCode\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        \\n        for a, b in queries:\\n\\t\\t\\n\\t\\t\\t# 1. Find distances from nodes a and b to the root\\n            depthA = int(log2(a))\\n            depthB = int(log2(b))\\n            \\n            # 2. If depth of node A is bigger - we move it up\\n\\t\\t\\tfor _ in range(depthA - depthB):\\n                a //= 2\\n                \\n            # 3. Similar to p.2, if depth of node B is bigger - we move it up (either one of these two will trigger)\\n\\t\\t\\tfor _ in range(depthB - depthA):\\n                b //= 2\\n                \\n            # 4. Move up until our nodes will \"meet\" - this will be our LCA\\n\\t\\t\\twhile a != b:\\n                a //= 2\\n                b //= 2\\n                \\n            # 5. Finally, find the distance from LCA to the root and get the result\\n\\t\\t\\tdepthLCA = int(log2(a))\\n            \\n            res.append(depthA + depthB - 2*depthLCA + 1)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` Distance between two nodes = Distance from first node to the root  + Distance from second node to the root - 2 * Distance from LCA to the root + 1```\n```O(logN * Q)```\n```O(1)```\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        \\n        for a, b in queries:\\n\\t\\t\\n\\t\\t\\t# 1. Find distances from nodes a and b to the root\\n            depthA = int(log2(a))\\n            depthB = int(log2(b))\\n            \\n            # 2. If depth of node A is bigger - we move it up\\n\\t\\t\\tfor _ in range(depthA - depthB):\\n                a //= 2\\n                \\n            # 3. Similar to p.2, if depth of node B is bigger - we move it up (either one of these two will trigger)\\n\\t\\t\\tfor _ in range(depthB - depthA):\\n                b //= 2\\n                \\n            # 4. Move up until our nodes will \"meet\" - this will be our LCA\\n\\t\\t\\twhile a != b:\\n                a //= 2\\n                b //= 2\\n                \\n            # 5. Finally, find the distance from LCA to the root and get the result\\n\\t\\t\\tdepthLCA = int(log2(a))\\n            \\n            res.append(depthA + depthB - 2*depthLCA + 1)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923536,
                "title": "short-clean-friendly-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] count = new int[queries.length];\\n        for(int i=0; i<queries.length; i++){\\n            count[i] += dis(queries[i][0], queries[i][1]);\\n        }\\n        return count;\\n    }\\n    private int dis(int n1, int n2){\\n        int count = 0;\\n        while(n1 != n2){\\n            if(n1 > n2) n1 /= 2;\\n            else    n2 /= 2;\\n            count++;\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] count = new int[queries.length];\\n        for(int i=0; i<queries.length; i++){\\n            count[i] += dis(queries[i][0], queries[i][1]);\\n        }\\n        return count;\\n    }\\n    private int dis(int n1, int n2){\\n        int count = 0;\\n        while(n1 != n2){\\n            if(n1 > n2) n1 /= 2;\\n            else    n2 /= 2;\\n            count++;\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923493,
                "title": "c-lowest-common-ancestor-explanation-o-m-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the lowest common ancestor of the two nodes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe parent node has the value `val / 2`, this is the internal implementation of a heap.\\n\\nKeep traversing up the node with the smaller `val` until both nodes are at the same node (lowest common ancestor). Increment a counter to track height. Add a constant `1` to account for the added edge.\\n\\n# Complexity\\n- Time complexity: O(M log N)\\n\\nFor each `M` query, travel up the binary tree for both nodes which is `2 * log N`. \\n\\n- Space complexity: O(M)\\n\\nFor the output vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for (vector<int>& query : queries) {\\n            int edges = 0;\\n            int x = query[0], y = query[1];\\n            while (x != y) {\\n                if (x > y) {\\n                    x /= 2;\\n                } else {\\n                    y /= 2;\\n                }\\n                ++edges;\\n            }            \\n            ans.push_back(edges + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for (vector<int>& query : queries) {\\n            int edges = 0;\\n            int x = query[0], y = query[1];\\n            while (x != y) {\\n                if (x > y) {\\n                    x /= 2;\\n                } else {\\n                    y /= 2;\\n                }\\n                ++edges;\\n            }            \\n            ans.push_back(edges + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412501,
                "title": "c-short-sweet-easy-to-understand-very-simple-lca",
                "content": "/* no of bit = 1 <- level 1\\nno of bit = 2 <- level 2\\nno of bit = 3 <- level 3\\n.....\\n*/\\n\\n````\\nclass Solution {\\npublic:\\n    int bitcnt(int a){\\n        int x = 0;\\n        while(a){\\n            x++;\\n            a >>= 1;\\n        }\\n        return x;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int x = 0;\\n        for(auto &i: queries){\\n            x = 1;\\n            while(bitcnt(i[0]) != bitcnt(i[1])){// move right max no untill both number don\\'t have same count of bit\\n                x++;//ony one number\\'s bit shift in right directions\\n                if(bitcnt(i[0]) > bitcnt(i[1])){\\n                    i[0] >>= 1;\\n                }else{\\n                    i[1] >>= 1;\\n                }\\n            }\\n            while(i[0] != i[1]){// while both no dont same shift both nos in right direction by one bit\\n                x += 2;//shifting both nos increment ans by 1\\n                i[0] >>= 1;\\n                i[1] >>= 1;\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int bitcnt(int a){\\n        int x = 0;\\n        while(a){\\n            x++;\\n            a >>= 1;\\n        }\\n        return x;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int x = 0;\\n        for(auto &i: queries){\\n            x = 1;\\n            while(bitcnt(i[0]) != bitcnt(i[1])){// move right max no untill both number don\\'t have same count of bit\\n                x++;//ony one number\\'s bit shift in right directions\\n                if(bitcnt(i[0]) > bitcnt(i[1])){\\n                    i[0] >>= 1;\\n                }else{\\n                    i[1] >>= 1;\\n                }\\n            }\\n            while(i[0] != i[1]){// while both no dont same shift both nos in right direction by one bit\\n                x += 2;//shifting both nos increment ans by 1\\n                i[0] >>= 1;\\n                i[1] >>= 1;\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923674,
                "title": "c-common-ancestor-tree-simulation",
                "content": "# Intuition\\nSince the tree follows a familiar pattern we don\\'t have to make the tree. We find the common ancestor of the two nodes and then we add the distances from that node to get the answer. \\n\\n# Approach\\nWhen we get the two numbers from the query we check if one of them is the root of the tree (that is 1 , edge case) we will simply add 1 to the distance of the other node to get the answer.\\nOtherwise we will find the common ancestor and the sum of distances from the common ancestor + 1 would be the ans to that query.\\n\\nWe used call by reference since we cannot pass 2 values in c++;\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void lca(int &a , int &b)\\n    {\\n        vector<int> pa;\\n        \\n        while(a>=1)\\n        {\\n            pa.push_back(a);\\n            a/=2;\\n        }\\n        \\n        vector<int> pb;\\n        \\n        while(b >= 1)\\n        {\\n            pb.push_back(b);\\n            b/=2;\\n        }\\n        \\n        int i = pa.size() - 1, j = pb.size() - 1;\\n        \\n        \\n        while(pa[i] == pb[j])\\n        {\\n            if(i == 0 || j == 0)\\n            {\\n                a=i;b=j;\\n                return;\\n            }\\n            i--;\\n            j--;\\n        }                                                                  \\n        i++;j++;\\n        a=i;b=j;\\n    }\\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int i = 0;\\n        for(auto it : queries)\\n        {\\n            if(it[0] == 1)\\n            {\\n                int c = 0;\\n                while(it[1] >= 1)\\n                {\\n                    c++;\\n                    it[1]/=2;\\n                }\\n                \\n                ans.push_back(c);\\n            }\\n            else if(it[1] == 1)\\n            {  \\n                int c = 0;\\n                while(it[0] >= 1)\\n                {\\n                    c++;\\n                    it[0]/=2;\\n                }\\n                \\n                ans.push_back(c);\\n            }\\n            \\n            else\\n            {\\n             lca(it[0] , it[1]);\\n             ans.push_back(it[0] + it[1] + 1);\\n            }\\n            cout<<ans[i++]<<endl;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void lca(int &a , int &b)\\n    {\\n        vector<int> pa;\\n        \\n        while(a>=1)\\n        {\\n            pa.push_back(a);\\n            a/=2;\\n        }\\n        \\n        vector<int> pb;\\n        \\n        while(b >= 1)\\n        {\\n            pb.push_back(b);\\n            b/=2;\\n        }\\n        \\n        int i = pa.size() - 1, j = pb.size() - 1;\\n        \\n        \\n        while(pa[i] == pb[j])\\n        {\\n            if(i == 0 || j == 0)\\n            {\\n                a=i;b=j;\\n                return;\\n            }\\n            i--;\\n            j--;\\n        }                                                                  \\n        i++;j++;\\n        a=i;b=j;\\n    }\\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        int i = 0;\\n        for(auto it : queries)\\n        {\\n            if(it[0] == 1)\\n            {\\n                int c = 0;\\n                while(it[1] >= 1)\\n                {\\n                    c++;\\n                    it[1]/=2;\\n                }\\n                \\n                ans.push_back(c);\\n            }\\n            else if(it[1] == 1)\\n            {  \\n                int c = 0;\\n                while(it[0] >= 1)\\n                {\\n                    c++;\\n                    it[0]/=2;\\n                }\\n                \\n                ans.push_back(c);\\n            }\\n            \\n            else\\n            {\\n             lca(it[0] , it[1]);\\n             ans.push_back(it[0] + it[1] + 1);\\n            }\\n            cout<<ans[i++]<<endl;\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2923474,
                "title": "python-c-o-mn-time-find-common-ancestor-with-explanation",
                "content": "The description of the problem is quite long but you basically need to find to the common ancestor of nodes in each query.\\nThe problem is very similar to https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/\\n\\nHere we do not even need to track parents for each child (and use dict as in the similar problem) because we know that each child is either `2 * val` or `2 * val + 1`. So, for each query we try to find an ancestor by dividing by 2 the node with larger value. Meanwhile, we also track the number of steps to reach the ancestor.\\n\\n*Time complexity*: `O(mn)`, where m is the size of `queries`\\n*Space complexity*: `O(m)` to store the result\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for p, q in queries:\\n            path = 0\\n            while p != q:\\n                path += 1\\n                if p > q:\\n                    p >>= 1\\n                else:\\n                    q >>= 1\\n            ans.append(path + 1) # to account for path between p and q\\n        return ans\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> res(queries.size(), 0);\\n        for (int i = 0; i < (int) queries.size(); ++i) {\\n            int p = queries[i][0];\\n            int q = queries[i][1];\\n            int path = 0;\\n            while (p != q) {\\n                ++path;\\n                if (p > q)\\n                    p >>= 1;\\n                else\\n                    q >>= 1;\\n            }\\n            res[i] = path + 1; // to account for path between p and q\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for p, q in queries:\\n            path = 0\\n            while p != q:\\n                path += 1\\n                if p > q:\\n                    p >>= 1\\n                else:\\n                    q >>= 1\\n            ans.append(path + 1) # to account for path between p and q\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> res(queries.size(), 0);\\n        for (int i = 0; i < (int) queries.size(); ++i) {\\n            int p = queries[i][0];\\n            int q = queries[i][1];\\n            int path = 0;\\n            while (p != q) {\\n                ++path;\\n                if (p > q)\\n                    p >>= 1;\\n                else\\n                    q >>= 1;\\n            }\\n            res[i] = path + 1; // to account for path between p and q\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927843,
                "title": "c-lowest-common-ancestor-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCycle path will always contain nodes between both qeury nodes and their Lowest Common Ancestor (all inclusive). We need to just find the length of cycle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make use of the Lowest Common Ancestor algorithm and keep track of number of edges traversed to reach the ancestors from both query nodes.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(auto query : queries) {\\n            int a = query[0], b = query[1], alen = 0, blen = 0;\\n            while(a != b) {\\n                while(a > b) {\\n                    a /= 2;\\n                    alen += 1;\\n                }\\n                while(b > a) {\\n                    b /= 2;\\n                    blen += 1;\\n                }\\n            }\\n            res.push_back((alen + blen ) > 0 ? alen + blen + 1 : 0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(auto query : queries) {\\n            int a = query[0], b = query[1], alen = 0, blen = 0;\\n            while(a != b) {\\n                while(a > b) {\\n                    a /= 2;\\n                    alen += 1;\\n                }\\n                while(b > a) {\\n                    b /= 2;\\n                    blen += 1;\\n                }\\n            }\\n            res.push_back((alen + blen ) > 0 ? alen + blen + 1 : 0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925073,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] res = new int[queries.length];\\n        int ind = 0;\\n        for(int[] q: queries) {\\n            int lca = findLCA(q[0], q[1]);\\n            res[ind++] = findDist(q[0]) - findDist(lca) + findDist(q[1]) - findDist(lca) + 1;\\n        }\\n        return res;\\n        \\n        \\n    }\\n    public static int findLCA(int u, int v) {  \\n        int max = Math.max(u,v);\\n        int min = Math.min(u,v);\\n        HashSet<Integer> hset = new HashSet<>();\\n        while(max != 0) {\\n            hset.add(max);\\n            max = max/2;\\n        }\\n        while(min != 0) {\\n            if(hset.contains(min)) return min;\\n            min = min/2;\\n        }\\n        return 1;  \\n    }\\n    public static int findDist(int num) {\\n         int mssb = 0;\\n         while(num > 0) {\\n             num = num>>1;\\n             mssb++;\\n         }\\n        return mssb;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] res = new int[queries.length];\\n        int ind = 0;\\n        for(int[] q: queries) {\\n            int lca = findLCA(q[0], q[1]);\\n            res[ind++] = findDist(q[0]) - findDist(lca) + findDist(q[1]) - findDist(lca) + 1;\\n        }\\n        return res;\\n        \\n        \\n    }\\n    public static int findLCA(int u, int v) {  \\n        int max = Math.max(u,v);\\n        int min = Math.min(u,v);\\n        HashSet<Integer> hset = new HashSet<>();\\n        while(max != 0) {\\n            hset.add(max);\\n            max = max/2;\\n        }\\n        while(min != 0) {\\n            if(hset.contains(min)) return min;\\n            min = min/2;\\n        }\\n        return 1;  \\n    }\\n    public static int findDist(int num) {\\n         int mssb = 0;\\n         while(num > 0) {\\n             num = num>>1;\\n             mssb++;\\n         }\\n        return mssb;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923686,
                "title": "lca-using-math",
                "content": "# Intuition\\nparent : `n / 2`\\nlevel : `log2(n)`\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(q * n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(abs(la - lb)))`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int level(int n) {\\n        return log2(n);\\n    }\\n    int move(int n, int l) {\\n        if(level(n) == l)\\n            return n;\\n        return move(n / 2, l);\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(vector<int>& q: queries) {\\n            int node = 1;\\n            int a = q[0], b = q[1];\\n            int la = level(a), lb = level(b);\\n            if(la < lb) {\\n                b = move(b, la);\\n                node += lb - la;\\n            }\\n            else {\\n                a = move(a, lb);\\n                node += la - lb;\\n            }\\n            while(a != b) {\\n                node += 2;\\n                a = a / 2;\\n                b = b / 2;\\n            }\\n            res.push_back(node);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int level(int n) {\\n        return log2(n);\\n    }\\n    int move(int n, int l) {\\n        if(level(n) == l)\\n            return n;\\n        return move(n / 2, l);\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(vector<int>& q: queries) {\\n            int node = 1;\\n            int a = q[0], b = q[1];\\n            int la = level(a), lb = level(b);\\n            if(la < lb) {\\n                b = move(b, la);\\n                node += lb - la;\\n            }\\n            else {\\n                a = move(a, lb);\\n                node += la - lb;\\n            }\\n            while(a != b) {\\n                node += 2;\\n                a = a / 2;\\n                b = b / 2;\\n            }\\n            res.push_back(node);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923550,
                "title": "cpp-lca",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto v:queries) {\\n            int par = 1;\\n            bool isPar = false;\\n            int u1=min(v[0],v[1]);\\n            int u2=max(v[0],v[1]);\\n            unordered_set<int> st;\\n            while(u1) {\\n                u1/=2;\\n                st.insert(u1);\\n            }\\n            while(u2) {\\n                u2/=2;\\n                if(u2 == min(v[0],v[1])) {\\n                    isPar = true;break;\\n                }\\n                if(st.count(u2)) {\\n                    break;\\n                }\\n            }\\n            if(isPar) {\\n                ans.push_back(floor(log2(max(v[0],v[1]))) - floor(log2(min(v[0],v[1]))) + 1);\\n            }\\n            else ans.push_back(floor(log2(v[0])) + floor(log2(v[1])) + 1 - 2 * floor(log2(u2)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto v:queries) {\\n            int par = 1;\\n            bool isPar = false;\\n            int u1=min(v[0],v[1]);\\n            int u2=max(v[0],v[1]);\\n            unordered_set<int> st;\\n            while(u1) {\\n                u1/=2;\\n                st.insert(u1);\\n            }\\n            while(u2) {\\n                u2/=2;\\n                if(u2 == min(v[0],v[1])) {\\n                    isPar = true;break;\\n                }\\n                if(st.count(u2)) {\\n                    break;\\n                }\\n            }\\n            if(isPar) {\\n                ans.push_back(floor(log2(max(v[0],v[1]))) - floor(log2(min(v[0],v[1]))) + 1);\\n            }\\n            else ans.push_back(floor(log2(v[0])) + floor(log2(v[1])) + 1 - 2 * floor(log2(u2)));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923498,
                "title": "java-lowest-common-ancesor-o-log-n",
                "content": "**Observation**\\nWe can get a parent of a node by deviding node\\'s value by 2.\\nLowest Common Ancesor is the root of the cycle we are looking for.\\n\\n\\n**Algorithm**\\n1. Get paths from the first and the second nodes to the root.\\n2. Remove duplicates from the both paths.\\n3. Nodes that left in the paths plus the one last duplicate form the cycle.\\n\\n\\n```\\npublic int[] cycleLengthQueries(int n, int[][] queries) {\\n\\tvar res = new int[queries.length];\\n\\t\\n\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\tvar a = getRootPath(queries[i][0]);\\n\\t\\tvar b = getRootPath(queries[i][1]);\\n\\t\\twhile (a.size() > 0 && b.size() > 0 && a.get(a.size() - 1).equals(b.get(b.size() - 1))) {\\n\\t\\t\\ta.remove(a.size() - 1);\\n\\t\\t\\tb.remove(b.size() - 1);\\n\\t\\t}\\n\\t\\tres[i] = a.size() + b.size() + 1;\\n\\t}\\n\\t\\n\\treturn res;\\n}\\n\\nprivate List<Integer> getRootPath(int u) {\\n\\tvar path = new ArrayList<Integer>();\\n\\twhile (u != 0) {\\n\\t\\tpath.add(u);\\n\\t\\tu /= 2;\\n\\t}\\n\\treturn path;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] cycleLengthQueries(int n, int[][] queries) {\\n\\tvar res = new int[queries.length];\\n\\t\\n\\tfor (int i = 0; i < res.length; i++) {\\n\\t\\tvar a = getRootPath(queries[i][0]);\\n\\t\\tvar b = getRootPath(queries[i][1]);\\n\\t\\twhile (a.size() > 0 && b.size() > 0 && a.get(a.size() - 1).equals(b.get(b.size() - 1))) {\\n\\t\\t\\ta.remove(a.size() - 1);\\n\\t\\t\\tb.remove(b.size() - 1);\\n\\t\\t}\\n\\t\\tres[i] = a.size() + b.size() + 1;\\n\\t}\\n\\t\\n\\treturn res;\\n}\\n\\nprivate List<Integer> getRootPath(int u) {\\n\\tvar path = new ArrayList<Integer>();\\n\\twhile (u != 0) {\\n\\t\\tpath.add(u);\\n\\t\\tu /= 2;\\n\\t}\\n\\treturn path;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905467,
                "title": "c-o-n-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(int x,int y,int n)\\n    {\\n        int x1=-1,y1=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(x&(1<<i))\\n            {\\n                x1=i;\\n            }\\n            if(y&(1<<i))\\n            {\\n                y1=i;\\n            }\\n        }\\n        int ans=0;\\n        if(y1>x1)\\n        {\\n            while(y1!=x1)\\n            {\\n                ans++;\\n                y/=2;\\n                y1--;\\n            }\\n            while(x!=y)\\n            {\\n                ans+=2;\\n                y/=2;\\n                x/=2;\\n            }\\n        }\\n        else{\\n            while(y1!=x1)\\n            {\\n                ans++;\\n                x/=2;\\n                x1--;\\n            }\\n            while(x!=y)\\n            {\\n                ans+=2;\\n                y/=2;\\n                x/=2;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto i:queries)\\n        {\\n            int u=i[0];\\n            int v=i[1];\\n            int t=fun(u,v,n);\\n            ans.push_back(t+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int x,int y,int n)\\n    {\\n        int x1=-1,y1=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(x&(1<<i))\\n            {\\n                x1=i;\\n            }\\n            if(y&(1<<i))\\n            {\\n                y1=i;\\n            }\\n        }\\n        int ans=0;\\n        if(y1>x1)\\n        {\\n            while(y1!=x1)\\n            {\\n                ans++;\\n                y/=2;\\n                y1--;\\n            }\\n            while(x!=y)\\n            {\\n                ans+=2;\\n                y/=2;\\n                x/=2;\\n            }\\n        }\\n        else{\\n            while(y1!=x1)\\n            {\\n                ans++;\\n                x/=2;\\n                x1--;\\n            }\\n            while(x!=y)\\n            {\\n                ans+=2;\\n                y/=2;\\n                x/=2;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto i:queries)\\n        {\\n            int u=i[0];\\n            int v=i[1];\\n            int t=fun(u,v,n);\\n            ans.push_back(t+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340716,
                "title": "michael-scott-says-he-did-this-in-java-using-lowest-common-ancestor",
                "content": "# Intuition\\nMichael is busy at the moment. This is Dwight Schrute, Assistant Regional Manager. I\\'ll explain the code in detai- ohh no Jim put my mouse in Jell-O again brb, MICHAEL!!! MICHAEL!!!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        \\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int a = (int)(Math.log(queries[i][0])/Math.log(2));\\n            int b = (int)(Math.log(queries[i][1])/Math.log(2));\\n            // System.out.println(\"Level \"+a+\" and \"+b);\\n            int suma=0,sumb=0;\\n            int para=queries[i][0],parb=queries[i][1];\\n            if(a>b)\\n            {\\n                for(int j=0;j<a-b;j++)\\n                {\\n                    suma++;\\n                    para=(int)para/2;\\n                }\\n            }\\n            else if(b>a)\\n            {\\n                for(int j=0;j<b-a;j++)\\n                {\\n                    sumb++;\\n                    parb=(int)parb/2;\\n                }\\n            }\\n            // System.out.println(\"Same level at \"+a+\" and \"+b);\\n            for(int j=0;j<Math.min(a,b);j++)\\n            {\\n                // System.out.println(\"Curr node \"+para+\" and \"+parb);\\n                if(para==parb)\\n                {\\n                    break;\\n                }\\n                para=(int)para/2;\\n                parb=(int)parb/2;\\n                suma++;\\n                sumb++;\\n            }\\n            ans[i]=suma+sumb+1;\\n        }\\n        return ans;\\n\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] ans = new int[queries.length];\\n        \\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int a = (int)(Math.log(queries[i][0])/Math.log(2));\\n            int b = (int)(Math.log(queries[i][1])/Math.log(2));\\n            // System.out.println(\"Level \"+a+\" and \"+b);\\n            int suma=0,sumb=0;\\n            int para=queries[i][0],parb=queries[i][1];\\n            if(a>b)\\n            {\\n                for(int j=0;j<a-b;j++)\\n                {\\n                    suma++;\\n                    para=(int)para/2;\\n                }\\n            }\\n            else if(b>a)\\n            {\\n                for(int j=0;j<b-a;j++)\\n                {\\n                    sumb++;\\n                    parb=(int)parb/2;\\n                }\\n            }\\n            // System.out.println(\"Same level at \"+a+\" and \"+b);\\n            for(int j=0;j<Math.min(a,b);j++)\\n            {\\n                // System.out.println(\"Curr node \"+para+\" and \"+parb);\\n                if(para==parb)\\n                {\\n                    break;\\n                }\\n                para=(int)para/2;\\n                parb=(int)parb/2;\\n                suma++;\\n                sumb++;\\n            }\\n            ans[i]=suma+sumb+1;\\n        }\\n        return ans;\\n\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333568,
                "title": "java-easy-solution-simple-logic",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     public int[] cycleLengthQueries(int n, int[][] queries) {\\n     int[] result = new int[queries.length];\\n     int i = 0;\\n        for(int[] arr :queries){\\n            int n1 = arr[0];\\n            int n2 = arr[1];\\n            int count = 2;\\n             while(n1 != n2){\\n                if(n1 > n2){\\n                   n1 = n1>>1;\\n                }\\n                else{\\n                   n2 = n2>>1;\\n                }\\n                count++;\\n            }\\n            result[i++]=count-1;\\n        }\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int[] cycleLengthQueries(int n, int[][] queries) {\\n     int[] result = new int[queries.length];\\n     int i = 0;\\n        for(int[] arr :queries){\\n            int n1 = arr[0];\\n            int n2 = arr[1];\\n            int count = 2;\\n             while(n1 != n2){\\n                if(n1 > n2){\\n                   n1 = n1>>1;\\n                }\\n                else{\\n                   n2 = n2>>1;\\n                }\\n                count++;\\n            }\\n            result[i++]=count-1;\\n        }\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124485,
                "title": "python-find-the-lowest-common-parent-explained",
                "content": "At the first glance, this problem looks like the one that finds the path length between two nodes of a tree.\\n\\nTo solve the queries (10^5) efficently, we need to traverse the tree and find out the length between all pairs of nodes, and store them in a hasp map. However, the data set (2^n) in this problem is big, which is impossible to store all the length values in memory.\\n\\nOne good thing about this problem is: this is a complete binary tree with the children values = `2n`, and `2n + 1`\\n\\nTherefore, we can easiy use the bitwise shift operations to find all the parents of a node. During this process, we just need to check the parents of the two nodes. Once we find the first common parent, we can stop and calculate the path length between the two nodes.\\n\\nSee the code for details.\\n\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        # Straightforward solutioin:\\n        # Using DFS to traverse the tree, and find out the path length between any two nodes.\\n        # Record the path length in a hash map and.\\n        # The query can be served at O(1) time complexity.\\n        # However, we need O(2^n) memory spaces.\\n        # ====================================================\\n        # We need an efficent method to calculate:\\n        # 1) the level of each node in the query;\\n        # 2) the common parent of the two nodes in a query.\\n        ans = []\\n        for a, b in queries:\\n            ans.append(self.findPathLength(a, b))\\n        return ans\\n        \\n    def findPathLength(self, a, b):\\n        if b < a:\\n            a, b = b, a\\n        path_a = {a: 0}\\n        pa_len, pb_len, ans = 0, 0, 0\\n        while b:\\n            if b in path_a:\\n                # we have found the common parent,\\n                # the a -> b path length == len(a -> common parent) + len(b -> common parent)\\n                # \"+1\" is for the extra edge from query\\n                ans = path_a[b] + pb_len + 1\\n                break\\n\\n            if a > 1:\\n                a = a >> 1\\n                pa_len += 1\\n                path_a[a] = pa_len\\n\\n            b = b >> 1\\n            pb_len += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        # Straightforward solutioin:\\n        # Using DFS to traverse the tree, and find out the path length between any two nodes.\\n        # Record the path length in a hash map and.\\n        # The query can be served at O(1) time complexity.\\n        # However, we need O(2^n) memory spaces.\\n        # ====================================================\\n        # We need an efficent method to calculate:\\n        # 1) the level of each node in the query;\\n        # 2) the common parent of the two nodes in a query.\\n        ans = []\\n        for a, b in queries:\\n            ans.append(self.findPathLength(a, b))\\n        return ans\\n        \\n    def findPathLength(self, a, b):\\n        if b < a:\\n            a, b = b, a\\n        path_a = {a: 0}\\n        pa_len, pb_len, ans = 0, 0, 0\\n        while b:\\n            if b in path_a:\\n                # we have found the common parent,\\n                # the a -> b path length == len(a -> common parent) + len(b -> common parent)\\n                # \"+1\" is for the extra edge from query\\n                ans = path_a[b] + pb_len + 1\\n                break\\n\\n            if a > 1:\\n                a = a >> 1\\n                pa_len += 1\\n                path_a[a] = pa_len\\n\\n            b = b >> 1\\n            pb_len += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993929,
                "title": "short-concise-solution-log-n-per-query",
                "content": "# Approach\\nThis is one of those **hard** rated problems that are hard purely because they require you to make a few non-trivial observations during the contest. The idea is pretty simple but took some time to come up with during the contest. If you think about it, if we add an edge between nodes $u$ and nodes $v$ our cycle must involve the lowest common ancestor (LCA) of $u$ and $v$. So, we are simply interested in the distance between the LCA of $u$ and $v$ to the nodes respectively. Using the fact that we are dealing with a complete binary tree, we can handle each query in $O(\\\\log_{2} n)$ time worst-case, which is fine for the constraints that we have.\\n\\nNote in the below code that we can replace int(v/2) with v //= 2. The logic for this is that 5//2 = 2 and 4//2, so we can traverse from the node to its parent regardless of whether the value of the node is even or odd.\\n\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        res = []\\n        for u, v in queries:\\n            count = 0\\n            while u != v:\\n                if u < v:\\n                    v = int(v/2)\\n                else:\\n                    u = int(u/2)\\n                count += 1\\n            res.append(count + 1)\\n        return res\\n     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        res = []\\n        for u, v in queries:\\n            count = 0\\n            while u != v:\\n                if u < v:\\n                    v = int(v/2)\\n                else:\\n                    u = int(u/2)\\n                count += 1\\n            res.append(count + 1)\\n        return res\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948872,
                "title": "c-short-solution-lca",
                "content": "```Observation : The cycle\\'s length will be equal to distance between the two nodes + 1```\\n\\nWhole problem rests on the notion of Lowest Common Ancestor.\\nSee : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/\\n\\n```\\nclass Solution {\\npublic:\\n    int height(int node){\\n        //height h has nodes numbered from 2**(h-1) to 2**h - 1.\\n        //i.e. h = most significant set bit\\'s position,1-based indexing.\\n        int h;\\n        for(int i=31;i>0;i--){\\n            if((node&(1<<i))!=0){h=i;break;}\\n        }\\n        return h;\\n    }\\n    int lca(int x,int y){\\n        if(height(y)>height(x)){\\n            swap(x,y);\\n        }\\n        int p = height(x)-height(y);\\n        x=x/pow(2,p);\\n        while(x!=y){\\n            x=x/2;\\n            y=y/2;\\n        }\\n        return x;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        int m = q.size();\\n        vector<int> ans(m);\\n        for(int i=0;i<m;i++){\\n            int a = q[i][0],b = q[i][1];\\n            ans[i] = height(a)+height(b)-2*height(lca(a,b))+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```Observation : The cycle\\'s length will be equal to distance between the two nodes + 1```\n```\\nclass Solution {\\npublic:\\n    int height(int node){\\n        //height h has nodes numbered from 2**(h-1) to 2**h - 1.\\n        //i.e. h = most significant set bit\\'s position,1-based indexing.\\n        int h;\\n        for(int i=31;i>0;i--){\\n            if((node&(1<<i))!=0){h=i;break;}\\n        }\\n        return h;\\n    }\\n    int lca(int x,int y){\\n        if(height(y)>height(x)){\\n            swap(x,y);\\n        }\\n        int p = height(x)-height(y);\\n        x=x/pow(2,p);\\n        while(x!=y){\\n            x=x/2;\\n            y=y/2;\\n        }\\n        return x;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        int m = q.size();\\n        vector<int> ans(m);\\n        for(int i=0;i<m;i++){\\n            int a = q[i][0],b = q[i][1];\\n            ans[i] = height(a)+height(b)-2*height(lca(a,b))+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935827,
                "title": "c-easiest-logic-by-finding-lca-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        for(auto it:queries)\\n        {\\n            int x=it[0],y=it[1],cnt=0;;\\n            while(x!=y)//since its a complete binary tree and we are given left contains 2*val and right contains 2*val+1\\n\\t\\t\\t\\t{            //therefore dividing by 2 gives the nodes  parent and then we keep on dividing until both x and y are equal we need \\n                if(x>y) //to stop at this point as we get the desired lca\\n                    x/=2;\\n                else y/=2;\\n                cnt++;\\n            }\\n            v.push_back(cnt+1);//we need to do cnt+1 since there is an edge between it[0] and it[1]\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        for(auto it:queries)\\n        {\\n            int x=it[0],y=it[1],cnt=0;;\\n            while(x!=y)//since its a complete binary tree and we are given left contains 2*val and right contains 2*val+1\\n\\t\\t\\t\\t{            //therefore dividing by 2 gives the nodes  parent and then we keep on dividing until both x and y are equal we need \\n                if(x>y) //to stop at this point as we get the desired lca\\n                    x/=2;\\n                else y/=2;\\n                cnt++;\\n            }\\n            v.push_back(cnt+1);//we need to do cnt+1 since there is an edge between it[0] and it[1]\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933020,
                "title": "lowest-common-ancestor-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        // 2 ^ (level + 1) - 1;\\n        int l = queries.length;\\n        int [] ans = new int[l];\\n        int i = 0;\\n        for(int []a:queries){\\n            int first = a[0],second = a[1];\\n            int level1 = findLevel(first);\\n            int level2 = findLevel(second);\\n            int root = findCommonRoot(first,second);\\n            int rootLevel = findLevel2(root);\\n            ans[i] = level1 + level2 - 2*rootLevel + 1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n     public int findLevel2(int a){\\n        int count = 0,two = 1;\\n        while(two<=a){\\n            two*=2;\\n            count++;\\n        }\\n        return count;\\n    }\\n    public int findLevel(int a){\\n        int count = 0,two = 1;\\n        while(two<=a){\\n            two*=2;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public int findCommonRoot(int first,int second){\\n        HashSet<Integer> rootsOfFirst = new HashSet<>();\\n        while(first!=0){\\n            rootsOfFirst.add(first);\\n            first/=2;\\n        }\\n        while(second!=0){\\n            if(rootsOfFirst.contains(second))return second;\\n            second/=2;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        // 2 ^ (level + 1) - 1;\\n        int l = queries.length;\\n        int [] ans = new int[l];\\n        int i = 0;\\n        for(int []a:queries){\\n            int first = a[0],second = a[1];\\n            int level1 = findLevel(first);\\n            int level2 = findLevel(second);\\n            int root = findCommonRoot(first,second);\\n            int rootLevel = findLevel2(root);\\n            ans[i] = level1 + level2 - 2*rootLevel + 1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n     public int findLevel2(int a){\\n        int count = 0,two = 1;\\n        while(two<=a){\\n            two*=2;\\n            count++;\\n        }\\n        return count;\\n    }\\n    public int findLevel(int a){\\n        int count = 0,two = 1;\\n        while(two<=a){\\n            two*=2;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    public int findCommonRoot(int first,int second){\\n        HashSet<Integer> rootsOfFirst = new HashSet<>();\\n        while(first!=0){\\n            rootsOfFirst.add(first);\\n            first/=2;\\n        }\\n        while(second!=0){\\n            if(rootsOfFirst.contains(second))return second;\\n            second/=2;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930697,
                "title": "concise-c-solution-in-o-queries-length",
                "content": "# Intuition\\nComplete binary tree - height of node is log2(value of node) \\n\\n# Approach\\n1. Find LCA\\n2. Find height of nodes\\n3. Add (2) - Height of LCA + 1\\n\\n# Complexity\\n- Time complexity: O(m)\\n\\n- Space complexity: O(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n\\n        for(auto &i : queries) {\\n            int l = i[0], r = i[1];\\n            // here we find height of the nodes in query\\n            while(l>0 && r>0 && l!=r) {\\n                if(l>r) l/=2;\\n                else r/=2;\\n            }\\n            //here we add the individual heights + 1 and subtract the height of the common ancestor\\n            v.push_back((int)log2(i[0]) + (int)log2(i[1]) + 1 - 2*(int)log2(l));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n\\n        for(auto &i : queries) {\\n            int l = i[0], r = i[1];\\n            // here we find height of the nodes in query\\n            while(l>0 && r>0 && l!=r) {\\n                if(l>r) l/=2;\\n                else r/=2;\\n            }\\n            //here we add the individual heights + 1 and subtract the height of the common ancestor\\n            v.push_back((int)log2(i[0]) + (int)log2(i[1]) + 1 - 2*(int)log2(l));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930695,
                "title": "concise-c-solution-in-o-queries-length",
                "content": "# Intuition\\nComplete binary tree - height of node is log2(value of node) \\n\\n# Approach\\n1. Find LCA\\n2. Find height of nodes\\n3. Add (2) - Height of LCA + 1\\n\\n# Complexity\\n- Time complexity: O(m)\\n\\n- Space complexity: O(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n\\n        for(auto &i : queries) {\\n            int l = i[0], r = i[1];\\n            // here we find height of the nodes in query\\n            while(l>0 && r>0 && l!=r) {\\n                if(l>r) l/=2;\\n                else r/=2;\\n            }\\n            //here we add the individual heights + 1 and subtract the height of the common ancestor\\n            v.push_back((int)log2(i[0]) + (int)log2(i[1]) + 1 - 2*(int)log2(l));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n\\n        for(auto &i : queries) {\\n            int l = i[0], r = i[1];\\n            // here we find height of the nodes in query\\n            while(l>0 && r>0 && l!=r) {\\n                if(l>r) l/=2;\\n                else r/=2;\\n            }\\n            //here we add the individual heights + 1 and subtract the height of the common ancestor\\n            v.push_back((int)log2(i[0]) + (int)log2(i[1]) + 1 - 2*(int)log2(l));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927222,
                "title": "easy-c-lca",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNotice how the answer is the sum of distances of both the nodes from their common ancestor + 1 (extra edge for the loop).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDividing by two give the parent node. Thus the number of times we can divide the node till it reaches LCA gives the distance from the node.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n- Space complexity: $$O(n)$$ (for the array of answer else $$O(1)$$)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int q=queries.size(), i, j;\\n        vector<int> ans(q);\\n\\n        for(j=0; j<q; j++){\\n            int a=0, b=0, x=queries[j][0], y=queries[j][1];\\n\\n            while(x != y){\\n                if(x > y){\\n                    a++;\\n                    x /= 2;\\n                }\\n                else{\\n                    b++;\\n                    y /= 2;\\n                }\\n            }\\n\\n            ans[j] = a + b + 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int q=queries.size(), i, j;\\n        vector<int> ans(q);\\n\\n        for(j=0; j<q; j++){\\n            int a=0, b=0, x=queries[j][0], y=queries[j][1];\\n\\n            while(x != y){\\n                if(x > y){\\n                    a++;\\n                    x /= 2;\\n                }\\n                else{\\n                    b++;\\n                    y /= 2;\\n                }\\n            }\\n\\n            ans[j] = a + b + 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925903,
                "title": "extremely-simple-and-intuitive-lca-java-solution-o-1-space-beats-100-of-solutions-runtime",
                "content": "# Intuition\\n1. We need to find the LCA.  We can do this by counting the number of divisions from each number in the query until they equal each other\\n\\n# Approach\\nSimply divide by 2 until the numbers equal each other.  Count the number of divisions until they equal each other\\n\\n# Complexity\\n- Time complexity:\\n$$O(logN+logM)$$ for each query\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] nums = new int[queries.length];\\n        for(int i = 0;i<queries.length;i++){\\n            int num1 = queries[i][0];\\n            int num2 = queries[i][1];\\n            int div = 0;\\n            while(num1!=num2){\\n                if(num1>num2){\\n                    num1/=2;\\n                    div++;\\n                }\\n                else{\\n                    num2/=2;\\n                    div++;\\n                }\\n            }\\n            nums[i] = div+1;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] nums = new int[queries.length];\\n        for(int i = 0;i<queries.length;i++){\\n            int num1 = queries[i][0];\\n            int num2 = queries[i][1];\\n            int div = 0;\\n            while(num1!=num2){\\n                if(num1>num2){\\n                    num1/=2;\\n                    div++;\\n                }\\n                else{\\n                    num2/=2;\\n                    div++;\\n                }\\n            }\\n            nums[i] = div+1;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924646,
                "title": "c-easy-understandable-solution",
                "content": "# Intuition\\nwe first need to find LCA of two node given in queries. for that we first insert whole path from node to root node for both nodes given in particular query in `arr1` & `arr2`\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSuppose we are given n=3 ans lets take query {5,3};\\n\\n                      1\\n                    /   \\\\\\n                   2     3\\n                 /  \\\\   /  \\\\    \\n                4   5  6    7 \\npath from 5---to--->1 (root)` arr1= 5->2->1`\\npath from 3---to--->1 (root) `arr2= 3->1`\\n\\n**STEP 2:**\\nnow we reverse both the arrays\\n`arr1= 1,2,5`  &\\n`arr2= 1,3`\\n\\n**STEP 3:**\\nnow we are gonna find index up to which both paths are common.\\nbased one simple computation we store ans for each queries in result array.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Space complexity: as we are storing path which is equal to O(height) here hight is itself n. so time complexity is O(n*(queries.size()))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Time complexity: same as space complexity. O(n*(queries.size())\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>result;\\n        for(int i=0;i<queries.size();i++){\\n            int first=queries[i][0];\\n            int second=queries[i][1];\\n            \\n            vector<int>arr1,arr2;\\n            while(first){\\n                arr1.push_back(first);\\n                first/=2;\\n            }\\n            while(second){\\n                arr2.push_back(second);\\n                second/=2;\\n            }\\n          \\n            reverse(arr1.begin(),arr1.end());reverse(arr2.begin(),arr2.end());\\n            \\n            int it=0;\\n            int n=arr1.size(),m=arr2.size();\\n            while(it<n&&it<m&&arr1[it]==arr2[it])it++;\\n            it--;\\n            result.push_back(n-it-1+m-it-1+1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>result;\\n        for(int i=0;i<queries.size();i++){\\n            int first=queries[i][0];\\n            int second=queries[i][1];\\n            \\n            vector<int>arr1,arr2;\\n            while(first){\\n                arr1.push_back(first);\\n                first/=2;\\n            }\\n            while(second){\\n                arr2.push_back(second);\\n                second/=2;\\n            }\\n          \\n            reverse(arr1.begin(),arr1.end());reverse(arr2.begin(),arr2.end());\\n            \\n            int it=0;\\n            int n=arr1.size(),m=arr2.size();\\n            while(it<n&&it<m&&arr1[it]==arr2[it])it++;\\n            it--;\\n            result.push_back(n-it-1+m-it-1+1);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924421,
                "title": "c-easy-10-lines-two-pointer",
                "content": "```C++\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &v:queries) {\\n            int len=1;//1 is edge length\\n            while(v[0]!=v[1]) { //use two-pointer to find out lowest common ancestor\\n                (v[0]>v[1]?v[0]:v[1])/=2;//always change to half for the largest value. \\n                len++;\\n            }\\n            ans.push_back(len);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Explain the code\\nI explain more about the part of these code\\n```C++\\n\\twhile(v[0]!=v[1]) { //use two-pointer to find out lowest common ancestor\\n\\t\\t(v[0]>v[1]?v[0]:v[1])/=2;//always change to half for the largest value. \\n\\t\\tlen++;\\n\\t}\\n```\\nThey are the same as the logic\\n\\n```C++\\n\\twhile(v[0]!=v[1]) { \\n\\t\\tif(v[0]<v[1]) swap(v[0],v[1]);\\n\\t\\tv[0]/=2;\\n\\t\\tlen++;\\n\\t}\\n```\\nI want to save the time of swap, so I use \\n```(v[0]>v[1]?v[0]:v[1])/=2;``` to find out which is the largest value `val` and let it do `val/=2`",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &v:queries) {\\n            int len=1;//1 is edge length\\n            while(v[0]!=v[1]) { //use two-pointer to find out lowest common ancestor\\n                (v[0]>v[1]?v[0]:v[1])/=2;//always change to half for the largest value. \\n                len++;\\n            }\\n            ans.push_back(len);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```C++\\n\\twhile(v[0]!=v[1]) { //use two-pointer to find out lowest common ancestor\\n\\t\\t(v[0]>v[1]?v[0]:v[1])/=2;//always change to half for the largest value. \\n\\t\\tlen++;\\n\\t}\\n```\n```C++\\n\\twhile(v[0]!=v[1]) { \\n\\t\\tif(v[0]<v[1]) swap(v[0],v[1]);\\n\\t\\tv[0]/=2;\\n\\t\\tlen++;\\n\\t}\\n```\n```(v[0]>v[1]?v[0]:v[1])/=2;```",
                "codeTag": "Java"
            },
            {
                "id": 2924389,
                "title": "python3-lca-sol-for-reference",
                "content": "T: O(H * Q)\\nS: O(Q)\\n\\nH = log2(n + 1)\\n\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for s, e in queries: \\n            p = s\\n            q = e\\n            a = 0\\n            \\n            while p != q:  \\n                while p > q: \\n                    p = p//2\\n                    a += 1\\n                while q > p:\\n                    q = q//2\\n                    a += 1\\n                    \\n            ans.append(a+1)\\n            \\n        return ans",
                "solutionTags": [
                    "Python3"
                ],
                "code": "T: O(H * Q)\\nS: O(Q)\\n\\nH = log2(n + 1)\\n\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for s, e in queries: \\n            p = s\\n            q = e\\n            a = 0\\n            \\n            while p != q:  \\n                while p > q: \\n                    p = p//2\\n                    a += 1\\n                while q > p:\\n                    q = q//2\\n                    a += 1\\n                    \\n            ans.append(a+1)\\n            \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2924352,
                "title": "python-time-space-beats-100-o-1-time-complexity-for-each-query-super-easy-implementation",
                "content": "# Intuition\\nBinary Encoding: Given the context of this question, actually its much more easier to understand it in binary encoding:\\n\\nFor example, node #6, can be written in binary as 0b110, and can be interprated as 1(right) -> 1(right) -> 0(left). Following this intuition, given two nodes, for example #12(0b1100) and #13(0b1101), their common ancestor is the longest commen prefix in their binary encoding, which is 0b110 -> #6! \\n\\nSee? You can easily get the common ancestor of any two of the nodes by simply compare their binary encoding and get the longest commen prefix. Knowing where their LCA is, the rest of the steps are then obvious.\\n\\n\\n# Complexity\\nConsidering the maximum length of the binary encoding is about 30, for each query, their time complexity is simply O(1).\\n- Time complexity: O(M) \\n- Space complexity: O(M)\\n\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        res = []\\n        for a, b in queries:\\n            bin_a = bin(a)[2:]\\n            bin_b = bin(b)[2:]\\n            \\n            i = 0\\n            while i < len(bin_a) and i < len(bin_b) and bin_a[i] == bin_b[i]:\\n                i += 1\\n            res.append(len(bin_a) + len(bin_b) - 2 * i + 1)\\n        \\n        return res\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        res = []\\n        for a, b in queries:\\n            bin_a = bin(a)[2:]\\n            bin_b = bin(b)[2:]\\n            \\n            i = 0\\n            while i < len(bin_a) and i < len(bin_b) and bin_a[i] == bin_b[i]:\\n                i += 1\\n            res.append(len(bin_a) + len(bin_b) - 2 * i + 1)\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924062,
                "title": "c-dekh-bhai-super-easy-solution-tc-o-30-sc-o-30",
                "content": "# Intuition\\nTraverse queries and get all parent nodes by simply dividing q[i][0] and q[i][1]\\n\\n# Approach\\n**Step: 1**\\nTraverse queries and and make two vector for q[i][0] and q[i][1]. These vector will store the all parent node of q[i][0] and q[i][1].\\n\\nTo get all parent node run two while loop for both q[i][0] and q[i][1]. Like below:\\n```\\nwhile(q[i][0]>1){\\n    l.push_back(q[i][0]);\\n    if(q[i][0]%2){\\n        q[i][0]--;\\n        q[i][0]/=2;\\n    }else{\\n        q[i][0]/=2;\\n    }\\n}\\n```\\nHere vector L stores all parent nodes of q[i][0].\\nSimilarly calculate all parent nodes of q[i][1].\\n\\n**Step:2**\\nUsing two pointer find the Lowest Common Ancestor. \\n```\\nint i=0, j=0;\\nwhile(i<l.size() && j<r.size() && l[i]!=r[j]){\\n    if(l[i]==r[j]){\\n        break;\\n    }else if(l[i]>r[j]){\\n        i++;\\n    }else{\\n        j++;\\n    }\\n}\\n```\\nFor Example:\\n```\\nL = [8,4,2,1]\\nR = [6,3,1]\\n```\\ni & j pointer is current is at 0th index. And we know that both vector is sorted in descending order. So if L[i]>R[j] that\\'s means doing i++ will be beneficial than doing j++ because may be after incrementing i by 1 L[i] can be equal to R[j].\\nUsing same thought j will increment by 1 if L[i]<R[j].\\nAnd if any point of time L[i]==R[j] that means I\\'ve got my LCS and I will just break;\\n\\nSo i+j+1 will be pushed into ans vector and finally return that. I did i+j+1 because: \\nIf we notice the previous example then LCS will be 1 and i will be 3 and j will be 2 means total distance from q[i][0] to LCS is 3 and from q[i][1] to LCS is 2. And adding extra +1 because we\\'ve to create an edge between q[i][0] and q[i][1];\\n\\n# Complexity\\n- Time complexity:\\nO(30) Because maximum depth of tree can be upto maximum 30\\nIgnoring the traversal of queries vector because no matter what we\\'ve to do it\\nOverall TC: O(n * 30)\\n\\n- Space complexity:\\nO(30)+O(30) Because we can have to store the all nodes in two vector of the maximum depth.\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> v;\\n        for(int i=0; i<q.size(); i++){\\n            int a=q[i][0], b=q[i][1];\\n            vector<int> l,r;\\n            while(a>1){\\n                l.push_back(a);\\n                if(a%2){\\n                    a--;\\n                    a/=2;\\n                }else{\\n                    a/=2;\\n                }\\n            }\\n            while(b>1){\\n                r.push_back(b);\\n                if(b%2){\\n                    b--;\\n                    b/=2;\\n                }else{\\n                    b/=2;\\n                }\\n            }\\n\\n            l.push_back(a);\\n            r.push_back(b);\\n\\n            int x=0, y=0;\\n            while(x<l.size() && y<r.size() && l[x]!=r[y]){\\n                if(l[x]==r[y]){\\n                    break;\\n                }else if(l[x]>r[y]){\\n                    x++;\\n                }else{\\n                    y++;\\n                }\\n            }\\n            v.push_back(x+y+1);\\n        }\\n        return v;\\n    }\\n};\\n```\\n**UPVOTE PLEASEEEEE :)**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(q[i][0]>1){\\n    l.push_back(q[i][0]);\\n    if(q[i][0]%2){\\n        q[i][0]--;\\n        q[i][0]/=2;\\n    }else{\\n        q[i][0]/=2;\\n    }\\n}\\n```\n```\\nint i=0, j=0;\\nwhile(i<l.size() && j<r.size() && l[i]!=r[j]){\\n    if(l[i]==r[j]){\\n        break;\\n    }else if(l[i]>r[j]){\\n        i++;\\n    }else{\\n        j++;\\n    }\\n}\\n```\n```\\nL = [8,4,2,1]\\nR = [6,3,1]\\n```\n```\\nclass Solution {\\n    public:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> v;\\n        for(int i=0; i<q.size(); i++){\\n            int a=q[i][0], b=q[i][1];\\n            vector<int> l,r;\\n            while(a>1){\\n                l.push_back(a);\\n                if(a%2){\\n                    a--;\\n                    a/=2;\\n                }else{\\n                    a/=2;\\n                }\\n            }\\n            while(b>1){\\n                r.push_back(b);\\n                if(b%2){\\n                    b--;\\n                    b/=2;\\n                }else{\\n                    b/=2;\\n                }\\n            }\\n\\n            l.push_back(a);\\n            r.push_back(b);\\n\\n            int x=0, y=0;\\n            while(x<l.size() && y<r.size() && l[x]!=r[y]){\\n                if(l[x]==r[y]){\\n                    break;\\n                }else if(l[x]>r[y]){\\n                    x++;\\n                }else{\\n                    y++;\\n                }\\n            }\\n            v.push_back(x+y+1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923989,
                "title": "c-lca-simple-logic-approach-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> getAncestors(int n) {\\n        vector<int> ans; \\n        while(n) {\\n            ans.push_back(n); \\n            n /= 2; \\n        }\\n        return ans; \\n    }\\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        // common question : how cycle is formed \\n        // answer is through lowest common ancestor only \\n        // and what is the length of the cycle ? \\n        // Length of cycle = 1 + lenght of path from LCA to A + length of path from LCA to B\\n        \\n        // Which can also be written as: 1 + depth(a) + depth(b) - 2* depth(LCA) \\n        // or start poping from back of path of a and b until node becomes unequal \\n        // then length = size of path left in a + size of path left in b + 1 \\n        \\n        // Now how to find the LCA and depth \\n        // given leftNode: 2 * val , right: 2 * val + 1 \\n        // More precisely in level x: val of nodes are: [2^x, 2^x + 1 - 1]\\n        // so for given node N depth is log2(N)  \\n        // Now how to find LCA ? \\n        // find all ancestors of a, b \\n        // check the common one from left side \\n        \\n        vector<int> ans; \\n        \\n        for(auto it: queries) {\\n            vector<int> lcaA = getAncestors(it[0]); \\n            vector<int> lcaB = getAncestors(it[1]); \\n\\n            //Last ances is always 1 \\n            // to get LCA \\n            while(lcaA.size() > 0 && lcaB.size() > 0 && (lcaA.back() == lcaB.back())) {\\n                lcaA.pop_back(); \\n                lcaB.pop_back(); \\n            } \\n            \\n            int cycleLength = 1 + lcaA.size() + lcaB.size(); \\n            ans.push_back(cycleLength); \\n        }\\n\\n        return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> getAncestors(int n) {\\n        vector<int> ans; \\n        while(n) {\\n            ans.push_back(n); \\n            n /= 2; \\n        }\\n        return ans; \\n    }\\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        // common question : how cycle is formed \\n        // answer is through lowest common ancestor only \\n        // and what is the length of the cycle ? \\n        // Length of cycle = 1 + lenght of path from LCA to A + length of path from LCA to B\\n        \\n        // Which can also be written as: 1 + depth(a) + depth(b) - 2* depth(LCA) \\n        // or start poping from back of path of a and b until node becomes unequal \\n        // then length = size of path left in a + size of path left in b + 1 \\n        \\n        // Now how to find the LCA and depth \\n        // given leftNode: 2 * val , right: 2 * val + 1 \\n        // More precisely in level x: val of nodes are: [2^x, 2^x + 1 - 1]\\n        // so for given node N depth is log2(N)  \\n        // Now how to find LCA ? \\n        // find all ancestors of a, b \\n        // check the common one from left side \\n        \\n        vector<int> ans; \\n        \\n        for(auto it: queries) {\\n            vector<int> lcaA = getAncestors(it[0]); \\n            vector<int> lcaB = getAncestors(it[1]); \\n\\n            //Last ances is always 1 \\n            // to get LCA \\n            while(lcaA.size() > 0 && lcaB.size() > 0 && (lcaA.back() == lcaB.back())) {\\n                lcaA.pop_back(); \\n                lcaB.pop_back(); \\n            } \\n            \\n            int cycleLength = 1 + lcaA.size() + lcaB.size(); \\n            ans.push_back(cycleLength); \\n        }\\n\\n        return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923937,
                "title": "lowest-common-ancestor-math-beats-100",
                "content": "# Most Efficient Method: \\nThe answer is basically the distance between the two nodes + 1. So we could calculate the distance by traversing from both the nodes simultaneously till their values become equal(== lca).\\n# Code: \\n```\\nclass Solution {\\npublic:\\n    // answer to every query is log2(u) + log2(v) - 2 * log2(lca(u, v)) + 1 \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans; \\n        for (auto &query : queries) {\\n            int u = query[0], v = query[1]; \\n            int dist = 1; \\n            while (u != v) {\\n                if (u > v) {\\n                    u >>= 1; \\n                } else {\\n                    v >>= 1; \\n                }\\n                dist++; \\n            }\\n            ans.push_back(dist); \\n        }\\n        return ans; \\n    }\\n};\\n```\\n# Complexity :\\n- Time:  **O(Q * log(max(u, v) / min(u, v))) ~ O(Q)**\\n- Space: **O(1)**\\n---\\n## The above approach is rather intuitive and not the first one most would think of. So I\\'ll also be explaining the brute method. \\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince it is a tree, any cycle will go through the LCA(lowest common ancestor) of the two nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow for finding the LCA of two nodes `u` and `v` we can brute force it.\\nTraverse the path path from the smaller node to the root and keep on storing the nodes we encounter, as we go like this: \\n```\\nunordered_set<int> nodes; \\nwhile (u > 0) {\\n    nodes.insert(u); \\n    u >>= 1; \\n}\\n```\\nNow traverse from the other node to root and on every step check if we have already visited that node, if yes then that is the LCA of the two nodes.\\n```\\nwhile (v > 0) {\\n    if (nodes.find(v) != nodes.end()) { // already visited this node in u\\'s path\\n        return v; \\n    }\\n    v >>= 1; \\n}\\n```\\n\\nOnce we have found the LCA of the two nodes, the answer is always `depth of u + depth of v - 2 * (depth of lca) + 1` or in mathematical terms `log2(u) + log2(v) - 2 * log2(lca(u, v)) + 1`.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(Q * log2(max(u, v)) * log(n))** where M is the number of queries. `log(n)` for searching in the set.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** max length path is n since height of the tree is n.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans; \\n        for (auto &query : queries) {\\n            int u = query[0], v = query[1]; \\n            if (u > v)  swap(u, v); \\n            int z = 1; \\n            set<int> nodes; \\n            while (u > 0) {\\n                nodes.insert(u); \\n                u >>= 1; \\n            }\\n            while (v > 0) {\\n                if (nodes.find(v) != nodes.end()) {\\n                    z = v; \\n                    break; \\n                }\\n                v >>= 1; \\n            }\\n            ans.push_back(log(query[0]) + log(query[1]) - (2 * log(z)) + 1); \\n        }\\n        return ans; \\n    }\\nprivate: \\n    int log (int n) {\\n        int count = 0; \\n        while (n > 0) {\\n            count++;\\n            n >>= 1; \\n        }\\n        return count; \\n    }\\n};\\n```\\n# Note: \\nUsing `unordered_set` will give TLE as in worst case for searching it takes *O(N)* time.",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // answer to every query is log2(u) + log2(v) - 2 * log2(lca(u, v)) + 1 \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans; \\n        for (auto &query : queries) {\\n            int u = query[0], v = query[1]; \\n            int dist = 1; \\n            while (u != v) {\\n                if (u > v) {\\n                    u >>= 1; \\n                } else {\\n                    v >>= 1; \\n                }\\n                dist++; \\n            }\\n            ans.push_back(dist); \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nunordered_set<int> nodes; \\nwhile (u > 0) {\\n    nodes.insert(u); \\n    u >>= 1; \\n}\\n```\n```\\nwhile (v > 0) {\\n    if (nodes.find(v) != nodes.end()) { // already visited this node in u\\'s path\\n        return v; \\n    }\\n    v >>= 1; \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans; \\n        for (auto &query : queries) {\\n            int u = query[0], v = query[1]; \\n            if (u > v)  swap(u, v); \\n            int z = 1; \\n            set<int> nodes; \\n            while (u > 0) {\\n                nodes.insert(u); \\n                u >>= 1; \\n            }\\n            while (v > 0) {\\n                if (nodes.find(v) != nodes.end()) {\\n                    z = v; \\n                    break; \\n                }\\n                v >>= 1; \\n            }\\n            ans.push_back(log(query[0]) + log(query[1]) - (2 * log(z)) + 1); \\n        }\\n        return ans; \\n    }\\nprivate: \\n    int log (int n) {\\n        int count = 0; \\n        while (n > 0) {\\n            count++;\\n            n >>= 1; \\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923794,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto q : queries) {\\n            int a = q[0], b = q[1], l = 1;\\n            while(a != b) {\\n                a > b ? a /= 2 : b /= 2;\\n                l++;\\n            }\\n            ans.push_back(l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto q : queries) {\\n            int a = q[0], b = q[1], l = 1;\\n            while(a != b) {\\n                a > b ? a /= 2 : b /= 2;\\n                l++;\\n            }\\n            ans.push_back(l);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923764,
                "title": "easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        res=[]\\n        for x,y in queries:\\n            ans=1\\n            while x!=y:\\n                if x>y:\\n                    x//=2\\n                else:\\n                    y//=2\\n                ans+=1\\n            res.append(ans)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        res=[]\\n        for x,y in queries:\\n            ans=1\\n            while x!=y:\\n                if x>y:\\n                    x//=2\\n                else:\\n                    y//=2\\n                ans+=1\\n            res.append(ans)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923692,
                "title": "c-java-python3-climbing-up",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/af6e415cd101768ea8743ea9e4d22d788c9461c3) for solutions of weekly 324. \\n\\n**Intuition**\\nSince this is a complete tree, it is guaranteed to be shallow. We can compute the result of each query in a brute-force approach by visiting the parent of the two nodes. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic: \\n\\tvector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans; \\n        for (auto& q : queries) {\\n            unordered_map<int, int> dist; \\n            for (int u = q[0], d = 0; u; u /= 2) \\n                dist[u] = ++d; \\n            for (int v = q[1], d = 0; v; v /= 2, ++d) \\n                if (dist.count(v)) {\\n                    ans.push_back(d + dist[v]); \\n                    break; \\n                }\\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int sz = queries.length; \\n\\t\\tint[] ans = new int[sz]; \\n\\t\\tfor (int i = 0; i < sz; ++i) {\\n\\t\\t\\tHashMap<Integer, Integer> dist = new HashMap(); \\n\\t\\t\\tfor (int u = queries[i][0], d = 0; u > 0; u /= 2) \\n\\t\\t\\t\\tdist.put(u, ++d); \\n\\t\\t\\tfor (int v = queries[i][1], d = 0; v > 0; v /= 2, ++d) \\n\\t\\t\\t\\tif (dist.containsKey(v)) {\\n\\t\\t\\t\\t\\tans[i] = d + dist.get(v); \\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution: \\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for u, v in queries: \\n            dist = {}\\n            d = 0\\n            while u: \\n                dist[u] = (d := d+1)\\n                u //= 2\\n            d = 0 \\n            while v not in dist: \\n                d += 1\\n                v //= 2\\n            ans.append(d + dist[v])\\n        return ans \\t\\n```\\n**Complexity**\\nTime `O(NlogN)`\\nSpace `O(logN)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n\\tvector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans; \\n        for (auto& q : queries) {\\n            unordered_map<int, int> dist; \\n            for (int u = q[0], d = 0; u; u /= 2) \\n                dist[u] = ++d; \\n            for (int v = q[1], d = 0; v; v /= 2, ++d) \\n                if (dist.count(v)) {\\n                    ans.push_back(d + dist[v]); \\n                    break; \\n                }\\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int sz = queries.length; \\n\\t\\tint[] ans = new int[sz]; \\n\\t\\tfor (int i = 0; i < sz; ++i) {\\n\\t\\t\\tHashMap<Integer, Integer> dist = new HashMap(); \\n\\t\\t\\tfor (int u = queries[i][0], d = 0; u > 0; u /= 2) \\n\\t\\t\\t\\tdist.put(u, ++d); \\n\\t\\t\\tfor (int v = queries[i][1], d = 0; v > 0; v /= 2, ++d) \\n\\t\\t\\t\\tif (dist.containsKey(v)) {\\n\\t\\t\\t\\t\\tans[i] = d + dist.get(v); \\n\\t\\t\\t\\t\\tbreak; \\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans; \\n    }\\n}\\n```\n```\\nclass Solution: \\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for u, v in queries: \\n            dist = {}\\n            d = 0\\n            while u: \\n                dist[u] = (d := d+1)\\n                u //= 2\\n            d = 0 \\n            while v not in dist: \\n                d += 1\\n                v //= 2\\n            ans.append(d + dist[v])\\n        return ans \\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923607,
                "title": "binary-prefix-is-l-c-a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary tree is a Trie with 0 and 1 as its alphabet.\\n\\nTo poke one\\'s brain a bit more: Morton Code\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf one represents the Binary Tree using Binary Notation one would get:\\n\\n```\\n                          [1]\\n            .--------------^------------.\\n          [10]                         [11]\\n      .-----^-------.             .------^-------.\\n    [100]         [101]         [110]          [111]\\n  .---^---.     .---^---.     .---^---.      .---^---.\\n[1000] [1001] [1010] [1011] [1100] [1101] [1110] [1111]\\n```\\n\\nOne can see:\\n* The tree\\'s root node has 1.\\n* At every left branch, 0 is appended.\\n* At every right branch, 1 is appended.\\n* The Lowest Common Ancestor (LCA) of two numbers is the Common Prefix of their binary forms.\\n  * For example: for (5, 3), 5\\'s binary form is 101, 3\\'s binary form is 11, the prefix is 1.\\n  * Another example: for (5, 2), 5\\'s binary form is 101, 2\\'s binary form is 10, prefix is 10 in binary or 2 in decimal.\\n* The answer to a query `(a, b)` is the Path Length from a to the LCA plus the Path Length from b to the LCA minus 1.\\n\\n# Complexity\\n- Time complexity:\\n`O(mn)`, where `m` is the number of queries and `n` is the height of the tree.\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int LowestCommonAncestor(int a, int b) {\\n        bitset<32> ba(a), bb(b);\\n        int idx_a = 31, idx_b = 31;\\n        while (!ba.test(idx_a) && idx_a > 0) idx_a --;\\n        while (!bb.test(idx_b) && idx_b > 0) idx_b --;\\n        int ret = 0;\\n        while (idx_a >= 0 && idx_b >= 0) {\\n            if (ba.test(idx_a) == bb.test(idx_b)) {\\n                ret <<= 1;\\n                ret |= ba.test(idx_a);\\n            } else break;\\n            idx_a --;\\n            idx_b --;\\n        }\\n        return ret;\\n    }\\n    int PathLengthToLCA(int a, int lca) {\\n        int ret = 1;\\n        while (a > lca) {\\n            a /= 2;\\n            ret++;\\n        }\\n        return ret;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ret;\\n        for (const vector<int>& q : queries) {\\n            int a = q[0], b = q[1];\\n            int lca = LowestCommonAncestor(a, b);\\n            int r = PathLengthToLCA(a, lca) + PathLengthToLCA(b, lca) - 1;\\n//            printf(\"lca(%d,%d)=%d, ans=%d\\\\n\", a, b, lca, r);\\n            ret.push_back(r);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n                          [1]\\n            .--------------^------------.\\n          [10]                         [11]\\n      .-----^-------.             .------^-------.\\n    [100]         [101]         [110]          [111]\\n  .---^---.     .---^---.     .---^---.      .---^---.\\n[1000] [1001] [1010] [1011] [1100] [1101] [1110] [1111]\\n```\n```\\nclass Solution {\\npublic:\\n    int LowestCommonAncestor(int a, int b) {\\n        bitset<32> ba(a), bb(b);\\n        int idx_a = 31, idx_b = 31;\\n        while (!ba.test(idx_a) && idx_a > 0) idx_a --;\\n        while (!bb.test(idx_b) && idx_b > 0) idx_b --;\\n        int ret = 0;\\n        while (idx_a >= 0 && idx_b >= 0) {\\n            if (ba.test(idx_a) == bb.test(idx_b)) {\\n                ret <<= 1;\\n                ret |= ba.test(idx_a);\\n            } else break;\\n            idx_a --;\\n            idx_b --;\\n        }\\n        return ret;\\n    }\\n    int PathLengthToLCA(int a, int lca) {\\n        int ret = 1;\\n        while (a > lca) {\\n            a /= 2;\\n            ret++;\\n        }\\n        return ret;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ret;\\n        for (const vector<int>& q : queries) {\\n            int a = q[0], b = q[1];\\n            int lca = LowestCommonAncestor(a, b);\\n            int r = PathLengthToLCA(a, lca) + PathLengthToLCA(b, lca) - 1;\\n//            printf(\"lca(%d,%d)=%d, ans=%d\\\\n\", a, b, lca, r);\\n            ret.push_back(r);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923549,
                "title": "python3-lowest-common-ancestor",
                "content": "# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for a, b in queries:\\n            path_a, path_b = self.getPath(a), self.getPath(b)\\n            set_a, set_b = set(path_a), set(path_b)\\n            cnt = 0\\n            for num in path_a:\\n                if num not in set_b:\\n                    cnt += 1\\n            for num in path_b:\\n                if num not in set_a:\\n                    cnt += 1\\n            ans.append(cnt + 1)\\n        return ans\\n            \\n    def getPath(self, num):\\n        ans = []\\n        while num:\\n            ans.append(num)\\n            num //= 2\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for a, b in queries:\\n            path_a, path_b = self.getPath(a), self.getPath(b)\\n            set_a, set_b = set(path_a), set(path_b)\\n            cnt = 0\\n            for num in path_a:\\n                if num not in set_b:\\n                    cnt += 1\\n            for num in path_b:\\n                if num not in set_a:\\n                    cnt += 1\\n            ans.append(cnt + 1)\\n        return ans\\n            \\n    def getPath(self, num):\\n        ans = []\\n        while num:\\n            ans.append(num)\\n            num //= 2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923515,
                "title": "easy-c-solution-lowest-common-ancestor-in-complete-binary-tree",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int len(int n)\\n    {\\n        int cnt=0;\\n        while(n)\\n        {\\n            cnt++;\\n            n/=2;\\n        }\\n        return cnt;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int a=queries[i][0],b=queries[i][1],res=0;\\n            int len1=len(a),len2=len(b);\\n            while(len1>len2)\\n            {\\n                len1--;\\n                a/=2;\\n                res++;\\n            }\\n            while(len2>len1)\\n            {\\n                len2--;\\n                b/=2;\\n                res++;\\n            }\\n            while(a!=b)\\n            {\\n                a/=2;\\n                b/=2;\\n                res+=2;\\n            }\\n            res++;\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int len(int n)\\n    {\\n        int cnt=0;\\n        while(n)\\n        {\\n            cnt++;\\n            n/=2;\\n        }\\n        return cnt;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int a=queries[i][0],b=queries[i][1],res=0;\\n            int len1=len(a),len2=len(b);\\n            while(len1>len2)\\n            {\\n                len1--;\\n                a/=2;\\n                res++;\\n            }\\n            while(len2>len1)\\n            {\\n                len2--;\\n                b/=2;\\n                res++;\\n            }\\n            while(a!=b)\\n            {\\n                a/=2;\\n                b/=2;\\n                res+=2;\\n            }\\n            res++;\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923508,
                "title": "c-simple-intuitive-solution",
                "content": "\\nWe can use the fact that parent nodes are  `current node value / 2` to navigate up the tree until both left & right nodes are equal. Track the total number of times each node went up & add them to get the total cycle size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        // Find common ancestor of both nodes, get length from parent -> both children, add.\\n        vector<int> ans;\\n        for(auto q : queries) {\\n            int p1 = 0, p2 = 0;\\n            int c1 = q[0], c2 = q[1];\\n            while(c1 != c2) {\\n                if (c1 > c2) {\\n                    c1 /= 2;\\n                    p1++;\\n                } else {\\n                    c2 /= 2;\\n                    p2++;\\n                }\\n            }\\n            ans.push_back(p1 + p2 + 1); // +1 to add the common ancestor.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        // Find common ancestor of both nodes, get length from parent -> both children, add.\\n        vector<int> ans;\\n        for(auto q : queries) {\\n            int p1 = 0, p2 = 0;\\n            int c1 = q[0], c2 = q[1];\\n            while(c1 != c2) {\\n                if (c1 > c2) {\\n                    c1 /= 2;\\n                    p1++;\\n                } else {\\n                    c2 /= 2;\\n                    p2++;\\n                }\\n            }\\n            ans.push_back(p1 + p2 + 1); // +1 to add the common ancestor.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092317,
                "title": "o-1-space-complexity-lca-finding-lca-by-dividing-by-2",
                "content": "# Approach\\nDivide a, and b by 2 till you find the lowest common ancestor. Always divide the bigger one.\\n\\n# Complexity\\n- Time complexity:\\n $$O(log(n)*q)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(auto e: q){\\n            int a = e[0];\\n            int b = e[1];\\n            int ca=1,cb=1;\\n            int preva=a,prevb = b;\\n            while(preva != prevb){\\n                // cout<<preva<<\" \"<<prevb<<endl;\\n\\n                if(preva<prevb){\\n                    prevb /=2;\\n                    cb++;\\n                }\\n                else{\\n                    preva/=2;\\n                    ca++;\\n                }\\n            }\\n            // cout<<ca<<\" \"<<cb<<endl;\\n            ans.push_back(ca+cb-1);\\n            // cout<<\"------\"<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(auto e: q){\\n            int a = e[0];\\n            int b = e[1];\\n            int ca=1,cb=1;\\n            int preva=a,prevb = b;\\n            while(preva != prevb){\\n                // cout<<preva<<\" \"<<prevb<<endl;\\n\\n                if(preva<prevb){\\n                    prevb /=2;\\n                    cb++;\\n                }\\n                else{\\n                    preva/=2;\\n                    ca++;\\n                }\\n            }\\n            // cout<<ca<<\" \"<<cb<<endl;\\n            ans.push_back(ca+cb-1);\\n            // cout<<\"------\"<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4038398,
                "title": "lca",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int height(int u){\\n        int h=0;\\n        while(u>1){\\n            h++;\\n            u/=2;\\n        }\\n        return h;\\n    }\\n    int LCA(int u,int v){\\n        if(u==v) return u;\\n        int pu=u,pv=v;\\n        int hpu=height(pu),hpv=height(pv);\\n        if(hpu<hpv){\\n            while(hpu<hpv){\\n                pv=pv/2;\\n                hpv--;\\n            }\\n        }else if(hpv<hpu){\\n            while(hpu>hpv){\\n                pu=pu/2;\\n                hpu--;\\n            }\\n        }\\n        if(pu==pv) return pu;\\n        while(pu!=pv){\\n            pu/=2;\\n            pv/=2;\\n            if(pu==pv) return pu;\\n        }\\n        return pu;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int u=queries[i][0],v=queries[i][1];\\n            int h1=height(u),h2=height(v);\\n            int lca=LCA(u,v);\\n            int h3=height(lca);\\n            ans.push_back(h2+h1-2*h3+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int height(int u){\\n        int h=0;\\n        while(u>1){\\n            h++;\\n            u/=2;\\n        }\\n        return h;\\n    }\\n    int LCA(int u,int v){\\n        if(u==v) return u;\\n        int pu=u,pv=v;\\n        int hpu=height(pu),hpv=height(pv);\\n        if(hpu<hpv){\\n            while(hpu<hpv){\\n                pv=pv/2;\\n                hpv--;\\n            }\\n        }else if(hpv<hpu){\\n            while(hpu>hpv){\\n                pu=pu/2;\\n                hpu--;\\n            }\\n        }\\n        if(pu==pv) return pu;\\n        while(pu!=pv){\\n            pu/=2;\\n            pv/=2;\\n            if(pu==pv) return pu;\\n        }\\n        return pu;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            int u=queries[i][0],v=queries[i][1];\\n            int h1=height(u),h2=height(v);\\n            int lca=LCA(u,v);\\n            int h3=height(lca);\\n            ans.push_back(h2+h1-2*h3+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010369,
                "title": "c-easy-solution",
                "content": "```\\n\\n// Its Give TLE\\n\\nclass Solution {\\npublic:\\n    \\n    // calculating ancestor\\n    int cal(int node , int i , int j  )\\n    {\\n        \\n        if(node>max(i ,j ))\\n            return -1 ; \\n        if(node==i || node==j)\\n            return node ; \\n        \\n        int l = cal(node*2 , i ,j  ) ; \\n        int r = cal(node*2+1 , i, j ) ; \\n        \\n        if(l==-1)\\n            return r ;\\n        else if(r==-1)\\n            return l ;\\n        else\\n            return node ;\\n    }\\n    \\n    // calculating dis from ancestor to node \\n    \\n    int caldis(int a , int b )\\n    {\\n        \\n        if(a>b)\\n            return 1e9 ; \\n        if(a==b)\\n            return 0 ; \\n        int l = 1+caldis(a*2 , b ) ; \\n        int r = 1+caldis(a*2+1 , b ) ; \\n        \\n        return min(l ,r ) ; \\n    }\\n    \\n    \\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans ; \\n        \\n        for(auto it: queries)\\n        {\\n            int ancestor = cal(1,  it[0] , it[1]) ;\\n          \\n            ans.push_back(1+caldis(ancestor , it[0] ) + caldis(ancestor , it[1])) ;\\n\\n        }\\n        return ans ; \\n    }\\n};\\n\\n// Optimised Approach \\n\\nclass Solution {\\npublic:\\n\\n    int cal(int a, int b ) \\n    {\\n        \\n        int ans = 0;  \\n        while(a!=b)\\n        {\\n            if(a>b)\\n            {\\n                a/=2 ; \\n                ans++ ; \\n            }\\n            else\\n            {\\n                b/=2; \\n                ans++ ; \\n            }\\n        }\\n        return ans ; \\n    }\\n    \\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans ; \\n        \\n        for(auto it: queries)\\n        {\\n\\n            ans.push_back(1+cal(it[0] , it[1]));\\n\\n        }\\n        return ans ; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\n// Its Give TLE\\n\\nclass Solution {\\npublic:\\n    \\n    // calculating ancestor\\n    int cal(int node , int i , int j  )\\n    {\\n        \\n        if(node>max(i ,j ))\\n            return -1 ; \\n        if(node==i || node==j)\\n            return node ; \\n        \\n        int l = cal(node*2 , i ,j  ) ; \\n        int r = cal(node*2+1 , i, j ) ; \\n        \\n        if(l==-1)\\n            return r ;\\n        else if(r==-1)\\n            return l ;\\n        else\\n            return node ;\\n    }\\n    \\n    // calculating dis from ancestor to node \\n    \\n    int caldis(int a , int b )\\n    {\\n        \\n        if(a>b)\\n            return 1e9 ; \\n        if(a==b)\\n            return 0 ; \\n        int l = 1+caldis(a*2 , b ) ; \\n        int r = 1+caldis(a*2+1 , b ) ; \\n        \\n        return min(l ,r ) ; \\n    }\\n    \\n    \\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans ; \\n        \\n        for(auto it: queries)\\n        {\\n            int ancestor = cal(1,  it[0] , it[1]) ;\\n          \\n            ans.push_back(1+caldis(ancestor , it[0] ) + caldis(ancestor , it[1])) ;\\n\\n        }\\n        return ans ; \\n    }\\n};\\n\\n// Optimised Approach \\n\\nclass Solution {\\npublic:\\n\\n    int cal(int a, int b ) \\n    {\\n        \\n        int ans = 0;  \\n        while(a!=b)\\n        {\\n            if(a>b)\\n            {\\n                a/=2 ; \\n                ans++ ; \\n            }\\n            else\\n            {\\n                b/=2; \\n                ans++ ; \\n            }\\n        }\\n        return ans ; \\n    }\\n    \\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans ; \\n        \\n        for(auto it: queries)\\n        {\\n\\n            ans.push_back(1+cal(it[0] , it[1]));\\n\\n        }\\n        return ans ; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995744,
                "title": "one-line-o-n-python-solution",
                "content": "# Intuition\\nThe lowest common anscestor is the longest common prefix in binary form\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) - No additional space\\n\\n# Code\\n```\\ndef cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n    return [\\n        len(a) + len(b) - 2 * len(os.path.commonprefix([a, b])) + 1\\n        for a, b in ((bin(a)[2:], bin(b)[2:]) for a, b in queries)\\n    ]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n    return [\\n        len(a) + len(b) - 2 * len(os.path.commonprefix([a, b])) + 1\\n        for a, b in ((bin(a)[2:], bin(b)[2:]) for a, b in queries)\\n    ]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3988023,
                "title": "lca-with-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n**longest cycle = height of node 1 + height of node 2 - 2 * height of lca + 1**\\n\\nthis is the formulae which we are going to use.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLCA APPROACH WHICH IS DIRECT AS node i has 2*i and 2*i+1 as children.\\nwhen we divide children value by 2 we can reach its parent.\\nthis makes finding LCA easy.\\n\\n\\n# Complexity\\n- Time complexity:\\n**O(Q*N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n**O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int x=log2(queries[i][0]);\\n            int y=log2(queries[i][1]);\\n            int temp1=queries[i][0],temp2=queries[i][1];\\n            if(x<y) \\n            {\\n                swap(temp1,temp2);\\n                swap(x,y);\\n            }\\n            int sol=0;\\n            while(x!=y)\\n            {\\n                sol++;\\n                temp1/=2;\\n                x=log2(temp1);\\n            }\\n            int z=0;\\n            while(temp1!=temp2)\\n            {\\n                temp1/=2;\\n                temp2/=2;\\n            }\\n            z=log2(temp1);\\n            ans.push_back(1+sol+x+y-2*z);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int x=log2(queries[i][0]);\\n            int y=log2(queries[i][1]);\\n            int temp1=queries[i][0],temp2=queries[i][1];\\n            if(x<y) \\n            {\\n                swap(temp1,temp2);\\n                swap(x,y);\\n            }\\n            int sol=0;\\n            while(x!=y)\\n            {\\n                sol++;\\n                temp1/=2;\\n                x=log2(temp1);\\n            }\\n            int z=0;\\n            while(temp1!=temp2)\\n            {\\n                temp1/=2;\\n                temp2/=2;\\n            }\\n            z=log2(temp1);\\n            ans.push_back(1+sol+x+y-2*z);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979192,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for (auto it: queries)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            int cx=0;\\n            int cy=0;\\n            while(x!=y)\\n            {\\n                if (x>y)\\n                {\\n                    x/=2;\\n                    cx++;\\n                }\\n                else\\n                {\\n                    y/=2;\\n                    cy++;\\n                }\\n            }\\n            ans.push_back(cx+cy+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for (auto it: queries)\\n        {\\n            int x=it[0];\\n            int y=it[1];\\n            int cx=0;\\n            int cy=0;\\n            while(x!=y)\\n            {\\n                if (x>y)\\n                {\\n                    x/=2;\\n                    cx++;\\n                }\\n                else\\n                {\\n                    y/=2;\\n                    cy++;\\n                }\\n            }\\n            ans.push_back(cx+cy+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969730,
                "title": "fast-python-bit-manipulation",
                "content": "# Intuition\\n\\nIn this problem for each pair `a, b` we need to find the common ancestor `c` of `a` and `b` and then the cycle length is `level(a)+level(b)-2level(c)+1`.\\n\\nThe naive implementation is:\\n```\\ndef cycle_len(a, b):\\n    d = 1\\n    while a != b:\\n        if a > b:\\n            a, b = b, a\\n        b //= 2\\n        d += 1\\n    return d\\n```\\n\\nThis can be improved by first finding the common level and then \\ntaking the bitwise symmetric difference. Its bit length is exactly how many times do we need to go up one level to reach the common ancestor. \\n\\n# Code\\n```\\ndef cycle_len(a, b):\\n    d = 1\\n    level_a = a.bit_length()\\n    level_b = b.bit_length()\\n    if level_a < level_b:\\n        d += level_b-level_a\\n        b >>= level_b-level_a\\n    else:\\n        d += level_a-level_b\\n        a >>= level_a-level_b\\n    c = a^b\\n    d += 2*c.bit_length()\\n    return d\\n\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        return [cycle_len(a, b) for a, b in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef cycle_len(a, b):\\n    d = 1\\n    while a != b:\\n        if a > b:\\n            a, b = b, a\\n        b //= 2\\n        d += 1\\n    return d\\n```\n```\\ndef cycle_len(a, b):\\n    d = 1\\n    level_a = a.bit_length()\\n    level_b = b.bit_length()\\n    if level_a < level_b:\\n        d += level_b-level_a\\n        b >>= level_b-level_a\\n    else:\\n        d += level_a-level_b\\n        a >>= level_a-level_b\\n    c = a^b\\n    d += 2*c.bit_length()\\n    return d\\n\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        return [cycle_len(a, b) for a, b in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963057,
                "title": "lca-commneted",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n    int m = queries.size();  // Number of queries\\n    vector<int> res(m, 1);   // Initialize the result vector with default cycle lengths of 1\\n    \\n    // Iterate through each query\\n    for (int i = 0; i < m; ++i) {\\n        int x = queries[i][0], y = queries[i][1];  // Starting and ending nodes\\n        \\n        // Keep reducing the larger node until both nodes become equal\\n        while (x != y) {\\n            if (x > y)\\n                x /= 2;  // Move towards the root by halving\\n            else\\n                y /= 2;  // Move towards the root by halving\\n            res[i]++;  // Increment the cycle length\\n        }\\n    }\\n    \\n    return res;  // Return the vector containing cycle lengths for each query\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n    int m = queries.size();  // Number of queries\\n    vector<int> res(m, 1);   // Initialize the result vector with default cycle lengths of 1\\n    \\n    // Iterate through each query\\n    for (int i = 0; i < m; ++i) {\\n        int x = queries[i][0], y = queries[i][1];  // Starting and ending nodes\\n        \\n        // Keep reducing the larger node until both nodes become equal\\n        while (x != y) {\\n            if (x > y)\\n                x /= 2;  // Move towards the root by halving\\n            else\\n                y /= 2;  // Move towards the root by halving\\n            res[i]++;  // Increment the cycle length\\n        }\\n    }\\n    \\n    return res;  // Return the vector containing cycle lengths for each query\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938367,
                "title": "c-lca-o-q-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n          \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            \\n            int a=queries[i][0];\\n            int b=queries[i][1];\\n            int x=a;\\n            int y=b;\\n            long long level1=0;\\n            while(a!=1){\\n                a=a/2;\\n                level1++;\\n            }\\n            long long level2=0;\\n            while(b!=1){\\n                b=b/2;\\n                level2++;\\n            }\\n            unordered_map<long long,bool> visited(false);\\n            if(level1>level2){\\n                \\n                long long lca=1;\\n                while(x!=1){\\n                    visited[x]=true;\\n                    x=x/2;\\n                }\\n                visited[x]=true;\\n                long long level=0;\\n                while(y!=1){\\n                    if(visited[y]==true){\\n                        lca=y;\\n                        break;\\n                    }\\n                    else{\\n                        visited[y]=true;\\n                    }\\n                    y=y/2;\\n                    level++;\\n                }\\n                visited[y]=true;\\n                level=level2-level;\\n                long long num=abs(level-level1)+abs(level-level2)+1;\\n                ans.push_back(num);\\n            }\\n            else if(level2>level1){\\n                \\n                long long lca=1;\\n                while(y!=1){\\n                    visited[y]=true;\\n                    y=y/2;\\n                }\\n                visited[y]=true;\\n                long long level=0;\\n                while(x!=1){\\n                    if(visited[x]==true){\\n                        lca=x;\\n                        break;\\n                    }\\n                    else{\\n                        visited[x]=true;\\n                    }\\n                    x=x/2;\\n                    level++;\\n                }\\n                visited[x]=true;\\n                level=level1-level;\\n                long long num=abs(level-level1)+abs(level-level2)+1;\\n                ans.push_back(num);\\n                \\n            }\\n            else{\\n                \\n                long long lca=1;\\n                while(x!=1){\\n                    visited[x]=true;\\n                    x=x/2;\\n                }\\n                visited[x]=true;\\n                long long level=0;\\n                while(y!=1){\\n                    if(visited[y]==true){\\n                        lca=y;\\n                        break;\\n                    }\\n                    else{\\n                        visited[y]=true;\\n                    }\\n                    y=y/2;\\n                    level++;\\n                }\\n                visited[y]=true;\\n                level=level1-level;\\n                long long num=abs(level-level1)+abs(level-level2)+1;\\n                ans.push_back(num);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n          \\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++){\\n            \\n            int a=queries[i][0];\\n            int b=queries[i][1];\\n            int x=a;\\n            int y=b;\\n            long long level1=0;\\n            while(a!=1){\\n                a=a/2;\\n                level1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3918717,
                "title": "find-distance-from-the-lca-c-code-o-q-log-n-approach",
                "content": "# Intuition\\nJust find the distance from the LCA.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int getDistance(int x, int y) {\\n        int xDistanceFromLCA = 0;\\n        int yDistanceFromLCA = 0;\\n        while(x!=y) {\\n            if(x>y) {\\n                x/=2;\\n                xDistanceFromLCA++;\\n            } else {\\n                y/=2;\\n                yDistanceFromLCA++;\\n            }\\n        }\\n        return xDistanceFromLCA + yDistanceFromLCA + 1;\\n    }\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> result;\\n        for(auto& x: queries) {\\n            int distance = getDistance(x[0], x[1]);\\n            result.push_back(distance);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int getDistance(int x, int y) {\\n        int xDistanceFromLCA = 0;\\n        int yDistanceFromLCA = 0;\\n        while(x!=y) {\\n            if(x>y) {\\n                x/=2;\\n                xDistanceFromLCA++;\\n            } else {\\n                y/=2;\\n                yDistanceFromLCA++;\\n            }\\n        }\\n        return xDistanceFromLCA + yDistanceFromLCA + 1;\\n    }\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> result;\\n        for(auto& x: queries) {\\n            int distance = getDistance(x[0], x[1]);\\n            result.push_back(distance);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912419,
                "title": "simple-c-solution-lca",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind Lowest Commen Ancestor of Ai and Bi of Queries\\n\\n*For better understanding Dry-run Following code yourself\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto node : queries){\\n            int a = node[0], b = node[1];\\n            int ca = 0, cb = 0;\\n\\n            //For Finding Commen Ancestor and count node of left & right parts\\n            while(a != b){\\n                if(a > b){\\n                    a = a/2;\\n                    ca++;\\n                }\\n                if(b > a){\\n                    b = b/2;\\n                    cb++;\\n                }\\n            }\\n            // Simple added left node count + right node count + 1(For Commen Ancestor)\\n            ans.push_back(ca+cb+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto node : queries){\\n            int a = node[0], b = node[1];\\n            int ca = 0, cb = 0;\\n\\n            //For Finding Commen Ancestor and count node of left & right parts\\n            while(a != b){\\n                if(a > b){\\n                    a = a/2;\\n                    ca++;\\n                }\\n                if(b > a){\\n                    b = b/2;\\n                    cb++;\\n                }\\n            }\\n            // Simple added left node count + right node count + 1(For Commen Ancestor)\\n            ans.push_back(ca+cb+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903590,
                "title": "java-clean-code-explanation-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // we need to move towards common parent and also count each steps to reach to parent\\n    // left/2 or right/2 will give their parent because left and right are arranged in such a way.\\n    // count each steps then add 1 and store it.\\n\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int l=queries.length;\\n        int[] ans=new int[l];\\n        \\n        for(int i=0; i<l; i++){\\n\\n            int x=queries[i][0],y=queries[i][1];\\n            ans[i]++;\\n\\n            while(x != y){\\n                if(x>y) x/=2;\\n                else y/=2;\\n                ans[i]++;\\n            }\\n        }\\n        return ans;\\n    }\\n \\n} \\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    // we need to move towards common parent and also count each steps to reach to parent\\n    // left/2 or right/2 will give their parent because left and right are arranged in such a way.\\n    // count each steps then add 1 and store it.\\n\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int l=queries.length;\\n        int[] ans=new int[l];\\n        \\n        for(int i=0; i<l; i++){\\n\\n            int x=queries[i][0],y=queries[i][1];\\n            ans[i]++;\\n\\n            while(x != y){\\n                if(x>y) x/=2;\\n                else y/=2;\\n                ans[i]++;\\n            }\\n        }\\n        return ans;\\n    }\\n \\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887898,
                "title": "construct-the-path-till-root-node-2-is-its-parent",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstruct the path till root. Compare path and remove the common roots\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf Node is 15, its path is 15->7->3->1\\nIf Node is 21, its path is 21->10->5->2->1\\nremove common path ie 1.\\nAdd the length of both path and add 1 for the common ancestor\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(height) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(height) \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int path(int a, int b)\\n    {\\n        vector<int> va,vb;\\n        while(a!=1)\\n            va.push_back(a), a/=2;\\n        va.push_back(1);\\n        reverse(va.begin(), va.end());\\n        while(b!=1)\\n            vb.push_back(b), b/=2;\\n        vb.push_back(1);\\n        reverse(vb.begin(), vb.end());\\n        int i = 0;\\n        while(i<va.size() && i<vb.size() && va[i]==vb[i]) i++;\\n        return va.size()+vb.size()+1-i*2;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        for(auto a: queries)\\n        {\\n            v.push_back(path(a[0],a[1]));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int path(int a, int b)\\n    {\\n        vector<int> va,vb;\\n        while(a!=1)\\n            va.push_back(a), a/=2;\\n        va.push_back(1);\\n        reverse(va.begin(), va.end());\\n        while(b!=1)\\n            vb.push_back(b), b/=2;\\n        vb.push_back(1);\\n        reverse(vb.begin(), vb.end());\\n        int i = 0;\\n        while(i<va.size() && i<vb.size() && va[i]==vb[i]) i++;\\n        return va.size()+vb.size()+1-i*2;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        for(auto a: queries)\\n        {\\n            v.push_back(path(a[0],a[1]));\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856866,
                "title": "a-c-solution",
                "content": "the same as other c solutions\\n# Code\\n```\\nint search(int first, int second) {\\n  int counter = 0;\\n  while(first != second) {\\n    if(first < second) second /= 2;\\n    else first /= 2;\\n    counter++;\\n  }\\n  return ++counter;\\n}\\n\\nint* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n  *returnSize = queriesSize;\\n  int* ret = malloc(queriesSize * sizeof(int));\\n  for(int i = 0; i < queriesSize; i++) {\\n    ret[i] = search(queries[i][0], queries[i][1]);\\n  }\\n  return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint search(int first, int second) {\\n  int counter = 0;\\n  while(first != second) {\\n    if(first < second) second /= 2;\\n    else first /= 2;\\n    counter++;\\n  }\\n  return ++counter;\\n}\\n\\nint* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n  *returnSize = queriesSize;\\n  int* ret = malloc(queriesSize * sizeof(int));\\n  for(int i = 0; i < queriesSize; i++) {\\n    ret[i] = search(queries[i][0], queries[i][1]);\\n  }\\n  return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839383,
                "title": "c-short-solution-98",
                "content": "Idea is that cycle will always be formed by the two nodes separate paths to the LCA (lowest common ancestor), and the link that connnects the two nodes together. \\n\\nSince this is a complete binary tree, we can deduce the parents by divinding the node value by 2. \\n\\nLCA is one node, so eventually after dividing node `a` by `2` `n` times and node `b` by `2` `m` times, they will equal the same number. This is the LCA. The cycle length is `n+m+1`.\\n\\nThus we can greedily divide the bigger of the two numbers by two continuously until they equate each other. Each time we divide we add `1` to our path count.\\n\\nRun-time is `O(m*n)`, space is `O(1)`, without including the result array. `M` is length of `queries`. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        std::vector<int> res;\\n        for (auto q: queries) {\\n            int a = q[0], b = q[1], count = 1;\\n            while (a != b) {\\n                if (a > b) a >>= 1;\\n                else if (a < b) b >>= 1;\\n                ++count;\\n            }\\n\\n            res.push_back(count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        std::vector<int> res;\\n        for (auto q: queries) {\\n            int a = q[0], b = q[1], count = 1;\\n            while (a != b) {\\n                if (a > b) a >>= 1;\\n                else if (a < b) b >>= 1;\\n                ++count;\\n            }\\n\\n            res.push_back(count);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839373,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lcs(int a,int b){\\n        int cnt=0;\\n       while(a!=b){\\n           if(a>b){\\n               cnt++;\\n               a=a/2;\\n           }else{\\n               cnt++;\\n               b=b/2;\\n           }\\n       } \\n       return cnt;\\n    }\\n    // int height(int n){\\n    //     int cnt=0;\\n    //     int sum=0;\\n    //     while(sum<n){\\n    //         sum+=pow(2,cnt);\\n    //         cnt++;\\n    //     }\\n    //     return cnt-1;\\n    // }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++){\\n            int x = lcs(q[i][0],q[i][1]);\\n            ans.push_back(x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcs(int a,int b){\\n        int cnt=0;\\n       while(a!=b){\\n           if(a>b){\\n               cnt++;\\n               a=a/2;\\n           }else{\\n               cnt++;\\n               b=b/2;\\n           }\\n       } \\n       return cnt;\\n    }\\n    // int height(int n){\\n    //     int cnt=0;\\n    //     int sum=0;\\n    //     while(sum<n){\\n    //         sum+=pow(2,cnt);\\n    //         cnt++;\\n    //     }\\n    //     return cnt-1;\\n    // }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++){\\n            int x = lcs(q[i][0],q[i][1]);\\n            ans.push_back(x+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808250,
                "title": "simple-c-solution",
                "content": "# Intuition\\nFirst of all this is not even a tree question ,given two numbers we have to find where they become equal after dividing by 2 since child=2*parent ,2*parent+1 .divide the large number evry time until they become equal \\n\\nmy code is so simple to understand how to find where the numbers are meeting\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>a;\\n       for(auto it:queries){\\n           int p=it[0],q=it[1],c=0,d=0;\\n           while(true){\\n               if(p==q)break;\\n               else if(p>q&&p>1)p/=2,c++;\\n               else if(q>p&&q>1)q/=2,d++;\\n               if(p<=1&&q<=1)break;\\n           }\\n           a.push_back(c+d+1);\\n           \\n       }\\n       return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>a;\\n       for(auto it:queries){\\n           int p=it[0],q=it[1],c=0,d=0;\\n           while(true){\\n               if(p==q)break;\\n               else if(p>q&&p>1)p/=2,c++;\\n               else if(q>p&&q>1)q/=2,d++;\\n               if(p<=1&&q<=1)break;\\n           }\\n           a.push_back(c+d+1);\\n           \\n       }\\n       return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785283,
                "title": "javascript-lca",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar cycleLengthQueries = function (n, queries) {\\n  const ans = new Array(queries.length).fill(0);\\n  for (let i = 0; i < queries.length; i++) {\\n    let [v1, v2] = queries[i];\\n\\n    ans[i]++;\\n    while (v1 !== v2) {\\n      if (v1 > v2) {\\n        v1 = Math.floor(v1 / 2);\\n      } else {\\n        v2 = Math.floor(v2 / 2);\\n      }\\n      ans[i]++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nvar cycleLengthQueries = function (n, queries) {\\n  const ans = new Array(queries.length).fill(0);\\n  for (let i = 0; i < queries.length; i++) {\\n    let [v1, v2] = queries[i];\\n\\n    ans[i]++;\\n    while (v1 !== v2) {\\n      if (v1 > v2) {\\n        v1 = Math.floor(v1 / 2);\\n      } else {\\n        v2 = Math.floor(v2 / 2);\\n      }\\n      ans[i]++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776696,
                "title": "no-extra-space-is-used-reverse-engineering",
                "content": "# Intuition\\nTo find LCA, we just need to move upward direction and count no of edges. It will give the LCA node to node a + LCA to node b\\'s total height. So for connecting line we need to increase ans by 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\nO(mlogn)\\n\\n- Space complexity:\\nO(1) excluding the ans vector we are returning.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans; \\n        int m =  queries.size(); \\n        for(int i=0; i<m; i++){\\n            int a = queries[i][0]; \\n            int b = queries[i][1];\\n            \\n            int edges = 0; \\n            while(a!=b){\\n                if(a>b){\\n                    a = a/2; \\n                }else{\\n                    b = b/2; \\n                }\\n                edges++; \\n            }\\n            ans.push_back(edges+1); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans; \\n        int m =  queries.size(); \\n        for(int i=0; i<m; i++){\\n            int a = queries[i][0]; \\n            int b = queries[i][1];\\n            \\n            int edges = 0; \\n            while(a!=b){\\n                if(a>b){\\n                    a = a/2; \\n                }else{\\n                    b = b/2; \\n                }\\n                edges++; \\n            }\\n            ans.push_back(edges+1); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743084,
                "title": "c-easy-to-understand-solution-with-inline-comments-o-mlogn-faster-than-88",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe `getDistance` function calculates the distance between two nodes `u` and `v` in terms of the number of edges between them. It utilizes the `getParent` function to traverse the binary tree from both nodes towards their common ancestor. The distance variable keeps track of the number of edges traversed. \\n\\nThe loop continues until `u` and `v` are equal, indicating that they have reached their common ancestor. At each iteration, the function chooses the larger node and moves it up the tree using getParent, incrementing the distance by 1.\\n\\n# Complexity\\n## Time complexity:\\n\\nThe `getDistance` function has a time complexity of `O(log n)`, where `n` is the number of nodes in the binary tree. This function uses the getParent function to traverse the tree from both nodes `u` and `v` towards their common ancestor. \\n\\nThe number of iterations in the while loop is proportional to the distance between `u` and `v` in terms of the number of edges. \\n\\nIn a complete binary tree, the maximum distance between any two nodes is `O(log n)`, which corresponds to traversing from the deepest leaf to the root. Hence, the time complexity of getDistance is `O(log n)`.\\n\\nThe `cycleLengthQueries` function iterates through each query pair in the queries vector and calls the getDistance function for each pair. Therefore, the time complexity of `cycleLengthQueries` depends on the number of queries, which is denoted as m. As a result, the time complexity of `cycleLengthQueries` is `O(m log n)`.\\n\\n## Space complexity:\\nSize of Result vector which is `O(m)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // This works since the binary tree is indexed from 1-->2^n-1\\n    int getParent(int node) {\\n        return node / 2;\\n    }\\n    \\n    /*\\n        The getDistance function calculates the distance between two nodes u and v \\n        in terms of the number of edges between them. \\n        It utilizes the getParent function to traverse the binary tree from both \\n        nodes towards their common ancestor. \\n    */\\n    int getDistance(int u, int v) {\\n        int count = 1; // Since we always start from a starting node.\\n        while (u != v) {\\n            if (u > v) u = getParent(u);\\n            else v = getParent(v);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, const vector<vector<int>>& queries) {\\n        vector<int> result;\\n\\n        for (const auto& query : queries) {\\n            int u = query[0];\\n            int v = query[1];\\n\\n            int count = getDistance(u, v);\\n            result.push_back(count);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // This works since the binary tree is indexed from 1-->2^n-1\\n    int getParent(int node) {\\n        return node / 2;\\n    }\\n    \\n    /*\\n        The getDistance function calculates the distance between two nodes u and v \\n        in terms of the number of edges between them. \\n        It utilizes the getParent function to traverse the binary tree from both \\n        nodes towards their common ancestor. \\n    */\\n    int getDistance(int u, int v) {\\n        int count = 1; // Since we always start from a starting node.\\n        while (u != v) {\\n            if (u > v) u = getParent(u);\\n            else v = getParent(v);\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, const vector<vector<int>>& queries) {\\n        vector<int> result;\\n\\n        for (const auto& query : queries) {\\n            int u = query[0];\\n            int v = query[1];\\n\\n            int count = getDistance(u, v);\\n            result.push_back(count);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720025,
                "title": "lca",
                "content": "\\n\\n# Code\\n```\\n/*\\n    It\\'s complete binary tree, so for any node it\\'s parent would be simply node/2.\\n    and it\\'s level would be log2(node)\\n\\n    So, here you just need to reach at LCA and just count the number of steps needed to reach there!!\\n\\n    TC : O(30) in worst case for each query!!\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n\\n        for(auto &it : queries) {\\n            int u = it[0] , v = it[1];\\n\\n            int cnt = 0;\\n            int l1 = log2(u) , l2 = log2(v);\\n            // Making their level same!\\n            while(l1 != l2) {\\n                if(l1 > l2) {\\n                   u /= 2;\\n                   l1--; \\n                } else {\\n                    v /= 2;\\n                    l2--;\\n                }\\n                cnt++;\\n            }\\n\\n            // Reaching at LCA\\n            while(u != v) {\\n                u /= 2;\\n                v /= 2;\\n                cnt += 2;\\n            }\\n\\n            cnt++;        // a newly added edge\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n    It\\'s complete binary tree, so for any node it\\'s parent would be simply node/2.\\n    and it\\'s level would be log2(node)\\n\\n    So, here you just need to reach at LCA and just count the number of steps needed to reach there!!\\n\\n    TC : O(30) in worst case for each query!!\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n\\n        for(auto &it : queries) {\\n            int u = it[0] , v = it[1];\\n\\n            int cnt = 0;\\n            int l1 = log2(u) , l2 = log2(v);\\n            // Making their level same!\\n            while(l1 != l2) {\\n                if(l1 > l2) {\\n                   u /= 2;\\n                   l1--; \\n                } else {\\n                    v /= 2;\\n                    l2--;\\n                }\\n                cnt++;\\n            }\\n\\n            // Reaching at LCA\\n            while(u != v) {\\n                u /= 2;\\n                v /= 2;\\n                cnt += 2;\\n            }\\n\\n            cnt++;        // a newly added edge\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646794,
                "title": "short-ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nTo find the length of a cycle, add the distance from each node to their common parents plus 1.  It\\'s easy to find these distances because it\\'s a complete binary tree.\\n\\n# Approach\\nFind the distance for each query using a helper function:\\n1. Start distance at 1 for the added edge.\\n2. Whichever node is bigger, find its parent by dividng by two.  (This works because if the parent is x, the left node is 2x and the right node is 2x+1.  Either way, dividing by two gets you the parent.) Add 1 to the distance.\\n3. Repeat step two until you\\'ve found the common parent, completing the cycle.\\n4. Return the distance.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef cycle_length_queries(n, queries)\\n    queries.map { |query| distance(query) }\\nend\\n\\ndef distance(query)\\n    dist = 1\\n    a,b = query\\n\\n    until a == b\\n        if a > b\\n            a /= 2\\n        else\\n            b /= 2\\n        end\\n\\n        dist += 1\\n    end\\n\\n    dist\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef cycle_length_queries(n, queries)\\n    queries.map { |query| distance(query) }\\nend\\n\\ndef distance(query)\\n    dist = 1\\n    a,b = query\\n\\n    until a == b\\n        if a > b\\n            a /= 2\\n        else\\n            b /= 2\\n        end\\n\\n        dist += 1\\n    end\\n\\n    dist\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3641234,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] CycleLengthQueries(int n, int[][] queries) {\\n      int[] result = new int[queries.Length];\\n\\n        for (int i = 0; i < queries.Length; ++i) {\\n            int length = 1;\\n\\n            for (int a = queries[i][0], b = queries[i][1]; a != b; ++length, a /= 2) \\n                if (a < b)\\n                    (a, b) = (b, a);\\n            \\n            result[i] = length;\\n        }     \\n\\n        return result;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Math",
                    "Two Pointers",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] CycleLengthQueries(int n, int[][] queries) {\\n      int[] result = new int[queries.Length];\\n\\n        for (int i = 0; i < queries.Length; ++i) {\\n            int length = 1;\\n\\n            for (int a = queries[i][0], b = queries[i][1]; a != b; ++length, a /= 2) \\n                if (a < b)\\n                    (a, b) = (b, a);\\n            \\n            result[i] = length;\\n        }     \\n\\n        return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619969,
                "title": "common-ancestor-intuition",
                "content": "# Intuition\\nFor every query, get common parent and just find length of both to common parent and add them +1 (for the connection between the 2).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\n\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        # Get common parent. That is it, problem ends because you just find length of both to common parent and add them +1 (for the connection between the 2).\\n        def get_common_parent(i, j):\\n            while i != j:\\n                if i > j:\\n                    i = i // 2\\n                else:\\n                    j = j // 2\\n            return i\\n        \\n        def get_level(i):\\n            return int(math.log2(i))\\n        \\n        ans = []\\n        for i, j in queries:\\n            common_parent = get_common_parent(i, j)\\n            parent_level = get_level(common_parent)\\n            i_level = get_level(i)\\n            j_level = get_level(j)\\n            ans.append((j_level-parent_level) + (i_level-parent_level) + 1)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        # Get common parent. That is it, problem ends because you just find length of both to common parent and add them +1 (for the connection between the 2).\\n        def get_common_parent(i, j):\\n            while i != j:\\n                if i > j:\\n                    i = i // 2\\n                else:\\n                    j = j // 2\\n            return i\\n        \\n        def get_level(i):\\n            return int(math.log2(i))\\n        \\n        ans = []\\n        for i, j in queries:\\n            common_parent = get_common_parent(i, j)\\n            parent_level = get_level(common_parent)\\n            i_level = get_level(i)\\n            j_level = get_level(j)\\n            ans.append((j_level-parent_level) + (i_level-parent_level) + 1)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613529,
                "title": "simple-nlogn-solutions-using-simple-maths",
                "content": "# Intuition\\nBinary tree concept\\n\\n# Approach\\nFinding the distance between two nodes\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  nlogn\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(auto &i: q)\\n        {\\n            int x=i[0];\\n            int y=i[1];\\n            if(x>y)\\n            swap(x,y);\\n            int cnt=0;\\n            while((int)log2(y)>(int)log2(x))\\n            {\\n                y/=2;\\n                ++cnt;\\n            }\\n            \\n            while(x!=y)\\n            {\\n                cnt+=2;\\n                x/=2;\\n                y/=2;\\n            }\\n            ++cnt;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(auto &i: q)\\n        {\\n            int x=i[0];\\n            int y=i[1];\\n            if(x>y)\\n            swap(x,y);\\n            int cnt=0;\\n            while((int)log2(y)>(int)log2(x))\\n            {\\n                y/=2;\\n                ++cnt;\\n            }\\n            \\n            while(x!=y)\\n            {\\n                cnt+=2;\\n                x/=2;\\n                y/=2;\\n            }\\n            ++cnt;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511324,
                "title": "a-concise-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReduce a and b to their common root.\\nAlways reduce the bigger one first until they both become the common root.\\n\\nParameter n is NOT even used.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(q) where q is number of queries.\\nSolve() is of constant complexity. Given an integer has limited bitwidth.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(q) where q is number of queries.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Solve(int a, int b) {\\n        int result = 0;\\n        while (a != b) {\\n            if (a < b) swap(a, b);\\n            a >>= 1;\\n            result++;\\n        }\\n        return result + 1;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> result;\\n        for (auto q: queries) result.push_back(Solve(q[0], q[1]));\\n        return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int Solve(int a, int b) {\\n        int result = 0;\\n        while (a != b) {\\n            if (a < b) swap(a, b);\\n            a >>= 1;\\n            result++;\\n        }\\n        return result + 1;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> result;\\n        for (auto q: queries) result.push_back(Solve(q[0], q[1]));\\n        return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510485,
                "title": "go-gpt-4-solution",
                "content": "\\n\\n# Intuition\\nThe problem requires finding the length of the cycle between two nodes in a binary tree. To calculate the cycle length, we first need to find the Lowest Common Ancestor (LCA) of the two nodes. Once we have the LCA, we can calculate the distance of each node to the LCA and add the contribution of the edge connecting the LCA to its parent to get the cycle length.\\n\\n# Approach\\nThe approach first involves finding the LCA of the two nodes, which can be done using a simple while loop that repeatedly divides the larger node by two until both nodes are the same or share a common ancestor. Once we have the LCA, we calculate the cycle length as the sum of the distances of each node to the LCA and add the edge\\'s contribution to the cycle length.\\n\\nWe iterate through each query in the input array, calculate the cycle length for each query, and store it in an array of answers. Finally, we return the array of answers.\\n\\n# Complexity\\n- Time complexity: \\n  - The time complexity of finding the LCA of two nodes is O(log n) because we are dividing the larger node by two at each step until both nodes share a common ancestor or are the same node.\\n  - We have m queries to process, so the overall time complexity of the algorithm is O(m log n).\\n  \\n- Space complexity:\\n  - We are only storing the answers to each query in an array of size m, so the space complexity of the algorithm is O(m).\\n\\n# Code\\n```\\n// Function to find the lowest common ancestor of two nodes in a binary tree\\nfunc findLCA(a, b int) int {\\n    for a != b {\\n        if a > b {\\n            a /= 2\\n        } else {\\n            b /= 2\\n        }\\n    }\\n    return a\\n}\\n\\nfunc cycleLengthQueries(n int, queries [][]int) []int {\\n    m := len(queries)\\n    answer := make([]int, m)\\n\\n    for i, query := range queries {\\n        a, b := query[0], query[1]\\n        lca := findLCA(a, b)\\n\\n        // Calculate the length of the cycle as the sum of the distances from a and b to their LCA, plus 1\\n        cycleLength := 0\\n        for a != lca {\\n            a /= 2\\n            cycleLength++\\n        }\\n        for b != lca {\\n            b /= 2\\n            cycleLength++\\n        }\\n        cycleLength++ // Add the edge\\'s contribution to the cycle length\\n\\n        answer[i] = cycleLength\\n    }\\n\\n    return answer\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Function to find the lowest common ancestor of two nodes in a binary tree\\nfunc findLCA(a, b int) int {\\n    for a != b {\\n        if a > b {\\n            a /= 2\\n        } else {\\n            b /= 2\\n        }\\n    }\\n    return a\\n}\\n\\nfunc cycleLengthQueries(n int, queries [][]int) []int {\\n    m := len(queries)\\n    answer := make([]int, m)\\n\\n    for i, query := range queries {\\n        a, b := query[0], query[1]\\n        lca := findLCA(a, b)\\n\\n        // Calculate the length of the cycle as the sum of the distances from a and b to their LCA, plus 1\\n        cycleLength := 0\\n        for a != lca {\\n            a /= 2\\n            cycleLength++\\n        }\\n        for b != lca {\\n            b /= 2\\n            cycleLength++\\n        }\\n        cycleLength++ // Add the edge\\'s contribution to the cycle length\\n\\n        answer[i] = cycleLength\\n    }\\n\\n    return answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3474868,
                "title": "easy-approach-find-lca-in-o-log-max-q-0-q-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we have to find the LCA of both the nodes. Then we can find the distance of both the nodes from LCA and our ans will be dist + 1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find LCA we can use the normal approach to find LCA by traversing the tree but considering constraints, this will give TLE. There is one approach in CP which helps us to find LCA in O(Log N) using segment tree and some other tools as well but as in this case the given tree is complete binary tree.\\nWe can just move to the parent in O(1) and we do this operation for both nodes until there parent is same.\\n\\nOne problem is there, what if both nodes are not cousin?\\nIn this case first we come to the that ancestor of younger node who is cousin of other node.\\nThis can be done using log base 2 function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*32) in worst case\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n\\n        for(auto vec:q) {\\n            int cnt = 0;\\n            int val1 = vec[0],val2=vec[1];\\n\\n            if(val1<val2) swap(val1,val2);\\n            int x = log2(val1), y=log2(val2);\\n            while(x != y) {\\n                cnt++;\\n                val1/=2;\\n                x = log2(val1);\\n            }\\n            while(val1!=val2) {\\n                val1/=2;val2/=2;cnt+=2;\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf any suggestions are there please add.",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n\\n        for(auto vec:q) {\\n            int cnt = 0;\\n            int val1 = vec[0],val2=vec[1];\\n\\n            if(val1<val2) swap(val1,val2);\\n            int x = log2(val1), y=log2(val2);\\n            while(x != y) {\\n                cnt++;\\n                val1/=2;\\n                x = log2(val1);\\n            }\\n            while(val1!=val2) {\\n                val1/=2;val2/=2;cnt+=2;\\n            }\\n            ans.push_back(cnt+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462509,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(queries.length)*log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n\\n        int ans[] = new int[queries.length];\\n\\n        int index = 0;\\n        for(int[] query:queries){\\n            int a = query[0];\\n            int b = query[1];\\n\\n            if(a==b){\\n                ans[index++] = 1;\\n                continue;\\n            }\\n\\n            HashSet<Integer>set1 = new HashSet();\\n            while(a>0){\\n                set1.add(a);\\n                a = (a%2==0)?a:--a;\\n                a/=2;\\n            }\\n\\n            HashSet<Integer>set2 = new HashSet();\\n            while(b>0){\\n                set2.add(b);\\n                b = (b%2==0)?b:--b;\\n                b/=2;\\n            }\\n            int res = set1.size()+set2.size();\\n            set1.retainAll(set2);\\n            res+=-2*set1.size()+1;\\n            ans[index++]=res;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n\\n        int ans[] = new int[queries.length];\\n\\n        int index = 0;\\n        for(int[] query:queries){\\n            int a = query[0];\\n            int b = query[1];\\n\\n            if(a==b){\\n                ans[index++] = 1;\\n                continue;\\n            }\\n\\n            HashSet<Integer>set1 = new HashSet();\\n            while(a>0){\\n                set1.add(a);\\n                a = (a%2==0)?a:--a;\\n                a/=2;\\n            }\\n\\n            HashSet<Integer>set2 = new HashSet();\\n            while(b>0){\\n                set2.add(b);\\n                b = (b%2==0)?b:--b;\\n                b/=2;\\n            }\\n            int res = set1.size()+set2.size();\\n            set1.retainAll(set2);\\n            res+=-2*set1.size()+1;\\n            ans[index++]=res;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453291,
                "title": "observation-and-lca",
                "content": "At first i used the method i knew for finding lca of two nodes in O(logn) but it tle.\\n\\n```\\nclass Solution {\\npublic:\\n    int _size, maxi;\\n    vector<vector<int>>sparse_table;\\n    \\n    void dfs(vector<int>&nodes, int node,  int parent){\\n          if(node >= _size)return;\\n        \\n          nodes[node] = nodes[parent]+1;\\n        \\n          dfs(nodes, node*2, node);\\n          dfs(nodes, node*2+1, node);\\n    }\\n    void _build_sparse_table(){\\n        \\n        for(int node = 1; node < _size; node++){\\n             \\n              for(int i = 1; i <=maxi; i++){\\n                    \\n                     if(sparse_table[node][i-1] !=-1)sparse_table[node][i] = sparse_table[sparse_table[node][i-1]][i-1];\\n              }\\n        }\\n        \\n    }\\n    \\n    int lca(int node1, int node2, vector<int>&nodes){\\n        \\n        // what is the lca between two nodes.\\n        if(nodes[node1] < nodes[node2])swap(node1, node2);\\n        \\n        int depth = nodes[node1]-nodes[node2];\\n    \\n        if(depth >0){\\n        \\n            int counter = 0;\\n            while(depth && node1!=-1){\\n                  if(depth&1){\\n                       node1 = sparse_table[node1][counter];\\n                  }\\n                  counter++;\\n                  depth>>=1;\\n            }\\n            \\n        }\\n       \\n        if(node1 ==node2) return  node1;\\n        \\n        for (int i = maxi; i >= 0; i--)\\n        {\\n            if (sparse_table[node1][i]!=-1 and sparse_table[node1][i] != sparse_table[node2][i])\\n            {\\n                node1 = sparse_table[node1][i];\\n                node2 = sparse_table[node2][i];\\n            }\\n        }\\n        \\n        return sparse_table[node1][0];\\n        \\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        _size = (1 <<n);\\n        vector<int>nodes(_size);\\n        \\n        nodes[1] = -1;\\n        dfs(nodes, 1, 1);\\n        \\n        maxi = log2(_size);\\n        sparse_table.resize(_size, vector<int>(maxi+1,-1));\\n        sparse_table[1][0] = -1;\\n        \\n        for(int i = 2; i < _size; i++){\\n             sparse_table[i][0] = i/2;\\n        }\\n        \\n        \\n        _build_sparse_table();\\n        \\n        vector<int>ans;\\n               \\n        for(auto& query : queries){\\n\\n             int x = query[0], y = query[1];\\n               int common = lca(query[0],query[1], nodes);\\n               ans.push_back(nodes[x]+nodes[y] - (2*nodes[common])+1);\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```\\ndue to vast number of queries.\\n\\nbut then after several trials i observed this\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int a, int b){\\n           int counter = 0;\\n        \\n           while(a!=b){\\n                 \\n                if(a < b){b/=2; counter++;}\\n                else if(a > b){ a/=2; counter++;}\\n                else{\\n                     a/=2;\\n                     b/=2;\\n                     counter+=2;\\n                }\\n           }\\n           return counter+1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>answer;\\n        \\n        for(auto& query : queries){\\n                \\n                answer.push_back(solve(query[0],query[1]));\\n        }\\n        \\n        return answer;\\n    }\\n};\\n\\n```\\n\\nthere is a pattern for getting the lca since all nodes are present from the given fact that a node has children (2*i+1) and (2*i+2)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int _size, maxi;\\n    vector<vector<int>>sparse_table;\\n    \\n    void dfs(vector<int>&nodes, int node,  int parent){\\n          if(node >= _size)return;\\n        \\n          nodes[node] = nodes[parent]+1;\\n        \\n          dfs(nodes, node*2, node);\\n          dfs(nodes, node*2+1, node);\\n    }\\n    void _build_sparse_table(){\\n        \\n        for(int node = 1; node < _size; node++){\\n             \\n              for(int i = 1; i <=maxi; i++){\\n                    \\n                     if(sparse_table[node][i-1] !=-1)sparse_table[node][i] = sparse_table[sparse_table[node][i-1]][i-1];\\n              }\\n        }\\n        \\n    }\\n    \\n    int lca(int node1, int node2, vector<int>&nodes){\\n        \\n        // what is the lca between two nodes.\\n        if(nodes[node1] < nodes[node2])swap(node1, node2);\\n        \\n        int depth = nodes[node1]-nodes[node2];\\n    \\n        if(depth >0){\\n        \\n            int counter = 0;\\n            while(depth && node1!=-1){\\n                  if(depth&1){\\n                       node1 = sparse_table[node1][counter];\\n                  }\\n                  counter++;\\n                  depth>>=1;\\n            }\\n            \\n        }\\n       \\n        if(node1 ==node2) return  node1;\\n        \\n        for (int i = maxi; i >= 0; i--)\\n        {\\n            if (sparse_table[node1][i]!=-1 and sparse_table[node1][i] != sparse_table[node2][i])\\n            {\\n                node1 = sparse_table[node1][i];\\n                node2 = sparse_table[node2][i];\\n            }\\n        }\\n        \\n        return sparse_table[node1][0];\\n        \\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        _size = (1 <<n);\\n        vector<int>nodes(_size);\\n        \\n        nodes[1] = -1;\\n        dfs(nodes, 1, 1);\\n        \\n        maxi = log2(_size);\\n        sparse_table.resize(_size, vector<int>(maxi+1,-1));\\n        sparse_table[1][0] = -1;\\n        \\n        for(int i = 2; i < _size; i++){\\n             sparse_table[i][0] = i/2;\\n        }\\n        \\n        \\n        _build_sparse_table();\\n        \\n        vector<int>ans;\\n               \\n        for(auto& query : queries){\\n\\n             int x = query[0], y = query[1];\\n               int common = lca(query[0],query[1], nodes);\\n               ans.push_back(nodes[x]+nodes[y] - (2*nodes[common])+1);\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int a, int b){\\n           int counter = 0;\\n        \\n           while(a!=b){\\n                 \\n                if(a < b){b/=2; counter++;}\\n                else if(a > b){ a/=2; counter++;}\\n                else{\\n                     a/=2;\\n                     b/=2;\\n                     counter+=2;\\n                }\\n           }\\n           return counter+1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>answer;\\n        \\n        for(auto& query : queries){\\n                \\n                answer.push_back(solve(query[0],query[1]));\\n        }\\n        \\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423842,
                "title": "simple-solution-lca-o-m",
                "content": "## time complexity = O(m*n) = O(m) -- n is constant (n_max = 30)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<int>v;\\n        for(auto it : queries){\\n            int a = it[0];\\n            int b = it[1];\\n\\n            int cnt = 1;\\n            while(a != b){\\n                if(a>b){\\n                    a/=2;\\n                    cnt++;\\n                }\\n                else{\\n                    b/=2;\\n                    cnt++;\\n                }\\n            }\\n            v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```\\n# upvote if it\\'s help you HAPPY CODIGN",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n\\n        vector<int>v;\\n        for(auto it : queries){\\n            int a = it[0];\\n            int b = it[1];\\n\\n            int cnt = 1;\\n            while(a != b){\\n                if(a>b){\\n                    a/=2;\\n                    cnt++;\\n                }\\n                else{\\n                    b/=2;\\n                    cnt++;\\n                }\\n            }\\n            v.push_back(cnt);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414174,
                "title": "c-fast-find-lca",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We need to Find the LCA first, the concept to find the lcs is same as LC1650\\n2. After, find the LCA, we need to count how many node from my current node to LCA, because we need to count my current node, therefore, the count = 1\\n3. Because we will count the root two times, therefore, we need to - 1 at our sum\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsuppose we have n node, we find the root, the worst case is log(n)\\nsuppose the queries size is m\\nTime complexity will be O(mlong(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDepend on if we need to count the returning array, if yes, it will be O(m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto& query : queries)\\n        {\\n            int n0 = query[0], n1 = query[1];\\n            while(n0 != n1)\\n            {\\n                n0 = (n0 == 1) ? query[1] : n0 / 2;\\n                n1 = (n1 == 1) ? query[0] : n1 / 2;\\n            }\\n            int root = n1;\\n            int count0 = 1, count1 = 1;\\n            n0 = query[0];\\n            n1 = query[1];\\n            while(n0 != root)\\n            {\\n                count0++;\\n                n0 /= 2;\\n            }\\n            while(n1 != root)\\n            {\\n                count1++;\\n                n1 /= 2;\\n            }\\n            int sum = count0 + count1 - 1;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto& query : queries)\\n        {\\n            int n0 = query[0], n1 = query[1];\\n            while(n0 != n1)\\n            {\\n                n0 = (n0 == 1) ? query[1] : n0 / 2;\\n                n1 = (n1 == 1) ? query[0] : n1 / 2;\\n            }\\n            int root = n1;\\n            int count0 = 1, count1 = 1;\\n            n0 = query[0];\\n            n1 = query[1];\\n            while(n0 != root)\\n            {\\n                count0++;\\n                n0 /= 2;\\n            }\\n            while(n1 != root)\\n            {\\n                count1++;\\n                n1 /= 2;\\n            }\\n            int sum = count0 + count1 - 1;\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409392,
                "title": "seems-my-solution-is-more-elegant-than-the-high-ranking-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int h(int a) {\\n        while ((a & (a -1)) != 0) {\\n            a = a & (a - 1);\\n        }\\n        return a;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        for (auto& q : queries) {\\n            int a = q[0], b = q[1];\\n            int r = 0;\\n            if (a < b) {\\n                int t = a; a = b; b = t;\\n            }\\n            // cout <<\"*\" << a << \" \" << b << endl;\\n            while (h(a) != h(b)) {\\n                a >>= 1;\\n                r++;\\n            }\\n            // cout << a << \" \" << b << endl;\\n            while (a != b) {\\n                a >>= 1;\\n                b >>= 1;\\n                r += 2;\\n                // cout << a << \" \" << b << endl;\\n            }\\n            v.push_back(r + 1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int h(int a) {\\n        while ((a & (a -1)) != 0) {\\n            a = a & (a - 1);\\n        }\\n        return a;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> v;\\n        for (auto& q : queries) {\\n            int a = q[0], b = q[1];\\n            int r = 0;\\n            if (a < b) {\\n                int t = a; a = b; b = t;\\n            }\\n            // cout <<\"*\" << a << \" \" << b << endl;\\n            while (h(a) != h(b)) {\\n                a >>= 1;\\n                r++;\\n            }\\n            // cout << a << \" \" << b << endl;\\n            while (a != b) {\\n                a >>= 1;\\n                b >>= 1;\\n                r += 2;\\n                // cout << a << \" \" << b << endl;\\n            }\\n            v.push_back(r + 1);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3408406,
                "title": "cpp-basic-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(int i =0; i < queries.size(); i++){\\n            map<int, int>mp;\\n            int start = max(queries[i][0], queries[i][1]), des = min(queries[i][1],queries[i][0]);\\n            int temp =1;\\n            while(start != 0){\\n                mp[start] = temp;\\n                temp++;\\n                start /=2;\\n            }\\n            temp =0;\\n            while(!mp[des]){\\n                mp[des] = temp;\\n                temp++;\\n                des /= 2;\\n            }\\n            ans.push_back(temp+mp[des]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(int i =0; i < queries.size(); i++){\\n            map<int, int>mp;\\n            int start = max(queries[i][0], queries[i][1]), des = min(queries[i][1],queries[i][0]);\\n            int temp =1;\\n            while(start != 0){\\n                mp[start] = temp;\\n                temp++;\\n                start /=2;\\n            }\\n            temp =0;\\n            while(!mp[des]){\\n                mp[des] = temp;\\n                temp++;\\n                des /= 2;\\n            }\\n            ans.push_back(temp+mp[des]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406615,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(), 0);\\n        for(int i = 0; i < queries.size(); i++){\\n            unordered_map<int, int> mp;\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            int d = 0;\\n            while(a > 1){\\n                mp[a] = d;\\n                if(a % 2 == 0) a /= 2;\\n                else{\\n                    a -= 1;\\n                    a /= 2;\\n                }\\n                d++;\\n            }\\n            mp[a] = d;\\n            d = 0;\\n            int res = -1;\\n            while(b > 1){\\n                if(mp.count(b)){\\n                    res = mp[b] + d;\\n                    break;\\n                }\\n                if(b % 2 == 0) b /= 2;\\n                else{\\n                    b -= 1;\\n                    b /= 2;\\n                }\\n                d++;\\n            }\\n            if(res == -1) res = mp[1] + d;\\n            ans[i] = res + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(), 0);\\n        for(int i = 0; i < queries.size(); i++){\\n            unordered_map<int, int> mp;\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            int d = 0;\\n            while(a > 1){\\n                mp[a] = d;\\n                if(a % 2 == 0) a /= 2;\\n                else{\\n                    a -= 1;\\n                    a /= 2;\\n                }\\n                d++;\\n            }\\n            mp[a] = d;\\n            d = 0;\\n            int res = -1;\\n            while(b > 1){\\n                if(mp.count(b)){\\n                    res = mp[b] + d;\\n                    break;\\n                }\\n                if(b % 2 == 0) b /= 2;\\n                else{\\n                    b -= 1;\\n                    b /= 2;\\n                }\\n                d++;\\n            }\\n            if(res == -1) res = mp[1] + d;\\n            ans[i] = res + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394056,
                "title": "c-explained-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif we can get the lowest common ancestor of the two noes being connected then the depth  of ai node from this par + depth of bi from this par +1 will be the xyxle length created if they are connected by an edge\\nsince the nodes can be at most 2^30 so 10^5 x 30 will be accepted\\nnow why x 30?\\nactally to reach the lowest common parent we have to reach the parent of the samller node until we get a common node par for both of the connecting nodes to reach one level up (or immediate parent node of a node)  id/2 since it is a full binary tree\\nby doing this we will eventually get the LCA node for both nodes no of divisions to reach LCA from a particular node is the no of edges\\ncycle length will be no of edges to reach ai + bi from the LCA +1 (for ne edge being added)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbinary tree O(m*h)  h->height\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n**PLS UPVOTE**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m=queries.size();\\n        vector<int> ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int x= 0; // divisions to reach par from ai\\n            int y= 0; // no of divisions to reach par from bi\\n            int a=queries[i][0];\\n            int b=queries[i][1];\\n            while(a!=b){\\n                if(a>b){\\n                    a=a>>1;\\n                    x++;\\n                }\\n                else{\\n                    b=b>>1;\\n                    y++;\\n                }\\n            }\\n            ans[i]=x+y+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m=queries.size();\\n        vector<int> ans(m,0);\\n        for(int i=0;i<m;i++){\\n            int x= 0; // divisions to reach par from ai\\n            int y= 0; // no of divisions to reach par from bi\\n            int a=queries[i][0];\\n            int b=queries[i][1];\\n            while(a!=b){\\n                if(a>b){\\n                    a=a>>1;\\n                    x++;\\n                }\\n                else{\\n                    b=b>>1;\\n                    y++;\\n                }\\n            }\\n            ans[i]=x+y+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389736,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n, queries):\\n        result = []\\n\\n        for i,j in queries:\\n            total = 1\\n\\n            while i != j:\\n                if i > j: i = i//2\\n                else: j = j//2\\n                total += 1\\n\\n            result.append(total)\\n\\n        return result\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n, queries):\\n        result = []\\n\\n        for i,j in queries:\\n            total = 1\\n\\n            while i != j:\\n                if i > j: i = i//2\\n                else: j = j//2\\n                total += 1\\n\\n            result.append(total)\\n\\n        return result\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344942,
                "title": "c-distance-to-lca",
                "content": "# Complexity\\n\\n- Time complexity: $$O(mn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int[] CycleLengthQueries(int n, int[][] queries)\\n    {\\n        int m = queries.Length;\\n\\n        int[] answer = new int[m];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            answer[i] = FindCycleLength(queries[i][0], queries[i][1]);\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int FindCycleLength(int a, int b)\\n    {\\n        var map = new Dictionary<int, int>();\\n\\n        int distance = 0;\\n        while (a > 0)\\n        {\\n            map.Add(a, distance++);\\n            a /= 2;\\n        }\\n        \\n        distance = 0;\\n        while (!map.ContainsKey(b))\\n        {\\n            distance++;\\n            b /= 2;\\n        }\\n\\n        return 1 + distance + map[b];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] CycleLengthQueries(int n, int[][] queries)\\n    {\\n        int m = queries.Length;\\n\\n        int[] answer = new int[m];\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            answer[i] = FindCycleLength(queries[i][0], queries[i][1]);\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int FindCycleLength(int a, int b)\\n    {\\n        var map = new Dictionary<int, int>();\\n\\n        int distance = 0;\\n        while (a > 0)\\n        {\\n            map.Add(a, distance++);\\n            a /= 2;\\n        }\\n        \\n        distance = 0;\\n        while (!map.ContainsKey(b))\\n        {\\n            distance++;\\n            b /= 2;\\n        }\\n\\n        return 1 + distance + map[b];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303799,
                "title": "c-100-faster-similar-to-lca-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    // TO GET A GOOD UNDERSTANDING OF LCA CONCEPT, I WOULD RECOMMEND **ERRICHTO\\'S VIDEO ON LCA**\\n    vector<int> pow;\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        if(pow.size() == 0){\\n            long long p = 1;\\n            while(p < INT_MAX){\\n                pow.push_back(p);\\n                p *= 2;\\n            }\\n            // 1 2 4 8 16 32 \\n        }\\n        \\n        auto LevelOf = [&](int n){\\n            auto it = lower_bound(begin(pow), end(pow), n) - begin(pow);\\n            if(pow[it] == n){\\n                return it + 1;\\n            }\\n            return it;\\n        };\\n        \\n        vector<int> ans;\\n        for(auto &q : queries){\\n            int a = q[0], b = q[1];\\n            int levA = LevelOf(a), levB = LevelOf(b);       // akin to depth in a binary tree\\n            int dist = 0;\\n            if(levA < levB){\\n                swap(a, b);\\n                swap(levA, levB);\\n            }\\n            while(levA != levB){\\n\\t\\t\\t    // ensuring both the nodes are on the same level \\n                a /= 2;\\n                levA--;\\n                dist++;\\n            }\\n            if(a == b){\\n                ans.push_back(dist + 1);        // +1 because of extra edge that is added during query\\n                continue;\\n            }\\n            \\n            while(a != b){\\n\\t\\t\\t   // moving one step closer to each other simultaneously\\n                a /= 2;\\n                b /= 2;\\n                dist += 2;\\n            }\\n            \\n            ans.push_back(dist + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // TO GET A GOOD UNDERSTANDING OF LCA CONCEPT, I WOULD RECOMMEND **ERRICHTO\\'S VIDEO ON LCA**\\n    vector<int> pow;\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        if(pow.size() == 0){\\n            long long p = 1;\\n            while(p < INT_MAX){\\n                pow.push_back(p);\\n                p *= 2;\\n            }\\n            // 1 2 4 8 16 32 \\n        }\\n        \\n        auto LevelOf = [&](int n){\\n            auto it = lower_bound(begin(pow), end(pow), n) - begin(pow);\\n            if(pow[it] == n){\\n                return it + 1;\\n            }\\n            return it;\\n        };\\n        \\n        vector<int> ans;\\n        for(auto &q : queries){\\n            int a = q[0], b = q[1];\\n            int levA = LevelOf(a), levB = LevelOf(b);       // akin to depth in a binary tree\\n            int dist = 0;\\n            if(levA < levB){\\n                swap(a, b);\\n                swap(levA, levB);\\n            }\\n            while(levA != levB){\\n\\t\\t\\t    // ensuring both the nodes are on the same level \\n                a /= 2;\\n                levA--;\\n                dist++;\\n            }\\n            if(a == b){\\n                ans.push_back(dist + 1);        // +1 because of extra edge that is added during query\\n                continue;\\n            }\\n            \\n            while(a != b){\\n\\t\\t\\t   // moving one step closer to each other simultaneously\\n                a /= 2;\\n                b /= 2;\\n                dist += 2;\\n            }\\n            \\n            ans.push_back(dist + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298675,
                "title": "java-100-easy-beginner-friendly-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Intution behind this problem is find the level of left part of the query ,level of right part of the query ,level of Least Common Ancestor of left and right  so that we could calculate the cyclic distance \\n\\nNow,\\n\\ndistance towards left from Least Common Ancestor \\n                             = left level - commonParent level \\ndistance towards right from Least Common Ancestor \\n                            =   right level - commonParent level \\nleft to right is always 1 (i.e a link is always attached between left and right through the given query )\\n\\nTherefore answer is distance towards left from Least Common Ancestor + distance towards right from Least Common Ancestor  + 1 \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int LeastCommonParent(int l,int r) {\\n\\n        if(l == r)\\n        {    return l;    }\\n        else if(l/2>r/2)\\n        {    return LeastCommonParent(l/2,r);    }\\n        else\\n        {    return LeastCommonParent(l,r/2);    }\\n\\n    }\\n\\n    public int level(int x)\\n    {\\n        if(x<=1)\\n            return 0;\\n        return (int) (  Math.log(x)/Math.log(2) ); \\n\\n    }\\n\\n    public int[] cycleLengthQueries(int n, int[][] queries) \\n    {\\n\\n        int ans [] = new int [queries.length];\\n\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n\\n            int commonParent = LeastCommonParent(left,right);\\n\\n            ans[i]= level(left) +  level(right) + 1 - (2*level(commonParent))  ; \\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int LeastCommonParent(int l,int r) {\\n\\n        if(l == r)\\n        {    return l;    }\\n        else if(l/2>r/2)\\n        {    return LeastCommonParent(l/2,r);    }\\n        else\\n        {    return LeastCommonParent(l,r/2);    }\\n\\n    }\\n\\n    public int level(int x)\\n    {\\n        if(x<=1)\\n            return 0;\\n        return (int) (  Math.log(x)/Math.log(2) ); \\n\\n    }\\n\\n    public int[] cycleLengthQueries(int n, int[][] queries) \\n    {\\n\\n        int ans [] = new int [queries.length];\\n\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n\\n            int commonParent = LeastCommonParent(left,right);\\n\\n            ans[i]= level(left) +  level(right) + 1 - (2*level(commonParent))  ; \\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298550,
                "title": "java-solution-from-huifeng-guan-youtube-video",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=PMKr2PKmyUY\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] ret = new int[queries.length];\\n        int idx = 0;\\n        for (int[] query : queries) {\\n            int a = query[0];\\n            int b = query[1];\\n            int count = 0;\\n\\n            while (a != b) {\\n                if (a > b) {\\n                    a = a/2;\\n                } else {\\n                    b = b/2;\\n                }\\n                count++;\\n            }\\n            ret[idx] = count + 1;\\n            idx++;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] ret = new int[queries.length];\\n        int idx = 0;\\n        for (int[] query : queries) {\\n            int a = query[0];\\n            int b = query[1];\\n            int count = 0;\\n\\n            while (a != b) {\\n                if (a > b) {\\n                    a = a/2;\\n                } else {\\n                    b = b/2;\\n                }\\n                count++;\\n            }\\n            ret[idx] = count + 1;\\n            idx++;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250563,
                "title": "c-solution",
                "content": "\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint find_root(int j, int k){\\n    int p = 1;\\n    while (j != k){\\n        if (j > k){\\n            j >>= 1;\\n        } else {\\n            k >>= 1;\\n        }\\n        p++;\\n    }\\n    return p;\\n}\\n\\n\\nint* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int* ans = malloc(sizeof(int)*queriesSize);\\n    *returnSize = queriesSize;\\n\\n    for (int i = 0 ; i < queriesSize ; i++){\\n        ans[i] = find_root(queries[i][0], queries[i][1]);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint find_root(int j, int k){\\n    int p = 1;\\n    while (j != k){\\n        if (j > k){\\n            j >>= 1;\\n        } else {\\n            k >>= 1;\\n        }\\n        p++;\\n    }\\n    return p;\\n}\\n\\n\\nint* cycleLengthQueries(int n, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int* ans = malloc(sizeof(int)*queriesSize);\\n    *returnSize = queriesSize;\\n\\n    for (int i = 0 ; i < queriesSize ; i++){\\n        ans[i] = find_root(queries[i][0], queries[i][1]);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231981,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[] CycleLengthQueries(int n, int[][] queries) {\\n        int m=queries.Length;\\n        int[] res=new int[m];\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            int a=queries[i][0];\\n            int b=queries[i][1];\\n            int da=0,db=0;\\n            int t=1;\\n            while(t<=a){\\n                t<<=1;\\n                da++;\\n            }\\n            t=1;\\n            while(t<=b){\\n                t<<=1;\\n                db++;\\n            }\\n            res[i]=1+Math.Abs(da-db);    \\n\\n            if(da>db)\\n                while(da-->db)\\n                    a=a/2;\\n            else if(db>da)\\n                while(db-->da)\\n                    b=b/2;\\n            while(a!=b)\\n            {\\n                a=a/2;\\n                b=b/2;\\n                res[i]+=2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] CycleLengthQueries(int n, int[][] queries) {\\n        int m=queries.Length;\\n        int[] res=new int[m];\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            int a=queries[i][0];\\n            int b=queries[i][1];\\n            int da=0,db=0;\\n            int t=1;\\n            while(t<=a){\\n                t<<=1;\\n                da++;\\n            }\\n            t=1;\\n            while(t<=b){\\n                t<<=1;\\n                db++;\\n            }\\n            res[i]=1+Math.Abs(da-db);    \\n\\n            if(da>db)\\n                while(da-->db)\\n                    a=a/2;\\n            else if(db>da)\\n                while(db-->da)\\n                    b=b/2;\\n            while(a!=b)\\n            {\\n                a=a/2;\\n                b=b/2;\\n                res[i]+=2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220618,
                "title": "go-simple-solution-by-finding-lowest-common-ancesstor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nconst (\\n\\tmaxN = 30\\n)\\n\\ntype Solution struct {\\n\\tbitOffset2BitNum [maxN + 2]int\\n\\tbitNum2BitOffset map[int]int\\n}\\n\\nfunc NewSolution() (retSolution *Solution) {\\n\\tretSolution = &Solution{}\\n\\tretSolution.bitOffset2BitNum = [maxN + 2]int{}\\n\\tretSolution.bitNum2BitOffset = make(map[int]int)\\n\\tlastBitNum := 1\\n\\tfor bitOffset := 0; bitOffset <= maxN+1; bitOffset += 1 {\\n\\t\\tretSolution.bitOffset2BitNum[bitOffset] = lastBitNum\\n\\t\\tretSolution.bitNum2BitOffset[lastBitNum] = bitOffset\\n\\t\\tlastBitNum = lastBitNum << 1\\n\\t}\\n\\treturn retSolution\\n}\\n\\nfunc (s *Solution) LowestCommonAncestor(a, b int) (retAncestor int) {\\n\\tif a == b {\\n\\t\\treturn a\\n\\t}\\n\\tif a > b {\\n\\t\\ta, b = b, a\\n\\t}\\n\\thsbOfA := s.HighestSignificantBitNum(a)\\n\\thsbOffsetOfA := s.bitNum2BitOffset[hsbOfA]\\n\\thsbOfB := s.HighestSignificantBitNum(b)\\n\\thsbOffsetOfB := s.bitNum2BitOffset[hsbOfB]\\n\\n\\tia := hsbOffsetOfA\\n\\tib := hsbOffsetOfB\\n\\tretAncestor = 0\\n\\tfor ia >= 0 && ib >= 0 {\\n\\t\\taBitNum := s.bitOffset2BitNum[ia] & a\\n\\t\\tbBitNum := s.bitOffset2BitNum[ib] & b\\n\\t\\tif (aBitNum > 0 && bBitNum > 0) || (aBitNum == 0 && bBitNum == 0) {\\n\\t\\t\\tia -= 1\\n\\t\\t\\tib -= 1\\n\\t\\t\\tretAncestor = retAncestor | aBitNum\\n\\t\\t} else {\\n\\t\\t\\tretAncestor = retAncestor >> (ia + 1)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn retAncestor\\n}\\n\\nfunc (s *Solution) HighestSignificantBitNum(num int) (retNum int) {\\n\\tlOffset := 0\\n\\thOffset := maxN + 1\\n\\tfor lOffset < hOffset {\\n\\t\\tmidOffset := lOffset + (hOffset-lOffset)>>1\\n\\t\\tmidOffsetBitNum := s.bitOffset2BitNum[midOffset]\\n\\t\\tif midOffsetBitNum < num {\\n\\t\\t\\tlOffset = midOffset + 1\\n\\t\\t\\t// retNum is the max bitNum such that retNum smaller than num\\n\\t\\t\\tretNum = midOffsetBitNum\\n\\t\\t} else if midOffsetBitNum > num {\\n\\t\\t\\thOffset = midOffset\\n\\t\\t} else {\\n\\t\\t\\tretNum = midOffsetBitNum\\n\\t\\t\\treturn retNum\\n\\t\\t}\\n\\t}\\n\\treturn retNum\\n}\\n\\nfunc (s *Solution) LevelInTree(num int) (retLevel int) {\\n\\thsb := s.HighestSignificantBitNum(num)\\n\\thsbOffset := s.bitNum2BitOffset[hsb]\\n\\tretLevel = hsbOffset\\n\\treturn retLevel\\n}\\n\\nfunc (s *Solution) cycleLengthQueries(n int, queries [][]int) (retCycleLenArr []int) {\\n\\tif n > maxN {\\n\\t\\tpanic(\"n > maxN\")\\n\\t} else if n <= 0 {\\n\\t\\tpanic(\"n not positive\")\\n\\t}\\n\\tretCycleLenArr = make([]int, len(queries))\\n\\tfor idx, query := range queries {\\n\\t\\ta, b := query[0], query[1]\\n\\t\\tif a > b {\\n\\t\\t\\ta, b = b, a\\n\\t\\t}\\n\\t\\tlca := s.LowestCommonAncestor(a, b)\\n\\t\\tif a == lca {\\n\\t\\t\\tretCycleLenArr[idx] = s.LevelInTree(b) - s.LevelInTree(a) + 1\\n\\t\\t} else {\\n\\t\\t\\tretCycleLenArr[idx] = s.LevelInTree(a) + s.LevelInTree(b) - 2*s.LevelInTree(lca) - -+1\\n\\t\\t}\\n\\t}\\n\\treturn retCycleLenArr\\n}\\n\\nfunc cycleLengthQueries(n int, queries [][]int) (retCycleLenArr []int) {\\n\\th := NewSolution()\\n\\tretCycleLenArr = h.cycleLengthQueries(n, queries)\\n\\treturn retCycleLenArr\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nconst (\\n\\tmaxN = 30\\n)\\n\\ntype Solution struct {\\n\\tbitOffset2BitNum [maxN + 2]int\\n\\tbitNum2BitOffset map[int]int\\n}\\n\\nfunc NewSolution() (retSolution *Solution) {\\n\\tretSolution = &Solution{}\\n\\tretSolution.bitOffset2BitNum = [maxN + 2]int{}\\n\\tretSolution.bitNum2BitOffset = make(map[int]int)\\n\\tlastBitNum := 1\\n\\tfor bitOffset := 0; bitOffset <= maxN+1; bitOffset += 1 {\\n\\t\\tretSolution.bitOffset2BitNum[bitOffset] = lastBitNum\\n\\t\\tretSolution.bitNum2BitOffset[lastBitNum] = bitOffset\\n\\t\\tlastBitNum = lastBitNum << 1\\n\\t}\\n\\treturn retSolution\\n}\\n\\nfunc (s *Solution) LowestCommonAncestor(a, b int) (retAncestor int) {\\n\\tif a == b {\\n\\t\\treturn a\\n\\t}\\n\\tif a > b {\\n\\t\\ta, b = b, a\\n\\t}\\n\\thsbOfA := s.HighestSignificantBitNum(a)\\n\\thsbOffsetOfA := s.bitNum2BitOffset[hsbOfA]\\n\\thsbOfB := s.HighestSignificantBitNum(b)\\n\\thsbOffsetOfB := s.bitNum2BitOffset[hsbOfB]\\n\\n\\tia := hsbOffsetOfA\\n\\tib := hsbOffsetOfB\\n\\tretAncestor = 0\\n\\tfor ia >= 0 && ib >= 0 {\\n\\t\\taBitNum := s.bitOffset2BitNum[ia] & a\\n\\t\\tbBitNum := s.bitOffset2BitNum[ib] & b\\n\\t\\tif (aBitNum > 0 && bBitNum > 0) || (aBitNum == 0 && bBitNum == 0) {\\n\\t\\t\\tia -= 1\\n\\t\\t\\tib -= 1\\n\\t\\t\\tretAncestor = retAncestor | aBitNum\\n\\t\\t} else {\\n\\t\\t\\tretAncestor = retAncestor >> (ia + 1)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\treturn retAncestor\\n}\\n\\nfunc (s *Solution) HighestSignificantBitNum(num int) (retNum int) {\\n\\tlOffset := 0\\n\\thOffset := maxN + 1\\n\\tfor lOffset < hOffset {\\n\\t\\tmidOffset := lOffset + (hOffset-lOffset)>>1\\n\\t\\tmidOffsetBitNum := s.bitOffset2BitNum[midOffset]\\n\\t\\tif midOffsetBitNum < num {\\n\\t\\t\\tlOffset = midOffset + 1\\n\\t\\t\\t// retNum is the max bitNum such that retNum smaller than num\\n\\t\\t\\tretNum = midOffsetBitNum\\n\\t\\t} else if midOffsetBitNum > num {\\n\\t\\t\\thOffset = midOffset\\n\\t\\t} else {\\n\\t\\t\\tretNum = midOffsetBitNum\\n\\t\\t\\treturn retNum\\n\\t\\t}\\n\\t}\\n\\treturn retNum\\n}\\n\\nfunc (s *Solution) LevelInTree(num int) (retLevel int) {\\n\\thsb := s.HighestSignificantBitNum(num)\\n\\thsbOffset := s.bitNum2BitOffset[hsb]\\n\\tretLevel = hsbOffset\\n\\treturn retLevel\\n}\\n\\nfunc (s *Solution) cycleLengthQueries(n int, queries [][]int) (retCycleLenArr []int) {\\n\\tif n > maxN {\\n\\t\\tpanic(\"n > maxN\")\\n\\t} else if n <= 0 {\\n\\t\\tpanic(\"n not positive\")\\n\\t}\\n\\tretCycleLenArr = make([]int, len(queries))\\n\\tfor idx, query := range queries {\\n\\t\\ta, b := query[0], query[1]\\n\\t\\tif a > b {\\n\\t\\t\\ta, b = b, a\\n\\t\\t}\\n\\t\\tlca := s.LowestCommonAncestor(a, b)\\n\\t\\tif a == lca {\\n\\t\\t\\tretCycleLenArr[idx] = s.LevelInTree(b) - s.LevelInTree(a) + 1\\n\\t\\t} else {\\n\\t\\t\\tretCycleLenArr[idx] = s.LevelInTree(a) + s.LevelInTree(b) - 2*s.LevelInTree(lca) - -+1\\n\\t\\t}\\n\\t}\\n\\treturn retCycleLenArr\\n}\\n\\nfunc cycleLengthQueries(n int, queries [][]int) (retCycleLenArr []int) {\\n\\th := NewSolution()\\n\\tretCycleLenArr = h.cycleLengthQueries(n, queries)\\n\\treturn retCycleLenArr\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3211791,
                "title": "c-simple-code-and-easy-to-understand-clean-code",
                "content": "# Complexity\\n- Time complexity:\\nO(n*60) because for any query there can be at max of 30 levels which will take total of at max 60 iterations.\\n\\n- Space complexity:\\nO(queries.size()) for storing the ans\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto x: queries){\\n            int currans = 1;\\n            int i = x[0], j = x[1];\\n            while(i!=j){\\n                if(i>j){\\n                    i/=2;\\n                }\\n                else{\\n                    j/=2;\\n                }\\n\\n                currans+=1;\\n            }\\n            ans.push_back(currans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto x: queries){\\n            int currans = 1;\\n            int i = x[0], j = x[1];\\n            while(i!=j){\\n                if(i>j){\\n                    i/=2;\\n                }\\n                else{\\n                    j/=2;\\n                }\\n\\n                currans+=1;\\n            }\\n            ans.push_back(currans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196497,
                "title": "find-lowest-common-ancestor-using-divide-2-until-equal-and-count-edges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind lowest common ancesstor and count edge while finding lca\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake first(f) and second(s) edge,\\nto find lca divide the greater edge by 2 and increment edge++,\\nwhen f==s mean they are at common ancestor and you have recorded all the edges and than store edge+1 because there is connecting edge between f and s,\\ndo for all the queries and return the array;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)*O(lca)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] a=new int[queries.length];\\n        for(int i=0,f,s,e;i<queries.length;i++){\\n            f=queries[i][0];s=queries[i][1];e=0;\\n            while(f!=s){\\n                if(f>s){\\n                    f=f/2;e++;\\n                }\\n                else{\\n                    s=s/2;e++;\\n                }\\n            }\\n            a[i]=e+1;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] a=new int[queries.length];\\n        for(int i=0,f,s,e;i<queries.length;i++){\\n            f=queries[i][0];s=queries[i][1];e=0;\\n            while(f!=s){\\n                if(f>s){\\n                    f=f/2;e++;\\n                }\\n                else{\\n                    s=s/2;e++;\\n                }\\n            }\\n            a[i]=e+1;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186444,
                "title": "c-calculate-bit-length-with-builtin-clz-o-1-time-complecity-per-query",
                "content": "Calculate the distance between two node directly without loop for each query.\\n```cpp\\nconstexpr int bit_len(uint32_t x) { return sizeof(x) * 8 - __builtin_clz(x); }\\n\\nclass Solution {\\npublic:\\n    static vector<int> cycleLengthQueries(int, const vector<vector<int>> &queries) {\\n        vector<int> ans;\\n        ans.reserve(queries.size());\\n        for (auto &&query: queries) {\\n            uint32_t x = query[0], y = query[1];\\n            if (x < y) swap(x, y);\\n            int t = bit_len(x) - bit_len(y);\\n            x >>= t;\\n            int diff = x ^ y;\\n            if (diff) t += 2 * bit_len(diff);\\n            ans.push_back(t + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nconstexpr int bit_len(uint32_t x) { return sizeof(x) * 8 - __builtin_clz(x); }\\n\\nclass Solution {\\npublic:\\n    static vector<int> cycleLengthQueries(int, const vector<vector<int>> &queries) {\\n        vector<int> ans;\\n        ans.reserve(queries.size());\\n        for (auto &&query: queries) {\\n            uint32_t x = query[0], y = query[1];\\n            if (x < y) swap(x, y);\\n            int t = bit_len(x) - bit_len(y);\\n            x >>= t;\\n            int diff = x ^ y;\\n            if (diff) t += 2 * bit_len(diff);\\n            ans.push_back(t + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162064,
                "title": "python-bitwise-fast-solution-explanation",
                "content": "\\n\\n# Approach\\nObserve that when you construct the tree you can find the parent node from any value simply by val >>= 1 (shifting it bitwise to the right).\\nTo find the loop size we need to find the common ancestor and count the steps it took to find it.\\n\\n1. Take the bigger number and shift it bitwise until both numbers are on the same level of the tree (increase counter i by one at every step):\\n```\\n            if a < b: a,b = b,a\\n            while len(bin(a)) != len(bin(b)): a,i = a >> 1, i +1\\n```\\n2. Once both numbers are at the same level shift them both until they are equal - which means common acnestor was found. Increase i by 2 at every step:\\n```\\n            while a != b: a,b,i = a >> 1, b >>1, i+2\\n```\\n3. We found the loop. Put i+1 into the result (to include the \"extra edge\")\\n4. Repeat for all queries.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        for a,b in queries:\\n            i = 0\\n            if a < b: a,b = b,a\\n            while len(bin(a)) != len(bin(b)): a,i = a >> 1, i +1\\n            while a != b: a,b,i = a >> 1, b >>1, i+2\\n            res.append(i+1)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n            if a < b: a,b = b,a\\n            while len(bin(a)) != len(bin(b)): a,i = a >> 1, i +1\\n```\n```\\n            while a != b: a,b,i = a >> 1, b >>1, i+2\\n```\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        \\n        res = []\\n        for a,b in queries:\\n            i = 0\\n            if a < b: a,b = b,a\\n            while len(bin(a)) != len(bin(b)): a,i = a >> 1, i +1\\n            while a != b: a,b,i = a >> 1, b >>1, i+2\\n            res.append(i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140734,
                "title": "simple-lca-of-query-nodes-easy-elegant-solution-specially-designed-for-begineer-s",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        // this is nothing but we have to find the LCA of the given queries[0],queries[1];\\n        vector<int>ans;\\n        for(auto x: queries){\\n            unordered_map<int,int>nodeValToLen; // calculating the length from src to root(node=1 here), So that we can use this later;\\n            int currLen=0;\\n            int src = x[0];\\n            int des = x[1];\\n            while(src!=0){\\n                nodeValToLen[src] = ++currLen;\\n                src=src/2;\\n            }\\n            currLen=0; // reseting the value for the des node;\\n            while(des!=0){\\n                currLen++;\\n                if(nodeValToLen.count(des)){ // if that node is already present in the map then it means that value is the LCA of the given nodes, For Complete binary tree the length would be the sum of that edges;\\n                    ans.push_back(nodeValToLen[des]-1 + currLen);  // calcuating the total number of edges between src--lca--des\\n                    break;\\n                }\\n                des=des/2;\\n            }\\n        }\\n        \\n        return ans; // returning the ans when the work is done\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        // this is nothing but we have to find the LCA of the given queries[0],queries[1];\\n        vector<int>ans;\\n        for(auto x: queries){\\n            unordered_map<int,int>nodeValToLen; // calculating the length from src to root(node=1 here), So that we can use this later;\\n            int currLen=0;\\n            int src = x[0];\\n            int des = x[1];\\n            while(src!=0){\\n                nodeValToLen[src] = ++currLen;\\n                src=src/2;\\n            }\\n            currLen=0; // reseting the value for the des node;\\n            while(des!=0){\\n                currLen++;\\n                if(nodeValToLen.count(des)){ // if that node is already present in the map then it means that value is the LCA of the given nodes, For Complete binary tree the length would be the sum of that edges;\\n                    ans.push_back(nodeValToLen[des]-1 + currLen);  // calcuating the total number of edges between src--lca--des\\n                    break;\\n                }\\n                des=des/2;\\n            }\\n        }\\n        \\n        return ans; // returning the ans when the work is done\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134594,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe intuiton is simple....in order of to form the circle or loop, the loop passes upto the nearest common ancestor....so find the nearest common ancestor and the distance from both the nodes to that ancestor....add the path length from both nodes to the ancestor and return the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni decreased a or b which ever is greater to its parent and added this action to my temporary value (t).....this \"t\" stores the path length from the nodes to the path......i decreased a or b until both them are equal i.e., until the reach their nearest common ancestor.\\n\\ncomment if you have any doubts.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlogn for finding the ancestor and we are doing it for size of the queries times(k)....so the time complexity is klogn....\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nhavent used any extra space O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &it:queries){\\n           int a = it[0];\\n           int b = it[1];\\n           int t = 0;\\n           while(a!=b){\\n               if(a>b){\\n                   a/=2;\\n               }else{\\n                   b/=2;\\n               }\\n                t++;\\n           }\\n           ans.push_back(t+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &it:queries){\\n           int a = it[0];\\n           int b = it[1];\\n           int t = 0;\\n           while(a!=b){\\n               if(a>b){\\n                   a/=2;\\n               }else{\\n                   b/=2;\\n               }\\n                t++;\\n           }\\n           ans.push_back(t+1);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122751,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> res(m, 1);\\n        for (int i = 0; i < m; ++i) {\\n            int x = queries[i][0], y = queries[i][1];\\n            while (x != y) {\\n                if (x > y)\\n                    x /= 2;\\n                else\\n                    y /= 2;\\n                res[i]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> res(m, 1);\\n        for (int i = 0; i < m; ++i) {\\n            int x = queries[i][0], y = queries[i][1];\\n            while (x != y) {\\n                if (x > y)\\n                    x /= 2;\\n                else\\n                    y /= 2;\\n                res[i]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120522,
                "title": "simple-c-soln-lca-find",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n// funtion to find lca\\n    int lcaFind(int u, int v){\\n        while(u!=v){\\n            if(u>v) u/=2;\\n            else v/=2;\\n        }\\n        return u;\\n    }\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& Q) {\\n        vector<int> ans;\\n        for(auto it : Q){\\n// calculating lca considering them as separate nodes\\n            int sum =int(log2(it[0]))+int(log2(it[1]))+1;\\n            int n = lcaFind(it[0], it[1]);\\n// if lca is found different then subtracting lca height from both of them\\n            if(n != 1){\\n                sum-=2*int(log2(n));\\n            }\\n// storing answer of each query\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n// funtion to find lca\\n    int lcaFind(int u, int v){\\n        while(u!=v){\\n            if(u>v) u/=2;\\n            else v/=2;\\n        }\\n        return u;\\n    }\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& Q) {\\n        vector<int> ans;\\n        for(auto it : Q){\\n// calculating lca considering them as separate nodes\\n            int sum =int(log2(it[0]))+int(log2(it[1]))+1;\\n            int n = lcaFind(it[0], it[1]);\\n// if lca is found different then subtracting lca height from both of them\\n            if(n != 1){\\n                sum-=2*int(log2(n));\\n            }\\n// storing answer of each query\\n            ans.push_back(sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108269,
                "title": "short-and-simple-solution-easy-to-understand-iit-roorkee",
                "content": "\\n# Complexity\\n- Time complexity: O(N*Log2(N))\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) \\n    {\\n       vector<int>ans;\\n       for(int j=0;j<queries.size();j++)\\n       {\\n           int count=1;\\n           int s=queries[j][0];\\n           int e=queries[j][1];\\n           while(s!=e)\\n           {\\n               if(s<e)\\n               {\\n                   e=e/2;\\n                   count++;\\n               }\\n               else\\n               {\\n                   s=s/2;\\n                   count++;\\n               }\\n           }\\n           ans.push_back(count);\\n       }    \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Binary Tree",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) \\n    {\\n       vector<int>ans;\\n       for(int j=0;j<queries.size();j++)\\n       {\\n           int count=1;\\n           int s=queries[j][0];\\n           int e=queries[j][1];\\n           while(s!=e)\\n           {\\n               if(s<e)\\n               {\\n                   e=e/2;\\n                   count++;\\n               }\\n               else\\n               {\\n                   s=s/2;\\n                   count++;\\n               }\\n           }\\n           ans.push_back(count);\\n       }    \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104386,
                "title": "python3-lowest-common-ancestor-with-bit-magic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLooking at the pictures, I noticed that the biggest circle always went over the lowest common ancestor of both nodes.\\n\\nThe second information one needs is that if you numerate your nodes like given in the problem description, the binary representation gives the path.\\n\\nE.G. 5 = 101 -> Starting at node 1 (1) go left (0 which then is node 2 = 10) and then right(1 which then is node 5 = 101)\\nE.G. 23 = 10111 -> Starting at node 1 (1) go left (0 which then is node 2 = 10) and then right(1 which then is node 5 = 101) then right (1 which is node 11= 1011) then right (which is node 23 = 10111)\\n\\nThen one needs to figure out how to find the LCA using this bit stuff, which took me a little while.\\n\\nBasically you alway go up a layer (right shift the number) for the bigger number of both until they are equal (paths met at the lowest common ancestor).\\n\\nAfter that we need to increase the counter by one to account for the new edge.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTree knowledge, Binary represenation is path, bitshifting\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logK) where N is the amount of queries and K is the amount of nodes (n in the problem description)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        # we could shift back the numbers until they are either equal\\n        # or both of them are zero\\n        def count_depth(node1, node2):\\n            result = 1\\n            while node1 != node2:\\n                if node1 > node2:\\n                    result += 1\\n                    node1 = node1 >> 1\\n                if node2 > node1:\\n                    result += 1\\n                    node2 = node2 >> 1\\n            return result\\n        return [count_depth(n1, n2) for n1, n2 in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n\\n        # we could shift back the numbers until they are either equal\\n        # or both of them are zero\\n        def count_depth(node1, node2):\\n            result = 1\\n            while node1 != node2:\\n                if node1 > node2:\\n                    result += 1\\n                    node1 = node1 >> 1\\n                if node2 > node1:\\n                    result += 1\\n                    node2 = node2 >> 1\\n            return result\\n        return [count_depth(n1, n2) for n1, n2 in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091616,
                "title": "c-bit-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        auto solve = [](int a, int b) {\\n            int ac = 31;\\n            int bc = 31;\\n            while(!(a & (1 << ac))) ac -= 1;\\n            while(!(b & (1 << bc))) bc -= 1;\\n            \\n            while(ac != -1 && bc != -1) {\\n                int aa = (a & (1 << ac));\\n                int bb = (b & (1 << bc));\\n                if((aa && !bb) || (!aa && bb)) break;\\n                ac -= 1; bc -= 1;\\n            }\\n            \\n            if(ac == -1) return bc + 2;\\n            if(bc == -1) return ac + 2;\\n            return ac + bc + 3;\\n        };\\n        \\n        vector<int> res(queries.size());\\n        for(int i = 0; i < queries.size(); i++) res[i] = solve(queries[i][0], queries[i][1]);\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        auto solve = [](int a, int b) {\\n            int ac = 31;\\n            int bc = 31;\\n            while(!(a & (1 << ac))) ac -= 1;\\n            while(!(b & (1 << bc))) bc -= 1;\\n            \\n            while(ac != -1 && bc != -1) {\\n                int aa = (a & (1 << ac));\\n                int bb = (b & (1 << bc));\\n                if((aa && !bb) || (!aa && bb)) break;\\n                ac -= 1; bc -= 1;\\n            }\\n            \\n            if(ac == -1) return bc + 2;\\n            if(bc == -1) return ac + 2;\\n            return ac + bc + 3;\\n        };\\n        \\n        vector<int> res(queries.size());\\n        for(int i = 0; i < queries.size(); i++) res[i] = solve(queries[i][0], queries[i][1]);\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042487,
                "title": "lca",
                "content": "# Code\\n```\\nint LCA(int a,int b){\\nwhile(a!=b){\\n    if(log2(a)==log2(b)){\\n        a=a>>1;\\n        b=b>>1;\\n    }\\n    else if(log2(a)>log2(b)) a=a>>1;\\n    else b=b>>1;\\n}\\nreturn a;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>res;\\n        for(auto &x:queries){\\n            int a=log2(x[0]),b=log2(x[1]),c=log2(LCA(x[0],x[1]));\\n            res.push_back(a+b-2*c+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nint LCA(int a,int b){\\nwhile(a!=b){\\n    if(log2(a)==log2(b)){\\n        a=a>>1;\\n        b=b>>1;\\n    }\\n    else if(log2(a)>log2(b)) a=a>>1;\\n    else b=b>>1;\\n}\\nreturn a;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>res;\\n        for(auto &x:queries){\\n            int a=log2(x[0]),b=log2(x[1]),c=log2(LCA(x[0],x[1]));\\n            res.push_back(a+b-2*c+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039563,
                "title": "92-64-faster-c-recursive-function-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    ll fun(ll x){\\n        return log2(x);\\n    }\\n\\n    ll solve(ll a,ll b){\\n        if(a==b)    return a;\\n        if(a>b)     return solve(a>>1,b); \\n        else        return solve(a,b>>1);\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        ll m=queries.size();\\n        vector<int>ans(m);\\n        for(ll i=0;i<m;i++){\\n            ll a=fun(queries[i][0]),b=fun(queries[i][1]),c=fun(solve(queries[i][0],queries[i][1]))<<1;\\n            ans[i]=a+b-c+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    ll fun(ll x){\\n        return log2(x);\\n    }\\n\\n    ll solve(ll a,ll b){\\n        if(a==b)    return a;\\n        if(a>b)     return solve(a>>1,b); \\n        else        return solve(a,b>>1);\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        ll m=queries.size();\\n        vector<int>ans(m);\\n        for(ll i=0;i<m;i++){\\n            ll a=fun(queries[i][0]),b=fun(queries[i][1]),c=fun(solve(queries[i][0],queries[i][1]))<<1;\\n            ans[i]=a+b-c+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037662,
                "title": "c-lca",
                "content": "# Intuition\\nFind z = LCA(x, y), result = dist(x, z) + dist(y, z) + 1\\n\\n# Complexity\\n- Time complexity:\\n$$O(30 * m)$$\\n\\n- Space complexity:\\n$$O(m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int len = queries.size();\\n        vector<int> ans(len);\\n        int x = 0;\\n        for (auto& query : queries) {\\n            int lo = query[0];\\n            int hi = query[1];\\n            if (lo > hi) {\\n                swap(lo, hi);\\n            }\\n            unordered_map<int, int> dist;\\n            int div = lo / 2;\\n            int cnt = 1;\\n            dist[lo] = 0;\\n            while (div > 0) {\\n                dist[div] = cnt++;\\n                div /= 2;\\n            }\\n            div = hi;\\n            cnt = 0;\\n            int result = 0;\\n            while (div > 0) {\\n                if (dist.count(div)) {\\n                    result = dist[div] + cnt + 1;\\n                    ans[x++] = result;\\n                    break;\\n                }\\n                div /= 2;\\n                ++cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int len = queries.size();\\n        vector<int> ans(len);\\n        int x = 0;\\n        for (auto& query : queries) {\\n            int lo = query[0];\\n            int hi = query[1];\\n            if (lo > hi) {\\n                swap(lo, hi);\\n            }\\n            unordered_map<int, int> dist;\\n            int div = lo / 2;\\n            int cnt = 1;\\n            dist[lo] = 0;\\n            while (div > 0) {\\n                dist[div] = cnt++;\\n                div /= 2;\\n            }\\n            div = hi;\\n            cnt = 0;\\n            int result = 0;\\n            while (div > 0) {\\n                if (dist.count(div)) {\\n                    result = dist[div] + cnt + 1;\\n                    ans[x++] = result;\\n                    break;\\n                }\\n                div /= 2;\\n                ++cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008430,
                "title": "simple-math-sol-in-cpp-o-m-time-complexity",
                "content": "# Simple Cpp Sol Using basics maths\\n\\n **Time Complexity :O(m)**\\n# Code<M>\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto x:queries)\\n        {\\n            int a=x[0];\\n            int b=x[1];\\n            if(a>b) swap(a,b);\\n            int h1=log2(a)+1;\\n            int h2=log2(b)+1;\\n            int temp=h1+h2;\\n            while(h1!=h2)\\n            {\\n                b=b/2;\\n                h2-=1;\\n            }  \\n            while(a!=b)\\n            {\\n                a/=2;\\n                b/=2;\\n            }\\n            int l=log2(a)+1;\\n            temp=temp-2*(l)+1;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto x:queries)\\n        {\\n            int a=x[0];\\n            int b=x[1];\\n            if(a>b) swap(a,b);\\n            int h1=log2(a)+1;\\n            int h2=log2(b)+1;\\n            int temp=h1+h2;\\n            while(h1!=h2)\\n            {\\n                b=b/2;\\n                h2-=1;\\n            }  \\n            while(a!=b)\\n            {\\n                a/=2;\\n                b/=2;\\n            }\\n            int l=log2(a)+1;\\n            temp=temp-2*(l)+1;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980772,
                "title": "10-liner-code-c-o-q-log-n-lca-easiest-solution-with-explanation",
                "content": "Since, It\\'s a complete binary tree with nodes ranging [1, 2^(n-1) - 1].\\nIt follows the follwing property:\\n* If node C is a child of node P, then P = C/2\\n```\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> answer;\\n        for(vector<int> q: queries) {\\n\\t\\t// finding the lowest common ancestor of node L and node R, also keeping the count of edges in the path\\n            int L=q[0], R=q[1], l=0, r=0;\\n            while(L!=R) {\\n                if(L>R) L/=2, l++;\\n                else    R/=2, r++;\\n            }\\n            answer.push_back(l+r+1); // adding 1 for the new edge that needs to added\\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> answer;\\n        for(vector<int> q: queries) {\\n\\t\\t// finding the lowest common ancestor of node L and node R, also keeping the count of edges in the path\\n            int L=q[0], R=q[1], l=0, r=0;\\n            while(L!=R) {\\n                if(L>R) L/=2, l++;\\n                else    R/=2, r++;\\n            }\\n            answer.push_back(l+r+1); // adding 1 for the new edge that needs to added\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2979823,
                "title": "easy-med-question-o-n-brainteaser-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &q:queries){\\n            int a=q[0], b=q[1];\\n            int parA= a, parB=b;\\n            while(parA!=parB){\\n                if(parA>parB) parA/=2;\\n                else  parB/=2;\\n            }\\n            int la= log2(a)+1, lb=log2(b)+1;\\n            int lc= parA=log2(parA)+1;\\n            ans.push_back(la+lb-(2*lc)+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Brainteaser",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &q:queries){\\n            int a=q[0], b=q[1];\\n            int parA= a, parB=b;\\n            while(parA!=parB){\\n                if(parA>parB) parA/=2;\\n                else  parB/=2;\\n            }\\n            int la= log2(a)+1, lb=log2(b)+1;\\n            int lc= parA=log2(parA)+1;\\n            ans.push_back(la+lb-(2*lc)+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964848,
                "title": "c-solution-beat-90",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        this->n = n;\\n        vector<int> res;\\n        for(auto& ele: queries){\\n            if(ele[0] == ele[1]){\\n                res.push_back(1);\\n                continue;\\n            }\\n\\n            int num = getNumEdges(ele[0], ele[1]);\\n            res.push_back(num);\\n        }\\n\\n        return res;\\n    }\\n\\n    int getNumEdges(int a, int b){\\n        int i = 30;\\n        int j = 30;\\n        while(true){\\n            int c = a & (1<<i);\\n            if(c != 0){\\n                break;\\n            }\\n            i--;\\n        }\\n\\n        while(true){\\n            int c = b & (1<<j);\\n            if(c!=0){\\n                break;\\n            }\\n            j--;\\n        }\\n\\n        int h1 = i;\\n        int h2 = j;\\n\\n        while(i>=0 && j>=0){\\n            int bit_a = (1<<i)&a;\\n            int bit_b = (1<<j)&b;\\n            if(bit_a !=0 && bit_b == 0){\\n                break;\\n            }\\n            if(bit_a == 0 && bit_b!=0){\\n                break;\\n            }\\n\\n            i--;\\n            j--;\\n        }\\n\\n        return i+1+j+1+1;\\n\\n\\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        this->n = n;\\n        vector<int> res;\\n        for(auto& ele: queries){\\n            if(ele[0] == ele[1]){\\n                res.push_back(1);\\n                continue;\\n            }\\n\\n            int num = getNumEdges(ele[0], ele[1]);\\n            res.push_back(num);\\n        }\\n\\n        return res;\\n    }\\n\\n    int getNumEdges(int a, int b){\\n        int i = 30;\\n        int j = 30;\\n        while(true){\\n            int c = a & (1<<i);\\n            if(c != 0){\\n                break;\\n            }\\n            i--;\\n        }\\n\\n        while(true){\\n            int c = b & (1<<j);\\n            if(c!=0){\\n                break;\\n            }\\n            j--;\\n        }\\n\\n        int h1 = i;\\n        int h2 = j;\\n\\n        while(i>=0 && j>=0){\\n            int bit_a = (1<<i)&a;\\n            int bit_b = (1<<j)&b;\\n            if(bit_a !=0 && bit_b == 0){\\n                break;\\n            }\\n            if(bit_a == 0 && bit_b!=0){\\n                break;\\n            }\\n\\n            i--;\\n            j--;\\n        }\\n\\n        return i+1+j+1+1;\\n\\n\\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964804,
                "title": "share-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        this->n = n;\\n        vector<int> res;\\n        for(auto& ele: queries){\\n            if(ele[0] == ele[1]){\\n                res.push_back(1);\\n                continue;\\n            }\\n\\n            int num = getNumEdges(ele[0], ele[1]);\\n            res.push_back(num);\\n        }\\n\\n        return res;\\n    }\\n\\n    int getNumEdges(int a, int b){\\n         vector<int> list_a;\\n         while(a!=0){\\n             list_a.push_back(a);\\n             a >>= 1;\\n         }\\n\\n        vector<int> list_b;\\n        while(b!=0){\\n            list_b.push_back(b);\\n            b >>= 1;\\n        }\\n\\n        reverse(list_a);\\n        reverse(list_b);\\n\\n        int i = 0;\\n        while(i<list_a.size() && i < list_b.size()){\\n            if(list_a[i] != list_b[i]){\\n                break;\\n            }\\n            i++;\\n        }\\n\\n        int h1 = list_a.size() - i;\\n        int h2 = list_b.size() - i;\\n        return h1 + h2 + 1; \\n    }\\n\\n    void reverse(vector<int>& a){\\n        int i = 0;\\n        int j = a.size()-1;\\n        while(i<j){\\n            int t = a[i];\\n            a[i] = a[j];\\n            a[j] = t;\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        this->n = n;\\n        vector<int> res;\\n        for(auto& ele: queries){\\n            if(ele[0] == ele[1]){\\n                res.push_back(1);\\n                continue;\\n            }\\n\\n            int num = getNumEdges(ele[0], ele[1]);\\n            res.push_back(num);\\n        }\\n\\n        return res;\\n    }\\n\\n    int getNumEdges(int a, int b){\\n         vector<int> list_a;\\n         while(a!=0){\\n             list_a.push_back(a);\\n             a >>= 1;\\n         }\\n\\n        vector<int> list_b;\\n        while(b!=0){\\n            list_b.push_back(b);\\n            b >>= 1;\\n        }\\n\\n        reverse(list_a);\\n        reverse(list_b);\\n\\n        int i = 0;\\n        while(i<list_a.size() && i < list_b.size()){\\n            if(list_a[i] != list_b[i]){\\n                break;\\n            }\\n            i++;\\n        }\\n\\n        int h1 = list_a.size() - i;\\n        int h2 = list_b.size() - i;\\n        return h1 + h2 + 1; \\n    }\\n\\n    void reverse(vector<int>& a){\\n        int i = 0;\\n        int j = a.size()-1;\\n        while(i<j){\\n            int t = a[i];\\n            a[i] = a[j];\\n            a[j] = t;\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954321,
                "title": "easy-python-solution",
                "content": "# Intuition\\n\\nIt\\'s a math problem.\\n\\n# Approach\\n\\nFind bigger guy\\'s ancestor by dividing it with 2\\n\\n# Complexity\\n- Time complexity:\\n\\nO(nlogn)\\nn for the loop, log n for find the common ancestor of the two nodes\\n- Space complexity:\\n\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n\\n\\n        for a, b in queries:\\n            p = 0\\n            while a !=b :\\n                c = max(a, b)\\n                b = min(a, b)\\n                a = c//2\\n                p += 1\\n            ans.append(p+1)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n\\n\\n        for a, b in queries:\\n            p = 0\\n            while a !=b :\\n                c = max(a, b)\\n                b = min(a, b)\\n                a = c//2\\n                p += 1\\n            ans.append(p+1)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954121,
                "title": "simple-easy-to-understand-solution",
                "content": "# Intuition\\nUse LCA concept to find the intersecting point of the two nodes of each query.\\n\\n# Approach\\nlog2(val) -> gives the depth of the current node.\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(mlog n)\\n    m->length of queries array\\n    n->max of the query value \\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lcaval(int x,int y)\\n    {\\n        while(x!=y)\\n        {\\n            if(x>y)\\n            {\\n                x=x/2;\\n            }\\n            else\\n            {\\n                y=y/2;\\n            }\\n        }\\n        return log2(x);\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n\\n        for(auto &q:queries)\\n        {\\n            int edges1=log2(q[0]);\\n            int edges2=log2(q[1]);\\n            ans.push_back(edges1+edges2+1-2*lcaval(q[0],q[1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lcaval(int x,int y)\\n    {\\n        while(x!=y)\\n        {\\n            if(x>y)\\n            {\\n                x=x/2;\\n            }\\n            else\\n            {\\n                y=y/2;\\n            }\\n        }\\n        return log2(x);\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n\\n        for(auto &q:queries)\\n        {\\n            int edges1=log2(q[0]);\\n            int edges2=log2(q[1]);\\n            ans.push_back(edges1+edges2+1-2*lcaval(q[0],q[1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953220,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(int bda , int chota)\\n    {\\n        if(bda<chota) return fun(chota , bda);\\n        if(bda==chota) return 1; //same node\\n        \\n        // if(dp.find(bda)!=dp.end() && dp[bda].find(chota)!=dp[bda].end())\\n        //     return dp[bda][chota];\\n        \\n        return fun(bda/2,chota)+1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),0);\\n        int ind=0;\\n        for(auto i : queries)\\n        {\\n            ans[ind++]=fun(i[0],i[1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(int bda , int chota)\\n    {\\n        if(bda<chota) return fun(chota , bda);\\n        if(bda==chota) return 1; //same node\\n        \\n        // if(dp.find(bda)!=dp.end() && dp[bda].find(chota)!=dp[bda].end())\\n        //     return dp[bda][chota];\\n        \\n        return fun(bda/2,chota)+1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(),0);\\n        int ind=0;\\n        for(auto i : queries)\\n        {\\n            ans[ind++]=fun(i[0],i[1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951042,
                "title": "very-simple-and-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: Qlog(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // void even(int &a)\\n    // {\\n    //     if(a%2!=0) a-1;\\n    // }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        int a,b,c,d;\\n        for(auto it:queries)\\n        {\\n            \\n            a=it[0];\\n            b=it[1];\\n            c=1;\\n            \\n            while(b!=a)\\n            {\\n                ++c;\\n                if(a>b)a/=2;\\n                else b/=2;\\n            }\\n            ans.push_back(c);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // void even(int &a)\\n    // {\\n    //     if(a%2!=0) a-1;\\n    // }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        int a,b,c,d;\\n        for(auto it:queries)\\n        {\\n            \\n            a=it[0];\\n            b=it[1];\\n            c=1;\\n            \\n            while(b!=a)\\n            {\\n                ++c;\\n                if(a>b)a/=2;\\n                else b/=2;\\n            }\\n            ans.push_back(c);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946492,
                "title": "easy-c-solution",
                "content": "**IF YOU FOUND THIS SOLUTION HELPFUL THEN PLEASE LIKE IT**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tfor(int i=0;i<queries.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a=queries[i][0];\\n\\t\\t\\t\\tint b=queries[i][1];\\n\\t\\t\\t\\tif(a==b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile(a!=b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(a>b)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta/=2;\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tb/=2;\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv.push_back(count+1);\\n\\t\\t\\t}\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tfor(int i=0;i<queries.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint a=queries[i][0];\\n\\t\\t\\t\\tint b=queries[i][1];\\n\\t\\t\\t\\tif(a==b)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tv.push_back(0);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2945686,
                "title": "java-o-nm-12-ms-faster-than-98-73-less-than-77-72",
                "content": "# Intuition\\nFind Lowest common ancestor (LCA) by bit operation\\n\\nEX: n = 3\\nLevel 1, Node 1: 0001 -> Bit 1\\n\\nLevel 2, Node 2: 0010 -> Bit 2\\nLevel 2, Node 3: 0011\\n\\nLevel 3, Node 4: 0100 -> Bit 3\\nLevel 3, Node 5: 0101\\nLevel 3, Node 6: 0110\\nLevel 3, Node 7: 0111\\n\\nIf A = 5, B = 3\\nA & 4 > 0, means A is at level 3\\nB & 2 > 0, means B is at level 2\\n\\nPerform right shift to find ancestors of A and B and also calculate the paths.\\n\\n# Complexity\\n- Time complexity: O(mn)\\n- Space complexity: O(m)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int m = queries.length;\\n        int[] ans = new int[m];\\n        int bit = 1 << (n-1);\\n        for (int i = 0; i < m; i++) {\\n            int level = bit;\\n            int A = queries[i][0];\\n            int B = queries[i][1];\\n            int pathA = 0;\\n            int pathB = 0;\\n            boolean shiftA = false;\\n            boolean shiftB = false;\\n            while (bit > 0) {\\n                if (A == B) break;\\n                if (shiftA) {\\n                    A >>= 1;\\n                    pathA++;\\n                }\\n                if (shiftB) {\\n                    B >>= 1;\\n                    pathB++;\\n                }\\n                if (!shiftA) shiftA = (A & level) > 0;\\n                if (!shiftB) shiftB = (B & level) > 0;\\n                level >>= 1;\\n            }\\n            ans[i] = pathA+pathB+1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int m = queries.length;\\n        int[] ans = new int[m];\\n        int bit = 1 << (n-1);\\n        for (int i = 0; i < m; i++) {\\n            int level = bit;\\n            int A = queries[i][0];\\n            int B = queries[i][1];\\n            int pathA = 0;\\n            int pathB = 0;\\n            boolean shiftA = false;\\n            boolean shiftB = false;\\n            while (bit > 0) {\\n                if (A == B) break;\\n                if (shiftA) {\\n                    A >>= 1;\\n                    pathA++;\\n                }\\n                if (shiftB) {\\n                    B >>= 1;\\n                    pathB++;\\n                }\\n                if (!shiftA) shiftA = (A & level) > 0;\\n                if (!shiftB) shiftB = (B & level) > 0;\\n                level >>= 1;\\n            }\\n            ans[i] = pathA+pathB+1;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945337,
                "title": "c-beats-99-8-bit-manipulation-lowest-common-ancestor",
                "content": "# Intuition\\nNode numbering follows the heap-in-array numbering. To count the loop length one needs to find the Lowest Common Ancestor for both nodes, then calculate the length from it to both nodes, sum it and add 1 (for the LCA)\\n\\n# Approach\\nWe can use a builtin function which calculates the number of leading zeros in the binary representation of an integer. Subtract it from 31 to receive the position of the first bit set in both node coordinates. Then progressively check (using shifts) how many first digits in a and b are equal. When the loop stops it is at the position of the first mismatch.\\n# Complexity\\n- Time complexity:\\n$$O(n*log(k))$$\\n\\n- Space complexity:\\n$$O(n)$$ for storing the result\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int> ret;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            // calculate the  number\\n\\xA0\\xA0\\xA0\\xA0        // of leading zeroes\\n\\xA0\\xA0\\xA0\\xA0        int az = __builtin_clz(a);\\n            int bz = __builtin_clz(b);\\n            while(az < 32 && bz < 32 && ((a >> (31-az)) & 1) == ((b >> (31-bz)) & 1))\\n            {\\n                az++; bz++;\\n            }\\n            ret.push_back(32 - az + 32 - bz + 1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int> ret;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int a = queries[i][0];\\n            int b = queries[i][1];\\n            // calculate the  number\\n\\xA0\\xA0\\xA0\\xA0        // of leading zeroes\\n\\xA0\\xA0\\xA0\\xA0        int az = __builtin_clz(a);\\n            int bz = __builtin_clz(b);\\n            while(az < 32 && bz < 32 && ((a >> (31-az)) & 1) == ((b >> (31-bz)) & 1))\\n            {\\n                az++; bz++;\\n            }\\n            ret.push_back(32 - az + 32 - bz + 1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944080,
                "title": "java-bit-manipulation-o-m-o-1",
                "content": "\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] answer = new int[queries.length];\\n        int a, b, cycle;\\n        for (int i = 0; i < queries.length; i++) {\\n            a = queries[i][0]; b = queries[i][1];\\n            cycle = bitLength(a) + bitLength(b) + 1;\\n            a = reverseBits(a); b = reverseBits(b);\\n            while (a != 1 && b != 1) {\\n                if ((a & 1) != (b & 1)) {\\n                    break;\\n                }\\n                a >>= 1; b >>= 1;\\n                cycle -= 2;\\n            }\\n            answer[i] = cycle;\\n        }\\n        return answer;\\n    }\\n\\n    private int bitLength(int num) {\\n        int length = 0;\\n        while (num != 0) {\\n            length++;\\n            num >>= 1;\\n        }\\n        return length; \\n    }\\n\\n    private int reverseBits(int num) {\\n        int reverse = 1;\\n        while (num != 0) {\\n            reverse = (reverse << 1) | (num & 1);\\n            num >>= 1;\\n        }\\n        return reverse;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] answer = new int[queries.length];\\n        int a, b, cycle;\\n        for (int i = 0; i < queries.length; i++) {\\n            a = queries[i][0]; b = queries[i][1];\\n            cycle = bitLength(a) + bitLength(b) + 1;\\n            a = reverseBits(a); b = reverseBits(b);\\n            while (a != 1 && b != 1) {\\n                if ((a & 1) != (b & 1)) {\\n                    break;\\n                }\\n                a >>= 1; b >>= 1;\\n                cycle -= 2;\\n            }\\n            answer[i] = cycle;\\n        }\\n        return answer;\\n    }\\n\\n    private int bitLength(int num) {\\n        int length = 0;\\n        while (num != 0) {\\n            length++;\\n            num >>= 1;\\n        }\\n        return length; \\n    }\\n\\n    private int reverseBits(int num) {\\n        int reverse = 1;\\n        while (num != 0) {\\n            reverse = (reverse << 1) | (num & 1);\\n            num >>= 1;\\n        }\\n        return reverse;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943580,
                "title": "sum-query-paths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n This similar to LCA. One needs to observe the levels and paths of the two nodes in the query.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n 1. Iterate over the queries and sum the query paths.\\n 2. Compare and count the path of query node values, divide the highest value by 2 and increase the path count of that node by 1. When the nodes values are equals, then sum the 2 paths plus 1 (ie is the cyclic connection).\\n 3. Return the sum of the query paths and set to the final array results.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    m(logn), where is the m = number of queries, and n \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n m(logn) -- due to the recursive stack calls\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] results = new int[queries.length];\\n        for(int index = 0; index< queries.length; index++){\\n            int[] query = queries[index];\\n            results[index] = countNodePath(query[0], query[1],0,0);\\n        }\\n        return results;\\n    }\\n    \\n    private int countNodePath(int node1, int node2, int path1, int path2){\\n          if(node1 == node2){\\n             return path1 + path2 + 1;\\n          }\\n          if(node1 > node2){\\n            return countNodePath(node1/2,node2, path1+1, path2);\\n          }\\n          else{\\n              return countNodePath(node1,node2/2, path1, path2 + 1);\\n          }\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] results = new int[queries.length];\\n        for(int index = 0; index< queries.length; index++){\\n            int[] query = queries[index];\\n            results[index] = countNodePath(query[0], query[1],0,0);\\n        }\\n        return results;\\n    }\\n    \\n    private int countNodePath(int node1, int node2, int path1, int path2){\\n          if(node1 == node2){\\n             return path1 + path2 + 1;\\n          }\\n          if(node1 > node2){\\n            return countNodePath(node1/2,node2, path1+1, path2);\\n          }\\n          else{\\n              return countNodePath(node1,node2/2, path1, path2 + 1);\\n          }\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943545,
                "title": "lca-and-bit-manipulation-c",
                "content": "# Code\\n```\\nclass Solution {\\n    void determinePath(int num, vector<int>& path){\\n        while(num != 1){\\n            path.push_back(num);\\n            if (num % 2 == 0){\\n                num /= 2;\\n            }else{\\n                num--;\\n                num/= 2;\\n            }\\n        }\\n        path.push_back(1);\\n        reverse(path.begin(), path.end());\\n    }\\n    int calcDepth(int num){\\n        for(int i=30; i>=0; i--){\\n            if ((num>>i & 1) == 1){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto& query: queries){\\n            vector<int> path1;\\n            determinePath(query[0], path1);\\n            vector<int> path2;\\n            determinePath(query[1], path2);\\n            int lca = 1;\\n            for(int i=0; i<min(path1.size(), path2.size()); i++){\\n                if (path1[i] != path2[i]){\\n                    break;\\n                }\\n                lca = path1[i];\\n            }\\n            int depth1 = calcDepth(query[0]);\\n            int depth2 = calcDepth(query[1]);\\n            int depth3 = calcDepth(lca);\\n            ans.push_back(depth1 + depth2 - 2* depth3 + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    void determinePath(int num, vector<int>& path){\\n        while(num != 1){\\n            path.push_back(num);\\n            if (num % 2 == 0){\\n                num /= 2;\\n            }else{\\n                num--;\\n                num/= 2;\\n            }\\n        }\\n        path.push_back(1);\\n        reverse(path.begin(), path.end());\\n    }\\n    int calcDepth(int num){\\n        for(int i=30; i>=0; i--){\\n            if ((num>>i & 1) == 1){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto& query: queries){\\n            vector<int> path1;\\n            determinePath(query[0], path1);\\n            vector<int> path2;\\n            determinePath(query[1], path2);\\n            int lca = 1;\\n            for(int i=0; i<min(path1.size(), path2.size()); i++){\\n                if (path1[i] != path2[i]){\\n                    break;\\n                }\\n                lca = path1[i];\\n            }\\n            int depth1 = calcDepth(query[0]);\\n            int depth2 = calcDepth(query[1]);\\n            int depth3 = calcDepth(lca);\\n            ans.push_back(depth1 + depth2 - 2* depth3 + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942481,
                "title": "cpp-naive-o-nlogn-akash-kumar-nit-delhi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLowest Common Ancestor for the node a and b. find the height of a ,b and lowest common ancestor node. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn my approach I have first tried to find out  the level of the node a and  b. after that  I found the common node for both a and b. i.e the lowest common ancestor. To find the lowest common ancestor in o(logn). Firstly I bring both the nodes at the same level.Then we take the both nodes up to the parent until they meet at common node by simply dividing both number by 2. Finally I found the height of a, b and common nodes and initialised answer=height(a)+height(b)-2*height(LCA)+1. +1 is for adding the common node in the cycle.  \\n\\n# Complexity\\n- Time complexity:\\nAdd your time complexity here, e.g. $$O(nlogn)$$\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    //funcion for finding the level of the number.\\n    int Level(int num)\\n    {\\n        int level,greater;\\n        for(int i=1;i<=30;i++)\\n        {\\n            greater=pow(2,i);\\n            if(greater>num)\\n            {\\n                level=i;\\n                break;\\n            }\\n        }\\n        \\n        return level;\\n    }\\n    //It Uses The Concept Of Lowest Common Ancestors i.e LCA.\\n    //First Level: 2^0 , Second Level: 2^1 to 2^2-1,  Third Level: 2^level-1 to 2^level--1.\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> res;\\n        for(int i=0;i<queries.size();i++)\\n        {   \\n            //initialising all the parameters.\\n            int a=queries[i][0],b=queries[i][1],a1=Level(a),b1=Level(b),save=max(a1,b1);\\n            //if level of a is greater than level of b bring a to the level of b.\\n            if(a1>b1)\\n            {\\n               while(save!=b1)\\n               a/=2, save--;\\n            } //if level of b is greater than level of a bring b to the level of a.\\n            else if(a1<b1)\\n            {\\n               while(save!=a1)\\n               b/=2, save--;  \\n            }\\n            //finding the common node.\\n            int root1=a,root2=b,rootlevel,ans;\\n               while(root1!=root2)\\n                root1/=2,root2/=2;\\n            //finding the level of the common node.\\n            rootlevel=Level(root1),ans=a1+b1-2*rootlevel+1;\\n            //pushing answer to the result vector.\\n            res.push_back(ans);\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //funcion for finding the level of the number.\\n    int Level(int num)\\n    {\\n        int level,greater;\\n        for(int i=1;i<=30;i++)\\n        {\\n            greater=pow(2,i);\\n            if(greater>num)\\n            {\\n                level=i;\\n                break;\\n            }\\n        }\\n        \\n        return level;\\n    }\\n    //It Uses The Concept Of Lowest Common Ancestors i.e LCA.\\n    //First Level: 2^0 , Second Level: 2^1 to 2^2-1,  Third Level: 2^level-1 to 2^level--1.\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int> res;\\n        for(int i=0;i<queries.size();i++)\\n        {   \\n            //initialising all the parameters.\\n            int a=queries[i][0],b=queries[i][1],a1=Level(a),b1=Level(b),save=max(a1,b1);\\n            //if level of a is greater than level of b bring a to the level of b.\\n            if(a1>b1)\\n            {\\n               while(save!=b1)\\n               a/=2, save--;\\n            } //if level of b is greater than level of a bring b to the level of a.\\n            else if(a1<b1)\\n            {\\n               while(save!=a1)\\n               b/=2, save--;  \\n            }\\n            //finding the common node.\\n            int root1=a,root2=b,rootlevel,ans;\\n               while(root1!=root2)\\n                root1/=2,root2/=2;\\n            //finding the level of the common node.\\n            rootlevel=Level(root1),ans=a1+b1-2*rootlevel+1;\\n            //pushing answer to the result vector.\\n            res.push_back(ans);\\n            \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941623,
                "title": "c-very-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& qr) {\\n         vector<int>ans(qr.size());\\n         int i=0;\\n         for(auto it : qr){\\n             int f = it[0];\\n             int s = it[1];\\n             vector<int>p1,p2;\\n             while(f>0){\\n                 p1.push_back(f);\\n                 f = f/2;\\n             }\\n             while(s>0){\\n                 p2.push_back(s);\\n                 s=s/2;\\n             }\\n             reverse(p1.begin(),p1.end());\\n             reverse(p2.begin(),p2.end());\\n             int x=0;\\n             while(x<p1.size() && x<p2.size()){\\n                 if(p1[x] != p2[x])\\n                     break;\\n                 x++;\\n             }\\n             ans[i++]=(p1.size()-x)+(p2.size()-x)+1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& qr) {\\n         vector<int>ans(qr.size());\\n         int i=0;\\n         for(auto it : qr){\\n             int f = it[0];\\n             int s = it[1];\\n             vector<int>p1,p2;\\n             while(f>0){\\n                 p1.push_back(f);\\n                 f = f/2;\\n             }\\n             while(s>0){\\n                 p2.push_back(s);\\n                 s=s/2;\\n             }\\n             reverse(p1.begin(),p1.end());\\n             reverse(p2.begin(),p2.end());\\n             int x=0;\\n             while(x<p1.size() && x<p2.size()){\\n                 if(p1[x] != p2[x])\\n                     break;\\n                 x++;\\n             }\\n             ans[i++]=(p1.size()-x)+(p2.size()-x)+1;\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940560,
                "title": "a-simple-o-log-n-2-solution-in-c",
                "content": "# Intuition\\nFind a common node in the path of each node to the root.\\n\\n# Approach\\nFind a path to the root for smaller node and push the path into a vector. Go upward through the graph for the larger node and for each node in this path check if the current node is available in the vector or not. If it was available the result is the distance of each node with the common node plus one.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n)^2)\\n\\n- Space complexity:\\nO(log(n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find_dist(int a,int b){\\n        vector<int>v;\\n        if(a<b) swap(a,b);\\n        while(b>0){\\n            v.push_back(b);\\n            b/=2;\\n        }\\n        int c=0;\\n        while(a>0){\\n            auto it = find(begin(v),end(v),a);\\n            if(it!=v.end())\\n                return c+(it-v.begin())+1;\\n            c++;\\n            a/=2;\\n        }\\n        return (log(a)+log(b))/log(2)+1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> res;\\n        for(auto &a:q){\\n            res.push_back(find_dist(a[0],a[1]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_dist(int a,int b){\\n        vector<int>v;\\n        if(a<b) swap(a,b);\\n        while(b>0){\\n            v.push_back(b);\\n            b/=2;\\n        }\\n        int c=0;\\n        while(a>0){\\n            auto it = find(begin(v),end(v),a);\\n            if(it!=v.end())\\n                return c+(it-v.begin())+1;\\n            c++;\\n            a/=2;\\n        }\\n        return (log(a)+log(b))/log(2)+1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> res;\\n        for(auto &a:q){\\n            res.push_back(find_dist(a[0],a[1]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940220,
                "title": "clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for (auto &pair: queries){\\n            int larger, smaller;\\n            if (pair[0] > pair[1]){\\n                arger = pair[0];\\n                smaller = pair[1];\\n            }else {\\n                larger = pair[1];\\n                smaller = pair[0];\\n            }\\n            int count(0);\\n            while (larger != smaller){\\n                if (larger > smaller){\\n                    larger /= 2;\\n                    count++;\\n                }else{\\n                    smaller /=2;\\n                    count++;\\n                }\\n            }\\n            ans.push_back(++count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for (auto &pair: queries){\\n            int larger, smaller;\\n            if (pair[0] > pair[1]){\\n                arger = pair[0];\\n                smaller = pair[1];\\n            }else {\\n                larger = pair[1];\\n                smaller = pair[0];\\n            }\\n            int count(0);\\n            while (larger != smaller){\\n                if (larger > smaller){\\n                    larger /= 2;\\n                    count++;\\n                }else{\\n                    smaller /=2;\\n                    count++;\\n                }\\n            }\\n            ans.push_back(++count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938755,
                "title": "lowest-common-ancestor-lca",
                "content": "# Approach\\nLowest Common Ancestor\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number} _\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nconst cycleLengthQueries = (_, queries) => {\\n    return queries.map(([a, b]) => {\\n        let result = 1;\\n        while (a !== b) {\\n            if (a > b) {\\n                [a, b] = [b, a]\\n            }\\n\\n            b >>= 1;\\n            result++;\\n        }\\n\\n        return result;\\n    })\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} _\\n * @param {number[][]} queries\\n * @return {number[]}\\n */\\nconst cycleLengthQueries = (_, queries) => {\\n    return queries.map(([a, b]) => {\\n        let result = 1;\\n        while (a !== b) {\\n            if (a > b) {\\n                [a, b] = [b, a]\\n            }\\n\\n            b >>= 1;\\n            result++;\\n        }\\n\\n        return result;\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2938071,
                "title": "lca-simple-beginner-friendly-solution",
                "content": "# Intuition\\nans[i] = 1+ dist from root for node1 + dist from root for node2  - (2*dist from root for lca of node1 and node2);\\n\\n# Approach\\ndist from root is the index left most set bit, counting begins from right. \\n\\n# Complexity\\n- Time complexity:\\nO(m*log(n))\\n\\n- Space complexity:\\nO(1) excluding the space required for answer.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int len = queries.length;\\n        int[] ans = new int[len];\\n        int pos = 0;\\n        for(int[] q: queries){\\n            int s1 = getDist(q[0]);\\n            int s2 = getDist(q[1]);\\n            int s3 = getDist(getLCA(q[0],q[1]));\\n            \\n            ans[pos++] = 1+s1+s2-(2*s3);\\n        }\\n        return ans;\\n    }\\n    \\n    private int getDist(int n){\\n        int dist = 0;\\n        while(n>0){\\n            dist++;\\n            n/=2;\\n        }\\n        return dist-1;\\n    }\\n    \\n    private int getLCA(int a1, int b1){\\n        int a = a1;\\n        int b = b1;\\n        \\n        while(a!=b){\\n            a= a==1?b1:a/2;\\n            b= b==1?a1:b/2;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int len = queries.length;\\n        int[] ans = new int[len];\\n        int pos = 0;\\n        for(int[] q: queries){\\n            int s1 = getDist(q[0]);\\n            int s2 = getDist(q[1]);\\n            int s3 = getDist(getLCA(q[0],q[1]));\\n            \\n            ans[pos++] = 1+s1+s2-(2*s3);\\n        }\\n        return ans;\\n    }\\n    \\n    private int getDist(int n){\\n        int dist = 0;\\n        while(n>0){\\n            dist++;\\n            n/=2;\\n        }\\n        return dist-1;\\n    }\\n    \\n    private int getLCA(int a1, int b1){\\n        int a = a1;\\n        int b = b1;\\n        \\n        while(a!=b){\\n            a= a==1?b1:a/2;\\n            b= b==1?a1:b/2;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938065,
                "title": "greedy-search-with-bit-base-idea-is-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nto find cycle\\'s root node, shift node\\'value  which means move to leaf node\\nthe length of cycle is same as move count to find union node\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        m = len(queries)\\n        res = [0]* m\\n        \\n        @cache\\n        def dp(a, b):\\n\\n            if a ==b:\\n                return 1\\n\\n            if a == 1:\\n                return dp(a, b>>1) + 1\\n            if b == 1:\\n                return dp(a>>1, b) + 1\\n            if a< b:\\n                return dp(a, b>>1) +1\\n            else:\\n                return dp(a>>1, b) + 1\\n\\n        for i in range(m):\\n            a, b = queries[i]\\n            res[i]= dp(a,b)\\n\\n        return res\\n    \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        m = len(queries)\\n        res = [0]* m\\n        \\n        @cache\\n        def dp(a, b):\\n\\n            if a ==b:\\n                return 1\\n\\n            if a == 1:\\n                return dp(a, b>>1) + 1\\n            if b == 1:\\n                return dp(a>>1, b) + 1\\n            if a< b:\\n                return dp(a, b>>1) +1\\n            else:\\n                return dp(a>>1, b) + 1\\n\\n        for i in range(m):\\n            a, b = queries[i]\\n            res[i]= dp(a,b)\\n\\n        return res\\n    \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937523,
                "title": "java-easiest-solution-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif we can find find common parent, we can calculate total nodes in the cycle with depth of both nodes from common parent.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor every query:\\n1. Calculate all parent with depth for node 1.\\n2. Calculate all parent with depth for node 2.\\n3. Calculate common parent with help of result 1 and 2.\\n4. Total number of nodes int the cycle will be depth of node1 from common parent + depth of node2 from common oarent + 1\\n\\ni.e for first exmaple\\nNode1 parent : [{5, 3}, {2, 2}, {1, 1}]\\nNode2 parent : [{3, 2}, {1, 1}]\\nCommon parent = {1, 1}\\nTotal number of nodes = (3 - 1) + (2 - 1) + 1 = 4\\n\\nP.S : Input node is also added in parent list because it is potential common parent.\\n\\n# Complexity\\n- Time complexity: mlogn  [m : number of queries, n : Maximum input]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: m + logn [m : number of queries, n : Maximum input]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] res = new int[queries.length];\\n        int i = 0;\\n       for(int[] q : queries) {\\n           List<int[]> parent1 = parentList(q[0]);\\n           List<int[]> parent2 = parentList(q[1]);\\n           res[i++] = getCycleLength(parent1, parent2);\\n       }\\n      return res; \\n    }\\n    \\n    public List<int[]> parentList(int n) {\\n        List<int[]> list = new ArrayList<>();\\n        int i = (int) Math.ceil(Math.log(n+1)/ Math.log(2));\\n        while(n > 0){\\n            list.add(new int[]{n, i--});\\n            n /= 2;\\n        }\\n        return list;\\n    }\\n    \\n    public int getCycleLength(List<int[]> p1, List<int[]> p2) {\\n        int i = 0, j = 0;\\n        while(i < p1.size() && j < p2.size()) {\\n            if(p1.get(i)[1] > p2.get(j)[1]) i++;\\n            else if(p1.get(i)[1] < p2.get(j)[1]) j++;\\n            else if(p1.get(i)[0] == p2.get(j)[0]) return p1.get(0)[1] - p1.get(i)[1] + p2.get(0)[1] - p2.get(j)[1] + 1; \\n            else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int[] res = new int[queries.length];\\n        int i = 0;\\n       for(int[] q : queries) {\\n           List<int[]> parent1 = parentList(q[0]);\\n           List<int[]> parent2 = parentList(q[1]);\\n           res[i++] = getCycleLength(parent1, parent2);\\n       }\\n      return res; \\n    }\\n    \\n    public List<int[]> parentList(int n) {\\n        List<int[]> list = new ArrayList<>();\\n        int i = (int) Math.ceil(Math.log(n+1)/ Math.log(2));\\n        while(n > 0){\\n            list.add(new int[]{n, i--});\\n            n /= 2;\\n        }\\n        return list;\\n    }\\n    \\n    public int getCycleLength(List<int[]> p1, List<int[]> p2) {\\n        int i = 0, j = 0;\\n        while(i < p1.size() && j < p2.size()) {\\n            if(p1.get(i)[1] > p2.get(j)[1]) i++;\\n            else if(p1.get(i)[1] < p2.get(j)[1]) j++;\\n            else if(p1.get(i)[0] == p2.get(j)[0]) return p1.get(0)[1] - p1.get(i)[1] + p2.get(0)[1] - p2.get(j)[1] + 1; \\n            else {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935486,
                "title": "python-lca-o-30m-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        res = []\\n        for v, w in queries:\\n            vpath, wpath = [],[]\\n            while v > 0:\\n                vpath.append(v)\\n                v //= 2\\n            while w > 0:\\n                wpath.append(w)\\n                w //= 2\\n            vpath.reverse()\\n            wpath.reverse()\\n            lv, lw = len(vpath), len(wpath)\\n            minl = min(lv, lw)\\n            tmpres = max(lv, lw) - min(lv, lw) + 1\\n            j = minl - 1\\n            while vpath[j] != wpath[j]:\\n                tmpres += 2\\n                j -= 1\\n            res.append(tmpres)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        res = []\\n        for v, w in queries:\\n            vpath, wpath = [],[]\\n            while v > 0:\\n                vpath.append(v)\\n                v //= 2\\n            while w > 0:\\n                wpath.append(w)\\n                w //= 2\\n            vpath.reverse()\\n            wpath.reverse()\\n            lv, lw = len(vpath), len(wpath)\\n            minl = min(lv, lw)\\n            tmpres = max(lv, lw) - min(lv, lw) + 1\\n            j = minl - 1\\n            while vpath[j] != wpath[j]:\\n                tmpres += 2\\n                j -= 1\\n            res.append(tmpres)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935112,
                "title": "c-lowest-common-ancestor-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int> ans;\\n        for(auto &q:queries)\\n        {\\n            int a=q[0],b=q[1];\\n            int d=0;\\n            while(a!=b)\\n            {\\n                if(a>b)\\n                    a/=2;\\n                else\\n                    b/=2;\\n                d++;\\n            }\\n            ans.push_back(d+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) \\n    {\\n        vector<int> ans;\\n        for(auto &q:queries)\\n        {\\n            int a=q[0],b=q[1];\\n            int d=0;\\n            while(a!=b)\\n            {\\n                if(a>b)\\n                    a/=2;\\n                else\\n                    b/=2;\\n                d++;\\n            }\\n            ans.push_back(d+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934609,
                "title": "simple-o-qn-approach",
                "content": "Since the binary tree is a special tree. we can observe that for a node with value v its parent has value v/2. \\nNow there are 2 cases:\\n\\n1. If both nodes are at same level then simple keep moving up the parent of both the nodes till they have the same parent and keep counting the nodes O(n)\\n\\n2. If both nodes are at different levels then first move the node at deeper level to shallow level by dividing it by 2. Once both nodes are at same level follow the step 1\\n\\n```\\nclass Solution {\\npublic:\\n    int lev(int n){\\n        return log2(n<<1);\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(auto v:q){\\n            if(v[0]>v[1])\\n                swap(v[0],v[1]);\\n            int cnt=1;\\n            while(lev(v[1])>lev(v[0])){\\n                cnt++;\\n                v[1]>>=1;\\n            }\\n        \\n            while(v[0]!=v[1]){\\n                cnt+=2;\\n                v[0]>>=1;\\n                v[1]>>=1;\\n            }\\n            \\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int lev(int n){\\n        return log2(n<<1);\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(auto v:q){\\n            if(v[0]>v[1])\\n                swap(v[0],v[1]);\\n            int cnt=1;\\n            while(lev(v[1])>lev(v[0])){\\n                cnt++;\\n                v[1]>>=1;\\n            }\\n        \\n            while(v[0]!=v[1]){\\n                cnt+=2;\\n                v[0]>>=1;\\n                v[1]>>=1;\\n            }\\n            \\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934155,
                "title": "python-5-line-solution-longest-common-prefix-in-bitwise",
                "content": "```\\ndef cycleLengthQueries(self, n: int, qs: List[List[int]]) -> List[int]:\\n\\tfor i in range(len(qs)):\\n\\t\\ta, b = min(qs[i]), max(qs[i])\\n\\t\\tk = b.bit_length() - a.bit_length()\\n\\t\\tqs[i] = k + 2*(a^(b>>k)).bit_length()+1\\n\\treturn qs\\n```\\n\\nThe most point here is the two values\\' LCA is the longest common prefix **(LCP)** in binary form.\\n* \\tfor (5-[101], 3-[11]), the LCP is 1. The LCA of 3 and 5 is 1\\n* for (13-[1101], 7-[111]), the LCP is 11. The LCA of 7 and 13 is 3\\n\\n```\\n                                [1]-1\\n            .---------------------^-------------------.\\n          [10]-2                                  [11]-3\\n      .-------^---------.                  .---------^----------.\\n    [100]-4           [101]-5           [110]-6              [111]-7\\n  .-----^-----.      .-----^-----.     .-----^-----.      .-----^-----.\\n[1000]-8 [1001]-9 [1010]-10 [1011]-11 [1100]-12 [1101]-13 [1110]-14 [1111]-15\\n```\\n\\nLet us say we have a<=b and the **binary length difference** as k.\\nWe need to make them in **the same length** with `b>>k`.\\nThe binary length of **a XOR b** is the distance **from a to LCA**.\\nThe distance **from b to LCA** is the previous result **plus k**.\\nThe final results of each query is `k + 2*(a^(b>>k)).bit_length()+1`\\n\\n##### Bonus:\\nIf we need to get **LCA value**, we can calculate as following:\\n```\\nx = (a^(b>>k)).bit_length()\\nLCA = a>>x  or  b>>(x+k)\\n```\\n\\n===============================\\nThe following solution applies LCP solution with binary value as a **string**.\\n```\\ndef cycleLengthQueries(self, n: int, qs: List[List[int]]) -> List[int]:\\n\\tfor i in range(len(qs)):\\n\\t\\ta, b, k = bin(min(qs[i]))[2:], bin(max(qs[i]))[2:], 0\\n\\t\\twhile(k<len(a) and a[k]==b[k]):\\n\\t\\t\\tk += 1\\n\\t\\tqs[i] = len(a)+len(b)-k*2+1\\n\\treturn qs\\n```",
                "solutionTags": [],
                "code": "```\\ndef cycleLengthQueries(self, n: int, qs: List[List[int]]) -> List[int]:\\n\\tfor i in range(len(qs)):\\n\\t\\ta, b = min(qs[i]), max(qs[i])\\n\\t\\tk = b.bit_length() - a.bit_length()\\n\\t\\tqs[i] = k + 2*(a^(b>>k)).bit_length()+1\\n\\treturn qs\\n```\n```\\n                                [1]-1\\n            .---------------------^-------------------.\\n          [10]-2                                  [11]-3\\n      .-------^---------.                  .---------^----------.\\n    [100]-4           [101]-5           [110]-6              [111]-7\\n  .-----^-----.      .-----^-----.     .-----^-----.      .-----^-----.\\n[1000]-8 [1001]-9 [1010]-10 [1011]-11 [1100]-12 [1101]-13 [1110]-14 [1111]-15\\n```\n```\\nx = (a^(b>>k)).bit_length()\\nLCA = a>>x  or  b>>(x+k)\\n```\n```\\ndef cycleLengthQueries(self, n: int, qs: List[List[int]]) -> List[int]:\\n\\tfor i in range(len(qs)):\\n\\t\\ta, b, k = bin(min(qs[i]))[2:], bin(max(qs[i]))[2:], 0\\n\\t\\twhile(k<len(a) and a[k]==b[k]):\\n\\t\\t\\tk += 1\\n\\t\\tqs[i] = len(a)+len(b)-k*2+1\\n\\treturn qs\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2932885,
                "title": "easiest-solution-o-n-space-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int help(int i , int j){\\n        int l = 0 , r = 0;\\n        while(i != j){\\n            if(i > j){\\n                i /= 2;\\n                l++;\\n            }else{\\n                j /= 2;\\n                r++;\\n            }\\n        }\\n        return l + r + 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto x : queries){\\n            ans.push_back(help(x[0] , x[1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(int i , int j){\\n        int l = 0 , r = 0;\\n        while(i != j){\\n            if(i > j){\\n                i /= 2;\\n                l++;\\n            }else{\\n                j /= 2;\\n                r++;\\n            }\\n        }\\n        return l + r + 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto x : queries){\\n            ans.push_back(help(x[0] , x[1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932639,
                "title": "lca-in-logn-c",
                "content": "# Complexity\\n- Time complexity: NlogN\\n- Space complexity: O(logN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &v : queries){\\n            int f = v.front(); int s = v.back();\\n            int lev = 1;\\n            unordered_map<int,int> mp1;\\n            mp1[f] = lev;\\n            while(f){\\n                if(f % 2)f -= 1;\\n                f /= 2;\\n                mp1[f] = ++lev;\\n            }\\n            lev = 0;\\n            while(s){\\n                if(mp1.count(s)) {ans.push_back(mp1[s]+lev); break;}\\n                if(s % 2) s--;\\n                s /= 2;\\n                ++lev;\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(auto &v : queries){\\n            int f = v.front(); int s = v.back();\\n            int lev = 1;\\n            unordered_map<int,int> mp1;\\n            mp1[f] = lev;\\n            while(f){\\n                if(f % 2)f -= 1;\\n                f /= 2;\\n                mp1[f] = ++lev;\\n            }\\n            lev = 0;\\n            while(s){\\n                if(mp1.count(s)) {ans.push_back(mp1[s]+lev); break;}\\n                if(s % 2) s--;\\n                s /= 2;\\n                ++lev;\\n            }\\n        }   \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931822,
                "title": "best-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nit is solved using single iteration\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nit basically a simple approach iterate the queries and take x and y value divide greater value until both not equal.\\nAnd also count how many time divide means we are going to up from child node to parent node then the answer is each queries is:\\ncx + cy + 1\\nhere one plus is that edges which is connect to the queries value x and y.\\nthats all\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(queris.size())\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nc\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(int i = 0; i < q.size(); i++){\\n            int x = q[i][0], y =  q[i][1];\\n            int cx = 0, cy = 0;\\n            while(x != y){\\n                if(x < y){\\n                    y /= 2;\\n                    cy++;\\n                }\\n                else{\\n                    x /= 2;\\n                    cx++;\\n                }\\n            }\\n            ans.push_back(cx+cy+1);\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(int i = 0; i < q.size(); i++){\\n            int x = q[i][0], y =  q[i][1];\\n            int cx = 0, cy = 0;\\n            while(x != y){\\n                if(x < y){\\n                    y /= 2;\\n                    cy++;\\n                }\\n                else{\\n                    x /= 2;\\n                    cx++;\\n                }\\n            }\\n            ans.push_back(cx+cy+1);\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930739,
                "title": "simple-lca-using-bitwise-operation-o-q-32",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**we requires 3 things:-**\\n (let queries[i]=[u,v]  )\\n1. depth[u]=x\\n2. depth[v]=y\\n3. depth[ancestor(u,v)]=z\\n\\nso, we get **ans=x+y-2*z +1** ( 1 => for the new edge )\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nas it is complete binary tree\\n\\nDepth can be calculated.(d)\\n **depth of    \"u\" ==>  2^d >u**   here \\'d\\' is depth\\n\\nAnd \\n\\nAncestor \\n\\nwe can see that we can move from current node to it\\'s \\nparent by left shifting the number (like. for u => \\n****parent of u is  =>  u>>1** **\\n\\n)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(q*32)$$ where **q == queries.size()**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n $$O(q)$$   for ans vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// **for finding ancestor**\\n int anc(int u,int v)\\n {\\n     if(u==v)return u;\\n     if(u>v) return anc(u>>1,v);\\n     else return anc(u,v>>1);\\n }\\n// **for depth cal..**\\n int d(int u)\\n { \\n     int i=0;\\n     for(;(1LL<<i)<=u;i++)\\n     {\\n         ;\\n\\n     }\\n     return i;\\n }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int u=q[i][0],v=q[i][1];\\n            ans.push_back(d(u)+d(v)-2*d(anc(u,v))+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nhope you like it :)",
                "solutionTags": [
                    "Bit Manipulation",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// **for finding ancestor**\\n int anc(int u,int v)\\n {\\n     if(u==v)return u;\\n     if(u>v) return anc(u>>1,v);\\n     else return anc(u,v>>1);\\n }\\n// **for depth cal..**\\n int d(int u)\\n { \\n     int i=0;\\n     for(;(1LL<<i)<=u;i++)\\n     {\\n         ;\\n\\n     }\\n     return i;\\n }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) {\\n        vector<int> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int u=q[i][0],v=q[i][1];\\n            ans.push_back(d(u)+d(v)-2*d(anc(u,v))+1);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930175,
                "title": "bit-manipulation-lca-with-o-1-per-query",
                "content": "# Intuition\\nThis is a common LCA problem but given that the `LEFT(x) = x << 1` and `RIGHT(x) = (x << 1) | 1`. Taking in this pattern, we know the LCA of two nodes will be a set of common prefix bits among two integers (every child is simply appending 0 or 1 from its parent).\\n\\n# Approach\\nFinding LCA can be done using bit manipulation in O(1) time. We can create a mask that set 1 to the common bits and 0 to all bits that are different:\\n```\\nunsigned int ls = __builtin_clz(s), le = __builtin_clz(e);\\nunsigned int common = (s << ls) ^ (~(e << le));\\n```\\nFor example, the number 4 (100) and number 10 (1010), we first shift all meaningful bits to be left aligned, and negate one of them (in this case `1010 -> 0101`), then XOR with the original number (`1000 0000... ^ 0101 1111.... = 1101 1111` note that it is left aligned and filled with trialing zeros and ones if negated). Now we can count the leading ones, and that is how many bits that is in common between both numbers by doing `__builtin_clz(~common)`. In this example, the answer is 2, so two leading bits are common between 4 and 10, which indicate there LCA is on level 2.\\n\\nThe cycle length would be the level of `levels of each number - 2 * level of LCA + 1`. In this case will be `level(4) + level(10) - 2 * level(2) + 1 = 3 + 4 - 2 * 2 + 1 = 4`.\\n\\nNote there need some handling of corner cases where one number is the already the LCA and the other is the left decendent. In this case the one number will be zero padded on the lower bits of the other number, making this apporach unrealiable since left shift is also 0 padded. So just need to handle this case separately.\\n\\n# Complexity\\n- Time complexity: `O(1)` per query, `O(N)` total\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int count(unsigned int s, unsigned int e) {\\n        if (e < s)  swap(s, e);\\n        // count leading zeros of both number\\n        unsigned int ls = __builtin_clz(s), le = __builtin_clz(e);\\n        // create a mask that has 1s for the common bits but 0s else where\\n        unsigned int common = (s << ls) ^ (~(e << le));\\n        unsigned int lc = 0;\\n        if (common != 0xffffffff) {\\n            // for common cases where one is not LCA of the other, count the number of common leading bits\\n            lc = 32 - __builtin_clz(~common);\\n        }\\n        // if one of them is LCA, then use LCA directly\\n        lc = max(lc, ls);\\n        return lc + lc - le - ls + 1;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(), 0);\\n        for (int i = 0; i < queries.size(); i++) {\\n            ans[i] = count(queries[i][0], queries[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nunsigned int ls = __builtin_clz(s), le = __builtin_clz(e);\\nunsigned int common = (s << ls) ^ (~(e << le));\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int count(unsigned int s, unsigned int e) {\\n        if (e < s)  swap(s, e);\\n        // count leading zeros of both number\\n        unsigned int ls = __builtin_clz(s), le = __builtin_clz(e);\\n        // create a mask that has 1s for the common bits but 0s else where\\n        unsigned int common = (s << ls) ^ (~(e << le));\\n        unsigned int lc = 0;\\n        if (common != 0xffffffff) {\\n            // for common cases where one is not LCA of the other, count the number of common leading bits\\n            lc = 32 - __builtin_clz(~common);\\n        }\\n        // if one of them is LCA, then use LCA directly\\n        lc = max(lc, ls);\\n        return lc + lc - le - ls + 1;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans(queries.size(), 0);\\n        for (int i = 0; i < queries.size(); i++) {\\n            ans[i] = count(queries[i][0], queries[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929935,
                "title": "golang-128-ms-13-7-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(m)$$\\n# Code\\n```\\nfunc cycleLengthQueries(n int, queries [][]int) []int {\\n\\tresult := make([]int, len(queries))\\n\\tfor i, query := range queries {\\n\\t\\tresult[i] = 1\\n\\t\\tfor query[0] != query[1] {\\n\\t\\t\\tif query[0] > query[1] {\\n\\t\\t\\t\\tquery[0] >>= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tquery[1] >>= 1\\n\\t\\t\\t}\\n\\t\\t\\tresult[i]++\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc cycleLengthQueries(n int, queries [][]int) []int {\\n\\tresult := make([]int, len(queries))\\n\\tfor i, query := range queries {\\n\\t\\tresult[i] = 1\\n\\t\\tfor query[0] != query[1] {\\n\\t\\t\\tif query[0] > query[1] {\\n\\t\\t\\t\\tquery[0] >>= 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tquery[1] >>= 1\\n\\t\\t\\t}\\n\\t\\t\\tresult[i]++\\n\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2929728,
                "title": "java-contest-time",
                "content": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int m = queries.length;\\n        int[] res = new int[m];\\n        \\n        for(int i = 0 ; i < m ; i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            \\n            int d1 = depth(left);\\n            int d2 = depth(right);\\n            \\n            int root = root(left, right);\\n            \\n            int d = depth(root);\\n            \\n            res[i] = d1 + d2 - 2 * d + 1;\\n                \\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int depth(int n){\\n        int count = 0 ;\\n        while(n > 0){\\n            n = n/2;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public int root(int u, int v){\\n        if(u > v){\\n            return root(v, u);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        \\n        while(u > 0){\\n            set.add(u);\\n            u = u/2;\\n        }\\n        while(!set.contains(v)){\\n            v = v/2;\\n        }\\n        return v;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int m = queries.length;\\n        int[] res = new int[m];\\n        \\n        for(int i = 0 ; i < m ; i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            \\n            int d1 = depth(left);\\n            int d2 = depth(right);\\n            \\n            int root = root(left, right);\\n            \\n            int d = depth(root);\\n            \\n            res[i] = d1 + d2 - 2 * d + 1;\\n                \\n        }\\n        \\n        return res;\\n    }\\n    \\n    public int depth(int n){\\n        int count = 0 ;\\n        while(n > 0){\\n            n = n/2;\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public int root(int u, int v){\\n        if(u > v){\\n            return root(v, u);\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        \\n        while(u > 0){\\n            set.add(u);\\n            u = u/2;\\n        }\\n        while(!set.contains(v)){\\n            v = v/2;\\n        }\\n        return v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929539,
                "title": "video-walkthrough-python-lca",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/g8medj6FhLw)\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ret = []\\n        for a,b in queries:\\n            length, pathOfA = 0, {}\\n            while a != 0: pathOfA[a],length, a = length, length + 1, a // 2\\n            length = 0\\n            while b not in pathOfA: b,length = b // 2, length + 1\\n            ret.append(length + pathOfA[b] + 1)\\n        return ret            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ret = []\\n        for a,b in queries:\\n            length, pathOfA = 0, {}\\n            while a != 0: pathOfA[a],length, a = length, length + 1, a // 2\\n            length = 0\\n            while b not in pathOfA: b,length = b // 2, length + 1\\n            ret.append(length + pathOfA[b] + 1)\\n        return ret            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929458,
                "title": "easy-explained-lca",
                "content": "# Intution\\n- We need to find the LCA of both nodes as the cycle formed will pass through the LCA.\\n- We cannot do the simple way of storing each node parent in a vector/array as number of nodes 2^30 exceeds the limit.\\n\\n\\n# Approach\\n1. First we will find level of both nodes .\\n2. Level of a node is log2(node_value) i.e. for node with value (4,5,6,7) level is 2 for node with value (2,3) is 1 and so on.\\n3. Now we will first make the level of both nodes same if not.\\n4. After making the level same if nodes becomes same then ans is level_diff+1.\\n5. Else we will iterate in while loop until they become same.\\n\\n# Example:\\n- We need to find cycle length after adding edge bw 5 and 12\\n- Level of 5 =log2(5)=2 \\n- Level of 12=log2(12)=3;\\n- Level not same so we will first make level same .Diff in level=1;\\n- So now for node with val 12 .It is even so it\\'s parent node val=12>>1=6.\\n- Now level are same and node value are 5 and 6.\\n- So we will iterate in while loop until their values get same i.e. we find their LCA.\\n-   node A = 5 node b =6\\n- node A=2 node B=3;\\n- node A=1 node B=1  \\n- break;\\n- cycle length =intial diff+2+2+1=6\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries)\\n    {\\n        vector<int>ans;\\n        for(auto it:queries)\\n        {\\n                int a=it[0];\\n                int b=it[1];\\n                int mn_a=log2(a); // level of node a \\n                int mn_b=log2(b); // level of node b\\n\\n               if(mn_a>mn_b)    // if level of a is greater than b\\n               {                // swap a and b along with their level values\\n                      swap(a,b); \\n                       swap(mn_a,mn_b);\\n               }\\n                int diff=mn_b-mn_a;\\n                 for(int i=1;i<=diff;i++)  // loop to make level same\\n                 {\\n                         if(b&1)        \\n                         {\\n                             b=(b-1)>>1;  \\n                         }\\n                         else\\n                         {\\n                                 b=b>>1;\\n                         }\\n                 }\\n                if(a==b)\\n                {\\n                        ans.push_back(diff+1);\\n                }\\n                else\\n                {\\n                        while(a!=b)\\n                        {\\n                                diff+=2;\\n                                if(a&1)\\n                                {\\n                                        a=(a-1)>>1;\\n                                }\\n                                else\\n                                {\\n                                        a=a>>1;\\n                                }\\n                                if(b&1)\\n                                {\\n                                        b=(b-1)>>1;\\n                                }\\n                                else\\n                                        b=b>>1;\\n                        }\\n                        diff++;  // for common node \\n                        ans.push_back(diff);\\n                }\\n                \\n        }\\n            return ans;\\n              \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries)\\n    {\\n        vector<int>ans;\\n        for(auto it:queries)\\n        {\\n                int a=it[0];\\n                int b=it[1];\\n                int mn_a=log2(a); // level of node a \\n                int mn_b=log2(b); // level of node b\\n\\n               if(mn_a>mn_b)    // if level of a is greater than b\\n               {                // swap a and b along with their level values\\n                      swap(a,b); \\n                       swap(mn_a,mn_b);\\n               }\\n                int diff=mn_b-mn_a;\\n                 for(int i=1;i<=diff;i++)  // loop to make level same\\n                 {\\n                         if(b&1)        \\n                         {\\n                             b=(b-1)>>1;  \\n                         }\\n                         else\\n                         {\\n                                 b=b>>1;\\n                         }\\n                 }\\n                if(a==b)\\n                {\\n                        ans.push_back(diff+1);\\n                }\\n                else\\n                {\\n                        while(a!=b)\\n                        {\\n                                diff+=2;\\n                                if(a&1)\\n                                {\\n                                        a=(a-1)>>1;\\n                                }\\n                                else\\n                                {\\n                                        a=a>>1;\\n                                }\\n                                if(b&1)\\n                                {\\n                                        b=(b-1)>>1;\\n                                }\\n                                else\\n                                        b=b>>1;\\n                        }\\n                        diff++;  // for common node \\n                        ans.push_back(diff);\\n                }\\n                \\n        }\\n            return ans;\\n              \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929361,
                "title": "c-beginner-friendly-solution-math",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>res;\\n        for(auto x:queries){\\n            int a=x[0],b=x[1],a_level=0,b_level=0;\\n            while(a!=b){\\n                if(a > b){\\n                   a/=2;\\n                   a_level++;\\n                }\\n                else{\\n                    b/=2;\\n                    b_level++;\\n                }     \\n            }\\n            res.push_back(a_level+b_level+1);\\n        }\\n     return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        \\n        vector<int>res;\\n        for(auto x:queries){\\n            int a=x[0],b=x[1],a_level=0,b_level=0;\\n            while(a!=b){\\n                if(a > b){\\n                   a/=2;\\n                   a_level++;\\n                }\\n                else{\\n                    b/=2;\\n                    b_level++;\\n                }     \\n            }\\n            res.push_back(a_level+b_level+1);\\n        }\\n     return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929220,
                "title": "easiest-way-to-solve-c-mathematical",
                "content": "Just find Lowest Common Ansestor and compute answer accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int lowestCommonAnsestor(int a,int b){\\n        if(a == b) return a;\\n        if(a > b) return lowestCommonAnsestor(b,a);\\n        return lowestCommonAnsestor(a,b/2);\\n    }\\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(auto p: queries){\\n            int x = p[0];\\n            int y = p[1];\\n            int z = lowestCommonAnsestor(x,y);\\n            int ans = int(log2(x)) + int(log2(y)) - 2*int(log2(z)) + 1;\\n            \\n            // cout << \"First Number \" << x << \" : log2(x) -> \" << int(log2(x)) << endl;\\n            // cout << \"Second Number \" << y << \" : log2(y) -> \" << int(log2(y)) << endl;\\n            // cout << \"LCA Number \" << z << \" : log2(z) -> \" << int(log2(z)) << endl;\\n            // cout << \"Ans :-> \" << ans << endl << endl;\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int lowestCommonAnsestor(int a,int b){\\n        if(a == b) return a;\\n        if(a > b) return lowestCommonAnsestor(b,a);\\n        return lowestCommonAnsestor(a,b/2);\\n    }\\n    \\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> res;\\n        for(auto p: queries){\\n            int x = p[0];\\n            int y = p[1];\\n            int z = lowestCommonAnsestor(x,y);\\n            int ans = int(log2(x)) + int(log2(y)) - 2*int(log2(z)) + 1;\\n            \\n            // cout << \"First Number \" << x << \" : log2(x) -> \" << int(log2(x)) << endl;\\n            // cout << \"Second Number \" << y << \" : log2(y) -> \" << int(log2(y)) << endl;\\n            // cout << \"LCA Number \" << z << \" : log2(z) -> \" << int(log2(z)) << endl;\\n            // cout << \"Ans :-> \" << ans << endl << endl;\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2929213,
                "title": "100-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto v:queries){\\n            int l=1;\\n            if(v[0]!=v[1])\\n            {\\n                int a=v[0];\\n                int b=v[1];\\n                while(a!=b){\\n                       if(a>b)a/=2;\\n                       else b/=2;\\n                       l++;\\n                }\\n                ans.push_back(l);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto v:queries){\\n            int l=1;\\n            if(v[0]!=v[1])\\n            {\\n                int a=v[0];\\n                int b=v[1];\\n                while(a!=b){\\n                       if(a>b)a/=2;\\n                       else b/=2;\\n                       l++;\\n                }\\n                ans.push_back(l);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929146,
                "title": "simple-and-steady-solution-best-solution-beats-100-time-complexity-and-100-space-complexity",
                "content": "\\n![WhatsApp Image 2022-12-19 at 22.06.46.jpg](https://assets.leetcode.com/users/images/e675fef8-c42b-45a4-bc23-9b6d28cf4cea_1671467853.2070603.jpeg)\\n# Intuition\\nUsing the concept of maths we find the common value of two connecting nodes\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the concept of loop and maths\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n      vector<int> ans;\\n        int i=0;\\n        int a,b,count;\\n        while(i<queries.size()){\\n            a=queries[i][0],b=queries[i][1];\\n             count=0;\\n               while(a!=b){\\n                 if(a>b){\\n                     a=a/2;\\n                 }\\n                 else{\\n                     b=b/2;\\n                 }\\n             count++;\\n               }\\n                  ans.push_back(count+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n      vector<int> ans;\\n        int i=0;\\n        int a,b,count;\\n        while(i<queries.size()){\\n            a=queries[i][0],b=queries[i][1];\\n             count=0;\\n               while(a!=b){\\n                 if(a>b){\\n                     a=a/2;\\n                 }\\n                 else{\\n                     b=b/2;\\n                 }\\n             count++;\\n               }\\n                  ans.push_back(count+1);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928973,
                "title": "using-lowest-common-ancestor-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int len(int a){\\n        return Integer.toBinaryString(a).length();\\n    } \\n    \\n    int solve(int a, int b){\\n        \\n       int cnt = 0;\\n       while(len(a) < len(b)){\\n           b = b/2;\\n           cnt++;\\n       }\\n        \\n       while(len(a) > len(b)){\\n           a = a/2;\\n           cnt++;\\n       } \\n        \\n        int cnt1 = 0;\\n        while(a != b){\\n            a = a/2;\\n            b = b/2;\\n            cnt1++;\\n        }\\n        \\n        return cnt + cnt1*2;\\n    }\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        \\n        int[] ans = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++){\\n            int val = solve(queries[i][0], queries[i][1]);\\n            ans[i] = val + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int len(int a){\\n        return Integer.toBinaryString(a).length();\\n    } \\n    \\n    int solve(int a, int b){\\n        \\n       int cnt = 0;\\n       while(len(a) < len(b)){\\n           b = b/2;\\n           cnt++;\\n       }\\n        \\n       while(len(a) > len(b)){\\n           a = a/2;\\n           cnt++;\\n       } \\n        \\n        int cnt1 = 0;\\n        while(a != b){\\n            a = a/2;\\n            b = b/2;\\n            cnt1++;\\n        }\\n        \\n        return cnt + cnt1*2;\\n    }\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        \\n        int[] ans = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++){\\n            int val = solve(queries[i][0], queries[i][1]);\\n            ans[i] = val + 1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927930,
                "title": "python3-o-mn-lowest-common-ancestor",
                "content": "# Intuition\\nThe problem is to find the Lowest Common Ancestor of every query.\\nThe parent of node v is v // 2.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\n- Space complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for u, v in queries:\\n            if u == v:\\n                ans.append(1)\\n                continue\\n            ancestors = {u : 0}\\n            while u > 0:\\n                u //= 2\\n                ancestors[u] = len(ancestors)\\n            step = 0\\n            while v > 0:\\n                if v in ancestors:\\n                    ans.append(1 + step + ancestors[v])\\n                    break\\n                v //= 2\\n                step += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cycleLengthQueries(self, n: int, queries: List[List[int]]) -> List[int]:\\n        ans = []\\n        for u, v in queries:\\n            if u == v:\\n                ans.append(1)\\n                continue\\n            ancestors = {u : 0}\\n            while u > 0:\\n                u //= 2\\n                ancestors[u] = len(ancestors)\\n            step = 0\\n            while v > 0:\\n                if v in ancestors:\\n                    ans.append(1 + step + ancestors[v])\\n                    break\\n                v //= 2\\n                step += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927492,
                "title": "finding-lca-in-min-heap-java-code-with-explanation",
                "content": "# Intuition\\nTo find lowest common ancestor in a min heap.\\n\\n# Approach\\n1. Find all ancestors for both nodes in each query. \\n2. Store them in two seperate lists such them each list stores ancestors in non-increasing order.\\n3. Find the Lowest Common Ancestor for both nodes. Add their indexes + 1 and return the result.\\n\\n# Complexity\\n- Time complexity:\\n1. 2 * [O(N * Log(N))] => Finding all ancestors for both nodes. This can result in worst case log(n) time if a node\\'s value is n, however since max value of n can be just 30 as per the criteria in question. Thus, 2 * [O(30 * Log(30))] ~ constant time => c\\n2. Finding the lowest common ancestot for both nodes. Since each list has a max size of Log(N), thus it will be 2 * Log(N) ~ constant time => c\\n3. Repeat 1. and 2. for all queries in question which can be M, thus this will be O(M) * 1 * 2.\\n\\nTotal TC -  [2 * O(N * Log(N)) + 2 * Log(N)] * O(M) ~ O(M) * C => O(M)\\n\\n- Space complexity:\\nO(LogN) => Extra space is just needed to store all ancestors for both nodes. Since I am using an extra hashmap to find the LCA, we have to add the S.C of that extra map too, which will again be just O(Log(N)) which is the max size of each list containing ancestors. We will be doing the same for every query. Thus net SC => O(M) * O(Log(N)) => O(M)* C ==> O(M)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int res[] = new int[queries.length];\\n        int i = 0;\\n        for(int query[] : queries){\\n            int a = query[0];\\n            int b = query[1];\\n            int[] m1 = findAncestors(a);\\n            int[] m2 = findAncestors(b);\\n            // print(m1);\\n            // print(m2);\\n            res[i++] = findLowestAncestor(m1, m2);\\n        }\\n        return res;\\n    }\\n    \\n    private int findLowestAncestor(int[] a, int[] b){\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < a.length; i++){\\n            map.put(a[i], i);\\n        }\\n        for(int i = 0; i < b.length; i++){\\n            int val = b[i];\\n            if(map.containsKey(val)){\\n                return (map.get(val) + 1 + i);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private void print(int[] arr){\\n        for(int i = 0; i < arr.length; i++){\\n            System.out.print(arr[i] + \", \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    private int[] findAncestors(int num){\\n        List<Integer> res = new ArrayList<Integer>();\\n        res.add(num);\\n        while(num != 1){\\n            int a = findMyAncestor(num);\\n            res.add(a);\\n            num = a;\\n        }\\n        int[] ans = new int[res.size()];\\n        for(int i = 0; i < ans.length; i++){\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n    private int findMyAncestor(int num){\\n        if(num % 2 == 1){\\n            return (num - 1) / 2;\\n        }else{\\n            return (num) / 2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] cycleLengthQueries(int n, int[][] queries) {\\n        int res[] = new int[queries.length];\\n        int i = 0;\\n        for(int query[] : queries){\\n            int a = query[0];\\n            int b = query[1];\\n            int[] m1 = findAncestors(a);\\n            int[] m2 = findAncestors(b);\\n            // print(m1);\\n            // print(m2);\\n            res[i++] = findLowestAncestor(m1, m2);\\n        }\\n        return res;\\n    }\\n    \\n    private int findLowestAncestor(int[] a, int[] b){\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < a.length; i++){\\n            map.put(a[i], i);\\n        }\\n        for(int i = 0; i < b.length; i++){\\n            int val = b[i];\\n            if(map.containsKey(val)){\\n                return (map.get(val) + 1 + i);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private void print(int[] arr){\\n        for(int i = 0; i < arr.length; i++){\\n            System.out.print(arr[i] + \", \");\\n        }\\n        System.out.println();\\n    }\\n    \\n    private int[] findAncestors(int num){\\n        List<Integer> res = new ArrayList<Integer>();\\n        res.add(num);\\n        while(num != 1){\\n            int a = findMyAncestor(num);\\n            res.add(a);\\n            num = a;\\n        }\\n        int[] ans = new int[res.size()];\\n        for(int i = 0; i < ans.length; i++){\\n            ans[i] = res.get(i);\\n        }\\n        return ans;\\n    }\\n    private int findMyAncestor(int num){\\n        if(num % 2 == 1){\\n            return (num - 1) / 2;\\n        }else{\\n            return (num) / 2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927472,
                "title": "lca",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) \\n    {\\n        vector<int>ans;\\n          for(int i=0;i<q.size();i++)\\n          {\\n              vector<int>a,b;\\n              \\n              while(q[i][0])\\n              {\\n                  a.push_back(q[i][0]);\\n                  q[i][0]/=2;\\n              }\\n\\n              while(q[i][1])\\n              {\\n                  b.push_back(q[i][1]);\\n                  q[i][1]/=2;\\n              }\\n\\n                while(!a.empty()&&!b.empty()&&a.back()==b.back())\\n                {\\n                    a.pop_back();\\n                    b.pop_back();\\n                }\\n              int res = (int)(a.size())+(int)(b.size())+1;\\n              ans.push_back(res);\\n\\n          }       \\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& q) \\n    {\\n        vector<int>ans;\\n          for(int i=0;i<q.size();i++)\\n          {\\n              vector<int>a,b;\\n              \\n              while(q[i][0])\\n              {\\n                  a.push_back(q[i][0]);\\n                  q[i][0]/=2;\\n              }\\n\\n              while(q[i][1])\\n              {\\n                  b.push_back(q[i][1]);\\n                  q[i][1]/=2;\\n              }\\n\\n                while(!a.empty()&&!b.empty()&&a.back()==b.back())\\n                {\\n                    a.pop_back();\\n                    b.pop_back();\\n                }\\n              int res = (int)(a.size())+(int)(b.size())+1;\\n              ans.push_back(res);\\n\\n          }       \\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927142,
                "title": "clean-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // find lca and its level\\n    int find_lca(int a, int b) {\\n        int counter = 1;\\n        while (a != b) {\\n            if (a > b) a /= 2;\\n            else b /= 2;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ret(queries.size());\\n        int index = 0;\\n        for (auto it : queries) {\\n            int a = it[0], b = it[1];\\n            ret[index++] = find_lca(a, b);\\n        }\\n        return ret;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // find lca and its level\\n    int find_lca(int a, int b) {\\n        int counter = 1;\\n        while (a != b) {\\n            if (a > b) a /= 2;\\n            else b /= 2;\\n            counter++;\\n        }\\n        return counter;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ret(queries.size());\\n        int index = 0;\\n        for (auto it : queries) {\\n            int a = it[0], b = it[1];\\n            ret[index++] = find_lca(a, b);\\n        }\\n        return ret;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927136,
                "title": "finding-closest-common-ancestor-recursive-implementation",
                "content": "# Intuition\\nThe idea is to reach the common ancestor node of the two nodes in queries[i].  \\n\\n# Approach\\nWe have two nodes : queries[i][0] (= temp1) and queries[i][1] (=temp2). A temporary variable \"temp\" is used to find the number of edges. At every step, the greater of temp1 and temp2 is divided by 2 and temp is incremented. This is carried on till temp1==temp2.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(log(queries[i][0]))+O(log(queries[i][1]))=O(n)+O(n)=O(n).\\n\\n- Space complexity:\\nSince recursive implementation is used, O(n) stack space is required.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            sort(queries[i].begin(),queries[i].end());\\n            int temp1=queries[i][0];\\n            int temp2=queries[i][1];\\n            int temp=0;\\n            while(temp1!=temp2){\\n                // cout<<temp1<<\" \"<<temp2<<endl;\\n                if (temp2>1){\\n                    temp2=temp2/2;\\n                    temp++;\\n                }\\n                if (temp2<temp1){\\n                    int swap=temp1;\\n                    temp1=temp2;\\n                    temp2=swap;\\n                }\\n            }\\n        ans.push_back(temp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease give an upvote if you find the solution and explanation helpful.\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int> ans;\\n        for(int i=0; i<queries.size(); i++){\\n            sort(queries[i].begin(),queries[i].end());\\n            int temp1=queries[i][0];\\n            int temp2=queries[i][1];\\n            int temp=0;\\n            while(temp1!=temp2){\\n                // cout<<temp1<<\" \"<<temp2<<endl;\\n                if (temp2>1){\\n                    temp2=temp2/2;\\n                    temp++;\\n                }\\n                if (temp2<temp1){\\n                    int swap=temp1;\\n                    temp1=temp2;\\n                    temp2=swap;\\n                }\\n            }\\n        ans.push_back(temp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1721060,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1734388,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1720069,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1720065,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1720055,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1719999,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1719972,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1804144,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1721230,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1720707,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1721060,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1734388,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1720069,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1720065,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1720055,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1719999,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1719972,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1804144,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1721230,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            },
            {
                "id": 1720707,
                "content": [
                    {
                        "username": "shivansh961",
                        "content": "It was easier than 2nd and 3rd questions. I didn\\'t even read this in the contest. LeetCode is getting weird day by day."
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be medium."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "If your solution is LOGN but got TLE, it is not your fault. This problem is too new and LC still has a bad baseline for its running time. Likely you are using data structure like `unordered_map` which is O(1) but still much slower than `vector`. As long as your solution is of O(MLOGN) (M is # of queries), then your solution is good, even though it might have TLE"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "I solved it using LCA, what you were using unordered_map, can you share the code?  "
                    },
                    {
                        "username": "rakshitsahu20",
                        "content": "UNORDERD_MAP TLE in c++ but not in other languages\\nLeetcode You should look into this...\\nclass Solution {\\npublic:\\n        Solution()\\n    {\\n        cin.tie(0);\\n        cout.tie(0);\\n        ios_base::sync_with_stdio(0);\\n    }\\n    int solve( vector<int>& x )\\n    {\\n            int mini = min( x[0] , x[1] );\\n            int maxi = max(x[0] , x[1]);\\n            unordered_map<int , int> umap;\\n            int count = 1;\\n        while( mini != 1 )\\n        {\\n            //cout<<mini<<\" \";\\n            umap[mini] = count;\\n            count++;\\n            mini = mini / 2;\\n        }\\n        umap[mini] = count;\\n        count = 1;\\n        //cout<<mini<<endl;\\n        while( maxi != 1 )\\n        {\\n            //cout<<maxi<<\" \";\\n            if( umap[maxi] > 0 )\\n                return umap[maxi] + count - 1;\\n            \\n            umap[maxi] = count;\\n            maxi = maxi / 2;\\n            count++;\\n        }\\n        //cout<<maxi<<endl;\\n        return umap[1] + count  - 1;\\n    }\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        int m = queries.size();\\n        vector<int> ans(m , 0);\\n        //cout<<solve( {2,3} )<<endl;\\n        \\n        for( int i =  0; i < m ;i++ )\\n        {\\n            vector<int> x = queries[i];\\n            ans[i] = solve(queries[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "GuMingDiaoYu",
                        "content": "There seems to be something wrong with the Java complier. The following is my code and I can run it successfully on my local machine. However, I always get java.util.EmptyStackException error. The test case is n = 14, queries = [[8303,8267]]. By the way, I can get accepted when switching to C++.\n\n```\nclass Solution {\n    public int[] cycleLengthQueries(int n, int[][] queries) {\n        if(n < 2) {\n            return new int[n];\n        }\n        \n        int[] ans = new int[queries.length];\n        \n        for(int i = 0; i < queries.length; i++) {\n            Stack<Integer> st1 = help(queries[i][0]);\n            Stack<Integer> st2 = help(queries[i][1]);\n        \n            while(! st1.isEmpty() && ! st2.isEmpty() \n                    && st1.peek() == st2.peek()) {\n                st1.pop();\n                st2.pop();\n            }\n            \n            // System.out.println(st1 + \" \" + st2 + \" \" + st1.size() + \" \" + st2.size());\n            // System.out.println(st1.peek() + \" \" + st2.peek());  java.util.EmptyStackException\n   // at line 101, java.base/java.util.Stack.peek\n  // at line 20, Solution.cycleLengthQueries\n  // at line 54, __DriverSolution__.__helper__\n  // at line 87, __Driver__.main\n            \n            ans[i] = st1.size() + st2.size() + 1;\n        }\n        \n        return ans;\n    }\n    \n    private Stack<Integer> help(int n){\n        Stack<Integer> st = new Stack<>();\n\n        while(n > 0) {\n            st.push(n);\n            n = n / 2;\n        }\n\n        return st;\n    }    \n}\n```"
                    },
                    {
                        "username": "rishabhsingh2305",
                        "content": "## I dont understand why map is giving TLE\\n    int nearPar(int a,int b){\\n        if(a>b)swap(a,b);\\n        unordered_map<int,bool>m;\\n        while(a){\\n            m[a]=true;\\n            a=a>>1;\\n        }\\n        while(b>1&&!m[b]){\\n            b=b>>1;\\n        }\\n        return b;\\n    }\\n\\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\\n        vector<int>ans;\\n        for(auto &i:queries){\\n            int par=nearPar(i[0],i[1]);\\n            int a=log2(i[0])+1;\\n            int b=log2(i[1])+1;\\n            par=log2(par)+1;\\n            \\n            \\n            int res=a+b-par-par+1;\\n            ans.push_back(res);\\n        }\\n        \\n        return ans;\\n    }\\n\\n"
                    },
                    {
                        "username": "ishank01",
                        "content": "When I submitted the below code in the contest it gave me TLE but just after the contest is finished. I submitted the same code it got Accepted. WHY?\n\n```\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        int m = queries.size();\n        vector<int> res;\n        \n        for(int i = 0; i < m; i++){\n            int a = min(queries[i][0], queries[i][1]);\n            int b = max(queries[i][0], queries[i][1]);\n            \n            vector<int> nodes1, nodes2;\n            while(b){ // 30\n                nodes1.push_back(b);\n                b = b / 2;\n            }\n            while(a){ // 30\n                nodes2.push_back(a);\n                a = a / 2;\n            }\n            int p = nodes1.size(), q = nodes2.size();\n            reverse(nodes1.begin(), nodes1.end());\n            reverse(nodes2.begin(), nodes2.end());\n            int l = 0, j = 0;\n            while(l < p && j < q){\n                if(nodes1[l] == nodes2[j]){\n                    l++;\n                    j++;\n                }\n                else{\n                    break;\n                }\n            }\n            res.push_back(p - l + q - j + 1);\n        }\n        \n        return res;\n    }\n};```"
                    },
                    {
                        "username": "hrthk_x",
                        "content": "Find lowest common ancesstor and count edge while finding lca and store edge + 1 as answer."
                    },
                    {
                        "username": "zhouhaibing089",
                        "content": "If I understand this correctly, parameter `n` is not necessarily required, is it true?"
                    },
                    {
                        "username": "suhaanbhandary1",
                        "content": "Yes, it\\'s not required"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "To solve it in efficient way search about meet in middle algorithm"
                    }
                ]
            }
        ]
    }
]