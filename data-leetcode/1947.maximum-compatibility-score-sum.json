[
    {
        "title": "Cheapest Flights Within K Stops",
        "question_content": "There are n cities connected by some number of flights. You are given an array flights where flights[i] = [fromi, toi, pricei] indicates that there is a flight from city fromi to city toi with cost pricei.\nYou are also given three integers src, dst, and k, return the cheapest price from src to dst with at most k stops. If there is no such route, return -1.\n&nbsp;\nExample 1:\n\nInput: n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1\nOutput: 700\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 3 is marked in red and has cost 100 + 600 = 700.\nNote that the path through cities [0,1,2,3] is cheaper but is invalid because it uses 2 stops.\n\nExample 2:\n\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1\nOutput: 200\nExplanation:\nThe graph is shown above.\nThe optimal path with at most 1 stop from city 0 to 2 is marked in red and has cost 100 + 100 = 200.\n\nExample 3:\n\nInput: n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0\nOutput: 500\nExplanation:\nThe graph is shown above.\nThe optimal path with no stops from city 0 to 2 is marked in red and has cost 500.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 100\n\t0 <= flights.length <= (n * (n - 1) / 2)\n\tflights[i].length == 3\n\t0 <= fromi, toi < n\n\tfromi != toi\n\t1 <= pricei <= 104\n\tThere will not be any multiple flights between two cities.\n\t0 <= src, dst, k < n\n\tsrc != dst",
        "solutions": [
            {
                "id": 115541,
                "title": "java-c-python-priority-queue-solution-tle-now",
                "content": "**Idea**\\nIt happen to be the same idea of Dijkstra\\'s algorithm, but we need to keep the path.\\n\\n**More**\\nMore helpful and detailed explanation here:\\nhttps://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\\n\\nPython\\n```py\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        f = collections.defaultdict(dict)\\n        for a, b, p in flights:\\n            f[a][b] = p\\n        heap = [(0, src, k + 1)]\\n        while heap:\\n            p, i, k = heapq.heappop(heap)\\n            if i == dst:\\n                return p\\n            if k > 0:\\n                for j in f[i]:\\n                    heapq.heappush(heap, (p + f[i][j], j, k - 1))\\n        return -1\\n```\\n\\n**Thanks @sur081547 for Java version**\\n```java\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, Map<Integer, Integer>> prices = new HashMap<>();\\n        for (int[] f : flights) {\\n            if (!prices.containsKey(f[0])) prices.put(f[0], new HashMap<>());\\n            prices.get(f[0]).put(f[1], f[2]);\\n        }\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> (Integer.compare(a[0], b[0])));\\n        pq.add(new int[] {0, src, k + 1});\\n        while (!pq.isEmpty()) {\\n            int[] top = pq.remove();\\n            int price = top[0];\\n            int city = top[1];\\n            int stops = top[2];\\n            if (city == dst) return price;\\n            if (stops > 0) {\\n                Map<Integer, Integer> adj = prices.getOrDefault(city, new HashMap<>());\\n                for (int a : adj.keySet()) {\\n                    pq.add(new int[] {price + adj.get(a), a, stops - 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n**C++ verison from @tensor-flower**\\n```cpp\\ntypedef tuple<int,int,int> ti;\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int,int>>>vp(n);\\n        for(const auto&f:flights)   vp[f[0]].emplace_back(f[1],f[2]);\\n        priority_queue<ti,vector<ti>,greater<ti>>pq;\\n        pq.emplace(0,src,K+1);\\n        while(!pq.empty()){\\n            auto [cost,u,stops] = pq.top();\\n            pq.pop();\\n            if(u==dst)  return cost;\\n            if(!stops)  continue;\\n            for(auto to:vp[u]){\\n                auto [v,w] = to;\\n                pq.emplace(cost+w,v,stops-1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        f = collections.defaultdict(dict)\\n        for a, b, p in flights:\\n            f[a][b] = p\\n        heap = [(0, src, k + 1)]\\n        while heap:\\n            p, i, k = heapq.heappop(heap)\\n            if i == dst:\\n                return p\\n            if k > 0:\\n                for j in f[i]:\\n                    heapq.heappush(heap, (p + f[i][j], j, k - 1))\\n        return -1\\n```\n```java\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, Map<Integer, Integer>> prices = new HashMap<>();\\n        for (int[] f : flights) {\\n            if (!prices.containsKey(f[0])) prices.put(f[0], new HashMap<>());\\n            prices.get(f[0]).put(f[1], f[2]);\\n        }\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> (Integer.compare(a[0], b[0])));\\n        pq.add(new int[] {0, src, k + 1});\\n        while (!pq.isEmpty()) {\\n            int[] top = pq.remove();\\n            int price = top[0];\\n            int city = top[1];\\n            int stops = top[2];\\n            if (city == dst) return price;\\n            if (stops > 0) {\\n                Map<Integer, Integer> adj = prices.getOrDefault(city, new HashMap<>());\\n                for (int a : adj.keySet()) {\\n                    pq.add(new int[] {price + adj.get(a), a, stops - 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```cpp\\ntypedef tuple<int,int,int> ti;\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int,int>>>vp(n);\\n        for(const auto&f:flights)   vp[f[0]].emplace_back(f[1],f[2]);\\n        priority_queue<ti,vector<ti>,greater<ti>>pq;\\n        pq.emplace(0,src,K+1);\\n        while(!pq.empty()){\\n            auto [cost,u,stops] = pq.top();\\n            pq.pop();\\n            if(u==dst)  return cost;\\n            if(!stops)  continue;\\n            for(auto to:vp[u]){\\n                auto [v,w] = to;\\n                pq.emplace(cost+w,v,stops-1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361711,
                "title": "java-dfs-bfs-bellman-ford-dijkstra-s",
                "content": "Here\\'s a compilation of 4 graph algorithms.\\n1. DFS\\nPretty straightforward implementation. keep a global answer and traverse all the children of the source upto k stops. If at any point we reach the destination,store the min of the naswer and the current cost.\\n\\nCode:\\n```\\n    int ans_dfs;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        ans_dfs=Integer.MAX_VALUE;\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] i:flights)\\n        {\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(new int[]{i[1],i[2]});\\n        }\\n        dfs(map,src,dst,K+1,0);\\n        return ans_dfs==Integer.MAX_VALUE?-1:ans_dfs;\\n    }\\n    public void dfs(Map<Integer,List<int[]>> map, int src, int dst, int k, int cost)\\n    {\\n        if(k<0)\\n            return;\\n        if(src==dst)\\n        {\\n            ans_dfs=cost;\\n            return;\\n        }\\n        if(!map.containsKey(src))\\n            return;\\n        for(int[] i:map.get(src))\\n        {\\n            if(cost+i[1]>ans_dfs)               //Pruning, check the sum of current price and next cost. If it\\'s greater then the ans so far, continue\\n                continue;\\n            dfs(map,i[0],dst,k-1,cost+i[1]);\\n        }\\n    }\\n```\\n\\nA few caveats, pruning the path based on the cost of next children will improve performance, remove the need of a visited set and solve the annoying TLE issue.\\n\\n2. BFS\\n\\tUnlike BFS, now we simultaneously traverse all the possible path going out from source for upto k steps. If the ans is found in between, we store the min of the current ans with the newly found one. A modification to the standard bfs design, we pass the starting cost a 0 to the queue as well and go on adding to it.\\nCode :\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] i:flights)\\n        {\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(new int[]{i[1],i[2]});\\n        }\\n        int step=0;\\n        Queue<int[]> q=new LinkedList<>();\\n        q.offer(new int[]{src,0});\\n        int ans=Integer.MAX_VALUE;\\n        while(!q.isEmpty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int[] curr=q.poll();\\n                if(curr[0]==dst)\\n                    ans=Math.min(ans,curr[1]);\\n                if(!map.containsKey(curr[0]))\\n                    continue;\\n                for(int[] f:map.get(curr[0]))\\n                {\\n                    if(curr[1]+f[1]>ans)      //Pruning\\n                        continue;\\n                    q.offer(new int[]{f[0],curr[1]+f[1]});\\n                }\\n            }\\n            if(step++>K)\\n                break;\\n        }\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n```\\n\\nSimilar to DFS, I used pruning to avoid TLE and remove the need of a visited set.\\n\\n3.Bellman Ford\\n\\tMuch like BFS, run the algorithm K times, if the answer exists, it should be stored in the helper matrix\\n\\nCode\\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        int[] cost=new int[n];\\n        Arrays.fill(cost,Integer.MAX_VALUE);\\n        cost[src]=0;\\n        for(int i=0;i<=K;i++)\\n        {\\n            int[] temp= Arrays.copyOf(cost,n);\\n            for(int[] f: flights)\\n            {\\n                int curr=f[0],next=f[1],price=f[2];\\n                if(cost[curr]==Integer.MAX_VALUE)\\n                    continue;\\n                temp[next]=Math.min(temp[next],cost[curr]+price);\\n            }\\n            cost=temp;\\n        }\\n        return cost[dst]==Integer.MAX_VALUE?-1:cost[dst];\\n    }\\n```\\n\\n4.Dijkstra\\'s\\nMuch like BFS, but use a PriorityQueue based on the cheapest cost. Incorporate the stop limit to individual paths to traverse upto k stops.\\ncredit to @lee215 for the solution\\n\\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) \\n    {\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] f:flights)\\n        {\\n            map.putIfAbsent(f[0],new ArrayList<>());\\n            map.get(f[0]).add(new int[]{f[1],f[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0],o2[0]);\\n            }\\n        });\\n        q.offer(new int[]{0,src,K+1});\\n        while(!q.isEmpty())\\n        {\\n            int[] c=q.poll();\\n            int cost=c[0];\\n            int curr=c[1];\\n            int stop=c[2];\\n            if(curr==dst)\\n                return cost;\\n            if(stop>0)\\n            {\\n                if(!map.containsKey(curr))\\n                    continue;\\n                for(int[] next:map.get(curr))\\n                {\\n                    q.add(new int[]{cost+next[1],next[0],stop-1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\t\\n\\n\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\n    int ans_dfs;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        ans_dfs=Integer.MAX_VALUE;\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] i:flights)\\n        {\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(new int[]{i[1],i[2]});\\n        }\\n        dfs(map,src,dst,K+1,0);\\n        return ans_dfs==Integer.MAX_VALUE?-1:ans_dfs;\\n    }\\n    public void dfs(Map<Integer,List<int[]>> map, int src, int dst, int k, int cost)\\n    {\\n        if(k<0)\\n            return;\\n        if(src==dst)\\n        {\\n            ans_dfs=cost;\\n            return;\\n        }\\n        if(!map.containsKey(src))\\n            return;\\n        for(int[] i:map.get(src))\\n        {\\n            if(cost+i[1]>ans_dfs)               //Pruning, check the sum of current price and next cost. If it\\'s greater then the ans so far, continue\\n                continue;\\n            dfs(map,i[0],dst,k-1,cost+i[1]);\\n        }\\n    }\\n```\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] i:flights)\\n        {\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(new int[]{i[1],i[2]});\\n        }\\n        int step=0;\\n        Queue<int[]> q=new LinkedList<>();\\n        q.offer(new int[]{src,0});\\n        int ans=Integer.MAX_VALUE;\\n        while(!q.isEmpty())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                int[] curr=q.poll();\\n                if(curr[0]==dst)\\n                    ans=Math.min(ans,curr[1]);\\n                if(!map.containsKey(curr[0]))\\n                    continue;\\n                for(int[] f:map.get(curr[0]))\\n                {\\n                    if(curr[1]+f[1]>ans)      //Pruning\\n                        continue;\\n                    q.offer(new int[]{f[0],curr[1]+f[1]});\\n                }\\n            }\\n            if(step++>K)\\n                break;\\n        }\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n```\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K)\\n    {\\n        int[] cost=new int[n];\\n        Arrays.fill(cost,Integer.MAX_VALUE);\\n        cost[src]=0;\\n        for(int i=0;i<=K;i++)\\n        {\\n            int[] temp= Arrays.copyOf(cost,n);\\n            for(int[] f: flights)\\n            {\\n                int curr=f[0],next=f[1],price=f[2];\\n                if(cost[curr]==Integer.MAX_VALUE)\\n                    continue;\\n                temp[next]=Math.min(temp[next],cost[curr]+price);\\n            }\\n            cost=temp;\\n        }\\n        return cost[dst]==Integer.MAX_VALUE?-1:cost[dst];\\n    }\\n```\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) \\n    {\\n        Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] f:flights)\\n        {\\n            map.putIfAbsent(f[0],new ArrayList<>());\\n            map.get(f[0]).add(new int[]{f[1],f[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0],o2[0]);\\n            }\\n        });\\n        q.offer(new int[]{0,src,K+1});\\n        while(!q.isEmpty())\\n        {\\n            int[] c=q.poll();\\n            int cost=c[0];\\n            int curr=c[1];\\n            int stop=c[2];\\n            if(curr==dst)\\n                return cost;\\n            if(stop>0)\\n            {\\n                if(!map.containsKey(curr))\\n                    continue;\\n                for(int[] next:map.get(curr))\\n                {\\n                    q.add(new int[]{cost+next[1],next[0],stop-1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115596,
                "title": "c-8-line-bellman-ford",
                "content": "```\nclass Solution {\npublic:\n    //bellman ford.\n    //just run it k+1 iterations.\n    int findCheapestPrice(int n, vector<vector<int>>& a, int src, int sink, int k) {\n        \n        vector<int> c(n, 1e8);\n        c[src] = 0;\n        \n        for(int z=0; z<=k; z++){\n            vector<int> C(c);\n            for(auto e: a)\n                C[e[1]] = min(C[e[1]], c[e[0]] + e[2]);\n            c = C;\n        }\n        return c[sink] == 1e8 ? -1 : c[sink];\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    //bellman ford.\n    //just run it k+1 iterations.\n    int findCheapestPrice(int n, vector<vector<int>>& a, int src, int sink, int k) {\n        \n        vector<int> c(n, 1e8);\n        c[src] = 0;\n        \n        for(int z=0; z<=k; z++){\n            vector<int> C(c);\n            for(auto e: a)\n                C[e[1]] = min(C[e[1]], c[e[0]] + e[2]);\n            c = C;\n        }\n        return c[sink] == 1e8 ? -1 : c[sink];\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 662812,
                "title": "c-bfs-bellman-ford-algo-dijkstra-algo",
                "content": "I check many posts in discussion forum but none of them were clear, consise and more readable. Here\\'s my solution:\\n\\nIf you find this post useful then **upvote** so that more people can see. Please comment if you have any doubt and I\\'ll try to improve this post.\\n\\nAlgos used are already well known so didn\\'t tried to explain it.\\n\\n1. BFS\\n```\\nint findCheapestPrice( int n, vector<vector<int>>& flights, int src, int dst, int K ) { \\n\\t// Create adjList\\n\\tunordered_map<int, vector< pair<int,int> > > adjList;\\n\\tfor( auto flight : flights )\\n\\t\\tadjList[flight[0]].push_back( { flight[1], flight[2] } );\\n\\n\\t/* BFS starting from src */\\n\\tqueue< pair<int,int> > q; // < node, dist_from_src > pair\\n\\tq.push( { src, 0 } );\\n\\tint srcToTgtDist = INT_MAX; // result\\n\\n\\twhile( !q.empty() && K-- >= 0 ) {\\n\\t\\tint size = q.size();\\n\\t\\tfor( int i = 0; i < size; i++ ) {\\n\\t\\t\\tauto curr = q.front(); q.pop();         \\n\\t\\t\\tfor( auto nbr : adjList[curr.first] ) {\\n\\t\\t\\t\\tif( srcToTgtDist < curr.second + nbr.second ) continue;\\n\\n\\t\\t\\t\\tq.push( { nbr.first, curr.second + nbr.second } );\\n\\n\\t\\t\\t\\t// update distance from src to dst\\n\\t\\t\\t\\tif( dst == nbr.first ) \\n\\t\\t\\t\\t\\tsrcToTgtDist = min( srcToTgtDist, curr.second + nbr.second );\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn srcToTgtDist == INT_MAX ? -1 : srcToTgtDist;\\n}\\n```\\n\\n2. Bellman-Ford Algorithm\\n\\n```\\n    /*  In bellman-ford algo calculates the shortest distance from the source\\n        point to all of the vertices.\\n        Time complexity of Bellman-Ford is O(VE),\\n    */\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        /* distance from source to all other nodes */\\n        vector<int> dist( n, INT_MAX );\\n        dist[src] = 0;\\n        \\n        // Run only K+1 times since we want shortest distance in K hops\\n        for( int i=0; i <= K; i++ ) {\\n            vector<int> tmp( dist );\\n            for( auto flight : flights ) {\\n                if( dist[ flight[0] ] != INT_MAX ) {\\n                    tmp[ flight[1] ] = min( tmp[flight[1]], dist[ flight[0] ] + flight[2] );\\n                }\\n            }\\n            dist = tmp;\\n        }\\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\\n    }\\n```\\n\\n3. Dijkstra Algo\\n```\\n    /* Dijkstra\\u2019s Algorithm allows you to calculate the shortest path between \\n    one node of your choosing and every other node in a graph. \\n    \\n    Given a graph and a source vertex in the graph, find shortest paths from source\\n    to all vertices in the given graph.\\n    \\n    We generate a SPT (shortest path tree) with given source as root. We maintain\\n    two sets, one set contains vertices included in shortest path tree, other set\\n    includes vertices not yet included in shortest path tree. At every step of the\\n    algorithm, we find a vertex which is in the other set (set of not yet included)\\n    and has a minimum distance from the source.\\n    \\n    Time Complexity:  If we take a closer look, we can observe that the statements\\n    in inner loop are executed O(V+E) times (similar to BFS).\\n    So overall time complexity is O(E+V)*O(LogV) which is O((E+V)*LogV) = O(ELogV)\\n    */\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        // create adjacency list\\n        unordered_map<int,vector<pair<int, int>>> adjList;\\n        for( auto f : flights )\\n            adjList[f[0]].push_back( { f[1], f[2] } );\\n        \\n        // minHeap based on cost of distance from source\\n        priority_queue< vector<int>, vector<vector<int>>, greater<vector<int>> > minHeap;\\n        minHeap.push( { 0, src, K+1 } ); // cost, vertex, hops\\n        \\n        while( !minHeap.empty() ) {\\n            auto t = minHeap.top(); minHeap.pop();\\n            int cost = t[0];\\n            int curr = t[1];\\n            int stop = t[2];\\n            if( curr == dst )\\n                return cost;\\n\\n            if( stop > 0 )\\n                for( auto next : adjList[curr] )\\n                    minHeap.push( { cost+next.second, next.first, stop-1 } );\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nint findCheapestPrice( int n, vector<vector<int>>& flights, int src, int dst, int K ) { \\n\\t// Create adjList\\n\\tunordered_map<int, vector< pair<int,int> > > adjList;\\n\\tfor( auto flight : flights )\\n\\t\\tadjList[flight[0]].push_back( { flight[1], flight[2] } );\\n\\n\\t/* BFS starting from src */\\n\\tqueue< pair<int,int> > q; // < node, dist_from_src > pair\\n\\tq.push( { src, 0 } );\\n\\tint srcToTgtDist = INT_MAX; // result\\n\\n\\twhile( !q.empty() && K-- >= 0 ) {\\n\\t\\tint size = q.size();\\n\\t\\tfor( int i = 0; i < size; i++ ) {\\n\\t\\t\\tauto curr = q.front(); q.pop();         \\n\\t\\t\\tfor( auto nbr : adjList[curr.first] ) {\\n\\t\\t\\t\\tif( srcToTgtDist < curr.second + nbr.second ) continue;\\n\\n\\t\\t\\t\\tq.push( { nbr.first, curr.second + nbr.second } );\\n\\n\\t\\t\\t\\t// update distance from src to dst\\n\\t\\t\\t\\tif( dst == nbr.first ) \\n\\t\\t\\t\\t\\tsrcToTgtDist = min( srcToTgtDist, curr.second + nbr.second );\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn srcToTgtDist == INT_MAX ? -1 : srcToTgtDist;\\n}\\n```\n```\\n    /*  In bellman-ford algo calculates the shortest distance from the source\\n        point to all of the vertices.\\n        Time complexity of Bellman-Ford is O(VE),\\n    */\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        /* distance from source to all other nodes */\\n        vector<int> dist( n, INT_MAX );\\n        dist[src] = 0;\\n        \\n        // Run only K+1 times since we want shortest distance in K hops\\n        for( int i=0; i <= K; i++ ) {\\n            vector<int> tmp( dist );\\n            for( auto flight : flights ) {\\n                if( dist[ flight[0] ] != INT_MAX ) {\\n                    tmp[ flight[1] ] = min( tmp[flight[1]], dist[ flight[0] ] + flight[2] );\\n                }\\n            }\\n            dist = tmp;\\n        }\\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\\n    }\\n```\n```\\n    /* Dijkstra\\u2019s Algorithm allows you to calculate the shortest path between \\n    one node of your choosing and every other node in a graph. \\n    \\n    Given a graph and a source vertex in the graph, find shortest paths from source\\n    to all vertices in the given graph.\\n    \\n    We generate a SPT (shortest path tree) with given source as root. We maintain\\n    two sets, one set contains vertices included in shortest path tree, other set\\n    includes vertices not yet included in shortest path tree. At every step of the\\n    algorithm, we find a vertex which is in the other set (set of not yet included)\\n    and has a minimum distance from the source.\\n    \\n    Time Complexity:  If we take a closer look, we can observe that the statements\\n    in inner loop are executed O(V+E) times (similar to BFS).\\n    So overall time complexity is O(E+V)*O(LogV) which is O((E+V)*LogV) = O(ELogV)\\n    */\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        // create adjacency list\\n        unordered_map<int,vector<pair<int, int>>> adjList;\\n        for( auto f : flights )\\n            adjList[f[0]].push_back( { f[1], f[2] } );\\n        \\n        // minHeap based on cost of distance from source\\n        priority_queue< vector<int>, vector<vector<int>>, greater<vector<int>> > minHeap;\\n        minHeap.push( { 0, src, K+1 } ); // cost, vertex, hops\\n        \\n        while( !minHeap.empty() ) {\\n            auto t = minHeap.top(); minHeap.pop();\\n            int cost = t[0];\\n            int curr = t[1];\\n            int stop = t[2];\\n            if( curr == dst )\\n                return cost;\\n\\n            if( stop > 0 )\\n                for( auto next : adjList[curr] )\\n                    minHeap.push( { cost+next.second, next.first, stop-1 } );\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099885,
                "title": "day-26-simple-bfs-easiest-beginner-friendly-solution",
                "content": "# Intuition of this Problem\\nWe can solve this problem using various ways:\\n- **Dijkstra Algorithm** - Time Complexity - O(V^2)\\n- **Floyd Warshall Algoithm** - Time Complexity - O(v^3)\\n- **Bellman Ford Algorithm** - Time Complexity - O(V^3)\\n\\nI used **simple BFS** to solve the problem. For furhter optimization in this solution we can use priority queue. But In this solution I didn\\'t use.\\n\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem\\n1. Initialize an adjacency list with the given flights information, where each index i represents the node i, and the corresponding value is a list of pairs (neighbor, price) representing the edges from node i to its neighboring nodes and the price of the flight.\\n2. Initialize a queue with the source node and its cost (0) and a vector minCost with the same size as the number of nodes, where each index i represents the minimum cost to reach node i and the corresponding value is initialized to INT_MAX.\\n3. Create a variable stops and initialize it to 0.\\n4. Start a while loop until the queue is not empty and stops are less than or equal to k (maximum stops allowed).\\n5. In the while loop, create a variable size equal to the size of the queue.\\n6. Start another while loop with the size of the queue.\\n7. In the inner while loop, pop the front element from the queue and assign it to a variable (currNode, cost).\\n8. Iterate through the neighbors and price of the current node from the adjacency list.\\n9. If the total cost to reach the neighbor is greater than or equal to the minimum cost to reach the neighbor, continue to the next iteration.\\n10. Else, update the minimum cost to reach the neighbor as the total cost and push the neighbor and its cost to the queue.\\n11. End the inner while loop and increment the stops by 1.\\n12. End the outer while loop.\\n13. If the minimum cost to reach the destination is still INT_MAX, return -1, otherwise, return the minimum cost to reach the destination.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto flight : flights){\\n            // flight[0] represent node i, flight[1] represent neighbor node of node i, flight[2] represent cost between node i to neighbor node\\n            adj[flight[0]].push_back({flight[1], flight[2]});\\n        }\\n        //it will store [node, cost]\\n        queue<pair<int, int>> q;\\n        q.push({src, 0});\\n        //it will store minimum cost to reach each node\\n        vector<int> minCost(n, INT_MAX);\\n        int stops = 0;\\n        while(!q.empty() && stops <= k){\\n            int size = q.size();\\n            while (size--) {\\n                auto [currNode, cost] = q.front();\\n                q.pop();\\n                for (auto& [neighbour, price] : adj[currNode]) {\\n                    if (price + cost < minCost[neighbour]){\\n                        minCost[neighbour] = price + cost;\\n                        q.push({neighbour, minCost[neighbour]});\\n                    }\\n                }\\n            }\\n            stops++;\\n        }\\n        if(minCost[dst] == INT_MAX)\\n            return -1;\\n        return minCost[dst];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        List<List<int[]>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\\n        for (int[] flight : flights) {\\n            adj.get(flight[0]).add(new int[] {flight[1], flight[2]});\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[] {src, 0});\\n        int[] minCost = new int[n];\\n        Arrays.fill(minCost, Integer.MAX_VALUE);\\n        int stops = 0;\\n        while (!q.isEmpty() && stops <= k) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] curr = q.poll();\\n                for (int[] neighbour : adj.get(curr[0])) {\\n                    int price = neighbour[1], neighbourNode = neighbour[0];\\n                    if (price + curr[1] >= minCost[neighbourNode]) continue;\\n                    minCost[neighbourNode] = price + curr[1];\\n                    q.offer(new int[] {neighbourNode, minCost[neighbourNode]});\\n                }\\n            }\\n            stops++;\\n        }\\n        return minCost[dst] == Integer.MAX_VALUE ? -1 : minCost[dst];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        adj = [[] for _ in range(n)]\\n        for flight in flights:\\n            adj[flight[0]].append((flight[1], flight[2]))\\n        \\n        q = [(src, 0)]\\n        minCost = [float(\\'inf\\') for _ in range(n)]\\n        stops = 0\\n        \\n        while q and stops <= k:\\n            size = len(q)\\n            for i in range(size):\\n                currNode, cost = q.pop(0)\\n                for neighbour, price in adj[currNode]:\\n                    if price + cost >= minCost[neighbour]:\\n                        continue\\n                    minCost[neighbour] = price + cost\\n                    q.append((neighbour, minCost[neighbour]))\\n            stops += 1\\n        \\n        return -1 if minCost[dst] == float(\\'inf\\') else minCost[dst]\\n\\n```\\n\\n# Time Complexity and Space Complexity\\n- Time complexity: **O(V + E*K)**\\nThe time complexity of this code is O(V + E*K) where E is the number of flights, and V is the number of cities. The reason for this is that the outer while loop runs for at most V iterations, and in each iteration, the inner while loop runs for at most E iterations.However, the maximum number of times an edge can be processed is limited by K.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(V + E)**\\nhe space complexity of this code is O(V + E), as it uses two data structures to store the graph (a list of lists) and the minimum cost to reach each node (an array of integers). The queue used to keep track of the next node to visit also takes up O(V) space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        for(auto flight : flights){\\n            // flight[0] represent node i, flight[1] represent neighbor node of node i, flight[2] represent cost between node i to neighbor node\\n            adj[flight[0]].push_back({flight[1], flight[2]});\\n        }\\n        //it will store [node, cost]\\n        queue<pair<int, int>> q;\\n        q.push({src, 0});\\n        //it will store minimum cost to reach each node\\n        vector<int> minCost(n, INT_MAX);\\n        int stops = 0;\\n        while(!q.empty() && stops <= k){\\n            int size = q.size();\\n            while (size--) {\\n                auto [currNode, cost] = q.front();\\n                q.pop();\\n                for (auto& [neighbour, price] : adj[currNode]) {\\n                    if (price + cost < minCost[neighbour]){\\n                        minCost[neighbour] = price + cost;\\n                        q.push({neighbour, minCost[neighbour]});\\n                    }\\n                }\\n            }\\n            stops++;\\n        }\\n        if(minCost[dst] == INT_MAX)\\n            return -1;\\n        return minCost[dst];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        List<List<int[]>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());\\n        for (int[] flight : flights) {\\n            adj.get(flight[0]).add(new int[] {flight[1], flight[2]});\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[] {src, 0});\\n        int[] minCost = new int[n];\\n        Arrays.fill(minCost, Integer.MAX_VALUE);\\n        int stops = 0;\\n        while (!q.isEmpty() && stops <= k) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] curr = q.poll();\\n                for (int[] neighbour : adj.get(curr[0])) {\\n                    int price = neighbour[1], neighbourNode = neighbour[0];\\n                    if (price + curr[1] >= minCost[neighbourNode]) continue;\\n                    minCost[neighbourNode] = price + curr[1];\\n                    q.offer(new int[] {neighbourNode, minCost[neighbourNode]});\\n                }\\n            }\\n            stops++;\\n        }\\n        return minCost[dst] == Integer.MAX_VALUE ? -1 : minCost[dst];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        adj = [[] for _ in range(n)]\\n        for flight in flights:\\n            adj[flight[0]].append((flight[1], flight[2]))\\n        \\n        q = [(src, 0)]\\n        minCost = [float(\\'inf\\') for _ in range(n)]\\n        stops = 0\\n        \\n        while q and stops <= k:\\n            size = len(q)\\n            for i in range(size):\\n                currNode, cost = q.pop(0)\\n                for neighbour, price in adj[currNode]:\\n                    if price + cost >= minCost[neighbour]:\\n                        continue\\n                    minCost[neighbour] = price + cost\\n                    q.append((neighbour, minCost[neighbour]))\\n            stops += 1\\n        \\n        return -1 if minCost[dst] == float(\\'inf\\') else minCost[dst]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267200,
                "title": "python-dijkstra",
                "content": "A good case to practice Dijkstra.\\n\\nTo implement Dijkstra, we need a priority queue to pop out the lowest weight node for next search. In this case, the weight would be the accumulated flight cost. So my node takes a form of `(cost, src, k)`. `cost` is the accumulated cost, `src` is the current node\\'s location, `k`  is stop times we left as we only have at most K stops. I also convert ```edges``` to an adjacent list based graph `g`.\\n\\nUse a `vis` array to maintain visited nodes to avoid loop. `vis[x]` record the remaining steps to reach x with the lowest cost. If `vis[x] >= k`, then no need to visit that case `(start from x with k steps left)` as a better solution has been visited before (more remaining step and lower cost as heappopped beforehand). And we should initialize `vis[x]` to `0` to ensure visit always stop at a negative `k`.\\n\\nOnce `k` is used up (`k == 0`) or `vis[x] >= k`, we no longer push that node `x` to our queue. Once a popped cost is our destination, we get our lowest valid cost.\\n\\nFor Dijkstra, there is not need to maintain a ```best cost``` for each node since it\\'s kind of greedy search. It always chooses the lowest cost node for next search. So the previous searched node always has a lower cost and has no chance to be updated. The first time we pop our destination from our queue, we have found the lowest cost to our destination.\\n```\\ndef findCheapestPrice(n, flights, src, dst, K):\\n\\tgraph = collections.defaultdict(dict)\\n\\tfor s, d, w in flights:\\n\\t\\tgraph[s][d] = w\\n\\tpq = [(0, src, K+1)]\\n\\tvis = [0] * n\\n\\twhile pq:\\n\\t\\tw, x, k = heapq.heappop(pq)\\n\\t\\tif x == dst:\\n\\t\\t\\treturn w\\n\\t\\tif vis[x] >= k:\\n\\t\\t\\tcontinue\\n\\t\\tvis[x] = k\\n\\t\\tfor y, dw in graph[x].items():\\n\\t\\t\\theapq.heappush(pq, (w+dw, y, k-1))\\n\\treturn -1\\n```\\nPython heapq doesn\\'t support update heap node\\'s weight. But if you implement your own heap structure and support that function, you can maintain a n-size heap and time complexity is O((m + n)logn). m is number of edges and n is number of nodes. And it can be improved to O(m + nlogn) with a Fibonacci heap where a delete min costs logn but an update cost costs constant time.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```edges```\n```best cost```\n```\\ndef findCheapestPrice(n, flights, src, dst, K):\\n\\tgraph = collections.defaultdict(dict)\\n\\tfor s, d, w in flights:\\n\\t\\tgraph[s][d] = w\\n\\tpq = [(0, src, K+1)]\\n\\tvis = [0] * n\\n\\twhile pq:\\n\\t\\tw, x, k = heapq.heappop(pq)\\n\\t\\tif x == dst:\\n\\t\\t\\treturn w\\n\\t\\tif vis[x] >= k:\\n\\t\\t\\tcontinue\\n\\t\\tvis[x] = k\\n\\t\\tfor y, dw in graph[x].items():\\n\\t\\t\\theapq.heappush(pq, (w+dw, y, k-1))\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 340911,
                "title": "understanding-bellman-ford",
                "content": "Actually Bellman Ford is a space optimized version of 2D Dynamic Programming Solution.\\n\\nTo understand Bellman Ford you need to understand the 2D version first.\\n\\ndp[v, k] = Shortest path from src to v using atmost k edges\\n\\ndp[v, k] = {Minimum dist over all u belonging to all vertices which are coming towards v(in the indegree[v])} min(dp[u, k-1] + w(u->v)).\\ndp[u, k-1] becoz we have to reach to u using atmost k-1 edges. As we have to reach v using atmost k edges.\\n\\nSimilarly dp[u, k-1] = (p belongs to indegree[u]) min(dp[p, k-2] + w(p->u)).\\n\\nWhy doesn\\'t Space optimized version work for atmost K edges case?\\n\\n![image](https://assets.leetcode.com/users/david_maverick/image_1563773352.png)\\n\\nUsing above example.\\n\\nThe space optimized version will depend on order of visiting the edges.\\n\\nSuppose the order in which we relax edges is:\\n0->1\\n1->2\\n0->2\\n\\nSo after 1 round of relaxation\\n\\nDistances will be 0->1 = 100\\n\\t\\t\\t\\t\\t\\t\\t0->2 = 200\\nWhich is wrong as using atmost 1 edge the distance from 0->2 should be 500.\\nThe 1D version is agnostic to the order in which we visit edges.\\n\\nNote: K Stops = K + 1 edges\\n\\n```\\nclass Solution\\n{\\npublic:\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\\n    {        \\n        vector<vector<int>> dp(K+2, vector<int>(n, INT_MAX));\\n        \\n        //dp[i][j] = Dist to reach j using atmost i edges from src\\n        \\n        for(int i = 0; i <= K+1; i++)\\n        {\\n            dp[i][src] = 0; // Dist to reach src always zero\\n        }\\n        \\n        for(int i = 1; i <= K+1; i++)\\n        {\\n            for(auto &f: flights)\\n            {\\n                //Using indegree\\n                int u = f[0];\\n                int v = f[1];\\n                int w = f[2];\\n                \\n                if(dp[i-1][u] != INT_MAX)\\n                    dp[i][v] = min(dp[i][v], dp[i-1][u] + w);\\n            }\\n        }\\n        \\n        return (dp[K+1][dst] == INT_MAX)? -1: dp[K+1][dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\\n    {        \\n        vector<vector<int>> dp(K+2, vector<int>(n, INT_MAX));\\n        \\n        //dp[i][j] = Dist to reach j using atmost i edges from src\\n        \\n        for(int i = 0; i <= K+1; i++)\\n        {\\n            dp[i][src] = 0; // Dist to reach src always zero\\n        }\\n        \\n        for(int i = 1; i <= K+1; i++)\\n        {\\n            for(auto &f: flights)\\n            {\\n                //Using indegree\\n                int u = f[0];\\n                int v = f[1];\\n                int w = f[2];\\n                \\n                if(dp[i-1][u] != INT_MAX)\\n                    dp[i][v] = min(dp[i][v], dp[i-1][u] + w);\\n            }\\n        }\\n        \\n        return (dp[K+1][dst] == INT_MAX)? -1: dp[K+1][dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128217,
                "title": "three-c-solutions-bfs-dfs-and-bf",
                "content": "#### 1. DFS \\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n       unordered_map<int, vector<pair<int,int>>> g;\\n       for (const auto& e : flights)\\n            g[e[0]].emplace_back(e[1], e[2]);        \\n        int ans = INT_MAX;\\n        vector<int> visited(n,0);\\n        dfs(s, d, K + 1, 0, visited, ans, g);\\n        return ans == INT_MAX ? - 1 : ans;\\n    }\\n    \\n    void dfs(int s, int d, int k, int cost, vector<int>& visited, int& ans, unordered_map<int, vector<pair<int,int>>>& g ) {\\n        if (s == d) { ans = cost; return; }\\n        if (k == 0) return; \\n        visited[s]=1;\\n        for (const auto& x : g[s]) {\\n          if (visited[x.first]==0){\\n              if (cost + x.second > ans) continue; // IMPORTANT!!! prunning \\n     \\n              dfs(x.first, d, k - 1, cost + x.second, visited, ans, g); \\n             \\n          }\\n        }\\n         visited[s] = 0;\\n  }\\n```\\n#### 2. BFS\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n       unordered_map<int, vector<pair<int,int>>> g;\\n       for (const auto& e : flights)\\n            g[e[0]].emplace_back(e[1], e[2]);        \\n        int ans = INT_MAX;\\n        queue<pair<int,int>> q;q.push({s,0}); \\n        int steps =0; \\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0; i<n; ++i){\\n             auto curr=q.front();q.pop();\\n            if(curr.first == d) ans = min(ans, curr.second);   \\n            for(auto x:  g[curr.first]){             \\n               if( curr.second + x.second > ans) continue;\\n                q.push({x.first,curr.second + x.second });\\n             }  \\n            }\\n          if(steps++ > K) break;\\n        }\\n        \\n        return ans == INT_MAX ? - 1 : ans;\\n    } \\n```\\n#### 3. BF\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n        const int INF = 1e9;\\n        vector<vector<int>> dp(K + 2, vector<int>(n, INF));\\n        dp[0][s] = 0;        \\n         for (int i = 1; i <= K + 1; ++i) {\\n            dp[i][s] = 0;\\n            for (const auto& x : flights)\\n                  dp[i][x[1]] = min(dp[i][x[1]], dp[i-1][x[0]] + x[2]);    \\n            }\\n            return dp[K + 1][d] >= INF ? -1 : dp[K + 1][d];\\n            \\n        } \\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n       unordered_map<int, vector<pair<int,int>>> g;\\n       for (const auto& e : flights)\\n            g[e[0]].emplace_back(e[1], e[2]);        \\n        int ans = INT_MAX;\\n        vector<int> visited(n,0);\\n        dfs(s, d, K + 1, 0, visited, ans, g);\\n        return ans == INT_MAX ? - 1 : ans;\\n    }\\n    \\n    void dfs(int s, int d, int k, int cost, vector<int>& visited, int& ans, unordered_map<int, vector<pair<int,int>>>& g ) {\\n        if (s == d) { ans = cost; return; }\\n        if (k == 0) return; \\n        visited[s]=1;\\n        for (const auto& x : g[s]) {\\n          if (visited[x.first]==0){\\n              if (cost + x.second > ans) continue; // IMPORTANT!!! prunning \\n     \\n              dfs(x.first, d, k - 1, cost + x.second, visited, ans, g); \\n             \\n          }\\n        }\\n         visited[s] = 0;\\n  }\\n```\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n       unordered_map<int, vector<pair<int,int>>> g;\\n       for (const auto& e : flights)\\n            g[e[0]].emplace_back(e[1], e[2]);        \\n        int ans = INT_MAX;\\n        queue<pair<int,int>> q;q.push({s,0}); \\n        int steps =0; \\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i=0; i<n; ++i){\\n             auto curr=q.front();q.pop();\\n            if(curr.first == d) ans = min(ans, curr.second);   \\n            for(auto x:  g[curr.first]){             \\n               if( curr.second + x.second > ans) continue;\\n                q.push({x.first,curr.second + x.second });\\n             }  \\n            }\\n          if(steps++ > K) break;\\n        }\\n        \\n        return ans == INT_MAX ? - 1 : ans;\\n    } \\n```\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int s, int d, int K) {\\n        const int INF = 1e9;\\n        vector<vector<int>> dp(K + 2, vector<int>(n, INF));\\n        dp[0][s] = 0;        \\n         for (int i = 1; i <= K + 1; ++i) {\\n            dp[i][s] = 0;\\n            for (const auto& x : flights)\\n                  dp[i][x[1]] = min(dp[i][x[1]], dp[i-1][x[0]] + x[2]);    \\n            }\\n            return dp[K + 1][d] >= INF ? -1 : dp[K + 1][d];\\n            \\n        } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686829,
                "title": "c-easy-beginner-friendly",
                "content": "```\\n// 1st approach\\n int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n    //1. Create an Adjacency List\\n        vector<vector<vector<int>>> adjList(n);\\n        \\n        //example :\\n        //0 : {1, 100}, {2, 500}\\n        //1 : {2, 100}\\n        //2 : \\n        \\n        \\n        for(auto f : flights) {\\n            int from = f[0];\\n            int to = f[1];\\n            int cost = f[2];\\n            adjList[from].push_back({to, cost});\\n            //from : source\\n            //to : dest \\n            //cost: cost from \\'from\\' to \\'to\\'\\n        }\\n        \\n        \\n    //2. Create a queue for performing BFS\\n        queue<vector<int>> q;\\n        \\n     //3. Push source in q as {src, money spent so far, number of stops b/w current city and source}\\n        q.push({src, 0, -1});\\n        //Note : if {A, B} are two directly connected cities, then number of stops b/w them is Zero,\\n        //so for convenience i\\'m assuming number of stops b/w A and A as -1\\n        \\n     int minCost = INT_MAX;   //this keeps track of minimum cost\\n    \\n        \\n     while(!q.empty()) {\\n            vector<int> curStation = q.front(); q.pop();\\n         \\n            int curCity = curStation[0];\\n            int curCost = curStation[1];\\n            int curK = curStation[2];      //this is the number of stops seen so far from source to current city\\n         \\n            if(curCity == dst) {\\n              minCost = min(minCost, curCost);\\n              continue;  \\n            }\\n             \\n         \\n            for(auto p : adjList[curCity]) {\\n                //we include a city in our route only if :\\n                // > it doesn\\'t exceed number of stops alloted\\n                // > it keeps cost less than mincost\\n\\t\\t\\t\\t//***\\n                if(curK+1 <= k and curCost + p[1] < minCost)\\n                q.push({p[0], p[1] + curCost, curK+1});\\n            } \\n         \\n     }   \\n        \\n     return minCost==INT_MAX?-1:minCost;   \\n    }\\n\\t\\n// ***\\n// We could have just normally pushed cities and tested the conditons at the time of popping them from q\\n//But what we did is more effecient bcoz, this prevents from inserting the false cities beforehand and keeps the size of q small, (simply, we are saving many PUSH and POP operations).\\n\\n// -------------------------------------------------------------------\\n// 2nd Approach\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        vector<vector< pair<int,int> >> graph(n);\\n        for( auto edge: flights ){\\n            graph[edge[0]].push_back( {edge[1],edge[2]} );\\n        }\\n        \\n        vector<int> dist(n,pow(10,4)*n) , prev(n);\\n        dist[src] = 0;\\n        prev = dist;\\n        k++;\\n        while( k-- ){\\n            for( int i = 0 ; i < n ; i++ ){\\n                for( int j = 0; j < graph[i].size(); j++ ){\\n                    int index = graph[i][j].first;\\n                    int value = graph[i][j].second;\\n                    // at x\\'th step there can be more than one updates\\n                    // so we compare the update value, of the index \\n                    // gettting updated \\n                    if( dist[ index ] > prev[i] + value ){\\n                        dist[ index ] = prev[i] + value;\\n                    }\\n                }\\n            }\\n            prev = dist;\\n        }\\n        if( prev[dst] == pow(10,4)*n ){\\n            return -1;\\n        }\\n        return prev[dst];\\n    }",
                "solutionTags": [],
                "code": "```\\n// 1st approach\\n int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n    //1. Create an Adjacency List\\n        vector<vector<vector<int>>> adjList(n);\\n        \\n        //example :\\n        //0 : {1, 100}, {2, 500}\\n        //1 : {2, 100}\\n        //2 : \\n        \\n        \\n        for(auto f : flights) {\\n            int from = f[0];\\n            int to = f[1];\\n            int cost = f[2];\\n            adjList[from].push_back({to, cost});\\n            //from : source\\n            //to : dest \\n            //cost: cost from \\'from\\' to \\'to\\'\\n        }\\n        \\n        \\n    //2. Create a queue for performing BFS\\n        queue<vector<int>> q;\\n        \\n     //3. Push source in q as {src, money spent so far, number of stops b/w current city and source}\\n        q.push({src, 0, -1});\\n        //Note : if {A, B} are two directly connected cities, then number of stops b/w them is Zero,\\n        //so for convenience i\\'m assuming number of stops b/w A and A as -1\\n        \\n     int minCost = INT_MAX;   //this keeps track of minimum cost\\n    \\n        \\n     while(!q.empty()) {\\n            vector<int> curStation = q.front(); q.pop();\\n         \\n            int curCity = curStation[0];\\n            int curCost = curStation[1];\\n            int curK = curStation[2];      //this is the number of stops seen so far from source to current city\\n         \\n            if(curCity == dst) {\\n              minCost = min(minCost, curCost);\\n              continue;  \\n            }\\n             \\n         \\n            for(auto p : adjList[curCity]) {\\n                //we include a city in our route only if :\\n                // > it doesn\\'t exceed number of stops alloted\\n                // > it keeps cost less than mincost\\n\\t\\t\\t\\t//***\\n                if(curK+1 <= k and curCost + p[1] < minCost)\\n                q.push({p[0], p[1] + curCost, curK+1});\\n            } \\n         \\n     }   \\n        \\n     return minCost==INT_MAX?-1:minCost;   \\n    }\\n\\t\\n// ***\\n// We could have just normally pushed cities and tested the conditons at the time of popping them from q\\n//But what we did is more effecient bcoz, this prevents from inserting the false cities beforehand and keeps the size of q small, (simply, we are saving many PUSH and POP operations).\\n\\n// -------------------------------------------------------------------\\n// 2nd Approach\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        vector<vector< pair<int,int> >> graph(n);\\n        for( auto edge: flights ){\\n            graph[edge[0]].push_back( {edge[1],edge[2]} );\\n        }\\n        \\n        vector<int> dist(n,pow(10,4)*n) , prev(n);\\n        dist[src] = 0;\\n        prev = dist;\\n        k++;\\n        while( k-- ){\\n            for( int i = 0 ; i < n ; i++ ){\\n                for( int j = 0; j < graph[i].size(); j++ ){\\n                    int index = graph[i][j].first;\\n                    int value = graph[i][j].second;\\n                    // at x\\'th step there can be more than one updates\\n                    // so we compare the update value, of the index \\n                    // gettting updated \\n                    if( dist[ index ] > prev[i] + value ){\\n                        dist[ index ] = prev[i] + value;\\n                    }\\n                }\\n            }\\n            prev = dist;\\n        }\\n        if( prev[dst] == pow(10,4)*n ){\\n            return -1;\\n        }\\n        return prev[dst];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 317262,
                "title": "2-clean-python-solution-bfs-dijkstra-explained",
                "content": "# Dijkstra\\nWe start from src and only got K+1 stops to use\\nEach time, we choose the cheapest place to go.\\n\\nIf the city we popout is dst, then the price must be lowest\\nSince we always pick the lowest place to go.\\n\\nIf we still have stops left (stops>1), we put its neighbor to the priority queue.\\nSo the city in the priority queue must be within the stops limit.\\n\\nMaking the graph takes O(E)\\nThe size of priority queue is O(V), since we might put all the cities in it.\\nSo for every pop, it is O(LogV). Total is O(VLogV).\\nFor every edge we call an heappush, so that is ELogV\\nO(E+ (V+E)LogV) -> O((V+E)LogV)\\nV is the number of cities within range K stops.\\n```\\nclass Solution(object):\\n\\tdef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\\tgraph = collections.defaultdict(list)\\n\\t\\tpq = []\\n\\n\\t\\tfor u, v, w in flights: graph[u].append((w, v))\\n\\n\\t\\theapq.heappush(pq, (0, K+1, src))\\n\\t\\twhile pq:\\n\\t\\t\\tprice, stops, city = heapq.heappop(pq)\\n\\n\\t\\t\\tif city is dst: return price\\n\\t\\t\\tif stops>0:\\n\\t\\t\\t\\tfor price_to_nei, nei in graph[city]:\\n\\t\\t\\t\\t\\theapq.heappush(pq, (price+price_to_nei, stops-1, nei))\\n\\t\\treturn -1\\n```\\n# BFS\\nThis is mostly straight forward BFS.\\nWhen we are out of stops, or price is greater than min_price, we stop adding cities to the queue.\\nEvery time we encounter dst we compare the price and set it to the min.\\n\\nMaking the graph takes O(E)\\nBFS every node in adjacent list takes O(V+E)\\nV is the number of cities within range K stops.\\n```\\nclass Solution1(object):\\n\\tdef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\\tgraph = collections.defaultdict(list)\\n\\t\\tq = collections.deque()\\n\\t\\tmin_price = float(\\'inf\\')\\n\\n\\t\\tfor u, v, w in flights: graph[u].append((w, v))\\n\\t\\tq.append((src, 0, 0))\\n\\t\\twhile q:\\n\\t\\t\\tcity, stops, price = q.popleft()\\n\\t\\t\\tif city==dst:\\n\\t\\t\\t\\tmin_price = min(min_price, price)\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\tif stops<=K and price<=min_price:\\n\\t\\t\\t\\tfor price_to_nei, nei in graph[city]:\\n\\t\\t\\t\\t\\tq.append((nei, stops+1, price+price_to_nei))\\n\\n\\t\\treturn min_price if min_price!=float(\\'inf\\') else -1\\n```\\n\\n```\\nI really take time tried to make the best solution or explaination. \\nBecause I wanted to help others like me. \\nIf you like my answer, a star on GitHub means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\\tgraph = collections.defaultdict(list)\\n\\t\\tpq = []\\n\\n\\t\\tfor u, v, w in flights: graph[u].append((w, v))\\n\\n\\t\\theapq.heappush(pq, (0, K+1, src))\\n\\t\\twhile pq:\\n\\t\\t\\tprice, stops, city = heapq.heappop(pq)\\n\\n\\t\\t\\tif city is dst: return price\\n\\t\\t\\tif stops>0:\\n\\t\\t\\t\\tfor price_to_nei, nei in graph[city]:\\n\\t\\t\\t\\t\\theapq.heappush(pq, (price+price_to_nei, stops-1, nei))\\n\\t\\treturn -1\\n```\n```\\nclass Solution1(object):\\n\\tdef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\\tgraph = collections.defaultdict(list)\\n\\t\\tq = collections.deque()\\n\\t\\tmin_price = float(\\'inf\\')\\n\\n\\t\\tfor u, v, w in flights: graph[u].append((w, v))\\n\\t\\tq.append((src, 0, 0))\\n\\t\\twhile q:\\n\\t\\t\\tcity, stops, price = q.popleft()\\n\\t\\t\\tif city==dst:\\n\\t\\t\\t\\tmin_price = min(min_price, price)\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\tif stops<=K and price<=min_price:\\n\\t\\t\\t\\tfor price_to_nei, nei in graph[city]:\\n\\t\\t\\t\\t\\tq.append((nei, stops+1, price+price_to_nei))\\n\\n\\t\\treturn min_price if min_price!=float(\\'inf\\') else -1\\n```\n```\\nI really take time tried to make the best solution or explaination. \\nBecause I wanted to help others like me. \\nIf you like my answer, a star on GitHub means a lot to me. \\nhttps://github.com/wuduhren/leetcode-python\\n```",
                "codeTag": "Java"
            },
            {
                "id": 128776,
                "title": "5-ms-ac-java-solution-based-on-dijkstra-s-algorithm",
                "content": "The key point for this problem using Dijkstra\\'s Algorithm is to have two different weights on each edge, because if only consider cost, intermediate cases with higher cost but fewer stops which can further become the shortest valid solution will be discarded.\\n\\nI use a minHeap as the conventional Dijkstra\\'s Algorithm does. The difference is that conventional Dijkstra\\'s Algorithm would remove higher cost with fewer stops cases from heap and only offer cases with lower cost into heap, but I keep all valid intermediate cases in heap and offer higher cost but fewer stops cases into heap as well.  \\n```\\nclass Solution {\\n    private class City implements Comparable<City>{\\n        int id;\\n        int costFromSrc;\\n        int stopFromSrc;\\n        public City(int id, int costFromSrc, int stopFromSrc){\\n            this.id = id;\\n            this.costFromSrc = costFromSrc;\\n            this.stopFromSrc = stopFromSrc;\\n        }\\n        public boolean equals(City c){\\n            if(c instanceof City)\\n                return this.id == c.id;\\n            return false;\\n        }\\n        public int compareTo(City c){\\n            return this.costFromSrc - c.costFromSrc;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[][] srcToDst = new int[n][n];\\n        for(int i = 0; i < flights.length; i++)\\n            srcToDst[flights[i][0]][flights[i][1]] = flights[i][2]; \\n\\t\\t\\t\\t\\t\\t\\n        PriorityQueue<City> minHeap = new PriorityQueue();\\n        minHeap.offer(new City(src,0,0));\\n\\t\\t\\t\\t\\n        int[] cost = new int[n];\\n        Arrays.fill(cost, Integer.MAX_VALUE);\\n        cost[src] = 0;\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        stop[src] = 0;\\n\\t\\t\\t\\t\\n        while(!minHeap.isEmpty()){\\n            City curCity = minHeap.poll();\\n            if(curCity.id == dst) return curCity.costFromSrc;\\n            if(curCity.stopFromSrc == K + 1) continue;\\n            int[] nexts = srcToDst[curCity.id];\\n            for(int i = 0; i < n; i++){\\n                if(nexts[i] != 0){\\n                    int newCost = curCity.costFromSrc + nexts[i];\\n                    int newStop = curCity.stopFromSrc + 1;\\n                    if(newCost < cost[i]){\\n                        minHeap.offer(new City(i, newCost, newStop));\\n                        cost[i] = newCost;\\n                    }\\n                    else if(newStop < stop[i]){\\n                        minHeap.offer(new City(i, newCost, newStop));\\n                        stop[i] = newStop;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cost[dst] == Integer.MAX_VALUE? -1:cost[dst];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class City implements Comparable<City>{\\n        int id;\\n        int costFromSrc;\\n        int stopFromSrc;\\n        public City(int id, int costFromSrc, int stopFromSrc){\\n            this.id = id;\\n            this.costFromSrc = costFromSrc;\\n            this.stopFromSrc = stopFromSrc;\\n        }\\n        public boolean equals(City c){\\n            if(c instanceof City)\\n                return this.id == c.id;\\n            return false;\\n        }\\n        public int compareTo(City c){\\n            return this.costFromSrc - c.costFromSrc;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[][] srcToDst = new int[n][n];\\n        for(int i = 0; i < flights.length; i++)\\n            srcToDst[flights[i][0]][flights[i][1]] = flights[i][2]; \\n\\t\\t\\t\\t\\t\\t\\n        PriorityQueue<City> minHeap = new PriorityQueue();\\n        minHeap.offer(new City(src,0,0));\\n\\t\\t\\t\\t\\n        int[] cost = new int[n];\\n        Arrays.fill(cost, Integer.MAX_VALUE);\\n        cost[src] = 0;\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        stop[src] = 0;\\n\\t\\t\\t\\t\\n        while(!minHeap.isEmpty()){\\n            City curCity = minHeap.poll();\\n            if(curCity.id == dst) return curCity.costFromSrc;\\n            if(curCity.stopFromSrc == K + 1) continue;\\n            int[] nexts = srcToDst[curCity.id];\\n            for(int i = 0; i < n; i++){\\n                if(nexts[i] != 0){\\n                    int newCost = curCity.costFromSrc + nexts[i];\\n                    int newStop = curCity.stopFromSrc + 1;\\n                    if(newCost < cost[i]){\\n                        minHeap.offer(new City(i, newCost, newStop));\\n                        cost[i] = newCost;\\n                    }\\n                    else if(newStop < stop[i]){\\n                        minHeap.offer(new City(i, newCost, newStop));\\n                        stop[i] = newStop;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return cost[dst] == Integer.MAX_VALUE? -1:cost[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532900,
                "title": "c-3-methods-bfs-bellman-ford-dijksrta-no-tle",
                "content": "**Method 1: Dijkstra\\'s Algorithm**\\n\\nSpace Complexity: ```O(e * k)```\\nTime Complexity: ```O(e * k) * (log(e * k))```\\n(Priority queue will store at max ```(e * k)``` values which will happen when the destinaton cannot be reached in ```k``` stops. To push a value it will take ```log(e * k)```)\\n(```e``` represent number of edges or size of ```flights``` vector)\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto e : flights) {\\n            graph[e[0]].push_back({e[1], e[2]});\\n        }\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        // {dist_from_src_node, node, number_of_stops_from_src_node}\\n        pq.push({0, src, 0});\\n        \\n        vector<int> stops(n, INT_MAX);\\n        // number of stops to reach indexth node with least possible price from src node\\n        // as it will be calculated once the pq.top() equals to indexth node\\n        \\n        // pq.top() will always store least cost among the pq elements so if already stop is calculated\\n        // and if that is greater than the cstop that means already we have a path with cheaper cost\\n        // as well as with less or equal number of stops\\n        \\n        while(!pq.empty()) {\\n            auto temp=pq.top();\\n            int cdist=temp[0];\\n            int cnode=temp[1];\\n            int cstop=temp[2];\\n            pq.pop();\\n            \\n            if(cstop>stops[cnode] || cstop>k+1)\\n                continue;\\n            \\n            stops[cnode]=cstop;\\n            if(cnode==dst) {\\n                return cdist;\\n            }\\n            \\n            for(auto a : graph[cnode]) {\\n                pq.push({cdist+a.second, a.first, cstop+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Method 2: BFS**\\n\\nSpace Complexity: ```O(e * k) + O(n)```\\nTime Complexity: ```O(e * k)```\\n(Queue will store at max ```(e * k)``` values for the same reason and pushing or popping requires ```O(1)```)\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto e : flights) {\\n            graph[e[0]].push_back({e[1], e[2]});\\n        }\\n        int ans=INT_MAX;\\n        vector<int> dist(n, INT_MAX);\\n        queue<pair<int, int>> q;\\n        q.push({src, 0});\\n        int stops=0;\\n        while(stops<=k && !q.empty()) {\\n            int sz=q.size();\\n            while(sz--) {\\n                int cnode=q.front().first;\\n                int cdist=q.front().second;\\n                q.pop();\\n                if(cdist>dist[cnode]) continue;\\n                dist[cnode]=cdist;\\n                for(auto e : graph[cnode]) {\\n                    if(e.second+cdist>ans) continue;\\n                    if(e.first==dst) ans=min(ans, e.second+cdist);\\n                    q.push({e.first, e.second+cdist});\\n                }\\n            }\\n            stops++;\\n        }\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```\\n\\n**Method 3: Bellman Ford**\\n\\nSpace Complexity: ```O(n)```\\nTime Complexity: ```O(e * k)```\\n(It simply makes the use of a ```dist``` vector. We run a loop ```k``` times and each time we traverse all the edges)\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& edges, int src, int dst, int k) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[src]=0;\\n        for(int i=0; i<=k; i++) {\\n            vector<int> temp(n);\\n            copy(dist.begin(), dist.end(), temp.begin());\\n            for(auto e : edges) {\\n                if(dist[e[0]]==INT_MAX)\\n                    continue;\\n                if(temp[e[1]]>dist[e[0]]+e[2])\\n                    temp[e[1]]=dist[e[0]]+e[2];\\n            }\\n            copy(temp.begin(), temp.end(), dist.begin());\\n        }\\n        if(dist[dst]==INT_MAX)\\n            return -1;\\n        return dist[dst];\\n    }\\n};\\n```\\n\\n*PLease upvote if you find this helpful* :)\\n*Feel free to comment in case of any doubt*",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```O(e * k)```\n```O(e * k) * (log(e * k))```\n```(e * k)```\n```k```\n```log(e * k)```\n```e```\n```flights```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto e : flights) {\\n            graph[e[0]].push_back({e[1], e[2]});\\n        }\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        // {dist_from_src_node, node, number_of_stops_from_src_node}\\n        pq.push({0, src, 0});\\n        \\n        vector<int> stops(n, INT_MAX);\\n        // number of stops to reach indexth node with least possible price from src node\\n        // as it will be calculated once the pq.top() equals to indexth node\\n        \\n        // pq.top() will always store least cost among the pq elements so if already stop is calculated\\n        // and if that is greater than the cstop that means already we have a path with cheaper cost\\n        // as well as with less or equal number of stops\\n        \\n        while(!pq.empty()) {\\n            auto temp=pq.top();\\n            int cdist=temp[0];\\n            int cnode=temp[1];\\n            int cstop=temp[2];\\n            pq.pop();\\n            \\n            if(cstop>stops[cnode] || cstop>k+1)\\n                continue;\\n            \\n            stops[cnode]=cstop;\\n            if(cnode==dst) {\\n                return cdist;\\n            }\\n            \\n            for(auto a : graph[cnode]) {\\n                pq.push({cdist+a.second, a.first, cstop+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```O(e * k) + O(n)```\n```O(e * k)```\n```(e * k)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int, int>>> graph(n);\\n        for(auto e : flights) {\\n            graph[e[0]].push_back({e[1], e[2]});\\n        }\\n        int ans=INT_MAX;\\n        vector<int> dist(n, INT_MAX);\\n        queue<pair<int, int>> q;\\n        q.push({src, 0});\\n        int stops=0;\\n        while(stops<=k && !q.empty()) {\\n            int sz=q.size();\\n            while(sz--) {\\n                int cnode=q.front().first;\\n                int cdist=q.front().second;\\n                q.pop();\\n                if(cdist>dist[cnode]) continue;\\n                dist[cnode]=cdist;\\n                for(auto e : graph[cnode]) {\\n                    if(e.second+cdist>ans) continue;\\n                    if(e.first==dst) ans=min(ans, e.second+cdist);\\n                    q.push({e.first, e.second+cdist});\\n                }\\n            }\\n            stops++;\\n        }\\n        if(ans==INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```\n```O(n)```\n```O(e * k)```\n```dist```\n```k```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& edges, int src, int dst, int k) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[src]=0;\\n        for(int i=0; i<=k; i++) {\\n            vector<int> temp(n);\\n            copy(dist.begin(), dist.end(), temp.begin());\\n            for(auto e : edges) {\\n                if(dist[e[0]]==INT_MAX)\\n                    continue;\\n                if(temp[e[1]]>dist[e[0]]+e[2])\\n                    temp[e[1]]=dist[e[0]]+e[2];\\n            }\\n            copy(temp.begin(), temp.end(), dist.begin());\\n        }\\n        if(dist[dst]==INT_MAX)\\n            return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686906,
                "title": "python-multipass-bfs-o-v-2-dijkstra-with-sortedlist-explained",
                "content": "There are a lot of different ways to handle this problem: using DFS, BFS, Dijkstra, Bellman-Ford, Dynamic programming. For me it is easier to use **BFS**, because we are asked to find the shortest distance between two given cities, not with all `dst` like in Dijkstra or Bellman-Ford. \\n\\n**BFS** the idea is to traverse our graph in usual bfs routine and also take into account that we can have maximum `k` stops, that is our pathes should have length less or equal than `k + 1`. To implement bfs in python usual way is to use deque (double ended queue), it works pretty fast in python. We can not use usual list like in dfs (for similate stack), because here we need to pop elements from the beginning of our queue.\\n\\nWe need to keep in each cell of our queue `3` values: current `city`, current number of `visited` cities and current `price`. It is worth to investigate new city if 3 conditions met:\\n1. Our current price is less or equal to minumum price found so far.\\n2. If we still can visit one more city, `visited < k+1`.\\n3. The current city is not our destination yet.\\n\\nIf we reached our city of destination, we update minimum price we get so far.\\n\\n**Complexity**, both time and memory of bfs is `O(V + E)`, where `E` is number of edges and `V` is number of vertices. Note however, that we have here multipass bfs, when we visit node, we do not mark it as visited, and we can visit it several times. In fact this algorighm is very similar to Dijkstra algorighm, and I think complexity is `O(E + V^2) = E(V^2)`, because we traverse each edge only once, but we can visit nodes a lot of times. **Update** I do no think it is quite true, need to be checked.\\n\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = defaultdict(list)\\n        deque_vert = deque([[src, 0, 0]])\\n        min_price = float(\\'inf\\')\\n     \\n        for i, j, w in flights: \\n            graph[i].append([j, w])\\n\\n        while deque_vert:\\n            city, visited, price = deque_vert.popleft()\\n\\n            if price <= min_price and visited <= k and city != dst:\\n                for neibh, price_neibh in graph[city]:\\n                     deque_vert.append([neibh, visited + 1, price + price_neibh])\\n            \\n            if city == dst:\\n                min_price = min(min_price, price)\\n                \\n        return min_price if min_price != float(\\'inf\\') else -1\\n```\\n\\n### Dijkstra \\n\\nThere is better complexity time solution (however we need bigger tests to check it).\\nI was wonderig is it possible to use `SortedList`, instead of `Heap` in Dijkstra algorighm, and the answer is yes! What we need to do is to pop the smallest element and to insert into our list in logarighmic time. Here we need to keep `2`-dimensional table `dist` for shortest distances with given length of path. \\n\\n**Complexity** I think it is `O(E+(Vk)*log(Vk))`, because there will be no more than `Vk` different elements in our SortedList (Heap) at any moment.\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = defaultdict(list)\\n        dist = [[float(\"inf\")] * (k+2) for _ in range(n)] \\n        dist[src][0] = 0\\n\\n        SList = SortedList([[0, 0, src]])\\n        \\n        for i, j, w in flights: \\n            graph[i].append([j, w])\\n        \\n        while SList:\\n            price, visited, city = SList.pop(0)\\n\\n            if city == dst: return price\\n            \\n            if visited <= k:\\n                for neibh, price_neibh in graph[city]: \\n                    candidate = dist[city][visited] + price_neibh\\n                    if candidate <= dist[neibh][visited + 1]:\\n                        dist[neibh][visited + 1] = candidate\\n                        SList.add([price + price_neibh, visited + 1, neibh])\\n                        \\n        return -1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = defaultdict(list)\\n        deque_vert = deque([[src, 0, 0]])\\n        min_price = float(\\'inf\\')\\n     \\n        for i, j, w in flights: \\n            graph[i].append([j, w])\\n\\n        while deque_vert:\\n            city, visited, price = deque_vert.popleft()\\n\\n            if price <= min_price and visited <= k and city != dst:\\n                for neibh, price_neibh in graph[city]:\\n                     deque_vert.append([neibh, visited + 1, price + price_neibh])\\n            \\n            if city == dst:\\n                min_price = min(min_price, price)\\n                \\n        return min_price if min_price != float(\\'inf\\') else -1\\n```\n```\\nclass Solution:\\n    def findCheapestPrice(self, n, flights, src, dst, k):\\n        graph = defaultdict(list)\\n        dist = [[float(\"inf\")] * (k+2) for _ in range(n)] \\n        dist[src][0] = 0\\n\\n        SList = SortedList([[0, 0, src]])\\n        \\n        for i, j, w in flights: \\n            graph[i].append([j, w])\\n        \\n        while SList:\\n            price, visited, city = SList.pop(0)\\n\\n            if city == dst: return price\\n            \\n            if visited <= k:\\n                for neibh, price_neibh in graph[city]: \\n                    candidate = dist[city][visited] + price_neibh\\n                    if candidate <= dist[neibh][visited + 1]:\\n                        dist[neibh][visited + 1] = candidate\\n                        SList.add([price + price_neibh, visited + 1, neibh])\\n                        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626208,
                "title": "detailed-c-standard-approaches-dp-approach-dfs-with-memoization-bfs",
                "content": "The questions can be easily solved using both the Depth First Search (DFS) and Breadth First Search (BFS) approach.\\n\\n**1. DFS Approach**\\nPretty standard format and easy to understand I guess. The only thing which appears to be different from a standard DFS call is the memoization part. Since, the nodes are higher in number and we can easily get a TLE re-calculating the distances, it\\'s better to store the computed values for later use.\\nOur cache (DP table) will be a 2-D grid because the only varible factors in our function call are `src` and `k`. Both these parameter decide the outcome, and hence both these parameters are needed to map the answer.\\n\\n```\\n\\tint dp[10001][101];\\n\\t\\n    int dfs(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {\\n        if (src == dst) return 0;\\n        if (k <= -1) return INT_MAX;\\n        \\n        if (dp[src][k] != -1) return dp[src][k];\\n        \\n        int ans = INT_MAX;\\n        for (auto child : graph[src]) {\\n            int res = dfs(graph, child.first, dst, k-1);\\n            if (res != INT_MAX)\\n                ans = min(ans, child.second +res);\\n        }\\n        \\n        return dp[src][k] = ans;\\n    }\\n```\\n\\n**2. BFS Approach**\\nWe might also use the BFS approach and the run time is slightly better than the DFS approach. This is also pretty standard, we\\'ll use a queue and so on. BFS will also give a TLE if we don\\'t prune using ` if(child.second + node.second > ans) continue;`\\n \\n ![image](https://assets.leetcode.com/users/abhisharma404/image_1589180870.png)\\n\\nA little explanation of the following using a dry run\\n```\\nif(child.second + node.second > ans) continue;\\nchild.second += node.second;\\nq.push(child);\\n```\\n1. We set ans = INT_MAX;\\n2. We push in all the nodes connected to 0, i.e. `2` and `1`.\\n3. We visit `2` and update our answer, `ans = min(ans, node.second)`, our answer is now equal to 500 and pop out `2`.\\n4. We visit `1`. Now `2` is a child of `1`, things are different from rest of the BFS here, just because we have visited `2` once does not mean we will ignore it like we use to do in standard BFS call. Instead, we\\'ll prune using the condition ` if(child.second + node.second > ans) continue;`. The following calculation happens:\\n\\ta. Child = `2`, Node = `1`\\n\\tb. Child.second = 100 (cost of `1` to `2`)\\n\\tc. Node.second = 100 (total cost from start i.e. `0` to `1`)\\n\\td. 100 + 100 = 200 < ans(=500), hence we update the value of the child node `2` and push it again into the queue.\\n\\n```\\n    int bfs(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {\\n        queue <pair<int, int>> q;\\n        for (auto p : graph[src]) {\\n            q.push(p);\\n        }\\n        int ans = INT_MAX;\\n        while (!q.empty()) {\\n            int sz = q.size();\\n            k--;\\n            if (k < -1) break;\\n            for (int s=0; s<sz; s++) {\\n                auto node = q.front();\\n                q.pop();\\n                if (node.first == dst)\\n                    ans = min(ans, node.second);\\n                for (auto child : graph[node.first]) {\\n                    if(child.second + node.second > ans) continue;\\n                    child.second += node.second;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n**3. Caller Function**\\n\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        memset(dp, -1, sizeof dp);\\n        // Build the graph\\n        vector<vector<pair<int, int>>> graph(n);\\n        for (auto vec : flights) {\\n            graph[vec[0]].emplace_back(make_pair(vec[1], vec[2]));\\n        }\\n        int ans = bfs(graph, src, dst, K);  // or make the dfs call\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n```\\n\\nI hope it helps. :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint dp[10001][101];\\n\\t\\n    int dfs(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {\\n        if (src == dst) return 0;\\n        if (k <= -1) return INT_MAX;\\n        \\n        if (dp[src][k] != -1) return dp[src][k];\\n        \\n        int ans = INT_MAX;\\n        for (auto child : graph[src]) {\\n            int res = dfs(graph, child.first, dst, k-1);\\n            if (res != INT_MAX)\\n                ans = min(ans, child.second +res);\\n        }\\n        \\n        return dp[src][k] = ans;\\n    }\\n```\n```\\nif(child.second + node.second > ans) continue;\\nchild.second += node.second;\\nq.push(child);\\n```\n```\\n    int bfs(vector<vector<pair<int, int>>>& graph, int src, int dst, int k) {\\n        queue <pair<int, int>> q;\\n        for (auto p : graph[src]) {\\n            q.push(p);\\n        }\\n        int ans = INT_MAX;\\n        while (!q.empty()) {\\n            int sz = q.size();\\n            k--;\\n            if (k < -1) break;\\n            for (int s=0; s<sz; s++) {\\n                auto node = q.front();\\n                q.pop();\\n                if (node.first == dst)\\n                    ans = min(ans, node.second);\\n                for (auto child : graph[node.first]) {\\n                    if(child.second + node.second > ans) continue;\\n                    child.second += node.second;\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        memset(dp, -1, sizeof dp);\\n        // Build the graph\\n        vector<vector<pair<int, int>>> graph(n);\\n        for (auto vec : flights) {\\n            graph[vec[0]].emplace_back(make_pair(vec[1], vec[2]));\\n        }\\n        int ans = bfs(graph, src, dst, K);  // or make the dfs call\\n        if (ans == INT_MAX)\\n            return -1;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100039,
                "title": "clean-codes-full-explanation-dijkstra-s-algo-c-java-python3",
                "content": "# Intuition :\\n- Since in this problem, we have to calculate the minimum cost to reach the destination from the source but with a restriction on the number of stops, we would be using Dijkstra\\u2019s Algorithm. Now, one must wonder that based on what parameter we should add elements to the priority queue.\\n\\n- Now, if we store the elements in the priority queue with the priority given to the minimum distance first, then after a few iterations we would realize that the Algorithm will halt when the number of stops would exceed. This may result in a wrong answer as it would not allow us to explore those paths which have more cost but fewer stops than the current answer.\\n\\n- To tackle this issue, we store the elements in terms of the minimum number of stops in the priority queue so that when the algorithm halts, we can get the minimum cost within limits.\\n\\n- Also, a point to note here is that do we really need a priority queue for carrying out the algorithm? The answer for that is No because when we are storing everything in terms of a number of stops, the stops are increasing monotonically which means that the number of sops is increasing by 1 and when we pop an element out of the queue, we are always popping the element with a lesser number of stops first. \\n- Replacing the priority queue with a simple queue will let us eliminate an extra log(N) of the complexity of insertion-deletion in a priority queue which would in turn make our algorithm a lot faster.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n**Initial configuration:**\\n- Queue: Define a Queue that would contain pairs of the type {stops, {node,dist} }, where \\u2018dist\\u2019 indicates the currently updated value of the distance from the source to the \\u2018node\\u2019 and \\u2018stops\\u2019 contains the number of nodes one has to traverse in order to reach node from src.\\n\\n- Distance Array: Define a distance array that would contain the minimum cost/distance from the source cell to a particular cell. If a cell is marked as \\u2018infinity\\u2019 then it is treated as unreachable/unvisited.\\n\\n- Source and Destination: Define the source and the destination from where the flights have to run.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Steps to Follow :\\n- Start by creating an adjacency list, a queue that stores the distance-node and stops pairs in the form {stops,{node,dist}} and a dist array with each node initialized with a very large number ( to indicate that they\\u2019re unvisited initially) and the source node marked as \\u20180\\u2019.\\n- We push the source cell to the queue along with its distance which is also 0 and the stops are marked as \\u20180\\u2019 initially because we\\u2019ve just started.\\n- Pop the element at the front of the queue and look out for its adjacent nodes. \\n- If the current dist value of a node is better than the previous distance indicated by the distance array and the number of stops until now is less than K, we update the distance in the array and push it to the queue. Also, increase the stop count by 1.\\n- We repeat the above three steps until the queue becomes empty. Note that we do not stop the algorithm from just reaching the destination node as it may give incorrect results.\\n- Return the calculated distance/cost after we reach the required number of stops. If the queue becomes empty and we don\\u2019t encounter the destination node, return \\u2018-1\\u2019 indicating there\\u2019s no path from source to destination.\\n\\n![Screenshot-2023-01-08-144144.webp](https://assets.leetcode.com/users/images/f9a796f2-4b3b-4b36-925e-95be42217e20_1674703906.0808144.webp)\\n\\n\\n# Complexity\\n- Time complexity: O(\\u2223E\\u2223 + \\u2223V\\u2223 log\\u2223E\\u2223)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(nk)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nAnother Approach \\u2B07\\uFE0F\\u2B07\\uFE0F with Python code also( Scroll down to \\ncheck).\\n```\\n# Codes for above Explained Approach :\\n```C++ []\\nclass Solution\\n{\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>> &flights,\\n                       int src, int dst, int K)\\n    {\\n        // Create the adjacency list to depict airports and flights in\\n        // the form of a graph.\\n        vector<pair<int, int>> adj[n];\\n        for (auto it : flights)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n\\n        // Create a queue which stores the node and their distances from the\\n        // source in the form of {stops, {node, dist}} with \\u2018stops\\u2019 indicating \\n        // the no. of nodes between src and current node.\\n        queue<pair<int, pair<int, int>>> q;\\n        \\n        q.push({0, {src, 0}});\\n\\n        // Distance array to store the updated distances from the source.\\n        vector<int> dist(n, 1e9);\\n        dist[src] = 0;\\n\\n        // Iterate through the graph using a queue like in Dijkstra with \\n        // popping out the element with min stops first.\\n        while (!q.empty())\\n        {\\n            auto it = q.front();\\n            q.pop();\\n            int stops = it.first;\\n            int node = it.second.first;\\n            int cost = it.second.second;\\n\\n            // We stop the process as soon as the limit for the stops reaches.\\n            if (stops > K)\\n                continue;\\n            for (auto iter : adj[node])\\n            {\\n                int adjNode = iter.first;\\n                int edW = iter.second;\\n\\n                // We only update the queue if the new calculated dist is\\n                // less than the prev and the stops are also within limits.\\n                if (cost + edW < dist[adjNode] && stops <= K)\\n                {\\n                    dist[adjNode] = cost + edW;\\n                    q.push({stops + 1, {adjNode, cost + edW}});\\n                }\\n            }\\n        }\\n        // If the destination node is unreachable return \\u2018-1\\u2019\\n        // else return the calculated dist from src to dst.\\n        if (dist[dst] == 1e9)\\n            return -1;\\n        return dist[dst];\\n    }\\n};\\n```\\n```Java []\\nclass Pair{\\n    int first;\\n    int second;\\n    public Pair(int first,int second){\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\nclass Tuple {\\n    int first, second, third; \\n    Tuple(int first, int second, int third) {\\n        this.first = first; \\n        this.second = second;\\n        this.third = third; \\n    }\\n}\\nclass Solution {\\n    public int findCheapestPrice(int n,int flights[][],int src,int dst,int K) {\\n\\n        // Create the adjacency list to depict airports and flights in\\n        // the form of a graph.\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>(); \\n        for(int i = 0;i<n;i++) {\\n            adj.add(new ArrayList<>()); \\n        }\\n        int m = flights.length; \\n        for(int i = 0;i<m;i++) {\\n            adj.get(flights[i][0]).add(new Pair(flights[i][1], flights[i][2])); \\n        }\\n        \\n        // Create a queue which stores the node and their distances from the\\n        // source in the form of {stops, {node, dist}} with \\u2018stops\\u2019 indicating \\n        // the no. of nodes between src and current node.\\n        Queue<Tuple> q = new LinkedList<>(); \\n        \\n        q.add(new Tuple(0, src, 0));\\n\\n        // Distance array to store the updated distances from the source. \\n        int[] dist = new int[n]; \\n        for(int i = 0;i<n;i++) {\\n            dist[i] = (int)(1e9); \\n        }\\n        dist[src] = 0; \\n\\n        // Iterate through the graph using a queue like in Dijkstra with \\n        // popping out the element with min stops first.\\n        while(!q.isEmpty()) {\\n            Tuple it = q.peek(); \\n            q.remove(); \\n            int stops = it.first; \\n            int node = it.second; \\n            int cost = it.third; \\n            \\n            // We stop the process as soon as the limit for the stops reaches.\\n            if(stops > K) continue; \\n            for(Pair iter: adj.get(node)) {\\n                int adjNode = iter.first; \\n                int edW = iter.second; \\n                \\n                // We only update the queue if the new calculated dist is\\n                // less than the prev and the stops are also within limits.\\n                if (cost + edW < dist[adjNode] && stops <= K) {\\n                    dist[adjNode] = cost + edW; \\n                    q.add(new Tuple(stops + 1, adjNode, cost + edW)); \\n                }\\n            }\\n        }\\n        // If the destination node is unreachable return \\u2018-1\\u2019\\n        // else return the calculated dist from src to dst.\\n        if(dist[dst] == (int)(1e9)) return -1; \\n        return dist[dst]; \\n    }\\n}\\n```\\n\\n\\n# Another Approach using Priority Queue :\\n```C++ []\\nclass Solution {\\n public:\\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,\\n                        int k) {\\n    vector<vector<pair<int, int>>> graph(n);\\n    using T = tuple<int, int, int>;  // (d, u, stops)\\n    priority_queue<T, vector<T>, greater<>> minHeap;\\n    vector<vector<int>> dist(n, vector<int>(k + 2, INT_MAX));\\n\\n    minHeap.emplace(0, src, k + 1);  // Start with node src with d == 0\\n    dist[src][k + 1] = 0;\\n\\n    for (const vector<int>& f : flights) {\\n      const int u = f[0];\\n      const int v = f[1];\\n      const int w = f[2];\\n      graph[u].emplace_back(v, w);\\n    }\\n\\n    while (!minHeap.empty()) {\\n      const auto [d, u, stops] = minHeap.top();\\n      minHeap.pop();\\n      if (u == dst)\\n        return d;\\n      if (stops > 0)\\n        for (const auto& [v, w] : graph[u]) {\\n          const int newDist = d + w;\\n          if (newDist < dist[v][stops - 1]) {\\n            dist[v][stops - 1] = newDist;\\n            minHeap.emplace(newDist, v, stops - 1);\\n          }\\n        }\\n    }\\n\\n    return -1;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n    List<Pair<Integer, Integer>>[] graph = new List[n];\\n    // (d, u, stops)\\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    int[][] dist = new int[n][k + 2];\\n    Arrays.stream(dist).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\\n\\n    for (int i = 0; i < n; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int[] f : flights) {\\n      final int u = f[0];\\n      final int v = f[1];\\n      final int w = f[2];\\n      graph[u].add(new Pair<>(v, w));\\n    }\\n\\n    minHeap.offer(new int[] {0, src, k + 1}); // Start with node src with d == 0\\n    dist[src][k + 1] = 0;\\n\\n    while (!minHeap.isEmpty()) {\\n      final int d = minHeap.peek()[0];\\n      final int u = minHeap.peek()[1];\\n      final int stops = minHeap.poll()[2];\\n      if (u == dst)\\n        return d;\\n      if (stops > 0)\\n        for (Pair<Integer, Integer> pair : graph[u]) {\\n          final int v = pair.getKey();\\n          final int w = pair.getValue();\\n          final int newDist = d + w;\\n          if (newDist < dist[v][stops - 1]) {\\n            dist[v][stops - 1] = newDist;\\n            minHeap.offer(new int[] {d + w, v, stops - 1});\\n          }\\n        }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n    graph = [[] for _ in range(n)]\\n    minHeap = [(0, src, k + 1)]  # (d, u, stops)\\n    dist = [[math.inf] * (k + 2) for _ in range(n)]\\n\\n    for u, v, w in flights:\\n      graph[u].append((v, w))\\n\\n    while minHeap:\\n      d, u, stops = heapq.heappop(minHeap)\\n      if u == dst:\\n        return d\\n      if stops > 0:\\n        for v, w in graph[u]:\\n          newDist = d + w\\n          if newDist < dist[v][stops - 1]:\\n            dist[v][stops - 1] = newDist\\n            heapq.heappush(minHeap, (newDist, v, stops - 1))\\n\\n    return -1\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/85caab22-23a7-4187-8f6a-b4725bfd78ac_1674703985.897158.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nAnother Approach \\u2B07\\uFE0F\\u2B07\\uFE0F with Python code also( Scroll down to \\ncheck).\\n```\n```C++ []\\nclass Solution\\n{\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>> &flights,\\n                       int src, int dst, int K)\\n    {\\n        // Create the adjacency list to depict airports and flights in\\n        // the form of a graph.\\n        vector<pair<int, int>> adj[n];\\n        for (auto it : flights)\\n        {\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n\\n        // Create a queue which stores the node and their distances from the\\n        // source in the form of {stops, {node, dist}} with \\u2018stops\\u2019 indicating \\n        // the no. of nodes between src and current node.\\n        queue<pair<int, pair<int, int>>> q;\\n        \\n        q.push({0, {src, 0}});\\n\\n        // Distance array to store the updated distances from the source.\\n        vector<int> dist(n, 1e9);\\n        dist[src] = 0;\\n\\n        // Iterate through the graph using a queue like in Dijkstra with \\n        // popping out the element with min stops first.\\n        while (!q.empty())\\n        {\\n            auto it = q.front();\\n            q.pop();\\n            int stops = it.first;\\n            int node = it.second.first;\\n            int cost = it.second.second;\\n\\n            // We stop the process as soon as the limit for the stops reaches.\\n            if (stops > K)\\n                continue;\\n            for (auto iter : adj[node])\\n            {\\n                int adjNode = iter.first;\\n                int edW = iter.second;\\n\\n                // We only update the queue if the new calculated dist is\\n                // less than the prev and the stops are also within limits.\\n                if (cost + edW < dist[adjNode] && stops <= K)\\n                {\\n                    dist[adjNode] = cost + edW;\\n                    q.push({stops + 1, {adjNode, cost + edW}});\\n                }\\n            }\\n        }\\n        // If the destination node is unreachable return \\u2018-1\\u2019\\n        // else return the calculated dist from src to dst.\\n        if (dist[dst] == 1e9)\\n            return -1;\\n        return dist[dst];\\n    }\\n};\\n```\n```Java []\\nclass Pair{\\n    int first;\\n    int second;\\n    public Pair(int first,int second){\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\nclass Tuple {\\n    int first, second, third; \\n    Tuple(int first, int second, int third) {\\n        this.first = first; \\n        this.second = second;\\n        this.third = third; \\n    }\\n}\\nclass Solution {\\n    public int findCheapestPrice(int n,int flights[][],int src,int dst,int K) {\\n\\n        // Create the adjacency list to depict airports and flights in\\n        // the form of a graph.\\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>(); \\n        for(int i = 0;i<n;i++) {\\n            adj.add(new ArrayList<>()); \\n        }\\n        int m = flights.length; \\n        for(int i = 0;i<m;i++) {\\n            adj.get(flights[i][0]).add(new Pair(flights[i][1], flights[i][2])); \\n        }\\n        \\n        // Create a queue which stores the node and their distances from the\\n        // source in the form of {stops, {node, dist}} with \\u2018stops\\u2019 indicating \\n        // the no. of nodes between src and current node.\\n        Queue<Tuple> q = new LinkedList<>(); \\n        \\n        q.add(new Tuple(0, src, 0));\\n\\n        // Distance array to store the updated distances from the source. \\n        int[] dist = new int[n]; \\n        for(int i = 0;i<n;i++) {\\n            dist[i] = (int)(1e9); \\n        }\\n        dist[src] = 0; \\n\\n        // Iterate through the graph using a queue like in Dijkstra with \\n        // popping out the element with min stops first.\\n        while(!q.isEmpty()) {\\n            Tuple it = q.peek(); \\n            q.remove(); \\n            int stops = it.first; \\n            int node = it.second; \\n            int cost = it.third; \\n            \\n            // We stop the process as soon as the limit for the stops reaches.\\n            if(stops > K) continue; \\n            for(Pair iter: adj.get(node)) {\\n                int adjNode = iter.first; \\n                int edW = iter.second; \\n                \\n                // We only update the queue if the new calculated dist is\\n                // less than the prev and the stops are also within limits.\\n                if (cost + edW < dist[adjNode] && stops <= K) {\\n                    dist[adjNode] = cost + edW; \\n                    q.add(new Tuple(stops + 1, adjNode, cost + edW)); \\n                }\\n            }\\n        }\\n        // If the destination node is unreachable return \\u2018-1\\u2019\\n        // else return the calculated dist from src to dst.\\n        if(dist[dst] == (int)(1e9)) return -1; \\n        return dist[dst]; \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst,\\n                        int k) {\\n    vector<vector<pair<int, int>>> graph(n);\\n    using T = tuple<int, int, int>;  // (d, u, stops)\\n    priority_queue<T, vector<T>, greater<>> minHeap;\\n    vector<vector<int>> dist(n, vector<int>(k + 2, INT_MAX));\\n\\n    minHeap.emplace(0, src, k + 1);  // Start with node src with d == 0\\n    dist[src][k + 1] = 0;\\n\\n    for (const vector<int>& f : flights) {\\n      const int u = f[0];\\n      const int v = f[1];\\n      const int w = f[2];\\n      graph[u].emplace_back(v, w);\\n    }\\n\\n    while (!minHeap.empty()) {\\n      const auto [d, u, stops] = minHeap.top();\\n      minHeap.pop();\\n      if (u == dst)\\n        return d;\\n      if (stops > 0)\\n        for (const auto& [v, w] : graph[u]) {\\n          const int newDist = d + w;\\n          if (newDist < dist[v][stops - 1]) {\\n            dist[v][stops - 1] = newDist;\\n            minHeap.emplace(newDist, v, stops - 1);\\n          }\\n        }\\n    }\\n\\n    return -1;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n    List<Pair<Integer, Integer>>[] graph = new List[n];\\n    // (d, u, stops)\\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n    int[][] dist = new int[n][k + 2];\\n    Arrays.stream(dist).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\\n\\n    for (int i = 0; i < n; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int[] f : flights) {\\n      final int u = f[0];\\n      final int v = f[1];\\n      final int w = f[2];\\n      graph[u].add(new Pair<>(v, w));\\n    }\\n\\n    minHeap.offer(new int[] {0, src, k + 1}); // Start with node src with d == 0\\n    dist[src][k + 1] = 0;\\n\\n    while (!minHeap.isEmpty()) {\\n      final int d = minHeap.peek()[0];\\n      final int u = minHeap.peek()[1];\\n      final int stops = minHeap.poll()[2];\\n      if (u == dst)\\n        return d;\\n      if (stops > 0)\\n        for (Pair<Integer, Integer> pair : graph[u]) {\\n          final int v = pair.getKey();\\n          final int w = pair.getValue();\\n          final int newDist = d + w;\\n          if (newDist < dist[v][stops - 1]) {\\n            dist[v][stops - 1] = newDist;\\n            minHeap.offer(new int[] {d + w, v, stops - 1});\\n          }\\n        }\\n    }\\n\\n    return -1;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n    graph = [[] for _ in range(n)]\\n    minHeap = [(0, src, k + 1)]  # (d, u, stops)\\n    dist = [[math.inf] * (k + 2) for _ in range(n)]\\n\\n    for u, v, w in flights:\\n      graph[u].append((v, w))\\n\\n    while minHeap:\\n      d, u, stops = heapq.heappop(minHeap)\\n      if u == dst:\\n        return d\\n      if stops > 0:\\n        for v, w in graph[u]:\\n          newDist = d + w\\n          if newDist < dist[v][stops - 1]:\\n            dist[v][stops - 1] = newDist\\n            heapq.heappush(minHeap, (newDist, v, stops - 1))\\n\\n    return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099854,
                "title": "dynamic-programming-solution-with-video",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCredit to @gcl272633743 \\n\\n\\n![Screenshot 2023-01-26 at 6.55.48 AM.png](https://assets.leetcode.com/users/images/f9e5e5c9-161e-47f6-ab9f-44c5eb9bc735_1674696379.0685956.png)\\n\\nWe will have a table where columns are cities and row indicates steps(not stops) Any row, column indicates cost to travel from src to this city in k steps. If its infinity its not possible.\\n\\nInitially all are infinity, we mark the source column to 0, as the cost required to travel from src to src is 0 with any steps.\\n\\nNow we go to each step, i.e say step 1 (row 1).\\n\\nWe check all the flights and if the source is already visited, i.e(the previous row is not infinity) we change this cell\\'s value.\\n\\nex [0,1,100] city 0 is visisted with 0 steps, hence dp[1][1] = 100;\\n[1,2,100] no change since 1 is not visited in previous steps.\\n\\nSame goes for 2 steps\\neg [1,2,100]-- is 1 already visited, yes so dp[2][2] = 100+100\\n[1,3,600] -- is 1 already visited, yes dp[2][3] = 100+600 =700\\n\\n\\nhttps://youtu.be/5V_72xBSh8E\\n\\n\\nFor More read: https://medium.com/swlh/graph-dynamic-programming-heap-cheapest-flights-within-k-stops-e622ce956479\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/e81a44ac-2a0a-4268-8033-63780c428560_1674698166.6324708.webp)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[][] dp = new int[k+2][n];\\n        for(int i=0; i<=k+1; i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);    \\n        }\\n        //fly from src to scr cost 0\\n        for(int i=0; i<=k+1; i++){\\n            dp[i][src] = 0;    \\n        }\\n        \\n        for(int i=1; i<=k+1; i++){\\n            for(int[] f: flights){\\n                if(dp[i-1][f[0]]!=Integer.MAX_VALUE){\\n                    dp[i][f[1]] = Math.min(dp[i][f[1]],dp[i-1][f[0]]+f[2]);\\n                }\\n            }\\n        }\\n        return dp[k+1][dst] == Integer.MAX_VALUE ? -1 : dp[k+1][dst];\\n    }\\n}\\n```\\n\\n```\\ndef findCheapestPrice(self, n, flights, src, dst, k):\\n        dp = [[sys.maxsize for _ in range(n)] for _ in range(k+2)]\\n        for i in range(k+2):\\n            dp[i][src] = 0\\n        for i in range(1, k+2):\\n            for f in flights:\\n                if dp[i-1][f[0]] != sys.maxsize:\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i-1][f[0]] + f[2])\\n        return dp[k+1][dst] if dp[k+1][dst] != sys.maxsize else -1\\n        \\n```\\n\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\\n        for (int i = 0; i <= k + 1; i++) {\\n            dp[i][src] = 0;\\n        }\\n        for (int i = 1; i <= k + 1; i++) {\\n            for (const auto& f : flights) {\\n                if (dp[i - 1][f[0]] != INT_MAX) {\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i - 1][f[0]] + f[2]);\\n                }\\n            }\\n        }\\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[][] dp = new int[k+2][n];\\n        for(int i=0; i<=k+1; i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);    \\n        }\\n        //fly from src to scr cost 0\\n        for(int i=0; i<=k+1; i++){\\n            dp[i][src] = 0;    \\n        }\\n        \\n        for(int i=1; i<=k+1; i++){\\n            for(int[] f: flights){\\n                if(dp[i-1][f[0]]!=Integer.MAX_VALUE){\\n                    dp[i][f[1]] = Math.min(dp[i][f[1]],dp[i-1][f[0]]+f[2]);\\n                }\\n            }\\n        }\\n        return dp[k+1][dst] == Integer.MAX_VALUE ? -1 : dp[k+1][dst];\\n    }\\n}\\n```\n```\\ndef findCheapestPrice(self, n, flights, src, dst, k):\\n        dp = [[sys.maxsize for _ in range(n)] for _ in range(k+2)]\\n        for i in range(k+2):\\n            dp[i][src] = 0\\n        for i in range(1, k+2):\\n            for f in flights:\\n                if dp[i-1][f[0]] != sys.maxsize:\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i-1][f[0]] + f[2])\\n        return dp[k+1][dst] if dp[k+1][dst] != sys.maxsize else -1\\n        \\n```\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\\n        for (int i = 0; i <= k + 1; i++) {\\n            dp[i][src] = 0;\\n        }\\n        for (int i = 1; i <= k + 1; i++) {\\n            for (const auto& f : flights) {\\n                if (dp[i - 1][f[0]] != INT_MAX) {\\n                    dp[i][f[1]] = min(dp[i][f[1]], dp[i - 1][f[0]] + f[2]);\\n                }\\n            }\\n        }\\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163698,
                "title": "easy-java-bellman-ford",
                "content": "```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int INF = 0x3F3F3F3F;\\n        int[] cost = new int[n];\\n        Arrays.fill(cost, INF);\\n        cost[src] = 0;\\n        int ans = cost[dst];\\n        for(int i = k; i >= 0; i--){\\n            int[] cur = new int[n];\\n            Arrays.fill(cur, INF);\\n            for(int[] flight : flights){\\n                cur[flight[1]] = Math.min(cur[flight[1]], cost[flight[0]] + flight[2]);\\n            }\\n            cost = cur;\\n            ans = Math.min(ans, cost[dst]);\\n        }\\n        return ans == INF ? -1 : ans;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int INF = 0x3F3F3F3F;\\n        int[] cost = new int[n];\\n        Arrays.fill(cost, INF);\\n        cost[src] = 0;\\n        int ans = cost[dst];\\n        for(int i = k; i >= 0; i--){\\n            int[] cur = new int[n];\\n            Arrays.fill(cur, INF);\\n            for(int[] flight : flights){\\n                cur[flight[1]] = Math.min(cur[flight[1]], cost[flight[0]] + flight[2]);\\n            }\\n            cost = cur;\\n            ans = Math.min(ans, cost[dst]);\\n        }\\n        return ans == INF ? -1 : ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099967,
                "title": "fast-c-solution",
                "content": "# Solution Code\\n\\n``` C++ []\\n\\nclass Solution { // similar to network delay time.  dijkstra algo\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        for(auto e: flights) graph[e[0]].push_back({e[1], e[2]});\\n        vector<int> prices(n, -1);\\n        queue<pair<int, int>> q; q.push({src, 0});\\n        ++K;\\n        while(!q.empty()) {\\n            if(!K) break;\\n            int len = q.size();\\n            for(int i = 0; i < len; i++) {\\n                auto cur = q.front(); q.pop();\\n                for(auto e: graph[cur.first]) {\\n                    int price = cur.second + e.second; \\n                    if(prices[e.first] == -1 || price < prices[e.first]) {\\n                        prices[e.first] = price;\\n                        q.push({e.first, price});\\n                    }\\n                }\\n            }\\n            K--;\\n        }\\n        return prices[dst];\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/49b61c2b-e657-488a-902a-01847800509c_1674701698.200033.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\n\\nclass Solution { // similar to network delay time.  dijkstra algo\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        for(auto e: flights) graph[e[0]].push_back({e[1], e[2]});\\n        vector<int> prices(n, -1);\\n        queue<pair<int, int>> q; q.push({src, 0});\\n        ++K;\\n        while(!q.empty()) {\\n            if(!K) break;\\n            int len = q.size();\\n            for(int i = 0; i < len; i++) {\\n                auto cur = q.front(); q.pop();\\n                for(auto e: graph[cur.first]) {\\n                    int price = cur.second + e.second; \\n                    if(prices[e.first] == -1 || price < prices[e.first]) {\\n                        prices[e.first] = price;\\n                        q.push({e.first, price});\\n                    }\\n                }\\n            }\\n            K--;\\n        }\\n        return prices[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115548,
                "title": "c-solution-using-dynamic-programming",
                "content": "ans[i][j] represents that the minimum cost from node src to node i using steps <= j\nThe initial state is ans[src][0] = 0, which means that from src to src there isn't any cost\nAnd ans[dst][K] means the minimum cost from node src to node dst using steps <= K\n\n```\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\n    {\n        const int INF = 1e9;\n        K++;\n        vector<vector<int>> ans(n, vector<int>(K+1));\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j <= K; j++)\n            {\n                ans[i][j] = INF;\n            }\n        }\n        ans[src][0] = 0;\n        for(int i = 1; i <= K; i++)\n        {\n            for(int j = 0; j < n; j++)   //To update ans[j][i](using i steps), we copy ans[j][i-1] first\n                ans[j][i] = ans[j][i-1];\n            for(const vector<int>& f: flights)\n            {\n                ans[f[1]][i] = min(ans[f[1]][i], ans[f[0]][i-1] + f[2]);\n            }\n        }\n        if(ans[dst][K] == INF) return -1;\n        return ans[dst][K];\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\n    {\n        const int INF = 1e9;\n        K++;\n        vector<vector<int>> ans(n, vector<int>(K+1));\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j <= K; j++)\n            {\n                ans[i][j] = INF;\n            }\n        }\n        ans[src][0] = 0;\n        for(int i = 1; i <= K; i++)\n        {\n            for(int j = 0; j < n; j++)   //To update ans[j][i](using i steps), we copy ans[j][i-1] first\n                ans[j][i] = ans[j][i-1];\n            for(const vector<int>& f: flights)\n            {\n                ans[f[1]][i] = min(ans[f[1]][i], ans[f[0]][i-1] + f[2]);\n            }\n        }\n        if(ans[dst][K] == INF) return -1;\n        return ans[dst][K];\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373237,
                "title": "java-solution-using-dijkstra-and-bellman-ford-with-explanation",
                "content": "**Dijkstra**\\nInstead of visited array we will use a stop array where stop[i] will store the min number of stops needed to reach i.\\nSo, in future if any other path having greater stops then the current will occur we will ignore that.\\n\\n**Why we can\\'t use boolean visited array?** As if we use visited array, and there can be a case where the smallest path according to Dijkstra algo can have more stops, and in this path we may mark one node visited which can contribute in other path and results in answer will be igonred due to visited.\\n```\\nclass Solution {\\n    class Pair{\\n        int v;\\n        int wt;\\n        int dist;\\n        \\n        Pair(int v, int wt, int dist){\\n            this.v = v;\\n            this.wt = wt;\\n            this.dist = dist;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : flights){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            \\n            graph.get(u).add(new Pair(v, wt, 0));\\n            \\n        }\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);\\n        pq.add(new Pair(src, 0, -1));\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        \\n        while(pq.size() > 0){\\n            Pair p = pq.remove();\\n            if(p.dist > k || stop[p.v] < p.dist)continue;\\n            \\n            stop[p.v] = p.dist;\\n            if(p.v == dst)return p.wt;\\n\\n            for(Pair nbr : graph.get(p.v)){\\n                pq.add(new Pair(nbr.v, p.wt + nbr.wt, p.dist + 1));\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Bellman ford**\\nAs in bellman ford, in the i\\'th iteration we would surely have found the best path of i distance, but in some cases i\\'th iteration can result in answer of (i + 1, i + 2 or n) length path, this is because of arrangment of edges.\\nSo, if we use the prev iteration array for checking the weight is smaller or not and updating in current array, we can easily overcome this situation.\\n\\n```\\n\\nclass Solution{\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[] prev = new int[n];\\n        Arrays.fill(prev, Integer.MAX_VALUE);\\n        prev[src] = 0;\\n        \\n        for(int i = 0 ; i <= k; i++){\\n            int[] curr = new int[n];\\n            for(int j = 0; j < n; j++)curr[j] = prev[j];\\n            \\n            for(int[] edge : flights){\\n                int u = edge[0];\\n                int v = edge[1];\\n                int wt = edge[2];\\n                \\n                if(prev[u] != Integer.MAX_VALUE && prev[u] + wt < curr[v]){\\n                    curr[v] = prev[u] + wt;\\n                }\\n            }\\n            for(int j = 0; j < n; j++)prev[j] = curr[j];\\n        }\\n        \\n        return prev[dst] == Integer.MAX_VALUE ? -1 : prev[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int v;\\n        int wt;\\n        int dist;\\n        \\n        Pair(int v, int wt, int dist){\\n            this.v = v;\\n            this.wt = wt;\\n            this.dist = dist;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<Pair>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : flights){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            \\n            graph.get(u).add(new Pair(v, wt, 0));\\n            \\n        }\\n        \\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);\\n        pq.add(new Pair(src, 0, -1));\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        \\n        while(pq.size() > 0){\\n            Pair p = pq.remove();\\n            if(p.dist > k || stop[p.v] < p.dist)continue;\\n            \\n            stop[p.v] = p.dist;\\n            if(p.v == dst)return p.wt;\\n\\n            for(Pair nbr : graph.get(p.v)){\\n                pq.add(new Pair(nbr.v, p.wt + nbr.wt, p.dist + 1));\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n\\nclass Solution{\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[] prev = new int[n];\\n        Arrays.fill(prev, Integer.MAX_VALUE);\\n        prev[src] = 0;\\n        \\n        for(int i = 0 ; i <= k; i++){\\n            int[] curr = new int[n];\\n            for(int j = 0; j < n; j++)curr[j] = prev[j];\\n            \\n            for(int[] edge : flights){\\n                int u = edge[0];\\n                int v = edge[1];\\n                int wt = edge[2];\\n                \\n                if(prev[u] != Integer.MAX_VALUE && prev[u] + wt < curr[v]){\\n                    curr[v] = prev[u] + wt;\\n                }\\n            }\\n            for(int j = 0; j < n; j++)prev[j] = curr[j];\\n        }\\n        \\n        return prev[dst] == Integer.MAX_VALUE ? -1 : prev[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499910,
                "title": "java-dijkstra-with-k-v-nodes-7ms-as-of-sep-2021",
                "content": "For shortest path finding algorhtms, I tend to master one sword and let it kill any monster. This question right here, is designed to trick people who naively wants to kill it using brain dead Dijkstra implementation or simple modifications. No not today. \\n\\nBut the good news is, you can still use Dijkstra algorithm to solve this question, with enough crafting in the way you define graph nodes. In this question, you have to consider each node as a joint state of k steps, and arriving at v node, thus being [k, v] and you would still want to expand best paths provided by your priority queue, just by sorting path cost of those [k,v] states. The only part that needs special care, is when you are expanding the best path when popped out of the p-queue:\\n\\n- **We want to expand a path, when the steps are smaller than current best path\\'s steps**, cause it might leads to final solution in case the best path exceeds step limit.\\n- **We of course still wants to expand a path when we found smaller cost.**\\n- Therefore, we simply do this:\\n\\t- You would need a 2d array of int[][] minCost = new int[k][n] which records best path from source to n node with length k. \\n\\t- For paths with k steps (k edges), we expand when we found a better path with exactly k steps (compare against defined minCost). \\n\\nWe can show that with this definiation of nodes, \\n- We still have path expansion consistency, meaning all path expanded by a given iteration must be larger than current path (dequeued node), thus the dequeuing sequence from priority queue best be non decreasing.  \\n\\t- For more about why consistency matters and Dijkstra should never process a node twice, see consistency check in A* algorithm https://en.wikipedia.org/wiki/A*_search_algorithm\\n\\n- This guarantees each  [k, v] state is only dequeued once, cause future dequeues always have larger edge cost, and will NEVER update mincost[k][v] again.\\n- This net us a overall complexity roughly O((kV + kE) * logX), where X is the max number of elements that can appear in the p-queue. \\n\\t- In some heap implementations, where one can modify priority value, this X = kV (number of nodes) \\n\\t- But for default p-queue implementation in Java, where you cannot modify the priority value, you must enqueue again with better values and record min values in the minCost array; when you found a node with larger values than minCost, you know this guy is outdated by a better value, you simply ditch it. \\n\\t- What is the max number of nodes that can be enqueued? It would be the number of best path expansions, which happens kE times and the queue volume is bounded by kE.\\n\\t- Thus, **time complexity for my below implementation is O((kV + kE) * log(kE)) ~= N^3 log N**\\n\\t- This is essentialy even worse than default Bellman-ford algorithm, which rums at O(NE) = O(N^3) and is much easier to implement under stress. To be honenst, this question + test case is designed for Bellman-ford, if you don\\'t know it, you will have a hard time. I dislike this.\\n\\t\\nDijkstra with kV node modification:\\n```\\nclass Solution {\\n    // modified Dijkstra.\\n    public int findCheapestPrice(int n, int[][] flights, \\n                                 int src, int dst, int k) {\\n        // Build graph.\\n        // node i -> list of (node j, cost)\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        \\n        for (int[] f : flights) {\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n        }\\n        \\n        // Queue node is int[] -> loc, cost, stops;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(10,\\n                        (o1, o2) -> o1[1] - o2[1]);\\n        pq.offer(new int[]{src, 0, 0});\\n        \\n        // Min cost tracker.\\n        // min cost for k stop arriving at n node.\\n        int[][] minCost = new int[k + 2][n];\\n        int inf = 1000000;\\n        for (int i = 0; i <= k + 1; i++) {\\n            for (int j = 0; j < n; j++) {\\n                minCost[i][j] = inf;\\n            }\\n        } \\n        \\n        minCost[0][src] = 0;\\n        \\n        // Best first search.\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            \\n            int curNode = cur[0];\\n            int curCost = cur[1];\\n            int curStops = cur[2];\\n            \\n            if (curNode == dst) return curCost;\\n            \\n            // No more stops possible, don\\'t expand.\\n            if (curStops == k + 1) continue;\\n            \\n            // outdated values.\\n            if (curCost > minCost[curStops][cur[0]]) continue;\\n            \\n            // Expand cur best path. \\n            for (int[] e : graph.get(curNode)) {\\n                if (curCost + e[1] < minCost[curStops + 1][e[0]]) {\\n                    // cur -> e[0];\\n                    minCost[curStops + 1][e[0]] = curCost + e[1];\\n                    pq.offer(new int[]{e[0], \\n                                       minCost[curStops + 1][e[0]], \\n                                       curStops + 1});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nBellman-ford algorithm, finding best path within k steps:\\nJust run the algo k times (or k+1, figure it out by considering a easy case).\\n```\\nclass Solution {\\n    // Bellman ford, natural strategy for best path within\\n    // X range.\\n    // 1 step -> max path len 1 -> 0 stop\\n    // k + 1 step -> path len k+1 -> k stop \\n    public int findCheapestPrice(int n, int[][] flights, \\n                                 int src, int dst, int k) {\\n        int inf = 1000000;\\n        int[] minCost = new int[n];\\n        for (int i = 0; i < n; i++) minCost[i] = inf;\\n        minCost[src] = 0;\\n        \\n        // k + 1 iterations of bellman ford best path expansion.\\n        // i-th iteration results in best path len <= i;\\n        // i+1 th iteration only expands best path len == i, \\n        // cause smaller len best path are expanded in prev iterations.\\n        // So, i+1 iteration has best path len <= i+1;\\n        // So, expanding k+1 rounds, give best path len <= k+1\\n        // Len k + 1 equivalent to k stops.\\n        for (int i = 0; i < k + 1; i++) {\\n            int[] updatedCost = minCost.clone();\\n            for (int[] e : flights) {\\n                // e0 -> e1, cost e2.\\n                // e0 cant be reached.\\n                if (minCost[e[0]] == inf) continue;\\n                \\n                if (minCost[e[0]] + e[2] < updatedCost[e[1]]) {\\n                    updatedCost[e[1]] = minCost[e[0]] + e[2];\\n                }\\n            }\\n            \\n            minCost = updatedCost;\\n        }\\n        \\n        return minCost[dst] == inf ? -1 : minCost[dst];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // modified Dijkstra.\\n    public int findCheapestPrice(int n, int[][] flights, \\n                                 int src, int dst, int k) {\\n        // Build graph.\\n        // node i -> list of (node j, cost)\\n        List<List<int[]>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        \\n        for (int[] f : flights) {\\n            graph.get(f[0]).add(new int[]{f[1], f[2]});\\n        }\\n        \\n        // Queue node is int[] -> loc, cost, stops;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(10,\\n                        (o1, o2) -> o1[1] - o2[1]);\\n        pq.offer(new int[]{src, 0, 0});\\n        \\n        // Min cost tracker.\\n        // min cost for k stop arriving at n node.\\n        int[][] minCost = new int[k + 2][n];\\n        int inf = 1000000;\\n        for (int i = 0; i <= k + 1; i++) {\\n            for (int j = 0; j < n; j++) {\\n                minCost[i][j] = inf;\\n            }\\n        } \\n        \\n        minCost[0][src] = 0;\\n        \\n        // Best first search.\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            \\n            int curNode = cur[0];\\n            int curCost = cur[1];\\n            int curStops = cur[2];\\n            \\n            if (curNode == dst) return curCost;\\n            \\n            // No more stops possible, don\\'t expand.\\n            if (curStops == k + 1) continue;\\n            \\n            // outdated values.\\n            if (curCost > minCost[curStops][cur[0]]) continue;\\n            \\n            // Expand cur best path. \\n            for (int[] e : graph.get(curNode)) {\\n                if (curCost + e[1] < minCost[curStops + 1][e[0]]) {\\n                    // cur -> e[0];\\n                    minCost[curStops + 1][e[0]] = curCost + e[1];\\n                    pq.offer(new int[]{e[0], \\n                                       minCost[curStops + 1][e[0]], \\n                                       curStops + 1});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Bellman ford, natural strategy for best path within\\n    // X range.\\n    // 1 step -> max path len 1 -> 0 stop\\n    // k + 1 step -> path len k+1 -> k stop \\n    public int findCheapestPrice(int n, int[][] flights, \\n                                 int src, int dst, int k) {\\n        int inf = 1000000;\\n        int[] minCost = new int[n];\\n        for (int i = 0; i < n; i++) minCost[i] = inf;\\n        minCost[src] = 0;\\n        \\n        // k + 1 iterations of bellman ford best path expansion.\\n        // i-th iteration results in best path len <= i;\\n        // i+1 th iteration only expands best path len == i, \\n        // cause smaller len best path are expanded in prev iterations.\\n        // So, i+1 iteration has best path len <= i+1;\\n        // So, expanding k+1 rounds, give best path len <= k+1\\n        // Len k + 1 equivalent to k stops.\\n        for (int i = 0; i < k + 1; i++) {\\n            int[] updatedCost = minCost.clone();\\n            for (int[] e : flights) {\\n                // e0 -> e1, cost e2.\\n                // e0 cant be reached.\\n                if (minCost[e[0]] == inf) continue;\\n                \\n                if (minCost[e[0]] + e[2] < updatedCost[e[1]]) {\\n                    updatedCost[e[1]] = minCost[e[0]] + e[2];\\n                }\\n            }\\n            \\n            minCost = updatedCost;\\n        }\\n        \\n        return minCost[dst] == inf ? -1 : minCost[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686939,
                "title": "python-by-dp-with-bellman-ford-algorithm-w-comment",
                "content": "Python sol by DP with Bellman-Ford algorithm\\n\\n---\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        \\n        price_table = [ float(\\'inf\\') for _ in range(n) ]\\n        \\n        # price of source must be 0\\n        price_table[ src ] = 0\\n\\t\\t\\n        # initialization with 0 transfer\\n        for source, destination, ticket_price in flights:\\n            if source == src:\\n                price_table[destination] = ticket_price\\n        \\n        \\n        # tranfer k times to update price table\\n        for trasfer in range(0, K):\\n            \\n            current_price = [*price_table]\\n            \\n            for source, destination, ticket_price in flights:\\n                \\n                current_price[destination] = min(current_price[destination], price_table[source] + ticket_price )\\n            \\n            # update current price back to price table    \\n            price_table = current_price\\n        \\n        \\n        if price_table[dst] == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return price_table[dst]\\n        \\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Bellman Ford algorithm](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        \\n        price_table = [ float(\\'inf\\') for _ in range(n) ]\\n        \\n        # price of source must be 0\\n        price_table[ src ] = 0\\n\\t\\t\\n        # initialization with 0 transfer\\n        for source, destination, ticket_price in flights:\\n            if source == src:\\n                price_table[destination] = ticket_price\\n        \\n        \\n        # tranfer k times to update price table\\n        for trasfer in range(0, K):\\n            \\n            current_price = [*price_table]\\n            \\n            for source, destination, ticket_price in flights:\\n                \\n                current_price[destination] = min(current_price[destination], price_table[source] + ticket_price )\\n            \\n            # update current price back to price table    \\n            price_table = current_price\\n        \\n        \\n        if price_table[dst] == float(\\'inf\\'):\\n            return -1\\n        else:\\n            return price_table[dst]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099830,
                "title": "leetcode-the-hard-way-explained-line-by-line-3-approaches",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=za7r4Chb3EA&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=26) if you are interested.\\n\\nThere\\'re still other ways to do it - such as modified Dijkstra or BFS. Will include someday when I\\'m free.\\n\\n**Approach 1: DP**\\n\\n```cpp\\n// TC: O(F * K)\\n// SC: O(N * K) \\n// where \\n// - F is the number of flights\\n// - K is the number of stops\\n// - N is the number of cities and K is the number of stops\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // dp[i][j]: min cost to reach city j using at most i edges from src\\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\\n        // base case\\n        for (int i = 0; i <= k + 1; i++) dp[i][src] = 0;\\n        // iterate each stop\\n        for (int i = 1; i <= k + 1; i++) {\\n            // iterate each flight\\n            for (auto f : flights) {\\n                int from = f[0], to = f[1], cost = f[2];\\n                // ensure city `from` is reachable \\n                if (dp[i - 1][from] != INT_MAX) {\\n                    // from + cost -> to\\n                    dp[i][to] = min(dp[i][to], dp[i - 1][from] + cost);   \\n                }\\n            }\\n        }\\n        // if dp[k + 1][dst] == INT_MAX, it means it is unreachable\\n        // else return the cost\\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\\n    }\\n};\\n```\\n\\n**Approach 2: Bellman Ford**\\n\\n```cpp\\n// TC: O(F * K + N * K)\\n// SC: O(F) \\n// where \\n// - F is the number of flights\\n// - K is the number of stops\\n// - N is the number of cities and K is the number of stops\\nclass Solution {\\npublic:\\n    // https://leetcodethehardway.com/tutorials/graph-theory/bellman-ford-algorithm\\n    template<typename T_a3, typename T_vector>\\n    void bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\\n        dist[src] = 0;\\n        for (int i = 0; i <= mx_edges; i++) {\\n            T_vector ndist = dist;\\n            for (auto x : g) {\\n                auto [from, to, cost] = x;\\n                ndist[to] = min(ndist[to], dist[from] + cost);\\n            }\\n            dist = ndist;\\n        }\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // we can directly use bellman ford template here (prerequisite: you need to understand bellman ford algo)\\n        // bellman ford algo is used to find the shortest paths from source node to other nodes in a weighted graph\\n        vector<array<int, 3>> g;\\n        // initially cost with a large value\\n        // cost[i] means the cheapest price from src to city i\\n        vector<int> cost(n, 1e9);\\n        // reconstruct a bit - {src, dst, cost}\\n        for (auto f : flights) g.push_back({f[0], f[1], f[2]});\\n        bellman_ford(g, cost, src, k);\\n        // if cost[dst] == 1e9, it means it is unreachable\\n        // else we can show cost[dst]\\n        return cost[dst] == 1e9 ? -1 : cost[dst];\\n    }\\n};\\n```\\n\\n**Approach 3: Dijkstra\\'s Algorithm**\\n\\nWe can use Dijkstra\\'s Algorithm to find the shortest path. Dijkstra\\'s Algorithm uses a heap for weights of distance we travelled, meaning with a min heap we can always check the path that is currently the shortest. One key difference though is instead of a visited set, we will use a hash map, as we might visit a city early, but run out of stops and a set would prevent us from reaching this city again. So to prevent this we can use a hash map that maps cities to stops, and if we reach a city with fewer stops than last time, we can visit this city again.\\n\\nTime Complexity: $$O((F + C)logC)$$ Where $$F$$ is the number of flights, and $$C$$ is the number of cities. Worst case we must take all flights and visit all cities, updating our heap $$logC$$ times at each city.\\n\\nSpace Complexity: $$O(C)$$ Where $$C$$ is the number of cities. We must create an adjacency list, a heap, and a visited dictionary, all of which scale proportionally to the number of cities.\\n\\n```py\\n# written by @ColeB2\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        # create an adjacency list\\n        adj_list = [[] for _ in range(n)]\\n        # adjacenty list will be a list for cities and prices\\n        # we can fly to from a desitination, i, in the list.\\n        for from_i, to_i, price_i in flights:\\n            adj_list[from_i].append((to_i, price_i))\\n        # heap (price, stops, destination)\\n        heap = [(0, 0, src)]\\n        visited = defaultdict(int)\\n\\n        while heap:\\n            # pop off the lowest price destination in our heap.\\n            # Tracking price, # of stops we took, and destination.\\n            price, stops, dest = heapq.heappop(heap)\\n            # if we reached the destination, return the total price.\\n            if dest == dst:\\n                return price\\n            # Track the destination as visited, and stops to reach it.\\n            visited[dest] = stops\\n            # Loop through all potential flights from current destination.\\n            for to_i, price_i in adj_list[dest]:\\n                # stops > k, it means this path doesn\\'t work.\\n                # also if to destination isn\\'t visited, or it is\\n                # visited, but the # of stops < # of stops it took us\\n                # to reach the city the last time:\\n                if stops <= k and (to_i not in visited or stops < visited[to_i]):\\n                    # add that destination to the queue.\\n                    # price, stops, to destination. Where price is the\\n                    # current running price + price to fly there.\\n                    # The stops should be incremented by 1, and\\n                    # the destination is the to_i value.\\n                    heapq.heappush(heap, (price + price_i, stops + 1, to_i))\\n        # process everything but never reach destination, return -1\\n        return -1\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n// TC: O(F * K)\\n// SC: O(N * K) \\n// where \\n// - F is the number of flights\\n// - K is the number of stops\\n// - N is the number of cities and K is the number of stops\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // dp[i][j]: min cost to reach city j using at most i edges from src\\n        vector<vector<int>> dp(k + 2, vector<int>(n, INT_MAX));\\n        // base case\\n        for (int i = 0; i <= k + 1; i++) dp[i][src] = 0;\\n        // iterate each stop\\n        for (int i = 1; i <= k + 1; i++) {\\n            // iterate each flight\\n            for (auto f : flights) {\\n                int from = f[0], to = f[1], cost = f[2];\\n                // ensure city `from` is reachable \\n                if (dp[i - 1][from] != INT_MAX) {\\n                    // from + cost -> to\\n                    dp[i][to] = min(dp[i][to], dp[i - 1][from] + cost);   \\n                }\\n            }\\n        }\\n        // if dp[k + 1][dst] == INT_MAX, it means it is unreachable\\n        // else return the cost\\n        return dp[k + 1][dst] == INT_MAX ? -1 : dp[k + 1][dst];\\n    }\\n};\\n```\n```cpp\\n// TC: O(F * K + N * K)\\n// SC: O(F) \\n// where \\n// - F is the number of flights\\n// - K is the number of stops\\n// - N is the number of cities and K is the number of stops\\nclass Solution {\\npublic:\\n    // https://leetcodethehardway.com/tutorials/graph-theory/bellman-ford-algorithm\\n    template<typename T_a3, typename T_vector>\\n    void bellman_ford(T_a3 &g, T_vector &dist, int src, int mx_edges) {\\n        dist[src] = 0;\\n        for (int i = 0; i <= mx_edges; i++) {\\n            T_vector ndist = dist;\\n            for (auto x : g) {\\n                auto [from, to, cost] = x;\\n                ndist[to] = min(ndist[to], dist[from] + cost);\\n            }\\n            dist = ndist;\\n        }\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // we can directly use bellman ford template here (prerequisite: you need to understand bellman ford algo)\\n        // bellman ford algo is used to find the shortest paths from source node to other nodes in a weighted graph\\n        vector<array<int, 3>> g;\\n        // initially cost with a large value\\n        // cost[i] means the cheapest price from src to city i\\n        vector<int> cost(n, 1e9);\\n        // reconstruct a bit - {src, dst, cost}\\n        for (auto f : flights) g.push_back({f[0], f[1], f[2]});\\n        bellman_ford(g, cost, src, k);\\n        // if cost[dst] == 1e9, it means it is unreachable\\n        // else we can show cost[dst]\\n        return cost[dst] == 1e9 ? -1 : cost[dst];\\n    }\\n};\\n```\n```py\\n# written by @ColeB2\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        # create an adjacency list\\n        adj_list = [[] for _ in range(n)]\\n        # adjacenty list will be a list for cities and prices\\n        # we can fly to from a desitination, i, in the list.\\n        for from_i, to_i, price_i in flights:\\n            adj_list[from_i].append((to_i, price_i))\\n        # heap (price, stops, destination)\\n        heap = [(0, 0, src)]\\n        visited = defaultdict(int)\\n\\n        while heap:\\n            # pop off the lowest price destination in our heap.\\n            # Tracking price, # of stops we took, and destination.\\n            price, stops, dest = heapq.heappop(heap)\\n            # if we reached the destination, return the total price.\\n            if dest == dst:\\n                return price\\n            # Track the destination as visited, and stops to reach it.\\n            visited[dest] = stops\\n            # Loop through all potential flights from current destination.\\n            for to_i, price_i in adj_list[dest]:\\n                # stops > k, it means this path doesn\\'t work.\\n                # also if to destination isn\\'t visited, or it is\\n                # visited, but the # of stops < # of stops it took us\\n                # to reach the city the last time:\\n                if stops <= k and (to_i not in visited or stops < visited[to_i]):\\n                    # add that destination to the queue.\\n                    # price, stops, to destination. Where price is the\\n                    # current running price + price to fly there.\\n                    # The stops should be incremented by 1, and\\n                    # the destination is the to_i value.\\n                    heapq.heappush(heap, (price + price_i, stops + 1, to_i))\\n        # process everything but never reach destination, return -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 115623,
                "title": "10-line-python-dp-solution-o-n-2-k-time-o-n-space",
                "content": "At every iteration compute the min cost to reach every city.\n\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        \"\"\"\n        :type n: int\n        :type flights: List[List[int]]\n        :type src: int\n        :type dst: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        INF=float('inf')\n        mn=[INF]*n\n        mn[src]=0\n        \n        for k in range(K+1):\n            newmn=mn[:]\n            for (a,b, cost) in flights:\n                newmn[b]=min(newmn[b],mn[a]+cost)\n            mn=newmn\n            \n        return mn[dst] if mn[dst]!=INF else -1\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        \"\"\"\n        :type n: int\n        :type flights: List[List[int]]\n        :type src: int\n        :type dst: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        INF=float('inf')\n        mn=[INF]*n\n        mn[src]=0\n        \n        for k in range(K+1):\n            newmn=mn[:]\n            for (a,b, cost) in flights:\n                newmn[b]=min(newmn[b],mn[a]+cost)\n            mn=newmn\n            \n        return mn[dst] if mn[dst]!=INF else -1\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100580,
                "title": "c-dfs-dp-short-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\n    const int inf = 1e8;\\n    int dp[101][101];\\n\\npublic:\\n    int dfs(int node, int k, int dest, vector<vector<int>> &cost, vector<int> adj[])\\n    {\\n        if (k < 0)\\n            return inf;\\n\\n        if (node == dest)\\n            return 0;\\n\\n        if (dp[node][k] != -1)\\n            return dp[node][k];\\n\\n        int ans = inf;\\n        for (auto i : adj[node])\\n            ans = min(ans, cost[node][i] + dfs(i, k - 1, dest, cost, adj));\\n\\n        return dp[node][k] = ans;\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k)\\n    {\\n        memset(dp, -1, sizeof dp);\\n\\n        vector<vector<int>> cost(n, vector<int>(n));\\n        vector<int> adj[n];\\n        for (auto e : flights)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            cost[e[0]][e[1]] = e[2];\\n        }\\n\\n        int ans = dfs(src, k + 1, dst, cost, adj);\\n        return ans == inf ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    const int inf = 1e8;\\n    int dp[101][101];\\n\\npublic:\\n    int dfs(int node, int k, int dest, vector<vector<int>> &cost, vector<int> adj[])\\n    {\\n        if (k < 0)\\n            return inf;\\n\\n        if (node == dest)\\n            return 0;\\n\\n        if (dp[node][k] != -1)\\n            return dp[node][k];\\n\\n        int ans = inf;\\n        for (auto i : adj[node])\\n            ans = min(ans, cost[node][i] + dfs(i, k - 1, dest, cost, adj));\\n\\n        return dp[node][k] = ans;\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k)\\n    {\\n        memset(dp, -1, sizeof dp);\\n\\n        vector<vector<int>> cost(n, vector<int>(n));\\n        vector<int> adj[n];\\n        for (auto e : flights)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            cost[e[0]][e[1]] = e[2];\\n        }\\n\\n        int ans = dfs(src, k + 1, dst, cost, adj);\\n        return ans == inf ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181943,
                "title": "readable-javascript-solution",
                "content": "I know this isn\\'t the fastest solution, but it\\'s quite readable and using BFS.\\nBasic idea is \\n1. Construct a map of key/value pair of startingCity and [desitnationCity, price]\\n2. Start from src with price of 0 with stops (K) of K + 1.\\n3. Using queue (BFS), check current node and see if you have already arrived or push nextFlights into the queue\\n4. If you push nextFlights into the queue, sort it by the price (this is mimicing Priority Queue)\\n\\nSlowness comes from unoptimized Priority Queue.\\n\\n```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    let map = new Map();\\n    \\n    for (let i = 0; i < flights.length; i++) {\\n        const [start, end, price] = flights[i];\\n        let edges = map.get(start) || [];\\n        edges.push([end, price]);\\n        map.set(start, edges);\\n    }\\n    \\n    let queue = [[0, src, K + 1]];\\n    \\n    while (queue.length) {\\n        const [price, city, stops] = queue.shift();\\n        if (city === dst) return price;\\n        if (stops > 0) {\\n            const nextFlights = map.get(city) || [];\\n            for (let i = 0; i < nextFlights.length; i++) {\\n                const [next, cost] = nextFlights[i];\\n                queue.push([cost + price, next, stops - 1]);\\n            }\\n            queue.sort((a, b) => a[0] - b[0]);\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    let map = new Map();\\n    \\n    for (let i = 0; i < flights.length; i++) {\\n        const [start, end, price] = flights[i];\\n        let edges = map.get(start) || [];\\n        edges.push([end, price]);\\n        map.set(start, edges);\\n    }\\n    \\n    let queue = [[0, src, K + 1]];\\n    \\n    while (queue.length) {\\n        const [price, city, stops] = queue.shift();\\n        if (city === dst) return price;\\n        if (stops > 0) {\\n            const nextFlights = map.get(city) || [];\\n            for (let i = 0; i < nextFlights.length; i++) {\\n                const [next, cost] = nextFlights[i];\\n                queue.push([cost + price, next, stops - 1]);\\n            }\\n            queue.sort((a, b) => a[0] - b[0]);\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 166443,
                "title": "ac-simple-bfs-5ms-no-pq-beats-99-of-submissions",
                "content": "The idea is to perform a BFS from `src` upto only `K` levels. I initially hit a Memory limit but was able to get around by adding a `minPrices` check to skip exploring from a node if it does not give better result.\\nCode below - \\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        //convert flights[] to a weighted graph\\n        //perform BFS starting from src going only max depth of K\\n        //For Each node track the cost associated to reach that node\\n        int min = Integer.MAX_VALUE;\\n        int[][] graph = new int[n][n];\\n        int[] minPrices = new int[n];\\n        for (int[] flight : flights) {\\n            int start = flight[0];\\n            int end = flight[1];\\n            graph[start][end] = flight[2];\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        Queue<Integer> prices = new LinkedList<>();\\n        q.add(src);\\n        prices.add(0);\\n        while (!q.isEmpty() && K >= 0) {\\n            K--;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int start = q.poll();\\n                int priceTillNow = prices.poll();\\n                for (int j = 0; j < n; j++) {\\n                    int price = graph[start][j];\\n                    if (price > 0) {    //there is a flight\\n                        int curPrice = priceTillNow + price;\\n                        int oldPrice = minPrices[j];\\n                        //If there is a cheaper flight with lesser stops do not add it to q\\n                        if (oldPrice == 0 || oldPrice > curPrice) {\\n                            minPrices[j] = curPrice;\\n                            q.add(j);\\n                            prices.add(curPrice);\\n                            if (j == dst && min > curPrice) {\\n                                min = curPrice;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        //convert flights[] to a weighted graph\\n        //perform BFS starting from src going only max depth of K\\n        //For Each node track the cost associated to reach that node\\n        int min = Integer.MAX_VALUE;\\n        int[][] graph = new int[n][n];\\n        int[] minPrices = new int[n];\\n        for (int[] flight : flights) {\\n            int start = flight[0];\\n            int end = flight[1];\\n            graph[start][end] = flight[2];\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        Queue<Integer> prices = new LinkedList<>();\\n        q.add(src);\\n        prices.add(0);\\n        while (!q.isEmpty() && K >= 0) {\\n            K--;\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int start = q.poll();\\n                int priceTillNow = prices.poll();\\n                for (int j = 0; j < n; j++) {\\n                    int price = graph[start][j];\\n                    if (price > 0) {    //there is a flight\\n                        int curPrice = priceTillNow + price;\\n                        int oldPrice = minPrices[j];\\n                        //If there is a cheaper flight with lesser stops do not add it to q\\n                        if (oldPrice == 0 || oldPrice > curPrice) {\\n                            minPrices[j] = curPrice;\\n                            q.add(j);\\n                            prices.add(curPrice);\\n                            if (j == dst && min > curPrice) {\\n                                min = curPrice;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188471,
                "title": "bfs-level-order-99-49-faster-dijikstra-tle-explanation-with-images",
                "content": "**Approach 1: Using Dijkstra[TLE]**\\nIt happen to be the same idea of Dijkstra\\'s algorithm, but we need to keep the path. \\n*We consider current cost or not but we have to keep the track of path cost*. As currently it\\'s higher but for some other path we may get the minimum value at some other nodes(stops),considering this current cost. Consider Below Example for more clearity.\\n\\n***Code:***\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Approach 1: Using Dijksrta[TLE]\\n         vector<pair<int,int>> adj[n];\\n        // prepare an adjacency list\\n        for(int i = 0; i < flights.size(); i++){\\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            adj[u].push_back({v,w});\\n        }\\n        \\n        // create a distence vetor\\n        vector<int> disTo(n+1,INT_MAX);\\n        disTo[src] = 0;  // src is the source node\\n        \\n        priority_queue< pair<int,pair<int, int>>, vector<pair<int,pair<int, int>>>,greater<pair<int,pair<int,int>>> > pq;\\n        \\n        pq.push({0,{src,k+1}}); // {cost,{node,remainedStops}}\\n                 \\n        while(!pq.empty())\\n        {\\n            int cost = pq.top().first;\\n            int node = pq.top().second.first;\\n            int remStops = pq.top().second.second;\\n            pq.pop();\\n            \\n            if(node == dst){\\n                 return disTo[dst];\\n            }\\n            if(remStops == 0){\\n                 continue;\\n            }\\n            \\n            for(auto it: adj[node])\\n            {\\n                int next = it.first;\\n                int nextDis =it.second;\\n\\t\\t\\t\\t\\n                 if((cost + nextDis) < disTo[next]){\\n                 disTo[next] = cost + nextDis;\\n                }\\n                pq.push({cost + nextDis,{next,remStops-1}}); \\n          // We consider current cost or not but we have to keep the track of path cost, \\n          // As currently it\\'s higher but for some other path we may get the minimum value at some other nodes(stops),considering this current cost.\\n            }\\n        }\\n        \\n        if(disTo[dst] == INT_MAX) return -1;\\n        return disTo[dst];\\n    }\\n};\\n```\\n*NOTE* : You can do it by Dijkstra using DP but here i will be not discussing that.\\n\\n**Approach 2: Using BFS Levelwise Traversal**\\n\\n***Intution*** : Since we are allowed only K stops, so either we can reach the Destination Or Not depend on value of K.\\nSo the idea is to perform BFS K+1 times (considering src also), as we are allowed only K stops so at each level of BFS we will reach to stops with best possible cost.\\n\\n**NOTE:** *We can apply this same approach to all problem where we are bounded with some threshold value, we have to find the minimum path.*\\n\\n*Let\\'s take a example for more clearity:* \\n![image](https://assets.leetcode.com/users/images/054125b6-b556-47e2-bc46-63489468f36a_1656006744.3018532.jpeg)\\n![image](https://assets.leetcode.com/users/images/39f275e6-8f59-437d-9035-dac5a0672c66_1656008056.9923012.jpeg)\\n\\n\\n***Code:***\\n```\\nclass Solution {\\npublic:\\n    // Approach 2: Level Wise BFS \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n         vector<pair<int,int>> adj[n];\\n        // prepare an adjacency list\\n        for(int i = 0; i < flights.size(); i++){\\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            adj[u].push_back({v,w});\\n        }\\n        \\n        // create a distence vetor\\n        vector<int> disTo(n+1,INT_MAX);\\n        disTo[src] = 0;  // src is the source node\\n        \\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,src}); // {{cost,node}}\\n        k = k + 1;    \\n        \\n        while(!q.empty())\\n        {\\n         \\n            int size = q.size();\\n            k--;\\n            if(k < 0) break;\\n            // Do level Wise : Traverse all stops at current level and find best path to each stop\\n            for(int i = 0; i < size; i++)\\n            {\\n              auto curr = q.front(); q.pop();\\n              int node = curr.second;\\n              int cost = curr.first;\\n                 \\n              for(auto it: adj[node])\\n              {\\n                if(cost + it.second < disTo[it.first])\\n                {\\n                   disTo[it.first] = cost + it.second;\\n                   q.push({disTo[it.first],it.first});\\n                }\\n              }\\n             }\\n        }\\n        \\n        if(disTo[dst] == INT_MAX) return -1;\\n        return disTo[dst];\\n    }\\n};\\n```\\nSimiler Problem On 2D : https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/ \\nHope it helps you :)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Approach 1: Using Dijksrta[TLE]\\n         vector<pair<int,int>> adj[n];\\n        // prepare an adjacency list\\n        for(int i = 0; i < flights.size(); i++){\\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            adj[u].push_back({v,w});\\n        }\\n        \\n        // create a distence vetor\\n        vector<int> disTo(n+1,INT_MAX);\\n        disTo[src] = 0;  // src is the source node\\n        \\n        priority_queue< pair<int,pair<int, int>>, vector<pair<int,pair<int, int>>>,greater<pair<int,pair<int,int>>> > pq;\\n        \\n        pq.push({0,{src,k+1}}); // {cost,{node,remainedStops}}\\n                 \\n        while(!pq.empty())\\n        {\\n            int cost = pq.top().first;\\n            int node = pq.top().second.first;\\n            int remStops = pq.top().second.second;\\n            pq.pop();\\n            \\n            if(node == dst){\\n                 return disTo[dst];\\n            }\\n            if(remStops == 0){\\n                 continue;\\n            }\\n            \\n            for(auto it: adj[node])\\n            {\\n                int next = it.first;\\n                int nextDis =it.second;\\n\\t\\t\\t\\t\\n                 if((cost + nextDis) < disTo[next]){\\n                 disTo[next] = cost + nextDis;\\n                }\\n                pq.push({cost + nextDis,{next,remStops-1}}); \\n          // We consider current cost or not but we have to keep the track of path cost, \\n          // As currently it\\'s higher but for some other path we may get the minimum value at some other nodes(stops),considering this current cost.\\n            }\\n        }\\n        \\n        if(disTo[dst] == INT_MAX) return -1;\\n        return disTo[dst];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // Approach 2: Level Wise BFS \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n         vector<pair<int,int>> adj[n];\\n        // prepare an adjacency list\\n        for(int i = 0; i < flights.size(); i++){\\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            adj[u].push_back({v,w});\\n        }\\n        \\n        // create a distence vetor\\n        vector<int> disTo(n+1,INT_MAX);\\n        disTo[src] = 0;  // src is the source node\\n        \\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,src}); // {{cost,node}}\\n        k = k + 1;    \\n        \\n        while(!q.empty())\\n        {\\n         \\n            int size = q.size();\\n            k--;\\n            if(k < 0) break;\\n            // Do level Wise : Traverse all stops at current level and find best path to each stop\\n            for(int i = 0; i < size; i++)\\n            {\\n              auto curr = q.front(); q.pop();\\n              int node = curr.second;\\n              int cost = curr.first;\\n                 \\n              for(auto it: adj[node])\\n              {\\n                if(cost + it.second < disTo[it.first])\\n                {\\n                   disTo[it.first] = cost + it.second;\\n                   q.push({disTo[it.first],it.first});\\n                }\\n              }\\n             }\\n        }\\n        \\n        if(disTo[dst] == INT_MAX) return -1;\\n        return disTo[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925905,
                "title": "bfs-solution-beats-98-submissions-explanations-are-given",
                "content": "This is no way a medium difficult problem! Its more on the harder side. And I wasted lots of time thinking of a solution using Dijkstra algorithm whereas it could have been easily solved using a simple modified bfs!!\\n\\nI used modified bfs to find all possible \"valid\" paths to the destination node and returned the minimum cost from them. Here, \"valid\" path means it has at most k stops or simply it has total nodes  **less than or equal to (k +2)**.\\nCode with comments is given below. You can comment if you still have any confusion. I will be happy to reply. \\n\\n```\\nclass Solution {\\n    typedef pair<int, int> pii;\\n    typedef tuple<int, int, int> tiii;\\npublic:\\n    const int inf = 1e9;\\n    vector<pii> adj[110];\\n\\n    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k) {\\n        for (auto &e: flights)\\n            adj[e[0]].emplace_back(make_pair(e[1], e[2]));\\n\\n        return bfs(src, dst, k, n);\\n    }\\n\\n    int bfs(int src, int dest, int k, int n) {\\n        queue<tiii> q;\\n        vector<int> costs(n, inf); // stores minimum costs to travel to any node from souce using at mosts k+2 nodes\\n        costs[src] = 0; // source to source travel cost is 0\\n        q.push({src, 0, 1}); // {node, cost, stops}\\n\\n        while (!q.empty()) {\\n            auto[currNode, currCost, currTotalNodes] = q.front();\\n            q.pop();\\n\\n            // Having k stops between source and destination equals to total of k + 2 nodes in the path (including source and destination)\\n            // So, if path to currNode already has total k+2 nodes, there is no point to go any further\\n            if (currTotalNodes == k + 2)\\n                continue;\\n\\n            for (auto &[nextNode, cost]: adj[currNode]) { //iterate over all the neighbors of currNode\\n                int nextCost = currCost + cost;\\n                int nextTotalNodes = currTotalNodes + 1;\\n\\n                // Below if condition is the modified version of standard bfs.\\n                // In the standard bfs we don\\'t add a node again to the queue if it has been visited before.\\n                // Here, we may add a node again to the queue if current path to it has less cost than previously traversed paths.\\n                if (nextCost < costs[nextNode]) {\\n                    costs[nextNode] = nextCost; //update costs to reach nextNode\\n                    q.push({nextNode, nextCost, nextTotalNodes});\\n                }\\n            }\\n        }\\n\\n        if (costs[dest] == inf)\\n            return -1;\\n        else return costs[dest];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    typedef pair<int, int> pii;\\n    typedef tuple<int, int, int> tiii;\\npublic:\\n    const int inf = 1e9;\\n    vector<pii> adj[110];\\n\\n    int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int k) {\\n        for (auto &e: flights)\\n            adj[e[0]].emplace_back(make_pair(e[1], e[2]));\\n\\n        return bfs(src, dst, k, n);\\n    }\\n\\n    int bfs(int src, int dest, int k, int n) {\\n        queue<tiii> q;\\n        vector<int> costs(n, inf); // stores minimum costs to travel to any node from souce using at mosts k+2 nodes\\n        costs[src] = 0; // source to source travel cost is 0\\n        q.push({src, 0, 1}); // {node, cost, stops}\\n\\n        while (!q.empty()) {\\n            auto[currNode, currCost, currTotalNodes] = q.front();\\n            q.pop();\\n\\n            // Having k stops between source and destination equals to total of k + 2 nodes in the path (including source and destination)\\n            // So, if path to currNode already has total k+2 nodes, there is no point to go any further\\n            if (currTotalNodes == k + 2)\\n                continue;\\n\\n            for (auto &[nextNode, cost]: adj[currNode]) { //iterate over all the neighbors of currNode\\n                int nextCost = currCost + cost;\\n                int nextTotalNodes = currTotalNodes + 1;\\n\\n                // Below if condition is the modified version of standard bfs.\\n                // In the standard bfs we don\\'t add a node again to the queue if it has been visited before.\\n                // Here, we may add a node again to the queue if current path to it has less cost than previously traversed paths.\\n                if (nextCost < costs[nextNode]) {\\n                    costs[nextNode] = nextCost; //update costs to reach nextNode\\n                    q.push({nextNode, nextCost, nextTotalNodes});\\n                }\\n            }\\n        }\\n\\n        if (costs[dest] == inf)\\n            return -1;\\n        else return costs[dest];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519110,
                "title": "c-dijkstra-optimised-with-dp-new-approach-with-step-by-step-comments-in-code-clean",
                "content": "DIJKSTRA OPTIMISED with DP \\n\\n```\\nclass Solution {\\npublic:\\n    // Dijkstra with DP    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // create adjacenct list where adj[u] consists of a pair (v, weight from u to v )\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto i: flights){\\n            adj[i[0]].push_back({i[1], i[2]});\\n        }\\n        \\n        // create a 2D distance vector (acts like DP), where each element (dis[i][j]) represents the distance of \\'i\\' from \\'src\\' when there are \\'j\\' stops left.\\n        vector<vector<int>> dis(n+1, vector<int>(k+1,INT_MAX));\\n        \\n        \\n        // Dijkstra starts\\n        \\n        // Create a set (acts like priority queue) which holds { present weight or distance , { node, remaining stops } }\\n        set<pair<int,pair<int,int>>> se;\\n        // distance of src from src is 0 and there are k stops left\\n        se.insert({0,{src, k}});\\n        dis[src][k] = 0; // distance of src is 0 when k stops are left\\n        \\n        while(!se.empty()){\\n            // present element\\n            pair<int,pair<int,int>> pres = *(se.begin());\\n            // poping out pres\\n            se.erase(se.begin());\\n            \\n            int u = pres.second.first;\\n            // if reached dst. continue\\n            if( dst == u ) continue;\\n            \\n            // looping through the children of u ( i.e, all the v\\'s )\\n            for(pair<int,int> i : adj[u]){\\n                \\n                int presWeight = pres.first;\\n                int costUtoV = i.second;\\n                int v = i.first;\\n                int remainingK = pres.second.second;\\n                \\n                // if presentWeght + cost of u-> v is less than distance of \\'v\\' with \\'remainingK\\' stops left.  \\n                if(  presWeight + costUtoV < dis[v][remainingK]  ){\\n                    if( remainingK > 0 || (v == dst && remainingK == 0)){\\n                        // updating dis[v][remainingK]\\n                        dis[v][remainingK] = presWeight + costUtoV;\\n                        // pushing it to our set.\\n                        se.insert({costUtoV + presWeight, { v, remainingK-1 }});\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        // loop through all the \\'k\\' possibilities of reaching \\'dst\\' and choose the min\\n        for(int i  :dis[dst]) ans = min(i,ans);\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n\\n~ My own solution.\\nUpvote if you like the solution.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Dijkstra with DP    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // create adjacenct list where adj[u] consists of a pair (v, weight from u to v )\\n        vector<vector<pair<int,int>>> adj(n+1);\\n        for(auto i: flights){\\n            adj[i[0]].push_back({i[1], i[2]});\\n        }\\n        \\n        // create a 2D distance vector (acts like DP), where each element (dis[i][j]) represents the distance of \\'i\\' from \\'src\\' when there are \\'j\\' stops left.\\n        vector<vector<int>> dis(n+1, vector<int>(k+1,INT_MAX));\\n        \\n        \\n        // Dijkstra starts\\n        \\n        // Create a set (acts like priority queue) which holds { present weight or distance , { node, remaining stops } }\\n        set<pair<int,pair<int,int>>> se;\\n        // distance of src from src is 0 and there are k stops left\\n        se.insert({0,{src, k}});\\n        dis[src][k] = 0; // distance of src is 0 when k stops are left\\n        \\n        while(!se.empty()){\\n            // present element\\n            pair<int,pair<int,int>> pres = *(se.begin());\\n            // poping out pres\\n            se.erase(se.begin());\\n            \\n            int u = pres.second.first;\\n            // if reached dst. continue\\n            if( dst == u ) continue;\\n            \\n            // looping through the children of u ( i.e, all the v\\'s )\\n            for(pair<int,int> i : adj[u]){\\n                \\n                int presWeight = pres.first;\\n                int costUtoV = i.second;\\n                int v = i.first;\\n                int remainingK = pres.second.second;\\n                \\n                // if presentWeght + cost of u-> v is less than distance of \\'v\\' with \\'remainingK\\' stops left.  \\n                if(  presWeight + costUtoV < dis[v][remainingK]  ){\\n                    if( remainingK > 0 || (v == dst && remainingK == 0)){\\n                        // updating dis[v][remainingK]\\n                        dis[v][remainingK] = presWeight + costUtoV;\\n                        // pushing it to our set.\\n                        se.insert({costUtoV + presWeight, { v, remainingK-1 }});\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        // loop through all the \\'k\\' possibilities of reaching \\'dst\\' and choose the min\\n        for(int i  :dis[dst]) ans = min(i,ans);\\n        \\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738656,
                "title": "python3-modified-spfa-with-explanation-and-comments",
                "content": "Use SPFA with minor modification. The key idea here is that we create a \"cost_map\" dictionary that stores cities we have visited and the minimum price to get there. During SPFA, if we see a city that is not in the \"visited\" dictionary, we visit it and set/update \"cost_map[city]\" to the price to get there. If it\\'s already in the \"cost_map\" dictionary, we visit it if and only if we can visit it with a lower price. Also, if the current steps >= K, we don\\'t append it to queue. \\n\\nFinally, if the destination is in the \"cost_map\" dictionary, we can return it since we have visited it within K stops and we know that the price is going to be minimum. If destination is not in the \"cost_map\" dictionary, we\\'ve never visited the destination within K stops, return -1.\\n\\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        # build adjacency list\\n        neighbors = defaultdict(list)\\n        for source, dest, price in flights:\\n            neighbors[source].append([dest, price])\\n        \\n        # modified SPFA\\n        cost_map = {src: 0} \\n        queue = deque([(src, 0, 0)])\\n        while queue:\\n            city, cost_so_far, stops_taken = queue.popleft()\\n            for next_city, travel_cost in neighbors[city]:\\n                if next_city not in cost_map or travel_cost + cost_so_far < cost_map[next_city]:\\n                    cost_map[next_city] = travel_cost + cost_so_far\\n                    if stops_taken < K:\\n                        queue.append((next_city, cost_map[next_city], stops_taken + 1))\\n\\n        return cost_map[dst] if dst in cost_map else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        # build adjacency list\\n        neighbors = defaultdict(list)\\n        for source, dest, price in flights:\\n            neighbors[source].append([dest, price])\\n        \\n        # modified SPFA\\n        cost_map = {src: 0} \\n        queue = deque([(src, 0, 0)])\\n        while queue:\\n            city, cost_so_far, stops_taken = queue.popleft()\\n            for next_city, travel_cost in neighbors[city]:\\n                if next_city not in cost_map or travel_cost + cost_so_far < cost_map[next_city]:\\n                    cost_map[next_city] = travel_cost + cost_so_far\\n                    if stops_taken < K:\\n                        queue.append((next_city, cost_map[next_city], stops_taken + 1))\\n\\n        return cost_map[dst] if dst in cost_map else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690994,
                "title": "javascript-clean-dijkstra-s-algorithm",
                "content": "```javascript\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    const adjacencyList = new Map();\\n    \\n    for(let [start, end, cost] of flights) {\\n        if(adjacencyList.has(start)) adjacencyList.get(start).push([end, cost]);\\n        else adjacencyList.set(start, [[end, cost]]);\\n    }\\n    \\n    const queue = [[0, src, K+1]];\\n    const visited = new Map();\\n    \\n    while(queue.length) {\\n        queue.sort((a, b) => a[0] - b[0]);\\n        \\n        const [cost, city, stops] = queue.shift();\\n        visited.set(city, stops);\\n        \\n        if(city === dst) return cost;\\n        if(stops <= 0 || !adjacencyList.has(city))  continue;\\n            \\n        for(let [nextCity, nextCost] of adjacencyList.get(city)) {\\n            if(visited.has(nextCity) && visited.get(nextCity) >= stops-1) continue;\\n            queue.push([cost+nextCost, nextCity, stops-1]);\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    const adjacencyList = new Map();\\n    \\n    for(let [start, end, cost] of flights) {\\n        if(adjacencyList.has(start)) adjacencyList.get(start).push([end, cost]);\\n        else adjacencyList.set(start, [[end, cost]]);\\n    }\\n    \\n    const queue = [[0, src, K+1]];\\n    const visited = new Map();\\n    \\n    while(queue.length) {\\n        queue.sort((a, b) => a[0] - b[0]);\\n        \\n        const [cost, city, stops] = queue.shift();\\n        visited.set(city, stops);\\n        \\n        if(city === dst) return cost;\\n        if(stops <= 0 || !adjacencyList.has(city))  continue;\\n            \\n        for(let [nextCity, nextCost] of adjacencyList.get(city)) {\\n            if(visited.has(nextCity) && visited.get(nextCity) >= stops-1) continue;\\n            queue.push([cost+nextCost, nextCity, stops-1]);\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436785,
                "title": "python-solution-dijkstra-s-explained",
                "content": "Update: Modified solution. Hat-tip to @wangken82 for catching a bug, and LC admins for adding new test cases! :)\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        #Make graph\\n        adj_list = defaultdict(list)\\n        for u, v, w in flights:\\n            adj_list[u].append((v,w))\\n\\n        prior_queue = [ (0, -1, src) ] #weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if steps>k:\\n                continue\\n\\n            if node==dst:\\n                return cost\\n\\n            for neighb, weight in adj_list[node]:\\n                heapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))\\n\\n        return -1\\n\\n```\\n\\nDijkstra\\'s is a variant of BFS. The important thing to notice is that when you remove/pop elements from the queue as in a BFS, just pop the one which is closest to the current node - that\\'s it!\\n\\nAnother caveat in this problem though, (unlike regular BFS) is not to mark a node as visited after reaching it through one path. There could be other valid paths that could lead to the same node that we may have not explored - yet. (We usually mark nodes as visited to prevent infinite loops. I.e if node 0 is connected to node 1, and node 1 is connected to node 0, then if you don\\'t mark nodes as visited, an infinite loop is created. Here the graph is a DAG so we won\\'t have that issue) \\n\\nInspired by this gorgeous article: https://medium.com/basecs/finding-the-shortest-path-with-a-little-help-from-dijkstra-613149fbdc8e It\\'s beautifully explained here!\\n\\n**Update**: Optimized solution\\n\\nHT to @krishnancmf8 for this optimization\\n\\nPrevent unnecessary exploration of certain nodes, by keeping tracking of how many stops it took to reach that node when it was visited earlier. On subsequent visits, if number of steps it took to reach the node previously, was **lesser** than the current visit, we can safely ignore the current visit.\\n\\nFor. e.g if Node_5 was visited earlier (it means that a previous path to Node_5 cost lesser than the current path), and we stored the number of stops it took to reach Node_5 as 7.  Now, say we are have popped Node_5 again, (remember, this path is costlier), and consider two cases:\\na) Number of steps is 15 (greater than 7), so there\\'s no point exploring this further (why? We have already explored a cheaper path that took less steps)\\nb) Number of steps is 4 (less than 7), so there is a possibility that this path could lead us to solution (why? The earlier path may have been cheaper, but eventually may have have taken longer steps, and hence been invalid) \\n\\n**Note**: best_visited dictionary stores the steps taken to get to a node\\n\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        #Make graph\\n        adj_list = defaultdict(list)\\n        for u, v, w in flights:\\n            adj_list[u].append((v,w))\\n        \\n        best_visited = defaultdict(lambda : math.inf) # Initialized to maximum\\n        \\n        prior_queue = [ (0, -1, src) ] #weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if best_visited[node] <= steps:  #Have seen the node already, and the steps are more than last time\\n                continue\\n\\n            if steps>k:  # More than k stops, invalid\\n                continue\\n\\n            if node==dst: \\n                return cost\\n            \\n            best_visited[node] = steps #Update steps\\n\\n            for neighb, weight in adj_list[node]:\\n\\t\\t\\t\\tif steps + 1 < best_visited[neighb]: #Push neighb into the heap, only if steps+1 is better than the last time it was visited\\n\\t\\t\\t\\t\\theapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        #Make graph\\n        adj_list = defaultdict(list)\\n        for u, v, w in flights:\\n            adj_list[u].append((v,w))\\n\\n        prior_queue = [ (0, -1, src) ] #weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if steps>k:\\n                continue\\n\\n            if node==dst:\\n                return cost\\n\\n            for neighb, weight in adj_list[node]:\\n                heapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))\\n\\n        return -1\\n\\n```\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        import heapq\\n        from collections import defaultdict\\n\\n        #Make graph\\n        adj_list = defaultdict(list)\\n        for u, v, w in flights:\\n            adj_list[u].append((v,w))\\n        \\n        best_visited = defaultdict(lambda : math.inf) # Initialized to maximum\\n        \\n        prior_queue = [ (0, -1, src) ] #weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if best_visited[node] <= steps:  #Have seen the node already, and the steps are more than last time\\n                continue\\n\\n            if steps>k:  # More than k stops, invalid\\n                continue\\n\\n            if node==dst: \\n                return cost\\n            \\n            best_visited[node] = steps #Update steps\\n\\n            for neighb, weight in adj_list[node]:\\n\\t\\t\\t\\tif steps + 1 < best_visited[neighb]: #Push neighb into the heap, only if steps+1 is better than the last time it was visited\\n\\t\\t\\t\\t\\theapq.heappush(prior_queue, (cost+weight, steps + 1, neighb))\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295302,
                "title": "c-dijkstra-algo",
                "content": "Hey, I updated the solution with some lines of explanation. Hope you\\'ll like it.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        using ip = pair<int, int>;\\n        vector<vector<ip>> adj(n);\\n        for (auto& f : flights) adj[f[0]].push_back({f[1], f[2]});\\n        using arr = array<int, 3>;\\n        priority_queue<arr, vector<arr>, greater<arr>> pq;\\n        vector<int> dist(n, INT_MAX);\\n        pq.push({0, src, 0});\\n        while (!pq.empty()) {\\n            auto [cost, node, stops] = pq.top();\\n            pq.pop();\\n            if (node == dst) return cost; // if we found destination -> return current cost.\\n            if (stops > k) continue;\\n\\t\\t\\t// Optimization: if we already visit this node and it has fewer stops in \\n\\t\\t\\t// dist array than in pq we don\\'t need to explore it again.\\n            if (dist[node] != INT_MAX && dist[node] < stops) continue;\\n            dist[node] = stops;\\n            for (auto& [next, price] : adj[node]) {\\n                pq.push({cost + price, next, stops + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        using ip = pair<int, int>;\\n        vector<vector<ip>> adj(n);\\n        for (auto& f : flights) adj[f[0]].push_back({f[1], f[2]});\\n        using arr = array<int, 3>;\\n        priority_queue<arr, vector<arr>, greater<arr>> pq;\\n        vector<int> dist(n, INT_MAX);\\n        pq.push({0, src, 0});\\n        while (!pq.empty()) {\\n            auto [cost, node, stops] = pq.top();\\n            pq.pop();\\n            if (node == dst) return cost; // if we found destination -> return current cost.\\n            if (stops > k) continue;\\n\\t\\t\\t// Optimization: if we already visit this node and it has fewer stops in \\n\\t\\t\\t// dist array than in pq we don\\'t need to explore it again.\\n            if (dist[node] != INT_MAX && dist[node] < stops) continue;\\n            dist[node] = stops;\\n            for (auto& [next, price] : adj[node]) {\\n                pq.push({cost + price, next, stops + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516723,
                "title": "four-method-to-solve-this-program",
                "content": "### BFS\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int[] f : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        k++;\\n        int min = Integer.MAX_VALUE; \\n        int[] count = new int[n];// \\u5224\\u65AD\\u662F\\u5426\\u6709\\u73AF\\n        count[src]++; \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{src,0});\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            if(k--==0) break;\\n            while(size-->0){\\n                int[] cur = queue.poll();\\n                Map<Integer,Integer> next = map.getOrDefault(cur[0],null);\\n                if(next==null) continue;\\n                for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n                    if(cur[1] + entry.getValue() >= min) continue;\\n                    if(entry.getKey()==dst){\\n                        min = Math.min(min,cur[1] + entry.getValue());\\n                        continue;\\n                    } \\n                    if(count[entry.getKey()]++<=n){\\n                        queue.add(new int[]{entry.getKey(),cur[1] + entry.getValue()});    \\n                    }       \\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n```\\n### DFS\\n```\\nint min = Integer.MAX_VALUE;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int f[] : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        visited[src] = true;\\n        dfs(map,visited,0,src,dst,K+1);\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n    private void dfs(Map<Integer,Map<Integer,Integer>> map,boolean[] visited,int val,int cur,int dst,int k){\\n        if(k<0) return;\\n        if(cur==dst){\\n            min = Math.min(min,val);\\n        }\\n        Map<Integer,Integer> next = map.getOrDefault(cur,null);\\n        if(next==null) return;\\n        for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n            if(visited[entry.getKey()]) continue;\\n            if(val+entry.getValue()>=min) continue;\\n            visited[entry.getKey()] = true;\\n            dfs(map,visited,val+entry.getValue(),entry.getKey(),dst,k-1);\\n            visited[entry.getKey()] = false;\\n        }\\n    }\\n```\\n### PriorityQueue\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int[] f : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((x,y)->x[0]-y[0]);\\n        minHeap.add(new int[]{0,src,k+1});\\n        while(!minHeap.isEmpty()){\\n            int[] cur = minHeap.poll();\\n            int price = cur[0], city = cur[1], stop = cur[2];\\n            if(stop < 0) continue;\\n            if(city==dst) return price;\\n            Map<Integer,Integer> next = map.getOrDefault(city,new HashMap<>());\\n            for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n                minHeap.add(new int[]{price+entry.getValue(),entry.getKey(),stop-1});\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n### Dynamic Programming\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[][] dp = new int[k+2][n];\\n        for(int i=0; i<=k+1; i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);    \\n        }\\n        //fly from src to scr cost 0\\n        for(int i=0; i<=k+1; i++){\\n            dp[i][src] = 0;    \\n        }\\n        \\n        for(int i=1; i<=k+1; i++){\\n            for(int[] f: flights){\\n                if(dp[i-1][f[0]]!=Integer.MAX_VALUE){\\n                    dp[i][f[1]] = Math.min(dp[i][f[1]],dp[i-1][f[0]]+f[2]);\\n                }\\n            }\\n        }\\n        return dp[k+1][dst] == Integer.MAX_VALUE ? -1 : dp[k+1][dst];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int[] f : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        k++;\\n        int min = Integer.MAX_VALUE; \\n        int[] count = new int[n];// \\u5224\\u65AD\\u662F\\u5426\\u6709\\u73AF\\n        count[src]++; \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{src,0});\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            if(k--==0) break;\\n            while(size-->0){\\n                int[] cur = queue.poll();\\n                Map<Integer,Integer> next = map.getOrDefault(cur[0],null);\\n                if(next==null) continue;\\n                for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n                    if(cur[1] + entry.getValue() >= min) continue;\\n                    if(entry.getKey()==dst){\\n                        min = Math.min(min,cur[1] + entry.getValue());\\n                        continue;\\n                    } \\n                    if(count[entry.getKey()]++<=n){\\n                        queue.add(new int[]{entry.getKey(),cur[1] + entry.getValue()});    \\n                    }       \\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n```\n```\\nint min = Integer.MAX_VALUE;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int f[] : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        boolean[] visited = new boolean[n];\\n        visited[src] = true;\\n        dfs(map,visited,0,src,dst,K+1);\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n    private void dfs(Map<Integer,Map<Integer,Integer>> map,boolean[] visited,int val,int cur,int dst,int k){\\n        if(k<0) return;\\n        if(cur==dst){\\n            min = Math.min(min,val);\\n        }\\n        Map<Integer,Integer> next = map.getOrDefault(cur,null);\\n        if(next==null) return;\\n        for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n            if(visited[entry.getKey()]) continue;\\n            if(val+entry.getValue()>=min) continue;\\n            visited[entry.getKey()] = true;\\n            dfs(map,visited,val+entry.getValue(),entry.getKey(),dst,k-1);\\n            visited[entry.getKey()] = false;\\n        }\\n    }\\n```\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer,Map<Integer,Integer>> map = new HashMap<>();\\n        for(int[] f : flights){\\n            map.computeIfAbsent(f[0],m->new HashMap<>()).put(f[1],f[2]);\\n        }\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((x,y)->x[0]-y[0]);\\n        minHeap.add(new int[]{0,src,k+1});\\n        while(!minHeap.isEmpty()){\\n            int[] cur = minHeap.poll();\\n            int price = cur[0], city = cur[1], stop = cur[2];\\n            if(stop < 0) continue;\\n            if(city==dst) return price;\\n            Map<Integer,Integer> next = map.getOrDefault(city,new HashMap<>());\\n            for(Map.Entry<Integer,Integer> entry : next.entrySet()){\\n                minHeap.add(new int[]{price+entry.getValue(),entry.getKey(),stop-1});\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[][] dp = new int[k+2][n];\\n        for(int i=0; i<=k+1; i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);    \\n        }\\n        //fly from src to scr cost 0\\n        for(int i=0; i<=k+1; i++){\\n            dp[i][src] = 0;    \\n        }\\n        \\n        for(int i=1; i<=k+1; i++){\\n            for(int[] f: flights){\\n                if(dp[i-1][f[0]]!=Integer.MAX_VALUE){\\n                    dp[i][f[1]] = Math.min(dp[i][f[1]],dp[i-1][f[0]]+f[2]);\\n                }\\n            }\\n        }\\n        return dp[k+1][dst] == Integer.MAX_VALUE ? -1 : dp[k+1][dst];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099866,
                "title": "python3-simple-bfs",
                "content": "\\n# Code\\n```\\n\"\"\"\\nRuntime: 106 ms, faster than 88.35%\\nMemory Usage: 15 MB, less than 89.11%\\n\\n\"\"\"\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph, dis = defaultdict(list), [-1 for _ in range(n)]\\n        for f, to, price in flights:\\n            graph[f].append([to, price])\\n\\n        dis[src], q, step = 0, deque([src]), 0\\n\\n        while q and step <= k:\\n            sz = len(q)\\n            new_dis = list(dis)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                for neighbor in graph[cur]:\\n                    if new_dis[neighbor[0]] == -1 or new_dis[neighbor[0]] > dis[cur]+neighbor[1]:\\n                        new_dis[neighbor[0]] = dis[cur] + neighbor[1]\\n                        q.append(neighbor[0])\\n            step += 1\\n            dis = new_dis\\n\\n        return dis[dst]",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\n# Code\\n```\\n\"\"\"\\nRuntime: 106 ms, faster than 88.35%\\nMemory Usage: 15 MB, less than 89.11%\\n\\n\"\"\"\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph, dis = defaultdict(list), [-1 for _ in range(n)]\\n        for f, to, price in flights:\\n            graph[f].append([to, price])\\n\\n        dis[src], q, step = 0, deque([src]), 0\\n\\n        while q and step <= k:\\n            sz = len(q)\\n            new_dis = list(dis)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                for neighbor in graph[cur]:\\n                    if new_dis[neighbor[0]] == -1 or new_dis[neighbor[0]] > dis[cur]+neighbor[1]:\\n                        new_dis[neighbor[0]] = dis[cur] + neighbor[1]\\n                        q.append(neighbor[0])\\n            step += 1\\n            dis = new_dis\\n\\n        return dis[dst]",
                "codeTag": "Java"
            },
            {
                "id": 1412918,
                "title": "c-cpp-bfs-dijkstra-algo-level-order",
                "content": "Do like djikstra algorithm just take queue instead of priority queue and do level order traversal\\n\\nOne more level order traversal ques in graph\\nhttps://leetcode.com/problems/minimum-height-trees/\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n]; \\n        int m = flights.size();\\n        for(int i=0;i<m;i++){\\n            int p = flights[i][0];\\n            int q = flights[i][1];\\n            adj[p].push_back({q,flights[i][2]});\\n        }\\n        queue<pair<int,int>>q; // for level order traversal we use queue\\n        vector<bool> vis(n,0);\\n        q.push({0,src});\\n        vector<int>dist(n,INT_MAX);\\n        dist[src]=0;\\n        k+=1; // add +1 because it is starting from src\\n        while(!q.empty()){\\n            int size=q.size();\\n            k--;\\n            if(k<0) // break statement\\n                break;\\n            for(int i=0;i<size;i++){\\n                auto p = q.front();\\n                int node = p.second;\\n                int wt = p.first;\\n                q.pop();\\n                for(auto x:adj[node]){\\n                    if(x.second+wt<dist[x.first])\\n                    {\\n                        dist[x.first]=x.second+wt;\\n                        q.push({dist[x.first],x.first}); // if we use priority queue then this solution\\n                    }            //may go up in the queue that doesn\\'t gives us level order traversal\\n                }\\n                \\n            }\\n        }\\n        return dist[dst]==INT_MAX?-1:dist[dst];\\n    }\\n```\\n\\nIf you like please do upvote the solution",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n]; \\n        int m = flights.size();\\n        for(int i=0;i<m;i++){\\n            int p = flights[i][0];\\n            int q = flights[i][1];\\n            adj[p].push_back({q,flights[i][2]});\\n        }\\n        queue<pair<int,int>>q; // for level order traversal we use queue\\n        vector<bool> vis(n,0);\\n        q.push({0,src});\\n        vector<int>dist(n,INT_MAX);\\n        dist[src]=0;\\n        k+=1; // add +1 because it is starting from src\\n        while(!q.empty()){\\n            int size=q.size();\\n            k--;\\n            if(k<0) // break statement\\n                break;\\n            for(int i=0;i<size;i++){\\n                auto p = q.front();\\n                int node = p.second;\\n                int wt = p.first;\\n                q.pop();\\n                for(auto x:adj[node]){\\n                    if(x.second+wt<dist[x.first])\\n                    {\\n                        dist[x.first]=x.second+wt;\\n                        q.push({dist[x.first],x.first}); // if we use priority queue then this solution\\n                    }            //may go up in the queue that doesn\\'t gives us level order traversal\\n                }\\n                \\n            }\\n        }\\n        return dist[dst]==INT_MAX?-1:dist[dst];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433024,
                "title": "python-bfs-with-comments-beat-99-65-time-no-fancy-algorithms",
                "content": "Intuition:\\n\\nFor normal BFS traversal, we terminate a searching path if the current node was visited before.\\n\\nFor this problem, we define **seen[pos] = min cost from source to current city**. We terminate a searching path if \\n1) the current city was visited before AND the cost of this path >= seen[pos],\\n2) OR this path contains more than K stops.\\n\\nOtherwise, we keep searching and updating seen[pos].\\n\\n```\\ndef findCheapestPrice(self, n, flights, src, dst, K):\\n        if src == dst: return 0\\n        d, seen = collections.defaultdict(list), collections.defaultdict(lambda: float(\\'inf\\'))\\n        for u, v, p in flights:\\n            d[u] += [(v, p)]\\n    \\n        q = [(src, -1, 0)]\\n        \\n        while q:\\n            pos, k, cost = q.pop(0)\\n            if pos == dst or k == K: continue \\n            for nei, p in d[pos]:\\n                if cost + p >= seen[nei]:\\n                    continue\\n                else:\\n                    seen[nei] = cost+p\\n                    q += [(nei, k+1, cost+p)]\\n                \\n        return seen[dst] if seen[dst] < float(\\'inf\\') else -1\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef findCheapestPrice(self, n, flights, src, dst, K):\\n        if src == dst: return 0\\n        d, seen = collections.defaultdict(list), collections.defaultdict(lambda: float(\\'inf\\'))\\n        for u, v, p in flights:\\n            d[u] += [(v, p)]\\n    \\n        q = [(src, -1, 0)]\\n        \\n        while q:\\n            pos, k, cost = q.pop(0)\\n            if pos == dst or k == K: continue \\n            for nei, p in d[pos]:\\n                if cost + p >= seen[nei]:\\n                    continue\\n                else:\\n                    seen[nei] = cost+p\\n                    q += [(nei, k+1, cost+p)]\\n                \\n        return seen[dst] if seen[dst] < float(\\'inf\\') else -1\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1601771,
                "title": "clean-python-solution-self-explained-dijkstra",
                "content": "```python\\n\"\"\"\\nStandard Dijkstra, except this time instead of only explore the ones with least price\\nWe also need to explore the ones with less steps. So add stepFromSrc to check.\\n\\nTime: O(ELogE), since there will be at most E edges that get pushed into the heap.\\nSpace: O(E)\\n\"\"\"\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        priceFromSrc = {}\\n        stepFromSrc = {}\\n        h = [(0, 0, src)]\\n        G = collections.defaultdict(list)\\n        \\n        #build graph\\n        for s, d, p in flights:\\n            G[s].append((d, p))\\n        \\n        #dijkstra\\n        while h:\\n            price, k, node = heapq.heappop(h)\\n            \\n            if node==dst: return price\\n            if k>K: continue\\n            \\n            for nei, price2 in G[node]:\\n\\t\\t\\t\\t#explore next destination with less price or less steps\\n                if nei not in priceFromSrc or price+price2<=priceFromSrc[nei] or k<stepFromSrc[nei]:\\n                    priceFromSrc[nei] = price+price2\\n                    stepFromSrc[nei] = k\\n                    heapq.heappush(h, (price+price2, k+1, nei))\\n                    \\n        return -1\\n\"\"\"\\nFor more other topics, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\"\"\"\\nStandard Dijkstra, except this time instead of only explore the ones with least price\\nWe also need to explore the ones with less steps. So add stepFromSrc to check.\\n\\nTime: O(ELogE), since there will be at most E edges that get pushed into the heap.\\nSpace: O(E)\\n\"\"\"\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        priceFromSrc = {}\\n        stepFromSrc = {}\\n        h = [(0, 0, src)]\\n        G = collections.defaultdict(list)\\n        \\n        #build graph\\n        for s, d, p in flights:\\n            G[s].append((d, p))\\n        \\n        #dijkstra\\n        while h:\\n            price, k, node = heapq.heappop(h)\\n            \\n            if node==dst: return price\\n            if k>K: continue\\n            \\n            for nei, price2 in G[node]:\\n\\t\\t\\t\\t#explore next destination with less price or less steps\\n                if nei not in priceFromSrc or price+price2<=priceFromSrc[nei] or k<stepFromSrc[nei]:\\n                    priceFromSrc[nei] = price+price2\\n                    stepFromSrc[nei] = k\\n                    heapq.heappush(h, (price+price2, k+1, nei))\\n                    \\n        return -1\\n\"\"\"\\nFor more other topics, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227079,
                "title": "go-golang-python-explanation-with-2-examples-on-dijkstra-s-algorithm-variation",
                "content": "Go(golang)\\n---\\n\\nIn short, it is slow but it helps me to understand the Dijkstra\\'s Algorithm and the Priority Queue implementation. Since I haven\\'t found any discussion threads in Go, I tried to implement it (and submitted it) in Go and hope to help other Go engineers.\\n\\n**Explanation**\\nApparently, It is based on Dijkstra\\'s algorithm. However, since we have an **extra depth constraint**, we are going to **keep the paths** in the queue and **skip using a hashtable** such that we can consider all other possible paths.\\n\\n**The Trickiest Part 1**\\nWhy the first item found to the destination has the least cost???\\n\\nConsider an example,\\n```\\nn=4\\nflights = [[0,1,10],[0,2,20],[1,3,100],[2,3,1]]\\nsrc = 0\\ndst = 3\\nK = 1\\n```\\n**You may worry that the result will be 110**, but actually it doesn\\'t, let\\'s see the reason.\\n\\nLet\\'s go through the iterations of `for pq.Len() > 0`, (in readme for readabilty \\uD83E\\uDD13)\\n```\\nafter 1st iteration: pq will have [10, 20], 10 is 0->1, 20 is 0->2\\nafter 2nd iteration: pq will have [20, 110], 20 is 0->2, 110 is 0->1->3(arrived destination but it is not prioritized due to its high cost)\\nafter 3rd iteration: pq will have [21, 110], 21 is 0->2->3, 110 is 0->1->3\\nafter 4th iteration: since 21 has arrived the destination, we return it as a result\\n```\\n\\n**The Trickiest Part 2**\\n**Why dont we use a hastable** to avoid visiting a node again, like the original Dijkstra\\'s Algorithm?\\n\\nLet\\'s consider a test case\\n```\\nn=4\\nflights = [[0, 1, 1], [0, 2, 5], [1, 2, 1], [2, 3, 1]]\\nsrc = 0\\ndst = 3\\nK = 1\\n```\\nAccording to the original Dijkstra\\'s Algorithm, if we use a hashtable to fix the point as a route member and never visit again, **we will end up missing other paths which have less steps to the destination**.\\n\\nLet\\'s go through the iterations,\\n```\\nafter 1st iteration: pq will have [1, 5], 1 is 0->1, 5 is 0->2\\nafter 2nd iteration: pq will have [2, 5], 2 is 0->1->2, 5 is 0->2 (u see, here we have 2 paths to point2. if we set the 2(0->1->2) in the hashtable and never visit 2 again, we will miss the 5(0->2) which later reaches to the destination)\\nafter 3rd iteration: pq will have [5], 5 is 0->2, we popped 2 and do nothing because its steps-1 == K\\nafter 4th iteration: pq will have [6], 6 is 0->2->3, since 6 has arrived the destination, we return it as a result\\n```\\n\\n**Main function**\\n```go\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n\\n\\t// put flights into a hashtable for lookup\\n\\tflightsMap := make(map[int][][]int)\\n\\tfor _, flight := range flights {\\n\\t\\tfrom := flight[0]\\n\\t\\tif _, x := flightsMap[from]; x {\\n\\t\\t\\tflightsMap[from] = append(flightsMap[from], flight)\\n\\t\\t} else {\\n\\t\\t\\tflightsMap[from] = [][]int{flight}\\n\\t\\t}\\n\\t}\\n\\t// dijkstra\\'s\\n\\tpq := &PriorityQueue{}\\n\\theap.Init(pq)\\n\\theap.Push(pq, &Item{0, src, 0, 0})\\n\\tfor pq.Len() > 0 {\\n\\t\\titem := heap.Pop(pq).(*Item)\\n\\n\\t\\t// this is the trickiest part 1: why first item found is the result?\\n\\t\\tif item.Location == dst {\\n\\t\\t\\treturn item.Cost\\n\\t\\t}\\n\\t\\t\\n\\t\\t// the trickiest part 2: why dont we use a hastable to avoid visiting again?\\n\\n\\t\\tif item.Steps-1 == K {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif _, x := flightsMap[item.Location]; x {\\n\\t\\t\\tcandidates := flightsMap[item.Location]\\n\\t\\t\\tfor _, can := range candidates {\\n\\t\\t\\t\\ti := pq.Len()\\n\\t\\t\\t\\theap.Push(pq, &Item{item.Cost + can[2], can[1], item.Steps + 1, i})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\\n\\n**Priority Queue**\\nReference: https://golang.org/pkg/container/heap/#example__priorityQueue\\n```\\ntype Item struct {\\n\\tCost     int // The priority of the item in the queue.\\n\\tLocation int // The value of the item; arbitrary.\\n\\tSteps    int // The value of the item; arbitrary.\\n\\t// The index is needed by update and is maintained by the heap.Interface methods.\\n\\tIndex int // The index of the item in the heap.\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\t// We want Pop to give us the highest, not lowest, priority so we use greater than here.\\n\\treturn pq[i].Cost < pq[j].Cost\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].Index = i\\n\\tpq[j].Index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.Index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\titem.Index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n// update modifies the priority and value of an Item in the queue.\\nfunc (pq *PriorityQueue) update(item *Item, cost int, location int, steps int) {\\n\\titem.Cost = cost\\n\\titem.Location = location\\n\\titem.Steps = steps\\n\\theap.Fix(pq, item.Index)\\n}\\n```\\n\\nPython\\n---\\nGive my explanation above. In python, **I want to show you the nuance** how the original Dijkstra\\'s Algorithm can be modified for this question. **I deliberately leave the commented-out lines** which we usually do in the traditional Dijkstra\\'s Algorithm.\\n\\n```\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        \"\"\"\\n        Depth-limied Dijkstra\\'s Algorithm\\n        56ms beats 33.33%\\n        27jan2019\\n        \"\"\"\\n        flightsMap = {}\\n        for flight in flights:\\n            key = flight[0]\\n            if key in flightsMap:\\n                flightsMap[key].append(flight)\\n            else:\\n                flightsMap[key] = [flight]\\n\\n        # dijkstra\\'s\\n        heap = [(0, (src, 0))]\\n        # seen = {}\\n        while len(heap) > 0:\\n            cost, node = heapq.heappop(heap)\\n            location = node[0]\\n            steps = node[1]\\n\\n            # if location in seen and cost <= seen[location]:\\n            #     continue\\n            # seen[location] = cost\\n\\n            if location == dst:\\n                return cost\\n\\n            if steps-1 == K:\\n                continue\\n\\n            if location in flightsMap:\\n                candidates = flightsMap[location]\\n                for can in candidates:\\n                    # if can[1] not in seen:\\n                    temp = (can[1], steps+1)\\n                    heapq.heappush(heap, (cost+can[2], temp))\\n\\n        # if dst in seen:\\n        #     return seen[dst]\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nn=4\\nflights = [[0,1,10],[0,2,20],[1,3,100],[2,3,1]]\\nsrc = 0\\ndst = 3\\nK = 1\\n```\n```\\nafter 1st iteration: pq will have [10, 20], 10 is 0->1, 20 is 0->2\\nafter 2nd iteration: pq will have [20, 110], 20 is 0->2, 110 is 0->1->3(arrived destination but it is not prioritized due to its high cost)\\nafter 3rd iteration: pq will have [21, 110], 21 is 0->2->3, 110 is 0->1->3\\nafter 4th iteration: since 21 has arrived the destination, we return it as a result\\n```\n```\\nn=4\\nflights = [[0, 1, 1], [0, 2, 5], [1, 2, 1], [2, 3, 1]]\\nsrc = 0\\ndst = 3\\nK = 1\\n```\n```\\nafter 1st iteration: pq will have [1, 5], 1 is 0->1, 5 is 0->2\\nafter 2nd iteration: pq will have [2, 5], 2 is 0->1->2, 5 is 0->2 (u see, here we have 2 paths to point2. if we set the 2(0->1->2) in the hashtable and never visit 2 again, we will miss the 5(0->2) which later reaches to the destination)\\nafter 3rd iteration: pq will have [5], 5 is 0->2, we popped 2 and do nothing because its steps-1 == K\\nafter 4th iteration: pq will have [6], 6 is 0->2->3, since 6 has arrived the destination, we return it as a result\\n```\n```go\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n\\n\\t// put flights into a hashtable for lookup\\n\\tflightsMap := make(map[int][][]int)\\n\\tfor _, flight := range flights {\\n\\t\\tfrom := flight[0]\\n\\t\\tif _, x := flightsMap[from]; x {\\n\\t\\t\\tflightsMap[from] = append(flightsMap[from], flight)\\n\\t\\t} else {\\n\\t\\t\\tflightsMap[from] = [][]int{flight}\\n\\t\\t}\\n\\t}\\n\\t// dijkstra\\'s\\n\\tpq := &PriorityQueue{}\\n\\theap.Init(pq)\\n\\theap.Push(pq, &Item{0, src, 0, 0})\\n\\tfor pq.Len() > 0 {\\n\\t\\titem := heap.Pop(pq).(*Item)\\n\\n\\t\\t// this is the trickiest part 1: why first item found is the result?\\n\\t\\tif item.Location == dst {\\n\\t\\t\\treturn item.Cost\\n\\t\\t}\\n\\t\\t\\n\\t\\t// the trickiest part 2: why dont we use a hastable to avoid visiting again?\\n\\n\\t\\tif item.Steps-1 == K {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif _, x := flightsMap[item.Location]; x {\\n\\t\\t\\tcandidates := flightsMap[item.Location]\\n\\t\\t\\tfor _, can := range candidates {\\n\\t\\t\\t\\ti := pq.Len()\\n\\t\\t\\t\\theap.Push(pq, &Item{item.Cost + can[2], can[1], item.Steps + 1, i})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\n```\\ntype Item struct {\\n\\tCost     int // The priority of the item in the queue.\\n\\tLocation int // The value of the item; arbitrary.\\n\\tSteps    int // The value of the item; arbitrary.\\n\\t// The index is needed by update and is maintained by the heap.Interface methods.\\n\\tIndex int // The index of the item in the heap.\\n}\\n\\n// A PriorityQueue implements heap.Interface and holds Items.\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\t// We want Pop to give us the highest, not lowest, priority so we use greater than here.\\n\\treturn pq[i].Cost < pq[j].Cost\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n\\tpq[i].Index = i\\n\\tpq[j].Index = j\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.Index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\titem.Index = -1 // for safety\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n// update modifies the priority and value of an Item in the queue.\\nfunc (pq *PriorityQueue) update(item *Item, cost int, location int, steps int) {\\n\\titem.Cost = cost\\n\\titem.Location = location\\n\\titem.Steps = steps\\n\\theap.Fix(pq, item.Index)\\n}\\n```\n```\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        \"\"\"\\n        Depth-limied Dijkstra\\'s Algorithm\\n        56ms beats 33.33%\\n        27jan2019\\n        \"\"\"\\n        flightsMap = {}\\n        for flight in flights:\\n            key = flight[0]\\n            if key in flightsMap:\\n                flightsMap[key].append(flight)\\n            else:\\n                flightsMap[key] = [flight]\\n\\n        # dijkstra\\'s\\n        heap = [(0, (src, 0))]\\n        # seen = {}\\n        while len(heap) > 0:\\n            cost, node = heapq.heappop(heap)\\n            location = node[0]\\n            steps = node[1]\\n\\n            # if location in seen and cost <= seen[location]:\\n            #     continue\\n            # seen[location] = cost\\n\\n            if location == dst:\\n                return cost\\n\\n            if steps-1 == K:\\n                continue\\n\\n            if location in flightsMap:\\n                candidates = flightsMap[location]\\n                for can in candidates:\\n                    # if can[1] not in seen:\\n                    temp = (can[1], steps+1)\\n                    heapq.heappush(heap, (cost+can[2], temp))\\n\\n        # if dst in seen:\\n        #     return seen[dst]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100952,
                "title": "c-bfs-bellman-ford-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan use BFS,Dijksta\\'s Algo,Bellman Ford Algo only thing is check  for stops not exceeding k rest is same as before.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- BFS\\n- Bellman Ford Algo\\n# Complexity\\n- Time complexity:$$O(N*K)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**BFS**\\n```\\nclass Solution {\\npublic:\\n   \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int S, int dst, int k) {\\n        // shortest path algo with a little variation\\n         vector<vector<pair<int, int>>> adj(n);\\n        for (auto& e : flights) {\\n            adj[e[0]].push_back({e[1], e[2]});\\n        }\\n         vector<int>dis(n,INT_MAX);\\n        dis[S]=0;\\n        queue<pair<int,int>>pq;\\n        pq.push({0,S});\\n        int stops=0;\\n        while(stops<=k and !pq.empty()){\\n            int sz=pq.size();\\n            while(sz--){ \\n            auto [dist,node]=pq.front();\\n            pq.pop();\\n            for(auto& [nb,cost]:adj[node]){\\n                int temp=cost+dist;\\n                if(dis[nb]>temp){\\n                    dis[nb]=temp;\\n                    pq.push({temp,nb});\\n                }\\n            }\\n            }\\n            stops++;\\n        }\\n      \\n        return dis[dst]==INT_MAX?-1:dis[dst];\\n    \\n    }\\n};\\n```\\n**BELL MAN FORD ALGO**\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int S, int dst, int k) {\\n        // shortest path algo with a little variation\\n      \\n         vector<int>dis(n,INT_MAX);\\n        dis[S]=0;\\n        for(int i=0;i<=k;i++){\\n            vector<int>temp(dis);\\n            for(auto x:flights){\\n               if(dis[x[0]]!=INT_MAX){\\n                   temp[x[1]]=min(temp[x[1]],dis[x[0]]+x[2]);\\n               }\\n            }\\n            dis=temp;\\n        }\\n      return dis[dst] == INT_MAX ? -1 : dis[dst];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int S, int dst, int k) {\\n        // shortest path algo with a little variation\\n         vector<vector<pair<int, int>>> adj(n);\\n        for (auto& e : flights) {\\n            adj[e[0]].push_back({e[1], e[2]});\\n        }\\n         vector<int>dis(n,INT_MAX);\\n        dis[S]=0;\\n        queue<pair<int,int>>pq;\\n        pq.push({0,S});\\n        int stops=0;\\n        while(stops<=k and !pq.empty()){\\n            int sz=pq.size();\\n            while(sz--){ \\n            auto [dist,node]=pq.front();\\n            pq.pop();\\n            for(auto& [nb,cost]:adj[node]){\\n                int temp=cost+dist;\\n                if(dis[nb]>temp){\\n                    dis[nb]=temp;\\n                    pq.push({temp,nb});\\n                }\\n            }\\n            }\\n            stops++;\\n        }\\n      \\n        return dis[dst]==INT_MAX?-1:dis[dst];\\n    \\n    }\\n};\\n```\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int S, int dst, int k) {\\n        // shortest path algo with a little variation\\n      \\n         vector<int>dis(n,INT_MAX);\\n        dis[S]=0;\\n        for(int i=0;i<=k;i++){\\n            vector<int>temp(dis);\\n            for(auto x:flights){\\n               if(dis[x[0]]!=INT_MAX){\\n                   temp[x[1]]=min(temp[x[1]],dis[x[0]]+x[2]);\\n               }\\n            }\\n            dis=temp;\\n        }\\n      return dis[dst] == INT_MAX ? -1 : dis[dst];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099936,
                "title": "easy-solution-fully-explained-c-dijkstra-algorithm-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                  Please Upvote If You Find It Helpful.\\n```\\n# Approach: Using Dijkstra\\'s Algorithm\\n<!-- Describe your approach to solving the problem. -->\\nTime Complexity : O(E)\\nSpace Complexity : O(E)\\n\\n# Code\\n```\\n#define pi pair<int, pair<int,int>>\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Create an adjacency list to represent the flights\\n        vector<pair<int, int>> adj[n];\\n        for(auto it : flights){\\n            // for each flight, add an edge from the source city to the destination city with the price of the flight\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        // Create a queue to store the current node, the number of stops, and the price\\n        queue<pi> q;\\n        // Create an array to store the minimum price to reach each city\\n        vector<int> dist(n, 1e9);\\n        // Add the source city with 0 stops and 0 cost {stops,{node, price}}\\n        q.push({0, {src, 0}});\\n        dist[src] = 0;\\n        // Loop through the queue until it is empty\\n        while(!q.empty()){\\n            int stop = q.front().first;\\n            int node = q.front().second.first, price = q.front().second.second;\\n            q.pop();\\n            // If the number of stops is greater than the allowed stops, continue\\n            if(stop > k) continue;\\n            // For each adjacent city, update the minimum price if a cheaper path is found\\n            for(auto it:adj[node]){\\n                int adjN = it.first;\\n                int Nprice = it.second;\\n                if(dist[adjN] > price + Nprice && stop<=k){\\n                    dist[adjN] = price + Nprice;\\n                    q.push({stop+1, {adjN, dist[adjN]}});\\n                }\\n            }\\n        }\\n        // If the minimum price to reach the destination is still the maximum value, return -1\\n        if(dist[dst]==1e9) return -1;\\n        // Otherwise, return the minimum price\\n        return dist[dst];\\n    }\\n};\\n```\\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On[ Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n                  Please Upvote If You Find It Helpful.\\n```\n```\\n#define pi pair<int, pair<int,int>>\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Create an adjacency list to represent the flights\\n        vector<pair<int, int>> adj[n];\\n        for(auto it : flights){\\n            // for each flight, add an edge from the source city to the destination city with the price of the flight\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        // Create a queue to store the current node, the number of stops, and the price\\n        queue<pi> q;\\n        // Create an array to store the minimum price to reach each city\\n        vector<int> dist(n, 1e9);\\n        // Add the source city with 0 stops and 0 cost {stops,{node, price}}\\n        q.push({0, {src, 0}});\\n        dist[src] = 0;\\n        // Loop through the queue until it is empty\\n        while(!q.empty()){\\n            int stop = q.front().first;\\n            int node = q.front().second.first, price = q.front().second.second;\\n            q.pop();\\n            // If the number of stops is greater than the allowed stops, continue\\n            if(stop > k) continue;\\n            // For each adjacent city, update the minimum price if a cheaper path is found\\n            for(auto it:adj[node]){\\n                int adjN = it.first;\\n                int Nprice = it.second;\\n                if(dist[adjN] > price + Nprice && stop<=k){\\n                    dist[adjN] = price + Nprice;\\n                    q.push({stop+1, {adjN, dist[adjN]}});\\n                }\\n            }\\n        }\\n        // If the minimum price to reach the destination is still the maximum value, return -1\\n        if(dist[dst]==1e9) return -1;\\n        // Otherwise, return the minimum price\\n        return dist[dst];\\n    }\\n};\\n```\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693599,
                "title": "detailed-c-standard-approaches-bfs-approach",
                "content": "It could be solved using **Dijkstra algorithm**, But it could have been easily solved using a simple modified **BFS**!!\\n\\nSpace Complexity: **```O(e * k) + O(n)```**\\nTime Complexity: **```O(e * k)```**\\n(Queue will store at max **(e * k)** nodes for the same reason and push or pop requires **O(1)** time.)\\n\\n**C++ code (BFS) :**\\n```\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // initialize the adjacency list, distance and queue\\n        vector<pair<int, int>> adj[n];\\n        vector<int> dis(n, 1e9);\\n        queue<vector<int>> q;\\n        \\n        // make the adjacency list\\n        for(auto it: flights){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        \\n        // push the src node to the queue\\n        q.push({0, src, 0});\\n        // mark the distance as 0 (i.e it is the first element)\\n        dis[src] = 0;\\n        \\n        // until queue is empty do the operation\\n        while(!q.empty()){\\n            // take the first element of the queue\\n            int stop = q.front()[0];\\n            int node = q.front()[1];\\n            int cost = q.front()[2];\\n            // remove the first element\\n            q.pop();\\n            \\n            // if we reach destination with k+1 move then stop \\n            // iteration as we reached destination with atmost \\n            // k stops \\n            if(stop > k) continue;\\n            \\n            // check all its adjacent edges\\n            for(auto it: adj[node]){\\n                int adjNode = it.first;\\n                int weight = it.second;\\n                \\n                if(cost + weight < dis[adjNode]) {\\n                    dis[adjNode] = cost + weight;  // update the distance \\n                    q.push({stop+1, adjNode, cost + weight});  // push the adj element and new distance into queue\\n                }\\n            }\\n        }\\n        \\n        // if the distance of the dst is not changed the return -1\\n        // as it is not possible to reach destination\\n        return dis[dst] == 1e9 ? -1 : dis[dst];\\n    }\\n};\\n\\n```\\n\\nPLease upvote if you find this helpful. **:)**\\nFeel free to comment in case of any doubt.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```O(e * k) + O(n)```\n```O(e * k)```\n```\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // initialize the adjacency list, distance and queue\\n        vector<pair<int, int>> adj[n];\\n        vector<int> dis(n, 1e9);\\n        queue<vector<int>> q;\\n        \\n        // make the adjacency list\\n        for(auto it: flights){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        \\n        // push the src node to the queue\\n        q.push({0, src, 0});\\n        // mark the distance as 0 (i.e it is the first element)\\n        dis[src] = 0;\\n        \\n        // until queue is empty do the operation\\n        while(!q.empty()){\\n            // take the first element of the queue\\n            int stop = q.front()[0];\\n            int node = q.front()[1];\\n            int cost = q.front()[2];\\n            // remove the first element\\n            q.pop();\\n            \\n            // if we reach destination with k+1 move then stop \\n            // iteration as we reached destination with atmost \\n            // k stops \\n            if(stop > k) continue;\\n            \\n            // check all its adjacent edges\\n            for(auto it: adj[node]){\\n                int adjNode = it.first;\\n                int weight = it.second;\\n                \\n                if(cost + weight < dis[adjNode]) {\\n                    dis[adjNode] = cost + weight;  // update the distance \\n                    q.push({stop+1, adjNode, cost + weight});  // push the adj element and new distance into queue\\n                }\\n            }\\n        }\\n        \\n        // if the distance of the dst is not changed the return -1\\n        // as it is not possible to reach destination\\n        return dis[dst] == 1e9 ? -1 : dis[dst];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218027,
                "title": "c-dijkstra-variation-bellman-ford",
                "content": "**1. Dijkstra Variation:**\\n**Note**: This problem can\\'t be solved through Dijkstra without modification. Dijkstra will only revisit path with miniumum weight, but that\\'s not sufficient, we also need to revisit node having higher weight but lesser stops.\\n\\n```\\nFor E.g:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\n0\\n2\\n2\\n\\nDijkstra will assign node 1 weight 4: 0 -> 3 -> 1. Then it will travel node to node 2: 0 -> 3 -> 1 -> 2 giving weight 9.\\nAs soon as we change weight of 1 from 5 to 4 and add a stop through normal Dijkstra, we can\\'t reach correct solution,\\nwhich is to reach node 2 through 0 -> 1 -> 4 -> 2 with weight 7.\\n```\\n**Sum Up**: We need to modify Dijkstra, to consider 2nd path 0->1 even if node 1 has weight 5, but has only 1 stop unlike 1st path where node 1 takes 2 stops.\\n\\nBelow is the code applying same thing, a dry run on above example will improve understanding of this method.\\n**T.C** - O(v + elogv)\\n```\\n#define tii tuple<int, int, int>\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pii> adjList[n];\\n        for(auto& flight: flights){\\n            int source = flight[0], dest = flight[1], price = flight[2];\\n            adjList[source].push_back({dest, price});\\n        }\\n        return dijkstraVariation(adjList, n, src, dst, k);\\n    }\\n    \\n    int dijkstraVariation(vector<pii> adjList[], int n, int node, int dst, int k){\\n        priority_queue<tii, vector<tii>, greater<tii>> minHeap;\\n        vector<int> stops(n, INT_MAX), distance(n, INT_MAX);\\n        \\n        int minDist = INT_MAX;\\n        stops[node] = 0;\\n        distance[node] = 0;\\n        minHeap.push({0,node,0});\\n        \\n        while(!minHeap.empty()){\\n            auto [curDist, curNode, curStops] = minHeap.top();\\n            \\n            minHeap.pop();\\n            if(curNode == dst) return curDist;\\n            if(curStops == k+1) continue;\\n            \\n            auto neighbors = adjList[curNode];\\n            for(auto& neighborPair :neighbors){\\n                int neighbor = neighborPair.first, edgeWt = neighborPair.second;\\n                int nextDistance = curDist + edgeWt, nextStops = curStops+1;\\n                \\n                //This if check is same as normal Dijkstraz: Don\\'t forget to update both distance and stops.\\n                if(distance[neighbor] > nextDistance ){\\n                    distance[neighbor] = nextDistance;\\n                    stops[neighbor] = nextStops;\\n                    minHeap.push({nextDistance, neighbor, nextStops});\\n                }\\n                \\n                //This is main variation from Dijkstra: Don\\'t forget to update both distance and stops.\\n                else if(nextStops < stops[neighbor]){\\n                    distance[neighbor] = nextDistance;\\n                    stops[neighbor] = nextStops;\\n                    minHeap.push({nextDistance, neighbor, nextStops});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**2. Bellman Ford**\\nThis problem can be solved using Bellman Ford algorithm by performing k+1 relaxations, that\\'s it, if after k+1 relaxations price is not INT_MAX, then return price otherwise return -1.\\n\\n**Why we need tempPrice?**\\nLet\\'s take an example.\\n```\\n3\\n[[0,1,100],[1,2,100],[1,2,500]]\\n0\\n2\\n0\\n```\\n\\nYou can take 0 stops in going from 0 to 2, suppose you didn\\'t take temp array, and are making changes directly in price array.\\nYou will make k+1 -> 0+1 = 1 relaxation only.\\n\\n**Let\\'s start: (Not taking temp array)**\\n0 -> 1, original price = price[1] = Infinity, new price = 0+100 -> price[1] = 100.\\n1 -> 2, original price = price[2] = Infinity, new price = 100+100 -> price[2] = 200.\\n0 -> 2, original price = price[2] = 200 (calculated just above) < 500 -> No update.\\n\\nYou see, just because, changes were made directly to price array, we didn\\'t know that we took a stop at 1, and then moved to 2 from 1, that contradicted the condition that we can\\'t take any stops in between.\\n\\nIf you took temp array:\\n**Let\\'s start: (Taking temp array)**\\n0 -> 1, original price = price[1] = Infinity, new price = 0+100 -> tempPrice[1] = 100. //tempPrice is updated, not price.\\n1 -> 2, original price = price[2] = Infinity, new price = price[1] (Infinity) + 100 -> tempPrice[2] = Infinity.\\n0 -> 2, original price = price[2] = Infinity,new price = price[0] + 500 -> which is smaller than infinity -> Update tempPrice[2] = 500.\\n\\nHence price[2] = 500 taking 0 stops in between.\\n\\n**T.C** - \\nBellman Ford: O(ExV)\\nBut, since we have to relax k+1 times: O(ExK)\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        return bellmanFordVariation(flights, n, src, dst, k);\\n    }\\n    \\n    int bellmanFordVariation(vector<vector<int>>& flights, int n, int src, int dst, int k){\\n        vector<int> price(n, 10000000), tempPrice(n, 10000000);\\n        price[src] = tempPrice[src] = 0;\\n        \\n        //Relax k+1 times\\n        for(int i=1; i<=k+1; i++){\\n            for(auto& edge: flights){\\n                int source = edge[0], destination = edge[1], edgeCost = edge[2];\\n                int newCost = price[source] + edgeCost;\\n                \\n                if(newCost < tempPrice[destination]) tempPrice[destination] = newCost;\\n            }\\n\\n\\t\\t\\t//Copy tempPrice to price\\n            for(int i=0; i<n; i++) price[i] = tempPrice[i];\\n        }\\n        return price[dst] == 10000000 ? -1 : price[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nFor E.g:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\n0\\n2\\n2\\n\\nDijkstra will assign node 1 weight 4: 0 -> 3 -> 1. Then it will travel node to node 2: 0 -> 3 -> 1 -> 2 giving weight 9.\\nAs soon as we change weight of 1 from 5 to 4 and add a stop through normal Dijkstra, we can\\'t reach correct solution,\\nwhich is to reach node 2 through 0 -> 1 -> 4 -> 2 with weight 7.\\n```\n```\\n#define tii tuple<int, int, int>\\n#define pii pair<int, int>\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pii> adjList[n];\\n        for(auto& flight: flights){\\n            int source = flight[0], dest = flight[1], price = flight[2];\\n            adjList[source].push_back({dest, price});\\n        }\\n        return dijkstraVariation(adjList, n, src, dst, k);\\n    }\\n    \\n    int dijkstraVariation(vector<pii> adjList[], int n, int node, int dst, int k){\\n        priority_queue<tii, vector<tii>, greater<tii>> minHeap;\\n        vector<int> stops(n, INT_MAX), distance(n, INT_MAX);\\n        \\n        int minDist = INT_MAX;\\n        stops[node] = 0;\\n        distance[node] = 0;\\n        minHeap.push({0,node,0});\\n        \\n        while(!minHeap.empty()){\\n            auto [curDist, curNode, curStops] = minHeap.top();\\n            \\n            minHeap.pop();\\n            if(curNode == dst) return curDist;\\n            if(curStops == k+1) continue;\\n            \\n            auto neighbors = adjList[curNode];\\n            for(auto& neighborPair :neighbors){\\n                int neighbor = neighborPair.first, edgeWt = neighborPair.second;\\n                int nextDistance = curDist + edgeWt, nextStops = curStops+1;\\n                \\n                //This if check is same as normal Dijkstraz: Don\\'t forget to update both distance and stops.\\n                if(distance[neighbor] > nextDistance ){\\n                    distance[neighbor] = nextDistance;\\n                    stops[neighbor] = nextStops;\\n                    minHeap.push({nextDistance, neighbor, nextStops});\\n                }\\n                \\n                //This is main variation from Dijkstra: Don\\'t forget to update both distance and stops.\\n                else if(nextStops < stops[neighbor]){\\n                    distance[neighbor] = nextDistance;\\n                    stops[neighbor] = nextStops;\\n                    minHeap.push({nextDistance, neighbor, nextStops});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n3\\n[[0,1,100],[1,2,100],[1,2,500]]\\n0\\n2\\n0\\n```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        return bellmanFordVariation(flights, n, src, dst, k);\\n    }\\n    \\n    int bellmanFordVariation(vector<vector<int>>& flights, int n, int src, int dst, int k){\\n        vector<int> price(n, 10000000), tempPrice(n, 10000000);\\n        price[src] = tempPrice[src] = 0;\\n        \\n        //Relax k+1 times\\n        for(int i=1; i<=k+1; i++){\\n            for(auto& edge: flights){\\n                int source = edge[0], destination = edge[1], edgeCost = edge[2];\\n                int newCost = price[source] + edgeCost;\\n                \\n                if(newCost < tempPrice[destination]) tempPrice[destination] = newCost;\\n            }\\n\\n\\t\\t\\t//Copy tempPrice to price\\n            for(int i=0; i<n; i++) price[i] = tempPrice[i];\\n        }\\n        return price[dst] == 10000000 ? -1 : price[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684443,
                "title": "javascript-10-lines-of-sweet-bellman-ford",
                "content": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    let M = Array(n).fill().map((_, i) => i===src ? 0 : Infinity);\\n    for(let k=0; k<K+1; k++) {\\n        let N = [...M];\\n        for(let [from, to, price] of flights) {\\n            N[to] = Math.min(N[to], M[from] + price);\\n        }\\n        M = [...N];\\n    }\\n    return M[dst] != Infinity ? M[dst] : -1\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    let M = Array(n).fill().map((_, i) => i===src ? 0 : Infinity);\\n    for(let k=0; k<K+1; k++) {\\n        let N = [...M];\\n        for(let [from, to, price] of flights) {\\n            N[to] = Math.min(N[to], M[from] + price);\\n        }\\n        M = [...N];\\n    }\\n    return M[dst] != Infinity ? M[dst] : -1\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 405376,
                "title": "swift-bfs-easy-to-understand",
                "content": "We will be using BFS to solve this question.\\n\\n1. Create a graph where the key is the departure city and the value is the arrival city and the flight cost.\\n2. Create a queue that contains an object which keeps track of the current city, number of stops and the total running cost.\\n3. Populate the queue with the first city and the number of stops (0) with the total running cost (0). \\n4. For each element in the queue we will travel to each neighboring city and keep track of the number of stops and running costs.\\n5. Stop exploring if the current city is the destination city or the total running cost is greater than the minimum cost or the number of stops is greater than K.\\n\\n```\\ntypealias element = (city: Int, stops: Int, runningCost: Int)\\n\\nfunc findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ K: Int) -> Int {\\n\\tvar graph = [Int:[(Int, Int)]]()\\n\\n\\tfor flight in flights {\\n\\t\\tgraph[flight[0], default: []].append((flight[1], flight[2]))\\n\\t}\\n\\n\\tvar queue = [element]()\\n\\tqueue.append((city: src, stops: 0, runningCost: 0))\\n\\n\\tvar minCost = Int.max\\n\\n\\twhile !queue.isEmpty {\\n\\t\\tlet (city, stops, runningCost) = queue.removeFirst()\\n\\n\\t\\tif city == dst {\\n\\t\\t\\tminCost = min(minCost, runningCost)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif stops > K || runningCost > minCost {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor (nextCity, flightCost) in graph[city] ?? [] {\\n\\t\\t\\tqueue.append((nextCity, stops + 1, runningCost + flightCost))\\n\\t\\t}\\n\\t}\\n\\n\\treturn minCost != Int.max ? minCost : -1\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypealias element = (city: Int, stops: Int, runningCost: Int)\\n\\nfunc findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ K: Int) -> Int {\\n\\tvar graph = [Int:[(Int, Int)]]()\\n\\n\\tfor flight in flights {\\n\\t\\tgraph[flight[0], default: []].append((flight[1], flight[2]))\\n\\t}\\n\\n\\tvar queue = [element]()\\n\\tqueue.append((city: src, stops: 0, runningCost: 0))\\n\\n\\tvar minCost = Int.max\\n\\n\\twhile !queue.isEmpty {\\n\\t\\tlet (city, stops, runningCost) = queue.removeFirst()\\n\\n\\t\\tif city == dst {\\n\\t\\t\\tminCost = min(minCost, runningCost)\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif stops > K || runningCost > minCost {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor (nextCity, flightCost) in graph[city] ?? [] {\\n\\t\\t\\tqueue.append((nextCity, stops + 1, runningCost + flightCost))\\n\\t\\t}\\n\\t}\\n\\n\\treturn minCost != Int.max ? minCost : -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137426,
                "title": "one-line-modification-in-dijstara-algorithm-c",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    vector<vector<pair<int,int>>> graph;\\n    vector<int> dis;\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        graph.resize(n);\\n        dis.resize(n,INT_MAX);\\n        \\n        for(int i = 0 ; i<flights.size() ; i++){\\n            \\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            \\n            graph[u].push_back({v,w});\\n        }\\n        \\n        queue<tuple<int,int,int>> pq;\\n        pq.push({0, src , 0});      //  dis , source , no of stops\\n         \\n        dis[src] = 0;\\n        \\n        while(!pq.empty()){\\n            \\n            auto [d,u,st] = pq.front();\\n            pq.pop();\\n            \\n            \\n            for(auto [v , w] : graph[u]){\\n                \\n                if(d + w < dis[v]  && st<=k){\\n            \\n                    dis[v] = d + w;\\n                    \\n                    pq.push({dis[v], v, st+1});\\n                }\\n                \\n            }\\n        }\\n        \\n        if(dis[dst]==INT_MAX)return -1;\\n        \\n        return dis[dst];\\n        \\n    }\\n    \\n   \\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    vector<vector<pair<int,int>>> graph;\\n    vector<int> dis;\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        graph.resize(n);\\n        dis.resize(n,INT_MAX);\\n        \\n        for(int i = 0 ; i<flights.size() ; i++){\\n            \\n            int u = flights[i][0];\\n            int v = flights[i][1];\\n            int w = flights[i][2];\\n            \\n            graph[u].push_back({v,w});\\n        }\\n        \\n        queue<tuple<int,int,int>> pq;\\n        pq.push({0, src , 0});      //  dis , source , no of stops\\n         \\n        dis[src] = 0;\\n        \\n        while(!pq.empty()){\\n            \\n            auto [d,u,st] = pq.front();\\n            pq.pop();\\n            \\n            \\n            for(auto [v , w] : graph[u]){\\n                \\n                if(d + w < dis[v]  && st<=k){\\n            \\n                    dis[v] = d + w;\\n                    \\n                    pq.push({dis[v], v, st+1});\\n                }\\n                \\n            }\\n        }\\n        \\n        if(dis[dst]==INT_MAX)return -1;\\n        \\n        return dis[dst];\\n        \\n    }\\n    \\n   \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352199,
                "title": "c-easy-solution-explanation-bellman-ford",
                "content": "It is standard Bellman Ford  with just 2 small modifications :\\n1) We won\\'t allow relaxation beyond K to make sure cheapestPrice doesn\\'t have more than K stops\\n2) In each round of relaxation, changes will be done in temporary distance(price) array to ensure current path-length doesn\\'t go beyond current iteration number. \\n\\n( For clear understanding for temp: you may take example of a linear graph with source and destination at two ends and see how normal Bellman Ford behaves if edges are arranged from source to destination vs when using temporary distance array for modifications )\\n\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int end, int k) {\\n        vector<int> dst(n,1e7);\\n        vector<int> temp(n,1e7);\\n        dst[src]=0;\\n        temp[src]=0;\\n        for(int i=0;i<=k;++i)\\n        {\\n            for(vector<int> j:flights)\\n            {\\n                if(temp[j[1]] > dst[j[0]]+j[2])\\n                    temp[j[1]] = dst[j[0]]+j[2];\\n            }\\n            for(int j=0;j<n;++j)\\n                dst[j] = temp[j];\\n        }\\n        if(dst[end]==1e7)\\n            return -1;\\n        else\\n            return dst[end];\\n    }",
                "solutionTags": [],
                "code": "It is standard Bellman Ford  with just 2 small modifications :\\n1) We won\\'t allow relaxation beyond K to make sure cheapestPrice doesn\\'t have more than K stops\\n2) In each round of relaxation, changes will be done in temporary distance(price) array to ensure current path-length doesn\\'t go beyond current iteration number. \\n\\n( For clear understanding for temp: you may take example of a linear graph with source and destination at two ends and see how normal Bellman Ford behaves if edges are arranged from source to destination vs when using temporary distance array for modifications )\\n\\n```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int end, int k) {\\n        vector<int> dst(n,1e7);\\n        vector<int> temp(n,1e7);\\n        dst[src]=0;\\n        temp[src]=0;\\n        for(int i=0;i<=k;++i)\\n        {\\n            for(vector<int> j:flights)\\n            {\\n                if(temp[j[1]] > dst[j[0]]+j[2])\\n                    temp[j[1]] = dst[j[0]]+j[2];\\n            }\\n            for(int j=0;j<n;++j)\\n                dst[j] = temp[j];\\n        }\\n        if(dst[end]==1e7)\\n            return -1;\\n        else\\n            return dst[end];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1233858,
                "title": "java-dijkstra-s-use-visited-map-to-avoid-tle",
                "content": "\\n\\n```\\n \\n public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n        ArrayList<HashMap<Integer,Integer>> map=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            map.add(new HashMap<>());\\n        }\\n        \\n        for(int[] arr:flights){   \\n            map.get(arr[0]).put(arr[1],arr[2]);\\n        }\\n        \\n        Map<Integer, Integer> visited = new HashMap<>();\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[2]-b[2]);\\n        \\n        pq.offer(new int[]{src,-1,0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] rn=pq.poll();\\n            \\n           \\n            int city = rn[0];\\n            int stops = rn[1];\\n            int price = rn[2];\\n           \\n           \\n            if(city==dst){\\n                return price;\\n            }\\n            \\n            visited.put(city, stops); \\n            \\n            if(stops==k)continue;\\n               \\n            \\n                for(int val:map.get(city).keySet()){\\n                     if (!visited.containsKey(val) || stops < visited.get(val)) {\\n                    pq.offer(new int[]{val,stops+1,price+map.get(city).get(val)});\\n                     }\\n                }   \\n         \\n        }\\n        \\n        return -1;\\n   \\n    }\\n,,,",
                "solutionTags": [],
                "code": "\\n\\n```\\n \\n public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n        ArrayList<HashMap<Integer,Integer>> map=new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            map.add(new HashMap<>());\\n        }\\n        \\n        for(int[] arr:flights){   \\n            map.get(arr[0]).put(arr[1],arr[2]);\\n        }\\n        \\n        Map<Integer, Integer> visited = new HashMap<>();\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[2]-b[2]);\\n        \\n        pq.offer(new int[]{src,-1,0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] rn=pq.poll();\\n            \\n           \\n            int city = rn[0];\\n            int stops = rn[1];\\n            int price = rn[2];\\n           \\n           \\n            if(city==dst){\\n                return price;\\n            }\\n            \\n            visited.put(city, stops); \\n            \\n            if(stops==k)continue;\\n               \\n            \\n                for(int val:map.get(city).keySet()){\\n                     if (!visited.containsKey(val) || stops < visited.get(val)) {\\n                    pq.offer(new int[]{val,stops+1,price+map.get(city).get(val)});\\n                     }\\n                }   \\n         \\n        }\\n        \\n        return -1;\\n   \\n    }\\n,,,",
                "codeTag": "Unknown"
            },
            {
                "id": 207128,
                "title": "two-java-solutions-one-is-dp-and-the-other-is-dijkstra",
                "content": "Time Complexity for this solution is O(KN), k is stop and N is the number of cities\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        //dp[i][j] denotes the cheapest price within i-1 stops, stop in j city\\n        long[][] dp = new long[K+2][n];\\n        for (long[] d : dp) Arrays.fill(d, Integer.MAX_VALUE);\\n        dp[0][src] = 0;\\n        for (int i = 1; i < K+2; i++) {\\n            dp[i][src] = 0;\\n            for (int[] f : flights) {\\n                dp[i][f[1]] = Math.min(dp[i][f[1]], dp[i-1][f[0]] + f[2]);\\n            }\\n        }\\n        return dp[K+1][dst] == Integer.MAX_VALUE ? -1 : (int)dp[K+1][dst];\\n    }\\n```\\nTime Complexity is O(ElogV) E is the length of flights and V is the number of cities\\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new HashMap<>());\\n        for (int[] f : flights){\\n            map.get(f[0]).put(f[1], f[2]);\\n        } \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) ->a[0]-b[0]);\\n        pq.add(new int[] {0, src, -1});\\n        while (!pq.isEmpty()) {\\n            int[] temp = pq.poll();\\n            int cost = temp[0], ID = temp[1], stop = temp[2];\\n            if (ID == dst) return cost;\\n            if (stop < k) {\\n                Map<Integer, Integer> hs = map.getOrDefault(ID, new HashMap<>());\\n                for (int a : hs.keySet()) {\\n                    pq.add(new int[] {cost + hs.get(a), a, stop+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        //dp[i][j] denotes the cheapest price within i-1 stops, stop in j city\\n        long[][] dp = new long[K+2][n];\\n        for (long[] d : dp) Arrays.fill(d, Integer.MAX_VALUE);\\n        dp[0][src] = 0;\\n        for (int i = 1; i < K+2; i++) {\\n            dp[i][src] = 0;\\n            for (int[] f : flights) {\\n                dp[i][f[1]] = Math.min(dp[i][f[1]], dp[i-1][f[0]] + f[2]);\\n            }\\n        }\\n        return dp[K+1][dst] == Integer.MAX_VALUE ? -1 : (int)dp[K+1][dst];\\n    }\\n```\n```\\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) map.put(i, new HashMap<>());\\n        for (int[] f : flights){\\n            map.get(f[0]).put(f[1], f[2]);\\n        } \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) ->a[0]-b[0]);\\n        pq.add(new int[] {0, src, -1});\\n        while (!pq.isEmpty()) {\\n            int[] temp = pq.poll();\\n            int cost = temp[0], ID = temp[1], stop = temp[2];\\n            if (ID == dst) return cost;\\n            if (stop < k) {\\n                Map<Integer, Integer> hs = map.getOrDefault(ID, new HashMap<>());\\n                for (int a : hs.keySet()) {\\n                    pq.add(new int[] {cost + hs.get(a), a, stop+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3100173,
                "title": "c-bfs-solution-very-easy-dijkstra-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBreadth-First Search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- maintain a adj list with src -> {dst,cost}\\n- make a queue for pending node(pn)\\n- push stops,node,cost\\n- a distance vector & dist of src = 0\\n- perform normal BFS & check if adj[node] dist can be change within stops <=k\\n- if yes then update dist[currnode] & push to queue {stops+1,{currnode,updatedcost}}\\n- return dist[dst]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto it : flights){\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        queue<pair<int,pair<int,int>>> pn;\\n        pn.push({0,{src,0}});\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        while(!pn.empty()){\\n            auto front = pn.front();\\n            pn.pop();\\n            int stops = front.first;\\n            int node = front.second.first;\\n            int distance = front.second.second;\\n            if(stops>k)continue;\\n            for(auto it:adj[node]){\\n                int adjnode = it.first;\\n                int d = it.second;\\n                if(distance + d<dist[adjnode]&&stops<=k){\\n                    dist[adjnode] = distance + d;\\n                    pn.push({stops+1,{adjnode,distance+d}});\\n                }\\n            }\\n        }\\n        if(dist[dst]==1e9)return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto it : flights){\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        queue<pair<int,pair<int,int>>> pn;\\n        pn.push({0,{src,0}});\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        while(!pn.empty()){\\n            auto front = pn.front();\\n            pn.pop();\\n            int stops = front.first;\\n            int node = front.second.first;\\n            int distance = front.second.second;\\n            if(stops>k)continue;\\n            for(auto it:adj[node]){\\n                int adjnode = it.first;\\n                int d = it.second;\\n                if(distance + d<dist[adjnode]&&stops<=k){\\n                    dist[adjnode] = distance + d;\\n                    pn.push({stops+1,{adjnode,distance+d}});\\n                }\\n            }\\n        }\\n        if(dist[dst]==1e9)return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420325,
                "title": "queue-bfs-similar-to-dijkstras-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int,int>>>g(n);\\n        for(auto& i:flights) g[i[0]].push_back({i[1],i[2]});\\n        vector<int>dist(n,INT_MAX);\\n        dist[src]=0;\\n        queue<pair<int,int>>pq;\\n        pq.push({0,src});\\n        k+=1;\\n        while(!pq.empty() && k--){\\n            int n=pq.size();\\n            while(n--){\\n                int d=pq.front().first,s=pq.front().second;\\n                pq.pop();\\n                for(auto& i:g[s]){\\n                    if(dist[i.first]>d+i.second){\\n                        dist[i.first]=d+i.second;\\n                        pq.push({dist[i.first],i.first});\\n                    } \\n                }                \\n            }\\n        }\\n        return dist[dst]==INT_MAX? -1:dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<pair<int,int>>>g(n);\\n        for(auto& i:flights) g[i[0]].push_back({i[1],i[2]});\\n        vector<int>dist(n,INT_MAX);\\n        dist[src]=0;\\n        queue<pair<int,int>>pq;\\n        pq.push({0,src});\\n        k+=1;\\n        while(!pq.empty() && k--){\\n            int n=pq.size();\\n            while(n--){\\n                int d=pq.front().first,s=pq.front().second;\\n                pq.pop();\\n                for(auto& i:g[s]){\\n                    if(dist[i.first]>d+i.second){\\n                        dist[i.first]=d+i.second;\\n                        pq.push({dist[i.first],i.first});\\n                    } \\n                }                \\n            }\\n        }\\n        return dist[dst]==INT_MAX? -1:dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278081,
                "title": "python-bellman-ford-vs-spfa-vs-bfs",
                "content": "This problem is good to compare different solutions of shortest path algos: \\n1. Bellman-Ford\\n2. SPFA\\n3. BFS\\n\\nIn fact, the 3 solutions are quite similar: do `k+1` round relaxations and find the shortest path from `src` to `dst`. \\nOn the other hand, the difference is also obvious. If we consider Bellman-Ford as a benchmark, SPFA and BFS are optimazations based on different **PRUNING** strategies.\\n\\n**Bellman-Ford**\\n[Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) is based on relaxation. Each round of relaxation, we iteratve ALL the edges and do the relaxation based on the `prices` we got from previous round.\\n In the `k`-th round of relaxation, we could find the min prices for cities whose path from source is no more than `k` edges.\\n Therefore, we do `k+1` round relaxations, instead of the traditional `V-1` rounds.\\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n        prices = [inf] * n\\n        prices[src] = 0\\n        for _ in range(k+1):\\n            next_prices = [d for d in prices]\\n            for a, b, p in flights:\\n                if prices[a] + p < next_prices[b]:\\n                    next_prices[b] = prices[a] + p\\n            prices = next_prices\\n        return prices[dst] if prices[dst] != inf else -1\\n```\\n\\n**SPFA**\\nSPFA, or [Shortest Path Faster Algorithm](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm), is an optimazation of Bellman-Ford. Instead of iterate all edges  during a round of relaxation, we maintain a list of cities whose price is updated in this round. These cities are the ones we should visit in the next round.\\n\\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(dict)\\n        for a, b, p in flights:\\n            graph[a][b] = p\\n            \\n        prices = [inf] * n\\n        prices[src] = 0\\n        \\n        q = [src]\\n        nstops = 0\\n        \\n        while q and nstops <= k:\\n            next_q = []\\n            next_prices = [p for p in prices]\\n            for city in q:\\n                for nxt in graph[city]:\\n                    if prices[city] + graph[city][nxt] < next_prices[nxt]:\\n                        next_prices[nxt] = prices[city] + graph[city][nxt]\\n                        next_q.append(nxt)\\n            q = next_q\\n            prices = next_prices\\n            nstops += 1\\n            \\n        return -1 if prices[dst] == inf else prices[dst]\\n```\\n\\n**BFS**\\nBFS is another optimization of Bellman_Ford for this problem. We consider number of stops as the level of BFS in the city graph. For each city in visited in `nstops` level, add all its children to the next level, i.e. `nstops + 1` level. Maintain a min price for each ciy during BFS. The way we prune the BFS tree is: \\n- If we find the price to a city is higher than or equal to what we keep in `prices`, we could prune this branch, because it is obviously more enpensive then what we considered when we updated `prices[city]` the last time.\\n- If we reach `dst` during BFS, we don\\'t have to keep searching its children, because it won\\'t give a lower price to `dst`.\\n\\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n        graph = defaultdict(dict)\\n        for a, b, p in flights:\\n            graph[a][b] = p\\n            \\n        prices = {city: inf for city in range(n)}\\n        \\n        # price, city\\n        q = [(0, src)]\\n        stops = 0\\n        \\n        while q and stops <= k + 1:\\n\\n            next_q = []\\n            for price, city in q:\\n                if price > prices[city]:\\n                    continue\\n                prices[city] = price\\n                if city == dst:\\n                    continue\\n                for nxt in graph[city]:\\n                    next_q.append((price + graph[city][nxt], nxt))\\n                \\n            stops += 1\\n            q = next_q\\n            \\n        return prices[dst] if prices[dst] != inf else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n        prices = [inf] * n\\n        prices[src] = 0\\n        for _ in range(k+1):\\n            next_prices = [d for d in prices]\\n            for a, b, p in flights:\\n                if prices[a] + p < next_prices[b]:\\n                    next_prices[b] = prices[a] + p\\n            prices = next_prices\\n        return prices[dst] if prices[dst] != inf else -1\\n```\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(dict)\\n        for a, b, p in flights:\\n            graph[a][b] = p\\n            \\n        prices = [inf] * n\\n        prices[src] = 0\\n        \\n        q = [src]\\n        nstops = 0\\n        \\n        while q and nstops <= k:\\n            next_q = []\\n            next_prices = [p for p in prices]\\n            for city in q:\\n                for nxt in graph[city]:\\n                    if prices[city] + graph[city][nxt] < next_prices[nxt]:\\n                        next_prices[nxt] = prices[city] + graph[city][nxt]\\n                        next_q.append(nxt)\\n            q = next_q\\n            prices = next_prices\\n            nstops += 1\\n            \\n        return -1 if prices[dst] == inf else prices[dst]\\n```\n```\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n        graph = defaultdict(dict)\\n        for a, b, p in flights:\\n            graph[a][b] = p\\n            \\n        prices = {city: inf for city in range(n)}\\n        \\n        # price, city\\n        q = [(0, src)]\\n        stops = 0\\n        \\n        while q and stops <= k + 1:\\n\\n            next_q = []\\n            for price, city in q:\\n                if price > prices[city]:\\n                    continue\\n                prices[city] = price\\n                if city == dst:\\n                    continue\\n                for nxt in graph[city]:\\n                    next_q.append((price + graph[city][nxt], nxt))\\n                \\n            stops += 1\\n            q = next_q\\n            \\n        return prices[dst] if prices[dst] != inf else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 687660,
                "title": "c-python-bfs-template-and-bellman-ford",
                "content": "\\nApproach 1: BFS+template:\\n```\\nclass Solution { // BFS: BEST; Time/Space: O(n^(K+1)), O(n^(K+1))\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        int ans = INT_MAX;\\n        unordered_map<int, vector<pair<int, int>> > schedules;\\n        for(auto flight: flights)            \\n            schedules[flight[0]].emplace_back(flight[1], flight[2]); //okay\\n            //schedules[flight[0]].push_back({flight[1], flight[2]}); //Note1             \\n        queue<pair<int, int>> q{{{src, 0}}}; // it costs 0 to reach \\'src\\'\\n        for(int step = 0; !q.empty() && step <= K+1; step++){\\n            for(int size = q.size(); size-->0;){\\n                auto [target, cost] = q.front();q.pop();   //step1: current node                \\n                if(target == dst) {\\n                    ans = min(ans, cost);\\n                    continue; //Note4:\\n                }\\n                for(auto& next: schedules[target]){   //step2: check next nodes\\n                    if(cost + next.second > ans ) continue; //Note2: pruning\\n                    if(step == K + 1 && next.first != dst) continue; //Note5\\n                    q.emplace(next.first, cost + next.second); //Note3                    \\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1: ans;                             \\n    }          \\n};\\n/*\\nNote1: key->value means: src->{dst, cost}\\nNote2: pruning by best cost by far\\nNote3: why not need marking visited? Checking City 2 in Example 1. You may revist same city in different steps\\nNote4: Optional. If we reach destination, we don\\'t need to process target\\'s neighbor\\nNote5: Optional. If this is the last iteration, we should only update neighbor == target; otherwise we might create other minCost that require more than k stops\\n*/\\n```\\n\\nApproach 2: Python, Bellman-Ford Alogrithm:\\n```\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        prices = [float(\\'inf\\')] * n \\n        prices[src]=0\\n        \\n        for i in range(k+1):\\n            tempPrice = prices.copy()\\n            for s, d, p in flights:\\n                if tempPrice[s] < float(\\'inf\\'):\\n                    if tempPrice[d] > prices[s]+p:\\n                        tempPrice[d] = prices[s]+p\\n            prices = tempPrice.copy()\\n        \\n        return -1 if prices[dst] == float(\\'inf\\') else prices[dst]\\n```\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution { // BFS: BEST; Time/Space: O(n^(K+1)), O(n^(K+1))\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        int ans = INT_MAX;\\n        unordered_map<int, vector<pair<int, int>> > schedules;\\n        for(auto flight: flights)            \\n            schedules[flight[0]].emplace_back(flight[1], flight[2]); //okay\\n            //schedules[flight[0]].push_back({flight[1], flight[2]}); //Note1             \\n        queue<pair<int, int>> q{{{src, 0}}}; // it costs 0 to reach \\'src\\'\\n        for(int step = 0; !q.empty() && step <= K+1; step++){\\n            for(int size = q.size(); size-->0;){\\n                auto [target, cost] = q.front();q.pop();   //step1: current node                \\n                if(target == dst) {\\n                    ans = min(ans, cost);\\n                    continue; //Note4:\\n                }\\n                for(auto& next: schedules[target]){   //step2: check next nodes\\n                    if(cost + next.second > ans ) continue; //Note2: pruning\\n                    if(step == K + 1 && next.first != dst) continue; //Note5\\n                    q.emplace(next.first, cost + next.second); //Note3                    \\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1: ans;                             \\n    }          \\n};\\n/*\\nNote1: key->value means: src->{dst, cost}\\nNote2: pruning by best cost by far\\nNote3: why not need marking visited? Checking City 2 in Example 1. You may revist same city in different steps\\nNote4: Optional. If we reach destination, we don\\'t need to process target\\'s neighbor\\nNote5: Optional. If this is the last iteration, we should only update neighbor == target; otherwise we might create other minCost that require more than k stops\\n*/\\n```\n```\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        prices = [float(\\'inf\\')] * n \\n        prices[src]=0\\n        \\n        for i in range(k+1):\\n            tempPrice = prices.copy()\\n            for s, d, p in flights:\\n                if tempPrice[s] < float(\\'inf\\'):\\n                    if tempPrice[d] > prices[s]+p:\\n                        tempPrice[d] = prices[s]+p\\n            prices = tempPrice.copy()\\n        \\n        return -1 if prices[dst] == float(\\'inf\\') else prices[dst]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504130,
                "title": "java-bfs-prim-s-algorithm-minimum-spanning-tree",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        // pair<src_city, pair<dest_city, price>>\\n        Map<Integer, Map<Integer, Integer>> g = buildGraph(flights);\\n        \\n        Queue<Flight> q = new PriorityQueue<>(Comparator.comparingInt(f -> f.cost));\\n        \\n        q.add(new Flight(0, src, 0));\\n        \\n        while (!q.isEmpty()) {\\n            Flight f = q.poll();\\n            \\n            if (f.hops > K + 1) {\\n                continue;\\n            }\\n            \\n            if (f.to == dst) {\\n                return f.cost;\\n            }\\n            \\n            for (Map.Entry<Integer, Integer> u : g.getOrDefault(f.to, new HashMap<>()).entrySet()) {\\n                int to = u.getKey();\\n                \\n                int costSum = f.cost + u.getValue();\\n                q.add(new Flight(costSum, to, f.hops + 1));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    Map<Integer, Map<Integer, Integer>> buildGraph(int[][] flights) {\\n        Map<Integer, Map<Integer, Integer>> g = new HashMap<>();\\n        \\n        for (int[] edge : flights) {\\n            Map<Integer, Integer> u = g.getOrDefault(edge[0], new HashMap<>());\\n            u.put(edge[1], edge[2]);\\n            \\n            g.put(edge[0], u);            \\n        }\\n        \\n        return g;\\n    }\\n    \\n    class Flight {\\n        int cost;\\n        int to;\\n        int hops;\\n        \\n        Flight(int cost, int to, int hops) {\\n            this.cost = cost;\\n            this.to = to;\\n            this.hops = hops;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        // pair<src_city, pair<dest_city, price>>\\n        Map<Integer, Map<Integer, Integer>> g = buildGraph(flights);\\n        \\n        Queue<Flight> q = new PriorityQueue<>(Comparator.comparingInt(f -> f.cost));\\n        \\n        q.add(new Flight(0, src, 0));\\n        \\n        while (!q.isEmpty()) {\\n            Flight f = q.poll();\\n            \\n            if (f.hops > K + 1) {\\n                continue;\\n            }\\n            \\n            if (f.to == dst) {\\n                return f.cost;\\n            }\\n            \\n            for (Map.Entry<Integer, Integer> u : g.getOrDefault(f.to, new HashMap<>()).entrySet()) {\\n                int to = u.getKey();\\n                \\n                int costSum = f.cost + u.getValue();\\n                q.add(new Flight(costSum, to, f.hops + 1));\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    Map<Integer, Map<Integer, Integer>> buildGraph(int[][] flights) {\\n        Map<Integer, Map<Integer, Integer>> g = new HashMap<>();\\n        \\n        for (int[] edge : flights) {\\n            Map<Integer, Integer> u = g.getOrDefault(edge[0], new HashMap<>());\\n            u.put(edge[1], edge[2]);\\n            \\n            g.put(edge[0], u);            \\n        }\\n        \\n        return g;\\n    }\\n    \\n    class Flight {\\n        int cost;\\n        int to;\\n        int hops;\\n        \\n        Flight(int cost, int to, int hops) {\\n            this.cost = cost;\\n            this.to = to;\\n            this.hops = hops;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362377,
                "title": "python-dijkstra-with-detailed-comments-and-explanation",
                "content": "*-- Based on Dijsktra in the solution tab but with more comments and explanations --*\\n**IDEA:**\\nIn a basic Dijkstra algorithm, the only basis upon which one path is given priority over another\\nis the cost. In this problem however, there is an additional constraint; length of route or (number of stops)\\n\\nA slight modification can be introduced to basic Dijsktra to count for both (cost and length)\\nJust like in a normal Dijkstra, we have to keep track of the cost needed to reach a node in weightd dict;\\n\\n\\tweights = {\\n\\t\\t\\t\\tA : cost to reach node A,\\n\\t\\t\\t\\tB : cost to reach node B,\\n\\t\\t\\t\\t...,\\n\\t\\t\\t\\t..,\\n\\t\\t\\t\\t.\\n\\t\\t\\t  }\\n\\nBut we know that in the context of this problem we could reach the same node via two different routes and it\\'s possible that the more expensive route would be the way to go if the lesser-costly route had more than K stops between src (source node) and dst (destination node). So we have to keep track of all routes to the node and compare on the basis of (cost and number of stops). Hence our modified dict will look something like this\\nlook something like this:\\n\\n\\t\\tweights = {\\n\\t\\t\\t\\t(k1, A) : cost to reach node A taking k1 stops, ---- (*)\\n\\t\\t\\t\\t(k2, B) : cost to reach node B taking k2 steps,\\n\\t\\t\\t\\t(k3, A) : cost to reach node B taking k3 steps, ---- (*)\\n\\t\\t\\t\\t...,\\n\\t\\t\\t\\t..,\\n\\t\\t\\t\\t.\\n\\t\\t\\t  }\\n\\n\\t\\t(*) notice how we have two records that pertain to the same node (node A)\\n\\t\\tin the dict but with different k\\n\\nAn additional modifcation is also needed to be able to use the described approach. Instead of using a visited set to keep track of seen nodes so we don\\'t visit them again. We have to come up with a more nuanced elimination method as we no more can afford to exclude (eliminate) a node solely on the basis that we have seen it before. We are only allowed to exclude a node (not push it to the heap) if:\\n\\n- node seen before and node\\'s cost last time we saw it was less than current cost\\n- Or, node seen before and node\\'s number of steps was less last time we saw it\\n```\\nif cost > weights.get((k, node), float(\\'inf\\')) or k > K:\\n\\t\\tcontinue\\n```\\nThe logic here is simply this; if I\\'ve already seen a node via a cheaper route or via a route that had less number of stops, then I don\\'t\\nneed to consider it.\\n\\n**Final Code**\\n\\n```\\n        \\ndef findCheapestPrice(n, flights, src, dst, K):\\n\\t\\t# Build the graph:\\n        from collections import defaultdict\\n        d = defaultdict(list)\\n        for u, v, w in flights:\\n            d[u].append((w,v)) # directed\\n        \\n        # Apply Dijkstra:\\n        from heapq import heappop, heappush\\n        h = [(0, -1, src)] # cost, k, node\\n        weights = {} # instead of pre-processing the weights dict with placeholder values of inf and 0, we do it on the fly\\n        while h:\\n            cost, k, node = heappop(h)\\n            if cost > weights.get((k, node), float(\\'inf\\')) or \\\\\\n            k > K:\\n                continue # don\\'t even bother to add to heap\\n            if node == dst:\\n                return cost\\n            for edgeCost, nei in d[node]:\\n                newCost = edgeCost + cost\\n                if weights.get((k+1, nei), float(\\'inf\\')) > newCost:\\n                    weights[(k+1, nei)] = newCost\\n                    heappush(h, (newCost, k+1, nei))\\n        return -1 # all nodes visited but no dst found, so return -1\\n```\\n\\n**Initial code passing 35/41 test cases as of 8/19/19**\\nIn the code below, I naively used a visited set to keep tarck of the explored nodes and to make sure I don\\'t visit them again\\n```\\n# apply Dijsktra:\\nh = [(0, src, 0)] # format = (cost, src, steps)\\nvisited = set()\\nfrom heapq import heappop, heappush\\nwhile h:\\n\\tcheapest_cost, cheapest_node, stops = heappop(h)\\n\\tvisited.add(cheapest_node) \\n\\tif stops <= K:\\n\\t\\tfor edge_cost, nei in d[cheapest_node]:\\n\\t\\t\\tif weights[cheapest_node] + edge_cost < weights[nei]:\\n\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\tweights[nei] = weights[cheapest_node] + edge_cost\\n\\t\\t\\t\\t\\theappush(h, (weights[nei], nei, stops+1))\\nreturn weights[dst]\\n```\\n\\n**A test case where initial code would fail**\\n - see image:\\n\\n![image](https://assets.leetcode.com/users/abadawi/image_1566238824.png)\\n\\n- visualized:\\nBecause node 2 has been visited once via path (0 -> 1 -> 2), node 2 has been marked visited and thus was excluded from the preferred path -path with one stop- (0 -> 2 -> 3). See image:\\n\\n![image](https://assets.leetcode.com/users/abadawi/image_1566239428.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\nif cost > weights.get((k, node), float(\\'inf\\')) or k > K:\\n\\t\\tcontinue\\n```\n```\\n        \\ndef findCheapestPrice(n, flights, src, dst, K):\\n\\t\\t# Build the graph:\\n        from collections import defaultdict\\n        d = defaultdict(list)\\n        for u, v, w in flights:\\n            d[u].append((w,v)) # directed\\n        \\n        # Apply Dijkstra:\\n        from heapq import heappop, heappush\\n        h = [(0, -1, src)] # cost, k, node\\n        weights = {} # instead of pre-processing the weights dict with placeholder values of inf and 0, we do it on the fly\\n        while h:\\n            cost, k, node = heappop(h)\\n            if cost > weights.get((k, node), float(\\'inf\\')) or \\\\\\n            k > K:\\n                continue # don\\'t even bother to add to heap\\n            if node == dst:\\n                return cost\\n            for edgeCost, nei in d[node]:\\n                newCost = edgeCost + cost\\n                if weights.get((k+1, nei), float(\\'inf\\')) > newCost:\\n                    weights[(k+1, nei)] = newCost\\n                    heappush(h, (newCost, k+1, nei))\\n        return -1 # all nodes visited but no dst found, so return -1\\n```\n```\\n# apply Dijsktra:\\nh = [(0, src, 0)] # format = (cost, src, steps)\\nvisited = set()\\nfrom heapq import heappop, heappush\\nwhile h:\\n\\tcheapest_cost, cheapest_node, stops = heappop(h)\\n\\tvisited.add(cheapest_node) \\n\\tif stops <= K:\\n\\t\\tfor edge_cost, nei in d[cheapest_node]:\\n\\t\\t\\tif weights[cheapest_node] + edge_cost < weights[nei]:\\n\\t\\t\\t\\tif nei not in visited:\\n\\t\\t\\t\\t\\tweights[nei] = weights[cheapest_node] + edge_cost\\n\\t\\t\\t\\t\\theappush(h, (weights[nei], nei, stops+1))\\nreturn weights[dst]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3101719,
                "title": "java-dfs-memoization-approach",
                "content": "```\\n// Approach #1: DFS + Memoization Approach\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<int[]>> adjList = new HashMap<>();\\n        \\n        for (int[] flight : flights) \\n            adjList.computeIfAbsent(flight[0], value -> new ArrayList<int[]>())\\n                .add(new int[] { flight[1], flight[2] });\\n\\t\\t\\t\\t\\n\\t\\tInteger[][] memo = new Integer[n + 1][k + 1];\\n        int minPrice = dfs(adjList, src, dst, memo, k);\\n\\t\\t\\n        return minPrice == Integer.MAX_VALUE ? -1: minPrice;\\n    }\\n    \\n    private int dfs(Map<Integer, List<int[]>> adjList, int curr, int dst, Integer[][] memo, int k) {   \\n        if (curr == dst)\\n\\t\\t\\treturn 0;\\n        \\n\\t\\tif (k < 0 || !adjList.containsKey(curr))\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n        \\n\\t\\tif (memo[curr][k] != null) \\n\\t\\t\\t return memo[curr][k];\\n        \\n\\t\\tint minPrice = Integer.MAX_VALUE;\\n\\t\\t\\n        for (int[] next : adjList.get(curr)) {\\n\\t\\t\\tint price = dfs(adjList, next[0], dst, memo, k - 1);\\n\\t\\t\\t\\n            if (price != Integer.MAX_VALUE) \\n                minPrice = Math.min(minPrice, price + next[1]);\\n        }\\n\\t\\t\\n        return memo[curr][k] = minPrice;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n// Approach #1: DFS + Memoization Approach\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<int[]>> adjList = new HashMap<>();\\n        \\n        for (int[] flight : flights) \\n            adjList.computeIfAbsent(flight[0], value -> new ArrayList<int[]>())\\n                .add(new int[] { flight[1], flight[2] });\\n\\t\\t\\t\\t\\n\\t\\tInteger[][] memo = new Integer[n + 1][k + 1];\\n        int minPrice = dfs(adjList, src, dst, memo, k);\\n\\t\\t\\n        return minPrice == Integer.MAX_VALUE ? -1: minPrice;\\n    }\\n    \\n    private int dfs(Map<Integer, List<int[]>> adjList, int curr, int dst, Integer[][] memo, int k) {   \\n        if (curr == dst)\\n\\t\\t\\treturn 0;\\n        \\n\\t\\tif (k < 0 || !adjList.containsKey(curr))\\n\\t\\t\\treturn Integer.MAX_VALUE;\\n        \\n\\t\\tif (memo[curr][k] != null) \\n\\t\\t\\t return memo[curr][k];\\n        \\n\\t\\tint minPrice = Integer.MAX_VALUE;\\n\\t\\t\\n        for (int[] next : adjList.get(curr)) {\\n\\t\\t\\tint price = dfs(adjList, next[0], dst, memo, k - 1);\\n\\t\\t\\t\\n            if (price != Integer.MAX_VALUE) \\n                minPrice = Math.min(minPrice, price + next[1]);\\n        }\\n\\t\\t\\n        return memo[curr][k] = minPrice;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066105,
                "title": "python-easy-solution-using-dijkstra-s-algorithm",
                "content": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        #Make graph\\n        adj_list = {i:[] for i in range(n)}\\n        for frm, to, price in flights:\\n            adj_list[frm].append((to, price))\\n        \\n        best_visited = [2**31]*n # Initialized to maximum\\n        \\n        prior_queue = [ (0, -1, src) ]  # weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if best_visited[node] <= steps:  # Have seen the node already, and the current steps are more than last time\\n                continue\\n\\n            if steps > k:  # More than k stops, invalid\\n                continue\\n\\n            if node==dst:  # reach the destination # as priority_queue is a minHeap so this cost is the most minimum cost.\\n                return cost\\n            \\n            best_visited[node] = steps # Update steps\\n\\n            for neighb, weight in adj_list[node]:\\n                heapq.heappush(prior_queue, (cost + weight, steps + 1, neighb))\\n\\n        return -1\\n\\t\\t\\n# Time: O(n * len(flights) * log(n))\\n# Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        #Make graph\\n        adj_list = {i:[] for i in range(n)}\\n        for frm, to, price in flights:\\n            adj_list[frm].append((to, price))\\n        \\n        best_visited = [2**31]*n # Initialized to maximum\\n        \\n        prior_queue = [ (0, -1, src) ]  # weight, steps, node\\n\\n        while prior_queue:\\n            cost, steps, node = heapq.heappop(prior_queue)\\n            \\n            if best_visited[node] <= steps:  # Have seen the node already, and the current steps are more than last time\\n                continue\\n\\n            if steps > k:  # More than k stops, invalid\\n                continue\\n\\n            if node==dst:  # reach the destination # as priority_queue is a minHeap so this cost is the most minimum cost.\\n                return cost\\n            \\n            best_visited[node] = steps # Update steps\\n\\n            for neighb, weight in adj_list[node]:\\n                heapq.heappush(prior_queue, (cost + weight, steps + 1, neighb))\\n\\n        return -1\\n\\t\\t\\n# Time: O(n * len(flights) * log(n))\\n# Space: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513235,
                "title": "java-dijkstra-solution",
                "content": "```\\n// Dijkstra Solution\\n// Note 1: Check whether node.stop > k\\n// Note 2: Add to heap 1) distance is shorter; 2) number of stops are less.\\n// Time complexity: O(N + ElogN)\\n// Space complexity: O(N)\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        List<Node>[] graph = new ArrayList[n];\\n        buildGraph(graph, flights);\\n        int[] prices = new int[n];\\n        int[] stops = new int[n];\\n        Arrays.fill(prices, Integer.MAX_VALUE);\\n        Arrays.fill(stops, Integer.MAX_VALUE);\\n        prices[src] = 0;\\n        stops[src] = 0;\\n        PriorityQueue<Node> heap = new PriorityQueue<>((n1, n2) -> Integer.compare(n1.price, n2.price));\\n        heap.add(new Node(src, 0, 0));  // id, price, stop\\n        while (!heap.isEmpty()) {\\n            Node node = heap.poll();\\n            if (node.id == dst) return node.price;\\n            if (node.stop > k) continue;\\n            for (Node neighbor : graph[node.id]) {\\n                int nextCost = node.price + neighbor.price;\\n                int nextStop = node.stop+1;\\n                if (prices[neighbor.id] > nextCost) {\\n                    // if nextCost is less than price, update prices and stops array, and explore the neighbor.\\n                    prices[neighbor.id] = nextCost;\\n                    stops[neighbor.id] = nextStop;\\n                    heap.add(new Node(neighbor.id, nextCost, nextStop));\\n                } else if (stops[neighbor.id] > node.stop) {\\n                    // if node.stop < stops[neighbor.label], explore the neighbor.\\n                    heap.add(new Node(neighbor.id, nextCost, nextStop));\\n                }\\n            }\\n        }\\n        return prices[dst] == Integer.MAX_VALUE ? -1 : prices[dst];\\n    }\\n    \\n    private void buildGraph(List<Node>[] graph, int[][] flights) {\\n        for (int i = 0; i < graph.length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] flight : flights) {\\n            int from = flight[0], to = flight[1], price = flight[2];\\n            graph[from].add(new Node(to, price, 0));\\n        }\\n    }\\n    \\n    static class Node {\\n        int id, price, stop;\\n        Node(int id, int price, int stop) {\\n            this.id = id;\\n            this.price = price;\\n            this.stop = stop;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Dijkstra Solution\\n// Note 1: Check whether node.stop > k\\n// Note 2: Add to heap 1) distance is shorter; 2) number of stops are less.\\n// Time complexity: O(N + ElogN)\\n// Space complexity: O(N)\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        List<Node>[] graph = new ArrayList[n];\\n        buildGraph(graph, flights);\\n        int[] prices = new int[n];\\n        int[] stops = new int[n];\\n        Arrays.fill(prices, Integer.MAX_VALUE);\\n        Arrays.fill(stops, Integer.MAX_VALUE);\\n        prices[src] = 0;\\n        stops[src] = 0;\\n        PriorityQueue<Node> heap = new PriorityQueue<>((n1, n2) -> Integer.compare(n1.price, n2.price));\\n        heap.add(new Node(src, 0, 0));  // id, price, stop\\n        while (!heap.isEmpty()) {\\n            Node node = heap.poll();\\n            if (node.id == dst) return node.price;\\n            if (node.stop > k) continue;\\n            for (Node neighbor : graph[node.id]) {\\n                int nextCost = node.price + neighbor.price;\\n                int nextStop = node.stop+1;\\n                if (prices[neighbor.id] > nextCost) {\\n                    // if nextCost is less than price, update prices and stops array, and explore the neighbor.\\n                    prices[neighbor.id] = nextCost;\\n                    stops[neighbor.id] = nextStop;\\n                    heap.add(new Node(neighbor.id, nextCost, nextStop));\\n                } else if (stops[neighbor.id] > node.stop) {\\n                    // if node.stop < stops[neighbor.label], explore the neighbor.\\n                    heap.add(new Node(neighbor.id, nextCost, nextStop));\\n                }\\n            }\\n        }\\n        return prices[dst] == Integer.MAX_VALUE ? -1 : prices[dst];\\n    }\\n    \\n    private void buildGraph(List<Node>[] graph, int[][] flights) {\\n        for (int i = 0; i < graph.length; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] flight : flights) {\\n            int from = flight[0], to = flight[1], price = flight[2];\\n            graph[from].add(new Node(to, price, 0));\\n        }\\n    }\\n    \\n    static class Node {\\n        int id, price, stop;\\n        Node(int id, int price, int stop) {\\n            this.id = id;\\n            this.price = price;\\n            this.stop = stop;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427241,
                "title": "c-12ms-99-75-simple-bfs-commented",
                "content": "Runtime: 12 ms, faster than 99.75% of C++ online submissions for Cheapest Flights Within K Stops.\\nMemory Usage: 13.4 MB, less than 59.70% of C++ online submissions for Cheapest Flights Within K Stops.\\n```\\nclass Solution {\\npublic:\\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n    vector<vector<pair<int,int>>>g(n);\\n    vector<int>costs (n,INT_MAX);\\n    int answer = INT_MAX;\\n    \\n    for(auto &f: flights) g[f[0]].push_back({f[1], f[2]});     //current = {neigbour, cost to it}\\n    \\n    queue<tuple<int,int,int>> q;\\n    q.push({0,src,-1});                                        //total cost, to, tmp k\\n    while(!q.empty()){\\n      auto[tc, tt, tk] = q.front(); q.pop();\\n      if(tt == dst) {answer = min(tc, answer); continue;}\\n      if(tk++ == k || costs[tt] < tc) continue;\\n      costs[tt] = tc;\\n      \\n      for(auto &[n, c]: g[tt])                                 // &[neigbour, cost to it] \\n        if(tc + c < costs[n]) q.push({tc + c, n, tk});\\n    }\\n    \\n    return answer == INT_MAX ? -1 : answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n    vector<vector<pair<int,int>>>g(n);\\n    vector<int>costs (n,INT_MAX);\\n    int answer = INT_MAX;\\n    \\n    for(auto &f: flights) g[f[0]].push_back({f[1], f[2]});     //current = {neigbour, cost to it}\\n    \\n    queue<tuple<int,int,int>> q;\\n    q.push({0,src,-1});                                        //total cost, to, tmp k\\n    while(!q.empty()){\\n      auto[tc, tt, tk] = q.front(); q.pop();\\n      if(tt == dst) {answer = min(tc, answer); continue;}\\n      if(tk++ == k || costs[tt] < tc) continue;\\n      costs[tt] = tc;\\n      \\n      for(auto &[n, c]: g[tt])                                 // &[neigbour, cost to it] \\n        if(tc + c < costs[n]) q.push({tc + c, n, tk});\\n    }\\n    \\n    return answer == INT_MAX ? -1 : answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381417,
                "title": "my-java-solution-using-dijkstras-algorithm",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        if (flights == null || flights.length == 0 || n <= 0 || k < 0)\\n            return -1;\\n        List<List<Pair>> graph = buildGraph(flights, n);\\n        PriorityQueue<City> minHeap = new PriorityQueue<>((city1, city2) -> Integer.compare(city1.costFromSrc, city2.costFromSrc));\\n        // source, distance from src to current city, cost from src to currency city\\n        minHeap.offer(new City(src, 0, 0));\\n        Map<Integer, Integer> visited = new HashMap<>();\\n        while (!minHeap.isEmpty()) {\\n            City currentCity = minHeap.poll();\\n            if (visited.containsKey(currentCity.city) && visited.get(currentCity.city) <= currentCity.distanceFromSrc)\\n                continue;\\n            if (currentCity.city == dst)\\n                return currentCity.costFromSrc;\\n            if (currentCity.distanceFromSrc > k)\\n                continue;\\n            visited.put(currentCity.city, currentCity.distanceFromSrc);\\n            List<Pair> neighbour = graph.get(currentCity.city);\\n            for (Pair pair : neighbour) {\\n                minHeap.offer(new City(pair.destination, currentCity.distanceFromSrc + 1, currentCity.costFromSrc + pair.price));\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public List<List<Pair>> buildGraph(int [][] flights, int n) {\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i=0; i<n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] flight : flights) {\\n            graph.get(flight[0]).add(new Pair(flight[1], flight[2]));\\n        }\\n        return graph;\\n    }\\n}\\n\\nclass City {\\n    int city;\\n    // means the number of stops from source\\n    int distanceFromSrc;\\n    int costFromSrc;\\n    public City(int city, int distanceFromSrc, int costFromSrc) {\\n        this.city = city;\\n        this.distanceFromSrc = distanceFromSrc;\\n        this.costFromSrc = costFromSrc;\\n    }\\n}\\n\\nclass Pair {\\n    int destination;\\n    int price;\\n    public Pair(int destination, int price) {\\n        this.destination = destination;\\n        this.price = price;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        if (flights == null || flights.length == 0 || n <= 0 || k < 0)\\n            return -1;\\n        List<List<Pair>> graph = buildGraph(flights, n);\\n        PriorityQueue<City> minHeap = new PriorityQueue<>((city1, city2) -> Integer.compare(city1.costFromSrc, city2.costFromSrc));\\n        // source, distance from src to current city, cost from src to currency city\\n        minHeap.offer(new City(src, 0, 0));\\n        Map<Integer, Integer> visited = new HashMap<>();\\n        while (!minHeap.isEmpty()) {\\n            City currentCity = minHeap.poll();\\n            if (visited.containsKey(currentCity.city) && visited.get(currentCity.city) <= currentCity.distanceFromSrc)\\n                continue;\\n            if (currentCity.city == dst)\\n                return currentCity.costFromSrc;\\n            if (currentCity.distanceFromSrc > k)\\n                continue;\\n            visited.put(currentCity.city, currentCity.distanceFromSrc);\\n            List<Pair> neighbour = graph.get(currentCity.city);\\n            for (Pair pair : neighbour) {\\n                minHeap.offer(new City(pair.destination, currentCity.distanceFromSrc + 1, currentCity.costFromSrc + pair.price));\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public List<List<Pair>> buildGraph(int [][] flights, int n) {\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i=0; i<n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] flight : flights) {\\n            graph.get(flight[0]).add(new Pair(flight[1], flight[2]));\\n        }\\n        return graph;\\n    }\\n}\\n\\nclass City {\\n    int city;\\n    // means the number of stops from source\\n    int distanceFromSrc;\\n    int costFromSrc;\\n    public City(int city, int distanceFromSrc, int costFromSrc) {\\n        this.city = city;\\n        this.distanceFromSrc = distanceFromSrc;\\n        this.costFromSrc = costFromSrc;\\n    }\\n}\\n\\nclass Pair {\\n    int destination;\\n    int price;\\n    public Pair(int destination, int price) {\\n        this.destination = destination;\\n        this.price = price;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687441,
                "title": "java-dijkstra-s-solution-easy-solution-with-explanations",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        if(flights.length==0) return -1;\\n        \\n        HashMap<Integer, List<int []>> graph = new HashMap<>();\\n        \\n        for(int[] flight: flights){\\n            \\n            if(!graph.containsKey(flight[0])){\\n                graph.put(flight[0], new ArrayList<int[]>());\\n            }\\n            \\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\\n        }\\n        \\n        \\n        PriorityQueue<Node> q = new PriorityQueue<Node>((a,b) -> (a.cost - b.cost));\\n        \\n        q.add(new Node(src, 0, -1));\\n        \\n        while(!q.isEmpty()){\\n            \\n            Node curr = q.poll();\\n            \\n            if(curr.city == dst){\\n                return curr.cost;\\n            }\\n            \\n            if(curr.stop<K){\\n                List<int []> nexts = graph.getOrDefault(curr.city, new ArrayList<int[]>());\\n                \\n                for(int[] next: nexts){\\n                    q.add(new Node(next[0], curr.cost+next[1], curr.stop+1));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n\\nclass Node {\\n    int city;\\n    int cost;\\n    int stop;\\n    \\n    public Node(int city, int cost, int stop){\\n        this.city = city;\\n        this.cost = cost;\\n        this.stop = stop;\\n    }\\n}\\n```\\n\\nhttps://youtu.be/UK1SqJH3p_M",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        if(flights.length==0) return -1;\\n        \\n        HashMap<Integer, List<int []>> graph = new HashMap<>();\\n        \\n        for(int[] flight: flights){\\n            \\n            if(!graph.containsKey(flight[0])){\\n                graph.put(flight[0], new ArrayList<int[]>());\\n            }\\n            \\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\\n        }\\n        \\n        \\n        PriorityQueue<Node> q = new PriorityQueue<Node>((a,b) -> (a.cost - b.cost));\\n        \\n        q.add(new Node(src, 0, -1));\\n        \\n        while(!q.isEmpty()){\\n            \\n            Node curr = q.poll();\\n            \\n            if(curr.city == dst){\\n                return curr.cost;\\n            }\\n            \\n            if(curr.stop<K){\\n                List<int []> nexts = graph.getOrDefault(curr.city, new ArrayList<int[]>());\\n                \\n                for(int[] next: nexts){\\n                    q.add(new Node(next[0], curr.cost+next[1], curr.stop+1));\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n\\nclass Node {\\n    int city;\\n    int cost;\\n    int stop;\\n    \\n    public Node(int city, int cost, int stop){\\n        this.city = city;\\n        this.cost = cost;\\n        this.stop = stop;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100116,
                "title": "java-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS starting from the `src` city and limiting the traversal to `k+1` levels. Keep track of the cost of the trip so far until every city on the way to the destination. If a city can be reached in multiple ways, remember the lowest cost option. We will either reach the `dst` city within `k+1` iterations or not. Return the correct answer accordingly.\\n\\n# Complexity\\n- Time complexity: $$O(N+E*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N+E*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n    List<int[]>[] adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var flight : flights)\\n      adj[flight[0]].add(new int[] {flight[1], flight[2]});\\n\\n    var costToCity = new int[n];\\n    Arrays.fill(costToCity, Integer.MAX_VALUE);\\n\\n    var queue = new ArrayDeque<int[]>();\\n    queue.offer(new int[] {src, 0});\\n\\n    while (k-- >= 0 && !queue.isEmpty()) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var stop = queue.poll();\\n        if (stop[1] >= costToCity[stop[0]])\\n          continue;\\n\\n        costToCity[stop[0]] = stop[1];\\n\\n        for (var flight : adj[stop[0]]) {\\n          if (flight[0] == dst)\\n            costToCity[dst] = Math.min(costToCity[dst], stop[1] + flight[1]);\\n          else\\n            queue.offer(new int[] {flight[0], stop[1] + flight[1]});\\n        }\\n      }\\n    }\\n    return costToCity[dst] == Integer.MAX_VALUE ? -1 : costToCity[dst];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n    List<int[]>[] adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var flight : flights)\\n      adj[flight[0]].add(new int[] {flight[1], flight[2]});\\n\\n    var costToCity = new int[n];\\n    Arrays.fill(costToCity, Integer.MAX_VALUE);\\n\\n    var queue = new ArrayDeque<int[]>();\\n    queue.offer(new int[] {src, 0});\\n\\n    while (k-- >= 0 && !queue.isEmpty()) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var stop = queue.poll();\\n        if (stop[1] >= costToCity[stop[0]])\\n          continue;\\n\\n        costToCity[stop[0]] = stop[1];\\n\\n        for (var flight : adj[stop[0]]) {\\n          if (flight[0] == dst)\\n            costToCity[dst] = Math.min(costToCity[dst], stop[1] + flight[1]);\\n          else\\n            queue.offer(new int[] {flight[0], stop[1] + flight[1]});\\n        }\\n      }\\n    }\\n    return costToCity[dst] == Integer.MAX_VALUE ? -1 : costToCity[dst];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099806,
                "title": "c-simple",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k)   \\n    {\\n        int[] dist = new int[n];\\n        Array.Fill(dist, int.MaxValue);\\n        dist[src] = 0;\\n        for (int i = 0; i <= k; i++)\\n        {\\n            int[] temp = dist.ToArray();\\n            foreach (int[] flight in flights)\\n            {\\n                if (dist[flight[0]] != int.MaxValue) \\n                {\\n                    temp[flight[1]] = Math.Min(temp[flight[1]], dist[flight[0]] + flight[2]);\\n                }\\n            }\\n            dist = temp;\\n        }\\n        return dist[dst] == int.MaxValue ? -1 : dist[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k)   \\n    {\\n        int[] dist = new int[n];\\n        Array.Fill(dist, int.MaxValue);\\n        dist[src] = 0;\\n        for (int i = 0; i <= k; i++)\\n        {\\n            int[] temp = dist.ToArray();\\n            foreach (int[] flight in flights)\\n            {\\n                if (dist[flight[0]] != int.MaxValue) \\n                {\\n                    temp[flight[1]] = Math.Min(temp[flight[1]], dist[flight[0]] + flight[2]);\\n                }\\n            }\\n            dist = temp;\\n        }\\n        return dist[dst] == int.MaxValue ? -1 : dist[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893568,
                "title": "bellman-ford-algorithm-in-python",
                "content": "# Intuition\\nBellman-Ford is a pretty fun way to approach this problem, and is quite straightforward to both understand and implement once you get the hang of it.\\n\\nDjikstra\\'s currently encounters a TLE in Python, so I figured it would be useful to showcase a solution which is still capable of beating the LC test cases. Additionally, this is just a really fun problem to show the algorithm on, since the reasoning is quite straightforward.  \\n\\n# Approach\\nThe Bellman-Ford algorithm is a means of finding the shortest distance from a starting node to an ending node. In this case, the code is slightly modified since we are only permitted K connections between the start and destination; as such, a temporary array is required, which will be used to update the cost array during each loop.\\n\\nFirst, initialize your list of edges (in this case a defaultdict) and your starting cost array, with some unattainably high value (in this case float(\\'inf\\')). \\n\\nNext, begin the process of iterating through the edges K + 1 times (it is K + 1 times since we are concerned only with K *connections* rather than K *flights*).\\n\\nWith each iteration, create an initial temporary array by copying the current cost array. Iterate through each node, updating the cost to reach it in the temporary array by using its *current* cost plus the weight of the respective edge compared against the *temporary* cost.\\n\\nOnce you have looped through each node, update the current cost array with the temporary array, and continue to loop K more times.\\n\\nWith the K+1 loops complete, return the cost to reach the destination, if it is not the large value you set prior, in which case the problem indicates that you should return -1.\\n\\n\\n# Complexity\\nLetting E be the number of edges, N be the number of nodes and K being the number of allowed connections:\\n- Time complexity:\\nO(K * (N + E)) - All nodes, edges are iterated through a maximum of K+1 times\\n\\n- Space complexity:\\nO(N) - Two arrays containing N costs to reach a given node\\n# Code\\n```\\n\"\"\"\\nBellman-Ford Algorithm\\n0. Construct edgeDict, inital cost array\\n1. Iterate through vertexes K+1 times\\n    0. Create temp array based off current costs\\n    1. Update each node in the temp array with the minimum of the current temporary value and the non-temporary costs + edge weight\\n    2. Update the non-temporary array with the current temporary array\\n3. Return the cost to reach the destination, if it is not float(\\'inf\\')\\n\"\"\"\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        edgeDict = collections.defaultdict(list)\\n        for vertex, edge, weight in flights:\\n            edgeDict[vertex].append((edge, weight))\\n\\n        costs = [float(\\'inf\\') for _ in range(n)]\\n        costs[src] = 0\\n        \\n        for _ in range(k + 1):\\n            temp = costs.copy()\\n            for vertex in range(n):\\n                for edge, weight in edgeDict[vertex]:\\n                    temp[edge] = min(temp[edge], costs[vertex] + weight)\\n            costs = temp\\n        \\n        if temp[dst] != float(\\'inf\\'):\\n            return temp[dst]\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\nBellman-Ford Algorithm\\n0. Construct edgeDict, inital cost array\\n1. Iterate through vertexes K+1 times\\n    0. Create temp array based off current costs\\n    1. Update each node in the temp array with the minimum of the current temporary value and the non-temporary costs + edge weight\\n    2. Update the non-temporary array with the current temporary array\\n3. Return the cost to reach the destination, if it is not float(\\'inf\\')\\n\"\"\"\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        edgeDict = collections.defaultdict(list)\\n        for vertex, edge, weight in flights:\\n            edgeDict[vertex].append((edge, weight))\\n\\n        costs = [float(\\'inf\\') for _ in range(n)]\\n        costs[src] = 0\\n        \\n        for _ in range(k + 1):\\n            temp = costs.copy()\\n            for vertex in range(n):\\n                for edge, weight in edgeDict[vertex]:\\n                    temp[edge] = min(temp[edge], costs[vertex] + weight)\\n            costs = temp\\n        \\n        if temp[dst] != float(\\'inf\\'):\\n            return temp[dst]\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953963,
                "title": "javascript-bellman-ford-time-o-e-k-easy-and-fast",
                "content": "```\\nvar findCheapestPrice = function (n, flights, src, dst, k) {\\n    let prices = new Array(n).fill(Infinity);\\n    prices[src] = 0;\\n\\n    for (let i = 0; i < k + 1; i++) {\\n        let tmpPrices = [...prices];\\n        for (let [s, d, p] of flights) {\\n            if (prices[s] === Infinity) continue;\\n            if (prices[s] + p < tmpPrices[d]) tmpPrices[d] = prices[s] + p;\\n        }\\n        prices = [...tmpPrices];\\n    }\\n\\n    return prices[dst] === Infinity ? -1 : prices[dst];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nvar findCheapestPrice = function (n, flights, src, dst, k) {\\n    let prices = new Array(n).fill(Infinity);\\n    prices[src] = 0;\\n\\n    for (let i = 0; i < k + 1; i++) {\\n        let tmpPrices = [...prices];\\n        for (let [s, d, p] of flights) {\\n            if (prices[s] === Infinity) continue;\\n            if (prices[s] + p < tmpPrices[d]) tmpPrices[d] = prices[s] + p;\\n        }\\n        prices = [...tmpPrices];\\n    }\\n\\n    return prices[dst] === Infinity ? -1 : prices[dst];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522443,
                "title": "c-bellman-ford-algorithm-bfs-bottom-up-dp-relax-operation-for-k-1-times",
                "content": "```\\nclass Solution {\\npublic:\\n    //Bellman Ford Algorithm\\n    int shortestPath(vector<vector<int>>& flights,int src,int dst,int k,int n){\\n        vector<int> dist(n,INT_MAX);\\n        dist[src] = 0;\\n        for(int count=0; count<=k; count++){\\n            vector<int> temp = dist;\\n            for(vector<int>& v: flights){\\n                if(dist[v[0]] == INT_MAX)\\n                    continue;\\n\\t\\t\\t\\t//Relax Operation\\n                if(temp[v[1]] > dist[v[0]] + v[2])\\n                    temp[v[1]] = dist[v[0]] + v[2];\\n            }\\n            dist = temp;\\n        }\\n        return (dist[dst] == INT_MAX ? -1 : dist[dst]);\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        return shortestPath(flights,src,dst,k,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Bellman Ford Algorithm\\n    int shortestPath(vector<vector<int>>& flights,int src,int dst,int k,int n){\\n        vector<int> dist(n,INT_MAX);\\n        dist[src] = 0;\\n        for(int count=0; count<=k; count++){\\n            vector<int> temp = dist;\\n            for(vector<int>& v: flights){\\n                if(dist[v[0]] == INT_MAX)\\n                    continue;\\n\\t\\t\\t\\t//Relax Operation\\n                if(temp[v[1]] > dist[v[0]] + v[2])\\n                    temp[v[1]] = dist[v[0]] + v[2];\\n            }\\n            dist = temp;\\n        }\\n        return (dist[dst] == INT_MAX ? -1 : dist[dst]);\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        return shortestPath(flights,src,dst,k,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352180,
                "title": "easy-to-understand-java-solution-dynamic-programming",
                "content": "This is the Java version of the easy dynamic programming solution from [here.](https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/686774/SUGGESTION-FOR-BEGINNERS-BFS-or-DIJKSHTRA-or-DP)  PriorityQueue based solutions now give Time limit exceeded. \\n\\n```\\n\\n public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n\\t\\t//dp[i][j] means the minimum distance to reach from src to j with atmost i edges. \\n\\t\\t//Note that, we need atmost k stops, so it means atmost k+1 edges are permitted.\\n\\t\\t//Hence array is initialized with k+2 size.\\n        int[][] dp = new int[k+2][n];\\n        \\n\\t\\t//initiallly, we assume that minimum distance to any point from the source is infinity. \\n        for(int i=0; i<=k+1; i++){\\n           for(int j=0; j<n; j++){\\n\\t\\t      //Distance from source to source is always zero, irrespective of the number of stops/edges permitted. \\n\\t\\t\\t  //Otherwise, we assume Integer.MAX_VALUE unless it is possible to reach destination. \\n               dp[i][j] = j==src?0:Integer.MAX_VALUE;\\n           } \\n        }\\n              \\n        for(int i=1; i<=k+1; i++){\\n            for(int j=0;j<flights.length;j++){           \\n                int[] flight = flights[j];         \\n                int source = flight[0];\\n                int destination = flight[1];\\n                int price = flight[2];\\n         \\n\\t\\t        //We can reach destination in atmost k stops, only if the source/previous stop can be reachable in k-1 stops. Otherwise, it is impossible to reach the destination within k stops. \\n                if(dp[i-1][source] != Integer.MAX_VALUE){\\n                    dp[i][destination]= Math.min(dp[i][destination], dp[i-1][source] + price);\\n                }                \\n            }            \\n        }\\n        \\n        return dp[k+1][dst]==Integer.MAX_VALUE?-1:dp[k+1][dst];\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n\\t\\t//dp[i][j] means the minimum distance to reach from src to j with atmost i edges. \\n\\t\\t//Note that, we need atmost k stops, so it means atmost k+1 edges are permitted.\\n\\t\\t//Hence array is initialized with k+2 size.\\n        int[][] dp = new int[k+2][n];\\n        \\n\\t\\t//initiallly, we assume that minimum distance to any point from the source is infinity. \\n        for(int i=0; i<=k+1; i++){\\n           for(int j=0; j<n; j++){\\n\\t\\t      //Distance from source to source is always zero, irrespective of the number of stops/edges permitted. \\n\\t\\t\\t  //Otherwise, we assume Integer.MAX_VALUE unless it is possible to reach destination. \\n               dp[i][j] = j==src?0:Integer.MAX_VALUE;\\n           } \\n        }\\n              \\n        for(int i=1; i<=k+1; i++){\\n            for(int j=0;j<flights.length;j++){           \\n                int[] flight = flights[j];         \\n                int source = flight[0];\\n                int destination = flight[1];\\n                int price = flight[2];\\n         \\n\\t\\t        //We can reach destination in atmost k stops, only if the source/previous stop can be reachable in k-1 stops. Otherwise, it is impossible to reach the destination within k stops. \\n                if(dp[i-1][source] != Integer.MAX_VALUE){\\n                    dp[i][destination]= Math.min(dp[i][destination], dp[i-1][source] + price);\\n                }                \\n            }            \\n        }\\n        \\n        return dp[k+1][dst]==Integer.MAX_VALUE?-1:dp[k+1][dst];\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246845,
                "title": "java-bellman-ford-algorithm",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n//         Bellman Ford\\n        \\n        int[] path = new int[n];\\n        Arrays.fill(path, Integer.MAX_VALUE);\\n        path[src] = 0;\\n        \\n        for(int i = 0; i<=k; i++){\\n            int temp[] = path.clone(); // temp array is used so that at kth iteration only node at k\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   // stops away can fill\\n            for(int j = 0; j<flights.length; j++){\\n                int u = flights[j][0];\\n                int v = flights[j][1];\\n                int wt = flights[j][2];\\n                \\n                if(path[u] != Integer.MAX_VALUE){\\n                    temp[v] = Math.min(temp[v], path[u] + wt);\\n                }\\n            }\\n            path = temp;\\n        }\\n        \\n        return path[dst] == Integer.MAX_VALUE ? -1 : path[dst];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n//         Bellman Ford\\n        \\n        int[] path = new int[n];\\n        Arrays.fill(path, Integer.MAX_VALUE);\\n        path[src] = 0;\\n        \\n        for(int i = 0; i<=k; i++){\\n            int temp[] = path.clone(); // temp array is used so that at kth iteration only node at k\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   // stops away can fill\\n            for(int j = 0; j<flights.length; j++){\\n                int u = flights[j][0];\\n                int v = flights[j][1];\\n                int wt = flights[j][2];\\n                \\n                if(path[u] != Integer.MAX_VALUE){\\n                    temp[v] = Math.min(temp[v], path[u] + wt);\\n                }\\n            }\\n            path = temp;\\n        }\\n        \\n        return path[dst] == Integer.MAX_VALUE ? -1 : path[dst];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164459,
                "title": "c-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int Solve(int src,int dst,int k,unordered_map<int,unordered_map<int,int>> &adj){\\n        if(src == dst){\\n            return 0;\\n        }\\n        if(k < 0){\\n            return INT_MAX;\\n        }\\n        \\n        if(dp[src][k] != -1){\\n            return dp[src][k];\\n        }\\n        // else go for all valid adjacent stations \\n        int ans = INT_MAX;\\n        for(auto it : adj[src]){\\n           int t = Solve(it.first,dst,k-1,adj);\\n            if(t == INT_MAX){\\n                continue;\\n            }\\n           ans = min(ans,it.second + t);\\n        }\\n        dp[src][k] = ans;\\n        return ans;\\n        \\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int,unordered_map<int,int>>adj;\\n        for(auto it : flights){\\n            adj[it[0]][it[1]]  = it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int dp[n+1][k+1];\\n        \\n        int t = Solve(src,dst,K,adj);\\n        if(t == INT_MAX){\\n            return -1;\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][1001];\\n    int Solve(int src,int dst,int k,unordered_map<int,unordered_map<int,int>> &adj){\\n        if(src == dst){\\n            return 0;\\n        }\\n        if(k < 0){\\n            return INT_MAX;\\n        }\\n        \\n        if(dp[src][k] != -1){\\n            return dp[src][k];\\n        }\\n        // else go for all valid adjacent stations \\n        int ans = INT_MAX;\\n        for(auto it : adj[src]){\\n           int t = Solve(it.first,dst,k-1,adj);\\n            if(t == INT_MAX){\\n                continue;\\n            }\\n           ans = min(ans,it.second + t);\\n        }\\n        dp[src][k] = ans;\\n        return ans;\\n        \\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int,unordered_map<int,int>>adj;\\n        for(auto it : flights){\\n            adj[it[0]][it[1]]  = it[2];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int dp[n+1][k+1];\\n        \\n        int t = Solve(src,dst,K,adj);\\n        if(t == INT_MAX){\\n            return -1;\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790296,
                "title": "readable-python-djikstra",
                "content": "Use -k to evaluate cheapest paths with less stops first\\n\\n````\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        graph = {}\\n\\n        for u in range(n):\\n            graph[u] = []\\n\\n        for u,v,w in flights:\\n            graph[u].append((v,w))\\n\\n        heap = [(0,-K,src)]\\n\\n        while heap:\\n            (cost,i,u) = heapq.heappop(heap)\\n\\n            if u == dst:\\n                return cost\\n\\n            for v,w in graph[u]:\\n                nc = cost + w\\n\\n                if i <= 0:\\n                    heapq.heappush(heap, (nc,i+1,v))\\n\\n        return -1        \\n````",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "````\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        graph = {}\\n\\n        for u in range(n):\\n            graph[u] = []\\n\\n        for u,v,w in flights:\\n            graph[u].append((v,w))\\n\\n        heap = [(0,-K,src)]\\n\\n        while heap:\\n            (cost,i,u) = heapq.heappop(heap)\\n\\n            if u == dst:\\n                return cost\\n\\n            for v,w in graph[u]:\\n                nc = cost + w\\n\\n                if i <= 0:\\n                    heapq.heappush(heap, (nc,i+1,v))\\n\\n        return -1        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 686863,
                "title": "neat-dijkstra-java",
                "content": "```java\\nclass Solution {\\n    private final List<List<int[]>> graph = new ArrayList<>();\\n\\n    private void init(int n, int[][] flights) {\\n        for (int i = 0; i < n; i++)\\n            graph.add(new ArrayList<>());\\n        for (int[] flight : flights)\\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\\n    }\\n\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        init(n, flights);\\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        queue.offer(new int[]{src, 0, 0});\\n        while (!queue.isEmpty()) {\\n            int[] current = queue.poll();\\n            int city = current[0], distance = current[1], cost = current[2];\\n            if (city == dst)\\n                return cost;\\n            if (distance <= K) {\\n                for (int[] child : graph.get(city)) {\\n                    queue.offer(new int[]{child[0], distance + 1, cost + child[1]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    private final List<List<int[]>> graph = new ArrayList<>();\\n\\n    private void init(int n, int[][] flights) {\\n        for (int i = 0; i < n; i++)\\n            graph.add(new ArrayList<>());\\n        for (int[] flight : flights)\\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\\n    }\\n\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        init(n, flights);\\n        Queue<int[]> queue = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        queue.offer(new int[]{src, 0, 0});\\n        while (!queue.isEmpty()) {\\n            int[] current = queue.poll();\\n            int city = current[0], distance = current[1], cost = current[2];\\n            if (city == dst)\\n                return cost;\\n            if (distance <= K) {\\n                for (int[] child : graph.get(city)) {\\n                    queue.offer(new int[]{child[0], distance + 1, cost + child[1]});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433848,
                "title": "bellman-ford-solution",
                "content": "\\'\\'\\'\\n        similar bellman-ford, relax each edge k time to update dist to all point.\\n        each loop will use last (k-1)th time\\'s result to update new dist.\\n        difference with bellman-ford is, it is time restricted,\\n        original bellman-ford will use dist[v]=min(dist[v],dist[u] + w),but dist[u] may be updated in the same iteration.\\n        which may cause one iteration generate more than one relax.\\n        thus use copyed array to store .new result, which ensure each time relax only relax on last level array.\\n        \\'\\'\\'\\n```class Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst,k):#up to k times\\n        dist=[float(\\'inf\\')]*n#dist to dst.\\n        dist[src]=0\\n        for _ in range(k+1):\\n            new_dist=dist[:]\\n            for x,y,dis in flights:\\n                new_dist[y]=min(new_dist[y],dist[x]+dis)\\n            dist=new_dist\\n                \\n        return dist[dst] if dist[dst]!=float(\\'inf\\') else -1\\n        \\n\\t\\t",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n        similar bellman-ford, relax each edge k time to update dist to all point.\\n        each loop will use last (k-1)th time\\'s result to update new dist.\\n        difference with bellman-ford is, it is time restricted,\\n        original bellman-ford will use dist[v]=min(dist[v],dist[u] + w),but dist[u] may be updated in the same iteration.\\n        which may cause one iteration generate more than one relax.\\n        thus use copyed array to store .new result, which ensure each time relax only relax on last level array.\\n        \\'\\'\\'\\n```class Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst,k):#up to k times\\n        dist=[float(\\'inf\\')]*n#dist to dst.\\n        dist[src]=0\\n        for _ in range(k+1):\\n            new_dist=dist[:]\\n            for x,y,dis in flights:\\n                new_dist[y]=min(new_dist[y],dist[x]+dis)\\n            dist=new_dist\\n                \\n        return dist[dst] if dist[dst]!=float(\\'inf\\') else -1\\n        \\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 292696,
                "title": "java-dp-solution",
                "content": "dp[i][j] means within i flights, the min cost to city j.\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        double[][] dp = new double[K + 2][n];\\n        for (int i = 0; i < K + 2; i++) {\\n        \\tfor (int j = 0; j < n; j++) {\\n        \\t\\tdp[i][j] = 1e9;\\n        \\t}\\n        }\\n        dp[0][src] = 0;\\n        for (int i = 1; i <= K + 1; i++) {\\n        \\tdp[i][src] = 0;\\n        \\tfor (int[] flight : flights) {\\n        \\t\\tdp[i][flight[1]] = Math.min(dp[i][flight[1]], dp[i - 1][flight[0]] + flight[2]);\\n        \\t}\\n        }\\n        return dp[K + 1][dst] >= 1e9 ? -1 : (int)dp[K + 1][dst];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        double[][] dp = new double[K + 2][n];\\n        for (int i = 0; i < K + 2; i++) {\\n        \\tfor (int j = 0; j < n; j++) {\\n        \\t\\tdp[i][j] = 1e9;\\n        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 226772,
                "title": "js-beat-100-using-dp",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} flights\\n * @param {number} src\\n * @param {number} dst\\n * @param {number} K\\n * @return {number}\\n */\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n  var mn = new Array(n + 1).fill(Infinity);\\n  mn[src] = 0;\\n  for(var k = 0; k < K + 1; k++){\\n    var newmn = [].concat(mn);\\n    for(var i = 0; i < flights.length; i++){\\n      var f = flights[i], a = f[0], b = f[1], c = f[2];\\n      newmn[b] = Math.min(newmn[b], mn[a] + c);\\n    }\\n    mn = [].concat(newmn);\\n  }\\n  return mn[dst] != Infinity ? mn[dst] : -1\\n};\\n```\\nRuntime: 80 ms, faster than 100.00% of JavaScript online submissions for Cheapest Flights Within K Stops.",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} flights\\n * @param {number} src\\n * @param {number} dst\\n * @param {number} K\\n * @return {number}\\n */\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n  var mn = new Array(n + 1).fill(Infinity);\\n  mn[src] = 0;\\n  for(var k = 0; k < K + 1; k++){\\n    var newmn = [].concat(mn);\\n    for(var i = 0; i < flights.length; i++){\\n      var f = flights[i], a = f[0], b = f[1], c = f[2];\\n      newmn[b] = Math.min(newmn[b], mn[a] + c);\\n    }\\n    mn = [].concat(newmn);\\n  }\\n  return mn[dst] != Infinity ? mn[dst] : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115570,
                "title": "bfs-with-small-tweak-to-guarantee-k-stops",
                "content": "Many posts on the discussion here for this problem doesn't produce valid output for this input:\n```\n4\n[[0,1,100],[0,2,300],[0,3,500],[1,2,100],[2,3,100]]\n0\n3\n1\n```\nBecause if you simply allow the BFS to run 2 iterations (with k = 1), the distance between 0 and 3 would reduce to 300 because of this path (0->1->2->3), we shouldn't allow 2 to update 3 in the last iteration.If you write out what's in the queue and manually run it you will see what I'm saying. The trick is to only allow updates for destination in the last iteration.\n\n```\npublic class Solution\n{\n\tpublic int FindCheapestPrice(int n, int[,] flights, int src, int dst, int K) {\n\t\tvar nodes = this.InitializeGraph(flights);\n\n\t\tvar queue = new Queue<int>();\n\t\tvar cost = new Queue<int>();\n\t\tforeach (var airport in nodes.Keys) {\n\t\t\tnodes[airport].MinCost = Int32.MaxValue;\n\t\t}\n\n\t\tnodes[src].MinCost = 0;\n\t\tqueue.Enqueue(src);\n\t\tcost.Enqueue(0);\n\n\t\tint stops = 0;\n\t\twhile (queue.Count != 0) {\n\t\t\tif (stops > K) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint size = queue.Count;\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tvar currentNode = nodes[queue.Dequeue()];\n\t\t\t\tint currentCost = cost.Dequeue();\n\n\t\t\t\t// Optional: If we reach destination, we don't need to process target's neighbor\n\t\t\t\tif (currentNode.Label == dst) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach (var neighbor in currentNode.Neighbors.Keys) {\n\t\t\t\t\t// If this is the last iteration, we should only update neighbor == target\n\t\t\t\t\t// otherwise we might create other minCost that require more than k stops\n\t\t\t\t\tif (stops == K && neighbor != dst) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint nextCost = currentCost + currentNode.Neighbors[neighbor];\n\t\t\t\t\tif (nextCost < nodes[neighbor].MinCost) {\n\t\t\t\t\t\tnodes[neighbor].MinCost = nextCost;\n\t\t\t\t\t\tqueue.Enqueue(neighbor);\n\t\t\t\t\t\tcost.Enqueue(nextCost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstops++;\n\t\t}\n\n\t\tif (nodes[dst].MinCost == Int32.MaxValue) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn nodes[dst].MinCost;\n\t}\n\n\tprivate Dictionary<int, Node> InitializeGraph(int[,] flights) {\n\t\tvar nodes = new Dictionary<int, Node>();\n\t\tfor(int f = 0; f < flights.GetLength(0); f++) {\n\t\t\tvar from = flights[f,0];\n\t\t\tvar to = flights[f, 1];\n\t\t\tvar cost = flights[f, 2];\n\n\t\t\tif (!nodes.ContainsKey(from)) {\n\t\t\t\tnodes[from] = new Node(from);\n\t\t\t}\n\n\t\t\tif (!nodes.ContainsKey(to)) {\n\t\t\t\tnodes[to] = new Node(to);\n\t\t\t}\n\t\t\tnodes[from].Neighbors[to] = cost;\n\t\t}\n\n\t\treturn nodes;\n\t}\n}\n\npublic class Node\n{\n\tpublic int Label { get; set; }\n\tpublic Dictionary<int, int> Neighbors { get; }\n\tpublic int MinCost { get; set; }\n\n\tpublic Node(int label) {\n\t\tthis.Label = label;\n\t\tthis.Neighbors = new Dictionary<int, int>();\n\t}\n}\n```",
                "solutionTags": [],
                "code": "```\n4\n[[0,1,100],[0,2,300],[0,3,500],[1,2,100],[2,3,100]]\n0\n3\n1\n```\n```\npublic class Solution\n{\n\tpublic int FindCheapestPrice(int n, int[,] flights, int src, int dst, int K) {\n\t\tvar nodes = this.InitializeGraph(flights);\n\n\t\tvar queue = new Queue<int>();\n\t\tvar cost = new Queue<int>();\n\t\tforeach (var airport in nodes.Keys) {\n\t\t\tnodes[airport].MinCost = Int32.MaxValue;\n\t\t}\n\n\t\tnodes[src].MinCost = 0;\n\t\tqueue.Enqueue(src);\n\t\tcost.Enqueue(0);\n\n\t\tint stops = 0;\n\t\twhile (queue.Count != 0) {\n\t\t\tif (stops > K) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint size = queue.Count;\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tvar currentNode = nodes[queue.Dequeue()];\n\t\t\t\tint currentCost = cost.Dequeue();\n\n\t\t\t\t// Optional: If we reach destination, we don't need to process target's neighbor\n\t\t\t\tif (currentNode.Label == dst) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tforeach (var neighbor in currentNode.Neighbors.Keys) {\n\t\t\t\t\t// If this is the last iteration, we should only update neighbor == target\n\t\t\t\t\t// otherwise we might create other minCost that require more than k stops\n\t\t\t\t\tif (stops == K && neighbor != dst) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tint nextCost = currentCost + currentNode.Neighbors[neighbor];\n\t\t\t\t\tif (nextCost < nodes[neighbor].MinCost) {\n\t\t\t\t\t\tnodes[neighbor].MinCost = nextCost;\n\t\t\t\t\t\tqueue.Enqueue(neighbor);\n\t\t\t\t\t\tcost.Enqueue(nextCost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstops++;\n\t\t}\n\n\t\tif (nodes[dst].MinCost == Int32.MaxValue) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn nodes[dst].MinCost;\n\t}\n\n\tprivate Dictionary<int, Node> InitializeGraph(int[,] flights) {\n\t\tvar nodes = new Dictionary<int, Node>();\n\t\tfor(int f = 0; f < flights.GetLength(0); f++) {\n\t\t\tvar from = flights[f,0];\n\t\t\tvar to = flights[f, 1];\n\t\t\tvar cost = flights[f, 2];\n\n\t\t\tif (!nodes.ContainsKey(from)) {\n\t\t\t\tnodes[from] = new Node(from);\n\t\t\t}\n\n\t\t\tif (!nodes.ContainsKey(to)) {\n\t\t\t\tnodes[to] = new Node(to);\n\t\t\t}\n\t\t\tnodes[from].Neighbors[to] = cost;\n\t\t}\n\n\t\treturn nodes;\n\t}\n}\n\npublic class Node\n{\n\tpublic int Label { get; set; }\n\tpublic Dictionary<int, int> Neighbors { get; }\n\tpublic int MinCost { get; set; }\n\n\tpublic Node(int label) {\n\t\tthis.Label = label;\n\t\tthis.Neighbors = new Dictionary<int, int>();\n\t}\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 115500,
                "title": "adapted-dijkstra-python",
                "content": "\n> **Note: The code has been updated at 2018-2-18 17:33:41 (MST) to fix a bug pointed by @chang17 and @jray319. Thanks!**\n> Their test case should be added in. The testcases for the contest did not cover those.\n> The fix makes the solution not really a Dijkstra that it is losing some property that Dijkstra has to use a priority queue. Instead, it falls into a BFS like solution.\n> But since I effectively adapt it from Dijkstra, I decide to remain the original code in the bottom for anyone who is interested in the changes.\n\n\nThis is basically an implementation for the Dijkstra algorithm based on the description in the book \"Cracking the coding interview\", page 634. Its description is really clear.\nThe only thing that is \"adapted\" is highlighted in the code ```# this two lines are important``` below.\n\nUsing vanila Dijkstra can help us figure out the shortest weighted path from the ```src``` to ```dst```.\nBut then we lose the information of those paths that can reach ```dst``` with less stop.\nSo I record the information into the ```results``` list. Once it somehow reaches the ```dst``` from a path, we record it.\n\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        remain, ret, stop = [], float('inf'), 0\n        weights = [sys.maxint for i in range(n)]\n        graph = [{} for i in range(n)]\n        for s,d,w in flights:\n            graph[s][d]=w\n\n        heapq.heappush(remain, (0, src))\n        weights[src] = 0\n        while remain and stop <= K:\n            tmp, remain = remain, []\n            while tmp:\n                weight, node = heapq.heappop(tmp)\n                for tonode, toweight in graph[node].items():\n                    if weights[tonode] > weight + toweight:\n                        weights[tonode] = weight + toweight\n                        heapq.heappush(remain, (weights[tonode], tonode))    \n                    # this two lines are important\n                    if tonode == dst and weights[tonode]<ret:\n                        ret = weights[tonode]\n            stop+=1\n        return ret if ret < float('inf') else -1\n```\n\n**==========================================**\n> Below is the original code, that passed the testcases in the system but did not pass the testcase from @chang17 and @jray319\n> This adaptation and fix itself to me is a very interesting and great lesson to learn Dijkstra, maybe just because this is my first time implementing a Dijkstra.\n> hope you enjoy it too!\n\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        def getcount():\n            pre, count = dst, 0\n            while previous[pre] is not None:\n                count += 1\n                pre = previous[pre]\n            return count-1\n        \n        remain, results = [], []\n        graph = [{} for i in range(n)]\n        previous = [None for i in range(n)]\n        weights = [sys.maxint for i in range(n)]\n        for s,d,w in flights:\n            graph[s][d]=w\n\n        heapq.heappush(remain, (0, src))\n        weights[src] = 0\n        \n        while remain:\n            weight, node = heapq.heappop(remain)\n            for tonode, toweight in graph[node].items():\n                if weights[tonode] > weight + toweight:\n                    weights[tonode] = weight + toweight\n                    heapq.heappush(remain, (weights[tonode], tonode))\n                    previous[tonode] = node\n                if tonode == dst:\n                    heapq.heappush(results, (weights[tonode], getcount()))\n                        \n        while results:\n            w, count = heapq.heappop(results)\n            if count<=K:\n                return w        \n        return -1\n            \n```\n\nThe test cases:\nfrom @chang17,\n```\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n```\nfrom @jray319,\n```\n4\n[[0,1,1],[1,2,1],[2,3,1],[0,2,100]]\n0\n3\n1\n```",
                "solutionTags": [],
                "code": "```# this two lines are important```\n```src```\n```dst```\n```dst```\n```results```\n```dst```\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        remain, ret, stop = [], float('inf'), 0\n        weights = [sys.maxint for i in range(n)]\n        graph = [{} for i in range(n)]\n        for s,d,w in flights:\n            graph[s][d]=w\n\n        heapq.heappush(remain, (0, src))\n        weights[src] = 0\n        while remain and stop <= K:\n            tmp, remain = remain, []\n            while tmp:\n                weight, node = heapq.heappop(tmp)\n                for tonode, toweight in graph[node].items():\n                    if weights[tonode] > weight + toweight:\n                        weights[tonode] = weight + toweight\n                        heapq.heappush(remain, (weights[tonode], tonode))    \n                    # this two lines are important\n                    if tonode == dst and weights[tonode]<ret:\n                        ret = weights[tonode]\n            stop+=1\n        return ret if ret < float('inf') else -1\n```\n```\nclass Solution(object):\n    def findCheapestPrice(self, n, flights, src, dst, K):\n        def getcount():\n            pre, count = dst, 0\n            while previous[pre] is not None:\n                count += 1\n                pre = previous[pre]\n            return count-1\n        \n        remain, results = [], []\n        graph = [{} for i in range(n)]\n        previous = [None for i in range(n)]\n        weights = [sys.maxint for i in range(n)]\n        for s,d,w in flights:\n            graph[s][d]=w\n\n        heapq.heappush(remain, (0, src))\n        weights[src] = 0\n        \n        while remain:\n            weight, node = heapq.heappop(remain)\n            for tonode, toweight in graph[node].items():\n                if weights[tonode] > weight + toweight:\n                    weights[tonode] = weight + toweight\n                    heapq.heappush(remain, (weights[tonode], tonode))\n                    previous[tonode] = node\n                if tonode == dst:\n                    heapq.heappush(results, (weights[tonode], getcount()))\n                        \n        while results:\n            w, count = heapq.heappop(results)\n            if count<=K:\n                return w        \n        return -1\n            \n```\n```\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n```\n```\n4\n[[0,1,1],[1,2,1],[2,3,1],[0,2,100]]\n0\n3\n1\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100437,
                "title": "c-bfs-full-explanation-dijkstra-s-algo-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int src,int dst,int k,int n,vector<vector<int>> adj[])\\n    {\\n        queue<vector<int>> q;                       // make queue of vector for storing {node,dist,stop}\\n        q.push({src,0,0});                          // {node,dist,stop}\\n        vector<int> dis(n,INT_MAX);                 // for keep traking of minimum dist for every node\\n        dis[src]=0;                                 // src to src will be 0\\n        \\n        // BFS\\n        while(!q.empty())\\n        {\\n            int node = q.front()[0];\\n            int cost = q.front()[1];\\n            int stop = q.front()[2];\\n            q.pop();\\n            \\n            if(stop>k) continue;                     // if stop is bigger than k then just continue no need to find cost\\n            \\n            // check adjacency nodes\\n            for(auto &it : adj[node])\\n            {\\n                int nexNode = it[0];                 // nextNode\\n                int nexWeight = it[1];               // nextNode Weight\\n                \\n                // if i am having better option then took that and push it into queue with stop+1, as i used node as a stop\\n                if(cost +  nexWeight < dis[nexNode])\\n                {\\n                    dis[nexNode] = cost + nexWeight;                     // taking min cost for nexNode\\n                    q.push({nexNode, dis[nexNode],stop+1});\\n                }\\n            }\\n        }\\n        \\n        if(dis[dst]==INT_MAX) return -1;                // if I didn\\'t reached to my dst then return -1\\n        else return dis[dst];                           // return min cost for dst node from  dis\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        // Directed Graph\\n        vector<vector<int>> adj[n];\\n        for(auto &it : flights)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        // Function calling for BFS\\n        int ans = solve(src,dst,k,n,adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int src,int dst,int k,int n,vector<vector<int>> adj[])\\n    {\\n        queue<vector<int>> q;                       // make queue of vector for storing {node,dist,stop}\\n        q.push({src,0,0});                          // {node,dist,stop}\\n        vector<int> dis(n,INT_MAX);                 // for keep traking of minimum dist for every node\\n        dis[src]=0;                                 // src to src will be 0\\n        \\n        // BFS\\n        while(!q.empty())\\n        {\\n            int node = q.front()[0];\\n            int cost = q.front()[1];\\n            int stop = q.front()[2];\\n            q.pop();\\n            \\n            if(stop>k) continue;                     // if stop is bigger than k then just continue no need to find cost\\n            \\n            // check adjacency nodes\\n            for(auto &it : adj[node])\\n            {\\n                int nexNode = it[0];                 // nextNode\\n                int nexWeight = it[1];               // nextNode Weight\\n                \\n                // if i am having better option then took that and push it into queue with stop+1, as i used node as a stop\\n                if(cost +  nexWeight < dis[nexNode])\\n                {\\n                    dis[nexNode] = cost + nexWeight;                     // taking min cost for nexNode\\n                    q.push({nexNode, dis[nexNode],stop+1});\\n                }\\n            }\\n        }\\n        \\n        if(dis[dst]==INT_MAX) return -1;                // if I didn\\'t reached to my dst then return -1\\n        else return dis[dst];                           // return min cost for dst node from  dis\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        // Directed Graph\\n        vector<vector<int>> adj[n];\\n        for(auto &it : flights)\\n        {\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        // Function calling for BFS\\n        int ans = solve(src,dst,k,n,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099981,
                "title": "java-easy-understanding-graph-shortest-path",
                "content": "# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int prev[]=new int[n];\\n        Arrays.fill(prev,Integer.MAX_VALUE);\\n        prev[src]=0;\\n        for(int i=0;i<=k;i++){\\n            int cur[]=new int[n];\\n            for(int j=0;j<n;j++) cur[j]=prev[j];\\n                for(int e[]:flights){\\n                    int u=e[0],v=e[1],wt=e[2];\\n                    if(prev[u]!=Integer.MAX_VALUE&&prev[u]+wt<cur[v]){\\n                        cur[v]=prev[u]+wt;\\n                    }\\n                }\\n            for(int j=0;j<n;j++) prev[j]=cur[j];\\n        }\\n        return prev[dst]==Integer.MAX_VALUE?-1:prev[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int prev[]=new int[n];\\n        Arrays.fill(prev,Integer.MAX_VALUE);\\n        prev[src]=0;\\n        for(int i=0;i<=k;i++){\\n            int cur[]=new int[n];\\n            for(int j=0;j<n;j++) cur[j]=prev[j];\\n                for(int e[]:flights){\\n                    int u=e[0],v=e[1],wt=e[2];\\n                    if(prev[u]!=Integer.MAX_VALUE&&prev[u]+wt<cur[v]){\\n                        cur[v]=prev[u]+wt;\\n                    }\\n                }\\n            for(int j=0;j<n;j++) prev[j]=cur[j];\\n        }\\n        return prev[dst]==Integer.MAX_VALUE?-1:prev[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099921,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/zWZLw81HSks\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} flights\\n * @param {number} src\\n * @param {number} dst\\n * @param {number} k\\n * @return {number}\\n */\\nvar findCheapestPrice = function(n, flights, src, dst, k) {\\n    let map = {}\\n\\n    for(let [x,y,z] of flights){\\n        if(!map[y]) map[y] = []\\n        map[y].push([x,y,z])\\n    }\\n\\n    let min = Infinity;\\n\\n    let iterate = (end,sum,count)=>{\\n        if(count>k || sum >min) return;\\n\\n        if(end == src){\\n            min = Math.min(min,sum)\\n            return;\\n        }\\n        if(!map[end]) return;\\n\\n        for(let [x,y,z] of map[end]){\\n            iterate(x,sum+z,count+1)\\n        }\\n    }\\n    iterate(dst,0,-1)\\n    return min == Infinity ? -1 : min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} flights\\n * @param {number} src\\n * @param {number} dst\\n * @param {number} k\\n * @return {number}\\n */\\nvar findCheapestPrice = function(n, flights, src, dst, k) {\\n    let map = {}\\n\\n    for(let [x,y,z] of flights){\\n        if(!map[y]) map[y] = []\\n        map[y].push([x,y,z])\\n    }\\n\\n    let min = Infinity;\\n\\n    let iterate = (end,sum,count)=>{\\n        if(count>k || sum >min) return;\\n\\n        if(end == src){\\n            min = Math.min(min,sum)\\n            return;\\n        }\\n        if(!map[end]) return;\\n\\n        for(let [x,y,z] of map[end]){\\n            iterate(x,sum+z,count+1)\\n        }\\n    }\\n    iterate(dst,0,-1)\\n    return min == Infinity ? -1 : min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3099807,
                "title": "python-simple-modified-dijkstra",
                "content": "# Code\\n```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        G = defaultdict(list)\\n        for v, w, d in flights:\\n            G[v].append((w,d))\\n        h = [(0, 0, src)]\\n        visited = set()\\n        while h:\\n            d, curk, v = heappop(h)\\n            if v == dst: return d\\n            if (v, curk) in visited or curk > k: continue\\n            visited.add((v, curk))\\n            for w, ecost in G[v]:\\n                heappush(h, (d+ecost, curk + 1, w))\\n        return -1\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        G = defaultdict(list)\\n        for v, w, d in flights:\\n            G[v].append((w,d))\\n        h = [(0, 0, src)]\\n        visited = set()\\n        while h:\\n            d, curk, v = heappop(h)\\n            if v == dst: return d\\n            if (v, curk) in visited or curk > k: continue\\n            visited.add((v, curk))\\n            for w, ecost in G[v]:\\n                heappush(h, (d+ecost, curk + 1, w))\\n        return -1\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099788,
                "title": "c-easy-dfs-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<pair<int, int>>>& adj, vector<vector<int>>&dp, int& target, int maxFlightsAllowed, int curr)\\n    {\\n        if (curr == target) return 0;\\n        if (maxFlightsAllowed == 0) return INT_MAX;\\n        if (dp[curr][maxFlightsAllowed] != -1) return dp[curr][maxFlightsAllowed];\\n        \\n        int mnPrice = INT_MAX;\\n        for (pair<int, int>& adjNode : adj[curr])\\n        {\\n            int nextStop = adjNode.first;\\n            int flightPrice = adjNode.second;\\n            if (flightPrice == -1) continue; //already visited node\\n            \\n            adjNode.second = -1; //mark visited\\n            //====================================================================\\n            int priceToTarget = solve(adj, dp, target, maxFlightsAllowed - 1, nextStop);\\n            int totalPrice = (priceToTarget == INT_MAX)? INT_MAX : flightPrice + priceToTarget;\\n            mnPrice = min(mnPrice, totalPrice);\\n            //=======================================================================\\n            adjNode.second = flightPrice; //unmark visited\\n        }\\n        return dp[curr][maxFlightsAllowed] = mnPrice;\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>&flight : flights) adj[flight[0]].push_back({flight[1], flight[2]});\\n        \\n        k++; //flightsAllowed = stopsAllowed(k) + 1\\n        vector<vector<int>>dp(n, vector<int>(k + 1, -1));\\n        int bestPrice = solve(adj, dp, dst, k, src);\\n        return (bestPrice == INT_MAX? -1 : bestPrice);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<pair<int, int>>>& adj, vector<vector<int>>&dp, int& target, int maxFlightsAllowed, int curr)\\n    {\\n        if (curr == target) return 0;\\n        if (maxFlightsAllowed == 0) return INT_MAX;\\n        if (dp[curr][maxFlightsAllowed] != -1) return dp[curr][maxFlightsAllowed];\\n        \\n        int mnPrice = INT_MAX;\\n        for (pair<int, int>& adjNode : adj[curr])\\n        {\\n            int nextStop = adjNode.first;\\n            int flightPrice = adjNode.second;\\n            if (flightPrice == -1) continue; //already visited node\\n            \\n            adjNode.second = -1; //mark visited\\n            //====================================================================\\n            int priceToTarget = solve(adj, dp, target, maxFlightsAllowed - 1, nextStop);\\n            int totalPrice = (priceToTarget == INT_MAX)? INT_MAX : flightPrice + priceToTarget;\\n            mnPrice = min(mnPrice, totalPrice);\\n            //=======================================================================\\n            adjNode.second = flightPrice; //unmark visited\\n        }\\n        return dp[curr][maxFlightsAllowed] = mnPrice;\\n    }\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>&flight : flights) adj[flight[0]].push_back({flight[1], flight[2]});\\n        \\n        k++; //flightsAllowed = stopsAllowed(k) + 1\\n        vector<vector<int>>dp(n, vector<int>(k + 1, -1));\\n        int bestPrice = solve(adj, dp, dst, k, src);\\n        return (bestPrice == INT_MAX? -1 : bestPrice);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671408,
                "title": "c-dijkstra-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto it: flights){\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        queue<pair<int,pair<int,int>>> q;\\n        \\n        //{stops,{node,dist}};\\n        q.push({0,{src,0}});\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int stops = it.first;\\n            int node = it.second.first;\\n            int cost = it.second.second;\\n            \\n            if(stops > k) continue;\\n            for(auto itr: adj[node]){\\n                int adjNode = itr.first;\\n                int edW = itr.second;\\n                \\n                if(cost + edW < dist[adjNode] && stops <= k)\\n                {\\n                    dist[adjNode] = cost + edW;\\n                    q.push({stops+1,{adjNode,cost + edW}});\\n                }\\n            }\\n        }\\n        \\n        if(dist[dst] == 1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        \\n        for(auto it: flights){\\n            adj[it[0]].push_back({it[1],it[2]});\\n        }\\n        \\n        queue<pair<int,pair<int,int>>> q;\\n        \\n        //{stops,{node,dist}};\\n        q.push({0,{src,0}});\\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        \\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int stops = it.first;\\n            int node = it.second.first;\\n            int cost = it.second.second;\\n            \\n            if(stops > k) continue;\\n            for(auto itr: adj[node]){\\n                int adjNode = itr.first;\\n                int edW = itr.second;\\n                \\n                if(cost + edW < dist[adjNode] && stops <= k)\\n                {\\n                    dist[adjNode] = cost + edW;\\n                    q.push({stops+1,{adjNode,cost + edW}});\\n                }\\n            }\\n        }\\n        \\n        if(dist[dst] == 1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085006,
                "title": "simple-js-solution-w-comments-dfs-dijkstra-s-bellman-ford",
                "content": "```\\n/**\\n * DFS - Memoization\\n * *Time: O(V x K)\\n * *Space: O(V x K + V^2), V x K => space by memoization\\n */\\n// Runtime: 217 ms, faster than 20.38% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 52.4 MB, less than 18.21% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  const graph = {};\\n  const memo = {};\\n\\n  for (const [x, y, price] of flights) {\\n    if (!graph[x]) graph[x] = [];\\n    graph[x].push([y, price]);\\n  }\\n\\n  const traverse = (x, stops) => {\\n    const key = `${x}-${stops}`;\\n    let min = Infinity; // min price\\n\\n    // destination reached: add cost from destination to src\\n    if (x === dst) return 0;\\n    if (stops === 0) return -1;\\n    if (!graph[x]) return -1;\\n    if (memo[key]) return memo[key];\\n\\n    for (const [y, price] of graph[x]) {\\n      const total = traverse(y, stops - 1);\\n\\n      if (total === -1) continue; // invalid route: continue\\n      min = Math.min(min, total + price); // valid route: update min cost\\n    }\\n\\n    // memoize node-stops: min price\\n    // price can change for each node based on number of stops\\n    memo[key] = min;\\n    return min !== Infinity ? min : -1;\\n  };\\n\\n  const output = traverse(src, k + 1);\\n  return output !== Infinity ? output : -1;\\n};\\n\\n/**\\n * Dijkstra\\'s Algorithm\\n * *Time: O((V + E) x log V)\\n * *Space: O(V^2)\\n */\\n// Runtime: 182 ms, faster than 28.26% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 48.7 MB, less than 50.54% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  const graph = {};\\n\\n  for (const [x, y, price] of flights) {\\n    if (!graph[x]) graph[x] = [];\\n    graph[x].push([y, price]);\\n  }\\n\\n  const dp = Array.from({ length: n }, () => Infinity);\\n  dp[src] = 0;\\n\\n  const pq = [[src, 0, k + 1]]; // x, cost, stops\\n\\n  while (pq.length) {\\n    const [x, total, stops] = pq.shift();\\n\\n    if (x === dst) continue; // continue to find cheapest path\\n    if (stops === 0) continue; // exausted number of steps\\n    if (!graph[x]) continue;\\n\\n    for (const [y, price] of graph[x]) {\\n\\t// update destination cost if cheaper\\n      if (dp[y] > total + price) {\\n        dp[y] = total + price;\\n        pq.push([y, total + price, stops - 1]);\\n      }\\n    }\\n  }\\n\\n  return dp[dst] !== Infinity ? dp[dst] : -1;\\n};\\n\\n/**\\n * Bellman-Ford\\n * K = K + 1 iterations || E = number of edges || N = number of elements\\n * *Time: O(K x E)\\n * *Space: O(N)\\n */\\n// Runtime: 92 ms, faster than 91.54% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 41.5 MB, less than 89.34% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  let dp = Array.from({ length: n + 1 }, () => Infinity);\\n  dp[src] = 0;\\n\\n  // starting from source: visiting k + 1 verticies\\n  // if possible: visit all possible path to destination\\n  for (i = 0; i < k + 1; i++) {\\n    const temp = [...dp]; // array for comparison\\n\\n    // find cheapeast price for each path\\n    for (const [x, y, price] of flights) {\\n      if (dp[x] === Infinity) continue;\\n      temp[y] = Math.min(temp[y], dp[x] + price); // get cost from src -> dst and update\\n    }\\n\\n    dp = temp;\\n  }\\n\\n  return dp[dst] !== Infinity ? dp[dst] : -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * DFS - Memoization\\n * *Time: O(V x K)\\n * *Space: O(V x K + V^2), V x K => space by memoization\\n */\\n// Runtime: 217 ms, faster than 20.38% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 52.4 MB, less than 18.21% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  const graph = {};\\n  const memo = {};\\n\\n  for (const [x, y, price] of flights) {\\n    if (!graph[x]) graph[x] = [];\\n    graph[x].push([y, price]);\\n  }\\n\\n  const traverse = (x, stops) => {\\n    const key = `${x}-${stops}`;\\n    let min = Infinity; // min price\\n\\n    // destination reached: add cost from destination to src\\n    if (x === dst) return 0;\\n    if (stops === 0) return -1;\\n    if (!graph[x]) return -1;\\n    if (memo[key]) return memo[key];\\n\\n    for (const [y, price] of graph[x]) {\\n      const total = traverse(y, stops - 1);\\n\\n      if (total === -1) continue; // invalid route: continue\\n      min = Math.min(min, total + price); // valid route: update min cost\\n    }\\n\\n    // memoize node-stops: min price\\n    // price can change for each node based on number of stops\\n    memo[key] = min;\\n    return min !== Infinity ? min : -1;\\n  };\\n\\n  const output = traverse(src, k + 1);\\n  return output !== Infinity ? output : -1;\\n};\\n\\n/**\\n * Dijkstra\\'s Algorithm\\n * *Time: O((V + E) x log V)\\n * *Space: O(V^2)\\n */\\n// Runtime: 182 ms, faster than 28.26% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 48.7 MB, less than 50.54% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  const graph = {};\\n\\n  for (const [x, y, price] of flights) {\\n    if (!graph[x]) graph[x] = [];\\n    graph[x].push([y, price]);\\n  }\\n\\n  const dp = Array.from({ length: n }, () => Infinity);\\n  dp[src] = 0;\\n\\n  const pq = [[src, 0, k + 1]]; // x, cost, stops\\n\\n  while (pq.length) {\\n    const [x, total, stops] = pq.shift();\\n\\n    if (x === dst) continue; // continue to find cheapest path\\n    if (stops === 0) continue; // exausted number of steps\\n    if (!graph[x]) continue;\\n\\n    for (const [y, price] of graph[x]) {\\n\\t// update destination cost if cheaper\\n      if (dp[y] > total + price) {\\n        dp[y] = total + price;\\n        pq.push([y, total + price, stops - 1]);\\n      }\\n    }\\n  }\\n\\n  return dp[dst] !== Infinity ? dp[dst] : -1;\\n};\\n\\n/**\\n * Bellman-Ford\\n * K = K + 1 iterations || E = number of edges || N = number of elements\\n * *Time: O(K x E)\\n * *Space: O(N)\\n */\\n// Runtime: 92 ms, faster than 91.54% of JavaScript online submissions for Cheapest Flights Within K Stops.\\n// Memory Usage: 41.5 MB, less than 89.34% of JavaScript online submissions for Cheapest Flights Within K Stops.\\nconst findCheapestPrice = (n, flights, src, dst, k) => {\\n  let dp = Array.from({ length: n + 1 }, () => Infinity);\\n  dp[src] = 0;\\n\\n  // starting from source: visiting k + 1 verticies\\n  // if possible: visit all possible path to destination\\n  for (i = 0; i < k + 1; i++) {\\n    const temp = [...dp]; // array for comparison\\n\\n    // find cheapeast price for each path\\n    for (const [x, y, price] of flights) {\\n      if (dp[x] === Infinity) continue;\\n      temp[y] = Math.min(temp[y], dp[x] + price); // get cost from src -> dst and update\\n    }\\n\\n    dp = temp;\\n  }\\n\\n  return dp[dst] !== Infinity ? dp[dst] : -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924993,
                "title": "python-dijkstra-best-first-search-with-explaination",
                "content": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: \\n        # construct graph\\n        graph = defaultdict(list)   # key is \\'from\\', value is \\'(to, price)\\'\\n        for from_node, to_node, price in flights:\\n            graph[from_node].append((to_node, price))\\n        \\n        # best-first search/dijkstra (allowing duplicate visit if previous visits do not meet stop requirement)\\n        heap = [(0, -1, src)]   # (cost, stop, node)\\n        min_k = defaultdict(lambda: float(\\'inf\\'))\\n        min_k[src] = 0\\n        while heap:\\n            cost, stop, node = heapq.heappop(heap)\\n            if min_k[node] < stop:  # ignore the path if less-stop path exist\\n                continue\\n            min_k[node] = stop\\n            # check if node is destination\\n            if node == dst:\\n                return cost\\n            # update neighbors\\n            for to_node, to_cost in graph[node]:\\n                if stop+1 <= k:\\n                    heapq.heappush(heap, (cost+to_cost, stop+1, to_node))\\n                    \\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int: \\n        # construct graph\\n        graph = defaultdict(list)   # key is \\'from\\', value is \\'(to, price)\\'\\n        for from_node, to_node, price in flights:\\n            graph[from_node].append((to_node, price))\\n        \\n        # best-first search/dijkstra (allowing duplicate visit if previous visits do not meet stop requirement)\\n        heap = [(0, -1, src)]   # (cost, stop, node)\\n        min_k = defaultdict(lambda: float(\\'inf\\'))\\n        min_k[src] = 0\\n        while heap:\\n            cost, stop, node = heapq.heappop(heap)\\n            if min_k[node] < stop:  # ignore the path if less-stop path exist\\n                continue\\n            min_k[node] = stop\\n            # check if node is destination\\n            if node == dst:\\n                return cost\\n            # update neighbors\\n            for to_node, to_cost in graph[node]:\\n                if stop+1 <= k:\\n                    heapq.heappush(heap, (cost+to_cost, stop+1, to_node))\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759094,
                "title": "easy-c-solution-bellman-ford-detailed-explanation",
                "content": "```\\n#define MAX_DIST 1e6 // greater than (n-1) edges * 1e4 (max price)\\n//here INT_MAX doesnt work since INT_MAX+INT_MAX would give overflow \\n//but if vector is declared with long long int, then it wont give any error\\n\\n//or simply use int for vector but put prev[src]=0 and a condition inside \\n//for loop that ensures prev[f[0]]<INT_MAX\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        if (src == dst) \\n            return 0;\\n        \\n        vector<int> curr(n, MAX_DIST);      //keeps price to reach vertices, using atmost mth edges\\n        vector<int> prev;                   //keeps price to reach vertices, using atmost m-1th edges\\n        \\n        curr[src] = 0;                      //since price taken to reach from src to src = 0\\n        \\n        k++;                                //since atmost k stops are allowed\\n        while(k--){\\n            prev.assign(curr.begin(), curr.end());          //pass by value, and not reference\\n            for(auto f: flights)\\n                curr[f[1]] = min(curr[f[1]], prev[f[0]] + f[2]);\\n        }\\n        \\n        return (curr[dst] == MAX_DIST) ? -1 : curr[dst];    //if there exists no path, i.e MAX_DIST so returning -1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define MAX_DIST 1e6 // greater than (n-1) edges * 1e4 (max price)\\n//here INT_MAX doesnt work since INT_MAX+INT_MAX would give overflow \\n//but if vector is declared with long long int, then it wont give any error\\n\\n//or simply use int for vector but put prev[src]=0 and a condition inside \\n//for loop that ensures prev[f[0]]<INT_MAX\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        if (src == dst) \\n            return 0;\\n        \\n        vector<int> curr(n, MAX_DIST);      //keeps price to reach vertices, using atmost mth edges\\n        vector<int> prev;                   //keeps price to reach vertices, using atmost m-1th edges\\n        \\n        curr[src] = 0;                      //since price taken to reach from src to src = 0\\n        \\n        k++;                                //since atmost k stops are allowed\\n        while(k--){\\n            prev.assign(curr.begin(), curr.end());          //pass by value, and not reference\\n            for(auto f: flights)\\n                curr[f[1]] = min(curr[f[1]], prev[f[0]] + f[2]);\\n        }\\n        \\n        return (curr[dst] == MAX_DIST) ? -1 : curr[dst];    //if there exists no path, i.e MAX_DIST so returning -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678316,
                "title": "how-to-approach-such-problems",
                "content": "1. One way to solve is exhausting all the possible cases, you can use dfs (backtracking) something like in this problem https://leetcode.com/problems/maximum-path-quality-of-a-graph/, (backtracking works in this case because it has very few edges and you will prune the irrelevant cases using the current time+next edge time crosses the time limit) and backtracking works by unvisiting the node when we are done with that.\\n2. Now coming back to this problem, we could have use backtracking here as well but since there is no such restrictions on number of edges and the number of stops can also be high, thus backtracking will not be efficient here\\n3. Now there are multiple ways to solve this problem\\n\\ti. We can use DFS here as well, but problem with using DFS here is when we visit some node there can be efficient way to come to this node with  some other route (from some other ancestor of the current path via other path), so it becomes difficult, so lets think in reverse way, how about filling the answers from down to up? (assume our destination is in down position and source is our root) now from  any intermediate node there can be multiple paths to destination with different costs but we need to find out the one which uses atmost k stops, thus we need to keep track of stops also, hence we use dp[u][stops] as the min cost for reaching destination from u using \"stops\" stops and this will be \\n```\\ndp[u][stops] = min(dist[v][stops-1]+(cost of (u,v)); // v are the children of u node\\n```\\nthus code is like\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int> > adj[101];\\n    int dest;\\n    int ans=INT_MAX;\\n    int tot_stops;\\n    bool vis[101]={0};\\n    int dp[101][101];\\n    int dfs(int u,int stops){\\n        // for a node its optimal value can come from its child\\n        if(u==dest){\\n            return 0;\\n        }\\n        if(stops<=-1)return INT_MAX;\\n        if(dp[u][stops]!=-1)return dp[u][stops];\\n        int ret_val=INT_MAX;\\n        for(auto [v,p]: adj[u]){\\n            int val = dfs(v,stops-1);\\n\\t\\t\\t// if impossible to reach the destination from v\\n            if(val!=INT_MAX)\\n            ret_val = min(ret_val, p+val);\\n        }\\n        return dp[u][stops]=ret_val;  \\n    }\\n    \\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n            vis[i]=0;\\n            for(int j=0;j<=k;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<flights.size();i++){\\n            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});\\n        }\\n        dest=dst;\\n        tot_stops=k+1;\\n        ans = dfs(src,k);\\n        return (ans>(1e9))?-1:ans; \\n    }\\n};\\n```\\n\\nii. Dijkstra approach\\n1. Dijkstra can also work because we need to findout the shortest path from source to destination, just that we do not need to exceed the number of stops, only tricky part is , the shortest path should not exceed the number of stops, thus add a check to not put nodes if their level becomes greater than k\\n```\\nif(l>k+1)continue;\\n```\\nwhole code is\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int> > adj[101];\\n    \\n    int dijkstra(int n, int src, int dst, int k){\\n        vector<int> dist(n+1,(1e9));\\n        dist[src]=0;\\n        set<pair<pair<int,int>,int> > setds;\\n        setds.insert({{0,src},0});\\n        int ans=1e9;\\n        while(!setds.empty()){\\n            auto it=setds.begin();\\n            int d=it->first.first;\\n            int u=it->first.second;\\n            int l=it->second;\\n            setds.erase(it);\\n            if(l>k+1)continue;\\n            if(u==dst){\\n                    return d;\\n            }\\n            for(auto [v,p]:adj[u])\\n            {\\n                if(d+p<(1e9) && l<=k){\\n                    setds.insert({{d+p,v},l+1});\\n                }\\n            }\\n        }\\n        return  ans;\\n        \\n    }\\n    \\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        for(int i=0;i<flights.size();i++){\\n            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});\\n        }\\n        int ans=dijkstra(n,src,dst,k);\\n        return (ans>=(1e9))?-1:ans; \\n    }\\n}\\n```\\nthe beauty here is you will always reach at the optimal path to destination at first occurrence that is why there is a return statement in code\\n```\\nif(u==dst){\\n                    return d;\\n            }\\n```\\nThis is true because in dijkstra we always get the best path till some intermediate node and thus greedily going forward, and we already keeping check if stops exceeds the limit do not push the node in set\\n3. BFS approach there also you can keep track of level and it is similar to Dijkstra, just that answer is minimum and do not push over the stops count\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndp[u][stops] = min(dist[v][stops-1]+(cost of (u,v)); // v are the children of u node\\n```\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int> > adj[101];\\n    int dest;\\n    int ans=INT_MAX;\\n    int tot_stops;\\n    bool vis[101]={0};\\n    int dp[101][101];\\n    int dfs(int u,int stops){\\n        // for a node its optimal value can come from its child\\n        if(u==dest){\\n            return 0;\\n        }\\n        if(stops<=-1)return INT_MAX;\\n        if(dp[u][stops]!=-1)return dp[u][stops];\\n        int ret_val=INT_MAX;\\n        for(auto [v,p]: adj[u]){\\n            int val = dfs(v,stops-1);\\n\\t\\t\\t// if impossible to reach the destination from v\\n            if(val!=INT_MAX)\\n            ret_val = min(ret_val, p+val);\\n        }\\n        return dp[u][stops]=ret_val;  \\n    }\\n    \\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n            vis[i]=0;\\n            for(int j=0;j<=k;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        for(int i=0;i<flights.size();i++){\\n            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});\\n        }\\n        dest=dst;\\n        tot_stops=k+1;\\n        ans = dfs(src,k);\\n        return (ans>(1e9))?-1:ans; \\n    }\\n};\\n```\n```\\nif(l>k+1)continue;\\n```\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int> > adj[101];\\n    \\n    int dijkstra(int n, int src, int dst, int k){\\n        vector<int> dist(n+1,(1e9));\\n        dist[src]=0;\\n        set<pair<pair<int,int>,int> > setds;\\n        setds.insert({{0,src},0});\\n        int ans=1e9;\\n        while(!setds.empty()){\\n            auto it=setds.begin();\\n            int d=it->first.first;\\n            int u=it->first.second;\\n            int l=it->second;\\n            setds.erase(it);\\n            if(l>k+1)continue;\\n            if(u==dst){\\n                    return d;\\n            }\\n            for(auto [v,p]:adj[u])\\n            {\\n                if(d+p<(1e9) && l<=k){\\n                    setds.insert({{d+p,v},l+1});\\n                }\\n            }\\n        }\\n        return  ans;\\n        \\n    }\\n    \\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        for(int i=0;i<flights.size();i++){\\n            adj[flights[i][0]].push_back({flights[i][1],flights[i][2]});\\n        }\\n        int ans=dijkstra(n,src,dst,k);\\n        return (ans>=(1e9))?-1:ans; \\n    }\\n}\\n```\n```\\nif(u==dst){\\n                    return d;\\n            }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229100,
                "title": "dfs-c-dp-memoization-faster-than-80-with-explanation",
                "content": "```\\n/*\\nThis is a simple dfs approach:\\n1. Create an adjacency list for graph. Here, graph[i] stores all the edges ith vertex has in form of \\n{destination, price} pair.\\n2. Since the destination is not changing the unique state of dp depends on : source, number of stops\\nTherefore we need a 2d dp array.\\n3. We pass k + 1 stops, as everytime we encounter a city, we subtract a stop. So even if we \\nencounter destination, we would have subtracted an additional stop, so + 1.\\n4. Rest is simple dfs, if we encounter a city, we explore all the flights from that city\\nIf that city is destination, we stop our function.\\n5. Memoize the solution for better runtime.\\n\\n*/\\nclass Solution {\\npublic:\\n    int helper(int src, int dest, vector<pair<int, int>> graph[], int k, int dp[100][102]) {\\n        if(k < 0)\\n            return INT_MAX; //number of stops exceeds what is max allowed\\n        if(src == dest)\\n            return 0;\\n        if(dp[src][k] != -1)\\n            return dp[src][k];\\n        int ans = INT_MAX;\\n        for(int i = 0; i < graph[src].size(); i++) {\\n            int a = helper(graph[src][i].first, dest, graph, k - 1, dp);\\n            ans = min(ans, (a == INT_MAX) ? a : a + graph[src][i].second); //if path not possible a = int_max\\n\\t\\t\\t//else currCost = a + currEdgeWeight\\n        }\\n        return dp[src][k] = ans;\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int numFlights = flights.size();\\n        vector<pair<int, int>> graph[n];\\n        int dp[100][102];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i = 0; i < numFlights; i++) {\\n            graph[flights[i][0]].push_back({flights[i][1], flights[i][2]}); //adjacency list\\n        }\\n        int ans = helper(src, dst, graph, k + 1, dp);\\n        return (ans == INT_MAX) ? -1 : ans; //if path not possible return -1\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n/*\\nThis is a simple dfs approach:\\n1. Create an adjacency list for graph. Here, graph[i] stores all the edges ith vertex has in form of \\n{destination, price} pair.\\n2. Since the destination is not changing the unique state of dp depends on : source, number of stops\\nTherefore we need a 2d dp array.\\n3. We pass k + 1 stops, as everytime we encounter a city, we subtract a stop. So even if we \\nencounter destination, we would have subtracted an additional stop, so + 1.\\n4. Rest is simple dfs, if we encounter a city, we explore all the flights from that city\\nIf that city is destination, we stop our function.\\n5. Memoize the solution for better runtime.\\n\\n*/\\nclass Solution {\\npublic:\\n    int helper(int src, int dest, vector<pair<int, int>> graph[], int k, int dp[100][102]) {\\n        if(k < 0)\\n            return INT_MAX; //number of stops exceeds what is max allowed\\n        if(src == dest)\\n            return 0;\\n        if(dp[src][k] != -1)\\n            return dp[src][k];\\n        int ans = INT_MAX;\\n        for(int i = 0; i < graph[src].size(); i++) {\\n            int a = helper(graph[src][i].first, dest, graph, k - 1, dp);\\n            ans = min(ans, (a == INT_MAX) ? a : a + graph[src][i].second); //if path not possible a = int_max\\n\\t\\t\\t//else currCost = a + currEdgeWeight\\n        }\\n        return dp[src][k] = ans;\\n    }\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int numFlights = flights.size();\\n        vector<pair<int, int>> graph[n];\\n        int dp[100][102];\\n        memset(dp, -1, sizeof(dp));\\n        for(int i = 0; i < numFlights; i++) {\\n            graph[flights[i][0]].push_back({flights[i][1], flights[i][2]}); //adjacency list\\n        }\\n        int ans = helper(src, dst, graph, k + 1, dp);\\n        return (ans == INT_MAX) ? -1 : ans; //if path not possible return -1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140858,
                "title": "easy-c-solution-using-dijkstra",
                "content": "```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        // Make adj matrix with src->{dst, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n        for (int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][2], flights[i][1]});\\n        }\\n        \\n        // Make priority queue based on {distance, node, Steps_remaining}\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> myq;\\n        myq.push({0, src, K+1});\\n        \\n        while (!myq.empty()) {\\n            auto temp = myq.top();\\n            myq.pop();\\n            int dist  = temp[0];\\n            int node  = temp[1];\\n            int steps = temp[2];\\n            //cout << \"Node is \" << node << \" distance is \" << dist << \" steps are \" << steps << endl;\\n            \\n             if (steps < 0 ) {\\n                // Don\\'t do anything\\n                continue;\\n            }\\n            \\n            // Check if we reached the node\\n            if (node == dst) {\\n                return dist;\\n            }\\n            \\n           \\n            \\n            //Push all the neighboring nodes in the queue\\n            for (int i = 0; i < adj[node].size(); i++) {\\n                int neigh = adj[node][i].second;\\n                int dist2 = adj[node][i].first;\\n                //cout << \"node is \" << node << \" neigh is \" << neigh <<  \" dist2 is \" << dist2 << endl;\\n                myq.push({dist2+dist, neigh, steps-1});\\n            }\\n        }\\n                         \\n        return -1;\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "```\\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        // Make adj matrix with src->{dst, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n        for (int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][2], flights[i][1]});\\n        }\\n        \\n        // Make priority queue based on {distance, node, Steps_remaining}\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> myq;\\n        myq.push({0, src, K+1});\\n        \\n        while (!myq.empty()) {\\n            auto temp = myq.top();\\n            myq.pop();\\n            int dist  = temp[0];\\n            int node  = temp[1];\\n            int steps = temp[2];\\n            //cout << \"Node is \" << node << \" distance is \" << dist << \" steps are \" << steps << endl;\\n            \\n             if (steps < 0 ) {\\n                // Don\\'t do anything\\n                continue;\\n            }\\n            \\n            // Check if we reached the node\\n            if (node == dst) {\\n                return dist;\\n            }\\n            \\n           \\n            \\n            //Push all the neighboring nodes in the queue\\n            for (int i = 0; i < adj[node].size(); i++) {\\n                int neigh = adj[node][i].second;\\n                int dist2 = adj[node][i].first;\\n                //cout << \"node is \" << node << \" neigh is \" << neigh <<  \" dist2 is \" << dist2 << endl;\\n                myq.push({dist2+dist, neigh, steps-1});\\n            }\\n        }\\n                         \\n        return -1;\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 846768,
                "title": "c-commented-dijkstra-s-explained-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\\n    {\\n        // creating a weighted graph\\n        vector<vector<pair<int, int>>> graph(n);\\n        \\n        for(auto i: flights)\\n        {\\n            graph[i[0]].push_back({i[1], i[2]});\\n        }\\n        \\n        // creating a min heap or a priority queue\\n        // having distance, src and nodes left(where we can stop)\\n        // priority queu will be based upon distance, the node with least distance will\\n        // come on top\\n        priority_queue < pair<int, pair<int, int> > , vector < pair <int, pair<int, int> > > , greater<pair<int, pair<int, int> > > > pq;\\n        \\n        pq.push( {0, { src, K} });\\n           \\n        // applying Dijkstra\\'s Algorithm for shortest path from single source         \\n        while(!pq.empty())\\n        {\\n          pair<int, pair<int, int> > node = pq.top();\\n          pq.pop();\\n            \\n          // if current node is destination, return cost uptill now  \\n          if(node.second.first == dst)\\n            return node.first;\\n            \\n          // if nodes that we can visit is finished, skip this node  \\n          if(node.second.second < 0)\\n              continue;\\n           \\n          // now iterate over other nodes of the current node - distance will be\\n          // distance uptill this node + dist from this node to that neighbour node\\n          // and nodes which we can visit will be on less.\\n          for(auto i: graph[node.second.first])\\n          {\\n            pq.push({(node.first + i.second),{i.first,(node.second.second-1)}});\\n          }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K)\\n    {\\n        // creating a weighted graph\\n        vector<vector<pair<int, int>>> graph(n);\\n        \\n        for(auto i: flights)\\n        {\\n            graph[i[0]].push_back({i[1], i[2]});\\n        }\\n        \\n        // creating a min heap or a priority queue\\n        // having distance, src and nodes left(where we can stop)\\n        // priority queu will be based upon distance, the node with least distance will\\n        // come on top\\n        priority_queue < pair<int, pair<int, int> > , vector < pair <int, pair<int, int> > > , greater<pair<int, pair<int, int> > > > pq;\\n        \\n        pq.push( {0, { src, K} });\\n           \\n        // applying Dijkstra\\'s Algorithm for shortest path from single source         \\n        while(!pq.empty())\\n        {\\n          pair<int, pair<int, int> > node = pq.top();\\n          pq.pop();\\n            \\n          // if current node is destination, return cost uptill now  \\n          if(node.second.first == dst)\\n            return node.first;\\n            \\n          // if nodes that we can visit is finished, skip this node  \\n          if(node.second.second < 0)\\n              continue;\\n           \\n          // now iterate over other nodes of the current node - distance will be\\n          // distance uptill this node + dist from this node to that neighbour node\\n          // and nodes which we can visit will be on less.\\n          for(auto i: graph[node.second.first])\\n          {\\n            pq.push({(node.first + i.second),{i.first,(node.second.second-1)}});\\n          }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762644,
                "title": "variant-of-dijkstra-algorithm",
                "content": "Two changes from Dijkstra algorithm: 1. when we relax an edge (u, v) with cost/weight w, we do not overwrite v\\'s cost. Instead, we just insert another node into the priority queue, so the original node is kept at the queue (because the old one might have shorter distance even though it has higher cost). 2. we do not relax an edge if it is beyond our limit for K stops.\\n```\\nclass Solution {\\n    using PII = pair<int, int>; // neighbor idx, path cost\\n    using TIII = tuple<int, int, int>;  // cost, idx, distance\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<PII>> graph(n, vector<PII>());\\n        for (auto& flight : flights) {\\n            graph[flight[0]].emplace_back(flight[1], flight[2]);\\n        }\\n\\n        priority_queue<TIII, vector<TIII>, greater<>> pq;\\n        pq.emplace(0, src, 0);\\n\\n        while (!pq.empty()) {\\n            auto [cost, idx, distance] = pq.top();\\n            if (idx == dst) return cost;\\n            pq.pop();\\n            for (auto [neighborIdx, pathCost] : graph[idx]) {\\n                if (distance <= K) {\\n                    pq.emplace(cost + pathCost, neighborIdx, distance + 1);\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    using PII = pair<int, int>; // neighbor idx, path cost\\n    using TIII = tuple<int, int, int>;  // cost, idx, distance\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<PII>> graph(n, vector<PII>());\\n        for (auto& flight : flights) {\\n            graph[flight[0]].emplace_back(flight[1], flight[2]);\\n        }\\n\\n        priority_queue<TIII, vector<TIII>, greater<>> pq;\\n        pq.emplace(0, src, 0);\\n\\n        while (!pq.empty()) {\\n            auto [cost, idx, distance] = pq.top();\\n            if (idx == dst) return cost;\\n            pq.pop();\\n            for (auto [neighborIdx, pathCost] : graph[idx]) {\\n                if (distance <= K) {\\n                    pq.emplace(cost + pathCost, neighborIdx, distance + 1);\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687119,
                "title": "c-bellman-ford-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<int>distance(n,1e8);\\n        distance[src] = 0;\\n        \\n        for (int i = 0; i<=K;i++)\\n            \\n        {    vector<int>temp(distance);\\n            for (auto e : flights)\\n            {\\n                \\n               \\n                int a,b,w;\\n                a = e[0];\\n                b = e[1];\\n                w = e[2];\\n                temp[b] = min(temp[b],distance[a]+w);\\n                \\n                \\n                \\n                \\n            }\\n            \\n            distance = temp;\\n            \\n            \\n        }\\n        \\n        if (distance[dst] == 1e8)\\n            return -1;\\n        return distance[dst];\\n    }\\n};\\n\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<int>distance(n,1e8);\\n        distance[src] = 0;\\n        \\n        for (int i = 0; i<=K;i++)\\n            \\n        {    vector<int>temp(distance);\\n            for (auto e : flights)\\n            {\\n                \\n               \\n                int a,b,w;\\n                a = e[0];\\n                b = e[1];\\n                w = e[2];\\n                temp[b] = min(temp[b],distance[a]+w);\\n                \\n                \\n                \\n                \\n            }\\n            \\n            distance = temp;\\n            \\n            \\n        }\\n        \\n        if (distance[dst] == 1e8)\\n            return -1;\\n        return distance[dst];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 605725,
                "title": "fast-java-bellman-ford-based-solution-with-explanation",
                "content": "Bellmand Ford Algorithm: https://www.javatpoint.com/bellman-ford-algorithm\\n\\nFor K stops, we have K + 1 edges, thus we relax K + 1 times using Bellmand Ford Algorithm. Note here we have ``int[] tmpDist = Arrays.copyOf(dist, dist.length);`` together with ``if (dist[u] == Integer.MAX_VALUE) continue;``, because we want to take 1 step at a time by only visiting new nodes that are reachable from previous iteration.\\n\\n```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[src] = 0;\\n        for (int i = 0; i <= K; i++) {\\n            int[] tmpDist = Arrays.copyOf(dist, dist.length);\\n            for (int[] edge : flights) {\\n                int u = edge[0];\\n                if (dist[u] == Integer.MAX_VALUE) continue;\\n                int v = edge[1];\\n                int w = edge[2];\\n                tmpDist[v] = Math.min(tmpDist[v], dist[u] + w);\\n            }\\n            dist = tmpDist;\\n        }\\n        return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, Integer.MAX_VALUE);\\n        dist[src] = 0;\\n        for (int i = 0; i <= K; i++) {\\n            int[] tmpDist = Arrays.copyOf(dist, dist.length);\\n            for (int[] edge : flights) {\\n                int u = edge[0];\\n                if (dist[u] == Integer.MAX_VALUE) continue;\\n                int v = edge[1];\\n                int w = edge[2];\\n                tmpDist[v] = Math.min(tmpDist[v], dist[u] + w);\\n            }\\n            dist = tmpDist;\\n        }\\n        return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518000,
                "title": "java-simplified-dijkstra-based-approach-with-video-explanation",
                "content": "This snippet is actually from happygirlzt\\'s youtube channel.\\nIt\\'s very clean code and she has a great explanation of the problem in her video at: https://www.youtube.com/watch?v=H8EeY58LLz0\\n\\nReposting it here, as I found it useful and I\\'m surprised that she doesn\\'t have more followers.\\n\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[][] matrix = new int[n][n];\\n        for (int[] flight: flights) {\\n            matrix[flight[0]][flight[1]] = flight[2];\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n        pq.offer(new int[]{0, src, K + 1});\\n        \\n        \\n        while(!pq.isEmpty()) {\\n            int[] item = pq.poll();\\n            int price = item[0];\\n            int place = item[1];\\n            int kLeft = item[2];\\n            \\n            if (place == dst) {\\n                return price;\\n            }\\n            \\n            if (kLeft > 0) {\\n                for (int i = 0; i < n; i++) {\\n                    if (matrix[place][i] > 0) {\\n                        pq.offer(new int[]{price + matrix[place][i], i, kLeft - 1});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int[][] matrix = new int[n][n];\\n        for (int[] flight: flights) {\\n            matrix[flight[0]][flight[1]] = flight[2];\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\\n        pq.offer(new int[]{0, src, K + 1});\\n        \\n        \\n        while(!pq.isEmpty()) {\\n            int[] item = pq.poll();\\n            int price = item[0];\\n            int place = item[1];\\n            int kLeft = item[2];\\n            \\n            if (place == dst) {\\n                return price;\\n            }\\n            \\n            if (kLeft > 0) {\\n                for (int i = 0; i < n; i++) {\\n                    if (matrix[place][i] > 0) {\\n                        pq.offer(new int[]{price + matrix[place][i], i, kLeft - 1});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486697,
                "title": "c-faster-than-100-00-of-c-online-submissions-with-explanation",
                "content": "```\\n// Runtime: 4 ms, faster than 100.00% of C++ online submissions for Cheapest Flights Within K Stops.\\nclass Solution {\\npublic:\\n    /*\\n        Approach:\\n        1. Even though the problem appears to be like a good candidate for applying Dijkstra\\'s algo,\\n           it can be solved using just BFS. ( Ofcourse Dijkstra is a variant of BFS ).\\n        2. Construct the graph from the given flights.\\n        3. Perform a BFS from src to dst with the following constraint to reduce spurious computations:\\n           a. The # of hops to reach any city should not be > K + 1( we can have K stops, ( K + 1 )th is dst ) \\n           b. The new distance to current node\\'s neighbor should not be > minDist of neighbor.\\n        4. The above conditions( 3a and 3b ) reduce the boundary of the search drastically.\\n        \\n        In other words, the problem is really to find the minimum cost path of length at most ( K + 1 ) of all the paths from src -> dst.\\n        \\n        Note: The problem could be solved using DFS as well using constraints described in 3a and 3b above.\\n    \\n    */\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector< vector< pair< long, long > > > graph( n, vector< pair< long, long > >() );\\n        queue< tuple< long, long, long > > q; // dist, hops, city\\n\\n        for( auto &i : flights ) {\\n            int from, to, dist, hops;\\n            from = i[ 0 ], to = i[ 1 ], dist = i[ 2 ];\\n            \\n            graph[ from ].emplace_back( to, dist );\\n            if( from == src ) {\\n                dist = hops = 0;\\n            } else {\\n                dist = hops = INT_MAX;\\n            }\\n        }\\n\\n        q.emplace( 0, 0, src );\\n        vector< long > minDist( n, INT_MAX ); // maintain minDist of each node.\\n        minDist[ src ] = 0;\\n        while( not q.empty() ) {\\n            long currCity, currDist, currHops;\\n            tie( currDist, currHops, currCity ) = q.front(), q.pop();\\n            // cout << \"Curr: \" << currCity\\n            //      << \", currDist: \" << currDist\\n            //      << \", currHops: \" << currHops << endl;\\n            if( minDist[ currCity ] > currDist ) continue;\\n            for( auto &n : graph[ currCity ] ) {\\n                // cout << \"    : \" << n.first << \", dist: \" << n.second << endl;\\n                if( currDist + n.second > minDist[ n.first ] or currHops + 1 > K + 1 ) continue;\\n                q.emplace( currDist + n.second, currHops + 1, n.first );\\n                minDist[ n.first ] = min( minDist[ n.first ], currDist + n.second );\\n             }\\n        }\\n        \\n        return ( minDist[ dst ] == INT_MAX ) ? -1 : minDist[ dst ];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 100.00% of C++ online submissions for Cheapest Flights Within K Stops.\\nclass Solution {\\npublic:\\n    /*\\n        Approach:\\n        1. Even though the problem appears to be like a good candidate for applying Dijkstra\\'s algo,\\n           it can be solved using just BFS. ( Ofcourse Dijkstra is a variant of BFS ).\\n        2. Construct the graph from the given flights.\\n        3. Perform a BFS from src to dst with the following constraint to reduce spurious computations:\\n           a. The # of hops to reach any city should not be > K + 1( we can have K stops, ( K + 1 )th is dst ) \\n           b. The new distance to current node\\'s neighbor should not be > minDist of neighbor.\\n        4. The above conditions( 3a and 3b ) reduce the boundary of the search drastically.\\n        \\n        In other words, the problem is really to find the minimum cost path of length at most ( K + 1 ) of all the paths from src -> dst.\\n        \\n        Note: The problem could be solved using DFS as well using constraints described in 3a and 3b above.\\n    \\n    */\\n    \\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector< vector< pair< long, long > > > graph( n, vector< pair< long, long > >() );\\n        queue< tuple< long, long, long > > q; // dist, hops, city\\n\\n        for( auto &i : flights ) {\\n            int from, to, dist, hops;\\n            from = i[ 0 ], to = i[ 1 ], dist = i[ 2 ];\\n            \\n            graph[ from ].emplace_back( to, dist );\\n            if( from == src ) {\\n                dist = hops = 0;\\n            } else {\\n                dist = hops = INT_MAX;\\n            }\\n        }\\n\\n        q.emplace( 0, 0, src );\\n        vector< long > minDist( n, INT_MAX ); // maintain minDist of each node.\\n        minDist[ src ] = 0;\\n        while( not q.empty() ) {\\n            long currCity, currDist, currHops;\\n            tie( currDist, currHops, currCity ) = q.front(), q.pop();\\n            // cout << \"Curr: \" << currCity\\n            //      << \", currDist: \" << currDist\\n            //      << \", currHops: \" << currHops << endl;\\n            if( minDist[ currCity ] > currDist ) continue;\\n            for( auto &n : graph[ currCity ] ) {\\n                // cout << \"    : \" << n.first << \", dist: \" << n.second << endl;\\n                if( currDist + n.second > minDist[ n.first ] or currHops + 1 > K + 1 ) continue;\\n                q.emplace( currDist + n.second, currHops + 1, n.first );\\n                minDist[ n.first ] = min( minDist[ n.first ], currDist + n.second );\\n             }\\n        }\\n        \\n        return ( minDist[ dst ] == INT_MAX ) ? -1 : minDist[ dst ];\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 481874,
                "title": "javascript-solution-dijkstra-algorithm",
                "content": "### The idea\\n1. Use Dijkstra algorithm (please understand it if you are not familiar)\\n2. The code is slow, due to 2 reasons:\\n\\t1. the usage of `Object` instead of `Map`, because I think `Object` looks cleaner\\n\\t2. the lack of implementation of proper `priority queue`\\n``` javascript\\nvar findCheapestPrice1 = function(n, flights, src, dst, K) {\\n\\t /**\\n     * {\\n     *  \\'FROM\\': {\\n     *          \"DST 1\" : 100,\\n     *          \"DST 2\" : 200\\n     *          }\\n     * }\\n     */\\n    let flightHash = {};\\n    for (let flight of flights) {\\n        let [from, to, price] = flight;\\n        if (flightHash[from] == null) flightHash[from] = {};\\n        flightHash[from][to] = price;\\n    }\\n\\n    // initialize\\n    // Saves the minimun price to a destination at certain stops\\n    // Use the array index to indicate stops\\n    let minPrice = {src:[0]};\\n \\n    // [price, stop, location]\\n    // price: the price to a location\\n    let pq = [[0, 0, src]];\\n\\n    while (pq.length != 0) {\\n        let [price, stop, from] = pq.shift();\\n        if (stop > K + 1 || (minPrice[from] && price > minPrice[from][stop])) continue;\\n        if (from == dst) return price;\\n        let to = flightHash[from];\\n        for (let t in to) {\\n            if (minPrice[t]==null) minPrice[t] = [];\\n            let costToNext = price + to[t];\\n            if (costToNext > minPrice[t][stop+1]) continue;\\n            minPrice[t][stop+1] = costToNext;\\n            pq.push([costToNext, stop + 1, t]);\\n        }\\n        pq.sort((a,b)=>a[0]-b[0]);\\n    }\\n\\n    return -1;\\n};\\n```\\nFor this particular question, unlike other typical dijkstra problems, the algorithm does\\'t really need to compare new cost with previous saved cost. I think the reason is:\\n1. `If (stop > K + 1) continue;` this constraint ensures that we won\\'t get a result thats very cheap but exceed stop constraints\\n 2. Because the way PQ works, we will always get the cheapest entry, thus even if we push noisy, more expensive entries into the PQ, they certainly won\\'t have the chance to be looked at \\n ```\\n var findCheapestPrice = function(n, flights, src, dst, K) {\\n    let flightHash = {};\\n    for (let flight of flights) {\\n        let [from, to, price] = flight;\\n        if (flightHash[from] == null) flightHash[from] = {};\\n        flightHash[from][to] = price;\\n    }\\n \\n    let pq = [[0, 0, src]];\\n\\n    while (pq.length != 0) {\\n        let [price, stop, from] = pq.shift();\\n        if (stop > K + 1) continue;\\n        if (from == dst) return price;\\n        let to = flightHash[from];\\n        for (let t in to) {\\n            let costToNext = price + to[t];\\n            pq.push([costToNext, stop + 1, t]);\\n        }\\n        pq.sort((a,b)=>a[0]-b[0]);\\n    }\\n\\n    return -1;\\n};\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar findCheapestPrice1 = function(n, flights, src, dst, K) {\\n\\t /**\\n     * {\\n     *  \\'FROM\\': {\\n     *          \"DST 1\" : 100,\\n     *          \"DST 2\" : 200\\n     *          }\\n     * }\\n     */\\n    let flightHash = {};\\n    for (let flight of flights) {\\n        let [from, to, price] = flight;\\n        if (flightHash[from] == null) flightHash[from] = {};\\n        flightHash[from][to] = price;\\n    }\\n\\n    // initialize\\n    // Saves the minimun price to a destination at certain stops\\n    // Use the array index to indicate stops\\n    let minPrice = {src:[0]};\\n \\n    // [price, stop, location]\\n    // price: the price to a location\\n    let pq = [[0, 0, src]];\\n\\n    while (pq.length != 0) {\\n        let [price, stop, from] = pq.shift();\\n        if (stop > K + 1 || (minPrice[from] && price > minPrice[from][stop])) continue;\\n        if (from == dst) return price;\\n        let to = flightHash[from];\\n        for (let t in to) {\\n            if (minPrice[t]==null) minPrice[t] = [];\\n            let costToNext = price + to[t];\\n            if (costToNext > minPrice[t][stop+1]) continue;\\n            minPrice[t][stop+1] = costToNext;\\n            pq.push([costToNext, stop + 1, t]);\\n        }\\n        pq.sort((a,b)=>a[0]-b[0]);\\n    }\\n\\n    return -1;\\n};\\n```\n```\\n var findCheapestPrice = function(n, flights, src, dst, K) {\\n    let flightHash = {};\\n    for (let flight of flights) {\\n        let [from, to, price] = flight;\\n        if (flightHash[from] == null) flightHash[from] = {};\\n        flightHash[from][to] = price;\\n    }\\n \\n    let pq = [[0, 0, src]];\\n\\n    while (pq.length != 0) {\\n        let [price, stop, from] = pq.shift();\\n        if (stop > K + 1) continue;\\n        if (from == dst) return price;\\n        let to = flightHash[from];\\n        for (let t in to) {\\n            let costToNext = price + to[t];\\n            pq.push([costToNext, stop + 1, t]);\\n        }\\n        pq.sort((a,b)=>a[0]-b[0]);\\n    }\\n\\n    return -1;\\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 359391,
                "title": "c-straightforward-queue-map-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int, vector<pair<int, int>>> mm;\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n\\n        // city to cost\\n        queue<pair<int, int>> qu;\\n\\n        for(auto it : flights) {\\n            mm[it[0]].push_back({it[1], it[2]});\\n        }\\n\\n        qu.push({src, 0});\\n\\n        int count = 0;\\n        int res = INT_MAX;\\n        while(!qu.empty()) {\\n            if(count++ > K+1) break;\\n            int size = qu.size();\\n            for(int i = 0; i < size; i++) {\\n                pair<int, int> temp = qu.front();\\n                qu.pop();\\n                int city = temp.first;\\n                int cost = temp.second;\\n\\n                if(city == dst) {\\n                    res = min(res, cost);\\n                    continue;\\n                }\\n\\n                for(auto it : mm[city]) {\\n                    it.second += cost;\\n                    if(dist[it.first] < it.second) continue;\\n                    dist[it.first] = it.second;\\n                    qu.push({it.first, it.second});\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        unordered_map<int, vector<pair<int, int>>> mm;\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n\\n        // city to cost\\n        queue<pair<int, int>> qu;\\n\\n        for(auto it : flights) {\\n            mm[it[0]].push_back({it[1], it[2]});\\n        }\\n\\n        qu.push({src, 0});\\n\\n        int count = 0;\\n        int res = INT_MAX;\\n        while(!qu.empty()) {\\n            if(count++ > K+1) break;\\n            int size = qu.size();\\n            for(int i = 0; i < size; i++) {\\n                pair<int, int> temp = qu.front();\\n                qu.pop();\\n                int city = temp.first;\\n                int cost = temp.second;\\n\\n                if(city == dst) {\\n                    res = min(res, cost);\\n                    continue;\\n                }\\n\\n                for(auto it : mm[city]) {\\n                    it.second += cost;\\n                    if(dist[it.first] < it.second) continue;\\n                    dist[it.first] = it.second;\\n                    qu.push({it.first, it.second});\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280711,
                "title": "golang-bfs-dfs-dijkstra",
                "content": "Distinguised with original graph traversal, here we shouldn\\'t avoid travelling on the visited node. Because the shortest path may not satisfy the stops restriction, but the longer path may do. \\n#### BFS, level-order traversal.\\n```\\nimport \"container/list\"\\n\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    ret := MAX_INT\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n    level := 0\\n    for queue.Len() != 0 && level <= K + 1 {\\n        size := queue.Len()\\n        for i := 0; i < size; i++ {\\n            e := queue.Front()\\n            queue.Remove(e)\\n            curr := e.Value.([]int)\\n            if curr[0] == dst && ret > curr[1]{ ret = curr[1] }\\n            for _, edge := range graph[curr[0]] {\\n                if tempCost := curr[1] + edge[1]; tempCost < ret {\\n                    queue.PushBack([]int{edge[0], tempCost})\\n                }\\n            } \\n        }\\n        level++\\n    }\\n    if ret == MAX_INT { return -1 } else { return ret }\\n}\\n```\\n\\n#### DFS\\n``` golang\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    ret := MAX_INT\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    DFS(src, 0, 0, graph, dst, K, &ret)\\n    if ret == MAX_INT { return -1 } else { return ret }\\n}\\n\\n\\nfunc DFS(root, dist, depth int, graph [][][]int, dst, K int, min *int) {\\n    if depth > K + 1 { return }\\n    if root == dst && dist < *min { *min = dist }\\n    for _, edge := range graph[root] {\\n        if temp := dist + edge[1]; temp < *min {\\n            DFS(edge[0], temp, depth+1, graph, dst, K, min)\\n        }\\n    }\\n}\\n```\\n\\n#### Variant of Dijkstra using min-heap\\n```\\nimport \"container/heap\"\\n\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    h := &NodeHeap{}\\n    heap.Init(h)\\n    heap.Push(h, &Node{src, 0, 0})\\n    for h.Len() != 0 {\\n        currNode := heap.Pop(h).(*Node)\\n        currId := currNode.id\\n        if currId == dst { return currNode.dist }\\n        // 2. update the neighbors and heap.\\n        if currNode.stops <= K { // !!!\\n            for _, edge := range graph[currId] {\\n                heap.Push(h, &Node{edge[0], currNode.dist + edge[1], currNode.stops + 1})\\n\\t        }\\n        }\\n    }\\n    return -1\\n}\\n\\ntype Node struct { id, dist, stops int }\\ntype NodeHeap []*Node\\n\\nfunc (h NodeHeap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\nfunc (h NodeHeap) Less(i, j int) bool { return h[i].dist < h[j].dist }\\nfunc (h NodeHeap) Len() int { return len(h) }\\nfunc (h *NodeHeap) Push(v interface{}) { *h = append(*h, v.(*Node)) }\\nfunc (h *NodeHeap) Pop() interface{} {\\n    ret := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n    return ret\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport \"container/list\"\\n\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    ret := MAX_INT\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n    level := 0\\n    for queue.Len() != 0 && level <= K + 1 {\\n        size := queue.Len()\\n        for i := 0; i < size; i++ {\\n            e := queue.Front()\\n            queue.Remove(e)\\n            curr := e.Value.([]int)\\n            if curr[0] == dst && ret > curr[1]{ ret = curr[1] }\\n            for _, edge := range graph[curr[0]] {\\n                if tempCost := curr[1] + edge[1]; tempCost < ret {\\n                    queue.PushBack([]int{edge[0], tempCost})\\n                }\\n            } \\n        }\\n        level++\\n    }\\n    if ret == MAX_INT { return -1 } else { return ret }\\n}\\n```\n``` golang\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    ret := MAX_INT\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    DFS(src, 0, 0, graph, dst, K, &ret)\\n    if ret == MAX_INT { return -1 } else { return ret }\\n}\\n\\n\\nfunc DFS(root, dist, depth int, graph [][][]int, dst, K int, min *int) {\\n    if depth > K + 1 { return }\\n    if root == dst && dist < *min { *min = dist }\\n    for _, edge := range graph[root] {\\n        if temp := dist + edge[1]; temp < *min {\\n            DFS(edge[0], temp, depth+1, graph, dst, K, min)\\n        }\\n    }\\n}\\n```\n```\\nimport \"container/heap\"\\n\\nconst MAX_INT = int(^uint(0) >> 1)\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, K int) int {\\n    graph := make([][][]int, n)\\n    for _, flight := range flights {\\n        graph[flight[0]] = append(graph[flight[0]], flight[1:])\\n    }\\n    h := &NodeHeap{}\\n    heap.Init(h)\\n    heap.Push(h, &Node{src, 0, 0})\\n    for h.Len() != 0 {\\n        currNode := heap.Pop(h).(*Node)\\n        currId := currNode.id\\n        if currId == dst { return currNode.dist }\\n        // 2. update the neighbors and heap.\\n        if currNode.stops <= K { // !!!\\n            for _, edge := range graph[currId] {\\n                heap.Push(h, &Node{edge[0], currNode.dist + edge[1], currNode.stops + 1})\\n\\t        }\\n        }\\n    }\\n    return -1\\n}\\n\\ntype Node struct { id, dist, stops int }\\ntype NodeHeap []*Node\\n\\nfunc (h NodeHeap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\nfunc (h NodeHeap) Less(i, j int) bool { return h[i].dist < h[j].dist }\\nfunc (h NodeHeap) Len() int { return len(h) }\\nfunc (h *NodeHeap) Push(v interface{}) { *h = append(*h, v.(*Node)) }\\nfunc (h *NodeHeap) Pop() interface{} {\\n    ret := (*h)[len(*h)-1]\\n    *h = (*h)[:len(*h)-1]\\n    return ret\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 238116,
                "title": "python-simple-dijkstra",
                "content": "```py\\ndef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\"\"\"\\n\\t:type n: int\\n\\t:type flights: List[List[int]]\\n\\t:type src: int\\n\\t:type dst: int\\n\\t:type K: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\t# construct graph\\n\\tgraph = defaultdict(list)\\n\\tfor u, v, w in flights:\\n\\t\\tgraph[u].append((v, w))\\n\\n\\t# dist, idx, path_len\\n\\tq = [(0, src, 1)]\\n\\tmax_path_len = K + 2\\n\\twhile q:\\n\\t\\tdist, idx, path_len = heappop(q)\\n\\t\\tif path_len > max_path_len:\\n\\t\\t\\tcontinue\\n\\t\\tif idx == dst:\\n\\t\\t\\treturn dist\\n\\t\\tfor v, w in graph[idx]:\\n\\t\\t\\theappush(q, (dist+w, v, path_len+1))\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\ndef findCheapestPrice(self, n, flights, src, dst, K):\\n\\t\"\"\"\\n\\t:type n: int\\n\\t:type flights: List[List[int]]\\n\\t:type src: int\\n\\t:type dst: int\\n\\t:type K: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\t# construct graph\\n\\tgraph = defaultdict(list)\\n\\tfor u, v, w in flights:\\n\\t\\tgraph[u].append((v, w))\\n\\n\\t# dist, idx, path_len\\n\\tq = [(0, src, 1)]\\n\\tmax_path_len = K + 2\\n\\twhile q:\\n\\t\\tdist, idx, path_len = heappop(q)\\n\\t\\tif path_len > max_path_len:\\n\\t\\t\\tcontinue\\n\\t\\tif idx == dst:\\n\\t\\t\\treturn dist\\n\\t\\tfor v, w in graph[idx]:\\n\\t\\t\\theappush(q, (dist+w, v, path_len+1))\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180314,
                "title": "dijkstra-with-modification",
                "content": "* What is Dijkstra Algorithm and where to apply\\nDijkstra Algorithm aims to solve problem in a directed/undirected & weighted (weights are bigger than 0) graph, from source to all nodes with optimal path and cost.\\n\\n* How does it work\\n1. creates a min heap with initial node (source node) with cost of 0\\n2. expand the next node in heap with smallest value, if this is a terminate node, then return value\\n3. add current node to closed, add all unclosed neighbor of this node to heap and repeat second step\\n\\nIn this problem a pure Dijkstra Algorithm (see this https://leetcode.com/problems/network-delay-time/description/ ) won\\'t apply, because we are not necessarily finding the optimal solution, but should limit with K stops. Thus instead of adding explored nodes to closed set, we check if current count is over K.\\n\\n```\\nclass Solution {\\n    \\n    /**\\n    Dijkstra shortest weighted distance\\n    */\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int[] flight : flights) {\\n            int from = flight[0];\\n            int to = flight[1];\\n            int price = flight[2];\\n            map.putIfAbsent(from, new HashMap<>());\\n            map.get(from).put(to, price);\\n        }\\n        // place, cost\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) ->  a[1] - b[1] );\\n        pq.offer(new int[]{ src, 0, 0 });\\n        while (!pq.isEmpty()) {\\n            int[] current = pq.poll();\\n            int city = current[0];\\n            int cost = current[1];\\n            int count = current[2];\\n            if (count > K + 1) continue;\\n            if (city == dst) {\\n                return cost;\\n            }\\n            if (map.containsKey(city)) {\\n                Map<Integer, Integer> nexts = map.get(city);\\n                for (int nextCity : nexts.keySet()) {\\n                    pq.offer(new int[]{ nextCity, cost + nexts.get(nextCity), count + 1 });\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    /**\\n    Dijkstra shortest weighted distance\\n    */\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        Map<Integer, Map<Integer, Integer>> map = new HashMap<>();\\n        for (int[] flight : flights) {\\n            int from = flight[0];\\n            int to = flight[1];\\n            int price = flight[2];\\n            map.putIfAbsent(from, new HashMap<>());\\n            map.get(from).put(to, price);\\n        }\\n        // place, cost\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) ->  a[1] - b[1] );\\n        pq.offer(new int[]{ src, 0, 0 });\\n        while (!pq.isEmpty()) {\\n            int[] current = pq.poll();\\n            int city = current[0];\\n            int cost = current[1];\\n            int count = current[2];\\n            if (count > K + 1) continue;\\n            if (city == dst) {\\n                return cost;\\n            }\\n            if (map.containsKey(city)) {\\n                Map<Integer, Integer> nexts = map.get(city);\\n                for (int nextCity : nexts.keySet()) {\\n                    pq.offer(new int[]{ nextCity, cost + nexts.get(nextCity), count + 1 });\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869043,
                "title": "easy-c-solution-dijkstra-with-time-complexity-e-log-v",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe could use dijkstra here but the only problem seems to be appear is extra constraint of atmost k stops.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s suppose we are at a node before the destination node.So, can now be reach to the destination node from all the nodes just before destination node if we are able to reach atleast one of the these nodes. The answer is YES, because it\\'s take only 1 stops from all such nodes. Can\\'t we think opposite that we will go from the destination node to the neighbour node which is at least distance. If any of these node is able to reach to the source first. Then, that will be our answer. **So We will traverse the graph from destination to source not from the source to destination while applying dijkstra**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((number of edges)*log(number of nodes))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(number of nodes+ number of edges)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int, int>> adj[n];\\n        k=k+1;\\n        for(auto x: flights)\\n        {\\n            adj[x[1]].push_back({x[0], x[2]});\\n        }\\n        //{cost, {node, stops}}\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pendingNodes;\\n        vector<int> minCost(n, INT_MAX);\\n        pendingNodes.push({0, {dst, 0}});\\n        minCost[dst]=0;\\n        while(!pendingNodes.empty())\\n        {\\n            int cost=pendingNodes.top().first;\\n            int node=pendingNodes.top().second.first;\\n            int stops=pendingNodes.top().second.second;\\n            if(node==src)\\n            return cost;\\n            pendingNodes.pop();\\n            for(auto x: adj[node])\\n            {\\nif((cost+x.second)<minCost[x.first] && (stops+1)<=k)\\n{\\nminCost[x.first]=cost+x.second;\\npendingNodes.push({minCost[x.first], {x.first, stops+1}});\\n}\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int, int>> adj[n];\\n        k=k+1;\\n        for(auto x: flights)\\n        {\\n            adj[x[1]].push_back({x[0], x[2]});\\n        }\\n        //{cost, {node, stops}}\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pendingNodes;\\n        vector<int> minCost(n, INT_MAX);\\n        pendingNodes.push({0, {dst, 0}});\\n        minCost[dst]=0;\\n        while(!pendingNodes.empty())\\n        {\\n            int cost=pendingNodes.top().first;\\n            int node=pendingNodes.top().second.first;\\n            int stops=pendingNodes.top().second.second;\\n            if(node==src)\\n            return cost;\\n            pendingNodes.pop();\\n            for(auto x: adj[node])\\n            {\\nif((cost+x.second)<minCost[x.first] && (stops+1)<=k)\\n{\\nminCost[x.first]=cost+x.second;\\npendingNodes.push({minCost[x.first], {x.first, stops+1}});\\n}\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776481,
                "title": "c-simple-and-concise-easy-to-understand",
                "content": "# Approach\\n- We solve this problem using djikstra\\'s algo\\n- After implementing djikstra\\'s algo we check cost for each possible and return the minimum of all\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> dis(n, vector<int>(k + 2, 1e9));\\n        vector<vector<pair<int, int>>> adjList(n);\\n        for (const auto& flight : flights) {\\n            adjList[flight[0]].push_back({flight[1], flight[2]});\\n        }\\n\\n        dis[src][0] = 0;\\n        set<vector<int>> s;\\n        s.insert({0, src, 0});\\n\\n        while (!s.empty()) {\\n            vector<int> v = *(s.begin());\\n            s.erase(s.begin());\\n            int cost = v[0], sr = v[1], stops = v[2];\\n\\n            if (sr == dst) {\\n                return cost;\\n            }\\n\\n            if (stops <= k) {\\n                for (const auto& neighbor : adjList[sr]) {\\n                    int node = neighbor.first, c = neighbor.second;\\n                    if (dis[node][stops + 1] > cost + c) {\\n                        dis[node][stops + 1] = cost + c;\\n                        s.insert({dis[node][stops + 1], node, stops + 1});\\n                    }\\n                }\\n            }\\n        }\\n\\n        int result = 1e9;\\n        for(int i = 0; i <= k + 1; i++) {\\n            result = min(result, dis[dst][i]);\\n        }\\n        \\n        return result == 1e9 ? -1 : result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> dis(n, vector<int>(k + 2, 1e9));\\n        vector<vector<pair<int, int>>> adjList(n);\\n        for (const auto& flight : flights) {\\n            adjList[flight[0]].push_back({flight[1], flight[2]});\\n        }\\n\\n        dis[src][0] = 0;\\n        set<vector<int>> s;\\n        s.insert({0, src, 0});\\n\\n        while (!s.empty()) {\\n            vector<int> v = *(s.begin());\\n            s.erase(s.begin());\\n            int cost = v[0], sr = v[1], stops = v[2];\\n\\n            if (sr == dst) {\\n                return cost;\\n            }\\n\\n            if (stops <= k) {\\n                for (const auto& neighbor : adjList[sr]) {\\n                    int node = neighbor.first, c = neighbor.second;\\n                    if (dis[node][stops + 1] > cost + c) {\\n                        dis[node][stops + 1] = cost + c;\\n                        s.insert({dis[node][stops + 1], node, stops + 1});\\n                    }\\n                }\\n            }\\n        }\\n\\n        int result = 1e9;\\n        for(int i = 0; i <= k + 1; i++) {\\n            result = min(result, dis[dst][i]);\\n        }\\n        \\n        return result == 1e9 ? -1 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311492,
                "title": "best-o-e-solution",
                "content": "# Approach\\nDijkstra\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(E)$$\\n\\n- Space complexity:\\n$$O(V + E)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector <pair<int, int>> adj[n];\\n        for (auto it: flights) \\n            adj[it[0]].push_back({it[1], it[2]});\\n        queue <pair<int , pair<int, int>>> q;\\n        q.push({0, {0, src}});\\n        vector <int> cost(n, 1e9);\\n        cost[src] = 0;\\n        while (!q.empty()) {\\n            int stops = q.front().first;\\n            int ct = q.front().second.first;\\n            int node = q.front().second.second;\\n            q.pop();    \\n            if (stops > k)\\n                continue;\\n            for (auto it: adj[node]) {\\n                int adjNode = it.first;\\n                int wt = it.second;\\n                if (ct + wt < cost[adjNode]) {\\n                    cost[adjNode] = ct + wt;\\n                    q.push({stops+1, {ct + wt, adjNode}});\\n                }\\n            }\\n        }\\n        if (cost[dst] == 1e9)\\n            return -1;\\n        return cost[dst];    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector <pair<int, int>> adj[n];\\n        for (auto it: flights) \\n            adj[it[0]].push_back({it[1], it[2]});\\n        queue <pair<int , pair<int, int>>> q;\\n        q.push({0, {0, src}});\\n        vector <int> cost(n, 1e9);\\n        cost[src] = 0;\\n        while (!q.empty()) {\\n            int stops = q.front().first;\\n            int ct = q.front().second.first;\\n            int node = q.front().second.second;\\n            q.pop();    \\n            if (stops > k)\\n                continue;\\n            for (auto it: adj[node]) {\\n                int adjNode = it.first;\\n                int wt = it.second;\\n                if (ct + wt < cost[adjNode]) {\\n                    cost[adjNode] = ct + wt;\\n                    q.push({stops+1, {ct + wt, adjNode}});\\n                }\\n            }\\n        }\\n        if (cost[dst] == 1e9)\\n            return -1;\\n        return cost[dst];    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104523,
                "title": "java-dijkstra-commented",
                "content": "# Please Upvote \\uD83D\\uDE07\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        // map of <node (from) -> <node (to), cost of from - to>>\\n        Map<Integer, List<int[]>> adj = new HashMap<>();\\n        for (int[] f : flights) {\\n            adj.putIfAbsent(f[0], new ArrayList<>());\\n            adj.get(f[0]).add(new int[] {f[1], f[2]});\\n        }\\n\\n        // array to record minimum steps to reach a particular node\\n        int[] stops = new int[n];\\n        Arrays.fill(stops, Integer.MAX_VALUE);  // initialise with int_max\\n\\n        // min heap which will always give us least cost journey\\n        // {node, cost_from_src_node, number_of_stops_from_src_node}\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {src, 0, 0});    // starts with node 0, cost 0 and 0 steps\\n\\n        while (!pq.isEmpty()) {\\n            int[] currDetails = pq.poll();\\n            int currNode = currDetails[0];\\n            int costSoFar = currDetails[1];\\n            int stepsSoFar = currDetails[2];\\n\\n            // till the current node, if we have already encountered a path wi lesser stops\\n            // or if the number of stops exceeds the limit, we will skip\\n            if (stepsSoFar > stops[currNode] || stepsSoFar > k + 1) {\\n                continue;\\n            }\\n            // otherwise, it means that we have reached the current node with lesser number of stops\\n            // so we put the that new number of stops so far at index \\'currNode\\'\\n            stops[currNode] = stepsSoFar;\\n            if (currNode == dst) {  // if current node is our destination\\n                return costSoFar;   // return the cost incurred so far\\n            }\\n            // if we don\\'t haveany outoing edge from our current node,\\n            // means we can\\'t move further, therefore skip\\n            if (!adj.containsKey(currNode)) {\\n                continue;\\n            }\\n            // else, record all the nodes we can visit from current node\\n            for (int[] next : adj.get(currNode)) {\\n                int nextNode = next[0];\\n                // the cost till next node is current cost so far + \\n                // cost of travelling from current node to next node (edge weight)\\n                int costToNextNode = costSoFar + next[1];\\n                // push them to the heap (we take one more step so \\'steps + 1\\')\\n                pq.offer(new int[] {nextNode, costToNextNode, stepsSoFar + 1});\\n            }\\n        }\\n\\n        // if in any way, we didn\\'t reach dst, we will return -1\\n        return -1;\\n    }\\n}\\n```\\n---\\n### Clean solution:\\n``` java []\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<int[]>> adj = new HashMap<>();\\n        for (int[] f : flights) {\\n            adj.putIfAbsent(f[0], new ArrayList<>());\\n            adj.get(f[0]).add(new int[] {f[1], f[2]});\\n        }\\n\\n        int[] stops = new int[n];\\n        Arrays.fill(stops, Integer.MAX_VALUE);  \\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {src, 0, 0});    \\n\\n        while (!pq.isEmpty()) {\\n            int[] currDetails = pq.poll();\\n            int currNode = currDetails[0];\\n            int costSoFar = currDetails[1];\\n            int stepsSoFar = currDetails[2];\\n\\n            if (stepsSoFar > stops[currNode] || stepsSoFar > k + 1) {\\n                continue;\\n            }\\n            stops[currNode] = stepsSoFar;\\n            if (currNode == dst) {  \\n                return costSoFar;   \\n            }\\n            if (!adj.containsKey(currNode)) {\\n                continue;\\n            }\\n            for (int[] next : adj.get(currNode)) {\\n                pq.offer(new int[] {next[0], costSoFar + next[1], stepsSoFar + 1});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n---\\n\\n\\nLet $$e$$ be the number of flights and $$n$$ be number of cities in the given problem.\\n\\n### Time complexity: $$O(n + e*k *log(e*k))$$\\n\\n- Let\\'s assume any node `A` is popped out of the queue in an iteration. If the steps taken to visit `A `are more than `stops[currNode]`, we do not iterate over the neighbors of `A`. However, we will iterate over neighbors of `A` if the steps are less than `stops[A]`, which can be true `k` times. `A` can be popped the first time with `k` steps, followed by `k-1` steps, and so on until `1` step. The same argument would be valid for any other node like `A`. As a result, each edge can only be processed `k` times, resulting in $$O(e * k)$$ elements being processed.\\n- It will take the priority queue $$O(e*k *log(e*k))$$ time to push or pop $$O(e * k)$$ elements.\\n- We\\'ve added $$O(n)$$ time by using the stops array.\\n\\n\\n### Space complexity: $$O(n + e * k)$$\\n\\nWe are using the `adj` map, which requires $$O(e)$$ memory. The `stops` array would require $$O(n)$$ memory. As previously stated, the priority queue can only have $$O(e * k)$$ elements.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        // map of <node (from) -> <node (to), cost of from - to>>\\n        Map<Integer, List<int[]>> adj = new HashMap<>();\\n        for (int[] f : flights) {\\n            adj.putIfAbsent(f[0], new ArrayList<>());\\n            adj.get(f[0]).add(new int[] {f[1], f[2]});\\n        }\\n\\n        // array to record minimum steps to reach a particular node\\n        int[] stops = new int[n];\\n        Arrays.fill(stops, Integer.MAX_VALUE);  // initialise with int_max\\n\\n        // min heap which will always give us least cost journey\\n        // {node, cost_from_src_node, number_of_stops_from_src_node}\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {src, 0, 0});    // starts with node 0, cost 0 and 0 steps\\n\\n        while (!pq.isEmpty()) {\\n            int[] currDetails = pq.poll();\\n            int currNode = currDetails[0];\\n            int costSoFar = currDetails[1];\\n            int stepsSoFar = currDetails[2];\\n\\n            // till the current node, if we have already encountered a path wi lesser stops\\n            // or if the number of stops exceeds the limit, we will skip\\n            if (stepsSoFar > stops[currNode] || stepsSoFar > k + 1) {\\n                continue;\\n            }\\n            // otherwise, it means that we have reached the current node with lesser number of stops\\n            // so we put the that new number of stops so far at index \\'currNode\\'\\n            stops[currNode] = stepsSoFar;\\n            if (currNode == dst) {  // if current node is our destination\\n                return costSoFar;   // return the cost incurred so far\\n            }\\n            // if we don\\'t haveany outoing edge from our current node,\\n            // means we can\\'t move further, therefore skip\\n            if (!adj.containsKey(currNode)) {\\n                continue;\\n            }\\n            // else, record all the nodes we can visit from current node\\n            for (int[] next : adj.get(currNode)) {\\n                int nextNode = next[0];\\n                // the cost till next node is current cost so far + \\n                // cost of travelling from current node to next node (edge weight)\\n                int costToNextNode = costSoFar + next[1];\\n                // push them to the heap (we take one more step so \\'steps + 1\\')\\n                pq.offer(new int[] {nextNode, costToNextNode, stepsSoFar + 1});\\n            }\\n        }\\n\\n        // if in any way, we didn\\'t reach dst, we will return -1\\n        return -1;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<int[]>> adj = new HashMap<>();\\n        for (int[] f : flights) {\\n            adj.putIfAbsent(f[0], new ArrayList<>());\\n            adj.get(f[0]).add(new int[] {f[1], f[2]});\\n        }\\n\\n        int[] stops = new int[n];\\n        Arrays.fill(stops, Integer.MAX_VALUE);  \\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {src, 0, 0});    \\n\\n        while (!pq.isEmpty()) {\\n            int[] currDetails = pq.poll();\\n            int currNode = currDetails[0];\\n            int costSoFar = currDetails[1];\\n            int stepsSoFar = currDetails[2];\\n\\n            if (stepsSoFar > stops[currNode] || stepsSoFar > k + 1) {\\n                continue;\\n            }\\n            stops[currNode] = stepsSoFar;\\n            if (currNode == dst) {  \\n                return costSoFar;   \\n            }\\n            if (!adj.containsKey(currNode)) {\\n                continue;\\n            }\\n            for (int[] next : adj.get(currNode)) {\\n                pq.offer(new int[] {next[0], costSoFar + next[1], stepsSoFar + 1});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102418,
                "title": "python3-95-ms-faster-than-98-82-of-python3",
                "content": "```\\ndef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph, dis = defaultdict(list), [-1 for _ in range(n)]\\n        for f, to, price in flights:\\n            graph[f].append([to, price])\\n        dis[src], q, step = 0, deque([src]), 0\\n        while q and step <= k:\\n            sz = len(q)\\n            new_dis = list(dis)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                for neighbor in graph[cur]:\\n                    if new_dis[neighbor[0]] == -1 or new_dis[neighbor[0]] > dis[cur]+neighbor[1]:\\n                        new_dis[neighbor[0]] = dis[cur] + neighbor[1]\\n                        q.append(neighbor[0])\\n            step += 1\\n            dis = new_dis\\n        return dis[dst]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph, dis = defaultdict(list), [-1 for _ in range(n)]\\n        for f, to, price in flights:\\n            graph[f].append([to, price])\\n        dis[src], q, step = 0, deque([src]), 0\\n        while q and step <= k:\\n            sz = len(q)\\n            new_dis = list(dis)\\n            for _ in range(sz):\\n                cur = q.popleft()\\n                for neighbor in graph[cur]:\\n                    if new_dis[neighbor[0]] == -1 or new_dis[neighbor[0]] > dis[cur]+neighbor[1]:\\n                        new_dis[neighbor[0]] = dis[cur] + neighbor[1]\\n                        q.append(neighbor[0])\\n            step += 1\\n            dis = new_dis\\n        return dis[dst]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3101649,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        #define ppi pair<int, int> \\n        vector<ppi> adj[n];\\n        for(auto v:flights)\\n        adj[v[0]].push_back({v[1], v[2]});\\n        queue<ppi> q;\\n        q.push({src, 0});\\n        vector<int> dist(n, 1e9);\\n        int stops=0;\\n        while(stops<=k && !q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto [u, d]=q.front();\\n                q.pop();\\n                for(auto [v, w]:adj[u])\\n                {\\n                    if(dist[v]>d+w)\\n                    {\\n                        dist[v]=d+w;\\n                        q.push({v, dist[v]});\\n                    }\\n                }\\n            }\\n            stops++;\\n        }\\n        if(dist[dst]==1e9)\\n        return -1;\\n        return dist[dst];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        #define ppi pair<int, int> \\n        vector<ppi> adj[n];\\n        for(auto v:flights)\\n        adj[v[0]].push_back({v[1], v[2]});\\n        queue<ppi> q;\\n        q.push({src, 0});\\n        vector<int> dist(n, 1e9);\\n        int stops=0;\\n        while(stops<=k && !q.empty())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto [u, d]=q.front();\\n                q.pop();\\n                for(auto [v, w]:adj[u])\\n                {\\n                    if(dist[v]>d+w)\\n                    {\\n                        dist[v]=d+w;\\n                        q.push({v, dist[v]});\\n                    }\\n                }\\n            }\\n            stops++;\\n        }\\n        if(dist[dst]==1e9)\\n        return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100504,
                "title": "java-based-on-dijkstra-edge-relaxation",
                "content": "Sharing my solution for fun. It\\'s not optimal but another solution which one can learn from and brain storm :)\\n\\n# Intuition\\nWe want to run a relxation algorithm on the edges, exactly like Dijkstra. The nuance here is that we must also account the amount of moves we have taken. If we find a vertex with a longer distance but smaller moves, we must still explore it because maybe previously we didn\\'t have enough moves to reach the destination.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n        // Build graph\\n        // node -> [[neighbor,distance]]\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) graph.put(i, new ArrayList<>());\\n        \\n        for(int[] flight : flights) {\\n            int u = flight[0];\\n            int v = flight[1];\\n            int w = flight[2];\\n            graph.get(u).add(new int[] {v, w});\\n        }\\n        \\n        // int[] -> [node, distance, moves] for every index\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] distance = new int[n];\\n        Arrays.fill(distance, -1);\\n\\n        int[] maxMovesUpToNode = new int[n];\\n        Arrays.fill(maxMovesUpToNode, Integer.MAX_VALUE);\\n\\n        // Initial mark\\n        distance[src] = 0;\\n        pq.offer(new int[] {src, 0, 0});\\n        \\n        // Run Relaxation Algorithm\\n        while(!pq.isEmpty()) {\\n            int[] element = pq.poll();\\n            int node = element[0];\\n            int dis = element[1];\\n            int moves = element[2];\\n\\n            if(maxMovesUpToNode[node] < moves) continue;\\n            maxMovesUpToNode[node] = moves;\\n            \\n            for(int[] edge : graph.get(node)) {\\n                int neighbor = edge[0], weight = edge[1];\\n                \\n                int neighborNewDistance = weight + dis;\\n                if(distance[neighbor] == -1 || neighborNewDistance < distance[neighbor]) {\\n                    distance[neighbor] = neighborNewDistance;\\n                }\\n                // If we have moves left.\\n                if(k != moves) {\\n                    pq.offer(new int[] {neighbor, neighborNewDistance, moves + 1});\\n                }\\n            }\\n        }\\n        \\n        \\n        return distance[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        \\n        // Build graph\\n        // node -> [[neighbor,distance]]\\n        Map<Integer, List<int[]>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) graph.put(i, new ArrayList<>());\\n        \\n        for(int[] flight : flights) {\\n            int u = flight[0];\\n            int v = flight[1];\\n            int w = flight[2];\\n            graph.get(u).add(new int[] {v, w});\\n        }\\n        \\n        // int[] -> [node, distance, moves] for every index\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        int[] distance = new int[n];\\n        Arrays.fill(distance, -1);\\n\\n        int[] maxMovesUpToNode = new int[n];\\n        Arrays.fill(maxMovesUpToNode, Integer.MAX_VALUE);\\n\\n        // Initial mark\\n        distance[src] = 0;\\n        pq.offer(new int[] {src, 0, 0});\\n        \\n        // Run Relaxation Algorithm\\n        while(!pq.isEmpty()) {\\n            int[] element = pq.poll();\\n            int node = element[0];\\n            int dis = element[1];\\n            int moves = element[2];\\n\\n            if(maxMovesUpToNode[node] < moves) continue;\\n            maxMovesUpToNode[node] = moves;\\n            \\n            for(int[] edge : graph.get(node)) {\\n                int neighbor = edge[0], weight = edge[1];\\n                \\n                int neighborNewDistance = weight + dis;\\n                if(distance[neighbor] == -1 || neighborNewDistance < distance[neighbor]) {\\n                    distance[neighbor] = neighborNewDistance;\\n                }\\n                // If we have moves left.\\n                if(k != moves) {\\n                    pq.offer(new int[] {neighbor, neighborNewDistance, moves + 1});\\n                }\\n            }\\n        }\\n        \\n        \\n        return distance[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988160,
                "title": "c-solution-dijkstra-s-algorithm",
                "content": "# Please Upvote If You Find It Helpful.\\n# Approach: Using Dijkstra\\'s Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\n#define pi pair<int, pair<int,int>>\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int, int>> adj[n];\\n        for(auto it : flights){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        queue<pi> q;\\n        vector<int> dist(n, 1e9);\\n        //{stops,{node, price}}\\n        q.push({0, {src, 0}});\\n        dist[src] = 0;\\n        while(!q.empty()){\\n            int stop = q.front().first;\\n            int node = q.front().second.first, price = q.front().second.second;\\n            q.pop();\\n            if(stop > k) continue;\\n            for(auto it:adj[node]){\\n                int adjN = it.first;\\n                int Nprice = it.second;\\n                if(dist[adjN] > price + Nprice && stop<=k){\\n                    dist[adjN] = price + Nprice;\\n                    q.push({stop+1, {adjN, dist[adjN]}});\\n                }\\n            }\\n        }\\n        if(dist[dst]==1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pi pair<int, pair<int,int>>\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int, int>> adj[n];\\n        for(auto it : flights){\\n            adj[it[0]].push_back({it[1], it[2]});\\n        }\\n        queue<pi> q;\\n        vector<int> dist(n, 1e9);\\n        //{stops,{node, price}}\\n        q.push({0, {src, 0}});\\n        dist[src] = 0;\\n        while(!q.empty()){\\n            int stop = q.front().first;\\n            int node = q.front().second.first, price = q.front().second.second;\\n            q.pop();\\n            if(stop > k) continue;\\n            for(auto it:adj[node]){\\n                int adjN = it.first;\\n                int Nprice = it.second;\\n                if(dist[adjN] > price + Nprice && stop<=k){\\n                    dist[adjN] = price + Nprice;\\n                    q.push({stop+1, {adjN, dist[adjN]}});\\n                }\\n            }\\n        }\\n        if(dist[dst]==1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590919,
                "title": "modified-djikstra-s-prioritize-stops-before-the-cost-in-the-priority-queue",
                "content": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        \\n        maxHops = k+1\\n        \\n        graph = defaultdict(list)\\n        \\n        for (u,v,w) in flights:\\n            graph[u].append((v,w))\\n            \\n        \\n        cost = [float(\\'inf\\')]*n \\n        \\n        cost[src] = 0\\n        \\n        # here no. of stops is the first value used to sort ahead of the cost\\n        # This ensure we explore the shorter routes first!\\n        heap = [( 0, cost[src] ,src)]\\n        \\n        while heap:\\n            curStops, curCost, curNode = heappop(heap)\\n            \\n            for nbr,w in graph[curNode]:\\n                \\n                nextStops = curStops + 1\\n                nextCost = curCost + w\\n                \\n                # Don\\'t add to pq if the stops crosses the limit\\n                if nextCost < cost[nbr] and nextStops <= k+1:\\n                    cost[nbr] = nextCost\\n                    heappush(heap, ( nextStops, nextCost, nbr ))\\n            \\n    \\n        if cost[dst] != float(\\'inf\\'):\\n            return cost[dst]\\n        else:\\n            return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        \\n        maxHops = k+1\\n        \\n        graph = defaultdict(list)\\n        \\n        for (u,v,w) in flights:\\n            graph[u].append((v,w))\\n            \\n        \\n        cost = [float(\\'inf\\')]*n \\n        \\n        cost[src] = 0\\n        \\n        # here no. of stops is the first value used to sort ahead of the cost\\n        # This ensure we explore the shorter routes first!\\n        heap = [( 0, cost[src] ,src)]\\n        \\n        while heap:\\n            curStops, curCost, curNode = heappop(heap)\\n            \\n            for nbr,w in graph[curNode]:\\n                \\n                nextStops = curStops + 1\\n                nextCost = curCost + w\\n                \\n                # Don\\'t add to pq if the stops crosses the limit\\n                if nextCost < cost[nbr] and nextStops <= k+1:\\n                    cost[nbr] = nextCost\\n                    heappush(heap, ( nextStops, nextCost, nbr ))\\n            \\n    \\n        if cost[dst] != float(\\'inf\\'):\\n            return cost[dst]\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489340,
                "title": "c-priority-queue-bfs-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto x:flights)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n        }\\n        priority_queue< vector<int> ,vector<vector<int>>,greater<vector<int>>> pq;\\n        vector<int> stops(n,INT_MAX);\\n        pq.push({0,src,0});\\n        while(pq.size()!=0)\\n        {\\n            vector<int> v=pq.top();\\n            pq.pop();\\n            int current_stops=v[2],node=v[1],cost=v[0];\\n            if(node==dst)\\n                return cost;                               \\n            /* case1->if we have previously reached this node with \\n            less stops then no need to traverse this again with more stops\\n             case2-> if we have crossed the limit of maximum possible stops in both the cases we are\\n             not traversing further*/\\n            if(stops[node]<current_stops || current_stops>k)\\n                continue;\\n            stops[node]=current_stops;\\n            for(auto x:adj[node])\\n            {\\n                pq.push({cost+x.second,x.first,current_stops+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto x:flights)\\n        {\\n            adj[x[0]].push_back({x[1],x[2]});\\n        }\\n        priority_queue< vector<int> ,vector<vector<int>>,greater<vector<int>>> pq;\\n        vector<int> stops(n,INT_MAX);\\n        pq.push({0,src,0});\\n        while(pq.size()!=0)\\n        {\\n            vector<int> v=pq.top();\\n            pq.pop();\\n            int current_stops=v[2],node=v[1],cost=v[0];\\n            if(node==dst)\\n                return cost;                               \\n            /* case1->if we have previously reached this node with \\n            less stops then no need to traverse this again with more stops\\n             case2-> if we have crossed the limit of maximum possible stops in both the cases we are\\n             not traversing further*/\\n            if(stops[node]<current_stops || current_stops>k)\\n                continue;\\n            stops[node]=current_stops;\\n            for(auto x:adj[node])\\n            {\\n                pq.push({cost+x.second,x.first,current_stops+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386606,
                "title": "c-python-min-heap-dijkstra-algorithm",
                "content": "**C++ Code**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t#define f first\\n\\t\\t#define s second\\n\\t\\tint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k){\\n\\t\\t\\tpriority_queue< array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;\\n\\t\\t\\tunordered_map<int, vector<pair<int,int>>> g;\\n\\n\\t\\t\\tfor(auto& f : flights){\\n\\t\\t\\t\\tg[f[0]].push_back({f[1],f[2]});\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> dis(n,INT_MAX);\\n\\t\\t\\tpq.push({0,src,0});\\n\\t\\t\\twhile(!pq.empty()){\\n\\t\\t\\t\\tint c = pq.top()[0];            \\n\\t\\t\\t\\tint cur = pq.top()[1];\\n\\t\\t\\t\\tint lvl = pq.top()[2]; \\n\\t\\t\\t\\tpq.pop();  \\n\\t\\t\\t\\tif(cur==dst) return c;\\n\\t\\t\\t\\tif(lvl > k || lvl >= dis[cur]) continue;\\n\\t\\t\\t\\tdis[cur] = lvl;\\n\\t\\t\\t\\tfor(auto& nei : g[cur]){\\n\\t\\t\\t\\t\\tpq.push({c+nei.s, nei.f, lvl+1});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\n**Python Code**\\n\\n\\tclass Solution:\\n\\t\\tdef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tfor u,v,w in flights: graph[u].append((v,w))\\n\\n\\t\\t\\tpq = [(0,src,0)]\\n\\t\\t\\tdis = [float(\\'inf\\')]*n\\n\\n\\t\\t\\twhile pq:\\n\\t\\t\\t\\tc,n,l = heappop(pq)\\n\\t\\t\\t\\tif n==dst: return c\\n\\t\\t\\t\\tif l > k or l>= dis[n]: continue\\n\\t\\t\\t\\tdis[n] = l\\n\\t\\t\\t\\tfor v,w in graph[n]:\\n\\t\\t\\t\\t\\theappush(pq,(c+w,v,l+1))\\n\\t\\t\\treturn -1\\n\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t#define f first\\n\\t\\t#define s second\\n\\t\\tint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k){\\n\\t\\t\\tpriority_queue< array<int,3>, vector<array<int,3>>, greater<array<int,3>>> pq;\\n\\t\\t\\tunordered_map<int, vector<pair<int,int>>> g;\\n\\n\\t\\t\\tfor(auto& f : flights){\\n\\t\\t\\t\\tg[f[0]].push_back({f[1],f[2]}",
                "codeTag": "Java"
            },
            {
                "id": 2332195,
                "title": "java-bellman-ford-with-k-stops-using-2-arrays-5-ms",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[]dist = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[src] = 0;\\n        \\n        for(int i=1;i<=k+1;i++){\\n            int []dp1 = dist.clone();\\n            for(int []flight : flights){\\n                int u = flight[0];\\n                int v = flight[1];\\n                int uv = flight[2];\\n                \\n                if(dist[u] != Integer.MAX_VALUE){\\n                    dp1[v] = Math.min(dp1[v],dist[u] + uv);\\n                }\\n            }\\n            dist = dp1;\\n        }\\n        \\n        if(dist[dst] == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return dist[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int[]dist = new int[n];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[src] = 0;\\n        \\n        for(int i=1;i<=k+1;i++){\\n            int []dp1 = dist.clone();\\n            for(int []flight : flights){\\n                int u = flight[0];\\n                int v = flight[1];\\n                int uv = flight[2];\\n                \\n                if(dist[u] != Integer.MAX_VALUE){\\n                    dp1[v] = Math.min(dp1[v],dist[u] + uv);\\n                }\\n            }\\n            dist = dp1;\\n        }\\n        \\n        if(dist[dst] == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return dist[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827190,
                "title": "java-dfs-dp-clean-code",
                "content": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int graph[][] = new int[n][n];\\n        \\n        //creating matrix that represents grpah\\n        //graph[i][j] = price to travel from i to j\\n        for (int i = 0; i < flights.length; i++) {\\n            graph[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        \\n        //find cheapest price with k stops(k + 1 flights)\\n        int ans = findCheapestPrice(src, dst, graph, k + 1, new int[n + 1][n + 1][k + 2]);\\n        \\n        return ans >= 1000000 ? -1 : ans;\\n    }\\n    \\n    /*\\n        finds cheapest price with k flights from src to dst \\n\\t\\tO(N * N * K)\\n    */\\n    int findCheapestPrice(int src, int dst, int graph[][], int k, int dp[][][]) {\\n        \\n        //reached to destination\\n        if (dst == src) {\\n            return 0;\\n        }\\n        \\n        //no more flights left\\n        if (k == 0) {\\n            return 1000000;\\n        }\\n        \\n        //already calculated then return\\n        if (dp[src][dst][k] != 0) {\\n            return dp[src][dst][k];\\n        }\\n        \\n        \\n        //initializing min to some greater number\\n        //for each possible edge from src in graph traverse and caluculate distance\\n        //keep  minimum distance \\n        int min = 1000000;\\n        for (int i = 0; i < graph[src].length; i++) {\\n            if (graph[src][i] != 0) {\\n                min = Math.min(min, graph[src][i] + findCheapestPrice(i, dst, graph, k - 1, dp));\\n            }\\n        }\\n        \\n        return dp[src][dst][k] = min; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        int graph[][] = new int[n][n];\\n        \\n        //creating matrix that represents grpah\\n        //graph[i][j] = price to travel from i to j\\n        for (int i = 0; i < flights.length; i++) {\\n            graph[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        \\n        //find cheapest price with k stops(k + 1 flights)\\n        int ans = findCheapestPrice(src, dst, graph, k + 1, new int[n + 1][n + 1][k + 2]);\\n        \\n        return ans >= 1000000 ? -1 : ans;\\n    }\\n    \\n    /*\\n        finds cheapest price with k flights from src to dst \\n\\t\\tO(N * N * K)\\n    */\\n    int findCheapestPrice(int src, int dst, int graph[][], int k, int dp[][][]) {\\n        \\n        //reached to destination\\n        if (dst == src) {\\n            return 0;\\n        }\\n        \\n        //no more flights left\\n        if (k == 0) {\\n            return 1000000;\\n        }\\n        \\n        //already calculated then return\\n        if (dp[src][dst][k] != 0) {\\n            return dp[src][dst][k];\\n        }\\n        \\n        \\n        //initializing min to some greater number\\n        //for each possible edge from src in graph traverse and caluculate distance\\n        //keep  minimum distance \\n        int min = 1000000;\\n        for (int i = 0; i < graph[src].length; i++) {\\n            if (graph[src][i] != 0) {\\n                min = Math.min(min, graph[src][i] + findCheapestPrice(i, dst, graph, k - 1, dp));\\n            }\\n        }\\n        \\n        return dp[src][dst][k] = min; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738709,
                "title": "c-solutions-with-explanation",
                "content": "# 1. Brief explanation to relaxatioin\\n![image](https://assets.leetcode.com/users/images/ec432558-bacf-44c2-a0bf-717ff557c03f_1643783358.1116207.jpeg)\\nFor example, if we see a flight from city *i* to city *j* with price *p*, then the new minimal distance from source to *j* could be updated as shown in the formula below.\\n<img src=\"http://latex.codecogs.com/svg.image?dist[j] = min(dist[j], dist[i]+p)\" title=\"form1\" />\\n\\nThis is called relaxation in graph theory.\\n\\n\\n# 2. Suboptimal solution\\nThis problem requires the solution to be within *k* stops, meaning that the path we find can not exceed *k+1* edges.\\nIt means that while solving this problem, we might have to check some intermediate solutions that are not optimal.\\n\\nTaking the image below, for example, assuming that the source city is 0 and destination city is 3;\\nWhen *k* equals 1, we might be stuck at city 2 whose optimal (minimal) distance is 2 with the number of stops as 2 if we do not consider the intermediate solution where the distance from the source is 5 with the number of stops as 1.\\n![image](https://assets.leetcode.com/users/images/10cb4ad0-16ae-46ea-ad99-545c36940349_1643784894.322046.jpeg)\\n\\n\\n# 3. Bellman-Ford\\nIn each iteration, we go through every edge in the vector *flights*.\\nIn the other words, each iteration we are computing the smallest distance from each city to source city within *(number of iterations - 1)* stops.\\n\\nNote that we could not update to the same distance vector or we may update a distance to a city multiple times in one iteration. (e.g. city *a* updates city *b*, and city *b* updates city *c* right after.)I\\n```\\n#define MAX_DIST 1e6 // greater than (n-1) edges * 1e4 (max price)\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<int> dist(n, MAX_DIST);\\n        vector<int> old_dist;\\n        \\n        dist[src] = 0;\\n        \\n        k++; // k stops -> k+1 iterations\\n        while(k--){\\n            old_dist.assign(dist.begin(), dist.end());\\n            for(auto& f: flights){\\n                dist[f[1]] = min(dist[f[1]], old_dist[f[0]] + f[2]);\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst];\\n    }\\n};\\n```\\n\\n# 4. Breadth-First Search\\nFirst of all, I prepare an adjacent list *adj*, where *adj[i]* is a unordered_map mapping the indices of cities where we can fly from city i to their respective prices of flights.\\n\\nThen we perform a breadth-first search starting from the source city.\\nFor each iteration, we are checking a set of cities that are *(number of iterations)* away from the source city.\\n```\\n#define MAX_DIST 1e6\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n\\t    // adjacent list\\n        vector<unordered_map<int, int>> adj(n); // src: to->weight\\n        for(auto& f: flights)\\n            adj[f[0]][f[1]] = f[2];\\n\\n        vector<int> dist(n, MAX_DIST);\\n        \\n        queue<vector<int>> q;\\n        q.push({src, 0});\\n        \\n        k++;\\n        while(k--){\\n            int q_size = q.size();\\n            while(q_size--){\\n                auto x = q.front(); q.pop();\\n                int cur_idx = x[0];\\n                int cur_dist = x[1];\\n                \\n                for(auto p: adj[cur_idx]){\\n                    int new_dist = p.second + cur_dist;\\n                    if(new_dist < dist[p.first]){\\n                        q.push({p.first, new_dist});\\n                        dist[p.first] = new_dist;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst]; \\n    }\\n};\\n```\\n\\n# 5. Dijkstra\\nMy implementation with Dijkastra is basically the same as the code in the solution.\\nApart from that I move the line ```stop[new_idx] = new_stop;``` into the if scope doing relaxation.\\n\\nThe problem with the Dijkstra solution is that it will always go for the solution with the smallest distance regardless of the number of stops.\\nTherefore, I add a vector named *stop* recording the *number of stops* with the smallest distance for any city.\\nWhen there is an intermediate solution with a greater distance and a smaller *number of stops*, we will have to push it into priority_queue and check for possible better solutions for other cities.\\n```\\n#define MAX_DIST 1e6\\n#define vi vector<int>\\n\\nclass Solution {\\nprivate:\\n    class cmp {\\n    public:\\n        size_t operator()(const vi& v1, const vi& v2) const{ // {index, distance, stops}\\n            return v1[1] > v2[1]; // vector with smallest distance pop first\\n        }\\n    };\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // adjacent list\\n        vector<unordered_map<int, int>> adj(n);\\n        for(auto f: flights)\\n            adj[f[0]][f[1]] = f[2];\\n        \\n        // dist vector\\n        vector<int> dist(n, MAX_DIST);\\n        \\n        // stop vector\\n        vector<int> stop(n, n);\\n        \\n        // priority queue for dijkstra\\n        priority_queue<vi, vector<vi>, cmp> pq;\\n        pq.push({src, 0, 0}); // src with 0 dist, 0 stops\\n        dist[src] = 0;\\n        stop[src] = 0;\\n        \\n        // dijkstra\\n        while(!pq.empty()){\\n            vi cur = pq.top(); pq.pop(); // pop smallest distance\\n            \\n            int cur_idx = cur[0];\\n            int cur_dist = cur[1];\\n            int cur_stop = cur[2];\\n\\n            if(cur_idx == dst)\\n                return cur_dist;\\n            \\n            if(cur_stop == k + 1)\\n                continue;\\n\\n            for(auto& p: adj[cur_idx]){\\n                int new_idx = p.first;\\n                int new_dist = cur_dist + p.second;\\n                int new_stop = cur_stop + 1;\\n                \\n                if(new_dist < dist[new_idx]){ // relaxation\\n                    dist[new_idx] = new_dist;\\n                    pq.push({new_idx, new_dist, new_stop});\\n                    stop[new_idx] = new_stop;\\n                }\\n                else if(new_stop < stop[new_idx]){\\n                    pq.push({new_idx, new_dist, new_stop});\\n                }\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define MAX_DIST 1e6 // greater than (n-1) edges * 1e4 (max price)\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<int> dist(n, MAX_DIST);\\n        vector<int> old_dist;\\n        \\n        dist[src] = 0;\\n        \\n        k++; // k stops -> k+1 iterations\\n        while(k--){\\n            old_dist.assign(dist.begin(), dist.end());\\n            for(auto& f: flights){\\n                dist[f[1]] = min(dist[f[1]], old_dist[f[0]] + f[2]);\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst];\\n    }\\n};\\n```\n```\\n#define MAX_DIST 1e6\\n\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n\\t    // adjacent list\\n        vector<unordered_map<int, int>> adj(n); // src: to->weight\\n        for(auto& f: flights)\\n            adj[f[0]][f[1]] = f[2];\\n\\n        vector<int> dist(n, MAX_DIST);\\n        \\n        queue<vector<int>> q;\\n        q.push({src, 0});\\n        \\n        k++;\\n        while(k--){\\n            int q_size = q.size();\\n            while(q_size--){\\n                auto x = q.front(); q.pop();\\n                int cur_idx = x[0];\\n                int cur_dist = x[1];\\n                \\n                for(auto p: adj[cur_idx]){\\n                    int new_dist = p.second + cur_dist;\\n                    if(new_dist < dist[p.first]){\\n                        q.push({p.first, new_dist});\\n                        dist[p.first] = new_dist;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst]; \\n    }\\n};\\n```\n```stop[new_idx] = new_stop;```\n```\\n#define MAX_DIST 1e6\\n#define vi vector<int>\\n\\nclass Solution {\\nprivate:\\n    class cmp {\\n    public:\\n        size_t operator()(const vi& v1, const vi& v2) const{ // {index, distance, stops}\\n            return v1[1] > v2[1]; // vector with smallest distance pop first\\n        }\\n    };\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // adjacent list\\n        vector<unordered_map<int, int>> adj(n);\\n        for(auto f: flights)\\n            adj[f[0]][f[1]] = f[2];\\n        \\n        // dist vector\\n        vector<int> dist(n, MAX_DIST);\\n        \\n        // stop vector\\n        vector<int> stop(n, n);\\n        \\n        // priority queue for dijkstra\\n        priority_queue<vi, vector<vi>, cmp> pq;\\n        pq.push({src, 0, 0}); // src with 0 dist, 0 stops\\n        dist[src] = 0;\\n        stop[src] = 0;\\n        \\n        // dijkstra\\n        while(!pq.empty()){\\n            vi cur = pq.top(); pq.pop(); // pop smallest distance\\n            \\n            int cur_idx = cur[0];\\n            int cur_dist = cur[1];\\n            int cur_stop = cur[2];\\n\\n            if(cur_idx == dst)\\n                return cur_dist;\\n            \\n            if(cur_stop == k + 1)\\n                continue;\\n\\n            for(auto& p: adj[cur_idx]){\\n                int new_idx = p.first;\\n                int new_dist = cur_dist + p.second;\\n                int new_stop = cur_stop + 1;\\n                \\n                if(new_dist < dist[new_idx]){ // relaxation\\n                    dist[new_idx] = new_dist;\\n                    pq.push({new_idx, new_dist, new_stop});\\n                    stop[new_idx] = new_stop;\\n                }\\n                else if(new_stop < stop[new_idx]){\\n                    pq.push({new_idx, new_dist, new_stop});\\n                }\\n            }\\n        }\\n        \\n        return (dist[dst] == MAX_DIST) ? -1 : dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719520,
                "title": "2-solutions-dijkstra-and-bellman-ford",
                "content": "k stops means atmost k+1 distance\\n\\nDIJKSTRA\\n```\\nclass Solution {\\n    class Edge{\\n        int v;\\n        int wt;\\n        int dist;\\n        \\n        Edge(int v, int wt, int dist){\\n            this.v = v;\\n            this.wt = wt;\\n            this.dist = dist;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        k++;\\n        ArrayList<ArrayList<Edge>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : flights){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            \\n            graph.get(u).add(new Edge(v, wt, 1));\\n            \\n        }\\n        \\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);\\n        pq.add(new Edge(src, 0, 0));\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        \\n        while(pq.size() > 0){\\n            Edge p = pq.remove();\\n            if(p.dist > k || stop[p.v] < p.dist)continue;\\n            \\n            stop[p.v] = p.dist;\\n            if(p.v == dst)return p.wt;\\n\\n            for(Edge nbr : graph.get(p.v)){\\n                pq.add(new Edge(nbr.v, p.wt + nbr.wt, p.dist + 1));\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n\\nBELLMAN-FORD\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n\\t//here dp[i,j] means reaching jth vertex using atmost i hops\\n        int[][] dp = new int[k+2][n];\\n\\n        for(int i=0;i<k+2;i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);\\n        }]\\n        \\n        for(int i = 0; i <= k+1; i++){\\n            dp[i][src] = 0; // src is at a dist 0, no matter how many hops u take\\n        }\\n        \\n        for(int i = 1; i <= k+1; i++){\\n            for(int[] f: flights){\\n                int u = f[0];\\n                int v = f[1];\\n                int w = f[2];\\n                \\n                if(dp[i-1][u] != Integer.MAX_VALUE)\\n                    dp[i][v] = Math.min(dp[i][v], dp[i-1][u] + w);\\n            }\\n        }\\n        \\n        return (dp[k+1][dst] == Integer.MAX_VALUE)? -1: dp[k+1][dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Edge{\\n        int v;\\n        int wt;\\n        int dist;\\n        \\n        Edge(int v, int wt, int dist){\\n            this.v = v;\\n            this.wt = wt;\\n            this.dist = dist;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        k++;\\n        ArrayList<ArrayList<Edge>> graph = new ArrayList<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] edge : flights){\\n            int u = edge[0];\\n            int v = edge[1];\\n            int wt = edge[2];\\n            \\n            graph.get(u).add(new Edge(v, wt, 1));\\n            \\n        }\\n        \\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> a.wt - b.wt);\\n        pq.add(new Edge(src, 0, 0));\\n        int[] stop = new int[n];\\n        Arrays.fill(stop, Integer.MAX_VALUE);\\n        \\n        while(pq.size() > 0){\\n            Edge p = pq.remove();\\n            if(p.dist > k || stop[p.v] < p.dist)continue;\\n            \\n            stop[p.v] = p.dist;\\n            if(p.v == dst)return p.wt;\\n\\n            for(Edge nbr : graph.get(p.v)){\\n                pq.add(new Edge(nbr.v, p.wt + nbr.wt, p.dist + 1));\\n                \\n            }\\n            \\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n\\t//here dp[i,j] means reaching jth vertex using atmost i hops\\n        int[][] dp = new int[k+2][n];\\n\\n        for(int i=0;i<k+2;i++){\\n            Arrays.fill(dp[i],Integer.MAX_VALUE);\\n        }]\\n        \\n        for(int i = 0; i <= k+1; i++){\\n            dp[i][src] = 0; // src is at a dist 0, no matter how many hops u take\\n        }\\n        \\n        for(int i = 1; i <= k+1; i++){\\n            for(int[] f: flights){\\n                int u = f[0];\\n                int v = f[1];\\n                int w = f[2];\\n                \\n                if(dp[i-1][u] != Integer.MAX_VALUE)\\n                    dp[i][v] = Math.min(dp[i][v], dp[i-1][u] + w);\\n            }\\n        }\\n        \\n        return (dp[k+1][dst] == Integer.MAX_VALUE)? -1: dp[k+1][dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689620,
                "title": "c-bellman-ford-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        vector <int> distance(n ,INT_MAX);\\n        distance[src] = 0;\\n        \\n        for(int i = 0 ; i < k + 1; i ++){\\n            \\n            vector <int> copy(distance);\\n            for(auto flight : flights){\\n                int u = flight[0];\\n                int v = flight[1];\\n                int w = flight[2];\\n                \\n                if(distance[u] != INT_MAX and (distance[u] + w < copy[v])){\\n                    copy[v] = distance[u] + w;\\n                }\\n            }\\n            \\n            distance = copy;\\n        }\\n        \\n        \\n        return (distance[dst] == INT_MAX ? -1 : distance[dst]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        vector <int> distance(n ,INT_MAX);\\n        distance[src] = 0;\\n        \\n        for(int i = 0 ; i < k + 1; i ++){\\n            \\n            vector <int> copy(distance);\\n            for(auto flight : flights){\\n                int u = flight[0];\\n                int v = flight[1];\\n                int w = flight[2];\\n                \\n                if(distance[u] != INT_MAX and (distance[u] + w < copy[v])){\\n                    copy[v] = distance[u] + w;\\n                }\\n            }\\n            \\n            distance = copy;\\n        }\\n        \\n        \\n        return (distance[dst] == INT_MAX ? -1 : distance[dst]);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1449409,
                "title": "simple-python-o-v-elogv-dijkstra-solution",
                "content": "```Python\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(list)\\n        for a, b, price in flights:\\n            graph[a].append((b, price))\\n        \\n        node2minNstop = {i: float(\"inf\") for i in range(n)}\\n        pq = [(0, src, -1)]\\n        while pq:\\n            dist_from_src, node, n_stops = heappop(pq)\\n            if node == dst:\\n                return dist_from_src\\n\\t\\t\\t# skip current iteration if number of stops exceeds maximum\\n\\t\\t\\t# or we can reach current node with fewer stops. Suppose we\\'ve\\n\\t\\t\\t# visited this node before, by the property of Dijkstra we must have found\\n\\t\\t\\t# a path with lower cost to this node before. The only reason we might want\\n\\t\\t\\t# to visit it again is if we can visit it with fewer stops. If this is not the case, we\\n\\t\\t\\t# skip.\\n            if n_stops >= min(k, node2minNstop[node]):\\n                continue\\n            node2minNstop[node] = n_stops\\n            for neighbor, dist_to_neighbor in graph[node]:\\n                heappush(pq, (dist_from_src+dist_to_neighbor, neighbor, n_stops+1))\\n                    \\n        return -1\\n    \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nfrom heapq import heappush, heappop\\nfrom collections import defaultdict\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(list)\\n        for a, b, price in flights:\\n            graph[a].append((b, price))\\n        \\n        node2minNstop = {i: float(\"inf\") for i in range(n)}\\n        pq = [(0, src, -1)]\\n        while pq:\\n            dist_from_src, node, n_stops = heappop(pq)\\n            if node == dst:\\n                return dist_from_src\\n\\t\\t\\t# skip current iteration if number of stops exceeds maximum\\n\\t\\t\\t# or we can reach current node with fewer stops. Suppose we\\'ve\\n\\t\\t\\t# visited this node before, by the property of Dijkstra we must have found\\n\\t\\t\\t# a path with lower cost to this node before. The only reason we might want\\n\\t\\t\\t# to visit it again is if we can visit it with fewer stops. If this is not the case, we\\n\\t\\t\\t# skip.\\n            if n_stops >= min(k, node2minNstop[node]):\\n                continue\\n            node2minNstop[node] = n_stops\\n            for neighbor, dist_to_neighbor in graph[node]:\\n                heappush(pq, (dist_from_src+dist_to_neighbor, neighbor, n_stops+1))\\n                    \\n        return -1\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398215,
                "title": "modified-dijkstra-no-tle",
                "content": "Standard Dijkstra\\'s algorithm uses visit set to keep track of the vertices already included in the shortest path, so to not traverse them again.\\nBut here we need to traverse them again as stops maybe less. \\n\\nIdea is to keep a visit map (`vis[vertex] = stops`) with the stops for all the traversed vertices \\nNow if the same vertex is traversed again with stops `>=` stops present in the visit map, then that can be ignored as we already have the shortest distance for that many stops. It will remove all the redundant traversals.\\n\\n\\n```\\n\\n\\tpublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<Integer[]>> adj = new HashMap();\\n        int[] vis = new int[n];\\n        Arrays.fill(vis, Integer.MAX_VALUE);\\n        for(int[] flightcost : flights){\\n            adj.computeIfAbsent(flightcost[0], z -> new ArrayList()).add(new Integer[]{flightcost[1],flightcost[2]});\\n        }\\n        //Priority queue contains Integer array with 3 elements in order -> vertex, cost, stop \\n        Queue<Integer[]> que = new PriorityQueue<Integer[]>((o1,o2) -> {return o1[1]-o2[1];});        \\n        que.add(new Integer[]{src, 0, -1});\\n        \\n        while(!que.isEmpty()){\\n            Integer[] cur = que.poll();\\n            Integer curVertex = cur[0], curCost = cur[1], curStops = cur[2];\\n            if(curVertex == dst) return curCost;\\n\\t\\t\\t\\n            if(vis[curVertex] <= curStops || curStops == k || !adj.containsKey(curVertex)) continue;\\n            vis[curVertex] = curStops;\\n            for(Integer[] next : adj.get(curVertex)){\\n                que.add(new Integer[]{next[0], curCost + next[1], curStops+1});\\n            }            \\n        }\\n        return -1;\\n    }\\n\\t\\n\\n",
                "solutionTags": [],
                "code": "Standard Dijkstra\\'s algorithm uses visit set to keep track of the vertices already included in the shortest path, so to not traverse them again.\\nBut here we need to traverse them again as stops maybe less. \\n\\nIdea is to keep a visit map (`vis[vertex] = stops`) with the stops for all the traversed vertices \\nNow if the same vertex is traversed again with stops `>=` stops present in the visit map, then that can be ignored as we already have the shortest distance for that many stops. It will remove all the redundant traversals.\\n\\n\\n```\\n\\n\\tpublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        Map<Integer, List<Integer[]>> adj = new HashMap();\\n        int[] vis = new int[n];\\n        Arrays.fill(vis, Integer.MAX_VALUE);\\n        for(int[] flightcost : flights){\\n            adj.computeIfAbsent(flightcost[0], z -> new ArrayList()).add(new Integer[]{flightcost[1],flightcost[2]});\\n        }\\n        //Priority queue contains Integer array with 3 elements in order -> vertex, cost, stop \\n        Queue<Integer[]> que = new PriorityQueue<Integer[]>((o1,o2) -> {return o1[1]-o2[1];});        \\n        que.add(new Integer[]{src, 0, -1});\\n        \\n        while(!que.isEmpty()){\\n            Integer[] cur = que.poll();\\n            Integer curVertex = cur[0], curCost = cur[1], curStops = cur[2];\\n            if(curVertex == dst) return curCost;\\n\\t\\t\\t\\n            if(vis[curVertex] <= curStops || curStops == k || !adj.containsKey(curVertex)) continue;\\n            vis[curVertex] = curStops;\\n            for(Integer[] next : adj.get(curVertex)){\\n                que.add(new Integer[]{next[0], curCost + next[1], curStops+1});\\n            }            \\n        }\\n        return -1;\\n    }\\n\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1301173,
                "title": "easiest-c-code-12ms-small-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        vector<pair<int,int> > V[n+1] ;\\n        for(auto x:flights)\\n        {\\n            V[x[0]].push_back({x[1],x[2]}) ;\\n        }\\n        \\n        \\n        queue<pair<int,pair<int,int> > > Q ;\\n        Q.push({src,{0,0}}) ;\\n        \\n        int PRICE[n+1] ;\\n        for(int i=0 ; i<n+1 ; i++) PRICE[i]=INT_MAX ; \\n        PRICE[src]=0 ;\\n        \\n        while(!Q.empty())\\n        {\\n                int node = Q.front().first ;\\n                int dist = Q.front().second.first ;\\n                int cash = Q.front().second.second ;\\n\\n                Q.pop() ;\\n                for(auto child:V[node])\\n                {   \\n                    int jane_ka_price = child.second ; \\n                    int u = child.first ;\\n                    if(PRICE[u]>cash+jane_ka_price && dist<=K)\\n                    {\\n                        PRICE[u] = cash+jane_ka_price ;\\n                        Q.push({u,{dist+1,PRICE[u]} }) ;\\n                    }\\n                }\\n        }\\n\\n        return (PRICE[dst]<INT_MAX)? PRICE[dst]:-1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        vector<pair<int,int> > V[n+1] ;\\n        for(auto x:flights)\\n        {\\n            V[x[0]].push_back({x[1],x[2]}) ;\\n        }\\n        \\n        \\n        queue<pair<int,pair<int,int> > > Q ;\\n        Q.push({src,{0,0}}) ;\\n        \\n        int PRICE[n+1] ;\\n        for(int i=0 ; i<n+1 ; i++) PRICE[i]=INT_MAX ; \\n        PRICE[src]=0 ;\\n        \\n        while(!Q.empty())\\n        {\\n                int node = Q.front().first ;\\n                int dist = Q.front().second.first ;\\n                int cash = Q.front().second.second ;\\n\\n                Q.pop() ;\\n                for(auto child:V[node])\\n                {   \\n                    int jane_ka_price = child.second ; \\n                    int u = child.first ;\\n                    if(PRICE[u]>cash+jane_ka_price && dist<=K)\\n                    {\\n                        PRICE[u] = cash+jane_ka_price ;\\n                        Q.push({u,{dist+1,PRICE[u]} }) ;\\n                    }\\n                }\\n        }\\n\\n        return (PRICE[dst]<INT_MAX)? PRICE[dst]:-1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219308,
                "title": "bfs-bellman-ford-solution-dfs-dijkstra-s-cannot-ac",
                "content": "\\nIt\\'s 2021 now, but most of the highest-voted posts were written in 2018/2019. They discussed about BFS, DFS, Dijkstra\\'s, and Bellman-Ford. However, I find that (probably because LeetCode added more restrictive testcases), currenly only BFS and Bellman-Ford passes the test (I only verified this in C++). Nevertheless, in this post, we will discuss DFS, BFS, Dijkstra\\'s and Bellman-Ford.\\n\\n\\n\\n## BFS & DFS (TLE)\\n\\nWalk for at most k steps from `src` and report the price if`dst` is reached. Note that:\\n\\n- a node can be traversed more than once, as a path with more nodes can have shorter cost;\\n- Do early pruning by checking if `currPrice + price > minPrice`. This avoid infinite loops (but might traverse a loop multiple times).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // BFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n        \\n        int minPrice = INT_MAX;\\n        queue<pair<int, int>> q({{src, 0}});\\n        for (int i = 0; i <= k+1 && !q.empty(); ++i) {\\n            int len = q.size();\\n            while (len-- > 0) {\\n                pair<int, int> p = q.front(); q.pop();\\n                int curr = p.first, currPrice = p.second;\\n                if (curr == dst) {\\n                    minPrice = min(minPrice, currPrice);\\n                    continue;\\n                }\\n\\n                for (pair<int, int>& nextP : F[curr]) {\\n                    int next = nextP.first, price = nextP.second;\\n                \\n                    if (currPrice+price > minPrice) // pruning\\n                        continue;\\n\\n                    minPrices[next] = currPrice+price;\\n                    q.push({next, price+currPrice});\\n                }\\n            }\\n        }\\n        return minPrice == INT_MAX ? -1 : minPrice;\\n    }\\n};\\n```\\n\\n\\n\\nThe DFS solution is almost the same, except that when backtracking, use `visited` to avoid loops (each loop traversed at most once).\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // DFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n    \\n        int res = INT_MAX;\\n        vector<int> visited(n, false);\\n        visited[src] = true;\\n        dfs(F, visited, src, dst, k+1, 0, res);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n    void dfs(unordered_map<int, vector<pair<int, int>>>& F, vector<int>& visited, \\n             int src, int dst, int k, int currPrice, int& res) {\\n        if (src == dst) {\\n            res = min(res, currPrice);\\n            return;\\n        }\\n        if (k == 0) {\\n            return;\\n        }\\n\\n        for (auto p : F[src]) {\\n            auto [next, price] = p;\\n            if (visited[next] || currPrice+price > res) // pruning\\n                continue;\\n\\n            visited[next] = true;\\n            dfs(F, visited, next, dst, k-1, currPrice+price, res);\\n            visited[next] = false;\\n        }\\n    }\\n};\\n```\\n\\nHowever, both approaches above fail for TLE on LeetCode.\\n\\n\\n\\n\\n\\n## BFS with more aggressive pruning (AC)\\n\\nCan we prune more with BFS? Yes, `currPrice + price > minPrice` in the previous BFS solution might take several rounds in a loop before stopping, can we do better?\\n\\nYes. Whenever a node is traversed, remeber the min cost taken to reach the node. If the current cost at `u` is greater than the previous cost, then there\\'s no point continuing. Here\\'s the reason:\\n\\n- In BFS, a later traversal to `u` means the current path is longer than previous path;\\n- It\\'s possible for a later traversal (i.e., a path with more nodes on it) to have shorter cost, and this is the path we must consider;\\n- However, if a later traversal (i.e. a path with more nodes on it) has larger cost than previous path, just stop.\\n\\nBased on this idea, we have the following code:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // BFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n        \\n        unordered_map<int, int> minPrices; \\n        int minPrice = INT_MAX;\\n        queue<pair<int, int>> q({{src, 0}});\\n        for (int i = 0; i <= k+1 && !q.empty(); ++i) {\\n            int len = q.size();\\n            while (len-- > 0) {\\n                pair<int, int> p = q.front(); q.pop();\\n                int curr = p.first, currPrice = p.second;\\n                if (curr == dst) {\\n                    minPrice = min(minPrice, currPrice);\\n                    continue;\\n                }\\n\\n                for (pair<int, int>& nextP : F[curr]) {\\n                    int next = nextP.first, price = nextP.second;\\n                \\n                    // [Important] BFS early stop\\n                    // A node can be traversed more than once, because a path with more steps might have smaller cost;\\n                    // However, if a path with more steps have larger cost, there is no point continuing.\\n                    if (minPrices.count(next) > 0 && minPrices[next] < currPrice+price)\\n                        continue;\\n\\n                    minPrices[next] = currPrice+price;\\n                    q.push({next, price+currPrice});\\n                }\\n            }\\n        }\\n        return minPrice == INT_MAX ? -1 : minPrice;\\n    }\\n}\\n```\\n\\nIt\\'s not easy to implement the same idea with DFS: an earlier, unsuccessful traversal needs to clear the entries it filled in `minPrices`, but it\\'s not straightforward to do that.\\n\\n\\n\\n## Dijkstra\\'s Algorithm (TLE)\\n\\nAlgorithm: [Wiki](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Dijkstra\\'s algorithm\\n        typedef tuple<int,int,int> ti;\\n\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n\\n        priority_queue<ti, vector<ti>, greater<ti>> pq; // <cost, node, steps>\\n        pq.push({0, src, k+1});\\n        while (!pq.empty()) {\\n            auto [currPrice, node, k] = pq.top(); pq.pop();\\n            if (node == dst) return currPrice;\\n            if (k == 0) continue;\\n            for (auto [next, price] : F[node]) {\\n                pq.push({currPrice+price, next, k-1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThe idea is similar to Dijkstra\\'s algorithm. But note that we are not using `visited` to avoid revisiting a node, and not using `minDistances` to remeber the minimum distance to each node. Reason: the restriction of `k` stops. The final result might not be the shortest path - we might need to pick a path with fewer stops but higher cost.\\n\\nDijkstra\\'s algorithm timeouts on LeetCode.\\n\\nDetailed explanation on Dijkstra\\'s algorithm implementation: [link](https://leetcode.com/problems/path-with-maximum-probability/discuss/732293/Dijkstra\\'s-algorithm-implementation-C%2B%2B).\\n\\n\\n\\n## Bellman-Ford (AC)\\n\\nAlgorithm: [Wiki](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm)\\n\\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Bellman Ford\\n        vector<int> dp(n, INT_MAX);\\n        dp[src] = 0;\\n        for (int i = 0; i < k+1; ++i) {\\n            vector<int> temp = dp;\\n            for (vector<int>& f : flights) {\\n                int u = f[0], v = f[1], price = f[2];\\n                if (temp[u] == INT_MAX) continue;\\n                dp[v] = min(dp[v], temp[u]+price); \\n            }\\n        }\\n        return dp[dst] == INT_MAX ? -1 : dp[dst];\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n## Note\\n\\nThe complexity of Dijkstra\\'s algorithm is O(VlogV), while the complexity of Bellman-Ford is O(VE). Why Dijkstra\\'s TLE but Bellman-Ford AC? Actually, we implement different from the original Dijkstra\\'s, so the complexity is actually higher. \\n\\nTODO: Time complexity analysis.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // BFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n        \\n        int minPrice = INT_MAX;\\n        queue<pair<int, int>> q({{src, 0}});\\n        for (int i = 0; i <= k+1 && !q.empty(); ++i) {\\n            int len = q.size();\\n            while (len-- > 0) {\\n                pair<int, int> p = q.front(); q.pop();\\n                int curr = p.first, currPrice = p.second;\\n                if (curr == dst) {\\n                    minPrice = min(minPrice, currPrice);\\n                    continue;\\n                }\\n\\n                for (pair<int, int>& nextP : F[curr]) {\\n                    int next = nextP.first, price = nextP.second;\\n                \\n                    if (currPrice+price > minPrice) // pruning\\n                        continue;\\n\\n                    minPrices[next] = currPrice+price;\\n                    q.push({next, price+currPrice});\\n                }\\n            }\\n        }\\n        return minPrice == INT_MAX ? -1 : minPrice;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // DFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n    \\n        int res = INT_MAX;\\n        vector<int> visited(n, false);\\n        visited[src] = true;\\n        dfs(F, visited, src, dst, k+1, 0, res);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n\\n    void dfs(unordered_map<int, vector<pair<int, int>>>& F, vector<int>& visited, \\n             int src, int dst, int k, int currPrice, int& res) {\\n        if (src == dst) {\\n            res = min(res, currPrice);\\n            return;\\n        }\\n        if (k == 0) {\\n            return;\\n        }\\n\\n        for (auto p : F[src]) {\\n            auto [next, price] = p;\\n            if (visited[next] || currPrice+price > res) // pruning\\n                continue;\\n\\n            visited[next] = true;\\n            dfs(F, visited, next, dst, k-1, currPrice+price, res);\\n            visited[next] = false;\\n        }\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // BFS\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n        \\n        unordered_map<int, int> minPrices; \\n        int minPrice = INT_MAX;\\n        queue<pair<int, int>> q({{src, 0}});\\n        for (int i = 0; i <= k+1 && !q.empty(); ++i) {\\n            int len = q.size();\\n            while (len-- > 0) {\\n                pair<int, int> p = q.front(); q.pop();\\n                int curr = p.first, currPrice = p.second;\\n                if (curr == dst) {\\n                    minPrice = min(minPrice, currPrice);\\n                    continue;\\n                }\\n\\n                for (pair<int, int>& nextP : F[curr]) {\\n                    int next = nextP.first, price = nextP.second;\\n                \\n                    // [Important] BFS early stop\\n                    // A node can be traversed more than once, because a path with more steps might have smaller cost;\\n                    // However, if a path with more steps have larger cost, there is no point continuing.\\n                    if (minPrices.count(next) > 0 && minPrices[next] < currPrice+price)\\n                        continue;\\n\\n                    minPrices[next] = currPrice+price;\\n                    q.push({next, price+currPrice});\\n                }\\n            }\\n        }\\n        return minPrice == INT_MAX ? -1 : minPrice;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Dijkstra\\'s algorithm\\n        typedef tuple<int,int,int> ti;\\n\\n        unordered_map<int, vector<pair<int, int>>> F;\\n        for (vector<int>& f : flights)\\n            F[f[0]].push_back({f[1], f[2]});\\n\\n        priority_queue<ti, vector<ti>, greater<ti>> pq; // <cost, node, steps>\\n        pq.push({0, src, k+1});\\n        while (!pq.empty()) {\\n            auto [currPrice, node, k] = pq.top(); pq.pop();\\n            if (node == dst) return currPrice;\\n            if (k == 0) continue;\\n            for (auto [next, price] : F[node]) {\\n                pq.push({currPrice+price, next, k-1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // Bellman Ford\\n        vector<int> dp(n, INT_MAX);\\n        dp[src] = 0;\\n        for (int i = 0; i < k+1; ++i) {\\n            vector<int> temp = dp;\\n            for (vector<int>& f : flights) {\\n                int u = f[0], v = f[1], price = f[2];\\n                if (temp[u] == INT_MAX) continue;\\n                dp[v] = min(dp[v], temp[u]+price); \\n            }\\n        }\\n        return dp[dst] == INT_MAX ? -1 : dp[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195431,
                "title": "most-voted-priorityqueue-solution-getting-timing-out",
                "content": "The priority queue solution provided in most voted post is getting TLE for below use-case.\\n\\n```\\n13\\n[[11,12,74],[1,8,91],[4,6,13],[7,6,39],[5,12,8],[0,12,54],[8,4,32],[0,11,4],[4,0,91],[11,7,64],[6,3,88],[8,5,80],[11,10,91],[10,0,60],[8,7,92],[12,6,78],[6,2,8],[4,3,54],[3,11,76],[3,12,23],[11,6,79],[6,12,36],[2,11,100],[2,5,49],[7,0,17],[5,8,95],[3,9,98],[8,10,61],[2,12,38],[5,7,58],[9,4,37],[8,6,79],[9,0,1],[2,3,12],[7,10,7],[12,10,52],[7,2,68],[12,2,100],[6,9,53],[7,4,90],[0,5,43],[11,2,52],[11,8,50],[12,4,38],[7,9,94],[2,7,38],[3,7,88],[9,12,20],[12,0,26],[10,5,38],[12,8,50],[0,2,77],[11,0,13],[9,10,76],[2,6,67],[5,6,34],[9,7,62],[5,3,67]]\\n10\\n1\\n10\\n```\\n\\nCode\\n\\n```\\n Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] f:flights)\\n        {\\n            map.putIfAbsent(f[0],new ArrayList<>());\\n            map.get(f[0]).add(new int[]{f[1],f[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0],o2[0]);\\n            }\\n        });\\n        q.offer(new int[]{0,src,K+1});\\n        while(!q.isEmpty())\\n        {\\n            int[] c=q.poll();\\n            int cost=c[0];\\n            int curr=c[1];\\n            int stop=c[2];\\n            if(curr==dst)\\n                return cost;\\n            if(stop>0)\\n            {\\n                if(!map.containsKey(curr))\\n                    continue;\\n                for(int[] next:map.get(curr))\\n                {\\n                    q.add(new int[]{cost+next[1],next[0],stop-1});\\n                }\\n            }\\n        }\\n        return -1;\\n```",
                "solutionTags": [],
                "code": "```\\n13\\n[[11,12,74],[1,8,91],[4,6,13],[7,6,39],[5,12,8],[0,12,54],[8,4,32],[0,11,4],[4,0,91],[11,7,64],[6,3,88],[8,5,80],[11,10,91],[10,0,60],[8,7,92],[12,6,78],[6,2,8],[4,3,54],[3,11,76],[3,12,23],[11,6,79],[6,12,36],[2,11,100],[2,5,49],[7,0,17],[5,8,95],[3,9,98],[8,10,61],[2,12,38],[5,7,58],[9,4,37],[8,6,79],[9,0,1],[2,3,12],[7,10,7],[12,10,52],[7,2,68],[12,2,100],[6,9,53],[7,4,90],[0,5,43],[11,2,52],[11,8,50],[12,4,38],[7,9,94],[2,7,38],[3,7,88],[9,12,20],[12,0,26],[10,5,38],[12,8,50],[0,2,77],[11,0,13],[9,10,76],[2,6,67],[5,6,34],[9,7,62],[5,3,67]]\\n10\\n1\\n10\\n```\n```\\n Map<Integer,List<int[]>> map=new HashMap<>();\\n        for(int[] f:flights)\\n        {\\n            map.putIfAbsent(f[0],new ArrayList<>());\\n            map.get(f[0]).add(new int[]{f[1],f[2]});\\n        }\\n        PriorityQueue<int[]> q=new PriorityQueue<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return Integer.compare(o1[0],o2[0]);\\n            }\\n        });\\n        q.offer(new int[]{0,src,K+1});\\n        while(!q.isEmpty())\\n        {\\n            int[] c=q.poll();\\n            int cost=c[0];\\n            int curr=c[1];\\n            int stop=c[2];\\n            if(curr==dst)\\n                return cost;\\n            if(stop>0)\\n            {\\n                if(!map.containsKey(curr))\\n                    continue;\\n                for(int[] next:map.get(curr))\\n                {\\n                    q.add(new int[]{cost+next[1],next[0],stop-1});\\n                }\\n            }\\n        }\\n        return -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152831,
                "title": "c-explained-dijkstra-algo",
                "content": "Code has been commented below:\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        vector<vector<pair<int,int>>> adj(n);\\n //create a directed weighted graph from given edges in flights       \\n        for(int i=0;i<flights.size();i++){\\n           adj[flights[i][0]].push_back({flights[i][2], flights[i][1]}); \\n        }\\n        \\n//we use priority queue in ascending order of weights to process vertices\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> q;\\n\\n//push the start vertex \"src\" with weight 0 as a node is connected to itself no weight\\n//needed and the steps k+1, we use k+1 instead of k bcoz if we can visit k nodes as a stop\\n// it means we can visit k+1 edges\\n        \\n        q.push({0,{src, K+1}});\\n        \\n//Loop until q is not empty\\n        while(!q.empty()){\\n            auto node = q.top(); //get the front element with samllest weight in q\\n            q.pop();    ///remove the processed pair\\n            \\n            int cost = node.first;  //weight or cost of currently popped pair\\n            int v = node.second.first;  //the vertex\\n            int steps_left = node.second.second; //steps left currenlty\\n            \\n    //if steps_left becomes <0 this means we have exceeded the number of stops allowed from src to dst\\n            if(steps_left<0)continue;\\n//else if w have reached the dst return the cost of that path\\n            if(dst == v)return cost;\\n//Nowe we loop all the neighbour of vertex v above and add the cost of visiting and also\\n//reduce the steps_left and then push it in priority_queue to be processes further\\n            for(auto temp: adj[v]){\\n                int cost_to = temp.first;\\n              int to = temp.second;\\n                \\n                q.push({cost+cost_to, {to,steps_left-1}});\\n            }\\n            \\n        }\\n//if at last we are unable to reach dst from ource with given number of stops then return -1\\n       return -1;\\n    }\\n};\\n```\\n**Do upvote if explanation was useful & you liked the code :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        \\n        vector<vector<pair<int,int>>> adj(n);\\n //create a directed weighted graph from given edges in flights       \\n        for(int i=0;i<flights.size();i++){\\n           adj[flights[i][0]].push_back({flights[i][2], flights[i][1]}); \\n        }\\n        \\n//we use priority queue in ascending order of weights to process vertices\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> q;\\n\\n//push the start vertex \"src\" with weight 0 as a node is connected to itself no weight\\n//needed and the steps k+1, we use k+1 instead of k bcoz if we can visit k nodes as a stop\\n// it means we can visit k+1 edges\\n        \\n        q.push({0,{src, K+1}});\\n        \\n//Loop until q is not empty\\n        while(!q.empty()){\\n            auto node = q.top(); //get the front element with samllest weight in q\\n            q.pop();    ///remove the processed pair\\n            \\n            int cost = node.first;  //weight or cost of currently popped pair\\n            int v = node.second.first;  //the vertex\\n            int steps_left = node.second.second; //steps left currenlty\\n            \\n    //if steps_left becomes <0 this means we have exceeded the number of stops allowed from src to dst\\n            if(steps_left<0)continue;\\n//else if w have reached the dst return the cost of that path\\n            if(dst == v)return cost;\\n//Nowe we loop all the neighbour of vertex v above and add the cost of visiting and also\\n//reduce the steps_left and then push it in priority_queue to be processes further\\n            for(auto temp: adj[v]){\\n                int cost_to = temp.first;\\n              int to = temp.second;\\n                \\n                q.push({cost+cost_to, {to,steps_left-1}});\\n            }\\n            \\n        }\\n//if at last we are unable to reach dst from ource with given number of stops then return -1\\n       return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 915497,
                "title": "beat-99-2-c-solution-very-easy-to-understand-if-you-know-dijkstra-s-algorithm",
                "content": "Here is Dijkstra\\'s Algorithm\\n\\n```\\n    void dijkastra(vector<vector<pair<int,int>>> &graph) { \\n        int n = graph.size();\\n        vector<int> cost(n, INT_MAX); \\n        vector<int> parent(n, -1); \\n        vector<bool> visited(n, false); \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; \\n\\n        int src = 0; \\n        pq.push(make_pair(0, src)); \\n        cost[src] = 0; \\n\\n        while (!pq.empty()) { \\n            int u = pq.top().second; \\n            pq.pop(); \\n\\n            if (visited[u]) {\\n                continue;\\n            }\\n            visited[u] = true; \\n\\n            for (auto &[v, weight] : graph[u]) {\\n                if (visited[v]) {\\n                    continue;\\n                }\\n                int cost0 = cost[u] + weight;\\n                if (cost[v] > cost0) {\\n                    cost[v] = cost0; \\n                    pq.push(make_pair(cost[v], v)); \\n                    parent[v] = u; \\n                } \\n            } \\n        } \\n    } \\n\\n```\\n\\nHere is the solution similar to Dijkstra:\\n\\nTime Complexity: O(dV log(dV)) where d is the max in degree of a node. a node can be put in the heap at most d times. \\nSpace Complexity: O(dV) for the heap. O(E+V) for the graph. So O(dV) in total.\\n\\nAny better analysis?\\n\\n\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int, int> > > graph(n);\\n        for (auto & f : flights) {\\n            graph[f[0]].push_back({f[1], f[2]});\\n        }\\n        \\n        typedef tuple<int, int, int> Type;\\n        priority_queue<Type, vector<Type>, std::greater<Type>> que;\\n        vector<pair<int, int> > cost(n, {INT_MAX, INT_MAX}); //dist, k\\n  \\n        que.emplace(0, -1, src);        \\n        while(que.size()) {\\n            auto [dist, cur_k, cur] = que.top();\\n            que.pop();\\n            \\n            if (cur == dst && cur_k <= K) {\\n                return dist;\\n            }\\n            if (cur_k >= K) {\\n                continue;\\n            }\\n            \\n            // similar to check visited\\n            if (dist >= cost[cur].first && cur_k >= cost[cur].second) {\\n                continue;\\n            }\\n            // similar to update visited\\n            if (dist <= cost[cur].first && cur_k <= cost[cur].second) {\\n                cost[cur] = {dist, cur_k};\\n            }\\n            \\n            for (auto [ne, edge] : graph[cur]) {\\n                int dist0 = dist + edge;\\n                // similar to check visited\\n                if (dist0 < cost[ne].first || cur_k + 1 < cost[ne].second) {\\n                    que.emplace(dist0, cur_k + 1, ne);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\nYou can remove checking visited. However, it\\'s significantly slower because of more nodes in heap:\\n\\n```\\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int, int> > > graph(n);\\n        for (auto & f : flights) {\\n            graph[f[0]].push_back({f[1], f[2]});\\n        }\\n        \\n        typedef tuple<int, int, int> Type;\\n        priority_queue<Type, vector<Type>, std::greater<Type>> que;\\n  \\n        que.emplace(0, -1, src);        \\n        while(que.size()) {\\n            auto [dist, cur_k, cur] = que.top();\\n            que.pop();\\n            \\n            if (cur == dst && cur_k <= K) {\\n                return dist;\\n            }\\n            if (cur_k >= K) {\\n                continue;\\n            }\\n            \\n            for (auto [ne, edge] : graph[cur]) {\\n                int dist0 = dist + edge;\\n                que.emplace(dist0, cur_k + 1, ne);\\n            }\\n        }\\n        return -1;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void dijkastra(vector<vector<pair<int,int>>> &graph) { \\n        int n = graph.size();\\n        vector<int> cost(n, INT_MAX); \\n        vector<int> parent(n, -1); \\n        vector<bool> visited(n, false); \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq; \\n\\n        int src = 0; \\n        pq.push(make_pair(0, src)); \\n        cost[src] = 0; \\n\\n        while (!pq.empty()) { \\n            int u = pq.top().second; \\n            pq.pop(); \\n\\n            if (visited[u]) {\\n                continue;\\n            }\\n            visited[u] = true; \\n\\n            for (auto &[v, weight] : graph[u]) {\\n                if (visited[v]) {\\n                    continue;\\n                }\\n                int cost0 = cost[u] + weight;\\n                if (cost[v] > cost0) {\\n                    cost[v] = cost0; \\n                    pq.push(make_pair(cost[v], v)); \\n                    parent[v] = u; \\n                } \\n            } \\n        } \\n    } \\n\\n```\n```\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {\\n        vector<vector<pair<int, int> > > graph(n);\\n        for (auto & f : flights) {\\n            graph[f[0]].push_back({f[1], f[2]});\\n        }\\n        \\n        typedef tuple<int, int, int> Type;\\n        priority_queue<Type, vector<Type>, std::greater<Type>> que;\\n        vector<pair<int, int> > cost(n, {INT_MAX, INT_MAX}); //dist, k\\n  \\n        que.emplace(0, -1, src);        \\n        while(que.size()) {\\n            auto [dist, cur_k, cur] = que.top();\\n            que.pop();\\n            \\n            if (cur == dst && cur_k <= K) {\\n                return dist;\\n            }\\n            if (cur_k >= K) {\\n                continue;\\n            }\\n            \\n            // similar to check visited\\n            if (dist >= cost[cur].first && cur_k >= cost[cur].second) {\\n                continue;\\n            }\\n            // similar to update visited\\n            if (dist <= cost[cur].first && cur_k <= cost[cur].second) {\\n                cost[cur] = {dist, cur_k};\\n            }\\n            \\n            for (auto [ne, edge] : graph[cur]) {\\n                int dist0 = dist + edge;\\n                // similar to check visited\\n                if (dist0 < cost[ne].first || cur_k + 1 < cost[ne].second) {\\n                    que.emplace(dist0, cur_k + 1, ne);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 707448,
                "title": "c-3-approaches-top-down-dp-dijkstra-s-algorithm-bellman-ford-algorithm",
                "content": "***Approach1-TOP DOWN DP***\\n```\\nclass Solution {\\npublic:\\n    int getCheapFlight(vector<vector<pair<int,int>>> &adjL, int src, int &dst, int K, vector<vector<int>> &dp){        \\n        if(src==dst)\\n            return 0;\\n        if(K<0)\\n            return -1;\\n        if(dp[src][K]){            \\n            return dp[src][K];\\n        }\\n        \\n        int minCost=INT_MAX;\\n        for(auto x:adjL[src]){            \\n                int cost = getCheapFlight(adjL, x.first, dst, K-1, dp);    \\n                if(cost!=-1)\\n                    minCost = min(minCost,cost+x.second);            \\n        }\\n        if(minCost==INT_MAX)\\n            dp[src][K] = -1;\\n        else\\n            dp[src][K] = minCost;\\n        return dp[src][K];\\n    }\\n\\t\\n\\tint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) { \\n        vector<vector<pair<int,int>>> adjL(n);                \\n        for(auto x:flights){            \\n            adjL[x[0]].push_back({x[1],x[2]});\\n        }\\n        \\n        int cost = getCheapFlight(adjL, src, dst, K, dp);\\n        if(cost==0)\\n            return -1;\\n        return cost;\\n    }\\n}\\n```\\n\\n***Approach2- Dijkstra algorithm***\\n```\\ntypedef tuple<int,int,int> tupl;\\n\\nvector<vector<pair<int,int>>> adjL(n);                \\n        for(auto x:flights){            \\n            adjL[x[0]].push_back({x[1],x[2]});\\n        }\\n\\t\\t\\npriority_queue<tupl, vector<tupl>, greater<tupl>> pq;        \\n        pq.push({0,src,K});\\n        int cost=0;\\n        if(src==dst) return 0;            \\n        while(!pq.empty()){                               \\n            tupl t = pq.top();\\n            pq.pop();            \\n            int cc = get<0>(t);\\n            int vert = get<1>(t);\\n            int newk = get<2>(t);            \\n            if(vert==dst){                    \\n                return cc;\\n            }\\n            if(newk>=0){\\n                for(auto x:adjL[vert]){                                                        \\n                    pq.push({cc+x.second, x.first, newk-1});\\n                }\\n            }                                    \\n        }\\n        return -1;\\n```\\n\\n***Approach3-Bellman Ford***\\n```\\n vector<int> prev(n+1,INT_MAX);\\n        prev[src]=0;\\n        for(int i=0;i<=K;i++){\\n            vector<int> curr(prev);\\n            \\n            for(int i=0;i<flights.size();i++){\\n                int s = flights[i][0];\\n                int d = flights[i][1];\\n                int w = flights[i][2];\\n                if(prev[s]!=INT_MAX && (prev[s]+w)<curr[d]){\\n                    curr[d] = prev[s]+w;\\n                }                                \\n            }\\n            prev=curr;\\n        }\\n        if(prev[dst]==INT_MAX) return -1;\\n        return prev[dst];\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCheapFlight(vector<vector<pair<int,int>>> &adjL, int src, int &dst, int K, vector<vector<int>> &dp){        \\n        if(src==dst)\\n            return 0;\\n        if(K<0)\\n            return -1;\\n        if(dp[src][K]){            \\n            return dp[src][K];\\n        }\\n        \\n        int minCost=INT_MAX;\\n        for(auto x:adjL[src]){            \\n                int cost = getCheapFlight(adjL, x.first, dst, K-1, dp);    \\n                if(cost!=-1)\\n                    minCost = min(minCost,cost+x.second);            \\n        }\\n        if(minCost==INT_MAX)\\n            dp[src][K] = -1;\\n        else\\n            dp[src][K] = minCost;\\n        return dp[src][K];\\n    }\\n\\t\\n\\tint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) { \\n        vector<vector<pair<int,int>>> adjL(n);                \\n        for(auto x:flights){            \\n            adjL[x[0]].push_back({x[1],x[2]});\\n        }\\n        \\n        int cost = getCheapFlight(adjL, src, dst, K, dp);\\n        if(cost==0)\\n            return -1;\\n        return cost;\\n    }\\n}\\n```\n```\\ntypedef tuple<int,int,int> tupl;\\n\\nvector<vector<pair<int,int>>> adjL(n);                \\n        for(auto x:flights){            \\n            adjL[x[0]].push_back({x[1],x[2]});\\n        }\\n\\t\\t\\npriority_queue<tupl, vector<tupl>, greater<tupl>> pq;        \\n        pq.push({0,src,K});\\n        int cost=0;\\n        if(src==dst) return 0;            \\n        while(!pq.empty()){                               \\n            tupl t = pq.top();\\n            pq.pop();            \\n            int cc = get<0>(t);\\n            int vert = get<1>(t);\\n            int newk = get<2>(t);            \\n            if(vert==dst){                    \\n                return cc;\\n            }\\n            if(newk>=0){\\n                for(auto x:adjL[vert]){                                                        \\n                    pq.push({cc+x.second, x.first, newk-1});\\n                }\\n            }                                    \\n        }\\n        return -1;\\n```\n```\\n vector<int> prev(n+1,INT_MAX);\\n        prev[src]=0;\\n        for(int i=0;i<=K;i++){\\n            vector<int> curr(prev);\\n            \\n            for(int i=0;i<flights.size();i++){\\n                int s = flights[i][0];\\n                int d = flights[i][1];\\n                int w = flights[i][2];\\n                if(prev[s]!=INT_MAX && (prev[s]+w)<curr[d]){\\n                    curr[d] = prev[s]+w;\\n                }                                \\n            }\\n            prev=curr;\\n        }\\n        if(prev[dst]==INT_MAX) return -1;\\n        return prev[dst];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690997,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Perform Bellman-Ford to build current `cur` minimum distances from previous `pre` minimum distances via `K + 1` edge relaxations for the single-source-shortest-paths for `K` hops to find the minimum distance from source `S` to target `T` (if it exists), ie. we use the past to formulate the future.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun findCheapestPrice(N: Int, E: Array<IntArray>, S: Int, T: Int, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var pre = IntArray(N) { INF }; pre[S] = 0\\n        for (i in 0..K) {\\n            var cur = pre.copyOf()\\n            for ((u, v, w) in E)\\n                cur[v] = Math.min(cur[v], pre[u] + w)\\n            pre = cur\\n        }\\n        return if (pre[T] != INF) pre[T] else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, S, T, K) => {\\n    let pre = Array(N).fill(Infinity); pre[S] = 0;\\n    while (0 <= K--) {\\n        let cur = [...pre];\\n        for (let [u, v, w] of E)\\n            cur[v] = Math.min(cur[v], pre[u] + w);\\n        pre = cur;\\n    }\\n    return pre[T] != Infinity ? pre[T] : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def findCheapestPrice(self, N: int, E: List[List[int]], S: int, T: int, K: int, INF = int(1e9 + 7)) -> int:\\n        pre = [INF] * N; pre[S] = 0\\n        for _ in range(K + 1):\\n            cur = pre[:]\\n            for u, v, w in E:\\n                cur[v] = min(cur[v], pre[u] + w)\\n            pre = cur\\n        return pre[T] if pre[T] != INF else -1\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn find_cheapest_price(N: i32, E: VVI, S: i32, T: i32, K: i32) -> i32 {\\n        let (N, S, T) = (N as usize, S as usize, T as usize);\\n        let INF = 1e9 as i32 + 7;\\n        let mut pre = vec![INF; N]; pre[S] = 0;\\n        for _ in 0..=K {\\n            let mut cur = pre.clone();\\n            for edge in &E {\\n                let (u, v, w) = (edge[0] as usize, edge[1] as usize, edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w);\\n            }\\n            pre = cur;\\n        }\\n        if pre[T] != INF { pre[T] } else { -1 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findCheapestPrice(int N, VVI& E, int S, int T, int K, int INF = 1e9 + 7) {\\n        VI pre(N, INF); pre[S] = 0;\\n        while (0 <= K--) {\\n            VI cur{ pre };\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[T] != INF ? pre[T] : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Past solutions from October 2, 2020**\\n\\n**Solution #1:**\\n\\nPerform DFS + BT to find the minimum `cost` from `start` to target `T`.  The `cost` of each DFS path explored is accumulated as the recursive stack approaches the base cases.\\n\\n* **Base Cases:**\\n\\t* *Case 1:* we reached the target `T`, thus the minimum `cost` is recorded as the `best`\\n\\t* *Case 2:* all `k` hops are exhausted, simply `return` to allow the recursive stack to unwind and backtrack to the next DFS path to recursively explore.\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (_, E, start, T, hops, adj = new Map(), best = Infinity) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, cost = 0, seen = new Set()) => {\\n        if (u == T)\\n            best = Math.min(best, cost); // best is the minimum cost \\uD83C\\uDFAF\\n        if (u == T || !k)\\n            return; // destination reached or k-hops exhausted: stop \\uD83D\\uDED1\\n        seen.add(u); // \\uD83D\\uDC40 \\u2705 forward-tracking\\n        for (let [v, w] of [...adj.get(u) || []])\\n            if (!seen.has(v) && cost + w < best) // pruning condition: cost + w < best \\uD83E\\uDD14\\n                go(v, k - 1, cost + w, seen);\\n        seen.delete(u); // \\uD83D\\uDC40 \\u274C back-tracking\\n    };\\n    go();\\n    return best < Infinity ? best : -1;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>;\\n    Adj adj;\\n    int T, best;\\n    void go(int u, int k, int cost = 0, Set&& seen = {}) {\\n        if (u == T)\\n            best = min(best, cost); // best is the minimum cost \\uD83C\\uDFAF\\n        if (u == T || !k)\\n            return; // target T destination reached or k-hops exhausted: stop \\uD83D\\uDED1\\n        seen.insert(u); // \\uD83D\\uDC40 \\u2705 forward-tracking\\n        for (auto [v, w]: adj[u])\\n            if (seen.find(v) == seen.end() && cost + w < best) // pruning condition: cost + w < best \\uD83E\\uDD14\\n                go(v, k - 1, cost + w, move(seen));\\n        seen.erase(u); // \\uD83D\\uDC40 \\u274C back-tracking\\n    }\\npublic:\\n    int findCheapestPrice(int _, VVI& E, int start, int T_, int hops, int INF = int(1e9 + 7)) {\\n        T = T_;\\n        best = INF;\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        go(start, hops + 1);\\n        return best < INF ? best : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #2:**\\n\\nAn astute observer will notice its obviously silly to perform DFS + BT.  Solution #1 is so very inefficient that a pruning condition is necessary to avoid TLE.  An improved DFS solution simply uses memoization to store previously solved sub-problems (ie. use dynamic programming).  The cost `w` of each edge (`u`,`v`) is accumulated as the recursive stack unwinds, and each sub-problem\\'s optimal solution is stored in the memo `m`.\\n\\n**Summary:**\\n\\n[\\uD83C\\uDFA8 The **ART** of dynamic programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via brute-force top-down depth-first-search\\n2. **R**emember each subproblems\\' optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    let m = [...Array(N)].map(_ => Array(hops + 2).fill(-1)); // +2 because for V vertices there are V+1 edges and +1 for the memo itself to be 0..hops+1 inclusive\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, min = Infinity) => {\\n        if (m[u][k] > -1)\\n            return m[u][k]; // memo \\uD83E\\uDD14\\n        if (u == T)\\n            return m[u][k] = 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return m[u][k] = Infinity; // all k hops exhausted \\u274C\\n        for (let [v, w] of [...adj.get(u) || []])\\n            min = Math.min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return m[u][k] = min;\\n    };\\n    return go() < Infinity ? go() : -1;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>; // u -> [v, w] == edge u -> v with cost w\\n    Adj adj;\\n    int T;\\n    VVI m;\\n    static constexpr auto INF = int(1e9 + 7);\\n    int go(int u, int k, int min = INF) {\\n        if (m[u][k] > -1)\\n            return m[u][k]; // memo \\uD83E\\uDD14\\n        if (u == T)\\n            return m[u][k] = 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return m[u][k] = INF; // all k hops exhausted \\u274C\\n        for (auto [v, w]: adj[u])\\n            min = std::min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return m[u][k] = min;\\n    }\\npublic:\\n    int findCheapestPrice(int N, VVI& E, int start, int T_, int hops) {\\n        T = T_;\\n        m = VVI(N, VI(hops + 2, -1)); // +2 because for V vertices there are V+1 edges and +1 for the memo itself to be 0..hops+1 inclusive\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto ans = go(start, hops + 1);\\n        return ans < INF ? ans : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #2 - Supplemental:** it may be easier to understand this DFS algorithm without the memo.  The memo might make this solution look scary at first glance, however, this solution is fundamentally simple and concise.\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, min = Infinity) => {\\n        if (u == T)\\n            return 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return Infinity; // all k hops exhausted \\u274C\\n        for (let [v, w] of [...adj.get(u) || []])\\n            min = Math.min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return min;\\n    };\\n    return go() < Infinity ? go() : -1;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>; // u -> [v, w] == edge u -> v with cost w\\n    Adj adj;\\n    int T;\\n    static constexpr auto INF = int(1e9 + 7);\\n    int go(int u, int k, int min = INF) {\\n        if (u == T)\\n            return 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return INF; // all k hops exhaused \\u274C\\n        for (auto [v, w]: adj[u])\\n            min = std::min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return min;\\n    }\\npublic:\\n    int findCheapestPrice(int _, VVI& E, int start, int T_, int hops) {\\n        T = T_;\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto ans = go(start, hops + 1);\\n        return ans < INF ? ans : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #3:** Use [Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) to relax edges `u`,`v` of cost `w`\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, start, T, hops) => {\\n    let k = hops + 1;\\n    let pre = Array(N).fill(Infinity);\\n    pre[start] = 0;\\n    while (k--) { // relax all edges k times\\n        // bellman-ford: dist[v] = min(dist[v], dist[u] + w) ie. relax edge u,v of cost w\\n        // however, use previous and current to avoid overwritting our previous optimal edge relaxations\\n        // which we still need to read from in order to derive our current optimal edge relaxations for each k-th hop\\n        let cur = [...pre]; // derive current from previous \\uD83E\\uDD14 ie. update current optimal edge relaxations based upon previous optimal edge relaxations\\n        E.forEach(([u, v, w]) => cur[v] = Math.min(cur[v], pre[u] + w)); // relax all edges u,v of cost w for optimal distance to v \\uD83C\\uDFAF\\n        [pre, cur] = [cur, pre]; // persist current as previous via swap \\uD83E\\uDD14\\n    }\\n    return pre[T] < Infinity ? pre[T] : -1;\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findCheapestPrice(int N, VVI& E, int start, int T, int hops, int INF = int(1e9 + 7)) {\\n        auto k = hops + 1;\\n        VI pre(N, INF);\\n        pre[start] = 0;\\n        while (k--) { // relax all edges k times\\n            // bellman-ford: dist[v] = min(dist[v], dist[u] + w) ie. relax edge u,v of cost w\\n            // however, use previous and current to avoid overwritting our previous optimal edge relaxations\\n            // which we still need to read from in order to derive our current optimal edge relaxations for each k-th hop\\n            auto cur{ pre }; // derive current from previous \\uD83E\\uDD14 ie. update current optimal edge relaxations based upon previous optimal edge relaxations\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w); // relax all edges u,v of cost w for optimal distance to v \\uD83C\\uDFAF\\n            }\\n            swap(pre, cur); // persist current as previous via swap \\uD83E\\uDD14\\n        }\\n        return pre[T] < INF ? pre[T] : -1;\\n    }\\n};\\n```\\n\\n---\\n\\n**Solution #4:** [SPFA](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm) is a natural progression from [Bellman-Ford](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm).  Simply enqueue each current relaxed edge for each next k-th hop of edge relaxations.  And process each k-th hop per queue length.  Thus, we only relax *relevant* edges with SPFA rather than relaxing *all* edges with BF.  Since the code changes from BF to SPFA is straightforward, I\\'ve omitted comments in these solutions.\\n\\n*Javascript*\\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let k = hops + 1;\\n    let pre = Array(N).fill(Infinity);\\n    pre[start] = 0;\\n    let q = [ start ];\\n    while (k--) {\\n        let cur = [...pre];\\n        let len = q.length;\\n        while (len--) {\\n            let u = q.shift();\\n            for (let [v, w] of [...adj.get(u) || []])\\n                if (cur[v] > pre[u] + w)\\n                    cur[v] = pre[u] + w, q.push(v);\\n        }\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[T] < Infinity ? pre[T] : -1;\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>;\\n    int findCheapestPrice(int N, VVI& E, int start, int T, int hops, Adj adj = {}, int INF = int(1e9 + 7)) {\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto k = hops + 1;\\n        VI pre(N, INF);\\n        pre[start] = 0;\\n        queue<int> q{{ start }};\\n        while (k--) {\\n            auto cur{ pre };\\n            int len = q.size();\\n            while (len--) {\\n                auto u = q.front(); q.pop();\\n                for (auto [v, w]: adj[u])\\n                    if (cur[v] > pre[u] + w)\\n                        cur[v] = pre[u] + w, q.push(v);                \\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[T] < INF ? pre[T] : -1;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun findCheapestPrice(N: Int, E: Array<IntArray>, S: Int, T: Int, K: Int, INF: Int = (1e9 + 7).toInt()): Int {\\n        var pre = IntArray(N) { INF }; pre[S] = 0\\n        for (i in 0..K) {\\n            var cur = pre.copyOf()\\n            for ((u, v, w) in E)\\n                cur[v] = Math.min(cur[v], pre[u] + w)\\n            pre = cur\\n        }\\n        return if (pre[T] != INF) pre[T] else -1\\n    }\\n}\\n```\n```\\nlet findCheapestPrice = (N, E, S, T, K) => {\\n    let pre = Array(N).fill(Infinity); pre[S] = 0;\\n    while (0 <= K--) {\\n        let cur = [...pre];\\n        for (let [u, v, w] of E)\\n            cur[v] = Math.min(cur[v], pre[u] + w);\\n        pre = cur;\\n    }\\n    return pre[T] != Infinity ? pre[T] : -1;\\n};\\n```\n```\\nclass Solution:\\n    def findCheapestPrice(self, N: int, E: List[List[int]], S: int, T: int, K: int, INF = int(1e9 + 7)) -> int:\\n        pre = [INF] * N; pre[S] = 0\\n        for _ in range(K + 1):\\n            cur = pre[:]\\n            for u, v, w in E:\\n                cur[v] = min(cur[v], pre[u] + w)\\n            pre = cur\\n        return pre[T] if pre[T] != INF else -1\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn find_cheapest_price(N: i32, E: VVI, S: i32, T: i32, K: i32) -> i32 {\\n        let (N, S, T) = (N as usize, S as usize, T as usize);\\n        let INF = 1e9 as i32 + 7;\\n        let mut pre = vec![INF; N]; pre[S] = 0;\\n        for _ in 0..=K {\\n            let mut cur = pre.clone();\\n            for edge in &E {\\n                let (u, v, w) = (edge[0] as usize, edge[1] as usize, edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w);\\n            }\\n            pre = cur;\\n        }\\n        if pre[T] != INF { pre[T] } else { -1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findCheapestPrice(int N, VVI& E, int S, int T, int K, int INF = 1e9 + 7) {\\n        VI pre(N, INF); pre[S] = 0;\\n        while (0 <= K--) {\\n            VI cur{ pre };\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w);\\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[T] != INF ? pre[T] : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (_, E, start, T, hops, adj = new Map(), best = Infinity) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, cost = 0, seen = new Set()) => {\\n        if (u == T)\\n            best = Math.min(best, cost); // best is the minimum cost \\uD83C\\uDFAF\\n        if (u == T || !k)\\n            return; // destination reached or k-hops exhausted: stop \\uD83D\\uDED1\\n        seen.add(u); // \\uD83D\\uDC40 \\u2705 forward-tracking\\n        for (let [v, w] of [...adj.get(u) || []])\\n            if (!seen.has(v) && cost + w < best) // pruning condition: cost + w < best \\uD83E\\uDD14\\n                go(v, k - 1, cost + w, seen);\\n        seen.delete(u); // \\uD83D\\uDC40 \\u274C back-tracking\\n    };\\n    go();\\n    return best < Infinity ? best : -1;\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Set = unordered_set<int>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>;\\n    Adj adj;\\n    int T, best;\\n    void go(int u, int k, int cost = 0, Set&& seen = {}) {\\n        if (u == T)\\n            best = min(best, cost); // best is the minimum cost \\uD83C\\uDFAF\\n        if (u == T || !k)\\n            return; // target T destination reached or k-hops exhausted: stop \\uD83D\\uDED1\\n        seen.insert(u); // \\uD83D\\uDC40 \\u2705 forward-tracking\\n        for (auto [v, w]: adj[u])\\n            if (seen.find(v) == seen.end() && cost + w < best) // pruning condition: cost + w < best \\uD83E\\uDD14\\n                go(v, k - 1, cost + w, move(seen));\\n        seen.erase(u); // \\uD83D\\uDC40 \\u274C back-tracking\\n    }\\npublic:\\n    int findCheapestPrice(int _, VVI& E, int start, int T_, int hops, int INF = int(1e9 + 7)) {\\n        T = T_;\\n        best = INF;\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        go(start, hops + 1);\\n        return best < INF ? best : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    let m = [...Array(N)].map(_ => Array(hops + 2).fill(-1)); // +2 because for V vertices there are V+1 edges and +1 for the memo itself to be 0..hops+1 inclusive\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, min = Infinity) => {\\n        if (m[u][k] > -1)\\n            return m[u][k]; // memo \\uD83E\\uDD14\\n        if (u == T)\\n            return m[u][k] = 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return m[u][k] = Infinity; // all k hops exhausted \\u274C\\n        for (let [v, w] of [...adj.get(u) || []])\\n            min = Math.min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return m[u][k] = min;\\n    };\\n    return go() < Infinity ? go() : -1;\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>; // u -> [v, w] == edge u -> v with cost w\\n    Adj adj;\\n    int T;\\n    VVI m;\\n    static constexpr auto INF = int(1e9 + 7);\\n    int go(int u, int k, int min = INF) {\\n        if (m[u][k] > -1)\\n            return m[u][k]; // memo \\uD83E\\uDD14\\n        if (u == T)\\n            return m[u][k] = 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return m[u][k] = INF; // all k hops exhausted \\u274C\\n        for (auto [v, w]: adj[u])\\n            min = std::min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return m[u][k] = min;\\n    }\\npublic:\\n    int findCheapestPrice(int N, VVI& E, int start, int T_, int hops) {\\n        T = T_;\\n        m = VVI(N, VI(hops + 2, -1)); // +2 because for V vertices there are V+1 edges and +1 for the memo itself to be 0..hops+1 inclusive\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto ans = go(start, hops + 1);\\n        return ans < INF ? ans : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let go = (u = start, k = hops + 1, min = Infinity) => {\\n        if (u == T)\\n            return 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return Infinity; // all k hops exhausted \\u274C\\n        for (let [v, w] of [...adj.get(u) || []])\\n            min = Math.min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return min;\\n    };\\n    return go() < Infinity ? go() : -1;\\n};\\n```\n```\\nclass Solution {\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>; // u -> [v, w] == edge u -> v with cost w\\n    Adj adj;\\n    int T;\\n    static constexpr auto INF = int(1e9 + 7);\\n    int go(int u, int k, int min = INF) {\\n        if (u == T)\\n            return 0; // target T \\uD83C\\uDFAF\\n        if (!k)\\n            return INF; // all k hops exhaused \\u274C\\n        for (auto [v, w]: adj[u])\\n            min = std::min(min, w + go(v, k - 1)); // dfs edge u -> v with cost w\\n        return min;\\n    }\\npublic:\\n    int findCheapestPrice(int _, VVI& E, int start, int T_, int hops) {\\n        T = T_;\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto ans = go(start, hops + 1);\\n        return ans < INF ? ans : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (N, E, start, T, hops) => {\\n    let k = hops + 1;\\n    let pre = Array(N).fill(Infinity);\\n    pre[start] = 0;\\n    while (k--) { // relax all edges k times\\n        // bellman-ford: dist[v] = min(dist[v], dist[u] + w) ie. relax edge u,v of cost w\\n        // however, use previous and current to avoid overwritting our previous optimal edge relaxations\\n        // which we still need to read from in order to derive our current optimal edge relaxations for each k-th hop\\n        let cur = [...pre]; // derive current from previous \\uD83E\\uDD14 ie. update current optimal edge relaxations based upon previous optimal edge relaxations\\n        E.forEach(([u, v, w]) => cur[v] = Math.min(cur[v], pre[u] + w)); // relax all edges u,v of cost w for optimal distance to v \\uD83C\\uDFAF\\n        [pre, cur] = [cur, pre]; // persist current as previous via swap \\uD83E\\uDD14\\n    }\\n    return pre[T] < Infinity ? pre[T] : -1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int findCheapestPrice(int N, VVI& E, int start, int T, int hops, int INF = int(1e9 + 7)) {\\n        auto k = hops + 1;\\n        VI pre(N, INF);\\n        pre[start] = 0;\\n        while (k--) { // relax all edges k times\\n            // bellman-ford: dist[v] = min(dist[v], dist[u] + w) ie. relax edge u,v of cost w\\n            // however, use previous and current to avoid overwritting our previous optimal edge relaxations\\n            // which we still need to read from in order to derive our current optimal edge relaxations for each k-th hop\\n            auto cur{ pre }; // derive current from previous \\uD83E\\uDD14 ie. update current optimal edge relaxations based upon previous optimal edge relaxations\\n            for (auto& edge: E) {\\n                auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n                cur[v] = min(cur[v], pre[u] + w); // relax all edges u,v of cost w for optimal distance to v \\uD83C\\uDFAF\\n            }\\n            swap(pre, cur); // persist current as previous via swap \\uD83E\\uDD14\\n        }\\n        return pre[T] < INF ? pre[T] : -1;\\n    }\\n};\\n```\n```\\nlet findCheapestPrice = (N, E, start, T, hops, adj = new Map()) => {\\n    E.forEach(([u, v, w]) => adj.set(u, (adj.get(u) || new Set()).add([v, w])));\\n    let k = hops + 1;\\n    let pre = Array(N).fill(Infinity);\\n    pre[start] = 0;\\n    let q = [ start ];\\n    while (k--) {\\n        let cur = [...pre];\\n        let len = q.length;\\n        while (len--) {\\n            let u = q.shift();\\n            for (let [v, w] of [...adj.get(u) || []])\\n                if (cur[v] > pre[u] + w)\\n                    cur[v] = pre[u] + w, q.push(v);\\n        }\\n        [pre, cur] = [cur, pre];\\n    }\\n    return pre[T] < Infinity ? pre[T] : -1;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, vector<tuple<int, int>>>;\\n    int findCheapestPrice(int N, VVI& E, int start, int T, int hops, Adj adj = {}, int INF = int(1e9 + 7)) {\\n        for (auto& edge: E) {\\n            auto [u, v, w] = tie(edge[0], edge[1], edge[2]);\\n            adj[u].push_back({v, w});\\n        }\\n        auto k = hops + 1;\\n        VI pre(N, INF);\\n        pre[start] = 0;\\n        queue<int> q{{ start }};\\n        while (k--) {\\n            auto cur{ pre };\\n            int len = q.size();\\n            while (len--) {\\n                auto u = q.front(); q.pop();\\n                for (auto [v, w]: adj[u])\\n                    if (cur[v] > pre[u] + w)\\n                        cur[v] = pre[u] + w, q.push(v);                \\n            }\\n            swap(pre, cur);\\n        }\\n        return pre[T] < INF ? pre[T] : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688278,
                "title": "simple-bfs-variant-with-python3-o-n-2-time-and-space",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for s, d, price in flights:\\n            graph[s].append((d, price))\\n        seen = [float(\\'inf\\')] * n\\n        seen[src] = 0\\n        q = deque([(src, -1, 0)])\\n        while q:\\n            node, stops, node_cost = q.popleft()\\n            if node == dst or stops == K:\\n                continue\\n            for nei, price in graph[node]:\\n                if (nei_cost := node_cost+price) >= seen[nei]:\\n                    continue\\n                seen[nei] = nei_cost\\n                q.append((nei, stops+1, nei_cost))\\n    \\n        return seen[dst] if seen[dst] != float(\\'inf\\') else -1\\n```\\n\\nFun fact: The number of this flight problem is 787 :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for s, d, price in flights:\\n            graph[s].append((d, price))\\n        seen = [float(\\'inf\\')] * n\\n        seen[src] = 0\\n        q = deque([(src, -1, 0)])\\n        while q:\\n            node, stops, node_cost = q.popleft()\\n            if node == dst or stops == K:\\n                continue\\n            for nei, price in graph[node]:\\n                if (nei_cost := node_cost+price) >= seen[nei]:\\n                    continue\\n                seen[nei] = nei_cost\\n                q.append((nei, stops+1, nei_cost))\\n    \\n        return seen[dst] if seen[dst] != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687434,
                "title": "c-easy-solution-dfs",
                "content": "Time Complexity: **O(K * V * V)** in which V is the number of cities within the range K stops.\\n```\\npublic int FindCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n  var minCost = int.MaxValue;\\n  var adj = Enumerable.Range(0, n).ToDictionary(x => x, x => new List<(int, int)>());\\n  foreach(var f in flights) {\\n    adj[f[0]].Add((f[1],f[2]));\\n  }\\n\\n  var costs = new int[n];\\n  Array.Fill(costs, int.MaxValue);\\n  costs[src] = 0;\\n  //DFS(src, K + 1, 0);\\n  BFS();\\n\\n  return minCost == int.MaxValue ? -1 : minCost;\\n\\n  void DFS(int x, int k, int cost) {\\n    if (k < 0) return;\\n\\n    if (x == dst) {\\n      minCost = cost;\\n      return;\\n    }\\n\\n    if (!adj.ContainsKey(x)) return;\\n\\n    foreach (var neigbor in adj[x]) {\\n      var newCost = cost + neigbor.Item2;\\n      if (newCost > minCost || newCost > costs[neigbor.Item1]) continue;\\n\\n      costs[neigbor.Item1] = newCost;\\n      DFS(neigbor.Item1, k - 1, newCost);\\n    }\\n  }\\n\\n  void BFS() {\\n    var q = new Queue<int[]>();\\n    q.Enqueue(new[] {src, 0});\\n\\n    var stops = 0;\\n    while(q.Count > 0 && stops < K + 1){\\n      var cnt = q.Count;\\n      while(cnt > 0){\\n        cnt--;\\n        var node = q.Dequeue();       \\n\\n        foreach(var neigbor in adj[node[0]]){\\n          var cost = node[1] + neigbor.Item2;\\n          if(cost > minCost || cost > costs[neigbor.Item1]) continue;\\n\\n          if(neigbor.Item1 == dst){\\n            minCost = Math.Min(minCost, cost);\\n            continue;\\n          }          \\n\\n          costs[neigbor.Item1] = cost;          \\n          q.Enqueue(new[] {neigbor.Item1, cost});\\n        }\\n      }\\n      ++stops;\\n    }\\n  }    \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic int FindCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n  var minCost = int.MaxValue;\\n  var adj = Enumerable.Range(0, n).ToDictionary(x => x, x => new List<(int, int)>());\\n  foreach(var f in flights) {\\n    adj[f[0]].Add((f[1],f[2]));\\n  }\\n\\n  var costs = new int[n];\\n  Array.Fill(costs, int.MaxValue);\\n  costs[src] = 0;\\n  //DFS(src, K + 1, 0);\\n  BFS();\\n\\n  return minCost == int.MaxValue ? -1 : minCost;\\n\\n  void DFS(int x, int k, int cost) {\\n    if (k < 0) return;\\n\\n    if (x == dst) {\\n      minCost = cost;\\n      return;\\n    }\\n\\n    if (!adj.ContainsKey(x)) return;\\n\\n    foreach (var neigbor in adj[x]) {\\n      var newCost = cost + neigbor.Item2;\\n      if (newCost > minCost || newCost > costs[neigbor.Item1]) continue;\\n\\n      costs[neigbor.Item1] = newCost;\\n      DFS(neigbor.Item1, k - 1, newCost);\\n    }\\n  }\\n\\n  void BFS() {\\n    var q = new Queue<int[]>();\\n    q.Enqueue(new[] {src, 0});\\n\\n    var stops = 0;\\n    while(q.Count > 0 && stops < K + 1){\\n      var cnt = q.Count;\\n      while(cnt > 0){\\n        cnt--;\\n        var node = q.Dequeue();       \\n\\n        foreach(var neigbor in adj[node[0]]){\\n          var cost = node[1] + neigbor.Item2;\\n          if(cost > minCost || cost > costs[neigbor.Item1]) continue;\\n\\n          if(neigbor.Item1 == dst){\\n            minCost = Math.Min(minCost, cost);\\n            continue;\\n          }          \\n\\n          costs[neigbor.Item1] = cost;          \\n          q.Enqueue(new[] {neigbor.Item1, cost});\\n        }\\n      }\\n      ++stops;\\n    }\\n  }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686787,
                "title": "python-super-short-o-k-len-flights-solution-with-o-n-space",
                "content": "(explanation in comment below)\\n```\\nclass Solution:\\n    import math\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        dist = [math.inf]*n\\n        dist[src] = 0\\n        for _ in range(K+1):\\n            olddist = dist[:]\\n            for f in flights:\\n                dist[f[1]] = min(dist[f[1]], olddist[f[0]] + f[2])\\n        return dist[dst] if dist[dst] < math.inf else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    import math\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        dist = [math.inf]*n\\n        dist[src] = 0\\n        for _ in range(K+1):\\n            olddist = dist[:]\\n            for f in flights:\\n                dist[f[1]] = min(dist[f[1]], olddist[f[0]] + f[2])\\n        return dist[dst] if dist[dst] < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550074,
                "title": "simple-python-solution-with-explanation-using-min-heap-priority-queue-and-links-to-other-resources",
                "content": "```\\n# In this solution, we start at the \\'src\\' city and traverse to the next\\n# cities which have minimum cost and stops < k until we find our destination.\\n\\n# At first, you may be tempted to use a BFS and search the nodes in the queue \\n# with minimum cost. This should work but using a min heap is faster than a queue\\n# because it can give you the minimum element with O(1) time instead of O(n).\\n\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        \"\"\"\\n        :type n: int\\n        :type flights: List[List[int]]\\n        :type src: int\\n        :type dst: int\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Adjacency list as a hash map\\n        flight_map = collections.defaultdict(list)\\n        for origin, destination, cost in flights:\\n            flight_map[origin].append((destination,cost))\\n\\n        #Initially push \\'src\\' into the heap with stops=-1 and cost=0\\n        heap = []\\n        heapq.heappush(heap, (0,-1,src)) # (cost,stops,destination)\\n        visited = set() # Use a set to avoid unnecessary nodes in the heap, in case the graph has cycles\\n        while heap:\\n            cost, stops, city = heapq.heappop(heap)\\n            visited.add(city)\\n            \\n            if city == dst:\\n                return cost\\n            \\n            if stops < K: # can add another stop\\n                for next_city, flight_cost in flight_map[city]:\\n                    if next_city not in visited:\\n                        # pushes the next city into the heap and increse total cost and stops\\n                        heapq.heappush(heap, (cost+flight_cost,stops+1,next_city))\\n        \\n        return -1\\n```\\n\\nHeapq Python reference: https://docs.python.org/2/library/heapq.html\\n\\nIf you want to learn more about the theory behind heaps, check\\n out this video from Abdul Bari: https://www.youtube.com/watch?v=HqPJF2L5h9U&t=1s\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n# In this solution, we start at the \\'src\\' city and traverse to the next\\n# cities which have minimum cost and stops < k until we find our destination.\\n\\n# At first, you may be tempted to use a BFS and search the nodes in the queue \\n# with minimum cost. This should work but using a min heap is faster than a queue\\n# because it can give you the minimum element with O(1) time instead of O(n).\\n\\nclass Solution(object):\\n    def findCheapestPrice(self, n, flights, src, dst, K):\\n        \"\"\"\\n        :type n: int\\n        :type flights: List[List[int]]\\n        :type src: int\\n        :type dst: int\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # Adjacency list as a hash map\\n        flight_map = collections.defaultdict(list)\\n        for origin, destination, cost in flights:\\n            flight_map[origin].append((destination,cost))\\n\\n        #Initially push \\'src\\' into the heap with stops=-1 and cost=0\\n        heap = []\\n        heapq.heappush(heap, (0,-1,src)) # (cost,stops,destination)\\n        visited = set() # Use a set to avoid unnecessary nodes in the heap, in case the graph has cycles\\n        while heap:\\n            cost, stops, city = heapq.heappop(heap)\\n            visited.add(city)\\n            \\n            if city == dst:\\n                return cost\\n            \\n            if stops < K: # can add another stop\\n                for next_city, flight_cost in flight_map[city]:\\n                    if next_city not in visited:\\n                        # pushes the next city into the heap and increse total cost and stops\\n                        heapq.heappush(heap, (cost+flight_cost,stops+1,next_city))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434585,
                "title": "java-dijkstra-s-algorithm-clean-and-easy-to-understand",
                "content": "The idea is Dijkstra\\'s Algorithm. However, we need to modify it. \\n\\n**Brief Explanation of Correctness:**\\nThe proof of Dijkstra\\'s Algorithm will not be repeated here. We just say that the original graph G can be modified into a subgraph G\\' where only the nodes and edges can be visited in (K+1) steps are kept (not sure if dst is included).\\n\\nIf we run Dijkstra\\'s on subgraph G\\' and dst is in G\\', it should be shortest path from src to dst.\\n\\n**Algorithm:**\\nInitially push the src into the heap\\nfor every step:\\n    1. check if the current top element in heap is dst. If so return its costFromSrc;\\n    2. Push every adjacent edge into the heap if the distance is less than k;\\n    3. If it is larger than k, no more neighbors get pushed into the heap;\\nIf until the end, we cannot find dst, return -1;\\n\\n```java\\nclass Pair {\\n\\tint city, cost;\\n\\n\\tPair(int city, int cost) {\\n\\t\\tthis.city = city;\\n\\t\\tthis.cost = cost;\\n\\t}\\n}\\n\\nclass City {\\n\\tint city, distFromSrc, costFromSrc;\\n\\n\\tCity(int city, int distFromSrc, int cost) {\\n\\t\\tthis.city = city;\\n\\t\\tthis.distFromSrc = distFromSrc;\\n\\t\\tthis.costFromSrc = cost;\\n\\t}\\n}\\n\\nclass Solution {\\n\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n    \\t// DFS\\n        if(n <= 0 || flights == null || flights.length == 0 || K < 0)\\n        \\treturn -1;\\n\\n        List<List<Pair>> graph = new ArrayList<>();\\n        this.buildGraph(graph, n, flights);\\n\\n        Queue<City> pQueue = new PriorityQueue<>((City c1, City c2) -> c1.costFromSrc - c2.costFromSrc);\\n        pQueue.offer(new City(src, 0, 0));\\n\\n        int totalCost = 0;\\n\\n        while (!pQueue.isEmpty()) {\\n        \\tCity top = pQueue.poll();\\n\\n        \\tif (top.city == dst) {\\n        \\t\\treturn top.costFromSrc;\\n        \\t}\\n\\n        \\tif (top.distFromSrc > K) {\\n        \\t\\tcontinue;\\n        \\t}\\n\\n        \\tList<Pair> neighbors = graph.get(top.city);\\n        \\tfor (Pair neighbor: neighbors) {\\n        \\t\\tpQueue.offer(new City(neighbor.city, top.distFromSrc + 1, top.costFromSrc + neighbor.cost));\\n        \\t}\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void buildGraph(List<List<Pair>> graph, int n, int[][] flights) {\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tgraph.add(new ArrayList<>());\\n    \\t}\\n\\n    \\tfor (int[] flight: flights) {\\n    \\t\\tgraph.get(flight[0]).add(new Pair(flight[1], flight[2]));\\n    \\t}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Pair {\\n\\tint city, cost;\\n\\n\\tPair(int city, int cost) {\\n\\t\\tthis.city = city;\\n\\t\\tthis.cost = cost;\\n\\t}\\n}\\n\\nclass City {\\n\\tint city, distFromSrc, costFromSrc;\\n\\n\\tCity(int city, int distFromSrc, int cost) {\\n\\t\\tthis.city = city;\\n\\t\\tthis.distFromSrc = distFromSrc;\\n\\t\\tthis.costFromSrc = cost;\\n\\t}\\n}\\n\\nclass Solution {\\n\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n    \\t// DFS\\n        if(n <= 0 || flights == null || flights.length == 0 || K < 0)\\n        \\treturn -1;\\n\\n        List<List<Pair>> graph = new ArrayList<>();\\n        this.buildGraph(graph, n, flights);\\n\\n        Queue<City> pQueue = new PriorityQueue<>((City c1, City c2) -> c1.costFromSrc - c2.costFromSrc);\\n        pQueue.offer(new City(src, 0, 0));\\n\\n        int totalCost = 0;\\n\\n        while (!pQueue.isEmpty()) {\\n        \\tCity top = pQueue.poll();\\n\\n        \\tif (top.city == dst) {\\n        \\t\\treturn top.costFromSrc;\\n        \\t}\\n\\n        \\tif (top.distFromSrc > K) {\\n        \\t\\tcontinue;\\n        \\t}\\n\\n        \\tList<Pair> neighbors = graph.get(top.city);\\n        \\tfor (Pair neighbor: neighbors) {\\n        \\t\\tpQueue.offer(new City(neighbor.city, top.distFromSrc + 1, top.costFromSrc + neighbor.cost));\\n        \\t}\\n        }\\n\\n        return -1;\\n    }\\n\\n    private void buildGraph(List<List<Pair>> graph, int n, int[][] flights) {\\n    \\tfor (int i = 0; i < n; i++) {\\n    \\t\\tgraph.add(new ArrayList<>());\\n    \\t}\\n\\n    \\tfor (int[] flight: flights) {\\n    \\t\\tgraph.get(flight[0]).add(new Pair(flight[1], flight[2]));\\n    \\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371274,
                "title": "java-dijikstra",
                "content": "```\\nclass CustomComp implements Comparator<int[]>{\\n    public int compare(int[] a, int[] b){\\n        return a[0] - b[0];\\n    }\\n}\\nclass Solution {\\n    ArrayList<int[]>[] graph;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] flight: flights){\\n            graph[flight[0]].add(new int[]{flight[1], flight[2]});\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new CustomComp());\\n        pq.offer(new int[]{0, src, K+1});\\n        while(!pq.isEmpty()){\\n            int[] cur = pq.poll();\\n            if(cur[1] == dst) return cur[0];\\n            if(cur[2]>0){\\n                for(int[] nxt: graph[cur[1]]){\\n                    pq.offer(new int[]{cur[0]+nxt[1], nxt[0], cur[2]-1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass CustomComp implements Comparator<int[]>{\\n    public int compare(int[] a, int[] b){\\n        return a[0] - b[0];\\n    }\\n}\\nclass Solution {\\n    ArrayList<int[]>[] graph;\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        graph = new ArrayList[n];\\n        for(int i = 0; i < n; i++){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(int[] flight: flights){\\n            graph[flight[0]].add(new int[]{flight[1], flight[2]});\\n        }\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new CustomComp());\\n        pq.offer(new int[]{0, src, K+1});\\n        while(!pq.isEmpty()){\\n            int[] cur = pq.poll();\\n            if(cur[1] == dst) return cur[0];\\n            if(cur[2]>0){\\n                for(int[] nxt: graph[cur[1]]){\\n                    pq.offer(new int[]{cur[0]+nxt[1], nxt[0], cur[2]-1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234286,
                "title": "javascript-solution",
                "content": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    const graph = buildGraph(flights)\\n\\n    const queue = []\\n    queue.push([src, 0])\\n    \\n    let minCost = Infinity\\n    \\n    for (let stopsRemain = K + 1; stopsRemain >= 0; stopsRemain--) {\\n        let levelSize = queue.length\\n        for (let i = 0; i < levelSize; i++) {\\n            let [cur, costSoFar] = queue.shift()\\n            \\n            if (costSoFar > minCost) {\\n                continue\\n            }\\n            \\n            if (cur === dst) {\\n                minCost = Math.min(minCost, costSoFar)\\n                continue\\n            }\\n            \\n            let neighbors = graph[cur] || []\\n            for (let [nei, cost] of neighbors) {\\n                queue.push([nei, costSoFar + cost])\\n            }\\n        }\\n    }\\n    \\n    return minCost === Infinity ? -1 : minCost\\n};\\n\\nfunction buildGraph(edges) {\\n    const graph = {}\\n    for (let [src, dst, w] of edges) {\\n        graph[src] = graph[src] || []\\n        graph[src].push([dst, w])\\n    }\\n    return graph\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar findCheapestPrice = function(n, flights, src, dst, K) {\\n    const graph = buildGraph(flights)\\n\\n    const queue = []\\n    queue.push([src, 0])\\n    \\n    let minCost = Infinity\\n    \\n    for (let stopsRemain = K + 1; stopsRemain >= 0; stopsRemain--) {\\n        let levelSize = queue.length\\n        for (let i = 0; i < levelSize; i++) {\\n            let [cur, costSoFar] = queue.shift()\\n            \\n            if (costSoFar > minCost) {\\n                continue\\n            }\\n            \\n            if (cur === dst) {\\n                minCost = Math.min(minCost, costSoFar)\\n                continue\\n            }\\n            \\n            let neighbors = graph[cur] || []\\n            for (let [nei, cost] of neighbors) {\\n                queue.push([nei, costSoFar + cost])\\n            }\\n        }\\n    }\\n    \\n    return minCost === Infinity ? -1 : minCost\\n};\\n\\nfunction buildGraph(edges) {\\n    const graph = {}\\n    for (let [src, dst, w] of edges) {\\n        graph[src] = graph[src] || []\\n        graph[src].push([dst, w])\\n    }\\n    return graph\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 125551,
                "title": "easy-understanding-dp-in-java-o-n-n-k-9ms",
                "content": "It is obvious that filights within **K** stops is cheaper than **K-1** stops. So there is a very simple DP idea. We maintain a table DP\\\\[K]\\\\[N]. We could deduce K from K-1 as code below.\\n```\\n   public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int matrix[][] = new int[n][n];\\n        for (int i=0; i < flights.length; i++) {\\n            matrix[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        //dp[k][i] stores min value from src to i, when k stops are reached\\n        int dp[][] = new int[K+1][n];\\n        for (int i = 0; i<n; i++) {\\n            if(matrix[src][i] > 0)\\n                dp[0][i] = matrix[src][i];\\n            else \\n                dp[0][i] = Integer.MAX_VALUE;\\n        }\\n        \\n        int k=1;\\n        for (; k <=K; k++) {\\n            boolean changed = false;\\n            for (int i=0; i <n; i++) {\\n                dp[k][i] = dp[k-1][i];\\n                for (int j=0; j<n; j++) {\\n                    if (j != i) {\\n                        if ( dp[k-1][j] != Integer.MAX_VALUE && matrix[j][i] != 0) {\\n                            if (dp[k][i] > dp[k-1][j]+matrix[j][i]) {\\n                                dp[k][i] = dp[k-1][j]+matrix[j][i];\\n                                changed = true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (!changed) break;\\n        }\\n        k = Integer.min(K, k);\\n        return  dp[k][dst] == Integer.MAX_VALUE ? -1: dp[k][dst];\\n    }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n   public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {\\n        int matrix[][] = new int[n][n];\\n        for (int i=0; i < flights.length; i++) {\\n            matrix[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        //dp[k][i] stores min value from src to i, when k stops are reached\\n        int dp[][] = new int[K+1][n];\\n        for (int i = 0; i<n; i++) {\\n            if(matrix[src][i] > 0)\\n                dp[0][i] = matrix[src][i];\\n            else \\n                dp[0][i] = Integer.MAX_VALUE;\\n        }\\n        \\n        int k=1;\\n        for (; k <=K; k++) {\\n            boolean changed = false;\\n            for (int i=0; i <n; i++) {\\n                dp[k][i] = dp[k-1][i];\\n                for (int j=0; j<n; j++) {\\n                    if (j != i) {\\n                        if ( dp[k-1][j] != Integer.MAX_VALUE && matrix[j][i] != 0) {\\n                            if (dp[k][i] > dp[k-1][j]+matrix[j][i]) {\\n                                dp[k][i] = dp[k-1][j]+matrix[j][i];\\n                                changed = true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            if (!changed) break;\\n        }\\n        k = Integer.min(K, k);\\n        return  dp[k][dst] == Integer.MAX_VALUE ? -1: dp[k][dst];\\n    }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3224322,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static class pair{\\n        int v , w ;\\n        pair( int v , int w )\\n        {\\n            this.v = v ;\\n            this.w = w ;\\n        }\\n    }\\n    static class tuple{\\n        int  n , stops , cost ;\\n        tuple( int  n ,int stops ,int cost)\\n        {\\n            this.n = n ;\\n            this.stops = stops ;\\n            this.cost = cost;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<pair>> adj = new ArrayList<>();\\n        for (int i = 0; i < n  ; i++) {\\n            adj.add( new ArrayList<>());\\n        }\\n        for (int i = 0; i < flights.length; i++) {\\n            adj.get( flights[i][0] ).add( new pair( flights[i][1] , flights[i][2] ) );\\n        }\\n\\n        int dis[] = new int[n];\\n        Arrays.fill( dis , Integer.MAX_VALUE);\\n        dis[src] = 0 ;\\n\\n        Queue<tuple> q = new LinkedList<>();\\n        q.add( new tuple(src , 0 , 0 ));\\n        while (!q.isEmpty())\\n        {\\n            tuple t = q.poll();\\n            int u = t.n;\\n            int stops = t.stops;\\n            int cost = t.cost ;\\n\\n            if( stops>k ) continue;\\n\\n            for (int i = 0; i < adj.get(u).size(); i++) {\\n                int v = adj.get(u).get(i).v;\\n                int w = adj.get(u).get(i).w;\\n\\n                if( cost+w < dis[v] && stops<=k )\\n                {\\n                    dis[v] = cost+w;\\n                    q.add( new tuple(v , stops+1 , dis[v] ));\\n                }\\n            }\\n\\n        }\\n\\n        if( dis[dst] ==Integer.MAX_VALUE) return -1 ;\\n        else return dis[dst] ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static class pair{\\n        int v , w ;\\n        pair( int v , int w )\\n        {\\n            this.v = v ;\\n            this.w = w ;\\n        }\\n    }\\n    static class tuple{\\n        int  n , stops , cost ;\\n        tuple( int  n ,int stops ,int cost)\\n        {\\n            this.n = n ;\\n            this.stops = stops ;\\n            this.cost = cost;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        ArrayList<ArrayList<pair>> adj = new ArrayList<>();\\n        for (int i = 0; i < n  ; i++) {\\n            adj.add( new ArrayList<>());\\n        }\\n        for (int i = 0; i < flights.length; i++) {\\n            adj.get( flights[i][0] ).add( new pair( flights[i][1] , flights[i][2] ) );\\n        }\\n\\n        int dis[] = new int[n];\\n        Arrays.fill( dis , Integer.MAX_VALUE);\\n        dis[src] = 0 ;\\n\\n        Queue<tuple> q = new LinkedList<>();\\n        q.add( new tuple(src , 0 , 0 ));\\n        while (!q.isEmpty())\\n        {\\n            tuple t = q.poll();\\n            int u = t.n;\\n            int stops = t.stops;\\n            int cost = t.cost ;\\n\\n            if( stops>k ) continue;\\n\\n            for (int i = 0; i < adj.get(u).size(); i++) {\\n                int v = adj.get(u).get(i).v;\\n                int w = adj.get(u).get(i).w;\\n\\n                if( cost+w < dis[v] && stops<=k )\\n                {\\n                    dis[v] = cost+w;\\n                    q.add( new tuple(v , stops+1 , dis[v] ));\\n                }\\n            }\\n\\n        }\\n\\n        if( dis[dst] ==Integer.MAX_VALUE) return -1 ;\\n        else return dis[dst] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101972,
                "title": "striver-concept-modified-dijkstra-algorithm",
                "content": "# Intuition\\nReading the problem description itself class for a classical dijkstra algorithm. The only modification is the restriction of a maximum number of flights that we can take. If you don\\'t know Dijkstra, check it out in the Leetcode Explore-Cards or somewhere else.\\n\\nDijkstra is basically a modified BFS through a graph, where instead of the queue, we use a priority queue or heap tho push and get our next position from.\\n\\nThis enables us to always reach nodes with their lowest cost first, if we use cost as the key for the min-heap/priority queue.\\n\\nIn this questions there is one additional problem: Normally we terminate Dijkstra as soon as we reach a node that already has been processed, because we already found the lowest cost for travelling to this one.\\n\\nHere this would cause problem, since we could maybe travel cheaper to a certain city, but exceeded or really stressed our maximum number of flights.\\n\\nTherefore we terminate Dijkstra not on the lowest found cost but on the number of flight we took to get there. Still, because of the heap condition, we can terminate as soon as we reach the destination node as this will be guaranteed with the lowest cost (if the number of flights is acceptable, we should check that before exiting).\\n\\nThis will cause us to visit a node a maximum of K instead of only one time, but that is a tradeoff we need to make.\\n\\n\\n# Approach\\n\\nModified Dijkstra (termination condition modified). Also keep in mind that the number of flights taken is the the number of cities visited - 1.\\n> Quote\\n\\n# Code\\n```\\nfrom heapq import *\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(dict)\\n        for u, v, p in flights:\\n            graph[u][v] = p\\n        \\n        seen = {}\\n        pq = []\\n        heappush(pq, (0, 0, src))\\n        \\n        while pq:\\n            cost, hops, city = heappop(pq)\\n            seen[city] = hops\\n            \\n            if city == dst:\\n                return cost\\n            \\n            if hops > k:\\n                continue\\n            \\n            for next_city, next_cost in graph[city].items():\\n                if next_city in seen and seen[next_city] <= hops:\\n                    continue\\n                heappush(pq, (cost + next_cost, hops + 1, next_city))\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        graph = defaultdict(dict)\\n        for u, v, p in flights:\\n            graph[u][v] = p\\n        \\n        seen = {}\\n        pq = []\\n        heappush(pq, (0, 0, src))\\n        \\n        while pq:\\n            cost, hops, city = heappop(pq)\\n            seen[city] = hops\\n            \\n            if city == dst:\\n                return cost\\n            \\n            if hops > k:\\n                continue\\n            \\n            for next_city, next_cost in graph[city].items():\\n                if next_city in seen and seen[next_city] <= hops:\\n                    continue\\n                heappush(pq, (cost + next_cost, hops + 1, next_city))\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101838,
                "title": "python-simple-python-solution-using-bfs-graph",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 104 ms, faster than 91.42% of Python3 online submissions for Cheapest Flights Within K Stops.\\n# Memory Usage: 15.3 MB, less than 54.38% of Python3 online submissions for Cheapest Flights Within K Stops.\\n\\n\\tclass Solution:\\n\\t\\tdef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n\\t\\t\\tgraph = {}\\n\\n\\t\\t\\tfor city in range(n):\\n\\t\\t\\t\\tgraph[city] = []\\n\\n\\t\\t\\tfor flight in flights:\\n\\n\\t\\t\\t\\tsource, destination , price = flight\\n\\n\\t\\t\\t\\tgraph[source].append((destination, price))\\n\\n\\t\\t\\tdq = deque()\\n\\t\\t\\tdq.append((0 , src, 0))\\n\\n\\t\\t\\tprice = [10000000] * n\\n\\t\\t\\tprice[src] = 0\\n\\n\\t\\t\\twhile dq:\\n\\n\\t\\t\\t\\tcurrent_stop , current_city , current_price = dq.popleft()\\n\\n\\t\\t\\t\\tif current_stop > k:\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tfor next_city, cost in graph[current_city]:\\n\\n\\t\\t\\t\\t\\tif current_price + cost < price[next_city]:\\n\\t\\t\\t\\t\\t\\tprice[next_city] = current_price + cost\\n\\n\\t\\t\\t\\t\\t\\tdq.append((current_stop + 1, next_city , price[next_city]))\\n\\n\\t\\t\\tif price[dst] == 10000000:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn price[dst]\\n\\t\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution:\\n\\t\\tdef findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n\\n\\t\\t\\tgraph = {}",
                "codeTag": "Java"
            },
            {
                "id": 3100917,
                "title": "java-easy-solution-upvote-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   Relaxing the edge\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   Bellman Ford\\n   ![WhatsApp Image 2023-01-26 at 13.46.58.jpeg](https://assets.leetcode.com/users/images/d48374f6-69b5-41ce-a3d1-84d6eabaf86a_1674721102.0172527.jpeg)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n     O(K*E)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n                           Upvote it\\n![1725_upvote.png](https://assets.leetcode.com/users/images/aa0ae41f-b9a1-4f7a-b2cc-3a3e76f2743d_1674721466.8494942.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n       int cost[] = new int[n];\\n       Arrays.fill(cost, Integer.MAX_VALUE);\\n       cost[src] = 0;\\n       int count = 0;\\n       int tempcost[] = cost.clone();\\n       while(count <= k)\\n       {\\n           tempcost = cost.clone();\\n           for(int[] flight : flights)\\n           {\\n               int s = flight[0];\\n               int d = flight[1];\\n               int c = flight[2];\\n\\n               if(cost[s] != Integer.MAX_VALUE && (cost[s] + c ) < tempcost[d])\\n               {\\n                   tempcost[d] = cost[s] + c;\\n               }\\n           }\\n           cost = tempcost;\\n           count++;\\n       }\\n       if(cost[dst] == Integer.MAX_VALUE)\\n       {\\n           return -1;\\n       }\\n       return cost[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n       int cost[] = new int[n];\\n       Arrays.fill(cost, Integer.MAX_VALUE);\\n       cost[src] = 0;\\n       int count = 0;\\n       int tempcost[] = cost.clone();\\n       while(count <= k)\\n       {\\n           tempcost = cost.clone();\\n           for(int[] flight : flights)\\n           {\\n               int s = flight[0];\\n               int d = flight[1];\\n               int c = flight[2];\\n\\n               if(cost[s] != Integer.MAX_VALUE && (cost[s] + c ) < tempcost[d])\\n               {\\n                   tempcost[d] = cost[s] + c;\\n               }\\n           }\\n           cost = tempcost;\\n           count++;\\n       }\\n       if(cost[dst] == Integer.MAX_VALUE)\\n       {\\n           return -1;\\n       }\\n       return cost[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100885,
                "title": "java-solution-explained",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int first, second;\\n        public Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    class Tuple {\\n        int first, second, third;\\n        Tuple(int first, int second, int third){\\n            this.first = first;\\n            this.second = second;\\n            this.third = third;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        // we need to store the Adjacent nodes and edge weights.\\n        // so we need Pair.\\n        List<List<Pair>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        int m = flights.length;\\n        for(int i = 0; i < m; i++){\\n            adj.get(flights[i][0]).add(new Pair(flights[i][1], flights[i][2]));\\n        }\\n        Queue<Tuple> q = new LinkedList<>();\\n        // {stops, {node, dist}}\\n        q.add(new Tuple(0, src, 0));\\n        // declear the distance array. with same size n.\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, (int) 1e9);\\n        // distance to source is 0.\\n        dist[src] = 0;\\n        // T -> O(n) = E = flights.size().\\n        while(!q.isEmpty()){\\n            Tuple it = q.remove();\\n            int stops = it.first;\\n            int node = it.second;\\n            int cost = it.third;\\n            // if stops is greater then k mean no need to go further.\\n            if(stops > k) continue;\\n            for(Pair iter: adj.get(node)){\\n                // Adjacent node.\\n                int adjNode = iter.first;\\n                // edge weight.\\n                int edW = iter.second;\\n                // if cost + edge weight is < then distance of adjacent node && stops <= k.\\n                // mean we have to update our distance array.\\n                if(cost + edW < dist[adjNode] && stops <= k){\\n                    dist[adjNode] = cost + edW;\\n                    // increment the stops by 1, \\n                    // adjacent node,\\n                    // cost + edge weight.\\n                    q.add(new Tuple(stops + 1, adjNode, cost + edW));\\n                }\\n            }\\n        }\\n        // if the distance to destination is 1e9 means we never reach so, return -1.\\n        if(dist[dst] == (int) 1e9) return -1;\\n        return dist[dst];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int first, second;\\n        public Pair(int first, int second){\\n            this.first = first;\\n            this.second = second;\\n        }\\n    }\\n    class Tuple {\\n        int first, second, third;\\n        Tuple(int first, int second, int third){\\n            this.first = first;\\n            this.second = second;\\n            this.third = third;\\n        }\\n    }\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\\n        // we need to store the Adjacent nodes and edge weights.\\n        // so we need Pair.\\n        List<List<Pair>> adj = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        int m = flights.length;\\n        for(int i = 0; i < m; i++){\\n            adj.get(flights[i][0]).add(new Pair(flights[i][1], flights[i][2]));\\n        }\\n        Queue<Tuple> q = new LinkedList<>();\\n        // {stops, {node, dist}}\\n        q.add(new Tuple(0, src, 0));\\n        // declear the distance array. with same size n.\\n        int[] dist = new int[n];\\n        Arrays.fill(dist, (int) 1e9);\\n        // distance to source is 0.\\n        dist[src] = 0;\\n        // T -> O(n) = E = flights.size().\\n        while(!q.isEmpty()){\\n            Tuple it = q.remove();\\n            int stops = it.first;\\n            int node = it.second;\\n            int cost = it.third;\\n            // if stops is greater then k mean no need to go further.\\n            if(stops > k) continue;\\n            for(Pair iter: adj.get(node)){\\n                // Adjacent node.\\n                int adjNode = iter.first;\\n                // edge weight.\\n                int edW = iter.second;\\n                // if cost + edge weight is < then distance of adjacent node && stops <= k.\\n                // mean we have to update our distance array.\\n                if(cost + edW < dist[adjNode] && stops <= k){\\n                    dist[adjNode] = cost + edW;\\n                    // increment the stops by 1, \\n                    // adjacent node,\\n                    // cost + edge weight.\\n                    q.add(new Tuple(stops + 1, adjNode, cost + edW));\\n                }\\n            }\\n        }\\n        // if the distance to destination is 1e9 means we never reach so, return -1.\\n        if(dist[dst] == (int) 1e9) return -1;\\n        return dist[dst];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100612,
                "title": "recursion-memoization-tabulation-space-optimization",
                "content": "# Upvote if you my Like Solution\\n\\n# 1. Intuition : Recursion\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Recursion Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int k, int src, int dst, int n, vector<vector<int>>& adj) {\\n        // Base Case\\n        if(k < 0) return 1e7;\\n        if(src == dst) return 0;\\n\\n        // Recursive Case\\n        int ans = 1e7;\\n        for(int i = 0; i < n; i++) {\\n            if(adj[src][i] != -1) ans = min(ans, adj[src][i]+f(k-1, i, dst, n, adj));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        int val = f(k+1, src, dst, n, adj);\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\\n\\n# 2. Intuition : Memoization\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O((k+1)*(n^2)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + O((k+2)*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Memoization Code\\n```\\nclass Solution {\\npublic:\\n\\n    int f(int stops, int source, int destination, int n, vector<vector<int>>& adj, vector<vector<int>>& dp) {\\n        // Base Case\\n        if(stops < 0) return 1e7;\\n        if(source == destination) return 0;\\n\\n        // Recursive Case\\n        if(dp[stops][source] != -1) return dp[stops][source];\\n        int ans = 1e7;\\n        for(int i = 0; i < n; i++) {\\n            if(adj[source][i] != -1) ans = min(ans, adj[source][i]+f(stops-1, i, destination, n, adj, dp));\\n        }\\n\\n        return dp[stops][source] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<vector<int>> dp(k+2, vector<int> (n, -1));\\n        int val = f(k+1, src, dst, n, adj, dp);\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\\n\\n# 3. Intuition : Tabulation\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O((k+1)*(n^2)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O((k+2)*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Tabulation Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<vector<int>> dp(k+2, vector<int> (n, 0));\\n\\n        for(int stops = 0; stops <= k+1; stops++) {\\n            for(int source = n-1; source >= 0; source--) {\\n                if(source == dst) dp[stops][source] = 0;\\n                else {\\n                    int ans = 1e7;\\n                    for(int i = 0; i < n; i++) {\\n                        if(adj[source][i] != -1) {\\n                            int tp = (stops == 0 ? 1e7 : adj[source][i]+dp[stops-1][i]);\\n                            ans = min(ans, tp);\\n                        }\\n                    }\\n                    dp[stops][source] = ans;\\n                }\\n            }\\n        }\\n\\n        int val = dp[k+1][src];\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\\n\\n# 4. Intuition : Space Optimization\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: O((k+1)*(n^2)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Optimization Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<int> prev(n, 0), cur(n, 0);\\n\\n        for(int stops = 0; stops <= k+1; stops++) {\\n            for(int source = n-1; source >= 0; source--) {\\n                if(source == dst) cur[source] = 0;\\n                else {\\n                    int ans = 1e7;\\n                    for(int i = 0; i < n; i++) {\\n                        if(adj[source][i] != -1) {\\n                            int tp = (stops == 0 ? 1e7 : adj[source][i]+prev[i]);\\n                            ans = min(ans, tp);\\n                        }\\n                    }\\n                    cur[source] = ans;\\n                }\\n            }\\n            prev = cur;\\n        }\\n\\n        int val = prev[src];\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int f(int k, int src, int dst, int n, vector<vector<int>>& adj) {\\n        // Base Case\\n        if(k < 0) return 1e7;\\n        if(src == dst) return 0;\\n\\n        // Recursive Case\\n        int ans = 1e7;\\n        for(int i = 0; i < n; i++) {\\n            if(adj[src][i] != -1) ans = min(ans, adj[src][i]+f(k-1, i, dst, n, adj));\\n        }\\n\\n        return ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        int val = f(k+1, src, dst, n, adj);\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int f(int stops, int source, int destination, int n, vector<vector<int>>& adj, vector<vector<int>>& dp) {\\n        // Base Case\\n        if(stops < 0) return 1e7;\\n        if(source == destination) return 0;\\n\\n        // Recursive Case\\n        if(dp[stops][source] != -1) return dp[stops][source];\\n        int ans = 1e7;\\n        for(int i = 0; i < n; i++) {\\n            if(adj[source][i] != -1) ans = min(ans, adj[source][i]+f(stops-1, i, destination, n, adj, dp));\\n        }\\n\\n        return dp[stops][source] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<vector<int>> dp(k+2, vector<int> (n, -1));\\n        int val = f(k+1, src, dst, n, adj, dp);\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<vector<int>> dp(k+2, vector<int> (n, 0));\\n\\n        for(int stops = 0; stops <= k+1; stops++) {\\n            for(int source = n-1; source >= 0; source--) {\\n                if(source == dst) dp[stops][source] = 0;\\n                else {\\n                    int ans = 1e7;\\n                    for(int i = 0; i < n; i++) {\\n                        if(adj[source][i] != -1) {\\n                            int tp = (stops == 0 ? 1e7 : adj[source][i]+dp[stops-1][i]);\\n                            ans = min(ans, tp);\\n                        }\\n                    }\\n                    dp[stops][source] = ans;\\n                }\\n            }\\n        }\\n\\n        int val = dp[k+1][src];\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<vector<int>> adj(n, vector<int> (n, -1));\\n        for(int i = 0; i < flights.size(); i++) {\\n            adj[flights[i][0]][flights[i][1]] = flights[i][2];\\n        }\\n        \\n        vector<int> prev(n, 0), cur(n, 0);\\n\\n        for(int stops = 0; stops <= k+1; stops++) {\\n            for(int source = n-1; source >= 0; source--) {\\n                if(source == dst) cur[source] = 0;\\n                else {\\n                    int ans = 1e7;\\n                    for(int i = 0; i < n; i++) {\\n                        if(adj[source][i] != -1) {\\n                            int tp = (stops == 0 ? 1e7 : adj[source][i]+prev[i]);\\n                            ans = min(ans, tp);\\n                        }\\n                    }\\n                    cur[source] = ans;\\n                }\\n            }\\n            prev = cur;\\n        }\\n\\n        int val = prev[src];\\n        return (val == 1e7 ? -1 : val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100357,
                "title": "happy-republic-day-my-java-o-n-k-solution-using-memoization",
                "content": "\\n# Approach\\nUsed Recursion to go through all possible paths from source to destination, and took the price with the most minimum value\\nRecursion was giving TLE as expected\\nSo we have to take a dp of 2-dimensions to eliminate TLE\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] a, int src, int dst, int k) {\\n        List<List<List<Integer>>> graph = new ArrayList<>();\\n        int i,m=a.length;\\n        for(i=0;i<n;i++)\\n            graph.add(new ArrayList<>());\\n        for(i=0;i<m;i++)\\n        {\\n            ArrayList<Integer> tmp=new ArrayList<>();\\n            tmp.add(a[i][1]); tmp.add(a[i][2]);\\n            graph.get(a[i][0]).add(tmp);\\n        }\\n        int dp[][]=new int[n][k+2];\\n        for(int it[]:dp)\\n        Arrays.fill(it,-1);\\n        int ans=dfs(graph,src,dst,k+1,dp);\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n    public int dfs(List<List<List<Integer>>> graph,int src,int dst,int k,int dp[][])\\n    {\\n        if(k<0)  return Integer.MAX_VALUE;\\n        if(src==dst) return 0;\\n        if(dp[src][k]!=-1) return dp[src][k];\\n        int min=Integer.MAX_VALUE;\\n        for(List<Integer> it:graph.get(src))\\n        {\\n            int cho=it.get(0); int price=it.get(1);\\n            int cheap=dfs(graph,cho,dst,k-1,dp);\\n            if(cheap!=Integer.MAX_VALUE)\\n            min=Math.min(min,cheap+price);\\n        }\\n        return dp[src][k]=min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] a, int src, int dst, int k) {\\n        List<List<List<Integer>>> graph = new ArrayList<>();\\n        int i,m=a.length;\\n        for(i=0;i<n;i++)\\n            graph.add(new ArrayList<>());\\n        for(i=0;i<m;i++)\\n        {\\n            ArrayList<Integer> tmp=new ArrayList<>();\\n            tmp.add(a[i][1]); tmp.add(a[i][2]);\\n            graph.get(a[i][0]).add(tmp);\\n        }\\n        int dp[][]=new int[n][k+2];\\n        for(int it[]:dp)\\n        Arrays.fill(it,-1);\\n        int ans=dfs(graph,src,dst,k+1,dp);\\n        return ans==Integer.MAX_VALUE?-1:ans;\\n    }\\n    public int dfs(List<List<List<Integer>>> graph,int src,int dst,int k,int dp[][])\\n    {\\n        if(k<0)  return Integer.MAX_VALUE;\\n        if(src==dst) return 0;\\n        if(dp[src][k]!=-1) return dp[src][k];\\n        int min=Integer.MAX_VALUE;\\n        for(List<Integer> it:graph.get(src))\\n        {\\n            int cho=it.get(0); int price=it.get(1);\\n            int cheap=dfs(graph,cho,dst,k-1,dp);\\n            if(cheap!=Integer.MAX_VALUE)\\n            min=Math.min(min,cheap+price);\\n        }\\n        return dp[src][k]=min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100109,
                "title": "rust-elixir-solutions",
                "content": "Was going for a DP approach, but seems that they are officially called Bellman-Ford algorithm.\\n# Rust\\n```rust\\nimpl Solution {\\n    pub fn find_cheapest_price(n: i32, flights: Vec<Vec<i32>>, src: i32, dst: i32, k: i32) -> i32 {\\n        let mut adj = vec![Vec::new(); n as usize];\\n        for v in flights.iter() {\\n            adj[v[0] as usize].push((v[1] as usize, v[2]));\\n        }\\n        let mut cost = vec![i32::MAX; n as usize];\\n        cost[src as usize] = 0;\\n        for _ in 0..=k {\\n            let mut cost2 = cost.clone();\\n            for i in 0..n as usize {\\n                if cost[i] != i32::MAX {\\n                    for &(j, price) in adj[i].iter() {\\n                        cost2[j] = cost2[j].min(cost[i] + price);\\n                    }\\n                }\\n            }\\n            cost = cost2;\\n        }\\n        match cost[dst as usize] {\\n            i32::MAX => -1,\\n            x => x,\\n        }\\n    }\\n}\\n```\\n# Elixir\\nNot building the adjacency list and just iterate through `flights`.\\nThe result code is very compact.\\n```elixir\\ndefmodule Solution do\\n  @spec find_cheapest_price(n :: integer, flights :: [[integer]], src :: integer, dst :: integer, k :: integer) :: integer\\n  def find_cheapest_price(n, flights, src, dst, k) do\\n    Enum.reduce(0..k, %{src => 0}, fn _, cost ->\\n      Enum.reduce(flights, cost, fn [i, j, price], cost2 ->\\n        case Map.get(cost, i) do\\n          nil -> cost2\\n          x -> Map.update(cost2, j, x + price, &(min(&1, x + price)))\\n        end\\n      end)\\n    end)\\n    |> Map.get(dst, -1)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Dynamic Programming"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn find_cheapest_price(n: i32, flights: Vec<Vec<i32>>, src: i32, dst: i32, k: i32) -> i32 {\\n        let mut adj = vec![Vec::new(); n as usize];\\n        for v in flights.iter() {\\n            adj[v[0] as usize].push((v[1] as usize, v[2]));\\n        }\\n        let mut cost = vec![i32::MAX; n as usize];\\n        cost[src as usize] = 0;\\n        for _ in 0..=k {\\n            let mut cost2 = cost.clone();\\n            for i in 0..n as usize {\\n                if cost[i] != i32::MAX {\\n                    for &(j, price) in adj[i].iter() {\\n                        cost2[j] = cost2[j].min(cost[i] + price);\\n                    }\\n                }\\n            }\\n            cost = cost2;\\n        }\\n        match cost[dst as usize] {\\n            i32::MAX => -1,\\n            x => x,\\n        }\\n    }\\n}\\n```\n```elixir\\ndefmodule Solution do\\n  @spec find_cheapest_price(n :: integer, flights :: [[integer]], src :: integer, dst :: integer, k :: integer) :: integer\\n  def find_cheapest_price(n, flights, src, dst, k) do\\n    Enum.reduce(0..k, %{src => 0}, fn _, cost ->\\n      Enum.reduce(flights, cost, fn [i, j, price], cost2 ->\\n        case Map.get(cost, i) do\\n          nil -> cost2\\n          x -> Map.update(cost2, j, x + price, &(min(&1, x + price)))\\n        end\\n      end)\\n    end)\\n    |> Map.get(dst, -1)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3100092,
                "title": "python-sort-dfs-136-ms-faster-than-67-24",
                "content": "**Solution 1: DFS**\\nhttps://leetcode.com/submissions/detail/885406469/\\nRuntime: **136 ms**, faster than 67.24% of Python3 online submissions for Cheapest Flights Within K Stops.\\nMemory Usage: 15.2 MB, less than 54.38% of Python3 online submissions for Cheapest Flights Within K Stops.\\nP.S. If it is not sorted, the runtime would be around **1521 ms**.\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        NO_ROUTE = -1\\n        frs, tos = defaultdict(list), set() ## convert flights to dictionary/set form\\n        flights.sort(key=lambda x:x[2], reverse=True)\\n        for fr,to,price in flights:\\n            frs[fr].append([to, price])\\n            tos.add(to)\\n        if src not in frs or dst not in tos: return NO_ROUTE ## early exit\\n        \\n        cheapest, l = float(\\'inf\\'), [[t,p,0] for t,p in frs[src]]\\n        while l: ## dfs\\n            to, price, stop = l.pop()\\n            if price>=cheapest: continue\\n            if to==dst: \\n                cheapest = price\\n            elif stop<k and to in frs:\\n                for t,p in frs[to]:\\n                    if price+p<cheapest:\\n                        l += [[t, price+p, stop+1]]\\n        return cheapest if cheapest!=float(\\'inf\\') else NO_ROUTE\\n```\\n\\n**Solution 2: naive BFS, Memory Limit Exceeded**\\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        NO_ROUTE = -1\\n        \\n        fs = dict() ## convert flights to dictionary form\\n        for fr,to,price in flights:\\n            if fr in fs:\\n                fs[fr].append([to, price])\\n            else:\\n                fs[fr] = [[to, price]]\\n                \\n        if src not in fs: return NO_ROUTE ## edge case\\n        \\n        cheapest, l = None, fs[src]\\n        for i in range(k+1):\\n            if not l: break\\n            l_new = []\\n            for t1,p1 in l:\\n                if t1==dst: \\n                    cheapest = min(cheapest,p1) if cheapest else p1\\n                elif i<=k and t1 in fs: \\n                    l_new += [[t2,p1+p2] for t2,p2 in fs[t1]]\\n            l = l_new.copy()\\n        return cheapest if cheapest else NO_ROUTE\\n```\\nP.S. A working BFS solution would be like these. A cheaper route to a city must be always updated.\\nhttps://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/3100018/Python-BFS-solution\\nhttps://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/3100076/Python3-O(N-%2B-EK)-BFS\\n\\n**Large test cases**\\nhttps://leetcode.com/submissions/detail/885388076/testcase/  \\nhttps://leetcode.com/submissions/detail/885396480/testcase/",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        NO_ROUTE = -1\\n        frs, tos = defaultdict(list), set() ## convert flights to dictionary/set form\\n        flights.sort(key=lambda x:x[2], reverse=True)\\n        for fr,to,price in flights:\\n            frs[fr].append([to, price])\\n            tos.add(to)\\n        if src not in frs or dst not in tos: return NO_ROUTE ## early exit\\n        \\n        cheapest, l = float(\\'inf\\'), [[t,p,0] for t,p in frs[src]]\\n        while l: ## dfs\\n            to, price, stop = l.pop()\\n            if price>=cheapest: continue\\n            if to==dst: \\n                cheapest = price\\n            elif stop<k and to in frs:\\n                for t,p in frs[to]:\\n                    if price+p<cheapest:\\n                        l += [[t, price+p, stop+1]]\\n        return cheapest if cheapest!=float(\\'inf\\') else NO_ROUTE\\n```\n```\\nclass Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        NO_ROUTE = -1\\n        \\n        fs = dict() ## convert flights to dictionary form\\n        for fr,to,price in flights:\\n            if fr in fs:\\n                fs[fr].append([to, price])\\n            else:\\n                fs[fr] = [[to, price]]\\n                \\n        if src not in fs: return NO_ROUTE ## edge case\\n        \\n        cheapest, l = None, fs[src]\\n        for i in range(k+1):\\n            if not l: break\\n            l_new = []\\n            for t1,p1 in l:\\n                if t1==dst: \\n                    cheapest = min(cheapest,p1) if cheapest else p1\\n                elif i<=k and t1 in fs: \\n                    l_new += [[t2,p1+p2] for t2,p2 in fs[t1]]\\n            l = l_new.copy()\\n        return cheapest if cheapest else NO_ROUTE\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099840,
                "title": "let-s-learn-kotlin-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS through the graph, keeping a state value of `(location, cost_so_far, stops_so_far)` in the queue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Construct the `graph` for BFS. Specifically, for each node, we need to know all of its outgoing flights and how much they cost.\\n2. Instantiate a global array to track the `cheapest` means of arrival at each node.\\n3. At each iteration of BFS, disregard if the stops or cost are too high. Otherwise, update `cheapest` and add all the adjacent nodes to the queue.\\n    - Note: I initially set `stops = -1`. This is because `k` is being used to count the maximum number of layovers and arriving at your destination doesn\\'t count. So, if `k = 0`, we want to make sure a single iteration of BFS is still run.    \\n4. Return the cost to get to `dst` if we were able to get there.\\n\\n#### Disclaimer\\n@artemasoyan has a better [solution](https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/2877062/kotlin-belman-ford/) using the Bellman-Ford algorithm, which all the top submissions are copying. BFS here is a more standard approach, only ~20ms slower, and realistic to be expected in an interview. \\n\\n# Complexity\\n- Time complexity: $$O(N + F*K)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N + F*K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {\\n        // Build graph\\n        val graph: Array<MutableList<IntArray>> = Array(n) { mutableListOf<IntArray>() }\\n        for ((from, to, cost) in flights) {\\n            graph[from].add(intArrayOf(to, cost))\\n        }\\n\\n        // BFS\\n        var cheapest = IntArray(n) { Int.MAX_VALUE }\\n        var queue = LinkedList<IntArray>()\\n        queue.add(intArrayOf(src, 0, -1))\\n        while (queue.isNotEmpty()) {\\n            val (loc, cost, stops) = queue.poll()\\n            if (stops > k || cost >= cheapest[loc]) {\\n                continue\\n            }\\n            cheapest[loc] = cost\\n            for ((dest, price) in graph[loc]) {\\n                queue.add(intArrayOf(dest, cost + price, stops + 1))\\n            }\\n        }\\n        return if (cheapest[dst] == Int.MAX_VALUE) -1 else cheapest[dst]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {\\n        // Build graph\\n        val graph: Array<MutableList<IntArray>> = Array(n) { mutableListOf<IntArray>() }\\n        for ((from, to, cost) in flights) {\\n            graph[from].add(intArrayOf(to, cost))\\n        }\\n\\n        // BFS\\n        var cheapest = IntArray(n) { Int.MAX_VALUE }\\n        var queue = LinkedList<IntArray>()\\n        queue.add(intArrayOf(src, 0, -1))\\n        while (queue.isNotEmpty()) {\\n            val (loc, cost, stops) = queue.poll()\\n            if (stops > k || cost >= cheapest[loc]) {\\n                continue\\n            }\\n            cheapest[loc] = cost\\n            for ((dest, price) in graph[loc]) {\\n                queue.add(intArrayOf(dest, cost + price, stops + 1))\\n            }\\n        }\\n        return if (cheapest[dst] == Int.MAX_VALUE) -1 else cheapest[dst]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066930,
                "title": "beats-95-most-efficient-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& f, int src, int dst, int k) {\\n        queue<pair<int,pair<int,int>>>pq;\\n        vector<int>dist(n,1e9);\\n        pq.push({0,{0,src}});\\n        vector<vector<pair<int,int>>>v(n+1);\\n        for(int i=0;i<f.size();i++){\\n            v[f[i][0]].push_back({f[i][1],f[i][2]});\\n        }\\n        // for(int i=0;i<n;i++)\\n        while(pq.empty()==false){\\n            auto x=pq.front();\\n            int stop=x.first;\\n            int dis=x.second.first;\\n            int node=x.second.second;\\n            pq.pop();\\n            if(stop>k) continue;\\n            for(auto it:v[node]){\\n                if(dis+it.second<dist[it.first] && stop<=k){\\n                    dist[it.first]=dis+it.second;\\n                    pq.push({stop+1,{dist[it.first],it.first}});   \\n                }   \\n            }\\n        }\\n        if(dist[dst]==1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& f, int src, int dst, int k) {\\n        queue<pair<int,pair<int,int>>>pq;\\n        vector<int>dist(n,1e9);\\n        pq.push({0,{0,src}});\\n        vector<vector<pair<int,int>>>v(n+1);\\n        for(int i=0;i<f.size();i++){\\n            v[f[i][0]].push_back({f[i][1],f[i][2]});\\n        }\\n        // for(int i=0;i<n;i++)\\n        while(pq.empty()==false){\\n            auto x=pq.front();\\n            int stop=x.first;\\n            int dis=x.second.first;\\n            int node=x.second.second;\\n            pq.pop();\\n            if(stop>k) continue;\\n            for(auto it:v[node]){\\n                if(dis+it.second<dist[it.first] && stop<=k){\\n                    dist[it.first]=dis+it.second;\\n                    pq.push({stop+1,{dist[it.first],it.first}});   \\n                }   \\n            }\\n        }\\n        if(dist[dst]==1e9) return -1;\\n        return dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065571,
                "title": "swift-bfs",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ k: Int) -> Int {\\n        let graph = flights.reduce(into: [Int: [(Int, cost: Int)]]()) { graph, weightedEdge in\\n            graph[weightedEdge[1], default:.init()].append((weightedEdge[0], weightedEdge[2]))\\n        }\\n        \\n        var cheapestPrice = Int.max\\n        var stops = 0\\n        var bfs = [(dst, 0)]\\n        while !bfs.isEmpty && stops <= k {\\n            bfs = bfs.flatMap { cur in\\n                (graph[cur.0] ?? []).compactMap { next in\\n                    let newCost = cur.1 + next.1\\n                    guard newCost < cheapestPrice else { return nil }\\n                    if next.0 == src {\\n                        cheapestPrice = min(cheapestPrice, newCost)\\n                        return nil\\n                    }\\n                    return (next.0, newCost)\\n                }\\n            }\\n            stops += 1\\n        }\\n        return cheapestPrice == Int.max ? -1 : cheapestPrice\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findCheapestPrice(_ n: Int, _ flights: [[Int]], _ src: Int, _ dst: Int, _ k: Int) -> Int {\\n        let graph = flights.reduce(into: [Int: [(Int, cost: Int)]]()) { graph, weightedEdge in\\n            graph[weightedEdge[1], default:.init()].append((weightedEdge[0], weightedEdge[2]))\\n        }\\n        \\n        var cheapestPrice = Int.max\\n        var stops = 0\\n        var bfs = [(dst, 0)]\\n        while !bfs.isEmpty && stops <= k {\\n            bfs = bfs.flatMap { cur in\\n                (graph[cur.0] ?? []).compactMap { next in\\n                    let newCost = cur.1 + next.1\\n                    guard newCost < cheapestPrice else { return nil }\\n                    if next.0 == src {\\n                        cheapestPrice = min(cheapestPrice, newCost)\\n                        return nil\\n                    }\\n                    return (next.0, newCost)\\n                }\\n            }\\n            stops += 1\\n        }\\n        return cheapestPrice == Int.max ? -1 : cheapestPrice\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877062,
                "title": "kotlin-belman-ford",
                "content": "```kotlin\\nclass Solution {\\n    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {\\n        var dist = IntArray(n) { Int.MAX_VALUE }\\n        dist[src] = 0\\n        \\n        for (i in 0..k) {\\n            val temp = dist.copyOf()\\n            flights.forEach { (from, to, cost) -> \\n                if (dist[from] == Int.MAX_VALUE) return@forEach                \\n                temp[to] = Math.min(temp[to], dist[from] + cost)    \\n            }\\n            dist = temp\\n        }\\n        return if (dist[dst] == Int.MAX_VALUE) -1 else dist[dst]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\nclass Solution {\\n    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {\\n        var dist = IntArray(n) { Int.MAX_VALUE }\\n        dist[src] = 0\\n        \\n        for (i in 0..k) {\\n            val temp = dist.copyOf()\\n            flights.forEach { (from, to, cost) -> \\n                if (dist[from] == Int.MAX_VALUE) return@forEach                \\n                temp[to] = Math.min(temp[to], dist[from] + cost)    \\n            }\\n            dist = temp\\n        }\\n        return if (dist[dst] == Int.MAX_VALUE) -1 else dist[dst]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860363,
                "title": "dijkstra-s-algorithm-beats-90",
                "content": "\\n# Code\\n```\\nclass Tuple\\n{\\n    int stops;\\n    int node;\\n    int dist;\\n    public Tuple(int s,int node,int dis)\\n    {\\n        stops=s;\\n        this.node=node;\\n        dist=dis;\\n    }\\n}\\nclass Pairs\\n{\\n    int stop;\\n    int distance;\\n    public Pairs(int s,int d)\\n    {\\n        stop=s;\\n        distance=d;\\n    }\\n}\\nclass Solution \\n{\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) \\n    {\\n        List<List<Pairs>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)  adj.add(new ArrayList<Pairs>());\\n\\n        for(int i=0;i<flights.length;i++)\\n            adj.get(flights[i][0]).add(new Pairs(flights[i][1],flights[i][2]));\\n        \\n        //since we use priorityQueue on K, which increaeses by K+1\\n        //we can use a queue instead of a PQ\\n        //the least K stays at the top\\n        //PQ adds extra time complexity\\n        Queue<Tuple> queue=new LinkedList<>();\\n        int[] dist=new int[n];\\n        Tuple start=new Tuple(0,src,0);\\n        queue.add(start);\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n\\n        while(!queue.isEmpty())\\n        {\\n            Tuple top=queue.peek();\\n            queue.remove();\\n            int stops=top.stops;\\n            int node=top.node;\\n            int distance=top.dist;\\n            for(Pairs curr : adj.get(node))\\n            {\\n                int destination=curr.stop;\\n                int amount=curr.distance;\\n                //reaching the destination dosent count as K+1\\n                if(stops<=k && dist[destination]>distance+amount)\\n                {\\n                    dist[destination]=distance+amount;\\n                    queue.add(new Tuple(stops+1,destination,distance+amount));\\n                }\\n            }\\n        }\\n        int ans=dist[dst];\\n        return (ans==Integer.MAX_VALUE) ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Tuple\\n{\\n    int stops;\\n    int node;\\n    int dist;\\n    public Tuple(int s,int node,int dis)\\n    {\\n        stops=s;\\n        this.node=node;\\n        dist=dis;\\n    }\\n}\\nclass Pairs\\n{\\n    int stop;\\n    int distance;\\n    public Pairs(int s,int d)\\n    {\\n        stop=s;\\n        distance=d;\\n    }\\n}\\nclass Solution \\n{\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) \\n    {\\n        List<List<Pairs>> adj=new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)  adj.add(new ArrayList<Pairs>());\\n\\n        for(int i=0;i<flights.length;i++)\\n            adj.get(flights[i][0]).add(new Pairs(flights[i][1],flights[i][2]));\\n        \\n        //since we use priorityQueue on K, which increaeses by K+1\\n        //we can use a queue instead of a PQ\\n        //the least K stays at the top\\n        //PQ adds extra time complexity\\n        Queue<Tuple> queue=new LinkedList<>();\\n        int[] dist=new int[n];\\n        Tuple start=new Tuple(0,src,0);\\n        queue.add(start);\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n\\n        while(!queue.isEmpty())\\n        {\\n            Tuple top=queue.peek();\\n            queue.remove();\\n            int stops=top.stops;\\n            int node=top.node;\\n            int distance=top.dist;\\n            for(Pairs curr : adj.get(node))\\n            {\\n                int destination=curr.stop;\\n                int amount=curr.distance;\\n                //reaching the destination dosent count as K+1\\n                if(stops<=k && dist[destination]>distance+amount)\\n                {\\n                    dist[destination]=distance+amount;\\n                    queue.add(new Tuple(stops+1,destination,distance+amount));\\n                }\\n            }\\n        }\\n        int ans=dist[dst];\\n        return (ans==Integer.MAX_VALUE) ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826119,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        queue<array<int,3>> pq;\\n        \\n        pq.push({0,src,0});\\n        \\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        vector<vector<int>> adj[n];\\n        \\n        for(auto i : flights)\\n        {\\n            int x = i[0], y = i[1], wt = i[2];\\n            \\n            adj[x].push_back({y,wt});\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto node = pq.front();\\n            pq.pop();\\n            \\n            int u = node[1];\\n            int steps = node[2];\\n            int d = node[0];\\n            \\n            if(steps>k)\\n                continue;\\n            \\n            for(auto i : adj[u])\\n            {\\n                int v = i[0];\\n                int wt = i[1];\\n                \\n                if(dist[v] > wt+d && steps<=k)\\n                {\\n                    dist[v] = wt+d;\\n                    pq.push({dist[v],v,steps+1});\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        return dist[dst] == 1e9 ? -1 : dist[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) \\n    {\\n        queue<array<int,3>> pq;\\n        \\n        pq.push({0,src,0});\\n        \\n        vector<int> dist(n,1e9);\\n        dist[src] = 0;\\n        vector<vector<int>> adj[n];\\n        \\n        for(auto i : flights)\\n        {\\n            int x = i[0], y = i[1], wt = i[2];\\n            \\n            adj[x].push_back({y,wt});\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto node = pq.front();\\n            pq.pop();\\n            \\n            int u = node[1];\\n            int steps = node[2];\\n            int d = node[0];\\n            \\n            if(steps>k)\\n                continue;\\n            \\n            for(auto i : adj[u])\\n            {\\n                int v = i[0];\\n                int wt = i[1];\\n                \\n                if(dist[v] > wt+d && steps<=k)\\n                {\\n                    dist[v] = wt+d;\\n                    pq.push({dist[v],v,steps+1});\\n                    \\n                }\\n            }\\n        }\\n        \\n        \\n        return dist[dst] == 1e9 ? -1 : dist[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808078,
                "title": "c-max-heap-solution-dijkstra-s-algorithm",
                "content": "\\n**<<<<<<<UpVote**\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto flight : flights){\\n            adj[flight[0]].push_back({flight[1],flight[2]});\\n        }\\n        // {distance,{destination,stops}}\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        pq.push({0,{src,0}});\\n        vector<int> distance(n+1,1e9);\\n        distance[src]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int dist= it.first;\\n            int curLoc=it.second.first;\\n            int stops=it.second.second;\\n            pq.pop();\\n            for(auto loc : adj[curLoc] ){\\n                if((dist+loc.second) < distance[loc.first] && (stops+1)<=k+1){\\n                    distance[loc.first]=dist+loc.second;\\n                    pq.push ({distance[loc.first],{loc.first,stops+1}});\\n                    \\n                }\\n            }\\n        }\\n        return  distance[dst]==1e9?-1:distance[dst];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<pair<int,int>> adj[n];\\n        for(auto flight : flights){\\n            adj[flight[0]].push_back({flight[1],flight[2]});\\n        }\\n        // {distance,{destination,stops}}\\n        priority_queue<pair<int,pair<int,int>>> pq;\\n        pq.push({0,{src,0}});\\n        vector<int> distance(n+1,1e9);\\n        distance[src]=0;\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int dist= it.first;\\n            int curLoc=it.second.first;\\n            int stops=it.second.second;\\n            pq.pop();\\n            for(auto loc : adj[curLoc] ){\\n                if((dist+loc.second) < distance[loc.first] && (stops+1)<=k+1){\\n                    distance[loc.first]=dist+loc.second;\\n                    pq.push ({distance[loc.first],{loc.first,stops+1}});\\n                    \\n                }\\n            }\\n        }\\n        return  distance[dst]==1e9?-1:distance[dst];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2435316,
                "title": "standard-bellman-ford-algo-easy-explanation",
                "content": "Idea behind Belloman ford algorithm:\\n\\t**If a vertex is `k` edges away from source, it\\'s shortest path can found in `k` iterations (or Ralaxes).**\\n\\nAlgorithm:\\n`Instead N-1 iterate for k+1 (because for k stops there will be k+2 nodes in the path from src to dst).`\\n\\nwe took temp array in code to store distance because we only have to update distance of node if it is atmost i away.\\nEx. let\\'s say edegs 1->2 and 2->3\\nif we dont take temp array then in the first iteration itself distance of node 3 will get updated, As when 2->3 edge come distance of node 2 is already updated.\\n\\n\\nPlease upvote if it helps!!\\n\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        for(int i=0; i<=k; i++) {\\n            vector<int> temp(dist);\\n            for(auto &e: flights) {\\n                int u = e[0], v = e[1], w = e[2];\\n                if(dist[u] != INT_MAX && temp[v] > dist[u] + w) temp[v] = dist[u] + w;\\n            }\\n            dist = temp;\\n        }\\n        //please upvote!\\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        vector<int> dist(n, INT_MAX);\\n        dist[src] = 0;\\n        for(int i=0; i<=k; i++) {\\n            vector<int> temp(dist);\\n            for(auto &e: flights) {\\n                int u = e[0], v = e[1], w = e[2];\\n                if(dist[u] != INT_MAX && temp[v] > dist[u] + w) temp[v] = dist[u] + w;\\n            }\\n            dist = temp;\\n        }\\n        //please upvote!\\n        return dist[dst] == INT_MAX ? -1 : dist[dst];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564581,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1704521,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774750,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1714552,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774778,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1574329,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1566952,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1567042,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774631,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1775170,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1564581,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1704521,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774750,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1714552,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774778,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1574329,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1566952,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1567042,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1774631,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1775170,
                "content": [
                    {
                        "username": "jerryvikram",
                        "content": "Just a fun post. Did you notice the problem #. \"787\" --> Cheapest Fligths :-P"
                    },
                    {
                        "username": "djslim",
                        "content": "[@binitkumar0911](/binitkumar0911) Popular US aircraft made by boeing"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "[@hosua](/hosua) \\uD83D\\uDE05"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "787 aint cheap ... but 737 is"
                    },
                    {
                        "username": "hosua",
                        "content": "[@binitkumar0911](/binitkumar0911)  Boeing 787 Dreamliner\\n"
                    },
                    {
                        "username": "binitkumar0911",
                        "content": "787 ? what\\'s special about it?"
                    },
                    {
                        "username": "xychen11214",
                        "content": "This problem should be labeled hard!"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Its kind of easy if done with DP.... no need of heaps as well"
                    },
                    {
                        "username": "thewildnath",
                        "content": "[@ved20](/ved20) That would normally be true, but as we are still bound by K stops, I believe it would actually be the same problem."
                    },
                    {
                        "username": "ved20",
                        "content": "[@L39ND](/L39ND) if a price can be less than 0, then there is a possibility of a negative weight cycle existing in the graph, so no solution would exist since we could keep going around the cycle to reduce the price down to negative infinity."
                    },
                    {
                        "username": "qiushile",
                        "content": "[@L39ND](/L39ND) 666"
                    },
                    {
                        "username": "L39ND",
                        "content": "[@qiushile](/qiushile) if price can be less than zero it will prob be the same approach cus its still interger+/-, and who doesnt want free money lol "
                    },
                    {
                        "username": "qiushile",
                        "content": "If the price less than zero, might be hard"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Happy Republic Day!!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Jai Hind!"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "This question is hard even if you know dijkstras. it\\'s very easy to mess up in an interview with limited time"
                    },
                    {
                        "username": "2uringTested",
                        "content": "You dont even need to know dijkstra or any other graph algorithm for that matter for this question. Its a simple DP question, might not be the most optimal approach with DP but definitely passes the test cases. O(V*k)\\n \\n\\n```\\nclass Solution {\\npublic: \\n\\n    using vvp = vector<vector<pair<int,int>>>;\\n    using vvi = vector<vector<int>>;\\n\\n    vvp adjList;\\n    vvi dp;\\n    int dstn;\\n\\n    int rec(int src,int k){ // will return the best price for going from src to destination with at max k stops in between\\n\\n        //pruning:\\n        if(k<0) return 1e9;\\n\\n        //base case:\\n        if(src == dstn){\\n            return 0;\\n        }\\n\\n        //cache check:\\n        if(dp[src][k]!=-1) return dp[src][k];\\n\\n        //computations:\\n        int ans = 1e9;\\n        for(auto child: adjList[src]){\\n\\n            int city = child.first;\\n            int cost = child.second;\\n\\n            if(city==dstn) ans = min(ans,cost+rec(city,k));\\n            else ans = min(ans,cost + rec(city,k-1));\\n        }\\n\\n        //save and return:\\n        return dp[src][k] = ans;\\n    }\\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        \\n        dstn = dst;\\n        adjList = vvp(n);\\n        dp = vvi(n+1,vector<int>(k+1,-1));\\n\\n        for(auto &flight: flights){\\n            int x = flight[0];\\n            int y = flight[1];\\n            int cost = flight[2];\\n            pair<int,int> temp = {y,cost};\\n            adjList[x].push_back(temp);\\n        }\\n\\n        int ans = rec(src,k);\\n        if(ans == 1e9) return -1;\\n        return rec(src,k);\\n        \\n    }\\n};\\n\\n```\\n"
                    },
                    {
                        "username": "rezwan_09",
                        "content": "Yes! you have to modify Dijkstra and fail several times to find out the inner details\\n"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "ye graph khatam kahe nhi hota be?"
                    },
                    {
                        "username": "youssef19",
                        "content": "Java Solution provided did not pass this test case \\n\\n11\\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\\n0\\n2\\n4"
                    },
                    {
                        "username": "pbu",
                        "content": "did anyone notice this peculiar coincidence ?\\n\\ncheers"
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@pieceofpie](/pieceofpie) 787 being a plane, Boing 787 to be exact, and the problem number being 787. xD"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What is the coincidence? Can't find it..."
                    },
                    {
                        "username": "nishant_chhattani",
                        "content": "Could not find a optimized version of BFS for this solution , getting TLE on a case that is included recently ,all the BFS solutions are getting TLE on that testcase."
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@guptatanish145](/guptatanish145) thanks buddy..!! "
                    },
                    {
                        "username": "guptatanish145",
                        "content": "[@miteshkhemani8](/miteshkhemani8)  your thought process is amazing !!"
                    },
                    {
                        "username": "miteshkhemani8",
                        "content": "[@kaustubh4](/kaustubh4) \\n\\nWell....you are wrong.\\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        // controlled bfs\\n        vector<vector<pair<int,int>>> adjList(n);\\n        for(vector<int> &e : flights) {\\n            adjList[e[0]].push_back({e[1],e[2]});\\n        }\\n        vector<int> cost(n,INT_MAX);\\n        cost[src] = 0;\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        int level = 0;\\n        while(level <= k && !q.empty()) {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++) {\\n                int node = q.front().first;\\n                int baseCost = q.front().second;\\n                q.pop();\\n                for(auto &[des,price] : adjList[node]) {\\n                    if(baseCost + price <= cost[des]) {\\n                        q.push({des,baseCost + price});\\n                        cost[des] = baseCost + price;\\n                    }\\n                }\\n            }\\n            level ++;\\n        }\\n        if(cost[dst] == INT_MAX)\\n            return -1;\\n        return cost[dst];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "[@rammanoj](/rammanoj) While this is usually true, it actually doesn\\'t apply here. I\\'ve maxed out my time at 99.9% speed using BFS. DFS is great if the weights represent distance, but they don\\'t here (the price doesn\\'t seem to be a function of time at all). My biggest hint is to keep a \"buffer\" queue to defer updating values until after the current depth has been checked and then move the buffer to your main queue."
                    },
                    {
                        "username": "sentenzo",
                        "content": "I solved it with BFS after a fashion. To avoid TLE, you should pick not just any reachable node on each iteration, but only the nodes, where you get a better price than it was before (initially the price of each node is +infinity). \nOtherwise your nodes amount would increase exponentially (which probably causes TLE)."
                    },
                    {
                        "username": "rammanoj",
                        "content": "As [@kaustubh duraphe](/kaustubh4) pointed BFS is for unweighted graph. Try using DFS with memorization"
                    },
                    {
                        "username": "kaustubh4",
                        "content": "BFS should be used only to the unweighted graph. This problem is dealing with the weighted graph."
                    },
                    {
                        "username": "chees-e",
                        "content": "Smelling the beginning of series of directed graphs daily challenges... "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Here we go again"
                    },
                    {
                        "username": "saketsourav300",
                        "content": "Jai Shree Ram, flight is going to Ayodhya"
                    },
                    {
                        "username": "mochiball",
                        "content": "Jaa"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Jai Shree Ram !!!"
                    }
                ]
            },
            {
                "id": 1755433,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1775622,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1775341,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774793,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1575891,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1569551,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1775590,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774973,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774869,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774857,
                "content": [
                    {
                        "username": "just_another_leetcoder_11",
                        "content": "Seems like my BFS approach works and is accepted for this problem, but DFS gets a Time Limit Exceeded error. Could someone explain if it\\'s just because of the test case, or if BFS is just inherently better? \\n\\nI believe the amortized time complexity for both BFS and DFS should be the same, right?"
                    },
                    {
                        "username": "SuZs",
                        "content": "you can get stuck in a loop for DFS. In BFS, though you can be still in a loop, it will be broken by finding the actual solution. "
                    },
                    {
                        "username": "vsha96",
                        "content": "With standard BFS you will get TLE, here are tips for faster BFS\\n\\nTip1: if you see a node again, maybe you can compare with what minimum cost you can get to it?\\nTip2: n <= 100, it\\'s not that much to store all the costs for each node reached"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "One of the hardest question!"
                    },
                    {
                        "username": "jknagin",
                        "content": "From this problem I learned that you need to add the updated cost from the source to the current node into the queue with the node itself when you push a node to the queue. Tracking it separately doesn\\'t work."
                    },
                    {
                        "username": "JohnZhou98",
                        "content": "I don\\'t think dijstra algorithm would work here.\\nTake a look at this test case:\\n5\\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\\nstart: 0\\ngoal: 2\\nMaximum stops: 2\\n\\nThe fastest way would be to go from 0-> 3-> 1-> 4-> 2. But this would have 3 stops, and 3 stops won\\'t be allowed.\\nAs a result we have to settle for 0->5->1->4->2. But if we\\'re to use dijstra, this method will not be discovered because in dijstra only the fastest options are considered. But in this case, an actual dijstra doesn\\'t consider it since the path is slower, so it would never find this solution, instead it\\'d be skipped over since its less than the option that we already have.\\n\\nAs a result its not really dijstra because due to it having to reinsert the same already explored nodes into the heap again, it\\'d run a lot slower.\\n\\nCan you guys tell me if I\\'m right or wrong? Thanks.\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@thiscodeisugly](/thiscodeisugly) Thanks. This hint helped me. I was pq-ing around distance like usual. Passed 45/53 test cases. Changed to pq-ing around stops and it passed"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "I used Djikstra algo to find the solution and I ran the case it is working, see https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3100891/c-djikstra-algo-ove-algorithm/"
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "Actually it is a slight variation in Dijkstra\\'s. The distance that you calculate from the source has less priority than the number of stops and if you can build heap/PQ around num of stops, you can figure it out. (PS - as number of stops increase by +1 everytime, no need of PQ but just a normal Q suffices)."
                    },
                    {
                        "username": "Ttanlog",
                        "content": "I applied with you, I share my solution in bellman-ford"
                    },
                    {
                        "username": "seafmch",
                        "content": "Every PQ solution I look at enqueues PATHS. There are lots of paths. They add every possible path from src, as long as path len < k. This is O(v^k). Why? Because from src, we can choose to go to (v - 1) vertices. From there we can go to (v - 2) vertices... etc. Or maybe O(log(v^k)v^k) since the PQ size is v^k. What\\'s up with that? Why are these solutions accepted? Surely we can come up with something better that isn\\'t exponential.\\n\\nWe can\\'t just run Dijskstra, because the path length can be > k. We can\\'t BFS out from src by k layers and then prune the rest of the graph, because we can still get screwed by the actual path length being > k (implement it and try it, it won\\'t work). Unless there\\'s a more clever pruning technique I\\'m unaware of.\\n\\nIMO, this problem should disallow the naive v^k solution and then be upgraded to a Hard."
                    },
                    {
                        "username": "Tarab_Mojiz",
                        "content": "Can someone give a Tabulation DP approach from this memoization dp approach??? \\n\\n`int solve(unordered_map<int, vector<pair<int, int>>> &adj, int node, int dst, int k, int n, vector<vector<int>> &dp)\\n{\\n    if(node==dst)\\n    {\\n        return 0;\\n    }\\n    if(k<0)\\n    {\\n        return INT_MAX;\\n    }\\n    if(dp[node][k]!=-1)\\n    {\\n        return dp[node][k];\\n    }\\n    int ans=INT_MAX;\\n    for(auto it: adj[node])\\n    {\\n           int cost=solve(adj, it.first, dst, k-1, n, dp);\\n            if(cost==INT_MAX)\\n            {   \\n                continue;\\n            }\\n            ans=min(ans, it.second+ cost);\\n        \\n    }\\n    return dp[node][k]=ans;\\n}\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        unordered_map<int, vector<pair<int, int>>> adj;\\n        for(int i=0; i<flights.size(); i++)\\n        {\\n            adj[flights[i][0]].push_back(make_pair(flights[i][1], flights[i][2]));\\n        }\\n        int ans=0;\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        ans=solve(adj, src, dst, k, n, dp);        \\n        if(ans==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Whoever is trying to solve with dijkstra here is some advice :\\nJust added this 1 line\\nif(stop+1<=k+1) {                                   //<------ this line\\n    if(wt+dist<dis[adjNode]){\\n        dis[adjNode]=wt+dist;\\n        pq.add(new Pair(adjNode,dis[adjNode],stop+1));\\n}\\nand used queue instead of priority queue because in this \\nproblem K matters more than the shortest path."
                    },
                    {
                        "username": "s1ttu",
                        "content": "Happy Republic Day"
                    },
                    {
                        "username": "anshul_thakur69",
                        "content": "keep in mind that we need to prioritise no. of stops  more than path cost .\\nfirstly we need to check path with less stop then move for lowest cost."
                    }
                ]
            },
            {
                "id": 1774662,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1654496,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2064270,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2052131,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2050858,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2028947,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 2013521,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1973786,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1963735,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1958406,
                "content": [
                    {
                        "username": "gaijinpunch",
                        "content": "I have solutions that used to pass but no longer do.  Test cases clearly changed."
                    },
                    {
                        "username": "madhur_gupta",
                        "content": "Can You Tell What is wrong with my solution ?\\nclass Node {\\n    int src;\\n    int price;\\n\\n    Node(int src, int price){\\n        this.src = src;\\n        this.price = price;\\n    }\\n}\\n\\nclass Pair implements Comparable<Pair>{\\n    Node node;\\n    int numStop;\\n\\n    Pair(Node _node, int _numStop){\\n        this.node = _node;\\n        this.numStop = _numStop;\\n    }\\n\\n    @Override\\n    public int compareTo(Pair p){\\n        return this.node.price - p.node.price;\\n    }\\n}\\n\\nclass Solution {\\n    public int findCheapestPrice(int n, int[][] flights, int src, int dest, int k) {\\n       \\n        // Adjacency List....\\n       \\n        List<List<Node>> adj = new ArrayList<>();\\n        for(int i=0; i<n; i++) adj.add(new ArrayList<>());\\n\\n        for(int i=0; i<flights.length; i++) adj.get(flights[i][0]).add(new Node(flights[i][1], flights[i][2]));\\n\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        pq.offer(new Pair(new Node(src, 0), 0));\\n        \\n        int[] cost = new int[n];\\n        Arrays.fill(cost, (int)1e8);\\n        cost[src] = 0;\\n\\n        while(!pq.isEmpty()){\\n            Pair front = pq.poll();\\n        \\n            if(front.numStop > k) continue;\\n            for(Node nbr : adj.get(front.node.src)){\\n                if(cost[front.node.src] + nbr.price < cost[nbr.src] && front.numStop <= k) {\\n                    cost[nbr.src] = cost[front.node.src] + nbr.price;\\n                    pq.offer(new Pair(new Node(nbr.src, cost[nbr.src]), front.numStop+1));\\n                    \\n                }\\n            }\\n        \\n        }\\n\\n\\n        if(cost[dest] == (int)1e8) return -1;\\n        return cost[dest];\\n    }\\n}"
                    },
                    {
                        "username": "naveen17797",
                        "content": "n=3\\nflights = [[0,1,2], [1,2,1,], [2,0,10]]\\nsrc = 1, dst = 2 k=1\\nhow is the expected output 1 ?  there is literally no stops between 1 to 2, its just an edge"
                    },
                    {
                        "username": "archerfx",
                        "content": "Please help. Why isn\\'t this working? \\n```\\nclass Solution {\\npublic:\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        int inf = 1000000007;\\n\\n        // u -> {v, cost}\\n        vector<vector<pair<int, int>>> adj(n);\\n\\n        for (int i =0; i < flights.size(); i++) {\\n            adj[flights[i][0]].push_back({flights[i][1], flights[i][2]});\\n        }\\n\\n        vector<int> cost(n, inf);\\n\\n        cost[src] = 0;\\n\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, \\n            greater<pair<int, pair<int, int>>>> pq;\\n\\n        // {cost, {index, stops}}\\n        pq.push({0, {src, -1}});\\n\\n        while (!pq.empty()) {\\n            pair<int, pair<int, int>> cur = pq.top();\\n            pq.pop();\\n\\n            int u = cur.second.first;\\n            int stops = cur.second.second;\\n            if (stops >= k) continue;\\n\\n            for (int i = 0;  i < adj[u].size(); i++) {\\n                int nextCost = adj[u][i].second;\\n                int v = adj[u][i].first;\\n\\n                if (nextCost + cur.first < cost[v]) {\\n                    cost[v] = cur.first + nextCost;\\n                    pq.push({cost[v], {v, stops+1}});\\n                }\\n            }\\n        }\\n\\n        if (cost[dst] >= inf) return -1;\\n\\n        return cost[dst];\\n\\n    }\\n};\\n```"
                    },
                    {
                        "username": "mochiball",
                        "content": "Tough problem. I was able to solve it using just a Queue instead of Dijkstras but for anyone struggling : # of stops takes priority"
                    },
                    {
                        "username": "shrutiverma123",
                        "content": "Can someone tell me what\\'s the issue with my code?\\nI am getting TLE beyond n = 16\\n\\n\\n `class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\\n        cost = [math.inf]*(k+1)\\n    \\n        def dfs(s,stop,amount):\\n            if stop <= k:\\n                if s == dst: # reached the destination \\n                    cost[stop] = min(amount,cost[stop])\\n                    return cost[stop]\\n                      \\n            else:\\n                return math.inf\\n            \\n            for f in flights:\\n                if f[0] == s:\\n                    dfs(f[1],stop+1,amount+f[2])\\n            \\n            return cost[stop]\\n\\n        dfs(src,-1,0) # I am assuming it will give the smallest fare\\n        \\n        costMin = min(cost)\\n        print(cost)\\n        return -1 if costMin == math.inf else costMin`"
                    },
                    {
                        "username": "Gismet",
                        "content": "You can think of this problem as follows:\\nWe are limited to k stops on every path from src to dest. If k = 2, then we can stop two times, that means two edges and with src and dest, it makes a total of 4 nodes. That means any valid simple path in which we can reach dest at most k stops will have 4 nodes or 3 edges. So we shouldn\\'t traverse  a path which has more than 4 nodes. \\nThink about this one. If the problem had said you should find the shortest distance from src to dest, you could have used the Dijkstra\\'s algorithm for shortest path and that would have worked totally fine. But we are constrained by the number of stops we can have. So that makes the problem a little bit different. We might have the shortest path but if the number of stops on that path exceed the number of allowed stops, then even though it has the shortest distance from src to dest, it is not a valid path. \\nNow think about this. Let\\'s assume that we are given a graph in which every simple path from src to dest has at most k stops, or in other words every path is valid. That means you can take any path from src to dest, it will surely take you to the destination at most k stops. In this case we are not actually constrained by the number of stops anymore. Therefore the Dijkstra\\'s algorithm would work. That hints at the fact that we can actually use Dijkstra\\'s algorithm here with the added logic of handling stops. \\nSuppose this. If you have two adjacent nodes to the destination node, (what I meant by adjacent nodes is two nodes leading to destination node) then every path to the destination node must pass through these two nodes. So if we can reach these two nodes in k - 1 stops, then we can certainly reach the destination node. With this idea, it can be solved with Dijkstra\\'s algorithm. Thanks for reading. Happy conding. "
                    },
                    {
                        "username": "aisha96",
                        "content": "Can someone explain why we should ignore nodes if we have visited them earlier with fewer steps? Can we not visit them with more steps but lead to lower cost?"
                    },
                    {
                        "username": "saurabh134741",
                        "content": "Could be a hard type problem. Getting TLE with a dfs solution. Need to find out more."
                    },
                    {
                        "username": "stuartYoung_",
                        "content": "This question is like  Dijkstra with constraints"
                    }
                ]
            },
            {
                "id": 1951494,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1932453,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1919808,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1886820,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1870785,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1844052,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1842309,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1821968,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1814208,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1803634,
                "content": [
                    {
                        "username": "f20210727",
                        "content": "class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int,int>>> adj(n);\n        for(int i = 0; i < flights.size(); i++) {\n            int start = flights[i][0];\n            int end = flights[i][1];\n            int price = flights[i][2];\n            adj[start].push_back({end, price});\n        }\n\n        vector<int> vis(n, 0);\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, \n            greater<pair<int,pair<int,int>>>> pq;\n        pq.push({0, {0, src}});\n        int mini = 1e9;\n        vis[src]=1;\n        while(!pq.empty()) {\n            int steps = pq.top().first;\n            int price = pq.top().second.first;\n            int val = pq.top().second.second;\n            pq.pop();\n\n            if(val == dst && steps <= k) {\n                mini = min(mini, price);\n            }\n\n            if (steps > k) {\n                continue;\n            }\n\n            for(auto m : adj[val]) {\n                if((vis[m.first] == 0 && m.first != dst) || m.first == dst) {\n                    vis[m.first] = 1;\n                    int cost = price + m.second;\n                    if(m.first != dst)\n                        pq.push({steps+1, {cost,m.first}});\n                    else\n                        pq.push({steps, {cost, m.first}});\n                }\n            }\n        }\n\n        if(mini != 1e9) {\n            return mini;\n        }\n        return -1;\n    }\n};\nWhat's wrong  with  my code.It fails test case 44.I did a dry run. It seems fine.\nn=11\n[[0,3,3],[3,4,3],[4,1,3],[0,5,1],[5,1,100],[0,6,2],[6,1,100],[0,7,1],[7,8,1],[8,9,1],[9,1,1],[1,10,1],[10,2,1],[1,2,100]]\nsrc=0\ndst=2\nk=4"
                    },
                    {
                        "username": "r1r14d",
                        "content": "In a graph, If the number of nodes is N, To reach from src to destination, the longest number of edges it can take to reach from src to dest can be atmost N-1 edges (given graph with no negative-weight cycles, this question doesn\\u2019t not have them)\\n\\n#Relaxing means find an edge through which the distance of a node is smaller than the previously stored value, it uses this edge and stores the new value.\\n\\nIn Bellman ford, we hence relax  the edges K-1 times, as the longest distance between source and dest can be through N-1 edges and that itself can be the shortest distance\\n\\nBut we are only allowed to stop at K nodes, we are not allowed to see all N nodes\\n#the nodes we can pass through are K + src node + destination node. Hence, we have to relax (K + src node + destination node) - 1 edges\\n#i.e. (K+2)-1 = K+1 edges need to be relaxed"
                    },
                    {
                        "username": "neshvig10",
                        "content": "class Solution {\\npublic:\\n\\n\\n    vector <pair<long long int,long long int>> graph[101];\\n    int dst1;\\n    int src1;\\n    int k1;\\n\\n    vector <pair<long long int,long long int>> dp[101];\\n\\n    vector <pair<long long int,long long int>> func(int vertex,int st)\\n    {\\n        if (vertex==dst1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({0,st});\\n            return temp;\\n        }\\n\\n        if (st>k1)\\n        {\\n            vector <pair<long long int,long long int>> temp;\\n            temp.push_back({INT_MAX,st});\\n            return temp;\\n        }\\n\\n        if (dp[vertex].size())\\n        {\\n            vector <pair<long long int,long long int>> v2;\\n            for (auto x : dp[vertex])\\n            {\\n                if(st+x.second+1<=k1)\\n                {\\n                    v2.push_back({x.first,st+x.second-2});\\n                }\\n            }\\n            return v2;\\n        }\\n\\n\\n        vector <pair<long long int,long long int>> temp;\\n        for (auto x : graph[vertex]){\\n            vector <pair<long long int,long long int>> temp2=func(x.first,st+1);\\n            for (auto y : temp2)\\n            {\\n                if (y.first+x.second<INT_MAX)\\n                {\\n                    temp.push_back({y.first+x.second,y.second-(st)});\\n                }\\n            } \\n        }\\n        return dp[vertex]=temp;\\n    }\\n\\n    \\n    \\n\\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\\n        dst1=dst;\\n        src1=src;\\n        k1=k;\\n        // memset(dp,-1,sizeof(dp));\\n        for (auto x : flights)\\n        {\\n            graph[x[0]].push_back({x[1],x[2]});\\n            // graph[x[1]].push_back({x[0],x[2]});\\n        }\\n        \\n        vector <pair<long long int,long long int>> vans=func(src,0);\\n        long long int ans=INT_MAX;\\n        for (auto x : vans)\\n        {\\n            if (x.second<=k+1)\\n            {\\n                ans=min(ans,x.first);\\n            }\\n            cout<<x.first<<endl;\\n            \\n        }\\n        if (ans==INT_MAX)\\n            {\\n                ans=-1;\\n            }\\n        return ans;\\n\\n        \\n    }\\n};\\n\\nwhy is this code wrong ?"
                    },
                    {
                        "username": "jamesli789",
                        "content": "This was definitely one of the hardest medium problems I\\'ve ever done, took me a whole evening."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Fuck Djkstra\\'s solve using bellman ford!"
                    },
                    {
                        "username": "apkharsh",
                        "content": " Why my code is not working??\n```\nint findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        // first we need an adjacency list to store connections and weights\n        vector<vector<pair<int,int>>> adj(n);\n\n        for(auto it: flights){\n            adj[it[0]].push_back({it[1], it[2]});\n        }\n\n        // distance array to store the minimum distance for all nodes\n        vector<int> distance(n, 1e9);\n        distance[src] = 0;\n\n        // {stops,{node,dist}} for storing all nodes along with stops it took to reach them there\n        queue<pair<int,pair<int,int>>> nodes;\n        nodes.push({0, {src, 0}});\n\n        while(nodes.size()>0){\n            auto temp = nodes.front();\n            nodes.pop();\n\n            int stops = temp.first;\n            int parent = temp.second.first;\n            int cost = temp.second.second;\n\n            for(auto it: adj[parent]){\n\n                int child = it.first;\n                int pToC = it.second; // parent se child pe visit karne ki cost\n                \n                if(stops>k) continue;\n                // if(distance[parent] + pToC < distance[child] && stops<=k){\n                if(distance[parent] + pToC < distance[child]){\n                // if(cost + pToC < distance[child]){\n                    // if(stops==k && child!=dst) continue;\n                    distance[child] = distance[parent] + pToC;\n                    nodes.push({stops + 1, {child, distance[child]}});\n                }\n            }\n        }\n        if(distance[dst] != 1e9) return distance[dst];\n        return -1;\n    }\n```"
                    },
                    {
                        "username": "onurerkinsucu",
                        "content": "If BFS could be implemented for weighted graphs, and BFS provides better time complexity than Dijkstra, then why would anyone choose Dijkstra over BFS?"
                    },
                    {
                        "username": "ninja-power",
                        "content": "I was able to identify the solution for the problem statement but my solution is failing at the testcase number 41. I slept over my solution for 2 days but now I would really appreciate if someone can help me understand why it is failing?\\n\\n```\\ntype city struct {\\n    id int\\n    cost int\\n}\\n\\nfunc findCheapestPrice(n int, flights [][]int, src int, dst int, k int) int {\\n    adjList := make(map[int][]city)\\n\\n    for _, flight := range flights {\\n        s := flight[0]\\n        d := flight[1]\\n        c := flight[2]\\n\\n        adjList[s] = append(adjList[s], city{id: d, cost: c})\\n    }\\n\\n    result := math.MaxInt\\n    visited := make([]bool, n)\\n    queue := list.New()\\n    queue.PushBack([]int{src, 0})\\n\\n    for k >= 0 {\\n        cities := queue.Len()\\n\\n        if cities == 0 {\\n            break\\n        }\\n\\n        for i := 0; i < cities; i++ {\\n            currCity := queue.Remove(queue.Front()).([]int)\\n            s := currCity[0]\\n            c := currCity[1]\\n\\n            if visited[s] {\\n                continue\\n            }\\n\\n            visited[s] = true\\n\\n            for _, adjCity := range adjList[s] {\\n                if visited[adjCity.id] {\\n                    continue\\n                }\\n\\n                newCost := c + adjCity.cost\\n                \\n                if newCost >= result {\\n                    continue\\n                }\\n\\n                if adjCity.id == dst {\\n                    result = min(result, newCost)\\n                }\\n\\n                queue.PushBack([]int{adjCity.id, newCost})\\n            }\\n        }\\n\\n        k--\\n    }\\n\\n    if result == math.MaxInt {\\n        return -1\\n    }\\n\\n    return result\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```\\n\\nTestCase\\n\\nn = 15\\nflights = [[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]\\nsrc = 1\\ndst = 4\\nk = 10\\n\\nexpected output = 169\\nmy output = 231"
                    },
                    {
                        "username": "jainams6160",
                        "content": "got tle on the following memoization code\ncan someone please provide the reason and the time complexity aswell\n### the code is in java\n### i think the complexity would be O(n*k)\n\n```java\nclass Pair{\n       // l.one stores the index to where the arraylist's index goes to and l.two will store the cost\n        int one, two;\n        Pair(int one, int two){\n            this.one = one;\n            this.two = two;\n        }\n    }\n\n    static int dfs(ArrayList<ArrayList<Pair>> adj, int[][]dp, int index, int k, int cost, int dest){\n        if(k < 0)\n            return (int)1e9;\n        \n        if(index == dest)\n            return 0;\n            \n        if(dp[index][k] != (int)1e9)\n            return dp[index][k];\n\n        for(Pair l : adj.get(index)){\n            dp[index][k] = Math.min(l.two + dfs(adj, dp, l.one, k-1, cost+l.two, dest), dp[index][k]);\n        }\n        return dp[index][k];\n    }\n\n\npublic int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        ArrayList<ArrayList<Pair>> adj = new ArrayList<>();\n        for(int i =0;i<n;i++)\n            adj.add(new ArrayList<>());\n        for(int[] x : flights)\n            adj.get(x[0]).add(new Pair(x[1], x[2]));\n\n        int dp[][] = new int[n][k+2];\n        for(int x[] : dp)\n            Arrays.fill(x, (int)1e9);\n\n        int ans = dfs(adj, dp, src, k+1, 0, dst);\n        return ans == 1e9?-1 : ans;\n    }"
                    },
                    {
                        "username": "NamanMalhotra",
                        "content": "i did this problem using set or priority queue its giving me wrong answer  but by using queue its giving correct solution!! can anyone explain why so???"
                    }
                ]
            },
            {
                "id": 1779717,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775728,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775567,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775557,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775546,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775541,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775282,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775173,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775159,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775110,
                "content": [
                    {
                        "username": "himanshurajput",
                        "content": "The findCheapestPrice function takes in 5 parameters: an integer n, a 2D vector of integers flights, representing the edges in a graph, an integer src representing the source node, an integer dst representing the destination node, and an integer k representing the maximum number of stops allowed.\\nThe function initializes a 1D vector dist of size n, with all elements set to the maximum integer value. The distance from the source node to itself is set to 0.\\nThe function then enters a for loop that runs k+1 times. In each iteration, a temporary vector temp is created and initialized with the current values of the dist vector.\\nThe function then iterates through the flights vector and for each edge represented by e, it checks whether the distance from the source node to the starting node of the edge is not the maximum integer value. If it is, the function continues to the next edge.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nIf the distance is not the maximum integer value, the function checks if the distance to the ending node of the edge, plus the weight of the edge, is less than the current distance to that node. If it is, the new distance is set to the temporary vector temp.\\nAfter all edges have been considered, the temporary vector temp is copied over to the dist vector.\\nAfter the for loop has completed, the function checks whether the distance to the destination node is still the maximum integer value. If it is, the function returns -1, indicating that it is not possible to reach the destination node. Otherwise, it returns the distance to the destination node."
                    },
                    {
                        "username": "conanjoey",
                        "content": "I am using Python, If I use pop(), it does not pop correctly. If I use popleft(), it works well. Does anyone know why this is happening?\n\nThe case is below:\n5\n[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]\n0\n2\n2\n\nHere is my solution\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n\n        flights_dic = collections.defaultdict(list)\n        for fr, to, price in flights:\n            flights_dic[fr].append([to, price])\n\n        stops = 0\n\n        q = collections.deque([])\n        q.append([src, 0])\n\n        dist = [math.inf]*n\n\n        while q and stops<=k:\n            size = len(q)\n            for i in range(size):\n                cur_node, cur_price = q.pop()\n                for to, next_price in flights_dic[cur_node]:\n                    if cur_price + next_price >= dist[to]:\n                        continue\n                    dist[to] = cur_price + next_price\n                    q.append([to, dist[to]])\n            \n            stops += 1\n        if dist[dst] == math.inf:\n            return -1\n        return dist[dst]"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Why this is not hard!! It took away my sleep!!"
                    },
                    {
                        "username": "shikherjaiswal",
                        "content": "I will use this algorithm during my euro trip"
                    },
                    {
                        "username": "amandikshit10",
                        "content": "Why backtracking will fail here ?\\n"
                    },
                    {
                        "username": "Biniyamseid",
                        "content": "\"\"\"\n'''  \nwhy is this solution not working\n \n'''  \n'''\n\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        graph = defaultdict(list)\n        for i,j,l in flights:\n            graph[i].append([j,l])\n        minm = float(\"inf\")\n        def dfs(source,distance,visited,deepth,k):\n            nonlocal minm\n            if source == dst and deepth <= k+2:\n                print(deepth,k)\n                minm = min(minm,distance)\n\n            neighbour = graph[source]\n            for node in neighbour:\n                nodeval,distance1 = node\n                if nodeval not in visited:\n                    visited.add(nodeval)\n                    deepth += 1\n                    distance +=  distance1\n                    dfs(nodeval,distance,visited,deepth,k)\n        visited = set()\n        dfs(src,0,visited,0,k)\n        return minm if minm != float(\"inf\") else -1 \n'''\n\"\"\""
                    },
                    {
                        "username": "dhananjaykumar13092001",
                        "content": "why a dfs solution did not work here ?(gives TLE) \\n "
                    },
                    {
                        "username": "duarauddipon",
                        "content": "Same here. Tried memoization. But it will only give outOfMemoryError"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Loop"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "NOT GOOD WITH GRAPHS YET\\uD83D\\uDE22"
                    },
                    {
                        "username": "AMerrill",
                        "content": "You\\'ll get there! I had a hard time at the beginning, but you\\'ll get the hang of it."
                    },
                    {
                        "username": "Ur_or",
                        "content": "Good day!\\nYou have an inconsistency in the constraint condition on the input data. The last constraint point (src != dst) says that there must be at least 2 cities (2 <= n). This is a contradiction to the first point."
                    },
                    {
                        "username": "AMerrill",
                        "content": "No inconsistency. There just won\\'t be any flights if you only have 1 city."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "  \\n         class Solution:\\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:\\n        if not flights or not flights[0]:\\n            return -1\\n        res = [float(\\'inf\\')] * n\\n        grid = collections.defaultdict(list)\\n        for s, d, c in flights:\\n            grid[s].append([d, c])\\n        \\n        heap = [(0,src,0)] \\n        while heap:\\n            Cost, subS, visit = heap.pop(0)\\n            if res[subS] <= Cost or (visit > K and subS != dst): \\n                continue\\n\\n            res[subS] = Cost\\n            for nextDst, nextCost in grid[subS]: \\n                heap.append((Cost + nextCost, nextDst, visit + 1))\\n        \\n        return -1 if res[dst] == float(\\'inf\\') else res[dst]"
                    }
                ]
            },
            {
                "id": 1775092,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1775069,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1775037,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1775020,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774954,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774950,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774847,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774810,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774807,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            },
            {
                "id": 1774801,
                "content": [
                    {
                        "username": "xuyang21",
                        "content": "In the Dijkstra solution, It will encounter TLE if remove the \"stops\" array."
                    },
                    {
                        "username": "xogeetesh",
                        "content": "Happy Republic Day \\uD83C\\uDDEE\\uD83C\\uDDF3 "
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/787_Cheapest_Flights_Within_K_Stops.cpp\\n\\nLEAVE A STAR"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "seems a hard problem. with dfs+dp it seems easy who knows dp. Rest of all it\\'t not a medium problem.\\nanother solution with dijkstra maybe easy for some people.Though it\\'s not an easy algorithm.\\nPlease avoid sharing code in discussion session."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "Can this be solved in minimum paths algo ?"
                    },
                    {
                        "username": "xuyang21",
                        "content": "Got TLE on Go DFS Solution"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Can cycles exist?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Arghya Das](/arghyadas)Yes, from the 1st sample test case we can conclude that cycles may exist."
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "why not just bfs can anyone explain what it lacks to solve this?\\n"
                    },
                    {
                        "username": "dgrantpete",
                        "content": "BFS works great for this problem. You just have to keep the following in mind:\\n\\n1. It is critical to track the current depth of your node. I did this by using two alternating queues (and increasing the depth each time the queue was empty).\\n2. Ensure that the prices to each node aren\\'t updated until after the current depth is checked all the way. This one gave me a big headache in debugging...\\n3. Terminate immediately once depth exceeds `k + 1`"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Happy Republic Day from dijkstras:)"
                    },
                    {
                        "username": "Panda_2397",
                        "content": "this question is not that difficult if you know bellman ford algorithm.\\n\\nPlease note that K stops mean: there are K + 2 points in total. So K - 1 edges is passed through"
                    }
                ]
            }
        ]
    },
    {
        "title": "N-th Tribonacci Number",
        "question_content": "<p>The Tribonacci sequence T<sub>n</sub> is defined as follows:&nbsp;</p>\r\n\r\n<p>T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, and T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub> for n &gt;= 0.</p>\r\n\r\n<p>Given <code>n</code>, return the value of T<sub>n</sub>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 4\r\n<strong>Output:</strong> 4\r\n<strong>Explanation:</strong>\r\nT_3 = 0 + 1 + 1 = 2\r\nT_4 = 1 + 1 + 2 = 4\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> n = 25\r\n<strong>Output:</strong> 1389537\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>0 &lt;= n &lt;= 37</code></li>\r\n\t<li>The answer is guaranteed to fit within a 32-bit integer, ie. <code>answer &lt;= 2^31 - 1</code>.</li>\r\n</ul>",
        "solutions": [
            {
                "id": 345236,
                "title": "java-c-python-easy-and-concise",
                "content": "# Explanation\\nCalculate next element `d = a + b + c`,\\nlet `(a,b,c) = (b,c,d)`.\\nRepeat this process `n - 2` times;\\n\\nWe can loop `n` times and return `i0`.\\nIt can remove the special cases for `n < 2`.\\nBut I did `n - 2` loop on purpose.\\n`i1` and `i2` will get overflow.\\nThough it won\\'t throw an error in Java. Hardly say it\\'s a right answer.\\n\\nA possibly better solution is to start with the number before i0,i1,i2.\\nAs I did in python,\\n`i[-2] = 1`\\n`i[-1] = 1`\\n`i[0] = 0`\\nThen it won\\'t have this problem.\\n\\n# Complexity\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n# Solution 1\\n**Java:**\\n```java\\n    public int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d;\\n        while (n-- > 2) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        return c;\\n    }\\n```\\n**C++:**\\n```cpp\\n    int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d = a + b + c;\\n        while (n-- > 2) {\\n            d = a + b + c, a = b, b = c, c = d;\\n        }\\n        return c;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in xrange(n): a, b, c = b, c, a + b + c\\n        return c\\n```\\n\\n# Solution 2\\nSuggested by @modusV\\n**Java:**\\n```java\\n    public int tribonacci(int n) {\\n        int dp[] = {0, 1, 1};\\n        for (int i = 3; i <= n; ++i)\\n            dp[i % 3] = dp[0] + dp[1] + dp[2];\\n        return dp[n % 3];\\n    }\\n```\\n**C++:**\\n```cpp\\n    int tribonacci(int n) {\\n        int dp[] = {0, 1, 1};\\n        for (int i = 3; i <= n; ++i)\\n            dp[i % 3] = dp[0] + dp[1] + dp[2];\\n        return dp[n % 3];\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def tribonacci(self, n):\\n        dp = [0, 1, 1]\\n        for i in xrange(3, n + 1):\\n            dp[i % 3] = sum(dp)\\n        return dp[n % 3]\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d;\\n        while (n-- > 2) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        return c;\\n    }\\n```\n```cpp\\n    int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d = a + b + c;\\n        while (n-- > 2) {\\n            d = a + b + c, a = b, b = c, c = d;\\n        }\\n        return c;\\n    }\\n```\n```python\\n    def tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in xrange(n): a, b, c = b, c, a + b + c\\n        return c\\n```\n```java\\n    public int tribonacci(int n) {\\n        int dp[] = {0, 1, 1};\\n        for (int i = 3; i <= n; ++i)\\n            dp[i % 3] = dp[0] + dp[1] + dp[2];\\n        return dp[n % 3];\\n    }\\n```\n```cpp\\n    int tribonacci(int n) {\\n        int dp[] = {0, 1, 1};\\n        for (int i = 3; i <= n; ++i)\\n            dp[i % 3] = dp[0] + dp[1] + dp[2];\\n        return dp[n % 3];\\n    }\\n```\n```python\\n    def tribonacci(self, n):\\n        dp = [0, 1, 1]\\n        for i in xrange(3, n + 1):\\n            dp[i % 3] = sum(dp)\\n        return dp[n % 3]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1482728,
                "title": "c-python-2-solutions-dp-matrix-exponential-picture-explained-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DP One Pass**\\n- To calculate **N-th Tribonacci Number**\\n\\t- T[0] = 0\\n\\t- T[1] = 1\\n\\t- T[2] = 1\\n\\t- T[n] = T[n-3] + T[n-2] + T[n-1], n >= 3\\n\\t- Let `t0 = T[n-3]`, `t1 = T[n-2]`, `t2 = T[n-1]`, `tn = T[n]`, then `tn = t0 + t1 + t2`.\\n```python\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n == 0: return 0\\n        t0 = 0\\n        t1 = 1\\n        t2 = 1\\n        for i in range(n-2):\\n            tn = t0 + t1 + t2\\n            t0 = t1\\n            t1 = t2\\n            t2 = tn\\n        return t2\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 37`.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Matrix exponential**\\n- This problem is quite EASY since `N <= 37`. \\n- If this problem has constraint `N <= 10^16`, and the final result mod with `MOD = 10^9 + 7` for example (can check this problem **[12470 - Tribonacci](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=3914)**), we can\\'t solve it in Linear Time, we need to use **[Matrix exponential](https://en.wikipedia.org/wiki/Matrix_exponential)** technique to solve it in `O(logN)`.\\n- To calculate `fastPow(x, n)` in `O(logN)`, we use the idea from **[50. Pow(x, n)](https://leetcode.com/problems/powx-n/discuss/1341862)**.\\n\\n![image](https://assets.leetcode.com/users/images/915274e6-8f0b-4321-a0ae-5750e0ec593b_1632476141.6719818.png)\\n\\n<iframe src=\"https://leetcode.com/playground/P8HV3vXc/shared\" frameBorder=\"0\" width=\"100%\" height=780\"></iframe>\\n\\nComplexity:\\n- Time: `O(logN * M^3)`, where `N <= 37` is `Nth` tribonacci we need to find, `M = 3` is length of side in the matrix.\\n\\t- `fastPow` cost `O(logN)`\\n\\t- Multiply matrix `[3x3]` by `[3x3]` (when `half*half` in `fastPow`) costs `M^3`, where `M=3`.\\n- Space: `O(M^2)`\\n\\n**Practice yourself to solve problems which can be solved with Matrix Exponential**\\n- [509. Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\\n- [1220. Count Vowels Permutation](https://leetcode.com/problems/count-vowels-permutation/)\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n == 0: return 0\\n        t0 = 0\\n        t1 = 1\\n        t2 = 1\\n        for i in range(n-2):\\n            tn = t0 + t1 + t2\\n            t0 = t1\\n            t1 = t2\\n            t2 = tn\\n        return t2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115577,
                "title": "day-30-dp-easiest-beginner-friendly-sol-o-n-time-and-o-n-space",
                "content": "# Intuition of this Problem:\\nT[n] = T[n-1] + T[n-2] + T[n-3]\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize a vector \"Tribonacci\" with n+1 elements\\n2. Check if n is 0, if true return 0\\n3. Check if n is 1, if true return 1\\n4. Check if n is 2, if true return 1\\n5. Set Tribonacci[0] = 0, Tribonacci[1] = 1, Tribonacci[2] = 1\\n6. Iterate from i = 3 to n+1\\n    - Set Tribonacci[i] = Tribonacci[i-1] + Tribonacci[i-2] + Tribonacci[i-3]\\n1. Return Tribonacci[n]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n        vector<int> Tribonacci(n+1);\\n        Tribonacci[0] = 0;\\n        Tribonacci[1] = 1;\\n        Tribonacci[2] = 1;\\n        for(int i = 3; i < n+1; i++){\\n            Tribonacci[i] = Tribonacci[i-1] + Tribonacci[i-2] + Tribonacci[i-3];\\n        }\\n        return Tribonacci[n];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n        int[] Tribonacci = new int[n+1];\\n        Tribonacci[0] = 0;\\n        Tribonacci[1] = 1;\\n        Tribonacci[2] = 1;\\n        for(int i = 3; i < n+1; i++){\\n            Tribonacci[i] = Tribonacci[i-1] + Tribonacci[i-2] + Tribonacci[i-3];\\n        }\\n        return Tribonacci[n];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 1\\n        Tribonacci = [0] * (n + 1)\\n        Tribonacci[0] = 0\\n        Tribonacci[1] = 1\\n        Tribonacci[2] = 1\\n        for i in range(3, n + 1):\\n            Tribonacci[i] = Tribonacci[i-1] + Tribonacci[i-2] + Tribonacci[i-3]\\n        return Tribonacci[n]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)** // where n is the number given\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** // using extra space vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n        vector<int> Tribonacci(n+1);\\n        Tribonacci[0] = 0;\\n        Tribonacci[1] = 1;\\n        Tribonacci[2] = 1;\\n        for(int i = 3; i < n+1; i++){\\n            Tribonacci[i] = Tribonacci[i-1] + Tribonacci[i-2] + Tribonacci[i-3];\\n        }\\n        return Tribonacci[n];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n        int[] Tribonacci = new int[n+1];\\n        Tribonacci[0] = 0;\\n        Tribonacci[1] = 1;\\n        Tribonacci[2] = 1;\\n        for(int i = 3; i < n+1; i++){\\n            Tribonacci[i] = Tribonacci[i-1] + Tribonacci[i-2] + Tribonacci[i-3];\\n        }\\n        return Tribonacci[n];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        if n == 2:\\n            return 1\\n        Tribonacci = [0] * (n + 1)\\n        Tribonacci[0] = 0\\n        Tribonacci[1] = 1\\n        Tribonacci[2] = 1\\n        for i in range(3, n + 1):\\n            Tribonacci[i] = Tribonacci[i-1] + Tribonacci[i-2] + Tribonacci[i-3]\\n        return Tribonacci[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348040,
                "title": "c-simple-4-line-dp-solution-o-1-space",
                "content": "We only need to store three values at a time. Let\\'s use a static array and modulo-3 indexing.\\n\\n```C++\\nint tribonacci(int n) {\\n  int dp[3] = {0, 1, 1};\\n  for (int i = 3; i <= n; ++i)\\n    dp[i%3] += dp[(i+1)%3] + dp[(i+2)%3];\\n  return dp[n%3];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```C++\\nint tribonacci(int n) {\\n  int dp[3] = {0, 1, 1};\\n  for (int i = 3; i <= n; ++i)\\n    dp[i%3] += dp[(i+1)%3] + dp[(i+2)%3];\\n  return dp[n%3];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347604,
                "title": "c-o-k-3log-n-solution-k-3-matrix-exponentiation",
                "content": "```\\nWe have 3 equations:\\n        f(n)   = f(n-1) + f(n-2) + f(n-3)\\n        f(n-1) = f(n-1)\\n        f(n-2) =          f(n-2)\\n\\nBy turning them into matrix realtion. we get:\\n        | f(n)   |     | 1 1 1 |     | f(n-1) |\\n        | f(n-1) |  =  | 1 0 0 |  *  | f(n-2) |\\n        | f(n-2) |     | 0 1 0 |     | f(n-3) |\\n\\nSince we can compute an matrix exponent by O(log(n)), Simplify the relation into exponents\\n        | f(n)   |     | 1 1 1 |^(n-2)     | f(2) |\\n        | f(n-1) |  =  | 1 0 0 |       *   | f(1) |\\n        | f(n-2) |     | 0 1 0 |           | f(0) |\\n\\t\\t\\nThe matrix multiplication cost is k^3, k=3. So the total cost is O(k^3log(n))\\n```\\n\\n```C++\\nclass Solution {\\nprivate:\\n    vector<vector<int>> matrixMul(const vector<vector<int>> &A, const vector<vector<int>> &B) {\\n        vector<vector<int>> C(A.size(), vector<int>(B[0].size(), 0));\\n        for(int i=0; i<A.size(); ++i)\\n            for(int k=0; k<B.size(); ++k)\\n                for(int j=0; j<B[0].size();++j) {\\n                    C[i][j] += (A[i][k] * B[k][j]); \\n                }\\n        return C;\\n    }\\n    vector<vector<int>> matrixPow(const vector<vector<int>> &A, int k) {\\n        if(k == 0) {\\n            vector<vector<int>> C(A.size(), vector<int>(A.size(), 0));\\n            for(int i=0; i < A.size(); ++i) C[i][i] = 1;\\n            return C;\\n        }\\n        if(k == 1) return A;\\n        \\n        vector<vector<int>> C = matrixPow(A, k/2);\\n        C = matrixMul(C, C);\\n        if(k%2 == 1) return matrixMul(C,A);\\n        return C;\\n    }\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n==1 || n==2) return 1;\\n\\n        int f_0 = 0;\\n        int f_1 = 1;\\n        int f_2 = 1;\\n\\n        vector<vector<int>> C = matrixPow({\\n            {1,1,1},\\n            {1,0,0},\\n            {0,1,0}\\n        }, n-2);\\n        return matrixMul(C, {\\n            {f_2},\\n            {f_1},\\n            {f_0}\\n        })[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nWe have 3 equations:\\n        f(n)   = f(n-1) + f(n-2) + f(n-3)\\n        f(n-1) = f(n-1)\\n        f(n-2) =          f(n-2)\\n\\nBy turning them into matrix realtion. we get:\\n        | f(n)   |     | 1 1 1 |     | f(n-1) |\\n        | f(n-1) |  =  | 1 0 0 |  *  | f(n-2) |\\n        | f(n-2) |     | 0 1 0 |     | f(n-3) |\\n\\nSince we can compute an matrix exponent by O(log(n)), Simplify the relation into exponents\\n        | f(n)   |     | 1 1 1 |^(n-2)     | f(2) |\\n        | f(n-1) |  =  | 1 0 0 |       *   | f(1) |\\n        | f(n-2) |     | 0 1 0 |           | f(0) |\\n\\t\\t\\nThe matrix multiplication cost is k^3, k=3. So the total cost is O(k^3log(n))\\n```\n```C++\\nclass Solution {\\nprivate:\\n    vector<vector<int>> matrixMul(const vector<vector<int>> &A, const vector<vector<int>> &B) {\\n        vector<vector<int>> C(A.size(), vector<int>(B[0].size(), 0));\\n        for(int i=0; i<A.size(); ++i)\\n            for(int k=0; k<B.size(); ++k)\\n                for(int j=0; j<B[0].size();++j) {\\n                    C[i][j] += (A[i][k] * B[k][j]); \\n                }\\n        return C;\\n    }\\n    vector<vector<int>> matrixPow(const vector<vector<int>> &A, int k) {\\n        if(k == 0) {\\n            vector<vector<int>> C(A.size(), vector<int>(A.size(), 0));\\n            for(int i=0; i < A.size(); ++i) C[i][i] = 1;\\n            return C;\\n        }\\n        if(k == 1) return A;\\n        \\n        vector<vector<int>> C = matrixPow(A, k/2);\\n        C = matrixMul(C, C);\\n        if(k%2 == 1) return matrixMul(C,A);\\n        return C;\\n    }\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n==1 || n==2) return 1;\\n\\n        int f_0 = 0;\\n        int f_1 = 1;\\n        int f_2 = 1;\\n\\n        vector<vector<int>> C = matrixPow({\\n            {1,1,1},\\n            {1,0,0},\\n            {0,1,0}\\n        }, n-2);\\n        return matrixMul(C, {\\n            {f_2},\\n            {f_1},\\n            {f_0}\\n        })[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898781,
                "title": "python-easy-solution-with-explanation-3-different-approach-recursion-memorization-dp",
                "content": "### **Idea : \\n#####             1. simple recurssion\\n* #####                 base case --> if n ==0: return 0\\n\\t* #####                           --> if n ==1 or n == 2: return 1\\n* #####                 recurssion --> return rec(n-1) + rec(n-2) + rec(n-3)\\n#### Will run into time limit (due to redudent call stack)\\n```\\n        def rec(n):\\n            if n == 0:\\n                    return  0\\n            if n ==1 or n ==2:\\n                return 1            \\n            return rec(n-1) + rec(n-2) + rec(n-3)        \\n        return rec(n)\\n```\\n#### To solve redudent call stack , use memorization (dp)\\n#####           2. DP (recurssion with memorization) : Save the answers into dictionary to use that if they appear again (avoid redudent calculation)***\\n* #####                 - base case --> if n in memo: return memo[n]   : if the value has already been caculated and saved in dictionary, just return that value\\n* #####                 - recurssion :\\n\\t* #####                     memo[n] = rec(n-1) + rec(n-2) + rec(n-3)  # caculate and save the value in dictionary\\n\\t* #####                     return memo[n]**\\n\\n```\\n        # Recurssion with DP\\n        import collections\\n        memo = collections.defaultdict(int)\\n        memo[0], memo[1], memo[2] = 0,1,1\\n        def rec(n):\\n            if n in memo:\\n                return memo[n]\\n            memo[n] = rec(n-1) + rec(n-2) + rec(n-3)       \\n            return memo[n]\\n```\\n#### 3. Simple memorization (using hash map)\\n```\\n        # Memorization approach\\n        import collections\\n        memo = collections.defaultdict(int)\\n        memo[0], memo[1], memo[2] = 0,1,1\\n        for i in range(3,n+1):\\n            memo[i] = memo[i-1] + memo[i-2] + memo[i-3]\\n        return memo[n]\\n```\\n#### If you find this helpful, please ***upvote*** as appreciation, thanks",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n        def rec(n):\\n            if n == 0:\\n                    return  0\\n            if n ==1 or n ==2:\\n                return 1            \\n            return rec(n-1) + rec(n-2) + rec(n-3)        \\n        return rec(n)\\n```\n```\\n        # Recurssion with DP\\n        import collections\\n        memo = collections.defaultdict(int)\\n        memo[0], memo[1], memo[2] = 0,1,1\\n        def rec(n):\\n            if n in memo:\\n                return memo[n]\\n            memo[n] = rec(n-1) + rec(n-2) + rec(n-3)       \\n            return memo[n]\\n```\n```\\n        # Memorization approach\\n        import collections\\n        memo = collections.defaultdict(int)\\n        memo[0], memo[1], memo[2] = 0,1,1\\n        for i in range(3,n+1):\\n            memo[i] = memo[i-1] + memo[i-2] + memo[i-3]\\n        return memo[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1482837,
                "title": "python-2-solutions-dp-matrix-power-explained",
                "content": "#### Solution 1\\nIf you solved problem about Fibonacci numbers, this one will be a piece of cake for you. The idea is to use dynamic programming, where `dp[i]` is answer for `i-th` number. Then we can find `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`. Moreover, we do not need to use additional memory, because in fact we need to keep only last `3` numbers: `a, b, c`. Then we need to do `n` updates `a, b, c = b, c, a + b + c`. Note also, that I start with numbers `a, b, c = dp[-2], dp[-1], dp[0]`, where `dp[-1] = 0`, because `dp[-1] + dp[0] + dp[1] = dp[2]` and `dp[-2] = 1`, because `dp[-2] + dp[-1] + dp[0] = dp[1]`.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in range(n):\\n            a, b, c = b, c, a + b + c\\n            \\n        return c\\n```\\n\\n#### Solution 2\\nIf you plunge deep into solution of Fibonacci numbers problem, then you are aware that there is faster than `O(n)` solution for big `n`. The idea is so called fact matrix power. For every reccurunt equation we have, we can write it as evaluation of specific element of matrix of recurrence. In this problem `M = [[1,1,1],[1,0,0],[0,1,0]]`, which is equivalent to `a, b, c = b, c, a + b + c`. Notice, that we can also do matrix power with given module `MOD`, which I keep in my code, but we do not need in in fact - I keep it here for more reusable code.\\n\\n#### Complexity\\nTime complexity is `O(log n * M^3)`, where `M = 3` is the size of matrix. For given constraits there will be no gain in speed, but for bigger `n` there will be. Space complexity is `O(M^3)`.\\n\\n#### Code\\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def tribonacci(self, n):\\n        def power(M, n, MOD):\\n            result = np.eye(len(M), dtype = np.int64)\\n            while n > 0:\\n                if n%2: result = np.dot(M, result) % MOD\\n                M = np.dot(M, M) % MOD\\n                n //= 2\\n            return result\\n        \\n        t = power(np.array([[1,1,1],[1,0,0],[0,1,0]]), n, 1<<32)\\n        return t[0][-1]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in range(n):\\n            a, b, c = b, c, a + b + c\\n            \\n        return c\\n```\n```python\\nimport numpy as np\\n\\nclass Solution:\\n    def tribonacci(self, n):\\n        def power(M, n, MOD):\\n            result = np.eye(len(M), dtype = np.int64)\\n            while n > 0:\\n                if n%2: result = np.dot(M, result) % MOD\\n                M = np.dot(M, M) % MOD\\n                n //= 2\\n            return result\\n        \\n        t = power(np.array([[1,1,1],[1,0,0],[0,1,0]]), n, 1<<32)\\n        return t[0][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115558,
                "title": "beats-100-basics-of-dp-explained-java-c-python",
                "content": "# Intuition\\nThe initial solution that comes up to mind is to use 3 variables, t1,t2,t3 but this way, 3 operations have to be performed each step.\\n\\nWhy not recursion? It creates unnecessary stack and same values are calculated multiple times.\\n\\nSo the idea is to store the values of identified numbers in an array. This will cause additional space, but time is pretty fast. \\n\\n# Why Learning this is base for Dynamic Programming\\nThough this a very simple problem, this is the very underlying foundation for DP.\\nThis problem can also be solved recursively.\\nTrib[n] = Trib[n-1]+Trib[n-2]+Trib[n-3]\\n\\nLets say n = 4\\nTrib [4] = Trib[3]+Trib[2]+Trib[1];\\nTrib[3] = Trib[2]+Trib[1]+Trib[0];\\n\\nIf you look closely here the value of Trib[2] and Trib[1] are calculated multiple times, just to avoid this, we store the already calculated values. --> This is the whole idea of DP. Don\\'t calculate something twice, just store it. Start the solution from smallest possible and then increase i.e 1, 2 ,3 then 4, 5,6 \\n\\nSimilarly for 5 t2 is calculated 3 times, but as the tree grows the recalculated values increases\\n\\n![image](https://assets.leetcode.com/users/images/57a04f35-9d9d-4f16-9e95-1fdf6fcb5d2a_1675040014.673347.png)\\n\\nhttps://youtu.be/fiw_BenKGis\\n\\n![image](https://assets.leetcode.com/users/images/bfe9aaa8-1647-44e2-bd29-53ef9d29fe11_1675038911.4747224.png)\\n\\n```\\nint [] A = new int[n+1];\\n        if(n == 0 || n ==1) return n;\\n        if(n==2) return 1;\\n        A[0] = 0;\\n        A[1] = 1;\\n        A[2] = 1;\\n        for(int i = 3;i<=n;i++){\\n            A[i] = A[i-1]+A[i-2]+A[i-3];\\n        }\\n        return A[n];\\n```\\n\\n```\\nint tribonacci(int n) {\\nint A[n+1];\\nif(n == 0 || n ==1) return n;\\nif(n==2) return 1;\\nA[0] = 0;\\nA[1] = 1;\\nA[2] = 1;\\nfor(int i = 3;i<=n;i++){\\nA[i] = A[i-1]+A[i-2]+A[i-3];\\n}\\nreturn A[n];\\n}\\n```\\n```\\ndef tribonacci(self, n: int) -> int:\\n        A = [0]*(n+1)\\n        if n == 0 or n == 1:\\n            return n\\n        if n == 2:\\n            return 1\\n        A[0] = 0\\n        A[1] = 1\\n        A[2] = 1\\n        for i in range(3, n+1):\\n            A[i] = A[i-1] + A[i-2] + A[i-3]\\n        return A[n]\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nint [] A = new int[n+1];\\n        if(n == 0 || n ==1) return n;\\n        if(n==2) return 1;\\n        A[0] = 0;\\n        A[1] = 1;\\n        A[2] = 1;\\n        for(int i = 3;i<=n;i++){\\n            A[i] = A[i-1]+A[i-2]+A[i-3];\\n        }\\n        return A[n];\\n```\n```\\nint tribonacci(int n) {\\nint A[n+1];\\nif(n == 0 || n ==1) return n;\\nif(n==2) return 1;\\nA[0] = 0;\\nA[1] = 1;\\nA[2] = 1;\\nfor(int i = 3;i<=n;i++){\\nA[i] = A[i-1]+A[i-2]+A[i-3];\\n}\\nreturn A[n];\\n}\\n```\n```\\ndef tribonacci(self, n: int) -> int:\\n        A = [0]*(n+1)\\n        if n == 0 or n == 1:\\n            return n\\n        if n == 2:\\n            return 1\\n        A[0] = 0\\n        A[1] = 1\\n        A[2] = 1\\n        for i in range(3, n+1):\\n            A[i] = A[i-1] + A[i-2] + A[i-3]\\n        return A[n]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3115884,
                "title": "0ms-easy-solution-fully-explained-c-python3-java",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                        Please Upvote If You Find It Helpful.\\n```\\n\\n# Tribonacci Series\\nThe tribonacci series is a generalization of the Fibonacci sequence where each term is the sum of the three preceding terms.\\nThe Tribonacci Sequence: \\n0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852\\u2026 so on\\nGeneral Form of Tribonacci number: \\n\\n        a(n) = a(n-1) + a(n-2) + a(n-3) \\n        with \\n        a(0) = a(1) = 0, a(2) = 1. \\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we initialise the starting 3 numbers of the series and then check:\\n 1. If n==0 then return 0.\\n 2. If n==1 or n==2 then return 1;\\n 3. After that we run a loop from i=3 to n and find the series as\\n 4.    d = a + b + c\\n 5.    a = b\\n 6.    b = c\\n 7.    c = d\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n <!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a=0, b=1, c=1,d;  // Initialize the first three terms of the sequence\\n        if(n==0)\\n            return a;  // If n is 0, return the first term\\n        if(n==1 || n==2)\\n            return 1;  // If n is 1 or 2, return the second or third term respectively\\n        for(int i=3;i<=n;i++){  // Start the loop from the third term\\n            d = a + b + c;  // Calculate the next term in the sequence\\n            a = b;  // Update the value of a\\n            b = c;  // Update the value of b\\n            c = d;  // Update the value of c\\n        }\\n        return d;  // Return the nth term\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a = 0  # Initialize the first term of the sequence\\n        b = 1  # Initialize the second term of the sequence\\n        c = 1  # Initialize the third term of the sequence\\n        if n == 0:\\n            return 0  # If n is 0, return the first term\\n        if n == 1 or n == 2:\\n            return 1  # If n is 1 or 2, return the second or third term respectively\\n        for i in range(3, n+1):  # Start the loop from the third term\\n            d = a + b + c  # Calculate the next term in the sequence\\n            a = b  # Update the value of a\\n            b = c  # Update the value of b\\n            c = d  # Update the value of c\\n        return d  # Return the nth term\\n```\\n```Java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        // Initialize the first three numbers of the sequence\\n        int a = 0, b = 1, c = 1, d=0;\\n        \\n        // Check if n is 0\\n        if (n == 0)\\n            return a;\\n        \\n        // Check if n is 1 or 2\\n        if (n == 1 || n == 2)\\n            return 1;\\n        \\n        // Calculate each subsequent number in the sequence starting from the 3rd number\\n        for (int i = 3; i <= n; i++) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        \\n        // Return the n-th number in the sequence\\n        return d;\\n    }\\n}\\n\\n```\\n```\\n                           Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin]()",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```\\n                        Please Upvote If You Find It Helpful.\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a=0, b=1, c=1,d;  // Initialize the first three terms of the sequence\\n        if(n==0)\\n            return a;  // If n is 0, return the first term\\n        if(n==1 || n==2)\\n            return 1;  // If n is 1 or 2, return the second or third term respectively\\n        for(int i=3;i<=n;i++){  // Start the loop from the third term\\n            d = a + b + c;  // Calculate the next term in the sequence\\n            a = b;  // Update the value of a\\n            b = c;  // Update the value of b\\n            c = d;  // Update the value of c\\n        }\\n        return d;  // Return the nth term\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a = 0  # Initialize the first term of the sequence\\n        b = 1  # Initialize the second term of the sequence\\n        c = 1  # Initialize the third term of the sequence\\n        if n == 0:\\n            return 0  # If n is 0, return the first term\\n        if n == 1 or n == 2:\\n            return 1  # If n is 1 or 2, return the second or third term respectively\\n        for i in range(3, n+1):  # Start the loop from the third term\\n            d = a + b + c  # Calculate the next term in the sequence\\n            a = b  # Update the value of a\\n            b = c  # Update the value of b\\n            c = d  # Update the value of c\\n        return d  # Return the nth term\\n```\n```Java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        // Initialize the first three numbers of the sequence\\n        int a = 0, b = 1, c = 1, d=0;\\n        \\n        // Check if n is 0\\n        if (n == 0)\\n            return a;\\n        \\n        // Check if n is 1 or 2\\n        if (n == 1 || n == 2)\\n            return 1;\\n        \\n        // Calculate each subsequent number in the sequence starting from the 3rd number\\n        for (int i = 3; i <= n; i++) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        \\n        // Return the n-th number in the sequence\\n        return d;\\n    }\\n}\\n\\n```\n```\\n                           Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116501,
                "title": "c-dp-iterative-recursion-memoization-all-u-need",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust like fibonacii we can use both rescursion / dp or iterative appraoch. SO here the recurence relation is:\\n fin(n)=fib(n-1)+fib(n-2)+fib(n-3)\\nSo only difference is one more term is there rest is same.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo all approaches are below :\\n- Recursive \\n- Recusrion with Memoixation\\n- DP (with less space complexity O(1))\\n- Iterative\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Recusrive Solution [TLE]**\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n < 2)   return n;\\n        if(n == 2)  return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n};\\n```\\n**Recusrion with Memiozation**\\n```\\nclass Solution {\\npublic:\\nint dp[38];\\n  int fib1(int n){\\n      if(n==0)return dp[n]=0;\\n      if(n==1 or n==2)return dp[n]=1;\\n      \\n     if(dp[n]!=-1)return dp[n];\\n\\n      return dp[n]=fib1(n-1)+fib1(n-2)+fib1(n-3);\\n  }\\n    int tribonacci(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return fib1(n);\\n    }\\n};\\n```\\n**DP with O(1) Space (Beats 100%)**\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int dp[] ={0,1,1};\\n        for(int i=3;i<=n;i++){\\n            dp[i%3]=dp[0]+dp[1]+dp[2];\\n        }\\n        return dp[n%3];\\n    }\\n};\\n```\\n**Iterative Approach (Beats 100%)**\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n<2)return n;\\n        int t1=1,t2=1,t0=0,t3;\\n        for(int i=3;i<=n;i++){\\n            t3=(t0+t2+t1);\\n            t0=t1;\\n            t1=t2;\\n            t2=t3;\\n        }\\n        return t3;\\n    }\\n};\\n```\\n# Upvote if Helpfull\\uD83D\\uDD3C\\uD83D\\uDD3C",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n < 2)   return n;\\n        if(n == 2)  return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint dp[38];\\n  int fib1(int n){\\n      if(n==0)return dp[n]=0;\\n      if(n==1 or n==2)return dp[n]=1;\\n      \\n     if(dp[n]!=-1)return dp[n];\\n\\n      return dp[n]=fib1(n-1)+fib1(n-2)+fib1(n-3);\\n  }\\n    int tribonacci(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return fib1(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int dp[] ={0,1,1};\\n        for(int i=3;i<=n;i++){\\n            dp[i%3]=dp[0]+dp[1]+dp[2];\\n        }\\n        return dp[n%3];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n<2)return n;\\n        int t1=1,t2=1,t0=0,t3;\\n        for(int i=3;i<=n;i++){\\n            t3=(t0+t2+t1);\\n            t0=t1;\\n            t1=t2;\\n            t2=t3;\\n        }\\n        return t3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115908,
                "title": "java-c-100-faster-very-short-code-with-explanation",
                "content": "100% faster, **0ns** runtime code wuth *Dynamic Programming (DP)*\\n\\nWe use a array to store the calculated values so Space complexity in this case **O(n)**, so that repeating values can be fetched without spending all that computing time on calculating the same thing again. That\\'s Dynamic Programming for you.\\n\\nSo, we check for a particular value everytime before we calculate it, if absent we calculate it.\\n\\n# Code\\n``` Java []\\nclass Solution \\n{\\n    public int tribonacci(int n)\\n    {\\n        // O(n) time\\n        // O(n) space\\n        if(n < 3)   return n == 0 ? 0 : 1;\\n        \\n        int[] res = new int[n+1];\\n        res[0] = 0;\\n        res[1] = 1;\\n        res[2] = 1;\\n        // this array res will store the tribonacci values as fasten up the process, it is special property of DP\\n        \\n        for(int i = 3; i <= n; i++)\\n            res[i] = res[i-1] + res[i-2] + res[i-3];\\n        \\n        return res[n];\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int v[38]{0,1,1};\\n    // this vector v will store the tribonacci values as fasten up the process, it is special property of DP\\n    int tribonacci(int n) {\\n        if (n==0) return 0;\\n        if (v[n]) return v[n];\\n        // If value already calculated and stored we use it\\n        else return v[n] = tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n        // we store the value as we go on calculating\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/9ac4ec86-f5f6-47a2-bc32-11b73955dff9_1675049393.9920785.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` Java []\\nclass Solution \\n{\\n    public int tribonacci(int n)\\n    {\\n        // O(n) time\\n        // O(n) space\\n        if(n < 3)   return n == 0 ? 0 : 1;\\n        \\n        int[] res = new int[n+1];\\n        res[0] = 0;\\n        res[1] = 1;\\n        res[2] = 1;\\n        // this array res will store the tribonacci values as fasten up the process, it is special property of DP\\n        \\n        for(int i = 3; i <= n; i++)\\n            res[i] = res[i-1] + res[i-2] + res[i-3];\\n        \\n        return res[n];\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int v[38]{0,1,1};\\n    // this vector v will store the tribonacci values as fasten up the process, it is special property of DP\\n    int tribonacci(int n) {\\n        if (n==0) return 0;\\n        if (v[n]) return v[n];\\n        // If value already calculated and stored we use it\\n        else return v[n] = tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n        // we store the value as we go on calculating\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345382,
                "title": "java-easy-solution-with-comments",
                "content": "We run a for loop in which newElement is calculated.\\nnewElement is calculated by adding all the previous three elements\\nnewElement= first+second+third\\n\\n**Complexity:-**\\ntime= O(n)\\nspace=O(1)\\n\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int first=0,second=1,third=1;\\n        // here first,second and third are the previous three elements\\n        if(n<2)\\n            return n;\\n        // if n=0 or n=1 then the tribonacci number is n itself \\n        // else for loop will be executed\\n        for(int i=3;i<=n;i++)\\n        {\\n            int newElement=first+second+third;\\n            first=second;\\n            second=third;\\n            third=newElement;\\n        }\\n\\t\\t//If n=2 then the for loop is not executed and the initial value of the\\n\\t\\t//variable third is returned which is 1 \\n        return third;\\n        // returning the last element\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int first=0,second=1,third=1;\\n        // here first,second and third are the previous three elements\\n        if(n<2)\\n            return n;\\n        // if n=0 or n=1 then the tribonacci number is n itself \\n        // else for loop will be executed\\n        for(int i=3;i<=n;i++)\\n        {\\n            int newElement=first+second+third;\\n            first=second;\\n            second=third;\\n            third=newElement;\\n        }\\n\\t\\t//If n=2 then the for loop is not executed and the initial value of the\\n\\t\\t//variable third is returned which is 1 \\n        return third;\\n        // returning the last element\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363841,
                "title": "easy-python-with-dp",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        hmap = {0: 0, 1: 1, 2: 1}\\n        def trib(n):\\n            if n in hmap:\\n                return hmap[n]\\n            else:\\n                value = trib(n-1) + trib(n-2) + trib(n-3)\\n                hmap[n] = value\\n                return value\\n        return trib(n)\\n```\\nIf you like this solution please consider giving it a star on my [github](https://github.com/bwiens/leetcode-python). Means a lot to me.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        hmap = {0: 0, 1: 1, 2: 1}\\n        def trib(n):\\n            if n in hmap:\\n                return hmap[n]\\n            else:\\n                value = trib(n-1) + trib(n-2) + trib(n-3)\\n                hmap[n] = value\\n                return value\\n        return trib(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350547,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n    \\ta, b, c = 0, 1, 1\\n    \\tfor i in range(n): a, b, c = b, c, a + b + c\\n    \\treturn a\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n    \\ta, b, c = 0, 1, 1\\n    \\tfor i in range(n): a, b, c = b, c, a + b + c\\n    \\treturn a\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 483860,
                "title": "98-speed-100-memory-python3-list-operation-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        lst = [0, 1, 1]\\n        if n < 2:\\n            return lst[n]\\n        else:            \\n            for i in range(n-2):\\n                lst.append(sum(lst))\\n                lst.pop(0)\\n        return lst.pop()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        lst = [0, 1, 1]\\n        if n < 2:\\n            return lst[n]\\n        else:            \\n            for i in range(n-2):\\n                lst.append(sum(lst))\\n                lst.pop(0)\\n        return lst.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614221,
                "title": "4-different-approach",
                "content": "##### 1. Top - Down Approach \\n* *Time Complexity :* **O(n)**\\n* *Space Complexity :* **O(n)**\\n```\\nclass Solution(object):\\n    def sol(self, n, dp):\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n        if dp[n] != 0: return dp[n]\\n        dp[n] = self.sol(n - 1, dp) + self.sol(n - 2, dp) + self.sol(n - 3, dp)\\n        return dp[n]\\n    def tribonacci(self, n):\\n        dp = [0] * (n + 1)\\n        return self.sol(n, dp)\\n```\\n##### 2. Bottom - Up Approach \\n* *Time Complexity :* **O(n)**\\n* *Space Complexity :* **O(n)**\\n```\\n    def tribonacci(self, n):\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n        dp = [0] * (n + 1)\\n        dp[1], dp[2] = 1, 1\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\\n        return dp[n]\\n```\\n##### 3. With Space Optimization\\n* *Time Complexity :* **O(n)**\\n* *Space Complexity :* **O(1)**\\n```\\n    def tribonacci(self, n):\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n        first, second, third = 0, 1, 1\\n        for i in range(3, n + 1):\\n            sum_ = first + second + third\\n            first = second\\n            second = third\\n            third = sum_\\n        return third\\n```\\n##### 4. Recursive Solution\\n* *Time Complexity :* **O(3^n)**\\n* *Space Complexity :* **O(n)** (For recursive stack)\\n\\n* This solution will give **TLE** error.\\n```\\n    def tribonacci(self, n):\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n        return self.tribonacci(n - 1) + self.tribonacci(n - 2) + self.tribonacci(n - 3)\\n```\\n\\nPlease **UpVote**, if you like it **:)**",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def sol(self, n, dp):\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n        if dp[n] != 0: return dp[n]\\n        dp[n] = self.sol(n - 1, dp) + self.sol(n - 2, dp) + self.sol(n - 3, dp)\\n        return dp[n]\\n    def tribonacci(self, n):\\n        dp = [0] * (n + 1)\\n        return self.sol(n, dp)\\n```\n```\\n    def tribonacci(self, n):\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n        dp = [0] * (n + 1)\\n        dp[1], dp[2] = 1, 1\\n        for i in range(3, n + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\\n        return dp[n]\\n```\n```\\n    def tribonacci(self, n):\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n        first, second, third = 0, 1, 1\\n        for i in range(3, n + 1):\\n            sum_ = first + second + third\\n            first = second\\n            second = third\\n            third = sum_\\n        return third\\n```\n```\\n    def tribonacci(self, n):\\n        if n == 0: return 0\\n        if n == 1 or n == 2: return 1\\n        return self.tribonacci(n - 1) + self.tribonacci(n - 2) + self.tribonacci(n - 3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185474,
                "title": "c-easy-recursion-solution-0ms-beats-100-with-explanation",
                "content": "#### C++\\nIf T(n+3) = T(n) + T(n+1) + T(n+2) that implies T(n) = T(n-3) + T(n-2) + T(n-1). Recursively find all T(n) and store in array for quick look up saving time.\\n```\\nclass Solution {\\npublic:\\n    int t0=0, t1=1, t2=1;\\n    long long int arr[38]={0};\\n    int tribonacci(int n) {\\n        \\n        if(n==0)\\n            return t0;\\n        if(n==1)\\n            return t1;\\n        if(n==2)\\n            return t2;\\n        if(arr[n]!=0)\\n            return arr[n];\\n        return arr[n]=tribonacci(n-3)+tribonacci(n-2)+tribonacci(n-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t0=0, t1=1, t2=1;\\n    long long int arr[38]={0};\\n    int tribonacci(int n) {\\n        \\n        if(n==0)\\n            return t0;\\n        if(n==1)\\n            return t1;\\n        if(n==2)\\n            return t2;\\n        if(arr[n]!=0)\\n            return arr[n];\\n        return arr[n]=tribonacci(n-3)+tribonacci(n-2)+tribonacci(n-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348503,
                "title": "o-1-solution-using-math",
                "content": "https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#cite_note-6\\n![image](https://assets.leetcode.com/users/datavistics/image_1564640272.png)\\n\\n```\\n        a_p = (19+3*(33**.5))**(1/3)\\n        a_n = (19-3*(33**.5))**(1/3)\\n        b = (586+102*(33**.5))**(1/3)\\n        num = (1/3)*(a_p + a_n + 1)\\n        den = b**2 - 2*b + 4\\n        return round(3*b * (num ** n) / den)\\n```",
                "solutionTags": [],
                "code": "```\\n        a_p = (19+3*(33**.5))**(1/3)\\n        a_n = (19-3*(33**.5))**(1/3)\\n        b = (586+102*(33**.5))**(1/3)\\n        num = (1/3)*(a_p + a_n + 1)\\n        den = b**2 - 2*b + 4\\n        return round(3*b * (num ** n) / den)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2559412,
                "title": "n-th-tribonacci-number-recursive-and-memoization-3-line-code",
                "content": "**1. Recursive Solution**\\n\\n```\\nint tribonacci(int n) {\\n\\t\\t\\tif( n == 0)  return 0;\\n\\t\\t\\telse if ( n== 1 || n == 2)  return 1;\\n\\t\\t\\telse return tribonacci ( n - 1 )+tribonacci ( n - 2 )+tribonacci ( n - 3 );\\n    }\\n```\\n\\t\\n**2. Memoization Solution**\\n\\n\\n    int solve (int n, vector<int>&dp ) {\\n        if ( n == 0 ) return n;\\n        if ( n ==1 || n == 2) return 1;\\n        if ( dp[n]! = -1) return dp[n];\\n        return dp[ n ] = solve ( n-1 ,dp )+solve ( n-2 ,dp )+solve( n-3 ,dp );\\n    }\\n    \\n    int tribonacci(int n) {\\n        vector<int>dp(n+1,-1);\\n        return solve(n,dp);\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint tribonacci(int n) {\\n\\t\\t\\tif( n == 0)  return 0;\\n\\t\\t\\telse if ( n== 1 || n == 2)  return 1;\\n\\t\\t\\telse return tribonacci ( n - 1 )+tribonacci ( n - 2 )+tribonacci ( n - 3 );\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553323,
                "title": "java-100-clean-recursive-with-memoization",
                "content": "```\\nclass Solution {\\n    private HashMap<Integer, Integer> cache = new HashMap<>();\\n    public int tribonacci(int n) {\\n        \\n        if (cache.containsKey(n))\\n            return cache.get(n);\\n        \\n        if (n == 0) {\\n            cache.put(n, 0);\\n            return 0;\\n        }\\n        \\n        if (n == 1 || n == 2) {\\n            cache.put(n, 1);\\n            return 1;\\n        }\\n        \\n        int result =  tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\\n        cache.put(n, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private HashMap<Integer, Integer> cache = new HashMap<>();\\n    public int tribonacci(int n) {\\n        \\n        if (cache.containsKey(n))\\n            return cache.get(n);\\n        \\n        if (n == 0) {\\n            cache.put(n, 0);\\n            return 0;\\n        }\\n        \\n        if (n == 1 || n == 2) {\\n            cache.put(n, 1);\\n            return 1;\\n        }\\n        \\n        int result =  tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\\n        cache.put(n, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483709,
                "title": "n-th-tribonacci-number-one-pass-w-explanation-c-python-java",
                "content": "**IDEA**\\n*One Pass*\\n\\nTo calculate N-th Tribonacci Number\\n* `T[0] = 0`\\n* `T[1] = 1`\\n* `T[2] = 1`\\n* `T[n] = T[n-3] + T[n-2] + T[n-1]`, `n >= 3`\\n\\nWe only need to store three values at a time. We can use \\n* 3 variables\\n* A static array and modulo-3 indexing.\\n\\n**TIME COMPLEXITY - O(N)**\\n**SPACE COMPLEXITY - O(1)**\\n\\n**SOLUTION**\\n*Using 3 variables*\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n < 2) \\n            return n;\\n        int a = 0, b = 1, c = 1, d = a + b + c;\\n        while (n-- > 2) {\\n            d = a + b + c, a = b, b = c, c = d;\\n        }\\n        return c;\\n    }\\n};\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d;\\n        while (n-- > 2) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        return c;\\n    }\\n}\\n```\\n`IN PYTHON`\\n```\\ndef tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in xrange(n): a, b, c = b, c, a + b + c\\n        return c\\n```\\n*Using Static Array*\\n`IN C++`\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a[3] = {0 , 1 , 1} ;\\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            a[i%3] += a[(i+1)%3] + a[(i+2)%3] ;\\n        }\\n        return a[n%3] ;\\n    }\\n};\\n```\\n`IN JAVA`\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a[] = {0, 1, 1};\\n        for (int i = 3; i <= n; i++)\\n            a[i % 3] = a[0] + a[1] + a[2];\\n        return a[n % 3];\\n    }\\n}\\n```\\n`IN PYTHON`\\n```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        a = [0, 1, 1]\\n        for i in xrange(3, n + 1):\\n            a[i % 3] = sum(a)\\n        return a[n % 3]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n < 2) \\n            return n;\\n        int a = 0, b = 1, c = 1, d = a + b + c;\\n        while (n-- > 2) {\\n            d = a + b + c, a = b, b = c, c = d;\\n        }\\n        return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 2) return n;\\n        int a = 0, b = 1, c = 1, d;\\n        while (n-- > 2) {\\n            d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n        }\\n        return c;\\n    }\\n}\\n```\n```\\ndef tribonacci(self, n):\\n        a, b, c = 1, 0, 0\\n        for _ in xrange(n): a, b, c = b, c, a + b + c\\n        return c\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a[3] = {0 , 1 , 1} ;\\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            a[i%3] += a[(i+1)%3] + a[(i+2)%3] ;\\n        }\\n        return a[n%3] ;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a[] = {0, 1, 1};\\n        for (int i = 3; i <= n; i++)\\n            a[i % 3] = a[0] + a[1] + a[2];\\n        return a[n % 3];\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        a = [0, 1, 1]\\n        for i in xrange(3, n + 1):\\n            a[i % 3] = sum(a)\\n        return a[n % 3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117228,
                "title": "c-generate-at-compile-time-o-1-runtime-time-complexity",
                "content": "**TODO(heder): Insert cute meme to ask for up-votes. ;)**\\n\\n# Approach 1: generate at compile time\\n\\nTribonacci numbers don\\'t change. Ever. We can just hard code them or generate them at compile time.\\n\\n```cpp\\nnamespace {\\n\\nconstexpr auto generate() {\\n    array<int, 38> ans = {0, 1, 1};\\n\\n    for (int i = 3; i < size(ans); ++i)\\n        ans[i] = ans[i - 3] + ans[i - 2] + ans[i - 1];\\n\\n    return ans;\\n}\\n    \\nconstexpr auto Ts = generate();\\n\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static constexpr int tribonacci(int n) {\\n        return Ts[n];\\n    }\\n};\\n```\\n\\nAlternatively we could just hardcode them:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static constexpr array<int, 38> Ts = {\\n        0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609,\\n        19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770,\\n        8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474,\\n        1132436852, 2082876103\\n    };\\n\\n    static constexpr int tribonacci(int n) {\\n        return Ts[n];\\n    }\\n};\\n```\\n\\nTurns out I posted something very similar 18 months ago: https://leetcode.com/problems/n-th-tribonacci-number/discuss/1482855/C%2B%2B-O(1)-time-(pre-compute-either-offline-or-at-compile-time-w-constexpr) :)\\n\\n**Complexity Analysis**\\n  * Time complexity: $$O(1)$$\\n  * Space complexity: At runtime it\\'s $$O(1)$$, but even the precomputation is limited to 38 elements which is still $$O(1)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nnamespace {\\n\\nconstexpr auto generate() {\\n    array<int, 38> ans = {0, 1, 1};\\n\\n    for (int i = 3; i < size(ans); ++i)\\n        ans[i] = ans[i - 3] + ans[i - 2] + ans[i - 1];\\n\\n    return ans;\\n}\\n    \\nconstexpr auto Ts = generate();\\n\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static constexpr int tribonacci(int n) {\\n        return Ts[n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    static constexpr array<int, 38> Ts = {\\n        0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609,\\n        19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770,\\n        8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474,\\n        1132436852, 2082876103\\n    };\\n\\n    static constexpr int tribonacci(int n) {\\n        return Ts[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115652,
                "title": "leetcode-the-hard-way-explained-line-by-line-simple-dp-optimised",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=GIqeucuiPy4&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=27) if you are interested.\\n\\n```cpp\\n// TC: O(N)\\n// SC: O(N)\\nclass Solution {\\npublic:\\n\\t// since first three numbers are given, \\n\\t// let dp[i] be the value of T_n\\n\\t// we can build the dp[i] based on dp[i - 1] + dp[i - 2] + dp[i - 3]\\n    int tribonacci(int n) {\\n\\t    // first three numbers are known\\n        if (n == 0) return 0;\\n        if (n == 1 || n == 2) return 1;\\n\\t\\t// dp[i]: the value of T_n\\n        vector<int> dp(n + 1);\\n\\t\\t// base case\\n        dp[0] = 0;\\n        dp[1] = dp[2] = 1;\\n\\t\\t// dp[i] is the sum of the previous three values\\n        for(int i = 3; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        return dp[n];\\n    }\\n};\\n```\\n\\nIn the above DP solution, we can further optimize the space to constant space since we just need to know the previous three values.\\n\\n```cpp\\n// TC: O(N)\\n// SC: O(1)\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n == 0) return 0;\\n        if (n == 1 || n == 2) return 1;\\n        // vector<int> dp(n + 1);\\n        // dp[0] = 0;\\n        // dp[1] = dp[2] = 1;\\n        int a = 0, b = 1, c = 1, t;\\n        for(int i = 3; i <= n; i++) {\\n            // dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n            t = a + b + c;\\n            a = b;\\n            b = c;\\n            c = t;\\n        }\\n        // return dp[n];\\n        return c;\\n    }\\n};\\n```\\n\\nHere\\'s the hardcoded solution. In case someone is interested, you may take a look at the tribonacci sequence [A000073](https://oeis.org/A000073) at OEIS.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> lol = { 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103 };\\n    int tribonacci(int n) {\\n        return lol[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```cpp\\n// TC: O(N)\\n// SC: O(N)\\nclass Solution {\\npublic:\\n\\t// since first three numbers are given, \\n\\t// let dp[i] be the value of T_n\\n\\t// we can build the dp[i] based on dp[i - 1] + dp[i - 2] + dp[i - 3]\\n    int tribonacci(int n) {\\n\\t    // first three numbers are known\\n        if (n == 0) return 0;\\n        if (n == 1 || n == 2) return 1;\\n\\t\\t// dp[i]: the value of T_n\\n        vector<int> dp(n + 1);\\n\\t\\t// base case\\n        dp[0] = 0;\\n        dp[1] = dp[2] = 1;\\n\\t\\t// dp[i] is the sum of the previous three values\\n        for(int i = 3; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        return dp[n];\\n    }\\n};\\n```\n```cpp\\n// TC: O(N)\\n// SC: O(1)\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n == 0) return 0;\\n        if (n == 1 || n == 2) return 1;\\n        // vector<int> dp(n + 1);\\n        // dp[0] = 0;\\n        // dp[1] = dp[2] = 1;\\n        int a = 0, b = 1, c = 1, t;\\n        for(int i = 3; i <= n; i++) {\\n            // dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n            t = a + b + c;\\n            a = b;\\n            b = c;\\n            c = t;\\n        }\\n        // return dp[n];\\n        return c;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> lol = { 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415, 223317, 410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425, 53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103 };\\n    int tribonacci(int n) {\\n        return lol[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769198,
                "title": "javascript-iterative-recursive-memoization",
                "content": "# Recursive\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    if (mem[n] !== undefined) return mem[n];\\n    return mem[n] = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\\n};\\n\\nconst mem = {\\n    0: 0,\\n    1: 1,\\n    2: 1\\n};\\n```\\n\\n# Iterative\\n ```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    if (mem[n] !== undefined) return mem[n];\\n    for (let i = 3; i <= n; i++) {\\n        mem[i] = mem[i - 1] + mem[i - 2] + mem[i - 3];\\n    }\\n    return mem[n];\\n};\\n\\nconst mem = {\\n    0: 0,\\n    1: 1,\\n    2: 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    if (mem[n] !== undefined) return mem[n];\\n    return mem[n] = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\\n};\\n\\nconst mem = {\\n    0: 0,\\n    1: 1,\\n    2: 1\\n};\\n```\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    if (mem[n] !== undefined) return mem[n];\\n    for (let i = 3; i <= n; i++) {\\n        mem[i] = mem[i - 1] + mem[i - 2] + mem[i - 3];\\n    }\\n    return mem[n];\\n};\\n\\nconst mem = {\\n    0: 0,\\n    1: 1,\\n    2: 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345255,
                "title": "easy-solution-java-with-dp",
                "content": "Tn+3 = Tn + Tn+1 + Tn+2\\nwhich means \\nTn = Tn-1 + Tn-2 + Tn-3\\n```\\npublic static int tribonacci(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        return dp[n];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic static int tribonacci(int n) {\\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3116424,
                "title": "o-1-time-full-explanation-dynamic-programming-c-java-python3",
                "content": "# Basic Approaches :\\n- There can be two possible scenerios to implement the solution: \\n1. Space Optimisation, \\n2. Performance Optimisation.\\n- Space Optimisation can be implementated using dynamic programming without using recursion in it.\\n- We will implement second type of optimisation here:\\nPerformance based Optimisation. We will use both dynamic programming as well as recursion.\\n- Dynamic Programming has two major categories: Memoization and Tabulation.\\n- Memoization is a term describing an optimization technique where you cache previously computed results, and return the cached result when the same computation is needed again.\\n# Explanation to Approach :\\n- We will use precomputed 38 Tribonacci numbers:\\n- Initialize an array of Tribonacci numbers of size 38 with 0.\\n- Return tribo(n-1). The next is Recursion:\\n- if k = 0, return 0.\\n- If nums[k] != 0, return nums[k].\\n- Otherwise, nums[k] = tribo(k - 1) + tribo(k - 2) + tribo(k - 3). Return nums[k].\\n# Complexity\\n- Time complexity :O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : Constant Space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ | Java | Python3] :\\n```C++ []\\n#include <vector>\\n\\nclass Tri {\\n  private:\\n    int n = 38;\\n    std::vector<int> nums;\\n\\n  public:\\n    int tribo(int k) {\\n      if (k == 0) return 0;\\n      if (k >= (int)nums.size()) {\\n        nums.resize(k + 1);\\n      }\\n      if (nums[k] != 0) return nums[k];\\n\\n      nums[k] = tribo(k - 1) + tribo(k - 2) + tribo(k - 3);\\n      return nums[k];\\n    }\\n\\n    Tri() {\\n      nums.resize(n);\\n      nums[1] = 1;\\n      nums[2] = 1;\\n      tribo(n - 1);\\n    }\\n};\\n\\nclass Solution {\\n  public:\\n    static Tri t;\\n    int tribonacci(int n) {\\n      return t.tribo(n);\\n    }\\n};\\n\\nTri Solution::t = Tri();\\n```\\n```Java []\\nclass Tri {\\n  private int n = 38;\\n  public int[] nums = new int[n];\\n\\n  int tribo(int k) {\\n    if (k == 0) return 0;\\n    if (nums[k] != 0) return nums[k];\\n\\n    nums[k] = tribo(k - 1) + tribo(k - 2) + tribo(k - 3);\\n    return nums[k];\\n  }\\n\\n  Tri() {\\n    nums[1] = 1;\\n    nums[2] = 1;\\n    tribo(n - 1);\\n  }\\n}\\n\\nclass Solution {\\n  public static Tri t = new Tri();\\n  public int tribonacci(int n) {\\n    return t.nums[n];\\n  }\\n}\\n```\\n```Python3 []\\nclass Tri:\\n    n = 38\\n    nums = [0] * n\\n\\n    def tribo(self, k):\\n        if k == 0:\\n            return 0\\n        if self.nums[k] != 0:\\n            return self.nums[k]\\n\\n        self.nums[k] = self.tribo(k - 1) + self.tribo(k - 2) + self.tribo(k - 3)\\n        return self.nums[k]\\n\\n    def __init__(self):\\n        self.nums[1] = 1\\n        self.nums[2] = 1\\n        self.tribo(self.n - 1)\\n\\nclass Solution:\\n    t = Tri()\\n\\n    def tribonacci(self, n):\\n        return Solution.t.nums[n]\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/6fafea8a-d7d1-4f18-a3cb-c44d1832d7b5_1675057979.252868.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\n#include <vector>\\n\\nclass Tri {\\n  private:\\n    int n = 38;\\n    std::vector<int> nums;\\n\\n  public:\\n    int tribo(int k) {\\n      if (k == 0) return 0;\\n      if (k >= (int)nums.size()) {\\n        nums.resize(k + 1);\\n      }\\n      if (nums[k] != 0) return nums[k];\\n\\n      nums[k] = tribo(k - 1) + tribo(k - 2) + tribo(k - 3);\\n      return nums[k];\\n    }\\n\\n    Tri() {\\n      nums.resize(n);\\n      nums[1] = 1;\\n      nums[2] = 1;\\n      tribo(n - 1);\\n    }\\n};\\n\\nclass Solution {\\n  public:\\n    static Tri t;\\n    int tribonacci(int n) {\\n      return t.tribo(n);\\n    }\\n};\\n\\nTri Solution::t = Tri();\\n```\n```Java []\\nclass Tri {\\n  private int n = 38;\\n  public int[] nums = new int[n];\\n\\n  int tribo(int k) {\\n    if (k == 0) return 0;\\n    if (nums[k] != 0) return nums[k];\\n\\n    nums[k] = tribo(k - 1) + tribo(k - 2) + tribo(k - 3);\\n    return nums[k];\\n  }\\n\\n  Tri() {\\n    nums[1] = 1;\\n    nums[2] = 1;\\n    tribo(n - 1);\\n  }\\n}\\n\\nclass Solution {\\n  public static Tri t = new Tri();\\n  public int tribonacci(int n) {\\n    return t.nums[n];\\n  }\\n}\\n```\n```Python3 []\\nclass Tri:\\n    n = 38\\n    nums = [0] * n\\n\\n    def tribo(self, k):\\n        if k == 0:\\n            return 0\\n        if self.nums[k] != 0:\\n            return self.nums[k]\\n\\n        self.nums[k] = self.tribo(k - 1) + self.tribo(k - 2) + self.tribo(k - 3)\\n        return self.nums[k]\\n\\n    def __init__(self):\\n        self.nums[1] = 1\\n        self.nums[2] = 1\\n        self.tribo(self.n - 1)\\n\\nclass Solution:\\n    t = Tri()\\n\\n    def tribonacci(self, n):\\n        return Solution.t.nums[n]\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1502655,
                "title": "java-basic-dynamic-programming-must-do-it-with-dp-only",
                "content": "```\\npublic int tribonacci(int n) {\\n        \\n        //Base Conditions\\n        if(n==0||n==1)\\n            return n;\\n        \\n        int dp[]=new int[n+1];\\n        \\n        //Assigning Starting Values\\n        dp[0]=0; dp[1]=1; dp[2]=1;\\n        \\n        //Run loop till n and store sum of last three elements in dp[i]\\n        for(int i=3;i<=n;i++)\\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\\n        \\n        //return T(n)\\n        return dp[n];\\n    }\\n    \\n```\\n\\nIf you get it then I will be more happy if you give a **upvote**:))\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int tribonacci(int n) {\\n        \\n        //Base Conditions\\n        if(n==0||n==1)\\n            return n;\\n        \\n        int dp[]=new int[n+1];\\n        \\n        //Assigning Starting Values\\n        dp[0]=0; dp[1]=1; dp[2]=1;\\n        \\n        //Run loop till n and store sum of last three elements in dp[i]\\n        for(int i=3;i<=n;i++)\\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\\n        \\n        //return T(n)\\n        return dp[n];\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491019,
                "title": "c-memoization-tabulation-code-dynamic-porgramming",
                "content": "```\\n//Tabulation Code- (Bottom Up Dp)\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        int arr[39];\\n        arr[0]=0; arr[1]=1;arr[2]=1;\\n        if(n<=2) return arr[n];\\n        for(int i=3;i<=n;i++){\\n            arr[i]=arr[i-1]+arr[i-2]+arr[i-3];\\n        }\\n        return arr[n];\\n    }\\n};\\n\\n//Memoized Code- (Top Down Dp)\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int tribonacci(int n) {\\n        dp.resize(n+1,-1);\\n        return solve(n);\\n        \\n    }\\n    \\n    int solve(int n){\\n        if(dp[n]!=-1) return dp[n];\\n        else if(n==0) return dp[0]=0; \\n        else if(n==1 || n==2) return dp[n]=1;\\n        else return dp[n]=solve(n-1)+solve(n-2)+solve(n-3);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n//Tabulation Code- (Bottom Up Dp)\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        int arr[39];\\n        arr[0]=0; arr[1]=1;arr[2]=1;\\n        if(n<=2) return arr[n];\\n        for(int i=3;i<=n;i++){\\n            arr[i]=arr[i-1]+arr[i-2]+arr[i-3];\\n        }\\n        return arr[n];\\n    }\\n};\\n\\n//Memoized Code- (Top Down Dp)\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int tribonacci(int n) {\\n        dp.resize(n+1,-1);\\n        return solve(n);\\n        \\n    }\\n    \\n    int solve(int n){\\n        if(dp[n]!=-1) return dp[n];\\n        else if(n==0) return dp[0]=0; \\n        else if(n==1 || n==2) return dp[n]=1;\\n        else return dp[n]=solve(n-1)+solve(n-2)+solve(n-3);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361930,
                "title": "c-easy-solution-brute-force-recursive-dp-iterative-dp-optimised-solution",
                "content": "# Intuition\\nIt is just like fibonacci series.\\n\\n# Approach\\nIn normal recursive method, the terminating case for the recursion is n = 0, n = 1, n = 2. We recursively call for n != 0 && n != 1 && n != 2 **soln(n-1) + soln(n-2) + soln(n-3)**. \\n\\n**But using this method we are repeating the calls, so let us memorize them using dp and solve.**\\n\\nIn the same code we make some changes and store the value in dp table.\\n\\n**But using this method, recursive calls take extra space, so let us go for iterative method using dp.**\\n\\nNow make a dp array and store the base cases dp[0] = 0, dp[1] = 1 and dp[2] = 1. Now from 3 to n you can just store it dp[i] = dp[i-1]+dp[i-2]+dp[i-3].\\n\\n**But using this method, we are using extra space of N, so let us go for normal iterative method.**\\n\\nYou can see that we must only memorise the previous 3 elements so we will be storing last 3 elements.\\n\\n# Complexity\\n- Time complexity:\\nUsing normal recursion takes O(3^N)\\nUsing recursive dp takes O(N)\\nUsing Iterative dp takes O(N)\\nUsing Iterative method tajes O(N) \\n\\n- Space complexity:\\nUsing normal recursive takes O(3^N)\\nUsing recurive dp takes O(N) + O(Recursive cost)\\nUsing Iterative dp takes O(N)\\nUsing Iterative method takes O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint soln(int n){\\n    if(n == 0){\\n        return 0;\\n    }\\n    if(n == 1 || n == 2){\\n        return 1;\\n    }\\n    return soln(n-1)+soln(n-2)+soln(n-3);\\n}\\n    int tribonacci(int n) {\\n       return soln(n);\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\nint soln(int n,vector<int>&dp){\\n    if(n == 0){\\n        return 0;\\n    }\\n    if(n == 1 || n == 2){\\n        return 1;\\n    }\\n    if(dp[n] != -1){\\n        return dp[n];\\n    }\\n    return dp[n] = soln(n-1,dp)+soln(n-2,dp)+soln(n-3,dp);\\n}\\n    int tribonacci(int n) {\\n        vector<int>dp(n+1,-1);\\n       return soln(n,dp);\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n == 1 || n == 2){\\n            return 1;\\n        }\\n        vector<int>dp(n+1,0);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for(int i = 3;i<=n;i++){\\n            dp[i] = dp[i-1]+dp[i-2]+dp[i-3];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n == 1 || n == 2){\\n            return 1;\\n        }\\n        int n1 = 0,n2 = 1,n3 = 1;\\n        for(int i = 3;i<=n;i++){\\n            int ans = n1+n2+n3;\\n            n1 = n2;\\n            n2 = n3;\\n            n3 = ans;\\n        }\\n        return n3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint soln(int n){\\n    if(n == 0){\\n        return 0;\\n    }\\n    if(n == 1 || n == 2){\\n        return 1;\\n    }\\n    return soln(n-1)+soln(n-2)+soln(n-3);\\n}\\n    int tribonacci(int n) {\\n       return soln(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\nint soln(int n,vector<int>&dp){\\n    if(n == 0){\\n        return 0;\\n    }\\n    if(n == 1 || n == 2){\\n        return 1;\\n    }\\n    if(dp[n] != -1){\\n        return dp[n];\\n    }\\n    return dp[n] = soln(n-1,dp)+soln(n-2,dp)+soln(n-3,dp);\\n}\\n    int tribonacci(int n) {\\n        vector<int>dp(n+1,-1);\\n       return soln(n,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n == 1 || n == 2){\\n            return 1;\\n        }\\n        vector<int>dp(n+1,0);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for(int i = 3;i<=n;i++){\\n            dp[i] = dp[i-1]+dp[i-2]+dp[i-3];\\n        }\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n == 1 || n == 2){\\n            return 1;\\n        }\\n        int n1 = 0,n2 = 1,n3 = 1;\\n        for(int i = 3;i<=n;i++){\\n            int ans = n1+n2+n3;\\n            n1 = n2;\\n            n2 = n3;\\n            n3 = ans;\\n        }\\n        return n3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119917,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a=0,b=1,c=1;\\n        if(n==0) return a;\\n        if(n==1) return b;\\n        if(n==2) return c;\\n        for(int i=3;i<=n;i++)\\n            {\\n            int sum =a+b+c;\\n            a=b;\\n            b=c;\\n            c=sum;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a=0,b=1,c=1;\\n        if(n==0) return a;\\n        if(n==1) return b;\\n        if(n==2) return c;\\n        for(int i=3;i<=n;i++)\\n            {\\n            int sum =a+b+c;\\n            a=b;\\n            b=c;\\n            c=sum;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686304,
                "title": "c-100-faster-solution-using-dp",
                "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int res[n+1]; \\n        for(int i = 0; i < n+1; i++)\\n        {\\n            res[i] = 0;\\n        }\\n        res[n] = solve(n, res);\\n        return res[n];\\n    }\\npublic:\\n    int solve(int n, int memo[]){\\n        if(n <= 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 1;\\n        \\n        if(memo[n] != 0) return memo[n]; \\n        \\n        return memo[n] = solve(n-1,memo)+solve(n-2,memo)+solve(n-3,memo);\\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int res[n+1]; \\n        for(int i = 0; i < n+1; i++)\\n        {\\n            res[i] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1290667,
                "title": "java-recursion-simple-solution-0-ms-100-faster",
                "content": "Just recurse it until you find the non-zero array element.\\n```\\nclass Solution {\\n    int[] a;\\n    public int tri(int x){\\n\\t\\t//recurse it until you find the non-zero element\\n       if(a[x]!=0){\\n           return a[x];\\n       }\\n        a[x]=tri(x-1)+tri(x-2)+tri(x-3);\\n        return a[x];\\n    }\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1||n==2)return 1;\\n        a=new int[n+1];\\n        a[0]=0;a[1]=1;a[2]=1;a[3]=2;\\n        \\n        if(a[n]!=0)return a[n];\\n        return tri(n);\\n    }\\n}\\n```\\nGuys kindly upvote, if it helps you",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int[] a;\\n    public int tri(int x){\\n\\t\\t//recurse it until you find the non-zero element\\n       if(a[x]!=0){\\n           return a[x];\\n       }\\n        a[x]=tri(x-1)+tri(x-2)+tri(x-3);\\n        return a[x];\\n    }\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1||n==2)return 1;\\n        a=new int[n+1];\\n        a[0]=0;a[1]=1;a[2]=1;a[3]=2;\\n        \\n        if(a[n]!=0)return a[n];\\n        return tri(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385258,
                "title": "java-simple-additive-recursion-o-n",
                "content": "```\\n    public int tribonacci(int n) {\\n        return addTrib(n, 0, 1, 1);\\n    }\\n    \\n    private int addTrib(int n, int b1, int b2, int b3) {\\n        if (n == 0) return 0;\\n        if (n == 1 || n == 2) return 1;\\n        int sum = b1+b2+b3;\\n        if (n == 3) return sum;\\n        return addTrib(n-1, b2, b3, sum);\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    public int tribonacci(int n) {\\n        return addTrib(n, 0, 1, 1);\\n    }\\n    \\n    private int addTrib(int n, int b1, int b2, int b3) {\\n        if (n == 0) return 0;\\n        if (n == 1 || n == 2) return 1;\\n        int sum = b1+b2+b3;\\n        if (n == 3) return sum;\\n        return addTrib(n-1, b2, b3, sum);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3115801,
                "title": "iterative-recursion-memoization-c",
                "content": "# **Same Approach Used in Fibonacci Series**\\n**Starting three values of the series are given**\\n*Zeroth = 0\\nFirst = 1\\nSecond = 1*\\n\\n*For Third->\\nPreviously Zeroth = 0, First = 1, Second = 1;\\nThird = zeroth + first + second = 0 + 1 + 1\\nvalues for next iteration will change as Zeroth, First, Second will move one step forward\\nZeroth = First = 1\\nFirst = Second = 1\\nSecond = Third = 2*\\n\\n*For Forth->\\nForth = zeroth + first + second = 1 + 1 + 2 = 4\\nvalues for next iteration will change as Zeroth, First, Second will move one step forward\\nZeroth = First = 1\\nFirst = Second = 2\\nSecond = Forth = 4*\\n\\n**... Series Goes On**\\n\\n**See the Iterative Approach.. Code is same as above explaination**\\n\\n***Iterative [ACCEPTED]***\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int zeroth = 0, first = 1, second = 1, res;\\n        if(n < 2)       return n;\\n        if(n == 2)      return 1;\\n        for(int i = 3; i <= n; i++){\\n            res = zeroth + first + second;\\n            zeroth = first;\\n            first = second;\\n            second = res;\\n        }\\n        return res;\\n    }\\n};\\n```\\n***Recursive Solution [TLE]***\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n){\\n        if(n < 2)   return n;\\n        if(n == 2)  return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n};\\n```\\n\\n***Memoization [ACCEPTED]***\\n```\\nclass Solution {\\npublic:\\n    int memoized(int n, vector<int> &dp){\\n        if(n < 2)           return n;\\n        if(n == 2)          return 1;\\n        if(dp[n] != -1)     return dp[n];\\n        return dp[n] = memoized(n-1, dp) + memoized(n-2, dp) + memoized(n-3, dp);\\n    }\\n    int tribonacci(int n) {\\n        vector<int> dp(n+1, -1);\\n        return memoized(n, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int zeroth = 0, first = 1, second = 1, res;\\n        if(n < 2)       return n;\\n        if(n == 2)      return 1;\\n        for(int i = 3; i <= n; i++){\\n            res = zeroth + first + second;\\n            zeroth = first;\\n            first = second;\\n            second = res;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n){\\n        if(n < 2)   return n;\\n        if(n == 2)  return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int memoized(int n, vector<int> &dp){\\n        if(n < 2)           return n;\\n        if(n == 2)          return 1;\\n        if(dp[n] != -1)     return dp[n];\\n        return dp[n] = memoized(n-1, dp) + memoized(n-2, dp) + memoized(n-3, dp);\\n    }\\n    int tribonacci(int n) {\\n        vector<int> dp(n+1, -1);\\n        return memoized(n, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115525,
                "title": "daily-leetcoding-challenge-january-day-30",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 30.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-th-tribonacci-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Space Optimisation : Dynamic Programming\n\n  \n**Approach 2:** Performance Optimisation : Recursion with Memoization\n\n  \n**Approach 3:** Performance Optimisation : Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/n-th-tribonacci-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2334222,
                "title": "javascript-solution",
                "content": "```\\nconst tribonacci = (n) => {\\n    \\n    let result = [0,1,1]\\n    \\n    for(let i = 3; i<=n; i++) {\\n        result[i] = result[i-1] + result[i-2] + result[i-3]\\n    }\\n    \\n    return result[n]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst tribonacci = (n) => {\\n    \\n    let result = [0,1,1]\\n    \\n    for(let i = 3; i<=n; i++) {\\n        result[i] = result[i-1] + result[i-2] + result[i-3]\\n    }\\n    \\n    return result[n]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1743439,
                "title": "c-easy-to-understand-using-dp-100-faster",
                "content": "\\'\\'\\'\\n```\\n\\n```\\t\\t\\tclass Solution {\\n\\t\\t\\tpublic:\\n\\t\\t\\t\\tint tribonacci(int n) {\\n\\t\\t\\t\\t\\tint dp[n+1];\\n\\t\\t\\t\\t\\tif(n==0){\\n\\t\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(n<=1){\\n\\t\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tdp[0]=0;\\n\\t\\t\\t\\t\\tdp[1]=1;\\n\\t\\t\\t\\t\\tdp[2]=1;\\n\\t\\t\\t\\t\\tfor(int i=3;i<=n;i++){\\n\\t\\t\\t\\t\\t\\tdp[i]=dp[i-1]+dp[i-2]+dp[i-3];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn dp[n];\\n\\t\\t\\t\\t}\\n\\t\\t\\t* }\\n\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1575588,
                "title": "c-easy-solution-dp-100-faster",
                "content": "**Recursive**\\nBut it wil give TLE.\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n<2)return n;\\n        if(n==2)return 1;\\n        \\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n<2)return n;\\n        if(n==2)return 1;\\n        \\n        int a=0;\\n        int b=1;\\n        int c=1;\\n        int d=0;\\n        for(int i=3;i<=n;i++){\\n            d=a+b+c;\\n            a=b;\\n            b=c;\\n            c=d;\\n        }\\n        return d;\\n    }\\n};\\n```\\n\\nHope you liked it.\\n\\nPlease upvote it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n<2)return n;\\n        if(n==2)return 1;\\n        \\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n<2)return n;\\n        if(n==2)return 1;\\n        \\n        int a=0;\\n        int b=1;\\n        int c=1;\\n        int d=0;\\n        for(int i=3;i<=n;i++){\\n            d=a+b+c;\\n            a=b;\\n            b=c;\\n            c=d;\\n        }\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569763,
                "title": "go-constant-space-o-1-non-recursive",
                "content": "Recursive solution on Go surprisingly didn\\'t pass time limit with n = 35.\\nSo there is non-recursive solution with array storing last three elements of sequense.\\n```\\nfunc tribonacci(n int) int {\\n    triset := [3]int{0, 1, 1}\\n    if n < 3 {\\n        return triset[n]\\n    }\\n    for i := 3; i <= n; i++ {\\n        triset[i % 3] = triset[0] + triset[1] + triset[2]\\n    }\\n    return triset[n % 3]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Memoization"
                ],
                "code": "```\\nfunc tribonacci(n int) int {\\n    triset := [3]int{0, 1, 1}\\n    if n < 3 {\\n        return triset[n]\\n    }\\n    for i := 3; i <= n; i++ {\\n        triset[i % 3] = triset[0] + triset[1] + triset[2]\\n    }\\n    return triset[n % 3]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855147,
                "title": "sc-o-1-c-clean-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The fibbonacci and tribonacci series which only depends on previous terms.\\n- This can be easily solved using constant space and can be converted in optimized codes instead of complex one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store the previous three terms of the series and follow as in fibbonacci series.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n  int dp[3] = {0, 1, 1};\\n  for (int i = 3; i <= n; ++i)\\n    dp[i%3] += dp[(i+1)%3] + dp[(i+2)%3];\\n  return dp[n%3];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n  int dp[3] = {0, 1, 1};\\n  for (int i = 3; i <= n; ++i)\\n    dp[i%3] += dp[(i+1)%3] + dp[(i+2)%3];\\n  return dp[n%3];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119903,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a=0,b=1,c=1;\\n        if(n==0) return a;\\n        if(n==1) return b;\\n        if(n==2) return c;\\n        for(int i=3;i<=n;i++)\\n            {\\n            int sum =a+b+c;\\n            a=b;\\n            b=c;\\n            c=sum;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a=0,b=1,c=1;\\n        if(n==0) return a;\\n        if(n==1) return b;\\n        if(n==2) return c;\\n        for(int i=3;i<=n;i++)\\n            {\\n            int sum =a+b+c;\\n            a=b;\\n            b=c;\\n            c=sum;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116933,
                "title": "beginner-friendly-solution-easy",
                "content": "\\n# Approach\\nTake an array of n+3 size store first three Tribonacci sequence and return if n=0 or n=1 or n=2\\nif(n>=3) then take a loop,sum previous three Tribonacci sequence and store in array return array\\'s nth element\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a[n+3];\\n        a[0]=0;\\n        a[1]=1;\\n        a[2]=1;\\n        if(n==0) return 0;\\n        if(n==1 || n==2) return 1;\\n        for(int i=3;i<=n;i++){\\n            a[i]=a[i-1]+a[i-2]+a[i-3];\\n        }\\nreturn a[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int a[n+3];\\n        a[0]=0;\\n        a[1]=1;\\n        a[2]=1;\\n        if(n==0) return 0;\\n        if(n==1 || n==2) return 1;\\n        for(int i=3;i<=n;i++){\\n            a[i]=a[i-1]+a[i-2]+a[i-3];\\n        }\\nreturn a[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116418,
                "title": "c-constant-space-same-as-fibonacci",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        if(n==0) return 0;\\n        if(n==1 || n==2) return 1;\\n\\n        long long t0=0;  // t(n)\\n        long long t1=1;  // t(n+1)\\n        long long t2=1;  // t(n+2)\\n        long long ans=0;\\n\\n        for(int i=3;i<=n;i++)\\n        {\\n            ans = t0+t1+t2;      // prev 3 value sum\\n            t0=t1;               // t0 will become new t(n)\\n            t1=t2;               // t1 will become new t(n+1)\\n            t2=ans;              // now curr sum will become the new t(n+2) \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        if(n==0) return 0;\\n        if(n==1 || n==2) return 1;\\n\\n        long long t0=0;  // t(n)\\n        long long t1=1;  // t(n+1)\\n        long long t2=1;  // t(n+2)\\n        long long ans=0;\\n\\n        for(int i=3;i<=n;i++)\\n        {\\n            ans = t0+t1+t2;      // prev 3 value sum\\n            t0=t1;               // t0 will become new t(n)\\n            t1=t2;               // t1 will become new t(n+1)\\n            t2=ans;              // now curr sum will become the new t(n+2) \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116130,
                "title": "simple-and-efficient-solution-with-comments-and-explanation-beats-100",
                "content": "\\n\\n# Approach\\nThis approach uses a dynamic programming method to solve the problem of finding the nth number in the tribonacci sequence. The basic idea is to use a cache (in this case, an ArrayList) to store the already computed values of the sequence, so that they can be reused in future calculations.\\n\\nThe main function, tribonacci(int n), starts by checking if the value of n is already stored in the cache. If it is, it simply returns the value from the cache. If not, the function calculates the value by adding up the three previous values in the sequence (tribonacci(n-3) + tribonacci(n-2) + tribonacci(n-1)), and then stores the result in the cache for future use.\\n\\n# Complexity\\n- Time complexity: O(n), because each value of n is calculated only once and stored in the cache, so subsequent calculations are done in constant time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), because the cache stores the values of n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JAVA\\n```\\nclass Solution {\\n    static ArrayList<Integer> cache = new ArrayList<Integer>(Arrays.asList(0, 1, 1));\\n\\n    public static int tribonacci(int n) {\\n        // check if the value of n is already in the cache\\n        if (n >= cache.size() || cache.get(n) == null) {\\n            // if not, add the value to the cache by calculating the tribonacci sequence\\n            cache.add(tribonacci(n - 3) + tribonacci(n - 2) + tribonacci(n - 1));\\n        }\\n        // return the value from the cache\\n        return cache.get(n);\\n    }\\n}\\n\\n```\\n# JS\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nconst cache = [0, 1, 1];\\nvar tribonacci = function (n) {\\n    if (cache[n] === undefined) {\\n        cache[n] = tribonacci(n - 3) + tribonacci(n - 2) + tribonacci(n - 1);\\n    }\\n    return cache[n];\\n};\\n```\\n![cutecat](https://assets.leetcode.com/users/images/a368e607-130a-49ea-a1b8-58402aeb1cbf_1674878823.1172526.jpeg)",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    static ArrayList<Integer> cache = new ArrayList<Integer>(Arrays.asList(0, 1, 1));\\n\\n    public static int tribonacci(int n) {\\n        // check if the value of n is already in the cache\\n        if (n >= cache.size() || cache.get(n) == null) {\\n            // if not, add the value to the cache by calculating the tribonacci sequence\\n            cache.add(tribonacci(n - 3) + tribonacci(n - 2) + tribonacci(n - 1));\\n        }\\n        // return the value from the cache\\n        return cache.get(n);\\n    }\\n}\\n\\n```\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nconst cache = [0, 1, 1];\\nvar tribonacci = function (n) {\\n    if (cache[n] === undefined) {\\n        cache[n] = tribonacci(n - 3) + tribonacci(n - 2) + tribonacci(n - 1);\\n    }\\n    return cache[n];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115899,
                "title": "97-javascript-fast-very-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/1-a7K6_bcVc\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    let dp = new Array(n+1).fill(0);\\n    dp[1] = 1\\n    dp[2] = 1;\\n    for(let i =3; i<=n; i++){\\n        dp[i] = dp[i-1] + dp[i-2] +dp[i-3]\\n    }\\n    return dp[n]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    let dp = new Array(n+1).fill(0);\\n    dp[1] = 1\\n    dp[2] = 1;\\n    for(let i =3; i<=n; i++){\\n        dp[i] = dp[i-1] + dp[i-2] +dp[i-3]\\n    }\\n    return dp[n]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482743,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n     // for n , there is constraint that n can not eceeds to 37\\n        \\n//         int[] T = new int[38];\\n        \\n//         T[0] = 0;\\n//         T[1] = 1;\\n//         T[2] = 1;\\n        \\n//         if(n==0)\\n//             return 0;\\n        \\n//         if(n==1 || n==2)\\n//             return 1;\\n        \\n//         for(int i=3;i<=n;i++){\\n//             T[i] = T[i-1] + T[i-2] + T[i-3];\\n//         }\\n//         return T[n];\\n        \\n        // without using extra space\\n        \\n        int n0 = 0;\\n        int n1 = 1;\\n        int n2 = 1;\\n        int result = 0;\\n        \\n        if(n<1) return 0;\\n        if(n==1 || n==2) return 1;\\n        for(int i=3;i<=n;i++){\\n            result = n0 + n1 + n2;\\n            \\n            n0 = n1;\\n            n1 = n2;\\n            n2 = result;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n     // for n , there is constraint that n can not eceeds to 37\\n        \\n//         int[] T = new int[38];\\n        \\n//         T[0] = 0;\\n//         T[1] = 1;\\n//         T[2] = 1;\\n        \\n//         if(n==0)\\n//             return 0;\\n        \\n//         if(n==1 || n==2)\\n//             return 1;\\n        \\n//         for(int i=3;i<=n;i++){\\n//             T[i] = T[i-1] + T[i-2] + T[i-3];\\n//         }\\n//         return T[n];\\n        \\n        // without using extra space\\n        \\n        int n0 = 0;\\n        int n1 = 1;\\n        int n2 = 1;\\n        int result = 0;\\n        \\n        if(n<1) return 0;\\n        if(n==1 || n==2) return 1;\\n        for(int i=3;i<=n;i++){\\n            result = n0 + n1 + n2;\\n            \\n            n0 = n1;\\n            n1 = n2;\\n            n2 = result;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740115,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n):\\n        initial = [0,1,1]\\n        temp = []\\n        while len(initial)<=n:\\n            initial.append(sum(initial[-3:]))\\n        return initial[n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n):\\n        initial = [0,1,1]\\n        temp = []\\n        while len(initial)<=n:\\n            initial.append(sum(initial[-3:]))\\n        return initial[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349756,
                "title": "rust-1-liner-0ms-100-2-4mb",
                "content": "```\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        (0..n).fold((0,1,1), |(a,b,c), _| (b,c,a+b+c)).0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        (0..n).fold((0,1,1), |(a,b,c), _| (b,c,a+b+c)).0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345242,
                "title": "java-python-3-straight-forward-codes-time-o-n-space-o-1",
                "content": "```java\\n    public int tribonacci(int n) {\\n        int[] trib = {0, 1, 1};\\n        for (int i = 3; i <= n; ++i) {\\n            trib[i % 3] = trib[0] + trib[1] + trib[2];\\n        }\\n        return trib[n % 3];\\n    }\\n```\\n```python\\n    def tribonacci(self, n: int) -> int:\\n        trib = [0, 1, 1]\\n        for i in range(3, n + 1):\\n            trib[i % 3] = sum(trib) \\n        return trib[n % 3]\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int tribonacci(int n) {\\n        int[] trib = {0, 1, 1};\\n        for (int i = 3; i <= n; ++i) {\\n            trib[i % 3] = trib[0] + trib[1] + trib[2];\\n        }\\n        return trib[n % 3];\\n    }\\n```\n```python\\n    def tribonacci(self, n: int) -> int:\\n        trib = [0, 1, 1]\\n        for i in range(3, n + 1):\\n            trib[i % 3] = sum(trib) \\n        return trib[n % 3]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3119915,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a=0,b=1,c=1;\\n        if(n==0) return a;\\n        if(n==1) return b;\\n        if(n==2) return c;\\n        for(int i=3;i<=n;i++)\\n            {\\n            int sum =a+b+c;\\n            a=b;\\n            b=c;\\n            c=sum;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int a=0,b=1,c=1;\\n        if(n==0) return a;\\n        if(n==1) return b;\\n        if(n==2) return c;\\n        for(int i=3;i<=n;i++)\\n            {\\n            int sum =a+b+c;\\n            a=b;\\n            b=c;\\n            c=sum;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117012,
                "title": "java-classic-dp-fibonacci",
                "content": "# Code - O(n) space\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int[] dp = new int[Math.max(n + 1, 3)];\\n        dp[1] = dp[2] = 1;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\nAs you can see in the code, we only look on the previous `3` variables, so we can reduce the state to O(1).\\n\\n# Code - O(1) space\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n <= 2) {\\n            return Math.min(1, n);\\n        }\\n        int a = 0, b = 1, c = 1;\\n        int cur = 0;\\n        for (int i = 3; i <= n; i++) {\\n            cur = a + b + c;\\n            a = b;\\n            b = c;\\n            c = cur;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int[] dp = new int[Math.max(n + 1, 3)];\\n        dp[1] = dp[2] = 1;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n <= 2) {\\n            return Math.min(1, n);\\n        }\\n        int a = 0, b = 1, c = 1;\\n        int cur = 0;\\n        for (int i = 3; i <= n; i++) {\\n            cur = a + b + c;\\n            a = b;\\n            b = c;\\n            c = cur;\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116653,
                "title": "c-java-brute-force-to-optimised-w-detailed-explanation-easy-and-commented-soln",
                "content": "#### **Intuition:**\\n* There is not much about the problem, as we have define a sequence (called as  N-th Tribonacci) and have to give result on the basis of that sequence.\\n* The sequence is defind as Tn+3 = Tn + Tn+1 + Tn+2.\\n* Also some base cases are also included here as (T0 = 0, T1 = 1, T2 = 1 ).\\n* We will implement this only.\\n____________\\n##### **Recursive (TLE):**\\n* Recursive solution hits first, as that is what same as asked in the question.\\n* With gives bases cases we will apply that relation in our program.\\n\\n**CODES:**\\n* **C++ / JAVA (BOTH ARE SAME):**\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n                \\n        return tribonacci(n - 1) +  tribonacci(n - 2) +  tribonacci(n - 3);\\n   }\\n};\\n```\\n__________\\n##### **DP (MEMOZIATION):**\\n* We will receive **TLE with recursive code**, and question arises **why** ?\\n* See, One cool thing about our recursive codes is that, when they call themself and for some smaller input cases,\\nthey treat that input case as new problem, even they already computed that problem before.\\n* What I meant to say, suppose for n = 4 we call our recursive function \\nthen, recursive function goes something like as T4 = T3 + T2 + T1.\\n* Now, for again T3 it goes like T3 = T2 + T1 + T0.\\n* Now, bases cases hit and we will get our answer.\\n* But suppose someone asks us about n = 5, then it compute for n = 5 as T5 = T4 + T3 + T2.\\n* Now, T4, T3, T2, ***all three will be treated as brand new problem***, but we just computed our value for T4 above,\\nbut recursive function says no it dosen\\u2019t matter for me, I will again compute them again and then again give result.\\n* So, this is the problem in our recursive solution as for some already computed result,\\nwe are not taking advantage of that we simply compute again when we encounter some result.\\n* So, Now question arises how can we get rid of this problem i.e computing again and again.\\n* We will say why we are computing again a problem, because are not memorizing it, or precisely say we are not remembering it.\\n* So we make a table and stores all that result which are already computed,\\nand then if in some later process we need that values we will pick them from our table.\\n\\n* Annnnnd, this is what exactly dp is!!!\\n\\n```\\nTIME AND SPACE COMPLEXITY:\\nTime Complexity: O(n) \\nSpace Complexity: O(n) // because we are using dp table here\\n```\\n**CODES:**\\n* C++:\\n```\\nclass Solution {\\npublic:\\n    long long dp[38] = {0};\\n    int tribonacci(int n) {\\n        \\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n        \\n        if(dp[n] != 0)\\n            return dp[n];\\n        \\n       return dp[n] =  tribonacci(n - 1) +  tribonacci(n - 2) +  tribonacci(n - 3);\\n       \\n    }\\n};\\n```\\n* JAVA:\\n```\\nclass Solution {\\n    int [] dp = new int[38];\\n    public int solve(int n)\\n    {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n        \\n        if(dp[n] != 0)\\n            return dp[n];\\n                \\n        return dp[n] = solve(n - 1) +  solve(n - 2) +  solve(n - 3);\\n    }\\n    public int tribonacci(int n) {\\n        Arrays.fill(dp, 0);\\n        return solve(n);\\n    }\\n}\\n```\\n____________\\n##### **DP (BOTTOM UP APPROACH):**\\n* Instead of recursive code, we can use iterative method also, but the idea will be same.\\n* And also, there is no change in Time and Space Complexity here.\\n* They remain same as O(n).\\n\\n**CODES**\\n* **C++ / JAVA (BOTH ARE SAME):**\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n == 1 || n == 2) return 1;\\n        \\n        int dp[n + 1];\\n        dp[0] = 0, dp[1] = dp[2] = 1;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n_______________\\n#### **Now, Question arises do we really need a table here:**\\n* Answer is **NO**.\\n* If we observe our problem here at a particular instant of time in calculating any \\u2018n\\u2019, we **only required the value of last three variables here**.\\n* SO, why to make a table in calculating any answer.\\n* We will make three variables to store the previous last three values and then calculate our answer.\\n* It decreases our space complexity from O(n) to O(1).\\n\\n```\\nTIME AND SPACE COMPLEXITY:\\nTime Complexity: O(n) \\nSpace Complexity: O(1)\\n```\\n\\n**CODES:**\\n* **C++ / JAVA (BOTH ARE SAME):**\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n == 1 || n == 2) return 1;\\n        \\n        int LastThird = 0, LastSecond = 1, JustLast = 1;\\n        \\n        while(n > 2)\\n        {\\n            int sum = LastThird + LastSecond + JustLast;\\n            \\n            LastThird = LastSecond;\\n            LastSecond = JustLast;\\n            JustLast = sum;\\n            n--;\\n        }\\n       \\n        return JustLast;\\n    }\\n};\\n```\\n____________\\n***`If u find this useful , please consider to give an upvote!!`***\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n                \\n        return tribonacci(n - 1) +  tribonacci(n - 2) +  tribonacci(n - 3);\\n   }\\n};\\n```\n```\\nTIME AND SPACE COMPLEXITY:\\nTime Complexity: O(n) \\nSpace Complexity: O(n) // because we are using dp table here\\n```\n```\\nclass Solution {\\npublic:\\n    long long dp[38] = {0};\\n    int tribonacci(int n) {\\n        \\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n        \\n        if(dp[n] != 0)\\n            return dp[n];\\n        \\n       return dp[n] =  tribonacci(n - 1) +  tribonacci(n - 2) +  tribonacci(n - 3);\\n       \\n    }\\n};\\n```\n```\\nclass Solution {\\n    int [] dp = new int[38];\\n    public int solve(int n)\\n    {\\n        if(n == 0)\\n            return 0;\\n        if(n == 1 || n == 2)\\n            return 1;\\n        \\n        if(dp[n] != 0)\\n            return dp[n];\\n                \\n        return dp[n] = solve(n - 1) +  solve(n - 2) +  solve(n - 3);\\n    }\\n    public int tribonacci(int n) {\\n        Arrays.fill(dp, 0);\\n        return solve(n);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n == 1 || n == 2) return 1;\\n        \\n        int dp[n + 1];\\n        dp[0] = 0, dp[1] = dp[2] = 1;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nTIME AND SPACE COMPLEXITY:\\nTime Complexity: O(n) \\nSpace Complexity: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n == 1 || n == 2) return 1;\\n        \\n        int LastThird = 0, LastSecond = 1, JustLast = 1;\\n        \\n        while(n > 2)\\n        {\\n            int sum = LastThird + LastSecond + JustLast;\\n            \\n            LastThird = LastSecond;\\n            LastSecond = JustLast;\\n            JustLast = sum;\\n            n--;\\n        }\\n       \\n        return JustLast;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116637,
                "title": "simple-java-recursion-dp-solution-100-faster",
                "content": "**Recursion Solution :**\\n\\n**TC --> O(3 ^ N) since 3 Recursion Calls\\nSC --> O(N)**\\n\\n**\" (Time Limit Exceeded) \"**\\n\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        return f (n);\\n    }\\n    static int f (int n) {\\n        \\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        if (n == 1 || n == 2) {\\n            return 1;\\n        }\\n        \\n        return f (n - 1) + f (n - 2) + f (n - 3);\\n    }\\n}\\n```\\n\\n**Memoization Solution :**\\n\\n`Memoization means, using an array to store the answers of calculated recursion calls, if it already calculated we just return that answers from that array, else we calculate and store in the array.`\\n\\n\"`Using the pre caculated answers simply means Dynamic Programming\"`\\n\\n**TC --> O(N)\\nSC --> O(N) + O(N)**\\n\\n\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        \\n        int[] dp = new int[n+1];\\n        \\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = -1;\\n        }  \\n        return f (n, dp);\\n    }\\n    static int f (int n, int[] dp) {\\n        \\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        if (n == 1 || n == 2) {\\n            return 1;\\n        }\\n        \\n        if (dp[n] != -1) {\\n            return dp[n];\\n        }\\n        \\n        dp[n] = f (n - 1, dp) + f (n - 2, dp) + f (n - 3, dp);\\n        return dp[n];\\n    }\\n}\\n```\\n\\n**Tabulation Solution :**\\n\\n**TC --> O(N)\\nSC --> O(N)**\\n\\n`This method is used to reduce the recursion stack space.`\\n\\n\\n```\\nclass Solution {\\n    int[] dp = new int[38];\\n    public int tribonacci(int n) {\\n        \\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n        }\\n        return dp[n];\\n    }   \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        return f (n);\\n    }\\n    static int f (int n) {\\n        \\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        if (n == 1 || n == 2) {\\n            return 1;\\n        }\\n        \\n        return f (n - 1) + f (n - 2) + f (n - 3);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        \\n        int[] dp = new int[n+1];\\n        \\n        for (int i = 0; i < dp.length; i++) {\\n            dp[i] = -1;\\n        }  \\n        return f (n, dp);\\n    }\\n    static int f (int n, int[] dp) {\\n        \\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        if (n == 1 || n == 2) {\\n            return 1;\\n        }\\n        \\n        if (dp[n] != -1) {\\n            return dp[n];\\n        }\\n        \\n        dp[n] = f (n - 1, dp) + f (n - 2, dp) + f (n - 3, dp);\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] dp = new int[38];\\n    public int tribonacci(int n) {\\n        \\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n        }\\n        return dp[n];\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893196,
                "title": "java-100-faster-array-as-a-cache",
                "content": "# Code\\n```\\nclass Solution {\\n    static int[] cache = new int[38];\\n    public int tribonacci(int n) {\\n        if (n == 0) return 0;\\n        if (n == 1) return 1;\\n        if (n == 2) return 1;\\n        if (cache[n] > 0) return cache[n];\\n        else cache[n] = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\\n        return cache[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[] cache = new int[38];\\n    public int tribonacci(int n) {\\n        if (n == 0) return 0;\\n        if (n == 1) return 1;\\n        if (n == 2) return 1;\\n        if (cache[n] > 0) return cache[n];\\n        else cache[n] = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\\n        return cache[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741512,
                "title": "0ms-dynamic-programming-c-solution",
                "content": "fastest **0ms** runtime solution with *dynamic programming*\\n\\n```\\nclass Solution {\\npublic:\\n    int v[38]{0,1,1};\\n    int tribonacci(int n) {\\n        if (n==0) return 0;\\n        if (v[n]) return v[n];\\n        else return v[n] = tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/e78320c7-ec69-4a33-bd35-e9fbc12af046_1675049279.0039537.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int v[38]{0,1,1};\\n    int tribonacci(int n) {\\n        if (n==0) return 0;\\n        if (v[n]) return v[n];\\n        else return v[n] = tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741493,
                "title": "nth-tribonacci-number-best-solution-ever-100-faster",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        \\n        \\n      if(n==0)\\n      {\\n          return 0;\\n      }\\n        \\n        if(n==1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(n==2)\\n        {\\n            return 1;\\n        }\\n        \\n        if(n==3)\\n        {\\n            return 2;\\n        }\\n        \\n        int prev1=2;\\n        int prev2=1;\\n        int prev3=1;\\n        int prev4=0;\\n        int curr=0;\\n        \\n        for(long long i=4;i<=n;i++)\\n        {\\n           curr=prev1+prev2+prev3;\\n           prev3=prev2;\\n           prev2=prev1;\\n           prev1=curr;\\n        }\\n        \\n       return prev1;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        \\n        \\n      if(n==0)\\n      {\\n          return 0;\\n      }\\n        \\n        if(n==1)\\n        {\\n            return 1;\\n        }\\n        \\n        if(n==2)\\n        {\\n            return 1;\\n        }\\n        \\n        if(n==3)\\n        {\\n            return 2;\\n        }\\n        \\n        int prev1=2;\\n        int prev2=1;\\n        int prev3=1;\\n        int prev4=0;\\n        int curr=0;\\n        \\n        for(long long i=4;i<=n;i++)\\n        {\\n           curr=prev1+prev2+prev3;\\n           prev3=prev2;\\n           prev2=prev1;\\n           prev1=curr;\\n        }\\n        \\n       return prev1;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619356,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\n/*** 1137. N-th Tribonacci Number ***/\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1 || n==2){\\n            return 1;\\n        }\\n    int sum = 0;\\n        int a = 0;\\n        int b = 1;\\n        int c = 1;\\n        for(int i = 2; i < n ; i++){   \\n            sum = a + b + c;\\n            a = b;\\n            b = c;\\n            c = sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n/*** 1137. N-th Tribonacci Number ***/\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1 || n==2){\\n            return 1;\\n        }\\n    int sum = 0;\\n        int a = 0;\\n        int b = 1;\\n        int c = 1;\\n        for(int i = 2; i < n ; i++){   \\n            sum = a + b + c;\\n            a = b;\\n            b = c;\\n            c = sum;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630325,
                "title": "top-to-bottom-approach-c-d-p",
                "content": "class Solution {\\npublic:\\n\\n    int tribonacci(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        else if(n==1){\\n            return 1;\\n        }\\n        else if(n==2){\\n            return 1;\\n        }\\n        vector<int> dp(n+1,0);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=1;\\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\\n        }\\n        return dp[n];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int tribonacci(int n) {\\n        if(n==0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 852269,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int tribonacci(int n) {\\n        int a=0,b=1,c=1;\\n        int d=0;\\n        if(n==1||n==2)\\n            return 1;\\n        for(int i=3;i<=n;i++){\\n            d=a+b+c;\\n            a=b;\\n            b=c;\\n            c=d;\\n        }\\n        return d;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int tribonacci(int n) {\\n        int a=0,b=1,c=1;\\n        int d=0;\\n        if(n==1||n==2)\\n            return 1;\\n        for(int i=3;i<=n;i++){\\n            d=a+b+c;\\n            a=b;\\n            b=c;\\n            c=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 354081,
                "title": "java-c-python-3-simple-o-n-explanation-for-beginners",
                "content": "This is just a simple quick answer in Java, C++, and Python with time and space complexity of O(N): \\n( for java and  c++ 100% for mem, speed. for python, 100% memory, speed varies)\\nJava:\\n```\\nclass Solution {\\n    public int tribonacci(int n) { \\n        if (n == 0){\\n            return 0;\\n        } else if (n == 1 || n == 2){\\n            return 1;\\n        } else {\\n            int[] trib = new int[n + 1];\\n            trib[0] = 0;\\n            trib[1] = 1;\\n            trib [2] = 1;\\n            for (int i = 3; i < n + 1; i++){\\n                trib[i] = trib[i - 1] + trib[i - 2] + trib[i - 3];\\n            }\\n            return trib[n];\\n        }\\n    }\\n}\\n```\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n == 0){\\n            return 0;\\n        } else if (n == 1 || n == 2){\\n            return 1;\\n        } else {\\n            int trib[n + 1];\\n            trib[0] = 0;\\n            trib[1] = 1;\\n            trib [2] = 1;\\n            for (int i = 3; i < n + 1; i++){\\n                trib[i] = trib[i - 1] + trib[i - 2] + trib[i - 3];\\n            }\\n            return trib[n];\\n        }\\n    }\\n};\\n```\\nPython 3:\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        elif n == 1 or n == 2:\\n            return 1\\n        else:\\n            trib = [0,1,1];\\n            for i in range(3, n + 1):\\n                trib.append(ans[i - 1] + ans[i - 2] + ans[i - 3])\\n            return trib[n]\\n```\\n\\nExplanation (in psuedo code):\\n\\nthis is a recurive problem where:\\n*     tribonnaci(n) = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3)\\nwith the inital conditions of:\\n*     tribonacci(0) = 0, tribionacci(1) = 1, tribonacci(2) = 1\\n\\nso to start, we hard code in the intital values\\n```\\ndef int tribonacci(int n)\\n\\tif (n == 0)\\n\\t\\treturn 0\\n\\telse if (n == 1) or (n == 2)\\n\\t\\treturn 1\\n```\\nthen if n > 2 we answer the problem recursively:\\n\\tthe naive way to do this is to use functional recursion:\\n```\\ndef int naiveTrib(int n)\\n\\tif (n == 0)\\n\\t\\treturn 0\\n\\telse if (n == 1) or (n == 2)\\n\\t\\treturn 1\\n\\telse if n > 2\\n\\t\\treturn naiveTrib(n - 1) + naiveTrib(n - 2) + naiveTrib(n - 3)\\n```\\nbut this requires redundancy as I will soon show you:\\n\\nif we were to plug in 5 for n, lets see what happens...\\n1) **naiveTrib(5)** calls naiveTrib(**4**), naiveTrib(**3**) and naiveTrib(**2**)\\nnaiveTrib(2) is then easily resolved as 1, but naiveTrib(3) and naiveTrib(4) each call 3 methods themselves!\\n2) **naiveTrib(4)** calls naiveTrib(**3**), naiveTrib(**2**) and naiveTrib(**1**).\\n3) **naiveTrib(3)** calls naiveTrib(**2**), naiveTrib(**1**) and naiveTrib(**0**).\\n4) the three naiveTribs that naiveTrib(3) calls are then easily resolved as 1, 1, and 0 respectively,\\n5)  2 of the functions that naiveTrib(4) calls are easily resolved, with naiveTrib(2) and naiveTrib(1) being resolved as 1, and 1 respectively, \\nbut naiveTrib(3) calls 3 methods yet again!\\n6) **naiveTrib(3)** calls naiveTrib(**2**), naiveTrib(**1**) and naiveTrib(**0**).\\n7) these are finally then resolved easily as 1, 1, and 0\\n\\nThis was extremely redundant!!! we called **naiveTrib(3)** a total of **2 times**, naiveTrib(**2**) **4 times**, naive trib(**1**) **3 times**, and naiveTrib(**0**) **2 times**.\\nthe redundancy also worsens exponentially as n increases!\\n\\nto fix this, we simply make an **array of ints**(integer numbers) that stores the **tribonacci value of n** in its **nth index**... let me explain:\\n1) we make a **new Array** that can (and will eventually) hold every value **up to** and **including** tribonacci(**n**) (as we start from 0, the **size** will be **n + 1**)\\n```\\ndeclare tribonacci: new Array<int> with size(n + 1)\\n```\\n2) then we set our initial values\\n```\\nlet tribonacci[0] = 0 \\nlet tribonacci[1] = 1\\nlet tribonacci[2] = 1\\n```\\n3) then for **every integer** (lets call it \"**i**\") in the **range [3, n]** (inclusive) we **let triboncacci[i]** equal the **sum** of **triboncacci[i - 1], triboncacci[i - 2]**, and **triboncacci[i - 3]**.\\n``` \\nfor int i in range(3, n, inclusive)\\n\\tlet tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3]\\n```\\n4) then, of course, we return the value of tribonacci[n]\\n```\\nreturn tribonacci[n]\\n```\\nFinally, putting that all together its...\\n```\\ndef int tribonacci(int n)\\n\\tif (n == 0)\\n\\t\\treturn 0\\n\\telse if (n == 1) or (n == 2)\\n\\t\\treturn 1\\n\\telse if n > 2\\n\\t\\tdeclare tribonacci: new Array<int> with size(n + 1)\\n\\t\\tlet tribonacci[0] = 0 \\n\\t\\tlet tribonacci[1] = 1\\n\\t\\tlet tribonacci[2] = 1\\n\\t\\tfor int i in range(3, n, inclusive)\\n\\t\\t\\tlet tribonnaci[i] = triboncacci[i - 1] + triboncacci[i - 2] + triboncacci[i - 3]\\n\\t\\treturn tribonacci[n]\\n```\\nThere you go!!!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) { \\n        if (n == 0){\\n            return 0;\\n        } else if (n == 1 || n == 2){\\n            return 1;\\n        } else {\\n            int[] trib = new int[n + 1];\\n            trib[0] = 0;\\n            trib[1] = 1;\\n            trib [2] = 1;\\n            for (int i = 3; i < n + 1; i++){\\n                trib[i] = trib[i - 1] + trib[i - 2] + trib[i - 3];\\n            }\\n            return trib[n];\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n == 0){\\n            return 0;\\n        } else if (n == 1 || n == 2){\\n            return 1;\\n        } else {\\n            int trib[n + 1];\\n            trib[0] = 0;\\n            trib[1] = 1;\\n            trib [2] = 1;\\n            for (int i = 3; i < n + 1; i++){\\n                trib[i] = trib[i - 1] + trib[i - 2] + trib[i - 3];\\n            }\\n            return trib[n];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        elif n == 1 or n == 2:\\n            return 1\\n        else:\\n            trib = [0,1,1];\\n            for i in range(3, n + 1):\\n                trib.append(ans[i - 1] + ans[i - 2] + ans[i - 3])\\n            return trib[n]\\n```\n```\\ndef int tribonacci(int n)\\n\\tif (n == 0)\\n\\t\\treturn 0\\n\\telse if (n == 1) or (n == 2)\\n\\t\\treturn 1\\n```\n```\\ndef int naiveTrib(int n)\\n\\tif (n == 0)\\n\\t\\treturn 0\\n\\telse if (n == 1) or (n == 2)\\n\\t\\treturn 1\\n\\telse if n > 2\\n\\t\\treturn naiveTrib(n - 1) + naiveTrib(n - 2) + naiveTrib(n - 3)\\n```\n```\\ndeclare tribonacci: new Array<int> with size(n + 1)\\n```\n```\\nlet tribonacci[0] = 0 \\nlet tribonacci[1] = 1\\nlet tribonacci[2] = 1\\n```\n``` \\nfor int i in range(3, n, inclusive)\\n\\tlet tribonacci[i] = tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i - 3]\\n```\n```\\nreturn tribonacci[n]\\n```\n```\\ndef int tribonacci(int n)\\n\\tif (n == 0)\\n\\t\\treturn 0\\n\\telse if (n == 1) or (n == 2)\\n\\t\\treturn 1\\n\\telse if n > 2\\n\\t\\tdeclare tribonacci: new Array<int> with size(n + 1)\\n\\t\\tlet tribonacci[0] = 0 \\n\\t\\tlet tribonacci[1] = 1\\n\\t\\tlet tribonacci[2] = 1\\n\\t\\tfor int i in range(3, n, inclusive)\\n\\t\\t\\tlet tribonnaci[i] = triboncacci[i - 1] + triboncacci[i - 2] + triboncacci[i - 3]\\n\\t\\treturn tribonacci[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346639,
                "title": "cpp-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        \\n        int a = 0, b = 1, c = 1;\\n        \\n        int r = 0;\\n        \\n        if(n==0)\\n            return a;\\n        if(n==1)\\n            return b;\\n        if(n==2)\\n            return c;\\n        \\n        for(int i = 0;i < n-2;i++)\\n        {\\n            //cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<r<<endl;\\n            r=a+b+c;\\n            a=b;\\n            b=c;\\n            c=r;\\n        }\\n        \\n        return r;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        \\n        int a = 0, b = 1, c = 1;\\n        \\n        int r = 0;\\n        \\n        if(n==0)\\n            return a;\\n        if(n==1)\\n            return b;\\n        if(n==2)\\n            return c;\\n        \\n        for(int i = 0;i < n-2;i++)\\n        {\\n            //cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<r<<endl;\\n            r=a+b+c;\\n            a=b;\\n            b=c;\\n            c=r;\\n        }\\n        \\n        return r;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3303599,
                "title": "dynamic-programming-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        //Dynamic Programming\\n        list1=[0,1,1]\\n        a,b,c=0,1,1\\n        if n==0: return 0\\n        if n==1: return 1\\n        if n==2: return 1\\n        output=0\\n        for i in range(3,n+1):\\n            output=a+b+c\\n            a,b,c=b,c,output\\n        return output\\n```\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        list1=[0,1,1]\\n        if n<3:\\n            return list1[n]\\n        for i in range(3,n+1):\\n            list1.append(sum(list1[i-3:i]))\\n        return list1[-1]\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        //Dynamic Programming\\n        list1=[0,1,1]\\n        a,b,c=0,1,1\\n        if n==0: return 0\\n        if n==1: return 1\\n        if n==2: return 1\\n        output=0\\n        for i in range(3,n+1):\\n            output=a+b+c\\n            a,b,c=b,c,output\\n        return output\\n```\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        list1=[0,1,1]\\n        if n<3:\\n            return list1[n]\\n        for i in range(3,n+1):\\n            list1.append(sum(list1[i-3:i]))\\n        return list1[-1]\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119288,
                "title": "python-3-7-lines-w-explanation-and-example-t-m-98-96",
                "content": "Similar to *Fibonacci* numbers, *Tribonacci* numbers are generated by a linear transformation, and linear transformations can be composed. We use this fact to expedite the iteration to`n`by threes. \\n- First, we list the initial six *tribs*. \\n- Second, we determine which three will allow us to end on`n`when we iterate by threes.\\n- Third, we iterate to determine`Tn[n]`.\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n\\n        Tn = (0, 1, 1,  2, 4, 7)             \\n        if n < 6: return Tn[n]                              \\n\\n        r = n%3                                         #   r  = 11%3 = 2\\n\\n        a, b, c = Tn[r+1],Tn[r+2],Tn[r+3]               #        a           b            c\\n                                                        #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013    \\n        for _ in range(r+7,n,3):                        #   Tn[3] =  2  Tn[4] =  4  Tn[4] =  7\\n            a, b, c = a+b+c, a+2*b+2*c, 2*a+3*b+4*c     #   Tn[6] = 13  Tn[7] = 24  Tn[8] = 44       \\n                                                        #   \\n        return 2*a+3*b+4*c                              #     return 2(13)+3(24)+4(44) = 274\\n```\\n[https://leetcode.com/problems/n-th-tribonacci-number/submissions/887779606/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n\\n        Tn = (0, 1, 1,  2, 4, 7)             \\n        if n < 6: return Tn[n]                              \\n\\n        r = n%3                                         #   r  = 11%3 = 2\\n\\n        a, b, c = Tn[r+1],Tn[r+2],Tn[r+3]               #        a           b            c\\n                                                        #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013    \\n        for _ in range(r+7,n,3):                        #   Tn[3] =  2  Tn[4] =  4  Tn[4] =  7\\n            a, b, c = a+b+c, a+2*b+2*c, 2*a+3*b+4*c     #   Tn[6] = 13  Tn[7] = 24  Tn[8] = 44       \\n                                                        #   \\n        return 2*a+3*b+4*c                              #     return 2(13)+3(24)+4(44) = 274\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117947,
                "title": "python-easy-solution-95-run-time",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a,b,c=1,0,0\\n        for i in range(n):\\n            tmp=a+b+c\\n            a=b\\n            b=c\\n            c=tmp\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a,b,c=1,0,0\\n        for i in range(n):\\n            tmp=a+b+c\\n            a=b\\n            b=c\\n            c=tmp\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117480,
                "title": "akash-kannan-simple-java-solution",
                "content": "# Intuition\\nSIMPLE JAVA SOLUTION USING FOR LOOP SIMILAR TO FIBONACCI SERIES.\\nBEATS 100%%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int t0=0,t1=1,t2=1;\\n        int trib=0;\\n        if(n==1 || n==2)\\n        {\\n            return 1;\\n        }\\n        for(int i=3;i<=n;i++)\\n        {\\n           trib=t0+t1+t2;\\n           t0=t1;\\n           t1=t2;\\n           t2=trib;\\n        }\\n        return trib;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int tribonacci(int n) {\\n        int t0=0,t1=1,t2=1;\\n        int trib=0;\\n        if(n==1 || n==2)\\n        {\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3117270,
                "title": "java-dp-no-dp-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\n### 1. Using extra space (DP):\\nThe first `3` default numbers are `0, 1, 1`.\\n\\nStore them at the first `3` indices of an array (at index: `0, 1, 2`).\\n\\nStart iterating from index `3`, and at each iteration put the sum of previous `3` numbers into the current index.\\n\\ni.e. **`A[i] = A[i - 1] + A[i - 2] + A[i - 3]`**\\n\\n![image.png](https://assets.leetcode.com/users/images/6190e234-3fc1-45a0-b893-1514c66d381e_1675059865.0988173.png)\\n\\n#### Code:\\n``` java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 3) {    // base case\\n            return (n < 2)? n : 1;\\n        }\\n\\n        int[] a = new int[n+1];   // dp array\\n        a[1] = a[2] = 1;\\n\\n        for (int i = 3; i <= n; i++) {\\n            a[i] = a[i-1] + a[i-2] + a[i-3];\\n        }\\n\\n        return a[n];\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n### 2. No extra space:\\nWe will just play with variables.\\n\\nThree variable will store the initial numbers, and a fourth variable will store the sum of the three.\\n\\nThen we would change the values of the variables in this way:\\n\\n![image.png](https://assets.leetcode.com/users/images/5707fb73-9aa4-41f5-a3b2-5fe0a61b11e4_1675060841.451738.png)\\n\\n#### Code:\\n``` java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 3) {    // base case\\n            return (n < 2)? n : 1;\\n        }\\n\\n        int a = 0, b = 1, c = 1;\\n        for (int i = 3; i <= n; i++) {\\n            int sum = a + b + c;\\n            a = b;\\n            b = c;\\n            c = sum;\\n        }\\n\\n        return c;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 3) {    // base case\\n            return (n < 2)? n : 1;\\n        }\\n\\n        int[] a = new int[n+1];   // dp array\\n        a[1] = a[2] = 1;\\n\\n        for (int i = 3; i <= n; i++) {\\n            a[i] = a[i-1] + a[i-2] + a[i-3];\\n        }\\n\\n        return a[n];\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n < 3) {    // base case\\n            return (n < 2)? n : 1;\\n        }\\n\\n        int a = 0, b = 1, c = 1;\\n        for (int i = 3; i <= n; i++) {\\n            int sum = a + b + c;\\n            a = b;\\n            b = c;\\n            c = sum;\\n        }\\n\\n        return c;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117147,
                "title": "tribonacci-series-optimized-dynamic-programming-approach-o-n-0-ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor this problem, we need to understand how **Fibonacci Series** work. In **Fibonacci series**, the present element is sum of previous three elements. \\n\\nIn **Tribonacci Series**, the present element is sum of previous THREE elements, hence the name.\\n```cpp\\nTrib_4 = Trib_1 + Trib_2 + Trib_3\\nTrib_5 = Trib_2 + Trib_3 + Trib_4\\n\\n```\\nI think you can see how the dynamic programming approach will work by looking at these two equations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere can be two approaches to this problem, One is the naive recursive method and other involves Dynamic Programming approach.\\n\\nI won\\'t discuss the recursive approach because it is very inefficient.\\n```\\nT(n) = T(n-1) + T(n-2) + T(n-3)\\n\\n```\\nHere, *T(n) = O($3^{n}$)*\\n\\nIn the DP approach, we are starting off with the first 3 base cases, and for inputs larger than these, the for loop gets executed.\\n\\nWe store the sum of previous three elements in the ans variable and then update the auxillary variables.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we are iterating only once\\n\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nContant time since no matter what is the input size, the auxillary variables are of fixed size.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) { \\n        // This program is based on zeroth indexing\\n        if(n < 3 && n > 0){ // Base case for n = 1, 2\\n            return 1;\\n        }\\n        if (n==0){ // Base case for n = 0\\n            return n;\\n        }\\n        int t0 = 0, t1 = 1, t2 = 1; // Initializing the auxillary variables\\n        int ans = 0; // Answer variable\\n        for(int i = 2 ; i < n ; i++){\\n            ans = t0 + t1 + t2; // Adding the previous three numbers\\n            // Updating the variables for next iteration\\n            t0 = t1;\\n            t1 = t2;\\n            t2 = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nTrib_4 = Trib_1 + Trib_2 + Trib_3\\nTrib_5 = Trib_2 + Trib_3 + Trib_4\\n\\n```\n```\\nT(n) = T(n-1) + T(n-2) + T(n-3)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) { \\n        // This program is based on zeroth indexing\\n        if(n < 3 && n > 0){ // Base case for n = 1, 2\\n            return 1;\\n        }\\n        if (n==0){ // Base case for n = 0\\n            return n;\\n        }\\n        int t0 = 0, t1 = 1, t2 = 1; // Initializing the auxillary variables\\n        int ans = 0; // Answer variable\\n        for(int i = 2 ; i < n ; i++){\\n            ans = t0 + t1 + t2; // Adding the previous three numbers\\n            // Updating the variables for next iteration\\n            t0 = t1;\\n            t1 = t2;\\n            t2 = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098943,
                "title": "simple-approach-n-th-tribonacci-number",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a=0\\n        b=1\\n        c=1\\n        if n==0 or n==1:\\n            return n\\n        for i in range(2,n):\\n            d=a+b+c\\n            a=b\\n            b=c\\n            c=d\\n        return c\\n```\\nIf you find it helpful, please upvote!!\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a=0\\n        b=1\\n        c=1\\n        if n==0 or n==1:\\n            return n\\n        for i in range(2,n):\\n            d=a+b+c\\n            a=b\\n            b=c\\n            c=d\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744237,
                "title": "faster-than-100-space-optimised-dynamic-programmming",
                "content": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        \\n        \\n        int a=0,b=1,c=1;\\n        int s=0;\\n         if(n==0)\\n                return(a);\\n            if(n==1)\\n                return(b);\\n            if(n==2)\\n                return c;\\n        for(int i=3;i<=n;i++)\\n        {\\n           s=a+b+c;\\n            a=b;\\n            b=c;\\n            c=s;\\n            \\n        }\\n        return(s);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        \\n        \\n        int a=0,b=1,c=1;\\n        int s=0;\\n         if(n==0)\\n                return(a);\\n            if(n==1)\\n                return(b);\\n            if(n==2)\\n                return c;\\n        for(int i=3;i<=n;i++)\\n        {\\n           s=a+b+c;\\n            a=b;\\n            b=c;\\n            c=s;\\n            \\n        }\\n        return(s);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722112,
                "title": "c-simple-no-dp-explained",
                "content": "### 1. Make an Array and Initialize 1st 3 numbers\\n### 2. add previous 3 element to calculate from next\\n### 3. Return nth element\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n==0)\\n\\t\\t\\treturn 0;\\n        if(n<=2)\\n\\t\\t\\treturn 1;\\n        vector<int>tb(n+1);\\n        tb[0] = 0;\\n        tb[1] = 1;\\n        tb[2] = 1;\\n        for(int i=3;i<=n;i++)\\n            tb[i] = tb[i-3]+tb[i-2]+tb[i-1]; \\n        return tb[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n==0)\\n\\t\\t\\treturn 0;\\n        if(n<=2)\\n\\t\\t\\treturn 1;\\n        vector<int>tb(n+1);\\n        tb[0] = 0;\\n        tb[1] = 1;\\n        tb[2] = 1;\\n        for(int i=3;i<=n;i++)\\n            tb[i] = tb[i-3]+tb[i-2]+tb[i-1]; \\n        return tb[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676764,
                "title": "fastest-solution-100-faster-java-c-0ms",
                "content": "```\\n int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1||n==2) return 1;\\n        \\n        int d=0;\\n        for(int a=0,b=1,c=1,i=3;i<=n;++i){\\n            d=a+b+c;\\n            a=b;\\n            b=c;\\n            c=d;\\n        }\\n        return d;\\n    }\\n}\\n```\\n\\nFor C++ Use:\\n\\npublic:\\nint tribonacci(int n){.....}\\n\\nFor Java Use :\\n\\npublic int tribonacci(int n){.....}\\n\\nConsider Upvoting if you find this helpful.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1||n==2) return 1;\\n        \\n        int d=0;\\n        for(int a=0,b=1,c=1,i=3;i<=n;++i){\\n            d=a+b+c;\\n            a=b;\\n            b=c;\\n            c=d;\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2583056,
                "title": "dp-java-solution",
                "content": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1||n==2)return 1;\\n        int[] dp = new int[n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=1;\\n        for(int i=3; i<=n; i++){\\n            dp[i] = dp[i-2]+dp[i-1]+dp[i-3];\\n        }\\n        return dp[n];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1||n==2)return 1;\\n        int[] dp = new int[n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=1;\\n        for(int i=3; i<=n; i++){\\n            dp[i] = dp[i-2]+dp[i-1]+dp[i-3];\\n        }\\n        return dp[n];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570259,
                "title": "python-elegant-short-recursive-iterative-lru-cache",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\t@lru_cache(maxsize=None)\\n\\t\\tdef tribonacci(self, n: int) -> int:\\n\\t\\t\\tif n < 1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif n < 3:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\treturn self.tribonacci(n - 1) + self.tribonacci(n - 2) + self.tribonacci(n - 3)\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef tribonacci(self, n: int) -> int:\\n\\t\\t\\ta, b, c = 0, 1, 1\\n\\t\\t\\tfor _ in range(n):\\n\\t\\t\\t\\ta, b, c = b, c, a + b + c\\n\\t\\t\\treturn a\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\t@lru_cache(maxsize=None)\\n\\t\\tdef tribonacci(self, n: int) -> int:\\n\\t\\t\\tif n < 1:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\tif n < 3:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\treturn self.tribonacci(n - 1) + self.tribonacci(n - 2) + self.tribonacci(n - 3)\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef tribonacci(self, n: int) -> int:\\n\\t\\t\\ta, b, c = 0, 1, 1\\n\\t\\t\\tfor _ in range(n):\\n\\t\\t\\t\\ta, b, c = b, c, a + b + c\\n\\t\\t\\treturn a\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2172879,
                "title": "java-solution",
                "content": "To be honest, we can definitely solve the problem with an old fashion way of fibbonacci solution. But it won\\'t pass the Time Limit on leetcode plateform so we have to do it in this way.\\n\\n```\\nclass Solution \\n{\\n    public int tribonacci(int n)\\n    {\\n        // O(n) time\\n        // O(n) space\\n        if(n < 3)   return n == 0 ? 0 : 1;\\n        \\n        int[] res = new int[n+1];\\n        res[0] = 0;\\n        res[1] = 1;\\n        res[2] = 1;\\n        \\n        for(int i = 3; i <= n; i++)\\n            res[i] = res[i-1] + res[i-2] + res[i-3];\\n        \\n        return res[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int tribonacci(int n)\\n    {\\n        // O(n) time\\n        // O(n) space\\n        if(n < 3)   return n == 0 ? 0 : 1;\\n        \\n        int[] res = new int[n+1];\\n        res[0] = 0;\\n        res[1] = 1;\\n        res[2] = 1;\\n        \\n        for(int i = 3; i <= n; i++)\\n            res[i] = res[i-1] + res[i-2] + res[i-3];\\n        \\n        return res[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143062,
                "title": "c-clean-dp-two-approaches-o-1-space",
                "content": "#1 - Without dp, too slow...\\n\\n```\\n// Time Limit Exceeded\\n// 35 / 39 test cases passed.\\n\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n        => n switch\\n        {\\n            0 => 0,\\n            1 => 1,\\n            2 => 1,\\n            _ => Tribonacci(n - 1) + Tribonacci(n - 2) + Tribonacci(n - 3)\\n        };\\n}\\n```\\n\\n#2 - Top down dp, it passes but uses O(n) space\\n```\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n    {\\n        int?[] dp = new int?[n + 1];\\n        return TribonacciCore(n);\\n\\n        int TribonacciCore(int number)\\n            => dp[number] ??= number switch\\n            {\\n                0 => 0,\\n                1 => 1,\\n                2 => 1,\\n                _ => TribonacciCore(number - 1) + TribonacciCore(number - 2) + TribonacciCore(number - 3)\\n            };\\n    }\\n}\\n```\\n\\n#3 - Bottom up, O(1) space, O(N) time.\\n```\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n    {\\n        if (n is 0) return 0;\\n        if (n is 1) return 1;\\n\\n        int twoBack = 0;\\n        int oneBack = 1;\\n        int current = 1;\\n        for (int index = 2; index < n; index++)\\n        {\\n            (twoBack, oneBack, current) = (oneBack, current, current + oneBack + twoBack);\\n        }\\n\\n        return current;\\n    }\\n}\\n```\\n\\n#4 - tl;dr\\n```\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n    {\\n        if (n is 0 or 1) return n;\\n\\n        (int twoBack, int oneBack, int current)  =  (0, 1, 1);\\n        for (int index = 2; index < n; index++)\\n        {\\n            (twoBack, oneBack, current) = (oneBack, current, current + oneBack + twoBack);\\n        }\\n\\n        return current;\\n    }\\n}\\n```\\n\\n#5 - tl;dr\\n```\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n        => n is 0 or 1\\n            ? n\\n            : Enumerable.Range(0, n - 2)\\n                .Aggregate((0, 1, 1), (x, _) => (x.Item2, x.Item3, x.Item1 + x.Item2 + x.Item3))\\n                .Item3;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Time Limit Exceeded\\n// 35 / 39 test cases passed.\\n\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n        => n switch\\n        {\\n            0 => 0,\\n            1 => 1,\\n            2 => 1,\\n            _ => Tribonacci(n - 1) + Tribonacci(n - 2) + Tribonacci(n - 3)\\n        };\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n    {\\n        int?[] dp = new int?[n + 1];\\n        return TribonacciCore(n);\\n\\n        int TribonacciCore(int number)\\n            => dp[number] ??= number switch\\n            {\\n                0 => 0,\\n                1 => 1,\\n                2 => 1,\\n                _ => TribonacciCore(number - 1) + TribonacciCore(number - 2) + TribonacciCore(number - 3)\\n            };\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n    {\\n        if (n is 0) return 0;\\n        if (n is 1) return 1;\\n\\n        int twoBack = 0;\\n        int oneBack = 1;\\n        int current = 1;\\n        for (int index = 2; index < n; index++)\\n        {\\n            (twoBack, oneBack, current) = (oneBack, current, current + oneBack + twoBack);\\n        }\\n\\n        return current;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n    {\\n        if (n is 0 or 1) return n;\\n\\n        (int twoBack, int oneBack, int current)  =  (0, 1, 1);\\n        for (int index = 2; index < n; index++)\\n        {\\n            (twoBack, oneBack, current) = (oneBack, current, current + oneBack + twoBack);\\n        }\\n\\n        return current;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public int Tribonacci(int n)\\n        => n is 0 or 1\\n            ? n\\n            : Enumerable.Range(0, n - 2)\\n                .Aggregate((0, 1, 1), (x, _) => (x.Item2, x.Item3, x.Item1 + x.Item2 + x.Item3))\\n                .Item3;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621264,
                "title": "c-memoization-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int a[38];\\n    Solution(){\\n        memset(a,-1,sizeof(a));\\n    }\\n    int tribonacci(int n) {\\n        if(a[n]==-1){\\n            int res;\\n            \\n            if(n==0){\\n                res=0;\\n                return 0;\\n                \\n            }\\n            if(n==1 || n==2){\\n                res=1;\\n                return 1;\\n            }\\n            else{\\n            res=tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n            }\\n            a[n]=res;\\n        }\\n        return a[n];\\n        \\n        \\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int a[38];\\n    Solution(){\\n        memset(a,-1,sizeof(a));\\n    }\\n    int tribonacci(int n) {\\n        if(a[n]==-1){\\n            int res;\\n            \\n            if(n==0){\\n                res=0;\\n                return 0;\\n                \\n            }\\n            if(n==1 || n==2){\\n                res=1;\\n                return 1;\\n            }\\n            else{\\n            res=tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n            }\\n            a[n]=res;\\n        }\\n        return a[n];\\n        \\n        \\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583298,
                "title": "java-solution-faster-than-100-recursion-with-dp-memo",
                "content": "```\\nclass Solution {\\n    Map<Integer,Integer> memo = new HashMap<>();\\n    public Solution(){\\n        memo.put(0,0);\\n        memo.put(1,1);\\n        memo.put(2,1);\\n        memo.put(3,2);\\n    }\\n    public int tribonacci(int n) {  \\n        if(memo.containsKey(n)){\\n            return memo.get(n);\\n        }\\n        int s= tribonacci(n-3)+tribonacci(n-2)+tribonacci(n-1); \\n        memo.put(n,s);\\n        return s;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer,Integer> memo = new HashMap<>();\\n    public Solution(){\\n        memo.put(0,0);\\n        memo.put(1,1);\\n        memo.put(2,1);\\n        memo.put(3,2);\\n    }\\n    public int tribonacci(int n) {  \\n        if(memo.containsKey(n)){\\n            return memo.get(n);\\n        }\\n        int s= tribonacci(n-3)+tribonacci(n-2)+tribonacci(n-1); \\n        memo.put(n,s);\\n        return s;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531130,
                "title": "tribonaci-python-o-1-space",
                "content": "Use three variables to keep track of the three previous digits. \\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        if n==1:\\n            return 1\\n        if n==2:\\n            return 1\\n        prev1, prev2,prev3 = 0,1,1\\n        ans = 0\\n        for i in range(3,n+1):\\n            ans = prev1+prev2+prev3\\n            prev1=prev2\\n            prev2=prev3\\n            prev3=ans\\n        return ans\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n == 0:\\n            return 0\\n        if n==1:\\n            return 1\\n        if n==2:\\n            return 1\\n        prev1, prev2,prev3 = 0,1,1\\n        ans = 0\\n        for i in range(3,n+1):\\n            ans = prev1+prev2+prev3\\n            prev1=prev2\\n            prev2=prev3\\n            prev3=ans\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523695,
                "title": "easy-python-soln",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[0,1,1]\\n        for i in range(3,n+1):\\n            dp.append(dp[i-3]+dp[i-2]+dp[i-1])\\n        \\n        return dp[n]\\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        dp=[0,1,1]\\n        for i in range(3,n+1):\\n            dp.append(dp[i-3]+dp[i-2]+dp[i-1])\\n        \\n        return dp[n]\\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504155,
                "title": "o-n-time-o-1-space",
                "content": "```\\npublic class Solution {\\n    public int Tribonacci(int n) {\\n        var t = new int[] { 0, 1, 1 };\\n        for(int i = 3; i <= n; ++i) {\\n            t[i % 3] = t[0] + t[1] + t[2];\\n        }\\n        return t[n % 3];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Tribonacci(int n) {\\n        var t = new int[] { 0, 1, 1 };\\n        for(int i = 3; i <= n; ++i) {\\n            t[i % 3] = t[0] + t[1] + t[2];\\n        }\\n        return t[n % 3];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1483567,
                "title": "ruby-n-2-loop-s-iterations",
                "content": "## Leetcode: 1137. N-th Tribonacci Number.\\n\\n**Ruby: N-2 loop\\'s iterations.**\\n\\nCreate a loop were on each iteration calculated new Tribonacci number, first three elements would be returned by hardcoded return.\\n \\nRuby code:\\n```Ruby\\n# Leetcode: 1137. N-th Tribonacci Number.\\n# https://leetcode.com/problems/n-th-tribonacci-number/\\n# = = = = = = =\\n# Accepted.\\n# Thanks God!\\n# = = = = = = =\\n# https://leetcode.com/explore/challenge/card/september-leetcoding-challenge-2021/639/week-4-september-22nd-september-28th/3986/\\n# @param {Integer} n\\n# @return {Integer}\\ndef tribonacci(n)\\n  a,b,c = 0,1,1\\n  return a if 0 == n\\n  return b if 1 == n\\n  return c if 2 == n\\n  (n-2).times do \\n    a,b,c = b,c,a+b+c\\n  end\\n  return c\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```Ruby\\n# Leetcode: 1137. N-th Tribonacci Number.\\n# https://leetcode.com/problems/n-th-tribonacci-number/\\n# = = = = = = =\\n# Accepted.\\n# Thanks God!\\n# = = = = = = =\\n# https://leetcode.com/explore/challenge/card/september-leetcoding-challenge-2021/639/week-4-september-22nd-september-28th/3986/\\n# @param {Integer} n\\n# @return {Integer}\\ndef tribonacci(n)\\n  a,b,c = 0,1,1\\n  return a if 0 == n\\n  return b if 1 == n\\n  return c if 2 == n\\n  (n-2).times do \\n    a,b,c = b,c,a+b+c\\n  end\\n  return c\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1482855,
                "title": "c-o-1-time-pre-compute-either-offline-or-at-compile-time-w-constexpr",
                "content": "These numbers are not going to change. Ever. We can just pre-compute them. I have used the following Mathematica code pre-compute them:\\n\\n```\\nClearAll[T]\\nT[n_] := T[n] = T[n - 1] + T[n - 2] + T[n - 3]\\nT[0] = 0;\\nT[1] = 1;\\nT[2] = 1;\\nTable[T[n], {n, 0, 37}]\\n```\\n\\nWhich yields this constant time implementation.\\n\\n```\\n    static constexpr int tribonacci(int n) {\\n        constexpr array<int, 38> T = {0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274,\\n\\t\\t    504, 927, 1705, 3136,  5768, 10609, 19513, 35890, 66012, 121415, 223317,\\n\\t\\t\\t410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425,\\n\\t\\t\\t53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103};\\n        return T[n];\\n    }\\n```\\n\\nWe could also use a ```constexpr``` function to pre compute them at compile time, which could look like this:\\n\\n```\\nnamespace {\\n\\nconstexpr int T(const int n) {\\n    if (n == 0) return 0;\\n    if (n <= 2) return 1;\\n    \\n    int a = 0;\\n    int b = 1;\\n    int c = 1;\\n    for (int i = 3; i <= n; ++i) {\\n        const int next = a + b + c;\\n        a = b;\\n        b = c;\\n        c = next;\\n    }\\n    return c;\\n}\\n\\nconstexpr auto generate() {\\n    array<int, 38> ans = {};\\n    for (int i = 0; i < ans.size(); ++i) {\\n        ans[i] = T(i);\\n    }\\n    return ans;\\n}\\n    \\nconstexpr auto Ts = generate();\\n\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static constexpr int tribonacci(int n) {\\n        return Ts[n];\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nClearAll[T]\\nT[n_] := T[n] = T[n - 1] + T[n - 2] + T[n - 3]\\nT[0] = 0;\\nT[1] = 1;\\nT[2] = 1;\\nTable[T[n], {n, 0, 37}]\\n```\n```\\n    static constexpr int tribonacci(int n) {\\n        constexpr array<int, 38> T = {0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274,\\n\\t\\t    504, 927, 1705, 3136,  5768, 10609, 19513, 35890, 66012, 121415, 223317,\\n\\t\\t\\t410744, 755476, 1389537, 2555757, 4700770, 8646064, 15902591, 29249425,\\n\\t\\t\\t53798080, 98950096, 181997601, 334745777, 615693474, 1132436852, 2082876103};\\n        return T[n];\\n    }\\n```\n```constexpr```\n```\\nnamespace {\\n\\nconstexpr int T(const int n) {\\n    if (n == 0) return 0;\\n    if (n <= 2) return 1;\\n    \\n    int a = 0;\\n    int b = 1;\\n    int c = 1;\\n    for (int i = 3; i <= n; ++i) {\\n        const int next = a + b + c;\\n        a = b;\\n        b = c;\\n        c = next;\\n    }\\n    return c;\\n}\\n\\nconstexpr auto generate() {\\n    array<int, 38> ans = {};\\n    for (int i = 0; i < ans.size(); ++i) {\\n        ans[i] = T(i);\\n    }\\n    return ans;\\n}\\n    \\nconstexpr auto Ts = generate();\\n\\n}  // namespace\\n\\nclass Solution {\\npublic:\\n    static constexpr int tribonacci(int n) {\\n        return Ts[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459970,
                "title": "100-faster",
                "content": "***Liked it? Kindly Upvote*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n)\\n    {\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        if(n == 1 || n == 2)\\n        {\\n            return 1;\\n        }\\n        vector<int> dp(n + 1);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n)\\n    {\\n        if(n == 0)\\n        {\\n            return 0;\\n        }\\n        if(n == 1 || n == 2)\\n        {\\n            return 1;\\n        }\\n        vector<int> dp(n + 1);\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for(int i = 3 ; i <= n ; i++)\\n        {\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416952,
                "title": "python-easy-solution-beat-99",
                "content": "\\tclass Solution:\\n\\n\\t\\tdef tribonacci(self, n: int) -> int:\\n\\t\\t\\tlst = [-1 for i in range(n + 1)]\\n\\n\\t\\t\\tdef fun(n):\\n\\t\\t\\t\\tif n == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif n == 1:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tif n == 2:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\tif lst[n] == -1:\\n\\t\\t\\t\\t\\tlst[n] = fun(n - 1) + fun(n - 2) + fun(n - 3)\\n\\t\\t\\t\\treturn lst[n]\\n\\n\\t\\t\\treturn fun(n)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\tclass Solution:\\n\\n\\t\\tdef tribonacci(self, n: int) -> int:\\n\\t\\t\\tlst = [-1 for i in range(n + 1)]\\n\\n\\t\\t\\tdef fun(n):\\n\\t\\t\\t\\tif n == 0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif n == 1:\\n\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\tif n == 2:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\tif lst[n] == -1:\\n\\t\\t\\t\\t\\tlst[n] = fun(n - 1) + fun(n - 2) + fun(n - 3)\\n\\t\\t\\t\\treturn lst[n]\\n\\n\\t\\t\\treturn fun(n)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!",
                "codeTag": "Java"
            },
            {
                "id": 1311602,
                "title": "c-recursive-dp-memoization-dp-tabulation",
                "content": "```\\n// Recursive \\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        if (n <= 1) {\\n            return n;\\n        }    \\n        if (n == 2) {\\n            return 1;\\n        }\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n};\\n```\\n\\n```\\n// DP Memoization\\nclass Solution \\n{\\npublic:\\n    int memoization(int *dp, int n)\\n    {\\n        int result = -1;\\n        if (dp[n] != -1) {\\n            result = dp[n];\\n            return result;\\n        }\\n        if (n <= 1) {\\n            result = n;\\n        }    \\n        else if (n == 2) {\\n            result = 1;\\n        }\\n        else {\\n           result = memoization(dp, n-1) + memoization(dp, n-2) + memoization(dp, n-3);\\n        }\\n        dp[n] = result;\\n        return dp[n];\\n    }\\n    \\n    int tribonacci(int n) \\n    {\\n        int dp[38];\\n        for (int i = 0; i < 38; i++) {\\n            dp[i] = -1;\\n        }\\n        return memoization(dp, n);\\n    }\\n};\\n```\\n\\n```\\n// DP Tabulation\\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        int dp[38];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursive \\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        if (n <= 1) {\\n            return n;\\n        }    \\n        if (n == 2) {\\n            return 1;\\n        }\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n};\\n```\n```\\n// DP Memoization\\nclass Solution \\n{\\npublic:\\n    int memoization(int *dp, int n)\\n    {\\n        int result = -1;\\n        if (dp[n] != -1) {\\n            result = dp[n];\\n            return result;\\n        }\\n        if (n <= 1) {\\n            result = n;\\n        }    \\n        else if (n == 2) {\\n            result = 1;\\n        }\\n        else {\\n           result = memoization(dp, n-1) + memoization(dp, n-2) + memoization(dp, n-3);\\n        }\\n        dp[n] = result;\\n        return dp[n];\\n    }\\n    \\n    int tribonacci(int n) \\n    {\\n        int dp[38];\\n        for (int i = 0; i < 38; i++) {\\n            dp[i] = -1;\\n        }\\n        return memoization(dp, n);\\n    }\\n};\\n```\n```\\n// DP Tabulation\\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        int dp[38];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for (int i = 3; i <= n; i++) {\\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910272,
                "title": "java-readable-100-time-o-n-time-o-1-space-with-explanation",
                "content": "Like fibonacci, a classic recursion with memoization problem, we can apply the same approach to tribonacci.\\n\\nGiven:  Tn+3 = Tn+0 + Tn+1 + Tn+2,\\nwe know: Tn = Tn-3 + Tn-2 + Tn-1.\\nSo the plain/brute-force recursion solution would be:\\n```\\nif(n == 0) return 0;\\nif(n == 1) return 1;\\nif(n == 2) return 1;\\nreturn tribonacci(n-3) + tribonacci(n-2) + tribonacci(n-1);\\n```\\n\\nHowever this wastes a lot of time recalculating the same values over and over. We should store these, \"memoize\", and access as needed instead of recalculating.\\nSince N is guaranteed to be constrained within 0 - 37, we can store this in an array.\\n\\nTime complexity: O(n). Only calculate every value of n once, otherwise we return in O(1).\\nSpace complexity: O(1). Store a constant 38 integer array.\\n\\n\\n```\\nclass Solution {\\n    int[] memo;\\n    \\n    Solution() {\\n        // Initialize memo, with -1 as flags for not calculated\\n        memo = new int[38]; // 0 through 37\\n        memo[0] = 0;\\n        memo[1] = 1;\\n        memo[2] = 1;\\n        for(int i = 3; i < memo.length; i++) memo[i] = -1;\\n    }\\n    \\n    public int tribonacci(int n) {\\n        // If we have already calculated value, return it.\\n        if(memo[n] != -1) {\\n            return memo[n];\\n        }\\n        else {\\n            int result = tribonacci(n-3) + tribonacci(n-2) + tribonacci(n-1);\\n            memo[n] = result;\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nif(n == 0) return 0;\\nif(n == 1) return 1;\\nif(n == 2) return 1;\\nreturn tribonacci(n-3) + tribonacci(n-2) + tribonacci(n-1);\\n```\n```\\nclass Solution {\\n    int[] memo;\\n    \\n    Solution() {\\n        // Initialize memo, with -1 as flags for not calculated\\n        memo = new int[38]; // 0 through 37\\n        memo[0] = 0;\\n        memo[1] = 1;\\n        memo[2] = 1;\\n        for(int i = 3; i < memo.length; i++) memo[i] = -1;\\n    }\\n    \\n    public int tribonacci(int n) {\\n        // If we have already calculated value, return it.\\n        if(memo[n] != -1) {\\n            return memo[n];\\n        }\\n        else {\\n            int result = tribonacci(n-3) + tribonacci(n-2) + tribonacci(n-1);\\n            memo[n] = result;\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791080,
                "title": "c-simple-and-easy-dp-solution-o-n-time-o-1-space-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n <= 1) return n;\\n        if (n == 2) return 1;\\n        int one = 0, two = 1, three = 1, res;\\n        for (int i = 3; i<=n; i++)\\n        {\\n            res = one+two+three;\\n            one = two;\\n            two = three;\\n            three = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if (n <= 1) return n;\\n        if (n == 2) return 1;\\n        int one = 0, two = 1, three = 1, res;\\n        for (int i = 3; i<=n; i++)\\n        {\\n            res = one+two+three;\\n            one = two;\\n            two = three;\\n            three = res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345529,
                "title": "python-o-logn-using-matrix-multiplication",
                "content": "Let\\'s store first three tribonacci numbers as a column vector `t = [[T(0)], [T(1)], [T(2)]] = [[0], [1], [1]]`. We want to find a matrix *M* such that `M * t = [[T(1)], [T(2)], [T(3)]] = [[1], [1], [2]]`. For the dimensions to be correct, *M* has to be a **3x3** matrix. From the definition of tribonacci numbers, we can get that `M = [[0, 1, 0], [0, 0, 1], [1, 1, 1]]`. First row of *M* gets `T[1]` from  *t*, second one gets `T[2]`, and third one gets `T[0] + T[1] + T[2]` which is equal to `T[3]`. `M * t` effectively shifts *t* by 1 to the left, and appends the next tribonacci number to it. Therefore `M^n * t = [[T(n)], [T(n + 1)], [T(n + 2)]]`. Matrix multiplication can be done in O(logN) using [exponentiation by squaring](https://en.wikipedia.org/wiki/Exponentiation_by_squaring) (and numpy does it).\\n\\n**Python code:**\\n```\\nimport numpy as np\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        t = np.matrix([[0], [1], [1]])\\n        M = np.matrix([[0, 1, 0],\\n                       [0, 0, 1],\\n                       [1, 1, 1]])\\n        return (M ** n * t)[0,0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        t = np.matrix([[0], [1], [1]])\\n        M = np.matrix([[0, 1, 0],\\n                       [0, 0, 1],\\n                       [1, 1, 1]])\\n        return (M ** n * t)[0,0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700243,
                "title": "simple-java-solution-with-demo",
                "content": "# Intuition\\nEach element of a tribonacci sequence is based on 3 previous numbers.\\nIn fact, to get current value we need to sum 3 previous numbers.\\nSo there is a need to track only these 3 previous numbers.\\n\\n# Approach\\nWe will track 3 consecutive numbers using integer variables `t_0`, `t_1` and `t_2`. \\nTo start the sequence, we initialise these variables with 0, 1 and 1 correspondingly.\\n\\nAs we need to find n-th tribonacci number, we will create a `for`-loop and find the result.\\nEach time we go to the next iteration, we sum 3 variables and store the result in a `result` variable. Then we update the values of `t_0`, `t_1` and `t_2`:\\n`t_0` gets the value of `t_1`,\\n`t_1` gets the value of `t_2`, and\\n`t_2` gets the value of `result`.\\n\\nIn the demo below blue squares are the `t_0`, `t_1`, `t_2` variables.\\nThe pink square is the `result` variable.\\n\\n![Screen-Recording-2023-06-28-at-6.14.50-PM.gif](https://assets.leetcode.com/users/images/2541f6f7-5b97-4b4c-ac81-4e8f472310a5_1688120349.1401079.gif)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where `n` is the n-th tribonacci number.\\nThis complexity comes from the iteration in a `for`-loop.\\n\\n- Space complexity:\\n$$O(1)$$ as we don\\'t use any additional space except integer variables.\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n <= 2) {\\n            return 1;\\n        }\\n        int result = 0;\\n        int t_0 = 0, t_1 = 1, t_2 = 1;\\n        for (int i = 3; i <= n; i++) {\\n            result = t_0 + t_1 + t_2;\\n            t_0 = t_1;\\n            t_1 = t_2;\\n            t_2 = result;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (n <= 2) {\\n            return 1;\\n        }\\n        int result = 0;\\n        int t_0 = 0, t_1 = 1, t_2 = 1;\\n        for (int i = 3; i <= n; i++) {\\n            result = t_0 + t_1 + t_2;\\n            t_0 = t_1;\\n            t_1 = t_2;\\n            t_2 = result;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332116,
                "title": "c-solution-using-basic-dp",
                "content": "# Intuition\\nSame as fibonacci number sequence.\\n\\n# Approach\\nJust like in fibonacci number sequence we sum two previous terms here we need to sum three previous terms but just like fibonacci sequence we can see that many terms will be repeatedly calculated which will increase the overall time complexity if we try to solve this via recursion. The time complexity can be reduced from an exponential term to a linear one by simply storing the previously calculated result.\\n\\nRecursive approach :\\nT(4) = T(3) + T(2) + T(1) = 2T(2) + 2T(1) + T(0).\\n\\nDP :\\nSimply access previos indices of the array.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int tribonacci(int n) {\\n        // if( n == 0 ){\\n        //     return 0;\\n        // }\\n        // if( n <= 2 ){\\n        //     return 1;\\n        // }\\n        // return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n        vector<long long int> dp = {0,1,1};\\n        for( long long int i = 3; i < 38; i++ ){\\n            dp.push_back( dp[i-1] + dp[i-2] + dp[i-3] );\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int tribonacci(int n) {\\n        // if( n == 0 ){\\n        //     return 0;\\n        // }\\n        // if( n <= 2 ){\\n        //     return 1;\\n        // }\\n        // return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n        vector<long long int> dp = {0,1,1};\\n        for( long long int i = 3; i < 38; i++ ){\\n            dp.push_back( dp[i-1] + dp[i-2] + dp[i-3] );\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188411,
                "title": "c-java-100-solution-using-dynamic-programming-n-th-tribonacci-number",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n==0)\\n            return 0;\\n        int prev = 1,prev2=1,prev3=0;\\n        for(int i=2;i<n;i++)\\n        {\\n            int curr = prev+prev2+prev3;\\n            prev3 = prev2;\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)\\n            return 0;\\n        int prev = 1,prev2=1,prev3=0;\\n        for(int i=2;i<n;i++)\\n        {\\n            int curr = prev+prev2+prev3;\\n            prev3 = prev2;\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n==0)\\n            return 0;\\n        int prev = 1,prev2=1,prev3=0;\\n        for(int i=2;i<n;i++)\\n        {\\n            int curr = prev+prev2+prev3;\\n            prev3 = prev2;\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return prev;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)\\n            return 0;\\n        int prev = 1,prev2=1,prev3=0;\\n        for(int i=2;i<n;i++)\\n        {\\n            int curr = prev+prev2+prev3;\\n            prev3 = prev2;\\n            prev2 = prev;\\n            prev = curr;\\n        }\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134483,
                "title": "python-94-29-faster-dp-o-n",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n==0 or n==1:\\n            return n\\n        elif n==2:\\n            return 1\\n        a=[0,1,1]\\n        for i in range(3,n+1):\\n            a.append(a[i-1]+a[i-2]+a[i-3])\\n        return a[n]\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n==0 or n==1:\\n            return n\\n        elif n==2:\\n            return 1\\n        a=[0,1,1]\\n        for i in range(3,n+1):\\n            a.append(a[i-1]+a[i-2]+a[i-3])\\n        return a[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120544,
                "title": "the-most-unusual-solution-generating-function-time-o-log-n-space-o-1-only-math-without-dp",
                "content": "# Code\\nIt can be one line \\uD83D\\uDE0E\\n```\\nclass Solution:\\n\\n    def tribonacci(self, n: int) -> int:\\n        a = 0.18280353296829546\\n        c = -0.09140176648414775 - 0.34054653082707936j\\n        d = 0.09140176648414775 + 0.34054653082707936j\\n        z1 = 0.5436890126920766\\n        z2 = -0.7718445063460382 + 1.1151425080399373j\\n        z3 = -0.7718445063460382 - 1.1151425080399373j\\n        res = a / math.pow(z1, n + 1) + c / pow(z2, n + 1) + d / pow(z3, n + 1)\\n        return round(res.real)\\n```\\nMicro performance tunning \\uD83E\\uDD13\\n`math.pow(z1,.)` - because `z1` is real $$\\\\mathbb{R}$$, it\\'s faster than just `pow`\\n`pow(z2,.)` - because `z2`,`z3` are complex $$\\\\mathbb{C}$$\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log{n})$$ (because of `pow(num, n)`)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I was at university, we did a generating function for Fibonacci numbers. So I decided to make it for Tribonacci sequence.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Generating function wiki](https://en.wikipedia.org/wiki/Generating_function)\\nLet \\'s use an Ordinary generating function (OGF)\\n\\n$$G(z) = \\\\sum_{n=0}^{\\\\infty}z^nF_n$$\\n\\n$$z^0F_0 = 0$$\\n$$z^1F_1 = z$$\\n$$z^2F_2 = z^2$$\\n$$z^nF_n = z^n(F_{n-1} + F_{n-2} + F_{n-3}), n >= 3$$\\n\\n\\nSum both sides:\\n$$\\\\sum_{n=0}^{\\\\infty}z^nF_n = z + z^2 + \\\\sum_{n=3}^{\\\\infty}z^n(F_{n-1} + F_{n-2} + F_{n-3})$$\\nReplace some sums with $$G(z) = \\\\sum_{n=0}^{\\\\infty}z^nF_n$$\\n$$\\\\sum_{n=3}^{\\\\infty}z^nF_{n-1} = z * \\\\sum_{n=3}^{\\\\infty}z^{n-1}F_{n-1} = z * \\\\sum_{n=2}^{\\\\infty}z^{n}F_{n} = z*(G(z)-z^1F_1-z^0F_0) = z*(G(z)-z-0) = z*G(z)-z^2$$\\n$$\\\\sum_{n=3}^{\\\\infty}z^nF_{n-2} = z^2 * \\\\sum_{n=3}^{\\\\infty}z^{n-2}F_{n-2} = z^2 * \\\\sum_{n=1}^{\\\\infty}z^{n}F_{n} = z^2*G(z) = z^2*(G(z) - z^0F_0) = z^2*(G(z) - 0) = z^2*G(z)$$\\n$$\\\\sum_{n=3}^{\\\\infty}z^nF_{n-3} = z^3 * \\\\sum_{n=3}^{\\\\infty}z^{n-3}F_{n-3} = z^3 * \\\\sum_{n=0}^{\\\\infty}z^{n}F_{n} = z^3*G(z)$$\\n$$G(z) = z + z ^ 2 + z*G(z) - z^2 + z^2*G(z) + z^3*G(z)$$\\n$$G(z) = z + z*G(z) + z^2*G(z) + z^3*G(z)$$\\n$$G(z) - z*(G(z)-z) - z^2*G(z) - z^3*G(z) = z$$\\n$$G(z)(1-z-z^2-z^3)=z$$\\n$$G(z) = \\\\frac{z}{1-z-z^2-z^3}$$\\n\\nNow it needs to transform in such view from which it\\'s possible to apply formula of the sum of an infinitely decreasing geometric progression:\\n$$\\\\frac{1}{1-kz}=1+kz+(kz)^2+...=\\\\sum_{n=0}^{\\\\infty}k^nz^n$$.\\n\\nFor this it needs to solve this equation $$1 - z - z^2 - z^3$$.\\nLet\\'s solve it, you need to type in Google `solve cubic equation online` \\uD83D\\uDC41\\uD83D\\uDC44\\uD83D\\uDC41\\n\\nThere are 3 solutions to this equation:\\n* One solution is in real numbers $$\\\\mathbb{R}$$: $$z_1=0.5436890126920766$$;\\n* Two solutions are in complex numbers $$\\\\mathbb{C}$$:\\n    * $$z_2=-0.7718445063460382+i1.1151425080399373$$,\\n    * $$z_3=-0.7718445063460382-i1.1151425080399373$$.\\n\\nFirst decompose:\\n$$\\\\frac{z}{1-z-z^2-z^3}=\\\\frac{a}{z-z_1}+\\\\frac{b}{(z-z_2)(z-z_3)}$$\\nMultiply both sides on $$1-z-z^2-z^3$$\\n$$z=a(z-z_2)(z-z_3)+b(z-z_1)$$\\nPut $$z_1$$ to the equation above than $$a=\\\\frac{z_1}{(z_1-z_2)(z_1-z_3)}$$\\n$$a=0.18280353296829546$$\\nPut $$z_2$$ to the equation and get $$b=\\\\frac{z_2}{z_2-z_1}$$\\n$$b=0.7595158249816182-i0.2038519902328264$$\\n\\nSecond decompose:\\n$$\\\\frac{b}{(z-z_2)(z-z_3)}=\\\\frac{c}{z-z_2}+\\\\frac{d}{z-z_3}$$\\n$$b=c(z-z_3)+d(z-z_2)$$\\nPut $$z_2$$ to the equation above than $$c=\\\\frac{b}{z_2-z_3}$$\\n$$c=-0.09140176648414775-i0.34054653082707936$$\\nPut $$z_3$$ to the equation and get $$d=\\\\frac{b}{z_3-z_2}$$\\n$$d=0.09140176648414775+i0.34054653082707936$$\\n\\nLet\\'s write decomposed fraction:\\n$$\\\\frac{z}{1-z-z^2-z^3}=\\\\frac{a}{z-z_1}+\\\\frac{c}{z-z_2}+\\\\frac{d}{z-z_3}$$\\n\\nEach small fraction transform to $$\\\\frac{1}{1-kz}=1+kz+(kz)^2+...=\\\\sum_{n=0}^{\\\\infty}k^nz^n$$\\n$$\\\\frac{a}{z-z_1}=-\\\\frac{a}{z_1}\\\\frac{1}{1-\\\\frac{z}{z_1}}=-\\\\frac{a}{z_1}\\\\sum_{n=0}^{\\\\infty}(\\\\frac{1}{z_1})^n*z^n$$\\n$$\\\\frac{c}{z-z_2}=-\\\\frac{c}{z_2}\\\\frac{1}{1-\\\\frac{z}{z_2}}=-\\\\frac{c}{z_2}\\\\sum_{n=0}^{\\\\infty}(\\\\frac{1}{z_2})^n*z^n$$\\n$$\\\\frac{d}{z-z_3}=-\\\\frac{d}{z_3}\\\\frac{1}{1-\\\\frac{z}{z_3}}=-\\\\frac{d}{z_3}\\\\sum_{n=0}^{\\\\infty}(\\\\frac{1}{z_3})^n*z^n$$\\n\\nI don\\'t know where I made a mistake but there is no need in minus (-) before them :)\\nPlease point on my mistake if you find it\\n\\n$$G(z)=\\\\frac{a}{z_1}\\\\sum_{n=0}^{\\\\infty}(\\\\frac{1}{z_1})^n*z^n + \\\\frac{c}{z_2}\\\\sum_{n=0}^{\\\\infty}(\\\\frac{1}{z_2})^n*z^n + \\\\frac{d}{z_3}\\\\sum_{n=0}^{\\\\infty}(\\\\frac{1}{z_3})^n*z^n=\\\\sum_{n=0}^{\\\\infty}(\\\\frac{a}{z_1^{n+1}}+\\\\frac{c}{z_2^{n+1}}+\\\\frac{d}{z_3^{n+1}})z^n$$\\nRemind you that $$G(z) = \\\\sum_{n=0}^{\\\\infty}z^nF_n$$ than $$\\\\sum_{n=0}^{\\\\infty}(\\\\frac{a}{z_1^{n+1}}+\\\\frac{c}{z_2^{n+1}}+\\\\frac{d}{z_3^{n+1}})z^n=\\\\sum_{n=0}^{\\\\infty}F_nz^n$$\\n$$F_n=\\\\frac{a}{z_1^{n+1}}+\\\\frac{c}{z_2^{n+1}}+\\\\frac{d}{z_3^{n+1}}$$\\n\\n```\\nclass Solution:\\n\\n    def tribonacci(self, n: int) -> int:\\n        a = 0.18280353296829546\\n        c = -0.09140176648414775 - 0.34054653082707936j\\n        d = 0.09140176648414775 + 0.34054653082707936j\\n        z1 = 0.5436890126920766\\n        z2 = -0.7718445063460382 + 1.1151425080399373j\\n        z3 = -0.7718445063460382 - 1.1151425080399373j\\n        res = a / math.pow(z1, n + 1) + c / pow(z2, n + 1) + d / pow(z3, n + 1)\\n        return round(res.real)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n\\n    def tribonacci(self, n: int) -> int:\\n        a = 0.18280353296829546\\n        c = -0.09140176648414775 - 0.34054653082707936j\\n        d = 0.09140176648414775 + 0.34054653082707936j\\n        z1 = 0.5436890126920766\\n        z2 = -0.7718445063460382 + 1.1151425080399373j\\n        z3 = -0.7718445063460382 - 1.1151425080399373j\\n        res = a / math.pow(z1, n + 1) + c / pow(z2, n + 1) + d / pow(z3, n + 1)\\n        return round(res.real)\\n```\n```\\nclass Solution:\\n\\n    def tribonacci(self, n: int) -> int:\\n        a = 0.18280353296829546\\n        c = -0.09140176648414775 - 0.34054653082707936j\\n        d = 0.09140176648414775 + 0.34054653082707936j\\n        z1 = 0.5436890126920766\\n        z2 = -0.7718445063460382 + 1.1151425080399373j\\n        z3 = -0.7718445063460382 - 1.1151425080399373j\\n        res = a / math.pow(z1, n + 1) + c / pow(z2, n + 1) + d / pow(z3, n + 1)\\n        return round(res.real)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118119,
                "title": "dynamic-programming-memoization-tabulation-space-optimization-techniques-0-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int tribonacci(int n) {\\n        int[] aux = new int[n+1];\\n        return findTribonacci(aux,n);    \\n    }\\n    private int findTribonacci(int[] arr,int n){\\n        if(n == 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 1;\\n        int first = 0;\\n        if(arr[n-1] > 0) first = arr[n-1];\\n        else{\\n             first = findTribonacci(arr,n-1);\\n             arr[n-1] = first;\\n        }\\n\\n        int second = 0;\\n        if(arr[n-2] > 0) second = arr[n-2];\\n        else{\\n             second = findTribonacci(arr,n-2);\\n             arr[n-2] = second;\\n        }\\n\\n        int third = 0;\\n        if(arr[n-3] > 0) third = arr[n-3];\\n        else{\\n             third = findTribonacci(arr, n-3);\\n             arr[n-3] = third;\\n        }\\n        return first + second + third;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int tribonacci(int n) {\\n        int[] aux = new int[n+1];\\n        return findTribonacci(aux,n);    \\n    }\\n    private int findTribonacci(int[] arr,int n){\\n        if(n == 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 1;\\n        int first = 0;\\n        if(arr[n-1] > 0) first = arr[n-1];\\n        else{\\n             first = findTribonacci(arr,n-1);\\n             arr[n-1] = first;\\n        }\\n\\n        int second = 0;\\n        if(arr[n-2] > 0) second = arr[n-2];\\n        else{\\n             second = findTribonacci(arr,n-2);\\n             arr[n-2] = second;\\n        }\\n\\n        int third = 0;\\n        if(arr[n-3] > 0) third = arr[n-3];\\n        else{\\n             third = findTribonacci(arr, n-3);\\n             arr[n-3] = third;\\n        }\\n        return first + second + third;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117948,
                "title": "simple-java-o-n-easy-beginners",
                "content": "# Intuition\\nGeekster Platform\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        // initialize 3 numbers\\n        int a = 0;\\n        int b = 1;\\n        int c = 1;\\n        int i = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        if(n == 1) {\\n            return 1;\\n        }\\n        if(n == 2) {\\n            return 1;\\n        }\\n        while(i < n - 2) {\\n            int d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n            i ++; \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        // initialize 3 numbers\\n        int a = 0;\\n        int b = 1;\\n        int c = 1;\\n        int i = 0;\\n        if(n == 0) {\\n            return 0;\\n        }\\n        if(n == 1) {\\n            return 1;\\n        }\\n        if(n == 2) {\\n            return 1;\\n        }\\n        while(i < n - 2) {\\n            int d = a + b + c;\\n            a = b;\\n            b = c;\\n            c = d;\\n            i ++; \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117425,
                "title": "recursion-memoized-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be solved iteratively but tried recusion.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbase condition \\nn=0, n=1 ans n=2\\nhypothesis\\nto have the value of tribonacci n-1,n-2 and n-3\\ninduction \\ntribonacci n = sum of tribonacci n-1,n-2 and n-3; \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ -> since it is memoized it will not calculate again the value it already calculated.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ -> array of size 100 is constant space.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[100];\\n    int search(int n){\\n        if( n==0) return 0;\\n        if(n==1 || n==2) return 1;\\n        if(dp[n]!= -1) return dp[n];\\n        return dp[n] = search(n-3) + search(n-2) + search(n-1); \\n    }\\n    int tribonacci(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return search(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100];\\n    int search(int n){\\n        if( n==0) return 0;\\n        if(n==1 || n==2) return 1;\\n        if(dp[n]!= -1) return dp[n];\\n        return dp[n] = search(n-3) + search(n-2) + search(n-1); \\n    }\\n    int tribonacci(int n) {\\n        memset(dp,-1,sizeof(dp));\\n        return search(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117218,
                "title": "c-3-approach-memoization-tabulation-space-optimization",
                "content": "# Memoization\\n```\\nclass Solution \\n{\\npublic:\\n    int dp[38];\\n    int f(int n)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1 || n==2) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n] = f(n-1)+f(n-2)+f(n-3);\\n    }\\n    int tribonacci(int n) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return f(n);\\n    }\\n};\\n```\\n\\n# Tabulation\\n\\n```\\nint tribonacci(int n) \\n{\\n    if(n==0) return 0;\\n    if(n==1 || n==2) return 1;\\n    vector<int> dp(n+1, 0);\\n    dp[0]=0;\\n    dp[1] = dp[2] = 1;\\n    for(int i=3; i<=n; i++)\\n    {\\n        dp[i] = dp[i-1]+dp[i-2]+dp[i-3];\\n    }\\n\\n    return dp[n];\\n}\\n```\\n\\n# Space Optimization   \\n\\n\\n```\\nint tribonacci(int n) \\n{\\n    if(n==0) return 0;\\n    if(n==1 || n==2) return 1;\\n    int t0=0, t1=1, t2=1, t;\\n    for(int i=3; i<=n; i++)\\n    {\\n        t = t0+t1+t2;\\n        t0=t1;\\n        t1=t2;\\n        t2=t;\\n    }\\n\\n    return t;\\n}\\n```\\n    \\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int dp[38];\\n    int f(int n)\\n    {\\n        if(n<=0) return 0;\\n        if(n==1 || n==2) return 1;\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n] = f(n-1)+f(n-2)+f(n-3);\\n    }\\n    int tribonacci(int n) \\n    {\\n        memset(dp, -1, sizeof(dp));\\n        return f(n);\\n    }\\n};\\n```\n```\\nint tribonacci(int n) \\n{\\n    if(n==0) return 0;\\n    if(n==1 || n==2) return 1;\\n    vector<int> dp(n+1, 0);\\n    dp[0]=0;\\n    dp[1] = dp[2] = 1;\\n    for(int i=3; i<=n; i++)\\n    {\\n        dp[i] = dp[i-1]+dp[i-2]+dp[i-3];\\n    }\\n\\n    return dp[n];\\n}\\n```\n```\\nint tribonacci(int n) \\n{\\n    if(n==0) return 0;\\n    if(n==1 || n==2) return 1;\\n    int t0=0, t1=1, t2=1, t;\\n    for(int i=3; i<=n; i++)\\n    {\\n        t = t0+t1+t2;\\n        t0=t1;\\n        t1=t2;\\n        t2=t;\\n    }\\n\\n    return t;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116949,
                "title": "easy-and-short-and-understandable-code-greedy-approach",
                "content": "# Intuition\\n\\n# Approach\\nGreedy Approach\\n\\n# Complexity\\n- Time complexity:\\n- O(n-3)\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int prev1 = 0;\\n        int prev = 1;\\n        int curr =1;\\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 1;\\n        }\\n        for(int i =3;i<=n;i++){\\n            int temp = curr;\\n            curr = curr+prev+prev1;\\n            prev1 = prev;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```\\n![025a6e75-7e39-4bdd-8ecd-ea9c6023729a_1672712882.8563874.png](https://assets.leetcode.com/users/images/4a6011bc-2d39-4107-b92a-4ce46cd2e954_1675065376.0239704.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int prev1 = 0;\\n        int prev = 1;\\n        int curr =1;\\n        if(n == 0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return 1;\\n        }\\n        if(n==2){\\n            return 1;\\n        }\\n        for(int i =3;i<=n;i++){\\n            int temp = curr;\\n            curr = curr+prev+prev1;\\n            prev1 = prev;\\n            prev = temp;\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116356,
                "title": "java-simple-and-step-by-step-explained-dp-memoization-approach-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic Programming (Memoization)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1: Store the first 3 element as 0 1 1\\n2: Start loop from 3\\n3: dp[i] is calculated as dp[i-1] dp[i-2] + dp[i-3] \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->)(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n\\n        // 0th element of your series is 0\\n\\n        if(n==0){\\n            return 0;\\n        }\\n        // 1st and 2nd element of the series are 1 (Given in the question)\\n        if(n == 1 || n==2){\\n            return 1;\\n        }\\n        //Create a dp array of n+1 size\\n        int dp[] = new int [n+1];\\n        //intialize first three elements\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n\\n        // start the loop from 3 because 0,1,2 are pre intialize\\n        for(int i = 3; i <= n; i++){\\n\\n            dp[i] = dp[i-1] + dp[i-2] +dp[i-3];\\n        }\\n        return dp[n]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n\\n        // 0th element of your series is 0\\n\\n        if(n==0){\\n            return 0;\\n        }\\n        // 1st and 2nd element of the series are 1 (Given in the question)\\n        if(n == 1 || n==2){\\n            return 1;\\n        }\\n        //Create a dp array of n+1 size\\n        int dp[] = new int [n+1];\\n        //intialize first three elements\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n\\n        // start the loop from 3 because 0,1,2 are pre intialize\\n        for(int i = 3; i <= n; i++){\\n\\n            dp[i] = dp[i-1] + dp[i-2] +dp[i-3];\\n        }\\n        return dp[n]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116267,
                "title": "java-solution-linear-tc-0ms",
                "content": "# Intuition\\nSimilar to what we do in fibonacci series.\\n\\n\\n# Approach\\n \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int t0=0,t1=1,t2=1;\\n        if(n==0) return t0;\\n        else if(n==1) return t1;\\n        else if(n==2) return t2;\\n        while(n-->2){\\n            int nextVal = t0+t1+t2;\\n            t0=t1;\\n            t1=t2;\\n            t2=nextVal;\\n        }\\n        return t2;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int t0=0,t1=1,t2=1;\\n        if(n==0) return t0;\\n        else if(n==1) return t1;\\n        else if(n==2) return t2;\\n        while(n-->2){\\n            int nextVal = t0+t1+t2;\\n            t0=t1;\\n            t1=t2;\\n            t2=nextVal;\\n        }\\n        return t2;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115854,
                "title": "javascript-array-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force method to solve number sequence is by recurrsion. However, this would end up with TEL.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, try to see if it is possible to generalize an equation for this number sequence. However the [generalize solution](https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers) is rather complicated.\\n\\nSince we only need the last 3 values of the sequence, we can store them in an array and update it in a loop.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code - Recurrsion (TEL)\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    if (n == 0) return 0;\\n    if (n == 1) return 1;\\n    if (n == 2) return 1;\\n    return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n};\\n```\\n\\n# Code - Array\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    if (n == 0) return 0;\\n    if (n == 1) return 1;\\n    if (n == 2) return 1;\\n    const seq = [0, 1, 1]\\n    for (let i=3; i<=n; i++) {\\n        seq.push(seq[0] + seq[1] + seq[2]);\\n        seq.shift();\\n    }\\n    return seq[2];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    if (n == 0) return 0;\\n    if (n == 1) return 1;\\n    if (n == 2) return 1;\\n    return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n};\\n```\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar tribonacci = function(n) {\\n    if (n == 0) return 0;\\n    if (n == 1) return 1;\\n    if (n == 2) return 1;\\n    const seq = [0, 1, 1]\\n    for (let i=3; i<=n; i++) {\\n        seq.push(seq[0] + seq[1] + seq[2]);\\n        seq.shift();\\n    }\\n    return seq[2];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3115852,
                "title": "o-n-tc-o-1-sc",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDE6\\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDF2 \\uD835\\uDDE9\\uD835\\uDDF6\\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDDFC \\uD835\\uDDE6\\uD835\\uDDFC\\uD835\\uDDF9\\uD835\\uDE02\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB | \\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/tpIoOf4gXA0\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar tribonacci = function(n) {\\n    if (n == 0) return 0\\n\\n    let t0 = 0\\n    let t1 = 1\\n    let t2 = 1\\n    for (let i = 3; i <= n; i++) {\\n        [t0,t1,t2] = [t1,t2,t0+t1+t2]\\n    }\\n    return t2;\\n};\\n\\n\\n// 0,1,1,2,4,7...\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar tribonacci = function(n) {\\n    if (n == 0) return 0\\n\\n    let t0 = 0\\n    let t1 = 1\\n    let t2 = 1\\n    for (let i = 3; i <= n; i++) {\\n        [t0,t1,t2] = [t1,t2,t0+t1+t2]\\n    }\\n    return t2;\\n};\\n\\n\\n// 0,1,1,2,4,7...\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3115850,
                "title": "easy-video-explanation-t-c-o-n-s-c-o-1-beats-100-c",
                "content": "# Intuition and Approach\\n  https://youtu.be/s8_hOcINXd4\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n<3)\\n        {\\n            if(n==0) return 0;\\n            return 1;\\n        }\\n        int a=0,b=1,c=1,d;\\n        for(int i=3;i<=n;i++)\\n        {\\n            d=a+b+c;\\n            a=b;\\n            b=c;\\n            c=d;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n<3)\\n        {\\n            if(n==0) return 0;\\n            return 1;\\n        }\\n        int a=0,b=1,c=1,d;\\n        for(int i=3;i<=n;i++)\\n        {\\n            d=a+b+c;\\n            a=b;\\n            b=c;\\n            c=d;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115830,
                "title": "python3-26-ms-faster-than-92-94-of-python3",
                "content": "```\\nclass Solution:\\n    dict = {0:0,1:1,2:1}\\n    def tribonacci(self, n: int) -> int:\\n        if n<3:\\n            return self.dict[n]\\n        elif n in self.dict:\\n            return self.dict[n]\\n        self.dict[n] = self.tribonacci(n-3) + self.tribonacci(n-2) + self.tribonacci(n-1)\\n        return self.dict[n]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    dict = {0:0,1:1,2:1}\\n    def tribonacci(self, n: int) -> int:\\n        if n<3:\\n            return self.dict[n]\\n        elif n in self.dict:\\n            return self.dict[n]\\n        self.dict[n] = self.tribonacci(n-3) + self.tribonacci(n-2) + self.tribonacci(n-1)\\n        return self.dict[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115591,
                "title": "c-dp-memory-reduction",
                "content": "# Intuition & Approach\\nhttps://youtu.be/KgewaEdfIt8\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        vector<int> seq(3);\\n        seq[1] = seq[2] = 1;\\n\\n        for (int i = 3; i <= n; ++i)\\n            seq[i % 3] = seq[(i - 1) % 3] + seq[(i - 2) % 3] + seq[(i - 3) % 3];\\n\\n        return seq[n % 3];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        vector<int> seq(3);\\n        seq[1] = seq[2] = 1;\\n\\n        for (int i = 3; i <= n; ++i)\\n            seq[i % 3] = seq[(i - 1) % 3] + seq[(i - 2) % 3] + seq[(i - 3) % 3];\\n\\n        return seq[n % 3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115579,
                "title": "c-0ms-beats-100-math-solution-single-line-solution",
                "content": "Explicit math formula : https://mathworld.wolfram.com/TribonacciNumber.html\\n\\n```\\n#define b 1.83928675521416113255185256465328660042417874609759224677875863940420322208196642573843541942830700\\n#define k 0.336228116994941094225362954014332415157926090020459280443706248543829536991081917450120927806223168\\nclass Solution {\\npublic:\\n    inline int tribonacci(int n) {\\n        return round( pow(b, n) * k );\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define b 1.83928675521416113255185256465328660042417874609759224677875863940420322208196642573843541942830700\\n#define k 0.336228116994941094225362954014332415157926090020459280443706248543829536991081917450120927806223168\\nclass Solution {\\npublic:\\n    inline int tribonacci(int n) {\\n        return round( pow(b, n) * k );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096470,
                "title": "both-memoization-and-tabulation-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//// MEMOIZATION\\n    // int f(int n ,vector<int> &dp){\\n    //     if(n==0 || n==1) return n;\\n    //     if(n==2) return 1;\\n    //     if(dp[n] != -1 ) return dp[n];\\n    //     return dp[n] = f(n-1,dp) + f(n-2,dp) + f(n-3,dp);\\n    // }\\n\\n    // int tribonacci(int n) {\\n    //     vector<int>dp(n+1,-1);\\n    //     return f(n,dp);\\n    // }\\n\\n//// TABULATION\\n    int tribonacci(int n) {\\n        vector<int>dp(n+1,0);\\n        for(int i=0;i<=n;i++){\\n            if(i==0 || i == 1) dp[i] = i;\\n            else if(i==2) dp[i] = 1;\\n            else{\\n                dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//// MEMOIZATION\\n    // int f(int n ,vector<int> &dp){\\n    //     if(n==0 || n==1) return n;\\n    //     if(n==2) return 1;\\n    //     if(dp[n] != -1 ) return dp[n];\\n    //     return dp[n] = f(n-1,dp) + f(n-2,dp) + f(n-3,dp);\\n    // }\\n\\n    // int tribonacci(int n) {\\n    //     vector<int>dp(n+1,-1);\\n    //     return f(n,dp);\\n    // }\\n\\n//// TABULATION\\n    int tribonacci(int n) {\\n        vector<int>dp(n+1,0);\\n        for(int i=0;i<=n;i++){\\n            if(i==0 || i == 1) dp[i] = i;\\n            else if(i==2) dp[i] = 1;\\n            else{\\n                dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n            }\\n        }\\n        return dp[n];\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055884,
                "title": "solution-using-memoisation-beats-92",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    dict1 = {0:0,1:1,2:1}\\n#global hashmap to save tribonacci and refer\\n    \\n    def tribonacci(self, n: int) -> int:        \\n        #solution exist in hashmap\\n        if n<3:\\n            return self.dict1[n]\\n\\n        #if solution exists in map return\\n        elif n in self.dict1:\\n            return self.dict1[n]\\n\\n        #calculate it recursively and save in map\\n        self.dict1[n] = self.tribonacci(n-3) + self.tribonacci(n-2) + self.tribonacci(n-1)\\n        return self.dict1[n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    dict1 = {0:0,1:1,2:1}\\n#global hashmap to save tribonacci and refer\\n    \\n    def tribonacci(self, n: int) -> int:        \\n        #solution exist in hashmap\\n        if n<3:\\n            return self.dict1[n]\\n\\n        #if solution exists in map return\\n        elif n in self.dict1:\\n            return self.dict1[n]\\n\\n        #calculate it recursively and save in map\\n        self.dict1[n] = self.tribonacci(n-3) + self.tribonacci(n-2) + self.tribonacci(n-1)\\n        return self.dict1[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001324,
                "title": "c-easy-solution-easy-to-understand-3-approach-o-n-dp-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1 || n==2){\\n            return 1;\\n        }\\n        return solve(n-1) + solve(n-2) + solve(n-3);\\n    }\\n\\n    int solveDP(int n,vector<int> &dp){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1 || n==2){\\n            return 1;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        return dp[n] = solveDP(n-1,dp) + solveDP(n-2,dp) + solveDP(n-3,dp);\\n    }\\n\\n\\n\\n    int tribonacci(int n) {\\n        \\n        // Recursion Solution - TIME LIMIT EXCEED - PASSED 35 TEST CASE\\n        // return solve(n);\\n        \\n        // DP Solution - ACCEPTED\\n        // vector<int> dp(n+1,-1);\\n        // return solveDP(n,dp);\\n\\n        // For Loop Solution - ACCEPTED\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1 || n==2){\\n            return 1;\\n        }\\n        int prev1 = 0;\\n        int prev2 = 1;\\n        int prev3 = 1;\\n        for(int i=3; i<=n; i++){\\n            int curr = prev1 + prev2 + prev3;\\n            prev1 = prev2;\\n            prev2 = prev3;\\n            prev3= curr;\\n        }\\n        return prev3;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(int n){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1 || n==2){\\n            return 1;\\n        }\\n        return solve(n-1) + solve(n-2) + solve(n-3);\\n    }\\n\\n    int solveDP(int n,vector<int> &dp){\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1 || n==2){\\n            return 1;\\n        }\\n        if(dp[n]!=-1){\\n            return dp[n];\\n        }\\n        return dp[n] = solveDP(n-1,dp) + solveDP(n-2,dp) + solveDP(n-3,dp);\\n    }\\n\\n\\n\\n    int tribonacci(int n) {\\n        \\n        // Recursion Solution - TIME LIMIT EXCEED - PASSED 35 TEST CASE\\n        // return solve(n);\\n        \\n        // DP Solution - ACCEPTED\\n        // vector<int> dp(n+1,-1);\\n        // return solveDP(n,dp);\\n\\n        // For Loop Solution - ACCEPTED\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1 || n==2){\\n            return 1;\\n        }\\n        int prev1 = 0;\\n        int prev2 = 1;\\n        int prev3 = 1;\\n        for(int i=3; i<=n; i++){\\n            int curr = prev1 + prev2 + prev3;\\n            prev1 = prev2;\\n            prev2 = prev3;\\n            prev3= curr;\\n        }\\n        return prev3;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829870,
                "title": "c-easy-to-understand-solution",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    int tribonacci(int n) {\\n        vector<int> arr;\\n        arr.push_back(0);\\n        arr.push_back(1);\\n        arr.push_back(1);\\n        for(int i=3;i<=n;i++){\\n            arr.push_back(arr[i-1]+arr[i-2]+arr[i-3]);\\n        }\\n        \\n        return arr[n];\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int tribonacci(int n) {\\n        vector<int> arr;\\n        arr.push_back(0);\\n        arr.push_back(1);\\n        arr.push_back(1);\\n        for(int i=3;i<=n;i++){\\n            arr.push_back(arr[i-1]+arr[i-2]+arr[i-3]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2676264,
                "title": "python-using-a-list",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n       \\n        v=[0,1,1]\\n        if n<3:\\n            return v[n]\\n        \\n        for i in range(3,n+1):\\n            v.append(sum(v[i-3:i]))\\n        return v[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n       \\n        v=[0,1,1]\\n        if n<3:\\n            return v[n]\\n        \\n        for i in range(3,n+1):\\n            v.append(sum(v[i-3:i]))\\n        return v[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563803,
                "title": "dp-optimal-solution-o-1-space-beats-91-time-97-memory",
                "content": "Runtime: 32 ms, **faster than 91.32%** of Python3 online submissions for N-th Tribonacci Number.\\nMemory Usage: 13.7 MB, **less than 97.00%** of Python3 online submissions for N-th Tribonacci Number.\\n\\n\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        t0, t1, t2 = 0, 1, 1\\n        if n == 0 or n == 1:\\n            return n\\n        if n == 2:\\n            return 1\\n        \\n        for i in range(2, n):\\n            t = t0 + t1 + t2\\n            t2, t1, t0 = t, t2, t1\\n        \\n        return t\\n```\\n**Time : O(n)\\nSpace : O(1)**\\n\\nIf it helped you, kindly upvote :)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        t0, t1, t2 = 0, 1, 1\\n        if n == 0 or n == 1:\\n            return n\\n        if n == 2:\\n            return 1\\n        \\n        for i in range(2, n):\\n            t = t0 + t1 + t2\\n            t2, t1, t0 = t, t2, t1\\n        \\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411325,
                "title": "all-approaches-c-recursion-dp-easy",
                "content": "Recursion (Top-Down) : (Gives TLE)\\nT.C: 3^n\\nS.C: O(n) (Recursion Stack)\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n == 1 or n == 2) return 1;\\n        \\n        return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\\n    }\\n};\\n```\\n\\nMemoization (Top-Down):\\nT.C: O(n)\\nS.C: O(n) (Recursion Stack) + O(n) (Dp Array)\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        \\n        vector<int> dp (n+1, -1);\\n        return memoize(n, dp);\\n    }\\n    \\n    int memoize(int n, vector<int> &dp)\\n    {\\n        if(n == 0) return 0;\\n        if(n == 1 or n == 2) return 1;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = memoize(n - 1, dp) + memoize(n - 2, dp) + memoize(n - 3, dp);\\n    }\\n};\\n```\\n\\nTabulation (Bottom- Up) :\\nT.C: O(n)\\nS.C: O(n) (Dp Array)\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n <= 1) return n;\\n        vector<int> dp(n+1);        \\n        dp[0] = 0, dp[1] = dp[2] = 1;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\nUsing Variables : \\nT.C: O(n)\\nS.C: O(1)\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n <= 1) return n;     \\n        int prev3 = 0, prev2 = 1, prev1 = 1;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            int curr = prev1 + prev2 + prev3;\\n            prev3 = prev2;\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        \\n        return prev1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n == 1 or n == 2) return 1;\\n        \\n        return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        \\n        vector<int> dp (n+1, -1);\\n        return memoize(n, dp);\\n    }\\n    \\n    int memoize(int n, vector<int> &dp)\\n    {\\n        if(n == 0) return 0;\\n        if(n == 1 or n == 2) return 1;\\n        \\n        if(dp[n] != -1) return dp[n];\\n        \\n        return dp[n] = memoize(n - 1, dp) + memoize(n - 2, dp) + memoize(n - 3, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n <= 1) return n;\\n        vector<int> dp(n+1);        \\n        dp[0] = 0, dp[1] = dp[2] = 1;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(n <= 1) return n;     \\n        int prev3 = 0, prev2 = 1, prev1 = 1;\\n        \\n        for(int i = 3; i <= n; i++)\\n        {\\n            int curr = prev1 + prev2 + prev3;\\n            prev3 = prev2;\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        \\n        return prev1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324544,
                "title": "python-easy-loop",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a, b, c = 0, 1, 1\\n        if n == 0:\\n            return 0\\n        for i in range(n-2):\\n            a, b, c = b, c, (a+b+c)\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a, b, c = 0, 1, 1\\n        if n == 0:\\n            return 0\\n        for i in range(n-2):\\n            a, b, c = b, c, (a+b+c)\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223081,
                "title": "c-matrix-exponentiation",
                "content": "**General Case of Matrix Exponentiation**\\n\\nSo according to our equation. \\nF(n) = a*F(n-1) + b*F(n-2) + c*F(n-3)\\n\\n```\\n| F(n)   |  =  [ | a b c | ] ^ (n-2)   *  | F(2) |\\n| F(n-1) |     [ | 1 0 0 | ]              | F(1) |\\n| F(n-2) |     [ | 0 1 0 | ]              | F(0) |\\n```\\n\\nn\\'th term,\\n    F(n) = F(n-1) + F(n-2) + F(n-3), n >= 3\\n\\t\\nBase Cases :\\n    F(0) = 0, F(1) = 1, F(2) = 1\\n\\nPutting a = 1, b = 1 and c = 1 in above formula\\n\\n```\\n| F(n)   |  =  [ | 1 1 1 | ] ^ (n-2)   *  | F(2) |\\n| F(n-1) |     [ | 1 0 0 | ]              | F(1) |\\n| F(n-2) |     [ | 0 1 0 | ]              | F(0) |\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    void multiply(int a[3][3], int b[3][3]){\\n        \\n        int mul[3][3];      // we\\'ll save multiplication in new matrix\\n        for (int i=0; i<3; i++){\\n            for (int j=0; j<3; j++){\\n                \\n                mul[i][j] = 0;\\n                for (int k=0; k<3; k++)\\n                    mul[i][j] += a[i][k]*b[k][j];\\n            }\\n        }\\n        \\n        for (int i=0; i<3; i++)\\n            for (int j=0; j<3; j++)\\n                a[i][j] = mul[i][j];  // Updating our matrix\\n    }\\n    \\n    // through binary exponentiation or power paradigm\\n    void power(int F[3][3], int n){\\n        \\n        int M[3][3] = {{1,1,1}, {1,0,0}, {0,1,0}};\\n\\n        if (n == 1)\\n            return;\\n\\n        power(F, n/2);\\n        multiply(F, F);\\n\\n        if (n % 2 != 0)     // if n = odd\\n            multiply(F, M);\\n    } \\n    int tribonacci(int n){\\n\\n        int F[3][3] = {{1,1,1}, {1,0,0}, {0,1,0}};    // as, a=1, b=1, c=1\\n\\n        // Base cases\\n        if(n==0)\\n            return 0;\\n        if(n==1 || n==2)\\n            return 1;\\n        \\n        power(F, n-2);      // we have to multiply (n-2) times\\n        \\n        int ans = F[0][0] + F[0][1];       // F[0][0] * 1 + F[0][1] * 1 + F[0][2] * 0\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\n| F(n)   |  =  [ | a b c | ] ^ (n-2)   *  | F(2) |\\n| F(n-1) |     [ | 1 0 0 | ]              | F(1) |\\n| F(n-2) |     [ | 0 1 0 | ]              | F(0) |\\n```\n```\\n| F(n)   |  =  [ | 1 1 1 | ] ^ (n-2)   *  | F(2) |\\n| F(n-1) |     [ | 1 0 0 | ]              | F(1) |\\n| F(n-2) |     [ | 0 1 0 | ]              | F(0) |\\n```\n```\\nclass Solution {\\npublic:\\n    void multiply(int a[3][3], int b[3][3]){\\n        \\n        int mul[3][3];      // we\\'ll save multiplication in new matrix\\n        for (int i=0; i<3; i++){\\n            for (int j=0; j<3; j++){\\n                \\n                mul[i][j] = 0;\\n                for (int k=0; k<3; k++)\\n                    mul[i][j] += a[i][k]*b[k][j];\\n            }\\n        }\\n        \\n        for (int i=0; i<3; i++)\\n            for (int j=0; j<3; j++)\\n                a[i][j] = mul[i][j];  // Updating our matrix\\n    }\\n    \\n    // through binary exponentiation or power paradigm\\n    void power(int F[3][3], int n){\\n        \\n        int M[3][3] = {{1,1,1}, {1,0,0}, {0,1,0}};\\n\\n        if (n == 1)\\n            return;\\n\\n        power(F, n/2);\\n        multiply(F, F);\\n\\n        if (n % 2 != 0)     // if n = odd\\n            multiply(F, M);\\n    } \\n    int tribonacci(int n){\\n\\n        int F[3][3] = {{1,1,1}, {1,0,0}, {0,1,0}};    // as, a=1, b=1, c=1\\n\\n        // Base cases\\n        if(n==0)\\n            return 0;\\n        if(n==1 || n==2)\\n            return 1;\\n        \\n        power(F, n-2);      // we have to multiply (n-2) times\\n        \\n        int ans = F[0][0] + F[0][1];       // F[0][0] * 1 + F[0][1] * 1 + F[0][2] * 0\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994145,
                "title": "rust",
                "content": "```rust\\nfn tribonacci(n: i32) -> i32 {\\n\\tmatch n {\\n\\t\\t0 => 0,\\n\\t\\t1 | 2 => 1,\\n\\t\\t_ => {\\n\\t\\t\\tlet (_, _, c) = (3..=n).fold((0, 1, 1), |(a, b, c), _| (b, c, c + b + a));\\n\\t\\t\\tc\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nfn tribonacci(n: i32) -> i32 {\\n\\tmatch n {\\n\\t\\t0 => 0,\\n\\t\\t1 | 2 => 1,\\n\\t\\t_ => {\\n\\t\\t\\tlet (_, _, c) = (3..=n).fold((0, 1, 1), |(a, b, c), _| (b, c, c + b + a));\\n\\t\\t\\tc\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1623019,
                "title": "95-6-python-4-liner",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a,b,c = 0,1,1\\n        for _ in range(n):\\n            a,b,c = b,c,a+b+c\\n        return a\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a,b,c = 0,1,1\\n        for _ in range(n):\\n            a,b,c = b,c,a+b+c\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580778,
                "title": "javascript-dp-95-faster",
                "content": "Runtime: 64 ms, faster than 94.73% of JavaScript online submissions for N-th Tribonacci Number.\\nMemory Usage: 38.7 MB, less than 43.14% of JavaScript online submissions for N-th Tribonacci Number.\\nNext challenges:\\n\\n```\\nvar tribonacci = function(n) {\\n    let arr = new Array(n + 1).fill(0);\\n    arr[0] = 0;\\n    arr[1] = 1;\\n    arr[2] = 1; \\n    \\n    for(let i = 3; i <= n; i++) {\\n        arr[i] = arr[i - 3] + arr[i - 2] + arr[i -1];\\n    }\\n    \\n    return arr[n];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar tribonacci = function(n) {\\n    let arr = new Array(n + 1).fill(0);\\n    arr[0] = 0;\\n    arr[1] = 1;\\n    arr[2] = 1; \\n    \\n    for(let i = 3; i <= n; i++) {\\n        arr[i] = arr[i - 3] + arr[i - 2] + arr[i -1];\\n    }\\n    \\n    return arr[n];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482869,
                "title": "c-better-best-o-n-space-o-1-space-0ms-dp",
                "content": "1.  Space `O(n)` Time `O(n)`\\n```\\n long long int tribonacci(int n) {\\n        vector<long long>dp(38,0);   //dp vector to hold nth value (38 =37+1)\\n        dp[0]=0, dp[1]=1,dp[2]=1;    // base case\\n        if(n<3) return dp[n];\\n        for(int i=3;i<=n;i++)\\n            dp[i]=(dp[i-1]+dp[i-2]+dp[i-3]);\\n        return dp[n];\\n    }\\n```\\n\\n2.  Space `O(1)` Time `O(n)`\\n\\tWe see , that only three values are getting updated again and again, hence we can do a `modulo-3 indexing` as below\\n\\t\\n\\t```\\n\\tint tribonacci(int n) {\\n        int dp[3]={0,1,1};\\n        for(int i=3;i<=n;i++){\\n            dp[i%3]+=dp[(i+1)%3]+dp[(i+2)%3];\\n        }\\n        return dp[n%3];\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n long long int tribonacci(int n) {\\n        vector<long long>dp(38,0);   //dp vector to hold nth value (38 =37+1)\\n        dp[0]=0, dp[1]=1,dp[2]=1;    // base case\\n        if(n<3) return dp[n];\\n        for(int i=3;i<=n;i++)\\n            dp[i]=(dp[i-1]+dp[i-2]+dp[i-3]);\\n        return dp[n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482850,
                "title": "simple-java-solution-recursive-and-dynamic-programming",
                "content": "This problem is similar to Fibonacci series. We can do it in recursive way. But that is time complexity of n!. \\nThis is a good example of understanding Dynamic programming. We we store the subproblem and reuse it, instead of solving each problem again and again.\\n\\n**Recursive Approach:**\\n```\\npublic int tribonacci(int n) {\\n\\tif(n==0) return 0;\\n\\telse if(n<3) return 1;\\n\\treturn tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n}\\n```\\n\\n**Dynamic Programming Approach**\\n\\t\\n\\tpublic int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        else if(n<3) return 1;\\n        \\n        int[] arr = new int[n+1];\\n        arr[0] = 0;\\n        arr[1] = 1;\\n        arr[2] = 1;\\n        for(int i=3;i<arr.length;i++) {\\n            arr[i] = arr[i-1] + arr[i-2] + arr[i-3];\\n        }\\n        return arr[n];\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int tribonacci(int n) {\\n\\tif(n==0) return 0;\\n\\telse if(n<3) return 1;\\n\\treturn tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1228456,
                "title": "easy-java-4-lines-recursion-beats-100",
                "content": "```\\nclass Solution {\\n    int dp[] = new int[38];\\n    public int tribonacci(int n) {\\n        if(dp[n] != 0) return dp[n];\\n        if(n== 0) return 0;\\n        else if(n== 1 || n==2) return 1;\\n        \\n        return dp[n] = tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int dp[] = new int[38];\\n    public int tribonacci(int n) {\\n        if(dp[n] != 0) return dp[n];\\n        if(n== 0) return 0;\\n        else if(n== 1 || n==2) return 1;\\n        \\n        return dp[n] = tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1202434,
                "title": "c-simple-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint tribonacci(int n) {\\n\\t\\t\\tint dp[38] = {0, 1, 1, 2};\\n\\t\\t\\tfor(int i = 4; i <= n; i++){\\n\\t\\t\\t\\tdp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1];\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint tribonacci(int n) {\\n\\t\\t\\tint dp[38] = {0, 1, 1, 2}",
                "codeTag": "Java"
            },
            {
                "id": 1098034,
                "title": "simple-and-easy-to-understand-java-0-ms-faster-than-100-00-iterative-soln-clean-code",
                "content": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 1;\\n        \\n        \\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        \\n        for(int i = 3; i <= n; i++){\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n == 0) return 0;\\n        if(n == 1) return 1;\\n        if(n == 2) return 1;\\n        \\n        \\n        int[] dp = new int[n + 1];\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        \\n        for(int i = 3; i <= n; i++){\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        }\\n        \\n        return dp[n];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1040791,
                "title": "easy-python-high-speed",
                "content": "**Easy Python | High Speed**\\n\\n```\\nclass Solution:\\n    def tribonacci(self, n):\\n        if n<=2:\\n            return (n+1)>>1\\n        a,b,c = 0,1,1\\n        for _ in range(n-2):\\n            a,b,c = b,c,a+b+c\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n):\\n        if n<=2:\\n            return (n+1)>>1\\n        a,b,c = 0,1,1\\n        for _ in range(n-2):\\n            a,b,c = b,c,a+b+c\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903542,
                "title": "python-4-lines-beats-95-time-and-100-memory-iterative-dp",
                "content": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        data = [0,1,1]\\n        for i in range(3, n+1):\\n            data[i % 3] = data[i % 3] + data[(i % 3)-1] + data[(i % 3)-2]\\n        return data[n % 3]\\n```\\n\\nOther solution idea\\n\\n```\\n    def tribonacci(self, n):\\n        dp = [0, 1, 1]\\n        for i in range(3, n+1):\\n            dp[i % 3] = sum(dp)\\n        return dp[n % 3]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        data = [0,1,1]\\n        for i in range(3, n+1):\\n            data[i % 3] = data[i % 3] + data[(i % 3)-1] + data[(i % 3)-2]\\n        return data[n % 3]\\n```\n```\\n    def tribonacci(self, n):\\n        dp = [0, 1, 1]\\n        for i in range(3, n+1):\\n            dp[i % 3] = sum(dp)\\n        return dp[n % 3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902148,
                "title": "horrible-o-1-purely-mathematical-c-solution-that-no-one-should-use-ever-now-also-with-c",
                "content": "If you pull this out in an interview, I\\'m not sure if they should either hire you or disqualify you on the spot.\\n\\nTaken from https://mathworld.wolfram.com/TribonacciNumber.html.\\n\\n```\\npublic class Solution {\\n    private static readonly double alpha = (1 / 3.0) * Math.Pow(19 + 3.0 * Math.Sqrt(33), 1 / 3.0) + \\n        (1 / 3.0) * Math.Pow(19 - 3 * Math.Sqrt(33), 1 / 3.0) + (1 / 3.0);\\n    private static readonly double beta = 3 * Math.Pow(586 + 102 * Math.Sqrt(33), 1 / 3.0) / \\n        (Math.Pow(586 + 102 * Math.Sqrt(33), 2 / 3.0) + 4 - 2 * Math.Pow(586 + 102 * Math.Sqrt(33), 1 / 3.0));\\n\\n    public int Tribonacci(int n)\\n    {\\n        var trib = Math.Pow(alpha, n)* beta;\\n        return (int)Math.Round(trib, 0);\\n    }\\n}\\n```\\n\\nFor fun I also did it in C++ and it ran in... 0 ms. \\n\\n```class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        \\n        double alpha =1.83928675521416;\\n        double beta =0.336228116994941;\\n        \\n        double trib = pow(alpha, n)* beta;\\n        return (int)round(trib);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private static readonly double alpha = (1 / 3.0) * Math.Pow(19 + 3.0 * Math.Sqrt(33), 1 / 3.0) + \\n        (1 / 3.0) * Math.Pow(19 - 3 * Math.Sqrt(33), 1 / 3.0) + (1 / 3.0);\\n    private static readonly double beta = 3 * Math.Pow(586 + 102 * Math.Sqrt(33), 1 / 3.0) / \\n        (Math.Pow(586 + 102 * Math.Sqrt(33), 2 / 3.0) + 4 - 2 * Math.Pow(586 + 102 * Math.Sqrt(33), 1 / 3.0));\\n\\n    public int Tribonacci(int n)\\n    {\\n        var trib = Math.Pow(alpha, n)* beta;\\n        return (int)Math.Round(trib, 0);\\n    }\\n}\\n```\n```class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        \\n        double alpha =1.83928675521416;\\n        double beta =0.336228116994941;\\n        \\n        double trib = pow(alpha, n)* beta;\\n        return (int)round(trib);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 714581,
                "title": "matrix-exponentiation-java-solution-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/262bc24e-a15b-4cf5-a9c6-6cef40fd7b98_1593610485.4641726.png)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public void multiply(int[][] a, int[][] b){\\n        int m = a.length;\\n        int n = a[0].length;\\n        int c[][] = new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                c[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j];\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                a[i][j]=c[i][j];\\n            }\\n        }\\n    }\\n    public void matrixPower(int[][] a,int n){\\n        if(n<=1)return;\\n        matrixPower(a,n/2);\\n        multiply(a,a);\\n        if(n%2 == 1){\\n            int b[][] = {{1,1,1},{1,0,0},{0,1,0}};\\n            multiply(a,b);\\n        }\\n    }\\n    public int tribonacci(int n) {\\n        if(n<=1)return n;\\n        if(n==2)return n-1;\\n        int a[][] = {{1,1,1},{1,0,0},{0,1,0}};\\n        matrixPower(a,n-2);\\n        int b[][] = {{1,1,1},{1,0,0},{0,1,0}};\\n        multiply(a,b);\\n        return a[0][0];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void multiply(int[][] a, int[][] b){\\n        int m = a.length;\\n        int n = a[0].length;\\n        int c[][] = new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                c[i][j] = a[i][0]*b[0][j] + a[i][1]*b[1][j] + a[i][2]*b[2][j];\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                a[i][j]=c[i][j];\\n            }\\n        }\\n    }\\n    public void matrixPower(int[][] a,int n){\\n        if(n<=1)return;\\n        matrixPower(a,n/2);\\n        multiply(a,a);\\n        if(n%2 == 1){\\n            int b[][] = {{1,1,1},{1,0,0},{0,1,0}};\\n            multiply(a,b);\\n        }\\n    }\\n    public int tribonacci(int n) {\\n        if(n<=1)return n;\\n        if(n==2)return n-1;\\n        int a[][] = {{1,1,1},{1,0,0},{0,1,0}};\\n        matrixPower(a,n-2);\\n        int b[][] = {{1,1,1},{1,0,0},{0,1,0}};\\n        multiply(a,b);\\n        return a[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665432,
                "title": "rust-0-ms-2-mb",
                "content": "```rust\\npub fn tribonacci(n: i32) -> i32 {\\n        if n <= 2 {\\n            [0, 1, 1][n as usize]\\n        } else {\\n            (2..n).fold((0, 1, 1), |(a, b, c), _| (b, c, a + b + c)).2\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn tribonacci(n: i32) -> i32 {\\n        if n <= 2 {\\n            [0, 1, 1][n as usize]\\n        } else {\\n            (2..n).fold((0, 1, 1), |(a, b, c), _| (b, c, a + b + c)).2\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584615,
                "title": "c-recursion",
                "content": "```\\nvector<int> ans;\\nclass Solution {\\npublic:\\n    void recursion(int n)\\n    {\\n        if(ans.size()<=n)\\n        {\\n            recursion(n-3);\\n            recursion(n-2);\\n            recursion(n-1);\\n            ans.push_back(ans[n-3]+ans[n-2]+ans[n-1]);\\n        }\\n    }\\n    int tribonacci(int n) {\\n        ans.clear();\\n        ans.push_back(0);\\n        ans.push_back(1);\\n        ans.push_back(1);\\n        recursion(n);\\n        return ans[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nvector<int> ans;\\nclass Solution {\\npublic:\\n    void recursion(int n)\\n    {\\n        if(ans.size()<=n)\\n        {\\n            recursion(n-3);\\n            recursion(n-2);\\n            recursion(n-1);\\n            ans.push_back(ans[n-3]+ans[n-2]+ans[n-1]);\\n        }\\n    }\\n    int tribonacci(int n) {\\n        ans.clear();\\n        ans.push_back(0);\\n        ans.push_back(1);\\n        ans.push_back(1);\\n        recursion(n);\\n        return ans[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478029,
                "title": "3-python-o-n-sol-by-dp-w-explanation",
                "content": "Python O(n) by 1D DP.\\n\\n[\\u4E2D\\u6587\\u8A73\\u89E3\\u89E3\\u984C\\u5F71\\u7247 Tutorial video in Chinese](https://www.youtube.com/watch?v=fNFcRT7Fswc)\\n\\n[My tutorial of DP problem solving framework to Tribonacci number [ English ]](https://medium.com/@cutesciuridae/dive-into-dp-take-tribonacci-number-for-example-34fe657d35cb)\\n\\n[My tutorial of DP problem solving framework to Tribonacci number [ Chinese ]](https://medium.com/@cutesciuridae/dynamic-programming-%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA-%E4%BB%A5n-th-tribonacci-number-%E7%82%BA%E4%BE%8B-2d120c935a85?source=your_stories_page-------------------------------------)\\n\\n---\\n\\n```python []\\n\\n# Top-down DP without space optimization\\n# O(n) time\\n# O(n) space\\n\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        \\n        # DP table with base case\\n        # key: index i\\n        # value: corresponding Trib(i)\\n        memo = {\\n            0: 0,\\n            1: 1,\\n            2: 1\\n        }\\n\\n        def dp( i ):\\n\\n            if i in memo:\\n                return memo[i]\\n\\n            # General caess\\n            memo[i] = dp(i-3) + dp(i-2) + dp(i-1)\\n            return memo[i]\\n        #-------------------------\\n        return dp(n)\\n```\\n```python []\\n\\n# Bottom-up DP without space optimization\\n# O(n) time\\n# O(n) space\\n\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n\\n        # DP table with base case\\n        # key: index i\\n        # value: corresponding Trib(i)\\n        memo = {\\n            0: 0,\\n            1: 1,\\n            2: 1\\n        }\\n\\n        # General caess\\n        for i in range(3, n+1):\\n            memo[i] = memo[i-1] + memo[i-2] + memo[i-3]\\n\\n        return memo[n]     \\n```\\n```python []\\n\\n# Bottom-up DP with space optimization\\n# O(n) time\\n# O(1) space\\n\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        \\n        # DP table with base case\\n        # key: index i\\n        # value: corresponding Trib(i)\\n        memo = {\\n            0: 0,\\n            1: 1,\\n            2: 1\\n        }\\n\\n        # General cases\\n        # with space optimization\\n        for i in range(3, n+1):\\n            memo[i%3] = memo[(i-1)%3] + memo[(i-2)%3] + memo[(i-3)%3]\\n\\n        return memo[n%3]  \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python []\\n\\n# Top-down DP without space optimization\\n# O(n) time\\n# O(n) space\\n\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        \\n        # DP table with base case\\n        # key: index i\\n        # value: corresponding Trib(i)\\n        memo = {\\n            0: 0,\\n            1: 1,\\n            2: 1\\n        }\\n\\n        def dp( i ):\\n\\n            if i in memo:\\n                return memo[i]\\n\\n            # General caess\\n            memo[i] = dp(i-3) + dp(i-2) + dp(i-1)\\n            return memo[i]\\n        #-------------------------\\n        return dp(n)\\n```\n```python []\\n\\n# Bottom-up DP without space optimization\\n# O(n) time\\n# O(n) space\\n\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n\\n        # DP table with base case\\n        # key: index i\\n        # value: corresponding Trib(i)\\n        memo = {\\n            0: 0,\\n            1: 1,\\n            2: 1\\n        }\\n\\n        # General caess\\n        for i in range(3, n+1):\\n            memo[i] = memo[i-1] + memo[i-2] + memo[i-3]\\n\\n        return memo[n]     \\n```\n```python []\\n\\n# Bottom-up DP with space optimization\\n# O(n) time\\n# O(1) space\\n\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        \\n        # DP table with base case\\n        # key: index i\\n        # value: corresponding Trib(i)\\n        memo = {\\n            0: 0,\\n            1: 1,\\n            2: 1\\n        }\\n\\n        # General cases\\n        # with space optimization\\n        for i in range(3, n+1):\\n            memo[i%3] = memo[(i-1)%3] + memo[(i-2)%3] + memo[(i-3)%3]\\n\\n        return memo[n%3]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 451416,
                "title": "recursion-tailing-100-run-time-and-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int trib(int n, int a, int b, int c) {\\n        if (n <= 1) return n;\\n        if (n == 2) return c;\\n        return trib(n - 1, b, c, a + b + c);\\n    }\\n    \\n    int tribonacci(int n) {\\n        return trib(n, 0, 1, 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int trib(int n, int a, int b, int c) {\\n        if (n <= 1) return n;\\n        if (n == 2) return c;\\n        return trib(n - 1, b, c, a + b + c);\\n    }\\n    \\n    int tribonacci(int n) {\\n        return trib(n, 0, 1, 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345219,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Memory optimiziation, ie. `a, b, c = dp[i - 3], dp[i - 2], dp[i - 1]`\\n\\n---\\n\\n**Kotlin**\\n\\n*Top-Down*\\n```\\nclass Solution {\\n    fun tribonacci(N: Int): Int {\\n        fun go(i: Int = N): Int {\\n            if (i == 0) return 0\\n            if (i <= 2) return 1\\n            return go(i - 1) + go(i - 2) + go(i - 3)\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n*Top-Down w/ Memo*\\n```\\nclass Solution {\\n    fun tribonacci(N: Int): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = N): Int {\\n            if (i == 0) return 0\\n            if (i <= 2) return 1\\n            if (m.contains(i))\\n                return m[i]!!\\n            m[i] = go(i - 1) + go(i - 2) + go(i - 3)\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n*Bottom-Up*\\n```\\nclass Solution {\\n    fun tribonacci(N: Int): Int {\\n        if (N == 0) return 0\\n        if (N <= 2) return 1\\n        var dp = IntArray(N + 1) { 0 }\\n        dp[1] = 1\\n        dp[2] = 1\\n        for (i in 3..N)\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\\n        return dp[N]\\n    }\\n}\\n```\\n\\n*Bottom-Up (Memory Optimization)*\\n```\\nclass Solution {\\n    fun tribonacci(N: Int): Int {\\n        if (N == 0) return 0\\n        if (N <= 2) return 1\\n        var (a, b, c, d) = listOf(0, 1, 1, 2)\\n        for (i in 3..N) {\\n            d = a + b + c        // dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n            a = b; b = c; c = d  // \\uD83D\\uDC48 slide window\\n        }\\n        return d\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript**\\n\\n*Top-Down*\\n```\\nlet tribonacci = N => {\\n    let go = (i = N) => {\\n        if (i == 0) return 0;\\n        if (i <= 2) return 1;\\n        return go(i - 1) + go(i - 2) + go(i - 3);\\n    };\\n    return go();\\n};\\n```\\n\\n*Top-Down w/ Memo*\\n```\\nlet tribonacci = (N, m = new Map()) => {\\n    let go = (i = N) => {\\n        if (i == 0) return 0;\\n        if (i <= 2) return 1;\\n        if (m.has(i))\\n            return m.get(i);\\n        return m.set(i, go(i - 1) + go(i - 2) + go(i - 3))\\n                .get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n*Bottom-Up*\\n```\\nlet tribonacci = N => {\\n    if (N == 0) return 0;\\n    if (N <= 2) return 1;\\n    let dp = Array(N + 1).fill(0);\\n    dp[1] = dp[2] = 1;\\n    for (let i = 3; i <= N; ++i)\\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n    return dp[N];\\n};\\n```\\n\\n*Bottom-Up (Memory Optimization)*\\n```\\nlet tribonacci = (N, a = 0, b = 1, c = 1, d = 2) => {\\n    if (N == 0) return 0;\\n    if (N <= 2) return 1;\\n    for (let i = 3; i <= N; ++i)\\n        d = a + b + c,        // dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n        a = b, b = c, c = d;  // \\uD83D\\uDC48 slide window\\n    return d;\\n};\\n```\\n\\n---\\n\\n**Python3**\\n\\n*Top-Down*\\n```\\nclass Solution:\\n    def tribonacci(self, N: int) -> int:\\n        def go(i = N):\\n            if i == 0: return 0\\n            if i <= 2: return 1\\n            return go(i - 1) + go(i - 2) + go(i - 3)\\n        return go()\\n```\\n\\n*Top-Down w/ Memo*\\n```\\nclass Solution:\\n    def tribonacci(self, N: int) -> int:\\n        @cache\\n        def go(i = N):\\n            if i == 0: return 0\\n            if i <= 2: return 1\\n            return go(i - 1) + go(i - 2) + go(i - 3)\\n        return go()\\n```\\n\\n*Bottom-Up*\\n```\\nclass Solution:\\n    def tribonacci(self, N: int) -> int:\\n        if N == 0: return 0\\n        if N <= 2: return 1\\n        dp = [0] * (N + 1)\\n        dp[1] = 1\\n        dp[2] = 1\\n        for i in range(3, N + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\\n        return dp[N]\\n```\\n\\n*Bottom-Up (Memory Optimization)*\\n```\\nclass Solution:\\n    def tribonacci(self, N: int, a = 0, b = 1, c = 1, d = 2) -> int:\\n        if N == 0: return 0\\n        if N <= 2: return 1\\n        for i in range(3, N + 1):\\n            d = a + b + c        # dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n            a = b; b = c; c = d  # \\uD83D\\uDC48 slide window\\n        return d\\n```\\n\\n---\\n\\n**Rust**\\n\\n*Top-Down*\\n```\\n\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        let n = n as usize;\\n        fn go(i: usize) -> i32 {\\n            if i == 0 { return 0; }\\n            if i <= 2 { return 1; }\\n            go(i - 3) + go(i - 2) + go(i - 1)\\n        }\\n        go(n)\\n    }\\n}\\n```\\n\\n*Top-Down w/ Memo*\\n```\\nuse std::collections::HashMap;\\ntype Map = HashMap<usize, i32>;\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        let n = n as usize;\\n        let mut m = Map::new();\\n        fn go(i: usize, m: &mut Map) -> i32 {\\n            if i == 0 { return 0; }\\n            if i <= 2 { return 1; }\\n            if m.contains_key(&i) {\\n                return *m.get(&i).unwrap();\\n            }\\n            let (a, b, c) = (go(i - 3, m), go(i - 2, m), go(i - 1, m));\\n            m.insert(i, a + b + c);\\n            *m.get(&i).unwrap()\\n        }\\n        go(n, &mut m)\\n    }\\n}\\n```\\n\\n*Bottom-Up*\\n```\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        let n = n as usize;\\n        let mut dp = vec![0, 1, 1];\\n        for i in 3..=n {\\n            dp.push(dp[i - 3] + dp[i - 2] + dp[i - 1]);\\n        }\\n        dp[n]\\n    }\\n}\\n```\\n\\n*Bottom-Up (Memory Optimization)*\\n```\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        let n = n as usize;\\n        if n == 0 { return 0; }\\n        if n <= 2 { return 1; }\\n        let (mut a, mut b, mut c, mut d) = (0, 1, 1, 1234567890);\\n        for i in 3..=n {\\n            d = a + b + c;       // dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n            a = b; b = c; c = d; // \\uD83D\\uDC48 slide window\\n        }\\n        d\\n    }\\n}\\n```\\n\\n---\\n\\n**C++**\\n\\n*Top-Down*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    int tribonacci(int N) {\\n        fun go = [&](auto i) {\\n            if (i == 0) return 0;\\n            if (i <= 2) return 1;\\n            return go(i - 1) + go(i - 2) + go(i - 3);\\n        };\\n        return go(N);\\n    }\\n};\\n```\\n\\n*Top-Down w/ Memo*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int tribonacci(int N, Map m = {}) {\\n        fun go = [&](auto i) {\\n            if (i == 0) return 0;\\n            if (i <= 2) return 1;\\n            if (m.find(i) != m.end())\\n                return m[i];\\n            return m[i] = go(i - 1) + go(i - 2) + go(i - 3);\\n        };\\n        return go(N);\\n    }\\n};\\n```\\n\\n*Bottom-Up*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int tribonacci(int N) {\\n        if (N == 0) return 0;\\n        if (N <= 2) return 1;\\n        VI dp(N + 1);\\n        dp[1] = dp[2] = 1;\\n        for (auto i{ 3 }; i <= N; ++i)\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        return dp[N];\\n    }\\n};\\n```\\n\\n*Bottom-Up (Memory Optimization)*\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int N, int a = 0, int b = 1, int c = 1, int d = 2) {\\n        if (N == 0) return 0;\\n        if (N <= 2) return 1;\\n        for (auto i{ 3 }; i <= N; ++i)\\n            d = a + b + c,       // dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n            a = b, b = c, c = d; // \\uD83D\\uDC48 slide window\\n        return d;\\n    }\\n};\\n```\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun tribonacci(N: Int): Int {\\n        fun go(i: Int = N): Int {\\n            if (i == 0) return 0\\n            if (i <= 2) return 1\\n            return go(i - 1) + go(i - 2) + go(i - 3)\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun tribonacci(N: Int): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = N): Int {\\n            if (i == 0) return 0\\n            if (i <= 2) return 1\\n            if (m.contains(i))\\n                return m[i]!!\\n            m[i] = go(i - 1) + go(i - 2) + go(i - 3)\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun tribonacci(N: Int): Int {\\n        if (N == 0) return 0\\n        if (N <= 2) return 1\\n        var dp = IntArray(N + 1) { 0 }\\n        dp[1] = 1\\n        dp[2] = 1\\n        for (i in 3..N)\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\\n        return dp[N]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun tribonacci(N: Int): Int {\\n        if (N == 0) return 0\\n        if (N <= 2) return 1\\n        var (a, b, c, d) = listOf(0, 1, 1, 2)\\n        for (i in 3..N) {\\n            d = a + b + c        // dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n            a = b; b = c; c = d  // \\uD83D\\uDC48 slide window\\n        }\\n        return d\\n    }\\n}\\n```\n```\\nlet tribonacci = N => {\\n    let go = (i = N) => {\\n        if (i == 0) return 0;\\n        if (i <= 2) return 1;\\n        return go(i - 1) + go(i - 2) + go(i - 3);\\n    };\\n    return go();\\n};\\n```\n```\\nlet tribonacci = (N, m = new Map()) => {\\n    let go = (i = N) => {\\n        if (i == 0) return 0;\\n        if (i <= 2) return 1;\\n        if (m.has(i))\\n            return m.get(i);\\n        return m.set(i, go(i - 1) + go(i - 2) + go(i - 3))\\n                .get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet tribonacci = N => {\\n    if (N == 0) return 0;\\n    if (N <= 2) return 1;\\n    let dp = Array(N + 1).fill(0);\\n    dp[1] = dp[2] = 1;\\n    for (let i = 3; i <= N; ++i)\\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n    return dp[N];\\n};\\n```\n```\\nlet tribonacci = (N, a = 0, b = 1, c = 1, d = 2) => {\\n    if (N == 0) return 0;\\n    if (N <= 2) return 1;\\n    for (let i = 3; i <= N; ++i)\\n        d = a + b + c,        // dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n        a = b, b = c, c = d;  // \\uD83D\\uDC48 slide window\\n    return d;\\n};\\n```\n```\\nclass Solution:\\n    def tribonacci(self, N: int) -> int:\\n        def go(i = N):\\n            if i == 0: return 0\\n            if i <= 2: return 1\\n            return go(i - 1) + go(i - 2) + go(i - 3)\\n        return go()\\n```\n```\\nclass Solution:\\n    def tribonacci(self, N: int) -> int:\\n        @cache\\n        def go(i = N):\\n            if i == 0: return 0\\n            if i <= 2: return 1\\n            return go(i - 1) + go(i - 2) + go(i - 3)\\n        return go()\\n```\n```\\nclass Solution:\\n    def tribonacci(self, N: int) -> int:\\n        if N == 0: return 0\\n        if N <= 2: return 1\\n        dp = [0] * (N + 1)\\n        dp[1] = 1\\n        dp[2] = 1\\n        for i in range(3, N + 1):\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\\n        return dp[N]\\n```\n```\\nclass Solution:\\n    def tribonacci(self, N: int, a = 0, b = 1, c = 1, d = 2) -> int:\\n        if N == 0: return 0\\n        if N <= 2: return 1\\n        for i in range(3, N + 1):\\n            d = a + b + c        # dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n            a = b; b = c; c = d  # \\uD83D\\uDC48 slide window\\n        return d\\n```\n```\\n\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        let n = n as usize;\\n        fn go(i: usize) -> i32 {\\n            if i == 0 { return 0; }\\n            if i <= 2 { return 1; }\\n            go(i - 3) + go(i - 2) + go(i - 1)\\n        }\\n        go(n)\\n    }\\n}\\n```\n```\\nuse std::collections::HashMap;\\ntype Map = HashMap<usize, i32>;\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        let n = n as usize;\\n        let mut m = Map::new();\\n        fn go(i: usize, m: &mut Map) -> i32 {\\n            if i == 0 { return 0; }\\n            if i <= 2 { return 1; }\\n            if m.contains_key(&i) {\\n                return *m.get(&i).unwrap();\\n            }\\n            let (a, b, c) = (go(i - 3, m), go(i - 2, m), go(i - 1, m));\\n            m.insert(i, a + b + c);\\n            *m.get(&i).unwrap()\\n        }\\n        go(n, &mut m)\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        let n = n as usize;\\n        let mut dp = vec![0, 1, 1];\\n        for i in 3..=n {\\n            dp.push(dp[i - 3] + dp[i - 2] + dp[i - 1]);\\n        }\\n        dp[n]\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn tribonacci(n: i32) -> i32 {\\n        let n = n as usize;\\n        if n == 0 { return 0; }\\n        if n <= 2 { return 1; }\\n        let (mut a, mut b, mut c, mut d) = (0, 1, 1, 1234567890);\\n        for i in 3..=n {\\n            d = a + b + c;       // dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n            a = b; b = c; c = d; // \\uD83D\\uDC48 slide window\\n        }\\n        d\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    int tribonacci(int N) {\\n        fun go = [&](auto i) {\\n            if (i == 0) return 0;\\n            if (i <= 2) return 1;\\n            return go(i - 1) + go(i - 2) + go(i - 3);\\n        };\\n        return go(N);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int tribonacci(int N, Map m = {}) {\\n        fun go = [&](auto i) {\\n            if (i == 0) return 0;\\n            if (i <= 2) return 1;\\n            if (m.find(i) != m.end())\\n                return m[i];\\n            return m[i] = go(i - 1) + go(i - 2) + go(i - 3);\\n        };\\n        return go(N);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int tribonacci(int N) {\\n        if (N == 0) return 0;\\n        if (N <= 2) return 1;\\n        VI dp(N + 1);\\n        dp[1] = dp[2] = 1;\\n        for (auto i{ 3 }; i <= N; ++i)\\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\\n        return dp[N];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int N, int a = 0, int b = 1, int c = 1, int d = 2) {\\n        if (N == 0) return 0;\\n        if (N <= 2) return 1;\\n        for (auto i{ 3 }; i <= N; ++i)\\n            d = a + b + c,       // dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1]\\n            a = b, b = c, c = d; // \\uD83D\\uDC48 slide window\\n        return d;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036752,
                "title": "n-th-tribonacci-number-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        vector<int>tribonacci={0,1,1};\\n        if(n<tribonacci.size())\\n        {\\n            return tribonacci[n];\\n        }\\n        n-=2;\\n        while(n--)\\n        {\\n            int N=tribonacci.size();\\n            tribonacci.push_back(tribonacci[N-1]+tribonacci[N-2]+tribonacci[N-3]);\\n        }\\n        return tribonacci.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) \\n    {\\n        vector<int>tribonacci={0,1,1};\\n        if(n<tribonacci.size())\\n        {\\n            return tribonacci[n];\\n        }\\n        n-=2;\\n        while(n--)\\n        {\\n            int N=tribonacci.size();\\n            tribonacci.push_back(tribonacci[N-1]+tribonacci[N-2]+tribonacci[N-3]);\\n        }\\n        return tribonacci.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958530,
                "title": "using-dp-leetcode-75",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==0:\\n            return 0\\n        if n==1 or n==2:\\n            return 1\\n        dp = [0] * (n+1)\\n        dp[1]=1\\n        dp[2]=1\\n        for i in range(3,n+1):\\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3]\\n        return dp[n]\\n\\n```\\n# **PLEASE DO UPVOTE!!!**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        if n==0:\\n            return 0\\n        if n==1 or n==2:\\n            return 1\\n        dp = [0] * (n+1)\\n        dp[1]=1\\n        dp[2]=1\\n        for i in range(3,n+1):\\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3]\\n        return dp[n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898245,
                "title": "dp-solution-space-o-1-time-o-n-simple-and-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\na array of size 3 is there it has values of `fib(0),fib(1),fib(2)`\\nfurthur usig thier sum we append it to end of list and pop the first element\\nat end answer will be stored in last `a[2]` returning it does the job\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**______O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**______O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n==0:return 0\\n        d=[0]*(3)\\n        d[0]=0\\n        d[1]=d[2]=1\\n        for i in range(3,n+1):\\n            d.append(sum(d))\\n            d.pop(0)\\n        return d[2]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n==0:return 0\\n        d=[0]*(3)\\n        d[0]=0\\n        d[1]=d[2]=1\\n        for i in range(3,n+1):\\n            d.append(sum(d))\\n            d.pop(0)\\n        return d[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837220,
                "title": "easy-solution-and-beat-9x-time-o-n-space-o-1-deque-fifo-for-flexible-x-bonacci-sequence",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/4563cce2-ebfb-404a-847e-9645e1c2f355_1690702598.7235944.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        ansDeque = collections.deque([0, 1, 1])\\n        if n<3:\\n            return ansDeque[n]\\n        else:\\n            for i in range(3, n):\\n                ansDeque.append(sum(ansDeque))\\n                ansDeque.popleft()\\n            return sum(ansDeque)\\n```",
                "solutionTags": [
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        ansDeque = collections.deque([0, 1, 1])\\n        if n<3:\\n            return ansDeque[n]\\n        else:\\n            for i in range(3, n):\\n                ansDeque.append(sum(ansDeque))\\n                ansDeque.popleft()\\n            return sum(ansDeque)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801170,
                "title": "java-solution-with-memoization-in-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private Map<Integer, Integer> map = new HashMap<>();\\n\\n    public int tribonacci(int n) {\\n        if (n == 2 || n == 1){\\n            return 1;\\n        }\\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        return getValue(n - 3) + getValue(n - 2) + getValue(n - 1);     \\n        \\n    }\\n    private int getValue(int value) {\\n\\n        int a = map.getOrDefault(value,-1);\\n\\n        if (a == -1) {\\n            a = tribonacci(value);\\n            map.put(value, a);\\n        }\\n\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    private Map<Integer, Integer> map = new HashMap<>();\\n\\n    public int tribonacci(int n) {\\n        if (n == 2 || n == 1){\\n            return 1;\\n        }\\n        if (n == 0) {\\n            return 0;\\n        }\\n        \\n        return getValue(n - 3) + getValue(n - 2) + getValue(n - 1);     \\n        \\n    }\\n    private int getValue(int value) {\\n\\n        int a = map.getOrDefault(value,-1);\\n\\n        if (a == -1) {\\n            a = tribonacci(value);\\n            map.put(value, a);\\n        }\\n\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745716,
                "title": "java-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int[] z=new int[38];\\n        \\n    for(int i=0;i<z.length-3;i++){\\n            z[0]=0;\\n            z[1]=1;\\n            z[2]=1;\\n\\n            z[i+3]=z[i]+z[i+1]+z[i+2];\\n        }\\n        \\n\\n        return z[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int[] z=new int[38];\\n        \\n    for(int i=0;i<z.length-3;i++){\\n            z[0]=0;\\n            z[1]=1;\\n            z[2]=1;\\n\\n            z[i+3]=z[i]+z[i+1]+z[i+2];\\n        }\\n        \\n\\n        return z[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638569,
                "title": "beats-100-c-using-dp-vector-same-as-fibonacci-simple-to-understand",
                "content": "# Intuition\\n\\u2705BEATS 100% C++ Using DP (Vector)||Same as Fibonacci\\u2705||Simple To Understand\\u2705\\n\\n# Approach\\nUsing DP and take reference form previous normal fibonacci question.\\nExample :Here if we have to find tribonacci of 4 then we have to break it in form of 1+3 i.e 4. so here we first take the base condition and do n=n-3 as we have to convert it in form of Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0. so we do n=n-3 and store our answer in dp\\nthen return dp[n].\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvector<int>dp(38,-1);\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(dp[n]!=-1)return dp[n];\\n        if(n==0)return dp[n]=0;\\n        if(n==1)return dp[n]=1;\\n        if(n==2)return dp[n]=1; \\n        n=n-3; \\n        dp[n+3]=tribonacci(n)+tribonacci(n+1)+tribonacci(n+2);\\n        return dp[n+3];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int>dp(38,-1);\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n        if(dp[n]!=-1)return dp[n];\\n        if(n==0)return dp[n]=0;\\n        if(n==1)return dp[n]=1;\\n        if(n==2)return dp[n]=1; \\n        n=n-3; \\n        dp[n+3]=tribonacci(n)+tribonacci(n+1)+tribonacci(n+2);\\n        return dp[n+3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551140,
                "title": "constant-space-o-n-time-solution",
                "content": "# Intuition\\nThere would be three special cases, n= 0, n=1 and n=2 where T1 = 0, T2 = 1, T3 = 1 can be hardcoded.\\nFor subsequent Terms, add the last three elements.\\ne.g. for T4 = T1 + T2 + T3 (0+1+1) = 2\\nfor T5 = T4 + T3 + T2 (1+1+2) = 4\\nand so on.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nlet \\n\\nn1 => last element,\\nn2 => 2nd last element,\\nn3 => 3rd last element\\n\\nRun a loop starting from 3 upto n.\\nkeep assigning the next val to the last three vals.\\n\\nthen \\nn3,n2,n1 = n2, n1, n1+n2+n3\\n\\nafter the loop is completed, n3 is the answer.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nConstant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc tribonacci(n int) int {\\n    if n <=1 {\\n        return n\\n    }\\n    if n == 2{\\n        return 1\\n    }\\n\\n    var t1, t2, t3 int = 0,1,1\\n\\n    for i:=3; i<n+1; i++{\\n        t1,t2,t3 = t2,t3,t1+t2+t3\\n    }\\n    return t3\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc tribonacci(n int) int {\\n    if n <=1 {\\n        return n\\n    }\\n    if n == 2{\\n        return 1\\n    }\\n\\n    var t1, t2, t3 int = 0,1,1\\n\\n    for i:=3; i<n+1; i++{\\n        t1,t2,t3 = t2,t3,t1+t2+t3\\n    }\\n    return t3\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3485505,
                "title": "0-ms-beats-100-easy-to-understand",
                "content": "# Code\\n```\\nfunc tribonacci(_ n: Int, _ a: Int = 0, _ b: Int = 1, _ c: Int = 1) -> Int {\\n    switch n {\\n    case 0: return a\\n    case 1: return b\\n    case 2: return c\\n    default: return tribonacci(n - 1, b, c, a + b + c)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfunc tribonacci(_ n: Int, _ a: Int = 0, _ b: Int = 1, _ c: Int = 1) -> Int {\\n    switch n {\\n    case 0: return a\\n    case 1: return b\\n    case 2: return c\\n    default: return tribonacci(n - 1, b, c, a + b + c)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3276629,
                "title": "beats-100-easy-java-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst make a dp array initialize the 2 value in it as it requires the summation of three value. Then start filling the dp array from i = 3 and after that return dp[n].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int[] dp = new int[n+1];\\n        if(n == 0 || n == 1){\\n            return n;\\n        }\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for(int i= 3; i <= n; i++){\\n            dp[i]= dp[i-3]+dp[i-2]+dp[i-1];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\nPlease upvote if you are reading this as it will give me motivation to add more solution.\\n\\n<p align=\"center\">\\n<img src= \"https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg\" alt=\"\">\\n</p>\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        int[] dp = new int[n+1];\\n        if(n == 0 || n == 1){\\n            return n;\\n        }\\n        dp[0] = 0;\\n        dp[1] = 1;\\n        dp[2] = 1;\\n        for(int i= 3; i <= n; i++){\\n            dp[i]= dp[i-3]+dp[i-2]+dp[i-1];\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208552,
                "title": "the-earliest-bird-catches-a-worm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        F=[0,1,1]\\n        if n <= 2:\\n            return F[n]\\n        for i in range (3,n+1):\\n            F.append(F[0]+F[1]+F[2])\\n            F[0]=F[1]\\n            F[1]=F[2]\\n            F[2]=F[3]\\n            F.pop()\\n        return F[2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        F=[0,1,1]\\n        if n <= 2:\\n            return F[n]\\n        for i in range (3,n+1):\\n            F.append(F[0]+F[1]+F[2])\\n            F[0]=F[1]\\n            F[1]=F[2]\\n            F[2]=F[3]\\n            F.pop()\\n        return F[2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121401,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        int tribonacci(int n) {\\n        int arr[]={0,1,1};\\n        for(int i =3;i<=n;i++)\\n            arr[i%3]=arr[0]+arr[1]+arr[2];\\n        return arr[n%3];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int tribonacci(int n) {\\n        int arr[]={0,1,1};\\n        for(int i =3;i<=n;i++)\\n            arr[i%3]=arr[0]+arr[1]+arr[2];\\n        return arr[n%3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120567,
                "title": "python-memoization",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        memo = {}\\n        def trib(n):\\n            if n == 0:\\n                return 0\\n            if n in (1, 2):\\n                return 1\\n            if n in memo:\\n                res = memo[n]\\n            else:\\n                res = trib(n-1) + trib(n-2) + trib(n-3)\\n                memo[n] = res\\n            return res\\n\\n        return trib(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        memo = {}\\n        def trib(n):\\n            if n == 0:\\n                return 0\\n            if n in (1, 2):\\n                return 1\\n            if n in memo:\\n                res = memo[n]\\n            else:\\n                res = trib(n-1) + trib(n-2) + trib(n-3)\\n                memo[n] = res\\n            return res\\n\\n        return trib(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119479,
                "title": "easy-solution-using-dynamic-programming-faster-than-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a for loop to iterate through the array and add the previous three numbers in the sequence.\\n\\nBase Condition: For the 1st three numbers as shown in the code i.e,\\nif n is 0 return 0 and if n==1 or 2 return 1 likewise...\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n       if(n==0) return 0;\\n       if(n==1 || n==2) return 1; \\n       int a[] = new int[n+1];\\n       a[0] = 0;\\n       a[1] = 1;\\n       a[2] = 1;\\n        for(int i=3; i<=n; i++){\\n            a[i]=a[i-1]+a[i-2]+a[i-3];\\n        }\\n       return a[n];\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int tribonacci(int n) {\\n       if(n==0) return 0;\\n       if(n==1 || n==2) return 1; \\n       int a[] = new int[n+1];\\n       a[0] = 0;\\n       a[1] = 1;\\n       a[2] = 1;\\n        for(int i=3; i<=n; i++){\\n            a[i]=a[i-1]+a[i-2]+a[i-3];\\n        }\\n       return a[n];\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118753,
                "title": "easy-solution-with-4-different-approaches-easy-understand",
                "content": "# Approach - 1\\n<!-- Describe your approach to solving the problem. -->\\n# *Using recursion.*\\n\\n**Note : Getting TLE Due to extra time and recursion stack space hence nedded some optimal approach**\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nint solve(int n)\\n{\\n  if(n <= 0)\\n  {\\n    return 0;\\n  }\\n\\n  if(n == 1)\\n  {\\n    return 1;\\n  }\\n\\n  return solve(n-1) + solve(n-2) + solve(n-3);\\n\\n}\\n\\npublic:\\n    int tribonacci(int n) {\\n\\n      return solve(n);\\n        \\n    }\\n};\\n```\\n\\n\\n# Approach - 2\\n<!-- Describe your approach to solving the problem. -->\\n# *Using Dyanmic programming.*\\n# Memoization solution\\nRemoved Overlapping Sub-problems\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nint solve(int n,vector<int> &dp)\\n{\\n  if(n <= 0)\\n  {\\n    return 0;\\n  }\\n\\n  if(n == 1)\\n  {\\n    return 1;\\n  }\\n\\n  if(dp[n] != -1)\\n  {\\n    return dp[n];\\n  }\\n\\n  return dp[n] = solve(n-1,dp) + solve(n-2,dp) + solve(n-3,dp);\\n}\\npublic:\\n    int tribonacci(int n) {\\n\\n      vector<int> dp(n+1,-1);\\n\\n      return solve(n,dp);\\n        \\n    }\\n};\\n```\\n# Approach - 3\\n<!-- Describe your approach to solving the problem. -->\\n# *Using Dynamic Programming.*\\n# Tabulation solution \\n\\nRecursion Extra space removed \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n      vector<int> dp(n+1,-1);\\n\\n      if(n <= 0)\\n      {\\n        return 0;\\n      }\\n\\n      if(n == 1 || n == 2)\\n      {\\n        return 1;\\n      }\\n\\n      dp[0] = 0;\\n      dp[1] = 1;\\n      dp[2] = 1;\\n\\n      for(int i = 3; i <= n; i++)\\n      {\\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};\\n```\\n# Approach - 4\\n<!-- Describe your approach to solving the problem. -->\\n# *Using Dynammic Programming.*\\n# Space Optimization solution\\n\\nMost optimal solution \\nWithout any extra space(Constant space) i.e. O(1) space complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n      int a = 0;\\n      int b = 1;\\n      int c = 1;\\n      \\n      if(n <= 0)\\n      {\\n        return 0;\\n      }\\n\\n      if(n == 1 || n == 2)\\n      {\\n        return 1;\\n      }\\n\\n      for(int i = 3; i <= n; i++)\\n      {\\n        int ans = a + b + c;\\n        a = b;\\n        b = c;\\n        c = ans;\\n       }\\n        \\n      return c;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nint solve(int n)\\n{\\n  if(n <= 0)\\n  {\\n    return 0;\\n  }\\n\\n  if(n == 1)\\n  {\\n    return 1;\\n  }\\n\\n  return solve(n-1) + solve(n-2) + solve(n-3);\\n\\n}\\n\\npublic:\\n    int tribonacci(int n) {\\n\\n      return solve(n);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\nint solve(int n,vector<int> &dp)\\n{\\n  if(n <= 0)\\n  {\\n    return 0;\\n  }\\n\\n  if(n == 1)\\n  {\\n    return 1;\\n  }\\n\\n  if(dp[n] != -1)\\n  {\\n    return dp[n];\\n  }\\n\\n  return dp[n] = solve(n-1,dp) + solve(n-2,dp) + solve(n-3,dp);\\n}\\npublic:\\n    int tribonacci(int n) {\\n\\n      vector<int> dp(n+1,-1);\\n\\n      return solve(n,dp);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n      vector<int> dp(n+1,-1);\\n\\n      if(n <= 0)\\n      {\\n        return 0;\\n      }\\n\\n      if(n == 1 || n == 2)\\n      {\\n        return 1;\\n      }\\n\\n      dp[0] = 0;\\n      dp[1] = 1;\\n      dp[2] = 1;\\n\\n      for(int i = 3; i <= n; i++)\\n      {\\n        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n      int a = 0;\\n      int b = 1;\\n      int c = 1;\\n      \\n      if(n <= 0)\\n      {\\n        return 0;\\n      }\\n\\n      if(n == 1 || n == 2)\\n      {\\n        return 1;\\n      }\\n\\n      for(int i = 3; i <= n; i++)\\n      {\\n        int ans = a + b + c;\\n        a = b;\\n        b = c;\\n        c = ans;\\n       }\\n        \\n      return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118448,
                "title": "very-very-simple-cpp",
                "content": "\\n    int tribonacci(int n) {\\n    vector<int> a(n+3);\\n    a[0]=0;\\n    a[1]=1;\\n    a[2]=1;\\n    for(int i=3;i<=n;i++){\\n        a[i]=a[i-1]+a[i-2]+a[i-3];\\n    }\\n    return a[n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    int tribonacci(int n) {\\n    vector<int> a(n+3);\\n    a[0]=0;\\n    a[1]=1;\\n    a[2]=1;\\n    for(int i=3;i<=n;i++){\\n        a[i]=a[i-1]+a[i-2]+a[i-3];\\n    }\\n    return a[n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3118169,
                "title": "python-without-any-extra-list",
                "content": "# Intuition\\nThis problem is similar to the Fibonacci sequence, it just adds one more base case. In general, we use a list or array to record subproblems we\\'ve computed before. However, in this problem, we can just utilize three variables `a, b, c` to solve it.\\n\\n# Approach\\nWe start our loop from `3` to `n` (inclusive), In the end, return `c` if `n` is not equal to `0`, else return `0`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a, b, c = 0, 1, 1\\n        for _ in range(3, n + 1):\\n            c, b, a = a + b + c, c, b\\n        return c if n != 0 else 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        a, b, c = 0, 1, 1\\n        for _ in range(3, n + 1):\\n            c, b, a = a + b + c, c, b\\n        return c if n != 0 else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118094,
                "title": "python-simple-solution-for-noobs-similar-to-fib",
                "content": "\\n# Approach\\nUsed simple approach as in Fibonacci series.\\n\\n# Complexity\\n- Time complexity:\\nAdd your time complexity here is O(n)\\n\\n- Space complexity:\\nAdd your space complexity here is O(1)\\n# Code\\n```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        n1=0\\n        n2=1\\n        n3=1\\n        if n==0:\\n            return n1\\n        for i in range(n-2):\\n            n1,n2,n3=n2,n3,(n1+n2+n3)\\n        return n3\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def tribonacci(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        n1=0\\n        n2=1\\n        n3=1\\n        if n==0:\\n            return n1\\n        for i in range(n-2):\\n            n1,n2,n3=n2,n3,(n1+n2+n3)\\n        return n3\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1779980,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780045,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780020,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780036,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780312,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1892647,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780323,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780112,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1833192,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1755029,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1779980,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780045,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780020,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780036,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780312,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1892647,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780323,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780112,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1833192,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1755029,
                "content": [
                    {
                        "username": "AlyElsmmanKarram",
                        "content": "Finally EASY problem \\uD83E\\uDD72"
                    },
                    {
                        "username": "santanusen",
                        "content": "Much needed respite!"
                    },
                    {
                        "username": "Alien35",
                        "content": "Next problem => Fouronacci"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**OH THANK YOU FOR THE EASY MONDAY** \\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8"
                    },
                    {
                        "username": "Nikhil_jaat",
                        "content": "[@adityaekka2003](/adityaekka2003) me too bro that to in last test cases ): "
                    },
                    {
                        "username": "giriraj97",
                        "content": "[@adityaekka2003](/adityaekka2003) Use DP "
                    },
                    {
                        "username": "Hypatus",
                        "content": "[@adityaekka2003](/adityaekka2003) Try using [memoization](https://en.wikipedia.org/wiki/Memoization) if you\\'re going to use a recursive solution here"
                    },
                    {
                        "username": "adityaekka2003",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud) \\n\\nI get TLE\\n\\nclass Solution {\\npublic:\\n    int tribonacci(int n) {\\n\\n        if(n==0 || n<0)\\n        return 0;\\n        if(n==1 || n==2)\\n        return 1;\\n        \\n        int x=n-3;\\n\\n        return tribonacci(x)+tribonacci(x+1)+tribonacci(x+2);\\n    }\\n};"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "[@pragyt78](/pragyt78) don\\'t use recursion, use iterative approach and you will not have any problems.\\nCan you share your TLE code ? I am pretty interested to see what can cause a TLE."
                    },
                    {
                        "username": "pragyt78",
                        "content": "Were you able to resolve the tle???"
                    },
                    {
                        "username": "kontsis",
                        "content": "Thank god, so tired of doing hards for hours."
                    },
                    {
                        "username": "arghyadas",
                        "content": "After LFU , leetcode finally showed mercy. "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "Yeah, lfu was a good problem though, I didn\\'t knew it before."
                    },
                    {
                        "username": "Noah492",
                        "content": "Don\\'t want to bother understanding what this line means?:\\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\\n\\nBasically, all a Tribonacci number is, is the sum of the preceding three numbers\\nHere is a sample sequence:\\n0 1 1 2 4 7 13\\n\\n0 + 1 + 1 = 2\\n1 + 1 + 2 = 4\\n1 + 2 + 4 = 7\\n2 + 4 + 7 = 13\\n\\nHope that clarifies things!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Should Leonardo Fibonacci be called Leonardo Dibonacci or Bibonacci?"
                    },
                    {
                        "username": "spencermainaa",
                        "content": "Leonardo Couplebonacci"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Can we do this with matrix exponentiation for O(log(n)) time, as it is possible for [fibonacci numbers](https://math.stackexchange.com/questions/867394/how-to-compute-the-nth-number-of-a-general-fibonacci-sequence-with-matrix-multip)?\n\nMaybe the following 3 x 3 matrix is the building block we need?\n```\n1 1 1\n1 0 0\n0 1 0\n```"
                    },
                    {
                        "username": "zloytvoy",
                        "content": "Yes, every linear recursion can be written in the matrix form(since matrices describe linear transformations) and then the same trick with fast matrix exponentiation can be applied. However, one needs to be a bit more careful, since multiplying matrices also takes significant time. Ideally you will need to write it in the Jordan normal form before applying the fast multiplication trick.\\n\\nAs for your transformation: it sends (a, b, c) to (a+b+c, a, b) so indeed if you start with the vector (f_n, f_{n-1}, f_{n-2}) you will get (f_{n+1}, f_n, f_{n-1}). \\n"
                    },
                    {
                        "username": "RishabhDixit1",
                        "content": "if(n==0)\\n        return 0;\\n        if(n==1||n==2)\\n        return 1;\\n\\n        return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n        why it is showing TLE"
                    },
                    {
                        "username": "Deepankarletcode7765",
                        "content": "same bro\\n"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/ \\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\n"
                    },
                    {
                        "username": "colabee992",
                        "content": "Did a recursive like in a regular fibonacci but got TLE at n = 30. What should I do?"
                    },
                    {
                        "username": "ovi737",
                        "content": "You should use dp to store values"
                    },
                    {
                        "username": "charonme",
                        "content": "don\\'t repeatedly add the same 3 numbers again and again hundreds of thousands of times if you have already added them together once"
                    },
                    {
                        "username": "akamazing412",
                        "content": "use dp "
                    },
                    {
                        "username": "has_786",
                        "content": "you only need 4 variables and a for loop, done"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Make an array of size n+1 and store the values you get in recursion in that array... like arr[4]=4th tribonacci number. Also check if you have value already in array before calling function each time. This will save time and avoid repeated work for you. It\\'s called Memoization ... "
                    },
                    {
                        "username": "Diamantis",
                        "content": "Use dynamic programming, either recursively with memoization or iteratively."
                    },
                    {
                        "username": "ivan-guerra",
                        "content": "You can write a \"memoized\" solution which caches previous computations effectively \"pruning\" the recursion tree. Checkout this link [Fibonacci and Memoization](https://medium.com/@porzingod/fibonacci-and-memoization-e99f765b97f6) for an explanation."
                    }
                ]
            },
            {
                "id": 1780985,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 1780808,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 1752758,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 2067638,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 2054499,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 2014869,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 1958849,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 1863644,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 1852568,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 1840780,
                "content": [
                    {
                        "username": "shrutika051220",
                        "content": "  WHY IT IS GIVING TLE FOR ONE TEST CASE \\n\\n `int tribonacci(int n) {\\n     if(n==0){\\n         return 0;\\n     }\\n     if(n==1){\\n         return 1;\\n     }\\n     if(n==2){\\n         return 1;\\n     }\\n         return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);\\n     }`"
                    },
                    {
                        "username": "user0411bt",
                        "content": "[@shrutika051220](/shrutika051220) implement memoization else overlapping subproblems will be calculated again and again. Store it in a dp table."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "If you\\'re getting a TLE error when using the recursive formula return tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3);, it\\'s likely due to the fact that this implementation uses a lot of recursive function calls.\\n\\nEach time the tribonacci function is called recursively, it creates a new stack frame and takes up memory. If the number n is large, the number of recursive function calls can become very large, leading to a large amount of memory being used and slowing down the program.\\n\\nTo avoid this issue, you could use an iterative approach like the one I used in my solution URL: https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time."
                    },
                    {
                        "username": "charonme",
                        "content": "for n=30 you're adding 3 numbers 18947744 times, while you only need to add 3 numbers 28 times to get from t_0, t_1 and t_2 to t_30\n"
                    },
                    {
                        "username": "cosmin1490",
                        "content": "[@shrutika051220](/shrutika051220) because without memoization or other techniques to not recalculate a state multiple times, your actual complexity is exponential and not linear.  "
                    },
                    {
                        "username": "shrutika051220",
                        "content": "@can someone please answer this"
                    },
                    {
                        "username": "Nik228",
                        "content": "finally, i didn\\'t understand anything "
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "Why there is no Dart Language in this problem ? but other problems having solutions for Dart Language"
                    },
                    {
                        "username": "RenniOG",
                        "content": "What a fucking awful way of explaining the problem, it says T(n+3) = T(n) + T(n+1) + T(n+2) which is NOT correct, since you are given n, the correct way of explaining it would be for n==0, T(n) == 0; for 0<n<3, T(n) == 1; for n>=3, T(n) = T(n-1) + T(n-2) + T(n-3), since you are given n, basing the explanation on T(n+3) is both stupid and unnecessary. "
                    },
                    {
                        "username": "psionl0",
                        "content": "This is one of the LeetCode 75 questions (the only reason I am doing it).\nIf this is the first time you have ever heard of Dynamic Programming then this is a good place to start. There are many YouTubes that explain why using recursion to calculate Fibonacci numbers is a bad idea and how to use DP to speed up the calculation. Once you understand the concept, you can easily adapt the solution for Fibonacci numbers to this one."
                    },
                    {
                        "username": "amansingh21510",
                        "content": "i am getting this error will you help me to understand why it coming\\ncode is mention in last.\\n\\n=================================================================\\n==23==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000034 at pc 0x0000003550cd bp 0x7ffea2e68d30 sp 0x7ffea2e68d28\\nWRITE of size 4 at 0x602000000034 thread T0\\n    #2 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\n0x602000000034 is located 0 bytes to the right of 4-byte region [0x602000000030,0x602000000034)\\nallocated by thread T0 here:\\n    #5 0x7fac10047082  (/lib/x86_64-linux-gnu/libc.so.6+0x24082)\\nShadow bytes around the buggy address:\\n  0x0c047fff7fb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c047fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c047fff8000: fa fa fd fd fa fa[04]fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8010: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==23==ABORTING\\n\\ncode: \\n\\n\\n    int solveTab(int n)\\n    {\\n    \\n      vector<int> dp(n+1);\\n\\n      dp[0]=0;\\n      dp[1]=1;\\n      dp[2]=1;\\n\\n      for(int i=3; i<=n; i++)\\n      {\\n          dp[i] = dp[i-1] + dp[i-2] + dp[i-3];\\n      }\\n\\n      return dp[n];\\n    }"
                    },
                    {
                        "username": "minkowskiq",
                        "content": "What language are you using? The C++ starter code does not container a `solveTab` function or method."
                    },
                    {
                        "username": "layyy",
                        "content": "Store previous values to avoid TLE"
                    },
                    {
                        "username": "mr_1314_",
                        "content": "why recursive way is showing TLE?"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "  public HashMap<Integer,Integer> map = new HashMap<>();\\n    public int tribonacci(int n) {\\n        if(map.containsKey(n)){\\n            return map.get(n);\\n        }\\n        if(n<=0){\\n            return 0;\\n        }\\n        if(n<=2){\\n            return 1;\\n        }\\n        map.put(n,tribonacci(n-1)+tribonacci(n-2)+tribonacci(n-3));\\n        return map.get(n);\\n    }"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people rescue for tips?"
                    },
                    {
                        "username": "Arratay",
                        "content": "This problem would by more interesting for n bigger than 37, when it would be necessary to reduce time complexity to logarithmic.\\nFor example the task could be to calculate T_n mod 1000 000 000 (to fit in 32-bit)"
                    }
                ]
            },
            {
                "id": 1781609,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1781339,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1781300,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1781101,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1781099,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1781069,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1780969,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1780876,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1780805,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1780673,
                "content": [
                    {
                        "username": "shubhlaxh_porwal",
                        "content": "I am getting the below error when trying to do the problem using memoization. Can someon please help\\n `your inline code...your inline code...`\\n`class Solution:\\n    def tribonacci(self, n: int) -> int:\\n        def trt(n):\\n            memo={0: 0, 1: 1, 2: 1}\\n            if n in memo:\\n                return memo[n]\\n            else:\\n                memo[n] = trt(n-1) + trt(n-2) + trt(n-3)\\n                return memo[n]\\n        trt(n)\\n\\nError:\\nTypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 33 in _driver (Solution.py)\\n\\nI have tried using default dict but still i am getting same issue"
                    },
                    {
                        "username": "charlieanthony",
                        "content": "praise the lord - one that I can do lmao"
                    },
                    {
                        "username": "Susobhanakhuli",
                        "content": "class Solution {\\npublic:\\n    int tribonacci(int n) {\\n        int ans;\\n        int px = 0, py = 1, pz = 1;\\n        if(n==0)\\n            return px;\\n        if(n==1 || n==2)\\n            return py;\\n        for(int i=3; i<=n; i++){\\n            ans = px+py+pz;\\n            px = py;\\n            py = pz;\\n            pz = ans;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "what is tribonacy?"
                    },
                    {
                        "username": "ak_is_here",
                        "content": "The Tribonacci sequence is a mathematical sequence where each number is the sum of the previous three numbers. The sequence starts with 0, 1, 1, 2, 4, 7, 13, 24, and so on."
                    },
                    {
                        "username": "ankitmahapatra8018",
                        "content": "How we can reduce the space...."
                    },
                    {
                        "username": "ak_is_here",
                        "content": "Hey!\\nPlease refer to my solution :https://leetcode.com/problems/n-th-tribonacci-number/solutions/3335471/easiest-solution-beats-100-dynamic-programming-time-and-space-complexity/\\nThe iterative approach only requires a fixed amount of memory for the array T and runs in linear time.\\nHope this helps!\\nKeep Coding!"
                    },
                    {
                        "username": "_aakash027",
                        "content": "Finally easy problem\\n"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/n-th-tribonacci-number/solutions/3118629/js-linear-time-complexity-52-space-efficient-92-explanation/\\n\\nSpace Efficeint \\nLinear Time \\n"
                    },
                    {
                        "username": "Romil_",
                        "content": "after breaking my 10 days streak yesterday, this is exactly what I needed.  \\nLiterally took less than a minute. lol"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Finally **Easy problem\\uD83D\\uDE42** that can have **[Multiple Solutions](https://youtu.be/OlG_8lEBETY)**."
                    }
                ]
            },
            {
                "id": 1780653,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780628,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780607,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780559,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780496,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780475,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780456,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780455,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780450,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780433,
                "content": [
                    {
                        "username": "Afzal543",
                        "content": "Finally Question Of My Level !!!!!!!!!! "
                    },
                    {
                        "username": "Asadbek525",
                        "content": "Today holiday:)"
                    },
                    {
                        "username": "Nzappa-zap",
                        "content": "T1 must be 0 in Tribonacii"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Finally an Easy problem after loads of HARD problems !!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "Klemo1997",
                        "content": "Leetcode daily challenges really do be like for 5 mins or 5 hours and nothing in between"
                    },
                    {
                        "username": "theyashvishnoi",
                        "content": "hello easy question \\uD83D\\uDC4B...\\nlong time no see ."
                    },
                    {
                        "username": "tanjul_sarathe",
                        "content": "Try to do this Question by DP. bcoz when im doing this qs by recursion it shows time limit exceed.\\nAnd finally easy problems come..\\uD83E\\uDD72\\uD83E\\uDD72"
                    },
                    {
                        "username": "Msey",
                        "content": "after tree-problems this feels like a take a nap in a garden problem"
                    },
                    {
                        "username": "YairLevi",
                        "content": "Me: happy to have an easy problem.\\nLeetcode on Tuesday: \"Find node in constant time using LFU with Union-Find\""
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The moment when you feel a bit relaxed when \"Easy\" pops up on the problems screen."
                    }
                ]
            },
            {
                "id": 1780359,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780354,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780345,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780288,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780255,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780243,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780198,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780168,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780167,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            },
            {
                "id": 1780128,
                "content": [
                    {
                        "username": "Abhiraj_Mane",
                        "content": "while using recursion in java Its showing time limit exceeded and 36/39 testcases passes\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1 || n==2)return 1;\\n        return tribonacci(n-1) + tribonacci(n-2) + tribonacci(n-3);\\n    }\\n}\\ncan anyone help me in this?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Try memoizing results instead of going through recursion tree again and again"
                    },
                    {
                        "username": "tarun0428",
                        "content": "same \\n"
                    },
                    {
                        "username": "KuraCode",
                        "content": "https://www.youtube.com/watch?v=nxMDFd7GCsc\\n\\nStep by step of every solution"
                    },
                    {
                        "username": "Singhania9475",
                        "content": "Monday becomes funday after almost a month.."
                    },
                    {
                        "username": "Debugx_x",
                        "content": "EZZ"
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Thanks LeetCode for the easy one"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Hello, I am new to solving daily challenges. \\nThis is the first time I am coming across a daily challenge that is in the premium category, Is this normal?"
                    },
                    {
                        "username": "jithu7432",
                        "content": "Good to know that, but its still showing as premium for me https://leetcode.com/problems/n-th-tribonacci-number/solutions/348243/"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Daily challenges are never in premium category. Sometimes at the very start of the day (from UTC 0:00) it shows to be in premium category because of some system faults. Try checking in later in the day.\\nIn fact, it\\'s available now."
                    },
                    {
                        "username": "amanchandna",
                        "content": "S.C comparison of all O(n) approaches : [solution](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3115965/s-c-comparison-of-all-o-n-approaches/)"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Finallly an Easy Problem!!"
                    },
                    {
                        "username": "amanchandna",
                        "content": "Write recursive solution : get TLE\\nWrite memorized solution (I used map) : T.C O(n) S.C = O(n)\\nWrite O(1) space solution (using constants)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Getting an easy problem after many days of hard problems seems like a chilled glass of fruit juice or lemonade after enduring the scorching heat of the sun on a hot summer day..."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Visible Points",
        "question_content": "<p>You are given an array <code>points</code>, an integer <code>angle</code>, and your <code>location</code>, where <code>location = [pos<sub>x</sub>, pos<sub>y</sub>]</code> and <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> both denote <strong>integral coordinates</strong> on the X-Y plane.</p>\n\n<p>Initially, you are facing directly east from your position. You <strong>cannot move</strong> from your position, but you can <strong>rotate</strong>. In other words, <code>pos<sub>x</sub></code> and <code>pos<sub>y</sub></code> cannot be changed. Your field of view in <strong>degrees</strong> is represented by <code>angle</code>, determining how wide you can see from any given view direction. Let <code>d</code> be the amount in degrees that you rotate counterclockwise. Then, your field of view is the <strong>inclusive</strong> range of angles <code>[d - angle/2, d + angle/2]</code>.</p>\n\n<p>\n<video autoplay=\"\" controls=\"\" height=\"360\" muted=\"\" style=\"max-width:100%;height:auto;\" width=\"480\"><source src=\"https://assets.leetcode.com/uploads/2020/09/30/angle.mp4\" type=\"video/mp4\" />Your browser does not support the video tag or this video format.</video>\n</p>\n\n<p>You can <strong>see</strong> some set of points if, for each point, the <strong>angle</strong> formed by the point, your position, and the immediate east direction from your position is <strong>in your field of view</strong>.</p>\n\n<p>There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.</p>\n\n<p>Return <em>the maximum number of points you can see</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/30/89a07e9b-00ab-4967-976a-c723b2aa8656.png\" style=\"width: 400px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> points = [[2,1],[2,2],[3,3]], angle = 90, location = [1,1]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The shaded region represents your field of view. All points can be made visible in your field of view, including [3,3] even though [2,2] is in front and in the same line of sight.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> points = [[2,1],[2,2],[3,4],[1,1]], angle = 90, location = [1,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> All points can be made visible in your field of view, including the one at your location.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/30/5010bfd3-86e6-465f-ac64-e9df941d2e49.png\" style=\"width: 690px; height: 348px;\" />\n<pre>\n<strong>Input:</strong> points = [[1,0],[2,1]], angle = 13, location = [1,1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You can only see one of the two points, as shown above.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= points.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>points[i].length == 2</code></li>\n\t<li><code>location.length == 2</code></li>\n\t<li><code>0 &lt;= angle &lt; 360</code></li>\n\t<li><code>0 &lt;= pos<sub>x</sub>, pos<sub>y</sub>, x<sub>i</sub>, y<sub>i</sub> &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 877822,
                "title": "python-clean-sliding-window-solution-with-explanation",
                "content": "**Idea**\\n\\nHere are the steps:\\n\\n1) convert all coordinates to radians \\n2) sort the array\\n3) use sliding window to find the longest window that satisfies `arr[r] - arr[l] <= angle`.\\n\\nNote that we need to go around the circle, so we duplicate the array and offset the second half by 2*pi.\\n\\n</br>\\n\\n\\n**Complexity**\\n\\nTime complexity: `O(NlogN)`\\nSpace complexity: `O(N)`\\n\\n</br>\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        \\n        arr, extra = [], 0\\n        xx, yy = location\\n        \\n        for x, y in points:\\n            if x == xx and y == yy:\\n                extra += 1\\n                continue\\n            arr.append(math.atan2(y - yy, x - xx))\\n        \\n        arr.sort()\\n        arr = arr + [x + 2.0 * math.pi for x in arr]\\n        angle = math.pi * angle / 180\\n        \\n        l = ans = 0\\n        for r in range(len(arr)):\\n            while arr[r] - arr[l] > angle:\\n                l += 1\\n            ans = max(ans, r - l + 1)\\n            \\n        return ans + extra\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        \\n        arr, extra = [], 0\\n        xx, yy = location\\n        \\n        for x, y in points:\\n            if x == xx and y == yy:\\n                extra += 1\\n                continue\\n            arr.append(math.atan2(y - yy, x - xx))\\n        \\n        arr.sort()\\n        arr = arr + [x + 2.0 * math.pi for x in arr]\\n        angle = math.pi * angle / 180\\n        \\n        l = ans = 0\\n        for r in range(len(arr)):\\n            while arr[r] - arr[l] > angle:\\n                l += 1\\n            ans = max(ans, r - l + 1)\\n            \\n        return ans + extra\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877845,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<>();\\n        int count = 0;\\n        for (List<Integer> p : points) {\\n            int dx = p.get(0) - location.get(0);\\n            int dy = p.get(1) - location.get(1);\\n            if (dx == 0 && dy == 0) { // edge case of same point\\n                count++;\\n                continue;\\n            } \\n            angles.add(Math.atan2(dy, dx) * (180 / Math.PI));\\n        }\\n        Collections.sort(angles);\\n        List<Double> tmp = new ArrayList<>(angles);\\n        for (double d : angles) tmp.add(d + 360); // concatenate to handle edge case\\n        int res = count;\\n        for (int i = 0, j = 0; i < tmp.size(); i++) {\\n            while (tmp.get(i) - tmp.get(j) > angle) {\\n                j++;\\n            }\\n            res = Math.max(res, count + i - j + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<>();\\n        int count = 0;\\n        for (List<Integer> p : points) {\\n            int dx = p.get(0) - location.get(0);\\n            int dy = p.get(1) - location.get(1);\\n            if (dx == 0 && dy == 0) { // edge case of same point\\n                count++;\\n                continue;\\n            } \\n            angles.add(Math.atan2(dy, dx) * (180 / Math.PI));\\n        }\\n        Collections.sort(angles);\\n        List<Double> tmp = new ArrayList<>(angles);\\n        for (double d : angles) tmp.add(d + 360); // concatenate to handle edge case\\n        int res = count;\\n        for (int i = 0, j = 0; i < tmp.size(); i++) {\\n            while (tmp.get(i) - tmp.get(j) > angle) {\\n                j++;\\n            }\\n            res = Math.max(res, count + i - j + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877735,
                "title": "c-clean-with-explanation",
                "content": "- Find the angle between each point and your location (against the x axis)\\n- Duplicate entire array and append it to the end. Then increase angle by 360 for the appended portion - this is since we\\'re working with a cyclic array. Once you reach the end of the array, you want to continue comparing those values with the values at the beginning of the array.\\n- Use a sliding window to find the max that fit within the given degree\\n- Special case: If the given point is the same as location (for eg. both are [1, 1]) then count that separately - since there is no way to know the angle if the points overlap\\n\\n```\\n#define PI 3.14159265\\n#define MARGIN 1e-9\\n\\nclass Solution {\\npublic:\\n    double get_angle(int x_diff, int y_diff) {\\n        return atan2(y_diff, x_diff) * 180 / PI;\\n    }\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int i, j, n = points.size(), common = 0;\\n        vector<double> vals;\\n        for(i=0; i<n; i++) {\\n            int x = points[i][0] - location[0];\\n            int y = points[i][1] - location[1];\\n            if(x == 0 && y == 0) {\\n                common++;\\n            }\\n            else {\\n                double A = get_angle(x, y);\\n                if(A < 0) A += 360;\\n                vals.emplace_back(A);\\n            }\\n        }\\n\\n        sort(vals.begin(), vals.end());\\n        vector<double> a = vals;\\n        a.insert(a.end(), vals.begin(), vals.end());\\n        for(i=vals.size(); i<a.size(); i++)\\n            a[i] += 360;\\n        int ret = 0;\\n        for(i=0, j=0; i<a.size(); i++) {\\n            while(j < a.size() && (a[j]-a[i]<=angle + MARGIN))\\n                  j++;\\n            ret = max(ret, j - i);\\n        }\\n        return ret + common;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define PI 3.14159265\\n#define MARGIN 1e-9\\n\\nclass Solution {\\npublic:\\n    double get_angle(int x_diff, int y_diff) {\\n        return atan2(y_diff, x_diff) * 180 / PI;\\n    }\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int i, j, n = points.size(), common = 0;\\n        vector<double> vals;\\n        for(i=0; i<n; i++) {\\n            int x = points[i][0] - location[0];\\n            int y = points[i][1] - location[1];\\n            if(x == 0 && y == 0) {\\n                common++;\\n            }\\n            else {\\n                double A = get_angle(x, y);\\n                if(A < 0) A += 360;\\n                vals.emplace_back(A);\\n            }\\n        }\\n\\n        sort(vals.begin(), vals.end());\\n        vector<double> a = vals;\\n        a.insert(a.end(), vals.begin(), vals.end());\\n        for(i=vals.size(); i<a.size(); i++)\\n            a[i] += 360;\\n        int ret = 0;\\n        for(i=0, j=0; i<a.size(); i++) {\\n            while(j < a.size() && (a[j]-a[i]<=angle + MARGIN))\\n                  j++;\\n            ret = max(ret, j - i);\\n        }\\n        return ret + common;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877721,
                "title": "what-is-the-freaking-d-here",
                "content": "Well, though leetcode gives us a short video, which is not very helpful to understand the question. I am really confused on what the the *d* here it is. Please do not forget to explain all your variables you brought in the question...\\n\\nIn the end, I only did a random guess that d could be any angle, but please do not let your user to guess anything next time, leetcode. [sigh]\\n\\nI saw a lot of users comment like \"I guess\" or \"feel like\", see, that is the biggest problem here. And my concern was if d is free to set, then does the counterclock/clockwise matter? I am waiting for the correction from leetcode.\\n\\n```\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        ArrayList<Double> list = new ArrayList<>();\\n        ArrayList<Double> listCounter = new ArrayList<>();\\n        int res = 0, count = 0, left = 0;\\n        for (List<Integer> point : points) {\\n            if (point.equals(location)) {\\n                count++;\\n            } else {\\n                list.add(getDegree(point, location));\\n            }\\n        }\\n        Collections.sort(list);\\n        for (int right = 0; right < list.size(); right++) {\\n            while (list.get(right) - list.get(left) > angle) {\\n                left++;\\n            }\\n            res = Math.max(res, right - left + 1);\\n        }\\n        for (double i : list) {\\n            listCounter.add((i + 180) % 360);\\n        }\\n\\n        Collections.sort(listCounter);\\n        left = 0;\\n        for (int right = 0; right < listCounter.size(); right++) {\\n            while (listCounter.get(right) - listCounter.get(left) > angle) {\\n                left++;\\n            }\\n            res = Math.max(res, right - left + 1);\\n        }\\n        return res + count;\\n    }\\n\\n    public double getDegree(List<Integer> point, List<Integer> location) {\\n        double deltaX = point.get(0) - location.get(0);\\n        double deltaY = -(point.get(1) - location.get(1));\\n        double arc = Math.atan2(deltaY, deltaX);\\n\\t\\tarc = arc < 0 ? Math.abs(arc) : 2 * Math.PI - arc;\\n        return Math.toDegrees(arc);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        ArrayList<Double> list = new ArrayList<>();\\n        ArrayList<Double> listCounter = new ArrayList<>();\\n        int res = 0, count = 0, left = 0;\\n        for (List<Integer> point : points) {\\n            if (point.equals(location)) {\\n                count++;\\n            } else {\\n                list.add(getDegree(point, location));\\n            }\\n        }\\n        Collections.sort(list);\\n        for (int right = 0; right < list.size(); right++) {\\n            while (list.get(right) - list.get(left) > angle) {\\n                left++;\\n            }\\n            res = Math.max(res, right - left + 1);\\n        }\\n        for (double i : list) {\\n            listCounter.add((i + 180) % 360);\\n        }\\n\\n        Collections.sort(listCounter);\\n        left = 0;\\n        for (int right = 0; right < listCounter.size(); right++) {\\n            while (listCounter.get(right) - listCounter.get(left) > angle) {\\n                left++;\\n            }\\n            res = Math.max(res, right - left + 1);\\n        }\\n        return res + count;\\n    }\\n\\n    public double getDegree(List<Integer> point, List<Integer> location) {\\n        double deltaX = point.get(0) - location.get(0);\\n        double deltaY = -(point.get(1) - location.get(1));\\n        double arc = Math.atan2(deltaY, deltaX);\\n\\t\\tarc = arc < 0 ? Math.abs(arc) : 2 * Math.PI - arc;\\n        return Math.toDegrees(arc);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 894732,
                "title": "python-c-3-simple-steps",
                "content": "```html5\\n<b>Time Complexity: O(n&middot;log(n))\\nSpace Complexity: O(n)</b>\\n```\\n<iframe src=\"https://leetcode.com/playground/YyWmsvj7/shared\" frameBorder=\"0\" width=\"100%\" height=\"750\"></iframe>\\n\\n**Notes:**\\n1. ```math.atan2(y,x)``` is used instead of ```math.atan``` because it accounts for the sign of x and y.  \\n```html5\\n    math.atan2(-1, -1) * (180 / &pi;) = -135&deg;\\n\\tmath.atan2(1, 1) * (180 / &pi;) = 45&deg;\\n\\tmath.atan(1/1) * (180 / &pi;) = 45&deg;\\n\\tmath.atan(-1/-1) * (180 / &pi;) = 45&deg;\\n```\\n\\n2. Python: Step 2 is written for readability.  It is more efficient to replace step 2 with the following code:\\n```python\\n\\tangles = sorted((angle_from_me(p) for p in points))\\n\\tif not angles: return points_on_me\\n\\tmax_angle = angles[-1]\\n\\tfor a in angles:\\n\\t\\tif a + 360 > max_angle + angle: break\\n\\t\\tangles.append(a + 360)\\n```\\n\\n3. C++: `double` is used for angles for higher precision. If you are using C++ and obtaining a result that contains one or two points more than the expected result for just a few of the test cases, try increasing the precision by using `double`.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Sliding Window"
                ],
                "code": "```html5\\n<b>Time Complexity: O(n&middot;log(n))\\nSpace Complexity: O(n)</b>\\n```\n```math.atan2(y,x)```\n```math.atan```\n```html5\\n    math.atan2(-1, -1) * (180 / &pi;) = -135&deg;\\n\\tmath.atan2(1, 1) * (180 / &pi;) = 45&deg;\\n\\tmath.atan(1/1) * (180 / &pi;) = 45&deg;\\n\\tmath.atan(-1/-1) * (180 / &pi;) = 45&deg;\\n```\n```python\\n\\tangles = sorted((angle_from_me(p) for p in points))\\n\\tif not angles: return points_on_me\\n\\tmax_angle = angles[-1]\\n\\tfor a in angles:\\n\\t\\tif a + 360 > max_angle + angle: break\\n\\t\\tangles.append(a + 360)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 879125,
                "title": "c-atan2-and-sliding-window",
                "content": "Figure out the angle for each point as it relates to the center one. `atan2` deals with zeros, so it\\'s nice. \\n\\nThen use the sliding window pattern to figure out maximum points wihtin `angle`. A bit tricky part here is to wrap the angle around (e.g. the angle between 10 and 300 is 70). For that, we can go through the array twice, and add `360` after for when we are second time around.\\n\\n```cpp\\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& loc) {\\n    vector<double> angs;\\n    int max_points = 0, overlap = 0;\\n    for (auto &p : points) {\\n        if (p[1] == loc[1] && p[0] == loc[0])\\n            ++overlap;\\n        else\\n            angs.push_back(atan2(p[1] - loc[1], p[0] - loc[0]) * 180 / M_PI);\\n    }\\n    sort(begin(angs), end(angs));\\n    int sz = angs.size();\\n    for (int i = 0, j = 0; i < sz * 2; ++i) {\\n        if (360 * (i >= sz) + angs[i % sz] - 360 * (j >= sz) - angs[j % sz] > angle)\\n            ++j;\\n        max_points = max(max_points, i - j + 1);\\n    }\\n    return max_points + overlap;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& loc) {\\n    vector<double> angs;\\n    int max_points = 0, overlap = 0;\\n    for (auto &p : points) {\\n        if (p[1] == loc[1] && p[0] == loc[0])\\n            ++overlap;\\n        else\\n            angs.push_back(atan2(p[1] - loc[1], p[0] - loc[0]) * 180 / M_PI);\\n    }\\n    sort(begin(angs), end(angs));\\n    int sz = angs.size();\\n    for (int i = 0, j = 0; i < sz * 2; ++i) {\\n        if (360 * (i >= sz) + angs[i % sz] - 360 * (j >= sz) - angs[j % sz] > angle)\\n            ++j;\\n        max_points = max(max_points, i - j + 1);\\n    }\\n    return max_points + overlap;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877966,
                "title": "c-clean-and-commented-code-sliding-window-solution",
                "content": "I was surely surprised to see this problem as a medium at first, but turns out we complicate the solutions unnecessarily if the approach is not clear in our head. Kindly read the comments to understand the solution.\\n```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int answer = 0;\\n        double pi = acos(-1.0);\\n        vector<double> pointAngles;\\n        //iterate through all points p to find the required polar angle with respect to location\\n        for(auto p : points){\\n            if(p[0] == location[0] && p[1] == location[1]){\\n                //these are points with same location as yours\\n                answer += 1;\\n            }else {\\n                int dx = p[0] - location[0];\\n                int dy = p[1] - location[1];\\n                double angle = atan2(dy,dx); // gives inverse tangent in radians for a coordinate\\n                //convert to degrees\\n                double angle1 = angle * (180) / pi;\\n                pointAngles.push_back(angle1);\\n            }\\n        }\\n        sort(pointAngles.begin(),pointAngles.end());\\n        //sorting the angles will make sure that the required count is a contiguous length of angles\\n        int n = pointAngles.size();\\n        for(int i= 0; i < n ; ++i) {\\n            pointAngles.push_back(pointAngles[i] + 360);\\n            // push the angles again by adding 360 to handle the case of consecutive points being after a complete cycle. ex - 345 and 14 (if angle >= 29)\\n        }\\n        int start = 0;\\n        int cnt = 0;\\n        // now a simple implementation of sliding window of size angle\\n        for(int i =0; i < pointAngles.size(); ++i) {\\n            if(pointAngles[i] - pointAngles[start] > angle){\\n                start++;\\n            }\\n            cnt = max(cnt, i - start + 1);\\n        }\\n        answer += cnt; // add this length to the number of overlapping points earlier\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Geometry",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int answer = 0;\\n        double pi = acos(-1.0);\\n        vector<double> pointAngles;\\n        //iterate through all points p to find the required polar angle with respect to location\\n        for(auto p : points){\\n            if(p[0] == location[0] && p[1] == location[1]){\\n                //these are points with same location as yours\\n                answer += 1;\\n            }else {\\n                int dx = p[0] - location[0];\\n                int dy = p[1] - location[1];\\n                double angle = atan2(dy,dx); // gives inverse tangent in radians for a coordinate\\n                //convert to degrees\\n                double angle1 = angle * (180) / pi;\\n                pointAngles.push_back(angle1);\\n            }\\n        }\\n        sort(pointAngles.begin(),pointAngles.end());\\n        //sorting the angles will make sure that the required count is a contiguous length of angles\\n        int n = pointAngles.size();\\n        for(int i= 0; i < n ; ++i) {\\n            pointAngles.push_back(pointAngles[i] + 360);\\n            // push the angles again by adding 360 to handle the case of consecutive points being after a complete cycle. ex - 345 and 14 (if angle >= 29)\\n        }\\n        int start = 0;\\n        int cnt = 0;\\n        // now a simple implementation of sliding window of size angle\\n        for(int i =0; i < pointAngles.size(); ++i) {\\n            if(pointAngles[i] - pointAngles[start] > angle){\\n                start++;\\n            }\\n            cnt = max(cnt, i - start + 1);\\n        }\\n        answer += cnt; // add this length to the number of overlapping points earlier\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1761452,
                "title": "python-visual-explanation-sliding-window-complexity-analysis",
                "content": "Finding Angle is basic trigonometry => **SOHCAHTOA**, remember? lol\\nChose to use **TOA** because no extra step to find **Opp**(locY - pY) and **Adj** (locX - pX)\\n\\ntan(angle) = Opposite / Adjacent => **inverse of tan(opposite / adjacent) = angle**\\ninverse of tan in python is atan() and atan2()\\n\\natan2() return between -pi and pi wheres atan only returns between -pi/2 and pi/2\\nIn this case, we not only care about angles, but positions in 360 angles, so **atan2()** can be useful here.\\n*FYI Syntax-wise, atan() takes one argument, and atan2() takes two argument*\\n\\n**STEPS**\\n1. find all the angles of points to the location\\n2. make sure to count the point where positioned exactly same as location (add to your result later as prompt stated)\\n3. For all the founded angles, **add 360 and merge them into array of angles we found previously** => Say your lowest angle = -174 then adding 360 will be 186 and this will be added to your array as new point.\\n\\t- This is important because, we are going to use sliding window to count maximum sub-array with the boundary(angle) given, however, if we do this with just initially founded angles, we are not considering the case when the person is looking at -pi, in other words, when you are at the end of array, you should still consider the points at the start of the array. **(Please look at GIF)**\\n4. Sliding window to find maximum length sub-array that falls between angle at pointer \\'l\\' and \\'l + angle\\'\\n\\n![image](https://assets.leetcode.com/users/images/97a1af1f-5346-4188-a0a7-1e3b2a5e4d45_1644520012.1160696.gif)\\n\\n\\n**Complexity**\\n\\u2003**Time - O(Plog(P))** for sorting of an array length of (2P) where P represent number of points\\n\\u2003**Space - O(P)** for the array to store angles\\n \\n```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        locX, locY = location[0], location[1]\\n        pAngles = []\\n        locCount = 0\\n        \\n        # find angle from location O(P)\\n        for point in points:\\n            xp, yp = point[0], point[1]\\n            if (yp - locY) == 0 and (xp - locX) == 0:\\n                locCount += 1\\n                continue\\n            else:\\n                pAngle = math.degrees(math.atan2((xp - locX), (yp - locY)))\\n            pAngles.append(pAngle)\\n        \\n        # Add same angles in quadrant but from 180 to 540\\n        # explain in the above graphics\\n        pAngles += [a + 360 for a in pAngles] # O(P)\\n        # sort so we can slide window # O(P log(P))\\n        pAngles.sort()\\n        \\n        # Sliding Window to find maximum subarray within the angle given # O(P)\\n        maxCount = 0\\n        l, r = 0, 0\\n        while r < len(pAngles):\\n            while r < len(pAngles) and pAngles[r] <= pAngles[l] + angle:\\n                r += 1\\n            maxCount = max(maxCount, r - l)\\n            l += 1\\n        \\n        return maxCount + locCount\\n ```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        locX, locY = location[0], location[1]\\n        pAngles = []\\n        locCount = 0\\n        \\n        # find angle from location O(P)\\n        for point in points:\\n            xp, yp = point[0], point[1]\\n            if (yp - locY) == 0 and (xp - locX) == 0:\\n                locCount += 1\\n                continue\\n            else:\\n                pAngle = math.degrees(math.atan2((xp - locX), (yp - locY)))\\n            pAngles.append(pAngle)\\n        \\n        # Add same angles in quadrant but from 180 to 540\\n        # explain in the above graphics\\n        pAngles += [a + 360 for a in pAngles] # O(P)\\n        # sort so we can slide window # O(P log(P))\\n        pAngles.sort()\\n        \\n        # Sliding Window to find maximum subarray within the angle given # O(P)\\n        maxCount = 0\\n        l, r = 0, 0\\n        while r < len(pAngles):\\n            while r < len(pAngles) and pAngles[r] <= pAngles[l] + angle:\\n                r += 1\\n            maxCount = max(maxCount, r - l)\\n            l += 1\\n        \\n        return maxCount + locCount\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1327704,
                "title": "python-100-100-clean-commented-and-explained",
                "content": "The basic algorithm I used was to compute the polar angles (while counting/removing any points which coincided with your \\'location\\'), then sort the angles, and then count the number of points in each relevant sector using 2 pointers (slow/fast) remembering that the circle wraps around. Below is an animation I made illustrating the 2-pointer algorithm used in this problem. The slow pointer is represented by the green line, its point is included in the current count. The fast pointer is represented by the red line, its point is NOT included in the current count.\\n\\n![image](https://assets.leetcode.com/users/images/14120012-543e-41a3-aa51-e791f1086792_1625878700.2866209.gif)\\n\\nInstead of using this version of the 2-pointer solution, it\\'s also possible to solve the puzzle by binary searching for the next point, alternately updating the fast and slow pointers. I think this has been slightly faster in practice, but I haven\\'t implemented it yet.\\n\\nNext, I need to talk about my memory usage. While I did do some things to legitamately keep my memory usage lower (like using a cyclic array rather than appending a second copy of the array to itself), the main reason my memory usage is so low is because I kinda cheated. Instead of just storing the angles in a new array, I first removed them from the given array \\'points\\'. This means that while my solution uses O(n) auxillary memory, in terms of how LeetCode measures memory usage its effectively an O(1) solution (I personally think it\\'s bs that I can do this, but hate the game not the player, right?).\\n\\nTime Complexity : O(nlogn)\\nMemory Complexity : O(n)\\nBest Performance : 2044 ms/37.5 MB : 100%/100%\\n\\'\\'\\'\\n\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        #Compute the Angles of Each Point Relative to Yourself : O(n)\\n        angles = []\\n        Y, X = location.pop(), location.pop() #I\\'m just being extra about the memory thing here...\\n        m = 0\\n        for i in range(len(points)):\\n            #Get the Next Point\\n            x, y = points.pop()\\n            \\n            #Check if the Point is Not at Your Location\\n            if x != X or y != Y:\\n                #Compute the Angle of the Point in Radians\\n                angles.append(atan2(y - Y, x - X))\\n            else:\\n                #Record that the Point Exists\\n                m += 1\\n        \\n        #Sort the Remaining Angles : O(nlogn)\\n        angles.sort()\\n        \\n        #Convert the Angle to Radians\\n        angle *= pi/180\\n        \\n        #2-Pointer Solution : O(n)\\n        j = 1\\n        n = 0\\n        N = len(angles)\\n        for J, i in enumerate(range(N), start = N):\\n            #Increment j as Much as Possible to Find the Points in the Current Sector\\n            while j < J and (angles[j%N] - angles[i])%tau <= angle:\\n                j += 1\\n            \\n            #Check the Case\\n            if j == J:\\n                #The Result is Optimal\\n                return m + N\\n            else:\\n                #Save the Best Result so Far\\n                n = max(n, j - i)\\n        \\n        #Return the Maximum Number of Points\\n        return m + n\\n\\'\\'\\'\\nNote that \\'atan2\\', \\'pi\\', and \\'tau\\' are all included in python\\'s math library, which is imported by default in LeetCode. Also, because \\'atan2\\' outputs an angle in radians, I chose to work in radians throughout instead of in degrees like the problem was presented.\\n\\nEdit: A previous version of my code wrote the angles to the \\'points\\' array and saved which points to delete in a separate array. This algorithm was slightly slower, and used a few more MB of memory (its best performance was 2100 ms/40.4 MB). If you\\'d like to see the code for this version of the algorithm, it\\'s the demo code for the 40.4-41.4 MB submissions.",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Two Pointers",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "The basic algorithm I used was to compute the polar angles (while counting/removing any points which coincided with your \\'location\\'), then sort the angles, and then count the number of points in each relevant sector using 2 pointers (slow/fast) remembering that the circle wraps around. Below is an animation I made illustrating the 2-pointer algorithm used in this problem. The slow pointer is represented by the green line, its point is included in the current count. The fast pointer is represented by the red line, its point is NOT included in the current count.\\n\\n![image](https://assets.leetcode.com/users/images/14120012-543e-41a3-aa51-e791f1086792_1625878700.2866209.gif)\\n\\nInstead of using this version of the 2-pointer solution, it\\'s also possible to solve the puzzle by binary searching for the next point, alternately updating the fast and slow pointers. I think this has been slightly faster in practice, but I haven\\'t implemented it yet.\\n\\nNext, I need to talk about my memory usage. While I did do some things to legitamately keep my memory usage lower (like using a cyclic array rather than appending a second copy of the array to itself), the main reason my memory usage is so low is because I kinda cheated. Instead of just storing the angles in a new array, I first removed them from the given array \\'points\\'. This means that while my solution uses O(n) auxillary memory, in terms of how LeetCode measures memory usage its effectively an O(1) solution (I personally think it\\'s bs that I can do this, but hate the game not the player, right?).\\n\\nTime Complexity : O(nlogn)\\nMemory Complexity : O(n)\\nBest Performance : 2044 ms/37.5 MB : 100%/100%\\n\\'\\'\\'\\n\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        #Compute the Angles of Each Point Relative to Yourself : O(n)\\n        angles = []\\n        Y, X = location.pop(), location.pop() #I\\'m just being extra about the memory thing here...\\n        m = 0\\n        for i in range(len(points)):\\n            #Get the Next Point\\n            x, y = points.pop()\\n            \\n            #Check if the Point is Not at Your Location\\n            if x != X or y != Y:\\n                #Compute the Angle of the Point in Radians\\n                angles.append(atan2(y - Y, x - X))\\n            else:\\n                #Record that the Point Exists\\n                m += 1\\n        \\n        #Sort the Remaining Angles : O(nlogn)\\n        angles.sort()\\n        \\n        #Convert the Angle to Radians\\n        angle *= pi/180\\n        \\n        #2-Pointer Solution : O(n)\\n        j = 1\\n        n = 0\\n        N = len(angles)\\n        for J, i in enumerate(range(N), start = N):\\n            #Increment j as Much as Possible to Find the Points in the Current Sector\\n            while j < J and (angles[j%N] - angles[i])%tau <= angle:\\n                j += 1\\n            \\n            #Check the Case\\n            if j == J:\\n                #The Result is Optimal\\n                return m + N\\n            else:\\n                #Save the Best Result so Far\\n                n = max(n, j - i)\\n        \\n        #Return the Maximum Number of Points\\n        return m + n\\n\\'\\'\\'\\nNote that \\'atan2\\', \\'pi\\', and \\'tau\\' are all included in python\\'s math library, which is imported by default in LeetCode. Also, because \\'atan2\\' outputs an angle in radians, I chose to work in radians throughout instead of in degrees like the problem was presented.\\n\\nEdit: A previous version of my code wrote the angles to the \\'points\\' array and saved which points to delete in a separate array. This algorithm was slightly slower, and used a few more MB of memory (its best performance was 2100 ms/40.4 MB). If you\\'d like to see the code for this version of the algorithm, it\\'s the demo code for the 40.4-41.4 MB submissions.",
                "codeTag": "Python3"
            },
            {
                "id": 1595464,
                "title": "java-sliding-window-change-to-degree-explained-thoroughly",
                "content": "// Three steps to transform points\\n// 1. Change points to radian (Math.atan2(dx, dy))\\n// 2. Change radian to degree (radian * 180/Math.PI)\\n// 3. Add 360 to degree -> doing this will make the angles CIRCULAR (earlier it was just a list of degrees which was linear)\\n\\n// Thanks to @InfinityCode777 for his explanation for point (3) above\\n\\n// Short explanation is that the list of angles is not circular and you can\\'t \\'circle back\\' and check the angles prior to the first angle in the list. Ok, long version is ...\\n\\n// E.g. if this is your list of sorted angles [-179, -92, -10, 7, 55, 164, 167] and you vision angle is 90, (Plot this on a paper and it will help understand it a lot better!!).\\n\\n// Let\\'s start from the first angle -179, plug it into the algorithm above, the max visible points for this point would be 1, which is just -179 itself. However, if you check the angle plot, you will find [-179, 167, 164] are also within the visible range, but at the moment, the algorithm is not able to check that region yet, cuz -179 is the first element in the angle list.\\n\\n// To cover that you you don\\'t want the algorithm stop at last angle 7 but instead, to let it iterate back -179 to cover the region the algorithm has not yet checked at the beginning ( the region on -179\\'s clock-wise side).\\n\\n// To achieve that, you need to add the additional 360 to the original list and append it to the original lis and you will get [-179, -92, -10, 7, 55, 164, 167, 181, 268, 350, 367, 415, 524, 527]. Then after checking 7, you will look at angle 181 (or -179) but at this time, the algorithm is able to compare 181 with [164, 167]. Apparently, they are all within the visible range and the max visible points for this point would be 3 rather than 1\\n\\n// After above conversion, it is Sliding Window problem to MAXIMIZE the points withing the view (angle)\\n\\n// TC : O(NlogN) -> N = length of points\\n// SC : O(N) -> angles array\\n\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<>();\\n        int countOfSameLoc = 0;\\n        for(List<Integer> point : points) {\\n            int dx = point.get(0) - location.get(0); \\n            int dy = point.get(1) - location.get(1);\\n            \\n            if(dx == 0 && dy == 0) {\\n                countOfSameLoc++; // if the point lies on the \\'location\\' itself, it comes in the view ALWAYS (so ADD them in last)\\n            } else {\\n                double degree = Math.atan2(dy, dx) * (180/Math.PI); // Math.atan2(dy, dx) finds the radian of point (x, y) and +ve X-Axis\\n                angles.add(degree);\\n            }\\n        }\\n        \\n        Collections.sort(angles); // now the angles are from -ve to + ve\\n        \\n        int n = angles.size();\\n        for(int i = 0; i < n; i++) {\\n            angles.add(angles.get(i) + 360); // now all angles are CIRCULAR (-150 degree is 210) and (10 degree is now 370)\\n        }\\n        \\n        int begin = 0; // classic sliding window variable \\n        int res = 0;\\n        \\n        for(int end = 0; end < angles.size(); end++) {\\n            // increase \\'end\\' until \\'if\\' condtion doesn\\'t suffice; as soon as \\'if\\' if true, meaning we have gone OUT of VIEW of the \\'angle\\' so we need to increase the lower angle i.e \\'begin\\'\\n            while(angles.get(end) - angles.get(begin) > angle) { // this should be \\'while\\' and not \\'if\\' (sliding window always uses \\'while\\')\\n                begin++;\\n            }\\n            \\n            res = Math.max(res, end - begin + 1); // we need to return the MAX points that can come in VIEW (inside the \\'angle\\' of watch)\\n        }\\n        \\n        res += countOfSameLoc; // these are the points that lies on same location as that of \\'location\\' so ALWAYS add them\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<>();\\n        int countOfSameLoc = 0;\\n        for(List<Integer> point : points) {\\n            int dx = point.get(0) - location.get(0); \\n            int dy = point.get(1) - location.get(1);\\n            \\n            if(dx == 0 && dy == 0) {\\n                countOfSameLoc++; // if the point lies on the \\'location\\' itself, it comes in the view ALWAYS (so ADD them in last)\\n            } else {\\n                double degree = Math.atan2(dy, dx) * (180/Math.PI); // Math.atan2(dy, dx) finds the radian of point (x, y) and +ve X-Axis\\n                angles.add(degree);\\n            }\\n        }\\n        \\n        Collections.sort(angles); // now the angles are from -ve to + ve\\n        \\n        int n = angles.size();\\n        for(int i = 0; i < n; i++) {\\n            angles.add(angles.get(i) + 360); // now all angles are CIRCULAR (-150 degree is 210) and (10 degree is now 370)\\n        }\\n        \\n        int begin = 0; // classic sliding window variable \\n        int res = 0;\\n        \\n        for(int end = 0; end < angles.size(); end++) {\\n            // increase \\'end\\' until \\'if\\' condtion doesn\\'t suffice; as soon as \\'if\\' if true, meaning we have gone OUT of VIEW of the \\'angle\\' so we need to increase the lower angle i.e \\'begin\\'\\n            while(angles.get(end) - angles.get(begin) > angle) { // this should be \\'while\\' and not \\'if\\' (sliding window always uses \\'while\\')\\n                begin++;\\n            }\\n            \\n            res = Math.max(res, end - begin + 1); // we need to return the MAX points that can come in VIEW (inside the \\'angle\\' of watch)\\n        }\\n        \\n        res += countOfSameLoc; // these are the points that lies on same location as that of \\'location\\' so ALWAYS add them\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878821,
                "title": "video-explanation",
                "content": "https://www.youtube.com/watch?v=EIYPWWRZeWo",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=EIYPWWRZeWo",
                "codeTag": "Unknown"
            },
            {
                "id": 1344722,
                "title": "c-human-readable-explanation",
                "content": "Don\\'t be scared by the math description. You only need to know what is atan2.\\n\\n![image](https://assets.leetcode.com/users/images/a9986cc9-9c19-465d-9696-7d5a3546b65c_1626567603.790947.png)![image](https://assets.leetcode.com/users/images/b0e576c5-1b2d-41ed-a64d-5785ce3f391b_1626568498.8732185.png)\\n\\n\\n**Key Observations:**\\n1 All you need is to convert each point to an angle and then use sliding window technique to get the answer.\\n2 The angle will wrap around, like a circular array.\\n3 Special handling on points at location.\\n\\n**Steps:**\\n1 Move your location to (0, 0) and move all points also.\\n2 Keep count on all points already at location. \\n3 Use atan2 to convert all points into angles array.\\n4 Sort angles array ascendingly.\\n5 Copy each angle by adding 360 degree(2*PI) and append to angles array.\\n6 For each angle, see how many angles are in the visible window.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double PI = 3.141592;\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n\\t    // 1 Move your location to (0, 0) and move all points.\\n        for (auto & p : points) {\\n            p[0] -= location[0];\\n            p[1] -= location[1];\\n        }\\n        \\n        vector<double> angles;\\n        int atLocation = 0;\\n        for (auto & p : points) {\\n            // 2 Keep count on all points already at location. \\n            if (p[0] == 0 && p[1] == 0)\\n                atLocation++;\\n            else // 3 Use atan2 to convert all points into angles array.\\n                angles.push_back(atan2(p[1], p[0]));\\n        }\\n        \\n        // 4 Sort angles array ascendingly.\\n        sort(angles.begin(), angles.end());\\n        \\n        // 5 Copy each angle by adding 360 degree(2*PI) and append to angles array.\\n        int size = angles.size();\\n        for (int i = 0; i < size; i++) {\\n            angles.push_back(2 * PI + angles[i]);\\n        }\\n        \\n        double angleWindow = 1.0 * angle / 180 * PI;\\n        int res = 0;\\n        // 6 For each angle, see how many angles are in the visible window.\\n        for (int i = 0; i < angles.size() / 2; i++) {\\n            auto it = upper_bound(angles.begin() + i, angles.end(), angles[i] + angleWindow);  \\n            it--; \\n            res = max(res, int(it - angles.begin()) -  i + 1);\\n        }\\n        \\n        return res + atLocation;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double PI = 3.141592;\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n\\t    // 1 Move your location to (0, 0) and move all points.\\n        for (auto & p : points) {\\n            p[0] -= location[0];\\n            p[1] -= location[1];\\n        }\\n        \\n        vector<double> angles;\\n        int atLocation = 0;\\n        for (auto & p : points) {\\n            // 2 Keep count on all points already at location. \\n            if (p[0] == 0 && p[1] == 0)\\n                atLocation++;\\n            else // 3 Use atan2 to convert all points into angles array.\\n                angles.push_back(atan2(p[1], p[0]));\\n        }\\n        \\n        // 4 Sort angles array ascendingly.\\n        sort(angles.begin(), angles.end());\\n        \\n        // 5 Copy each angle by adding 360 degree(2*PI) and append to angles array.\\n        int size = angles.size();\\n        for (int i = 0; i < size; i++) {\\n            angles.push_back(2 * PI + angles[i]);\\n        }\\n        \\n        double angleWindow = 1.0 * angle / 180 * PI;\\n        int res = 0;\\n        // 6 For each angle, see how many angles are in the visible window.\\n        for (int i = 0; i < angles.size() / 2; i++) {\\n            auto it = upper_bound(angles.begin() + i, angles.end(), angles[i] + angleWindow);  \\n            it--; \\n            res = max(res, int(it - angles.begin()) -  i + 1);\\n        }\\n        \\n        return res + atLocation;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295228,
                "title": "c-sliding-window-solution-with-explaination",
                "content": "First calculate the angles made by all the points with the location. To achieve this, we will need to use atan2() that is C++ function to return arc tan (tan inverse) of the slope formed. So: atan2(y, x) = tan inverse (y/x). atan2() is used instead of atan(), as former has range of [-pi, pi], whereas latter has [-pi/2, pi/2]. \\nThe answer given by atan2() will be in radian, so convert it into degrees by multiplying 180/pi to it. The C++ M_PI constant = pi in mathematics. (Not used here) M_PI_2 = pi/2, M_1_PI = 1/pi, etc.\\n **(This is optional)** Also, if the angle is negative, add 360 directly to it, so that when we will traverse the sliding window,  the traversing is sequential, i.e. if it is -179 degree => +360 = 181 degrees, hence this point will be proceseed after point with angle 180 degrees or less. Or else point with angle -179 degrees will be processed before the point with angle 0 degrees or more. This is just to make the visualisation easy so that we start at 0 degrees and finish at 360, and as stated before this step is optional.\\nAlso, during the same process check if the point is same as location. If it is, we will store their number in one seprate quantity \\'at_start\\', this will be added to our finally answer directly, as these points are always visible irrespective of the orientation.\\nNow, we can loop for all the angles, set left of sliding window = 0 and check for each left and right pair (l and r) if the difference in the angles is greater than the angle given, then we decrease the size of our window from left. At every point we also calculate the maximum value of points we are getting in that window.\\n***Now comes the tricky part:***\\nWhy have I added angles + 360 to the vector again?\\nAnd now that size of vector pa (polar angles) has become double, why am I traversing it two times instead of one?\\nImagine we have some points with angles 0, 1, 2, ..... , 359 and some angle>=2\\nWhen we start at point with angle 0, we are not currently looking at angle 359, but as you would guess, the difference between those angles is less than 2, hence that point must be included in our answer too. But as we cannot do it at the start, we traverse the 360 degrees one more time, in order to include all those cases. \\nBut as we have a 1D vector, and it will only increase linearly, how can angle 0 come after 360 in 2nd iteration? - Simple, just add 360 to it, and repeat it in vector. Thus, we add 360 to all the angles and loop over all point 2 times to NOT miss any of those.\\nThink of it as 1 pass to make all points visible to our radar of sliding window. And 2nd pass to actually calculate the answer for max points visible to our radar at one time.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> pa;\\n        int at_start=0;\\n        for(auto point:points)\\n        {\\n            if(point[0]==location[0] && point[1]==location[1])\\n                at_start++;\\n            else\\n            {\\n                double ang = atan2(point[1]-location[1], point[0]-location[0]) * 180.0 /M_PI;\\n                if(ang<0)\\n                    ang+=360;\\n                pa.push_back(ang);\\n            }\\n        }\\n        sort(pa.begin(), pa.end());\\n        int n=pa.size();   \\n        int l = 0, ret=0;\\n        for(int i=0; i<n; i++)\\n            pa.push_back(pa[i] + 360);\\n        for(int r=0; r<pa.size(); r++)\\n        {\\n            while((pa[r]-pa[l])>angle)\\n                l++;\\n            ret = max(ret, r-l+1);\\n        }\\n        return ret+at_start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Geometry",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> pa;\\n        int at_start=0;\\n        for(auto point:points)\\n        {\\n            if(point[0]==location[0] && point[1]==location[1])\\n                at_start++;\\n            else\\n            {\\n                double ang = atan2(point[1]-location[1], point[0]-location[0]) * 180.0 /M_PI;\\n                if(ang<0)\\n                    ang+=360;\\n                pa.push_back(ang);\\n            }\\n        }\\n        sort(pa.begin(), pa.end());\\n        int n=pa.size();   \\n        int l = 0, ret=0;\\n        for(int i=0; i<n; i++)\\n            pa.push_back(pa[i] + 360);\\n        for(int r=0; r<pa.size(); r++)\\n        {\\n            while((pa[r]-pa[l])>angle)\\n                l++;\\n            ret = max(ret, r-l+1);\\n        }\\n        return ret+at_start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877863,
                "title": "deque-solution-detail-explained-from-math-and-with-pictures",
                "content": "Math background:\\n![image](https://assets.leetcode.com/users/images/d732e6ab-e285-4c22-85cf-08c4227bf846_1601784972.7245748.png)\\n\\nFor such an angle (a), we have tan(a) = y/x, and a = arctan(y/x).\\nSo if we have the coordinate (xa, ya) and location of person (xp, yp), we can calculate the angle with respect to the person is \\nangle = arctan((ya - yp)/(xa - xp))\\n\\nFor the list of points, we can tune it into list of angle:\\n```\\n        List<Double> ang = new ArrayList<>();\\n\\t\\t// record how many points are at the observer\\'s location\\n        int selfe = 0;\\n        for (int i = 0; i < points.size(); i++) {\\n            List<Integer> point = points.get(i);\\n            int x = point.get(0);\\n            int y = point.get(1);\\n            if (x == location.get(0) && y == location.get(1)) {\\n                selfe++;\\n                continue;\\n            }\\n\\t\\t\\t//calculate y/x\\n            float tang = (y - location.get(1)) * 1.0f / ((x - location.get(0)) * 1.0f);\\n\\t\\t\\t//calculate the angle by rad\\n            double an = Math.atan(tang);\\n\\t\\t\\t//convert it to degree\\n            double deg = an / Math.PI * 180;\\n\\t\\t\\t//because the Math.atan() function returns the angle from -90 degree to + 90 degree, so we need to add addition 180 degrees for the points at left(west) of the observer.\\n            if (x < location.get(0)) deg += 180;\\n            ang.add(deg);\\n        }\\n```\\n\\nAfter that, we will have a list of angles. Here I used a deque to keep track of the selected points. If a new point entered the last of deque, the deque will purge the first element until the first angle and last angle are within the observer\\'s permitted angle.\\n```\\n\\t\\t//sort it.\\n\\t\\tCollections.sort(ang);\\n        int max = 0;\\n        Deque<Double> dq = new ArrayDeque<>();\\n        for (int i = 0; i < ang.size(); i++) {\\n            dq.addLast(ang.get(i));\\n\\t\\t\\t// start purging, if the last angle - first angle is greater than the permitted angle.\\n            while (dq.peekLast() - dq.peekFirst() > angle) dq.pollFirst();\\n            max = Math.max(dq.size(),max);\\n        }\\n\\t\\t// do it twice. For example, if the permitted angle is 30, and there are element [-179, 179], we actually should consider them are permitted because they are off by only 2 degrees.\\n\\t\\t// I was lazy at the contest so I simply did the loop again, with every element added 360. it does not really affect the big o dramatically.\\n        for (int i = 0; i < ang.size(); i++) {\\n            dq.addLast(ang.get(i) + 360);\\n            while (dq.peekLast() - dq.peekFirst() > angle) dq.pollFirst();\\n            max = Math.max(dq.size(),max);\\n        }\\n```\\nreturn the count and the overlapped at observer\\'s position.\\n```\\nreturn  max + selfe;\\n```\\n\\nHere full code:\\n```\\npublic int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n    List<Double> ang = new ArrayList<>();\\n    int selfe = 0;\\n    for (int i = 0; i < points.size(); i++) {\\n        List<Integer> point = points.get(i);\\n        int x = point.get(0);\\n        int y = point.get(1);\\n        if (x == location.get(0) && y == location.get(1)) {\\n            selfe++;\\n            continue;\\n        }\\n        float tang = (y - location.get(1)) * 1.0f / ((x - location.get(0)) * 1.0f);\\n        double an = Math.atan(tang);\\n        double deg = an / Math.PI * 180;\\n        if (x < location.get(0)) deg += 180;\\n        ang.add(deg);\\n    }\\n    Collections.sort(ang);\\n    int max = 0;\\n    Deque<Double> dq = new ArrayDeque<>();\\n    for (int i = 0; i < ang.size(); i++) {\\n        dq.addLast(ang.get(i));\\n        while (dq.peekLast() - dq.peekFirst() > angle) dq.pollFirst();\\n        max = Math.max(dq.size(),max);\\n    }\\n    for (int i = 0; i < ang.size(); i++) {\\n        dq.addLast(ang.get(i) + 360);\\n        while (dq.peekLast() - dq.peekFirst() > angle) dq.pollFirst();\\n        max = Math.max(dq.size(),max);\\n    }\\n    return  max + selfe;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n        List<Double> ang = new ArrayList<>();\\n\\t\\t// record how many points are at the observer\\'s location\\n        int selfe = 0;\\n        for (int i = 0; i < points.size(); i++) {\\n            List<Integer> point = points.get(i);\\n            int x = point.get(0);\\n            int y = point.get(1);\\n            if (x == location.get(0) && y == location.get(1)) {\\n                selfe++;\\n                continue;\\n            }\\n\\t\\t\\t//calculate y/x\\n            float tang = (y - location.get(1)) * 1.0f / ((x - location.get(0)) * 1.0f);\\n\\t\\t\\t//calculate the angle by rad\\n            double an = Math.atan(tang);\\n\\t\\t\\t//convert it to degree\\n            double deg = an / Math.PI * 180;\\n\\t\\t\\t//because the Math.atan() function returns the angle from -90 degree to + 90 degree, so we need to add addition 180 degrees for the points at left(west) of the observer.\\n            if (x < location.get(0)) deg += 180;\\n            ang.add(deg);\\n        }\\n```\n```\\n\\t\\t//sort it.\\n\\t\\tCollections.sort(ang);\\n        int max = 0;\\n        Deque<Double> dq = new ArrayDeque<>();\\n        for (int i = 0; i < ang.size(); i++) {\\n            dq.addLast(ang.get(i));\\n\\t\\t\\t// start purging, if the last angle - first angle is greater than the permitted angle.\\n            while (dq.peekLast() - dq.peekFirst() > angle) dq.pollFirst();\\n            max = Math.max(dq.size(),max);\\n        }\\n\\t\\t// do it twice. For example, if the permitted angle is 30, and there are element [-179, 179], we actually should consider them are permitted because they are off by only 2 degrees.\\n\\t\\t// I was lazy at the contest so I simply did the loop again, with every element added 360. it does not really affect the big o dramatically.\\n        for (int i = 0; i < ang.size(); i++) {\\n            dq.addLast(ang.get(i) + 360);\\n            while (dq.peekLast() - dq.peekFirst() > angle) dq.pollFirst();\\n            max = Math.max(dq.size(),max);\\n        }\\n```\n```\\nreturn  max + selfe;\\n```\n```\\npublic int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n    List<Double> ang = new ArrayList<>();\\n    int selfe = 0;\\n    for (int i = 0; i < points.size(); i++) {\\n        List<Integer> point = points.get(i);\\n        int x = point.get(0);\\n        int y = point.get(1);\\n        if (x == location.get(0) && y == location.get(1)) {\\n            selfe++;\\n            continue;\\n        }\\n        float tang = (y - location.get(1)) * 1.0f / ((x - location.get(0)) * 1.0f);\\n        double an = Math.atan(tang);\\n        double deg = an / Math.PI * 180;\\n        if (x < location.get(0)) deg += 180;\\n        ang.add(deg);\\n    }\\n    Collections.sort(ang);\\n    int max = 0;\\n    Deque<Double> dq = new ArrayDeque<>();\\n    for (int i = 0; i < ang.size(); i++) {\\n        dq.addLast(ang.get(i));\\n        while (dq.peekLast() - dq.peekFirst() > angle) dq.pollFirst();\\n        max = Math.max(dq.size(),max);\\n    }\\n    for (int i = 0; i < ang.size(); i++) {\\n        dq.addLast(ang.get(i) + 360);\\n        while (dq.peekLast() - dq.peekFirst() > angle) dq.pollFirst();\\n        max = Math.max(dq.size(),max);\\n    }\\n    return  max + selfe;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1135124,
                "title": "greatest-problem-ever",
                "content": "Sliding window as piece of pie. &#127856;\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int overlap = 0;\\n        List<Double> list = new ArrayList<>(points.size());\\n        for (List<Integer> p : points) {\\n            if (p.get(0) == location.get(0) && p.get(1) == location.get(1)) {\\n                overlap++;\\n            } else {\\n                list.add(angle(p.get(1) - location.get(1), \\n                               p.get(0) - location.get(0)));\\n            }\\n        }\\n        Collections.sort(list);\\n        int max = 0;\\n        int n = list.size();\\n        int i2 = 0;\\n\\t\\t// list.get(i1) is first angle leg \\n\\t\\t// list.get(i2) is second angle leg\\n        for (int i1 = 0; i1 < n; i1++) {\\n\\t\\t\\t// let\\'s grow i1-i2 angle as much as possible\\n\\t\\t\\t// edge case example: angle = 30, i1 = 350 degrees, i2 = 10 degrees\\n\\t\\t\\t// edge case handling: allow i2 to circle around and calculate second leg as (360 + list.get(i2 % n))\\n\\t\\t\\t//                     then i1 = 350, i2 = 370, delta = 20 degrees < 30 degrees\\n            while ((i2 < n && list.get(i2) - list.get(i1) <= angle) || \\n                   (i2 >= n && 360 + list.get(i2 % n) - list.get(i1) <= angle)) {\\n                i2++;\\n            }\\n\\t\\t\\t// after i2 went as far as possible away from i1 under allowed limit - check if a new maximum found\\n            max = Math.max(max, i2-i1);        \\n        }\\n        return max + overlap;\\n    }\\n    \\n    private double angle(int dy, int dx) {\\n        double a = Math.toDegrees(Math.atan2(dy, dx));\\n        return (a < 0 ? a + 360 : a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int overlap = 0;\\n        List<Double> list = new ArrayList<>(points.size());\\n        for (List<Integer> p : points) {\\n            if (p.get(0) == location.get(0) && p.get(1) == location.get(1)) {\\n                overlap++;\\n            } else {\\n                list.add(angle(p.get(1) - location.get(1), \\n                               p.get(0) - location.get(0)));\\n            }\\n        }\\n        Collections.sort(list);\\n        int max = 0;\\n        int n = list.size();\\n        int i2 = 0;\\n\\t\\t// list.get(i1) is first angle leg \\n\\t\\t// list.get(i2) is second angle leg\\n        for (int i1 = 0; i1 < n; i1++) {\\n\\t\\t\\t// let\\'s grow i1-i2 angle as much as possible\\n\\t\\t\\t// edge case example: angle = 30, i1 = 350 degrees, i2 = 10 degrees\\n\\t\\t\\t// edge case handling: allow i2 to circle around and calculate second leg as (360 + list.get(i2 % n))\\n\\t\\t\\t//                     then i1 = 350, i2 = 370, delta = 20 degrees < 30 degrees\\n            while ((i2 < n && list.get(i2) - list.get(i1) <= angle) || \\n                   (i2 >= n && 360 + list.get(i2 % n) - list.get(i1) <= angle)) {\\n                i2++;\\n            }\\n\\t\\t\\t// after i2 went as far as possible away from i1 under allowed limit - check if a new maximum found\\n            max = Math.max(max, i2-i1);        \\n        }\\n        return max + overlap;\\n    }\\n    \\n    private double angle(int dy, int dx) {\\n        double a = Math.toDegrees(Math.atan2(dy, dx));\\n        return (a < 0 ? a + 360 : a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889670,
                "title": "javascript-sliding-window-easy-reading-code-and-explanation",
                "content": "First, the field of view in the description is a little bit abstract and hard to calculate. So, we need to find out a way to make it easier.\\nWe could imagine that there must be a unique line get through ourselves and any target point, so we could get lots of lines from all target points.\\nAnd then, if the angle of rotating between 2 lines is smaller than `angle`, we could say that we can see them both in the field of view.\\n\\nSo right now, we know that we could calculate the angles for all points and how to check whether they in the same field of view.\\nThe last question is that in which view we could see the most points.\\n\\nWe could write down all the angles in sorted order, and draw a field of view. It\\'s easy to find out the view is just like a box and changing the view is just moving the 2 edges of the box.\\nDoes this look familiar? Yes, it\\'s a typical sliding window. So we could solve it via sliding window solution.\\n\\nHere\\'s the code, I split them into 3 parts to make it easy to read.\\nHope this will be helpful. :)\\n\\n```js\\nconst visiblePoints = (points, angle, location) => {\\n  const angles = [];\\n  let max = 0;\\n\\n  for (const point of points) {\\n    if (point[0] === location[0] && point[1] === location[1]) { ++max; continue; }\\n    angles.push(Math.atan2(point[1] - location[1], point[0] - location[0]) * (180 / Math.PI));\\n  }\\n\\n  angles.sort((a, b) => a - b);\\n  const maxAngle = angles[angles.length - 1];\\n  for (const curAngle of angles) {\\n    if (curAngle + 360 - maxAngle > angle) break;\\n    angles.push(curAngle + 360);\\n  }\\n\\n  for (let left = 0, right = 0, cur = max + 1; right < angles.length; ++right, ++cur) {\\n    while (angles[right] - angles[left] > angle) { ++left; --cur; }\\n    cur > max && (max = cur);\\n  }\\n\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst visiblePoints = (points, angle, location) => {\\n  const angles = [];\\n  let max = 0;\\n\\n  for (const point of points) {\\n    if (point[0] === location[0] && point[1] === location[1]) { ++max; continue; }\\n    angles.push(Math.atan2(point[1] - location[1], point[0] - location[0]) * (180 / Math.PI));\\n  }\\n\\n  angles.sort((a, b) => a - b);\\n  const maxAngle = angles[angles.length - 1];\\n  for (const curAngle of angles) {\\n    if (curAngle + 360 - maxAngle > angle) break;\\n    angles.push(curAngle + 360);\\n  }\\n\\n  for (let left = 0, right = 0, cur = max + 1; right < angles.length; ++right, ++cur) {\\n    while (angles[right] - angles[left] > angle) { ++left; --cur; }\\n    cur > max && (max = cur);\\n  }\\n\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880140,
                "title": "c-sliding-window",
                "content": "```\\npublic int VisiblePoints(IList<IList<int>> points, int angle, IList<int> location) {\\n        int pointsAtOrigin = 0;\\n        int max = 0;\\n        List<Double> angles = new List<Double>();\\n        foreach(List<int> point in points)\\n        {\\n            double x = point[0] - location[0];\\n            double y = point[1] - location[1];\\n            if(x == 0 && y ==0)\\n            {\\n                pointsAtOrigin++;\\n            }\\n            else\\n            {\\n                double degrees = Math.Atan2(x,y) * (180.0 / Math.PI);\\n                angles.Add(degrees);\\n                angles.Add(degrees + 360);\\n            }\\n        }\\n        angles.Sort();\\n        int size = angles.Count();\\n        int slow = 0, fast = 0;\\n        for(;fast<size && slow < size/2;)\\n        {\\n            if(angles[fast] - angles[slow] <= angle)\\n            {\\n                max = Math.Max(max, fast - slow +1);\\n                if(max>=size/2)\\n                {\\n                    break;\\n                }\\n                fast++;\\n            }\\n            else\\n            {\\n                slow++;\\n            }\\n        }\\n        return pointsAtOrigin + max;\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\npublic int VisiblePoints(IList<IList<int>> points, int angle, IList<int> location) {\\n        int pointsAtOrigin = 0;\\n        int max = 0;\\n        List<Double> angles = new List<Double>();\\n        foreach(List<int> point in points)\\n        {\\n            double x = point[0] - location[0];\\n            double y = point[1] - location[1];\\n            if(x == 0 && y ==0)\\n            {\\n                pointsAtOrigin++;\\n            }\\n            else\\n            {\\n                double degrees = Math.Atan2(x,y) * (180.0 / Math.PI);\\n                angles.Add(degrees);\\n                angles.Add(degrees + 360);\\n            }\\n        }\\n        angles.Sort();\\n        int size = angles.Count();\\n        int slow = 0, fast = 0;\\n        for(;fast<size && slow < size/2;)\\n        {\\n            if(angles[fast] - angles[slow] <= angle)\\n            {\\n                max = Math.Max(max, fast - slow +1);\\n                if(max>=size/2)\\n                {\\n                    break;\\n                }\\n                fast++;\\n            }\\n            else\\n            {\\n                slow++;\\n            }\\n        }\\n        return pointsAtOrigin + max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176286,
                "title": "python-easy-understand-10-lines-code",
                "content": "This solution is best practise of other similar solutions. It took me a while to understand why we need:\\n**1. Calculate degrees between stand location and each point.**\\nImagine you stand on the location, and rotate yourself. You can always see all points after you rotated 360 degrees, so, you can transfer the relation between your location (two numbers) and each point (another two numbers) to angle(a single number), which would decrease the complecity a lot!\\nAs you start from East, postive X axis will be 0 degree. \\nThe math equation would be: **math.degrees(math.atan2(deltaY, deltaX))**\\n***Note: If a point is the same as location, you will always see it regardless, so we won\\'t consider them in step 2.*** \\n\\n**2. Use sliding window to find max number of points.** \\nAfter we got all the angles and sort them, the problem then became to: When I saw angle X, how many previous angles are still in my feild of view? \\nTwo pointers sliding window is the best way to solve this kind of issue.  \\nPointer `j` go through all the angles, while pointer `i` keep the smallest angle which is still visible within feild of view.\\n***Note: There is an issue that degree 0 is actually the same as 360, we are checking a sliding window in a circle, but the array is a straight line. The best way to solve this sort of cycle issue is to attach the same array in the end, with every angle plus 360 degrees.***      \\n\\nLastly, don\\'t forget to include the points which are the same as the location (len(points) - len(res))\\n\\n```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:        \\n        # start from east, build angles for each point, exclude point same as stand point\\n        res = sorted([math.degrees(math.atan2((p[1] - l[1]), (p[0] - l[0]))) for p in points if p != l])        \\n        \\n        # build slide window\\n        angles = res + [x + 360 for x in res]         \\n        i = 0            \\n        best = 0            \\n        for j, ang in enumerate(angles):                \\n            while ang - angles[i] > angle:                    \\n                i += 1                    \\n            best = max(best, j - i + 1)              \\n        \\n        return best + (len(points) - len(res))      \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:        \\n        # start from east, build angles for each point, exclude point same as stand point\\n        res = sorted([math.degrees(math.atan2((p[1] - l[1]), (p[0] - l[0]))) for p in points if p != l])        \\n        \\n        # build slide window\\n        angles = res + [x + 360 for x in res]         \\n        i = 0            \\n        best = 0            \\n        for j, ang in enumerate(angles):                \\n            while ang - angles[i] > angle:                    \\n                i += 1                    \\n            best = max(best, j - i + 1)              \\n        \\n        return best + (len(points) - len(res))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 877746,
                "title": "sliding-window-algorithm-java",
                "content": "1. Calcualte the angle of every point and the original point\\n2.  Sort the angles\\n3.  Using Sliding window to get the maximum number of points among the window angle.\\n4.  Notice some corner  cases. \\n```\\n    public int visiblePoints(List<List<Integer>> p, int d, List<Integer> lo) { \\n        int n = p.size();\\n        int x = lo.get(0);\\n        int y = lo.get(1);\\n        \\n\\t\\t// Some points are the same with the original points, process these points first\\n        int cnt0 = 0;\\n        for(List<Integer> l: p){\\n            int x0 = l.get(0);\\n            int y0= l.get(1);\\n            \\n            if(x == x0 && y == y0) cnt0++; \\n        }\\n\\t\\t\\n\\t\\t// make an array to store angles \\n        double [] A = new double[n - cnt0];\\n        \\n        int idx = 0;\\n        for(List<Integer> l : p){\\n            int x0 = l.get(0);\\n            int y0= l.get(1);\\n            if(x == x0 && y == y0) continue;;\\n            double de = Math.atan2(y0 - y, x0 - x);\\n            A[idx] = 180*de/Math.PI;\\n            idx++;\\n        }\\n    \\n      \\n        Arrays.sort(A);\\n        int s = 0;\\n        int max = 0;\\n        int cnt = 0;\\n        int z = n - cnt0; //\\n\\t\\t\\n\\t\\t//Sliding window\\n\\t\\t// Notice the 360 degree problem,\\n        for(int i = 0; i < 2*(n - cnt0); i++){\\n            double dd = 0.0;\\n            if(i < z){\\n                dd = A[i];\\n            }\\n            if(i >= z){\\n                dd = A[i%z] + 360; // process 360 degree problem\\n            }\\n            while(s < z && dd - A[s] > d){\\n                s++;\\n            }\\n            if(s >= z) break;\\n            cnt = i - s + 1;\\n            if(cnt > max){\\n                max = cnt;\\n            } \\n        }\\n        \\n        return max + cnt0;\\n        \\n    }",
                "solutionTags": [],
                "code": "1. Calcualte the angle of every point and the original point\\n2.  Sort the angles\\n3.  Using Sliding window to get the maximum number of points among the window angle.\\n4.  Notice some corner  cases. \\n```\\n    public int visiblePoints(List<List<Integer>> p, int d, List<Integer> lo) { \\n        int n = p.size();\\n        int x = lo.get(0);\\n        int y = lo.get(1);\\n        \\n\\t\\t// Some points are the same with the original points, process these points first\\n        int cnt0 = 0;\\n        for(List<Integer> l: p){\\n            int x0 = l.get(0);\\n            int y0= l.get(1);\\n            \\n            if(x == x0 && y == y0) cnt0++; \\n        }\\n\\t\\t\\n\\t\\t// make an array to store angles \\n        double [] A = new double[n - cnt0];\\n        \\n        int idx = 0;\\n        for(List<Integer> l : p){\\n            int x0 = l.get(0);\\n            int y0= l.get(1);\\n            if(x == x0 && y == y0) continue;;\\n            double de = Math.atan2(y0 - y, x0 - x);\\n            A[idx] = 180*de/Math.PI;\\n            idx++;\\n        }\\n    \\n      \\n        Arrays.sort(A);\\n        int s = 0;\\n        int max = 0;\\n        int cnt = 0;\\n        int z = n - cnt0; //\\n\\t\\t\\n\\t\\t//Sliding window\\n\\t\\t// Notice the 360 degree problem,\\n        for(int i = 0; i < 2*(n - cnt0); i++){\\n            double dd = 0.0;\\n            if(i < z){\\n                dd = A[i];\\n            }\\n            if(i >= z){\\n                dd = A[i%z] + 360; // process 360 degree problem\\n            }\\n            while(s < z && dd - A[s] > d){\\n                s++;\\n            }\\n            if(s >= z) break;\\n            cnt = i - s + 1;\\n            if(cnt > max){\\n                max = cnt;\\n            } \\n        }\\n        \\n        return max + cnt0;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2669181,
                "title": "angle-sliding-window-intuition-behind-polar-coordinates",
                "content": "# Intuition\\nThe maximum number of points within the given Field Of View (FOV) is the maximum of the number of points contained in the interval window $$[\\\\theta, \\\\theta+ FOV]$$ of size $$FOV$$, which starts at angle $$x$$ and considers the angle range up to $$x+FOV$$ inclusive.\\nTo attain this, every point has to be represented by its angle with respect to the x-axis relative to the observer (horizontal axis).\\nSince the problem assumes that we are able to observe:\\n- all points in the interval FOV up to infinity\\n- all points which are behind others in the same line of sight\\n\\nThen we do not care about the distance of any point from the observer location. Only the angle at which is located is relevant so solve the problem   \\n# Real world application\\nThis problem provides a simplified setting in which points captured by a LiDAR sensor have to be filtered so as to consider only the ones falling within the field of view of a given RGB camera sensor.\\nE.g. to obtian occupancy maps of the environment for an autonomous driving application.\\n\\n## Simplified algorithm\\nNote: the below simplified algorithm gives only a simple intuition about a sliding window solution which is then refined in the actual approach. \\nThis one would give \"off by 1\" or \"off by 2 errors\" due to the rounding of angles to integers. Nevertheless, it gives a proper intuition about the refinement steps.\\n1. Represent all points with respect to the observer location (perform a translation) \\n2. Transform all points to polar coordinates such that they are represented by distance(not needed for this problem) and an integer angle with respect to the observer.\\n3. Create a count vector of size $360+FOV$, with index that represents the angle and value the frequency (e.g. number of points) represented by that angle (ignore points exactly at observer location). Note that the array considers also FOV bonus locations in order to evaluate all possible windows that are placed in an interval that crosses angle 360 and 0 (which represent the same angular location).\\n4. Given the obtained counts, transform such array to a prefix sum array.\\n5. Compute number of points within window of size $FOV$ starting at \\n  $x \\\\in [0,360]$ by means of the prefix sum computedbefore $cur\\\\_count = prefix\\\\_sum[x+FOV]-prefix\\\\_sum[x-1] $\\n6. Return $max_{i}(cur\\\\_count_i) + K$, where K is the number of previously ignored points.\\n\\n# Approach\\nNote: this will be an in depth explanation that covers deeply all concepts.\\nJust glance through it if you want to just see the code.\\nFurthermore, the general setting of this problem is that of an engineering problem more than a CS one.\\nSo you might need a bit more math knowledge for this.\\n\\n#### Three concepts are fundamental to fully understand this problem:\\n* **Calculus**: any point x,y in cartesian coordinates can be mapped to another set of coordinates u,v.\\nSince the field of view (FOV for short) is here represented by an angle, it would  be neat **to have points and FOV in the same unit of measurement e.g. angles**. **Polar coordinates** allow to map a point **x,y in cartesian coordinates (x,y) to polar(radius,angle)**.\\nThis is achieved as follows:\\n. $$radius = (x^2+y^2)^{\\\\frac{1}{2}}$$\\n. $$angle=arctan(y/x)$$\\n\\nRead here for more details https://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates ). Here radius is not relevant since the problem states that you can \"see\" behind points on the same line of sight, otherwise you would need it.  \\n\\n\\n* **Sliding window**: Now that the field of view and the points are represent both as angles, we can\\nconceptualize the field of view as a window/interval/range which has size equal to the provided field of view angle ). Hence the problem is reduced to finding the sliding window that contains the maximum number of points. \\nStill, where should we slide the window that represents the field of view?\\nIt should be slid by placing it at any of the points x,y represented by their angle $\\\\theta$, and considering the FOV area after it: this is represented by the interval $[\\\\theta, \\\\theta + FOV]$, in which $FOV$ is basically the sliding window size.\\n\\n* **Coordinate translation**: \\npoints have to be represented with respect to the observer location, since the field of view has to be considered based on that position. \\nUp to now, the location of the observer (given in the problem as \"location\")\\nhas not been taken into account when considering angles and sliding windows. Indeed the data is given to us with respect to the origin of the plane. \\nHowever, as stated in the problem, we need to determine all quantities with respect to the observer\\'s field of view.\\nThis can be solved by simply translating all points such that they are represented with respect to the observer location, rather than the origin of the axis.\\nAs an example, if the observer is located at location=$(x_{obs}=1,y_{obs}=1)$ (with respect to the origin $(0,0)$), a point $(x=1,y=0)$ (also with respect to the origin), \\nthe observer would see it exactly below its location, thus at \\n$(x_{new}=0,y_{new}=-1)$. Therefore to achieve this result, every point has to be represented relative to the observer location.\\nThis is mathematically achieved by a simple translation:\\n. $$x_{new}=x-x_{obs}$$\\n. $$y_{new}=y-y_{obs}$$\\n\\n* **Edge cases**\\n  All points that after the translations are exactly below the observer are deemed at angle 0 (because $arctan(0)=0$) with respect to it. Still, any points located exactly at the observer location has to be considered as visible by any field of view sliding window. Thus, these are excluded and added back to the result after all computations are performed.\\n\\n# Complexity\\nN = number of points\\n- Time complexity:\\n$$O(N \\\\log N)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n# Code\\n```\\n\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        t = Solution.t\\n        to_angle = Solution.to_angle            \\n        \\n        points_at_location = 0\\n        angles = []\\n        for point in points:\\n            x1,y1 = t(*point, *location)\\n            if x1 == 0 and y1 == 0:\\n                points_at_location += 1\\n                continue\\n            ang = to_angle(x1,y1) \\n            angles.append(ang)\\n\\n            if ang >= 0 and ang < angle:\\n                angles.append(ang+360)\\n        angles = sorted(angles)\\n        max_s = 0\\n        j = 0\\n        for i in range(0, len(angles)):\\n            \\n            while angles[i]-angles[j] > angle:\\n                j += 1\\n\\n            max_s = max(i-j+1, max_s)\\n        return max_s + points_at_location\\n\\n\\n    def t(x,y, x0,y0):\\n        x1 = x-x0\\n        y1 = y-y0\\n        return x1,y1\\n    \\n    def to_angle(x,y):\\n        angle = (math.atan2(y,x)/(math.pi))*180 \\n        if angle < 0:\\n            angle += 360\\n        return angle\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        t = Solution.t\\n        to_angle = Solution.to_angle            \\n        \\n        points_at_location = 0\\n        angles = []\\n        for point in points:\\n            x1,y1 = t(*point, *location)\\n            if x1 == 0 and y1 == 0:\\n                points_at_location += 1\\n                continue\\n            ang = to_angle(x1,y1) \\n            angles.append(ang)\\n\\n            if ang >= 0 and ang < angle:\\n                angles.append(ang+360)\\n        angles = sorted(angles)\\n        max_s = 0\\n        j = 0\\n        for i in range(0, len(angles)):\\n            \\n            while angles[i]-angles[j] > angle:\\n                j += 1\\n\\n            max_s = max(i-j+1, max_s)\\n        return max_s + points_at_location\\n\\n\\n    def t(x,y, x0,y0):\\n        x1 = x-x0\\n        y1 = y-y0\\n        return x1,y1\\n    \\n    def to_angle(x,y):\\n        angle = (math.atan2(y,x)/(math.pi))*180 \\n        if angle < 0:\\n            angle += 360\\n        return angle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650271,
                "title": "c-o-n-log-n-30-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        // calc and sort angles and keep track of num of orgs (same point as location)\\n        vector<float> angles;\\n        int orgs = 0;\\n        for(auto p: points) {\\n            int dx = p[0] - location[0];\\n            int dy = p[1] - location[1];\\n            if(dx==0 && dy==0)\\n                orgs++;\\n            else\\n                angles.push_back(atan2(dy, dx) * 180. / M_PI);\\n        }\\n        sort(angles.begin(), angles.end());\\n        \\n        // count in sweeping window (handle overflow with modulo)\\n        int mx = 0;\\n        int j = 0;\\n        int n = angles.size();\\n        for(int i = 0; i < n; ++i) {\\n            while(angles[j % n] + 360 * (j / n) - angles[i] <= angle)\\n                ++j;\\n            mx = max(mx, j-i);\\n        }\\n        \\n        return mx + orgs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        // calc and sort angles and keep track of num of orgs (same point as location)\\n        vector<float> angles;\\n        int orgs = 0;\\n        for(auto p: points) {\\n            int dx = p[0] - location[0];\\n            int dy = p[1] - location[1];\\n            if(dx==0 && dy==0)\\n                orgs++;\\n            else\\n                angles.push_back(atan2(dy, dx) * 180. / M_PI);\\n        }\\n        sort(angles.begin(), angles.end());\\n        \\n        // count in sweeping window (handle overflow with modulo)\\n        int mx = 0;\\n        int j = 0;\\n        int n = angles.size();\\n        for(int i = 0; i < n; ++i) {\\n            while(angles[j % n] + 360 * (j / n) - angles[i] <= angle)\\n                ++j;\\n            mx = max(mx, j-i);\\n        }\\n        \\n        return mx + orgs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959085,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angles = []\\n        count = 0\\n        \\n        for point in points:\\n            dx = point[0] - location[0]\\n            dy = point[1] - location[1]\\n            if dx == 0 and dy == 0:\\n                count += 1\\n                continue\\n            ang = (math.atan2(dy,dx) * (180/math.pi))\\n            angles.append(ang)\\n        \\n        angles.sort()\\n        temp = []\\n        for ang in angles:\\n            if ang<0:\\n                temp.append(360+ang)\\n        angles.extend(temp)\\n        \\n        j = 0\\n        i = 0\\n        res = 0\\n        while j<len(angles):\\n            while i<j and angles[j]-angles[i] > angle:\\n                i+=1\\n            res = max(res, j-i+1)\\n            j+=1\\n        return res+count\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angles = []\\n        count = 0\\n        \\n        for point in points:\\n            dx = point[0] - location[0]\\n            dy = point[1] - location[1]\\n            if dx == 0 and dy == 0:\\n                count += 1\\n                continue\\n            ang = (math.atan2(dy,dx) * (180/math.pi))\\n            angles.append(ang)\\n        \\n        angles.sort()\\n        temp = []\\n        for ang in angles:\\n            if ang<0:\\n                temp.append(360+ang)\\n        angles.extend(temp)\\n        \\n        j = 0\\n        i = 0\\n        res = 0\\n        while j<len(angles):\\n            while i<j and angles[j]-angles[i] > angle:\\n                i+=1\\n            res = max(res, j-i+1)\\n            j+=1\\n        return res+count\\n",
                "codeTag": "Java"
            },
            {
                "id": 878453,
                "title": "c-atan2-inverse-tangent-sort-sliding-window",
                "content": "```\\n#define PI 3.14159265\\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int n=points.size(), ans=0;\\n        vector<double> v;\\n        for(int i=0; i<n; i++){\\n            if(points[i][0]==location[0] && points[i][1]==location[1]){\\n                ans++;\\n                continue;\\n            }\\n            double x=points[i][0]-location[0], y=points[i][1]-location[1], theta=atan2(y, x)*180/PI;\\n            if(theta<0) theta+=360.0;\\n            v.push_back(theta);\\n        }\\n        int left=0, res=0, m=v.size();\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<m; i++) v.push_back(360.0+v[i]);\\n        for(int right=0; right<v.size(); right++){\\n            while(v[right]-v[left]>(double)angle) left++;\\n            res=max(res, right-left+1);\\n        }\\n        return res+ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define PI 3.14159265\\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int n=points.size(), ans=0;\\n        vector<double> v;\\n        for(int i=0; i<n; i++){\\n            if(points[i][0]==location[0] && points[i][1]==location[1]){\\n                ans++;\\n                continue;\\n            }\\n            double x=points[i][0]-location[0], y=points[i][1]-location[1], theta=atan2(y, x)*180/PI;\\n            if(theta<0) theta+=360.0;\\n            v.push_back(theta);\\n        }\\n        int left=0, res=0, m=v.size();\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<m; i++) v.push_back(360.0+v[i]);\\n        for(int right=0; right<v.size(); right++){\\n            while(v[right]-v[left]>(double)angle) left++;\\n            res=max(res, right-left+1);\\n        }\\n        return res+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877782,
                "title": "java-o-n-logn-solution",
                "content": "Calculate all angles first and then use sliding window``\\n\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<>();\\n        \\n\\t\\t//you can always see yourself\\n        int self = 0;\\n        \\n        for(List<Integer> point : points) {\\n            if(location.get(0) == point.get(0) && location.get(1) == point.get(1)) {\\n                self++;\\n            } else {\\n                angles.add(getAngle(location, point));\\n\\t\\t\\t\\t//a trick to handle wrapping\\n                angles.add(getAngle(location, point) + 360);\\n            }\\n        }\\n\\n        Collections.sort(angles);\\n\\n        \\n        int out = 0;\\n        \\n        Queue<Double> q = new LinkedList<>();\\n        \\n        for(Double ang : angles) {\\n            q.add(ang);\\n            while(ang - q.peek() > angle) {\\n                q.poll();\\n            }\\n            \\n            out = Math.max(out, q.size());\\n        }\\n        \\n        return out + self;\\n    }\\n    \\n    private double getAngle(List<Integer> loc, List<Integer> point) {\\n        double angle = Math.toDegrees(Math.atan2(loc.get(1) - point.get(1), loc.get(0) - point.get(0)));\\n\\n        if(angle < 0){\\n            angle += 360;\\n        }\\n\\n        return angle;\\n    }    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<>();\\n        \\n\\t\\t//you can always see yourself\\n        int self = 0;\\n        \\n        for(List<Integer> point : points) {\\n            if(location.get(0) == point.get(0) && location.get(1) == point.get(1)) {\\n                self++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2344502,
                "title": "during-an-interview",
                "content": "**No ways to come up with these sol and formulas during an interview**",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1918408,
                "title": "c-sorting-and-deque",
                "content": "A couple notes on this solution:\\n* **atan** vs **atan2** : it is way safer and easier to go with atan2. \\n* disgard those points are overlapped with the given location. You will add those points at the end regardless of what is the field of view \\n* After sorting the angles, you need to add **some** of the angles to smoothly switch from angle<360 to angle>=0. But the question how many angles do I need? The answer is at most the upper_bound of the given angle. \\n* I love deque solution because it is very intuitive, you add an angle on the back and then check from the front of deque and evict whatever is no longer is in the FoV ... easy! \\n```\\nclass Solution {\\n    double get_angle(const double& v1, const double& v2)\\n    {\\n        return atan2(v1,v2)*180/M_PI;\\n    }\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> angles;\\n        int same_pos=0;\\n        for(auto p : points)\\n        {\\n            int delta_x = p[0]-location[0];\\n            int delta_y = p[1]-location[1];\\n            if (delta_x==0 and delta_y==0)\\n                same_pos++;\\n            else\\n            {\\n                double angle_ = get_angle(delta_x,delta_y);\\n                if (angle_<0)\\n                    angles.push_back(360+angle_);\\n                else\\n                    angles.push_back(angle_);\\n            }\\n        }\\n        \\n        sort(angles.begin(),angles.end());\\n        int pos = upper_bound(angles.begin(), angles.end(), angle)- angles.begin();\\n        \\n        for(int i=0; i<pos;i++)\\n            angles.push_back(angles[i]+360);\\n        \\n        int max_vis = 0;\\n        deque<double> deq;\\n        for(double a : angles)\\n        {\\n            deq.push_back(a);\\n            while(!deq.empty() && deq.front() < a-angle)\\n                deq.pop_front();\\n            \\n            max_vis = max((int)deq.size(), max_vis);\\n        }\\n        return max_vis+same_pos;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    double get_angle(const double& v1, const double& v2)\\n    {\\n        return atan2(v1,v2)*180/M_PI;\\n    }\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> angles;\\n        int same_pos=0;\\n        for(auto p : points)\\n        {\\n            int delta_x = p[0]-location[0];\\n            int delta_y = p[1]-location[1];\\n            if (delta_x==0 and delta_y==0)\\n                same_pos++;\\n            else\\n            {\\n                double angle_ = get_angle(delta_x,delta_y);\\n                if (angle_<0)\\n                    angles.push_back(360+angle_);\\n                else\\n                    angles.push_back(angle_);\\n            }\\n        }\\n        \\n        sort(angles.begin(),angles.end());\\n        int pos = upper_bound(angles.begin(), angles.end(), angle)- angles.begin();\\n        \\n        for(int i=0; i<pos;i++)\\n            angles.push_back(angles[i]+360);\\n        \\n        int max_vis = 0;\\n        deque<double> deq;\\n        for(double a : angles)\\n        {\\n            deq.push_back(a);\\n            while(!deq.empty() && deq.front() < a-angle)\\n                deq.pop_front();\\n            \\n            max_vis = max((int)deq.size(), max_vis);\\n        }\\n        return max_vis+same_pos;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495884,
                "title": "java-sliding-window-approach-commented-formatted",
                "content": "```java\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        // Use ArrayList here in case of TLE\\n        List<Double> memo = new ArrayList<>(); \\n        \\n        int same = 0;\\n        // Compute angle between \"straight-east\" and the point in degree\\n        for (List<Integer> point : points) {\\n            int dx = point.get(0) - location.get(0);\\n            int dy = point.get(1) - location.get(1);\\n            if (dx == 0 && dy == 0) {\\n                same++;\\n                continue;\\n            }\\n            double degree = Math.toDegrees(Math.atan2(dy, dx));\\n            memo.add(degree);\\n        }\\n        \\n        // sort degree to loop in a \"sliding window\" style\\n        Collections.sort(memo);\\n        int n = memo.size();\\n        // add a \"whole loop\" for negative degree to cover cases, like end of memo list and begin\\n        // of memo also could form a valid angle\\n        for (int i = 0; i < n; i++) {\\n            if (memo.get(i) < 0) {\\n                memo.add(memo.get(i) + 360);\\n            }\\n        }\\n        \\n        int count = 0;\\n        // sliding window here, end keeps moving\\n        // move left if current formed angle > limited\\n        for (int start = 0, end = 0; end < memo.size(); end++) {\\n            while (memo.get(end) - memo.get(start) > angle) {\\n                start++;\\n            }\\n            // filter the max possible \\n            count = Math.max(count, end - start + 1);\\n        }\\n        \\n        // not forget to add points same as \"location\"\\n        return count + same;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        // Use ArrayList here in case of TLE\\n        List<Double> memo = new ArrayList<>(); \\n        \\n        int same = 0;\\n        // Compute angle between \"straight-east\" and the point in degree\\n        for (List<Integer> point : points) {\\n            int dx = point.get(0) - location.get(0);\\n            int dy = point.get(1) - location.get(1);\\n            if (dx == 0 && dy == 0) {\\n                same++;\\n                continue;\\n            }\\n            double degree = Math.toDegrees(Math.atan2(dy, dx));\\n            memo.add(degree);\\n        }\\n        \\n        // sort degree to loop in a \"sliding window\" style\\n        Collections.sort(memo);\\n        int n = memo.size();\\n        // add a \"whole loop\" for negative degree to cover cases, like end of memo list and begin\\n        // of memo also could form a valid angle\\n        for (int i = 0; i < n; i++) {\\n            if (memo.get(i) < 0) {\\n                memo.add(memo.get(i) + 360);\\n            }\\n        }\\n        \\n        int count = 0;\\n        // sliding window here, end keeps moving\\n        // move left if current formed angle > limited\\n        for (int start = 0, end = 0; end < memo.size(); end++) {\\n            while (memo.get(end) - memo.get(start) > angle) {\\n                start++;\\n            }\\n            // filter the max possible \\n            count = Math.max(count, end - start + 1);\\n        }\\n        \\n        // not forget to add points same as \"location\"\\n        return count + same;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879691,
                "title": "java-python-kotlin-detailed-clean-readable",
                "content": "## Problem clarification/rephrasing\\n\\nThe problem is very poorly formulated. Essentially, we have a torch with some field of view `angle`. We can keep rotating counter-clock wise with this torch on. [somewhat like this](https://openstax.org/resources/ba4bbdf11a41fa334e16a2341b94328d8bca92cc)\\n\\nWe need to find maximum points covered by any specific rotation state.\\n\\n## Intuition\\n\\nSee it as a problem of finding maximum points covered by a fixed size (`angle`) sliding window in a circular array [(see what I mean by \"circular array\" here)](https://leetcode.com/problems/maximum-sum-circular-subarray/)\\n\\n### What mapping should we use to transform Cartesian coordinates to something suitable for sliding window?\\n\\nWe convert each vector (formed by `location` and point for all points) to an angle. This is *essentially Cartesian to [Polar coordinate](https://en.wikipedia.org/wiki/Polar_coordinate_system) conversion with origin shifted to `location`*\\n\\n```cpp\\ndouble cartesian_to_angle(vector<int> point, vector<int> location) {\\n    y_diff = point[1] - location[1];\\n    x_diff = point[0] - location[0];\\n    return math.atan2(y_diff, x_diff); // note math.atan2 and not math.atan to prevent zero division error when x_diff is 0\\n}\\n```\\n\\n### Edge cases\\n\\nLet\\'s say `theta` mapped value of some point. A point with `theta` value `-178` degrees and other point with `theta` value of `178` degrees are actually just 4 degrees apart but if we just process points by sorted angles, they will not be detected.\\n\\nTo adjust that, we add `360` degrees to all angles and reprocess them. This will process some points twice but won\\'t affect asymptotic runtime.\\n\\nVacuously, processing same points twice also won\\'t \"double count\" them because we\\'re processing points after adding `360` degrees separately, and not sorting regular angles and `360+angles` together.\\n\\n## Other notes\\n\\n- `angle` is in degrees, we need to convert it to radian because programming libraries mostly work with radians.\\n- to find angle, we are using `atan2` and not `atan` to prevent zero division error when `x_diff` in above code snippet is 0.\\n\\n## Code optimized for readability\\nI could write this shorter or faster, but asymptotically, it\\'s dominated by sort operation, so O(n lg n).\\n\\n```python\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        Point = namedtuple(\\'Point\\', \\'x y\\')\\n        my_location = Point(location[0], location[1])\\n        \\n        points, n = [Point(x, y) for x, y in points], len(points)\\n        # remove points on my location\\n        points_not_on_my_location = [point for point in points if not (point.x == my_location.x and point.y == my_location.y)]\\n        number_of_points_on_my_location = n - len(points_not_on_my_location)\\n\\n        def cartesian_to_angle(point):\\n            y_diff = point.y - my_location.y\\n            x_diff = point.x - my_location.x\\n            return math.atan2(y_diff, x_diff)\\n        angles = sorted(cartesian_to_angle(p) for p in points_not_on_my_location)\\n        # note that we didn\\'t combine and sort, we sorted once and combined, so we are not \"double counting\" in sliding window\\n        angles += [angle + 2 * math.pi for angle in angles]\\n        \\n        angle_in_radian = angle * math.pi / 180\\n        left = 0\\n        maximum_window_length = 0\\n        for right in range(len(angles)):\\n            while angles[right] - angles[left] > angle_in_radian:\\n                left += 1\\n            maximum_window_length = max(maximum_window_length, right - left + 1)\\n        return maximum_window_length + number_of_points_on_my_location\\n```\\n\\n### Kotlin\\n\\nI am learning Kotlin so here\\'s a version in that :D\\n\\n```kotlin\\nimport kotlin.math.PI\\nimport kotlin.math.atan2\\nimport kotlin.math.max\\n\\nclass Solution {\\n\\n    private fun cartesianToAngle(point: List<Int>, location: List<Int>): Double {\\n        return atan2((point[1] - location[1]).toDouble(), (point[0] - location[0]).toDouble())\\n    }\\n\\n    fun visiblePoints(points: List<List<Int>>, angle: Int, location: List<Int>): Int {\\n        val pointsNotOnLocation = points.filterNot { it[0] == location[0] && it[1] == location[1] }\\n        val numberOfPointsOnLocation = points.size - pointsNotOnLocation.size\\n\\n        val pointsAsAngles = pointsNotOnLocation.map { cartesianToAngle(it, location) }\\n        val sortedPointsAsAngles = pointsAsAngles.sorted()\\n\\n        val transformedAngles = sortedPointsAsAngles + (sortedPointsAsAngles.map { it + 2 * PI })\\n\\n        val length = transformedAngles.size\\n        var left = 0\\n        val angleInRadian = angle * PI / 180\\n        var maxPointsInWindow = 0\\n        for (right in 0 until length) {\\n            while (transformedAngles[right] - transformedAngles[left] > angleInRadian) {\\n                left++\\n            }\\n            maxPointsInWindow = max(maxPointsInWindow, right - left + 1)\\n        }\\n        return maxPointsInWindow + numberOfPointsOnLocation\\n    }\\n}\\n```\\n\\n### Java\\n\\nBecause Kotlin transpiles to Java easily, I didn\\'t have to type most of this Java code, it was generated. Thank you JetBrains! :D\\n\\n```java\\n\\n// static imports are bad; I\\'ve only kept them for readability\\nimport static java.lang.Math.*;\\n\\npublic class Solution {\\n\\n    private double cartesianToAngle(List<Integer> point, List<Integer> location) {\\n        return atan2(point.get(1) - location.get(1), point.get(0) - location.get(1));\\n    }\\n\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n\\n        int numberOfPointsOnLocation = 0;\\n        List<Double> pointsNotOnLocationAsAngles = new ArrayList<>();\\n        for (List<Integer> point : points) {\\n            if (location.get(1).equals(point.get(1)) && location.get(0).equals(point.get(0))) {\\n                numberOfPointsOnLocation++;\\n            } else {\\n                pointsNotOnLocationAsAngles.add(cartesianToAngle(point, location));\\n            }\\n        }\\n\\n        Collections.sort(pointsNotOnLocationAsAngles);\\n        List<Double> transformedAngles = new ArrayList<>(pointsNotOnLocationAsAngles);\\n\\n        // when two points -179 and 179 are only 2 degrees apart but after sorting, they are at extreme ends.\\n        // To avoid using a bunch of if/else conditions to detect such cases, for simplicity,\\n        // we just add 2 * PI to all points and process them again. This will bring points like -179 and 179 together\\n        // by transforming, say -179 to 181 and we\\'re happy.\\n        for (Double theta : pointsNotOnLocationAsAngles) {\\n            transformedAngles.add(theta + 2 * PI);\\n        }\\n        int maxPointsInWindow = 0;\\n        Double angleInRadian = angle * PI / 180;\\n\\n        int left = 0;\\n        for (int right = 0; right < transformedAngles.size(); right++) {\\n            while (transformedAngles.get(right) - transformedAngles.get(left) > angleInRadian) {\\n                left++;\\n            }\\n            maxPointsInWindow = max(maxPointsInWindow, right - left + 1);\\n        }\\n        return maxPointsInWindow + numberOfPointsOnLocation;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\ndouble cartesian_to_angle(vector<int> point, vector<int> location) {\\n    y_diff = point[1] - location[1];\\n    x_diff = point[0] - location[0];\\n    return math.atan2(y_diff, x_diff); // note math.atan2 and not math.atan to prevent zero division error when x_diff is 0\\n}\\n```\n```python\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        Point = namedtuple(\\'Point\\', \\'x y\\')\\n        my_location = Point(location[0], location[1])\\n        \\n        points, n = [Point(x, y) for x, y in points], len(points)\\n        # remove points on my location\\n        points_not_on_my_location = [point for point in points if not (point.x == my_location.x and point.y == my_location.y)]\\n        number_of_points_on_my_location = n - len(points_not_on_my_location)\\n\\n        def cartesian_to_angle(point):\\n            y_diff = point.y - my_location.y\\n            x_diff = point.x - my_location.x\\n            return math.atan2(y_diff, x_diff)\\n        angles = sorted(cartesian_to_angle(p) for p in points_not_on_my_location)\\n        # note that we didn\\'t combine and sort, we sorted once and combined, so we are not \"double counting\" in sliding window\\n        angles += [angle + 2 * math.pi for angle in angles]\\n        \\n        angle_in_radian = angle * math.pi / 180\\n        left = 0\\n        maximum_window_length = 0\\n        for right in range(len(angles)):\\n            while angles[right] - angles[left] > angle_in_radian:\\n                left += 1\\n            maximum_window_length = max(maximum_window_length, right - left + 1)\\n        return maximum_window_length + number_of_points_on_my_location\\n```\n```kotlin\\nimport kotlin.math.PI\\nimport kotlin.math.atan2\\nimport kotlin.math.max\\n\\nclass Solution {\\n\\n    private fun cartesianToAngle(point: List<Int>, location: List<Int>): Double {\\n        return atan2((point[1] - location[1]).toDouble(), (point[0] - location[0]).toDouble())\\n    }\\n\\n    fun visiblePoints(points: List<List<Int>>, angle: Int, location: List<Int>): Int {\\n        val pointsNotOnLocation = points.filterNot { it[0] == location[0] && it[1] == location[1] }\\n        val numberOfPointsOnLocation = points.size - pointsNotOnLocation.size\\n\\n        val pointsAsAngles = pointsNotOnLocation.map { cartesianToAngle(it, location) }\\n        val sortedPointsAsAngles = pointsAsAngles.sorted()\\n\\n        val transformedAngles = sortedPointsAsAngles + (sortedPointsAsAngles.map { it + 2 * PI })\\n\\n        val length = transformedAngles.size\\n        var left = 0\\n        val angleInRadian = angle * PI / 180\\n        var maxPointsInWindow = 0\\n        for (right in 0 until length) {\\n            while (transformedAngles[right] - transformedAngles[left] > angleInRadian) {\\n                left++\\n            }\\n            maxPointsInWindow = max(maxPointsInWindow, right - left + 1)\\n        }\\n        return maxPointsInWindow + numberOfPointsOnLocation\\n    }\\n}\\n```\n```java\\n\\n// static imports are bad; I\\'ve only kept them for readability\\nimport static java.lang.Math.*;\\n\\npublic class Solution {\\n\\n    private double cartesianToAngle(List<Integer> point, List<Integer> location) {\\n        return atan2(point.get(1) - location.get(1), point.get(0) - location.get(1));\\n    }\\n\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n\\n        int numberOfPointsOnLocation = 0;\\n        List<Double> pointsNotOnLocationAsAngles = new ArrayList<>();\\n        for (List<Integer> point : points) {\\n            if (location.get(1).equals(point.get(1)) && location.get(0).equals(point.get(0))) {\\n                numberOfPointsOnLocation++;\\n            } else {\\n                pointsNotOnLocationAsAngles.add(cartesianToAngle(point, location));\\n            }\\n        }\\n\\n        Collections.sort(pointsNotOnLocationAsAngles);\\n        List<Double> transformedAngles = new ArrayList<>(pointsNotOnLocationAsAngles);\\n\\n        // when two points -179 and 179 are only 2 degrees apart but after sorting, they are at extreme ends.\\n        // To avoid using a bunch of if/else conditions to detect such cases, for simplicity,\\n        // we just add 2 * PI to all points and process them again. This will bring points like -179 and 179 together\\n        // by transforming, say -179 to 181 and we\\'re happy.\\n        for (Double theta : pointsNotOnLocationAsAngles) {\\n            transformedAngles.add(theta + 2 * PI);\\n        }\\n        int maxPointsInWindow = 0;\\n        Double angleInRadian = angle * PI / 180;\\n\\n        int left = 0;\\n        for (int right = 0; right < transformedAngles.size(); right++) {\\n            while (transformedAngles.get(right) - transformedAngles.get(left) > angleInRadian) {\\n                left++;\\n            }\\n            maxPointsInWindow = max(maxPointsInWindow, right - left + 1);\\n        }\\n        return maxPointsInWindow + numberOfPointsOnLocation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 879059,
                "title": "javascript-heavily-commented-sliding-window",
                "content": "\\n```\\n// basically First i transform my points into degrees in regards to my location as the center\\n// I need to perform a sliding window to see how many points can fit within my window of length\\n// angle \\nvar visiblePoints = function(points, angle, location) {\\n    \\n    //Math.atan2(y,x) returns the ANGLE in RADIANS between the point (X,Y), the CENTER (0,0) and x\\'x\\n    // so Math.atan2(5,5) * (180/Math.pi) === 45 //transforms it from radians to degrees instead\\n    let [sx,sy]=location\\n    let onCenter=points.filter(([x,y])=>(x==sx&&y==sy)).length //if i m standing on a point i always count it\\n\\n    points=points.filter(([x,y])=>!(x==sx&&y==sy)) //other than that i dont want it messing with my result\\n\\n                 .map(([x,y])=>{\\n                    // i need to transform my center from (0,0) to location, hence (y-sy,x-sx)\\n                         return Math.atan2(y-sy,x-sx)*(180/Math.PI) //returns the degrees\\n                    })\\n                 .sort((a,b)=>a-b) \\n\\n    //I will now perform the circular array duplication trick in order to consider points from different view\\n    points=[...points,...points.map(d=>d+360)] \\n    // so for example if a point is 340, it can go with a point that is 15\\n    // example : [0,60,230,250,359], angle=200\\n    // would become     [0,60,230,250,359,360,420,590,610,719]\\n    // would allow me to pick  *   *   *   *   * ,which is practically [230,250,359,0,60] \\n    // (every element of my starting array), which are obviously visible with anangle fo 200 deg\\n\\n\\n    //now i will perform a sliding window that tracks the points visible from my current degree-my angle degrees\\n    let start=0,n=points.length,result=0\\n    for (let end = 0; end < n; end++) {\\n        while(start<end&&points[start]<points[end]-angle) //if the point of start is no bueno\\n            start++ // shrink the window until all the points are within angle degrees \\n        result=Math.max(result,end-start+1)\\n    }\\n    return result+onCenter //the points i can see + the ones i ms tanding on\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Geometry",
                    "Sliding Window"
                ],
                "code": "```\\n// basically First i transform my points into degrees in regards to my location as the center\\n// I need to perform a sliding window to see how many points can fit within my window of length\\n// angle \\nvar visiblePoints = function(points, angle, location) {\\n    \\n    //Math.atan2(y,x) returns the ANGLE in RADIANS between the point (X,Y), the CENTER (0,0) and x\\'x\\n    // so Math.atan2(5,5) * (180/Math.pi) === 45 //transforms it from radians to degrees instead\\n    let [sx,sy]=location\\n    let onCenter=points.filter(([x,y])=>(x==sx&&y==sy)).length //if i m standing on a point i always count it\\n\\n    points=points.filter(([x,y])=>!(x==sx&&y==sy)) //other than that i dont want it messing with my result\\n\\n                 .map(([x,y])=>{\\n                    // i need to transform my center from (0,0) to location, hence (y-sy,x-sx)\\n                         return Math.atan2(y-sy,x-sx)*(180/Math.PI) //returns the degrees\\n                    })\\n                 .sort((a,b)=>a-b) \\n\\n    //I will now perform the circular array duplication trick in order to consider points from different view\\n    points=[...points,...points.map(d=>d+360)] \\n    // so for example if a point is 340, it can go with a point that is 15\\n    // example : [0,60,230,250,359], angle=200\\n    // would become     [0,60,230,250,359,360,420,590,610,719]\\n    // would allow me to pick  *   *   *   *   * ,which is practically [230,250,359,0,60] \\n    // (every element of my starting array), which are obviously visible with anangle fo 200 deg\\n\\n\\n    //now i will perform a sliding window that tracks the points visible from my current degree-my angle degrees\\n    let start=0,n=points.length,result=0\\n    for (let end = 0; end < n; end++) {\\n        while(start<end&&points[start]<points[end]-angle) //if the point of start is no bueno\\n            start++ // shrink the window until all the points are within angle degrees \\n        result=Math.max(result,end-start+1)\\n    }\\n    return result+onCenter //the points i can see + the ones i ms tanding on\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2180512,
                "title": "python-short-and-efficient-solution-o-nlogn",
                "content": "```\\ndef visiblePoints(self, ps: List[List[int]], angle: int, location: List[int]) -> int:\\n\\ta, b = location[0], location[1]\\n\\tn = sum([1 for x, y in ps if x==a and y==b])\\n\\n\\tps_angle = sorted([atan2(y-b, x-a) for x, y in ps if x!=a or y!=b])\\n\\tps_angle += [(k + 2.0*pi) for k in ps_angle]\\n\\n\\tangle = radians(angle)\\n\\t\\n\\t# Two-points method to find Longest Contiguous Subarray\\n\\t# such that the angle difference of tail and head < angle\\n\\t\\n\\tans, hi = 0, 0\\n\\tfor lo in range(len(ps_angle)):\\n\\t\\twhile(hi<len(ps_angle) and ps_angle[lo]+angle>=ps_angle[hi]):\\n\\t\\t\\thi += 1\\n\\t\\tans = max(ans, hi-lo)\\n\\treturn ans+n\\n```",
                "solutionTags": [],
                "code": "```\\ndef visiblePoints(self, ps: List[List[int]], angle: int, location: List[int]) -> int:\\n\\ta, b = location[0], location[1]\\n\\tn = sum([1 for x, y in ps if x==a and y==b])\\n\\n\\tps_angle = sorted([atan2(y-b, x-a) for x, y in ps if x!=a or y!=b])\\n\\tps_angle += [(k + 2.0*pi) for k in ps_angle]\\n\\n\\tangle = radians(angle)\\n\\t\\n\\t# Two-points method to find Longest Contiguous Subarray\\n\\t# such that the angle difference of tail and head < angle\\n\\t\\n\\tans, hi = 0, 0\\n\\tfor lo in range(len(ps_angle)):\\n\\t\\twhile(hi<len(ps_angle) and ps_angle[lo]+angle>=ps_angle[hi]):\\n\\t\\t\\thi += 1\\n\\t\\tans = max(ans, hi-lo)\\n\\treturn ans+n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1989968,
                "title": "javascript-sliding-window-atan2-explanation-10-lines-clean-code",
                "content": "- We might have two types of points: \\n\\t1. Points that are at the location; 2. Points that are not at the location\\n- For case 1, we can simply use a constant count, to count how many points are at the location\\n- For case 2, we calculate the angle between the location and the point; then push them to array\\n- To calculate the angle: first find the radius, then convert to degree \\n![image](https://assets.leetcode.com/users/images/507ca860-115d-4616-889b-7b9a5ea1c0ed_1651172880.6333077.jpeg)\\n\\n- If degree is negative, push degree+360 to the array; then sort the array\\n- Use Sliding window to find the max visible points (not at location)\\n- Return the max visible points (not at location) and count (all points that are at the location)\\n\\nVideo explanation: https://www.youtube.com/watch?v=9fAkEkKSDwM&t=791s\\n```\\nvar visiblePoints = function(points, angle, location) {\\n    let [dx, dy] = location, count = 0, arr = [];\\n    for ([x,y] of points) {\\n        if (x == dx && y == dy) count++;\\n        else arr.push(Math.atan2(y-dy, x-dx) * 180 / Math.PI);\\n    }\\n    for (a of arr) if (a<0) arr.push(a+360);\\n    arr.sort((a,b) => a-b);\\n    let l = r = res = 0;\\n    while (r < arr.length) {\\n        while (arr[r] - arr[l] > angle) l++;\\n        res = Math.max(res, r-l+1);\\n        r++; \\n    }\\n    return res + count; \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar visiblePoints = function(points, angle, location) {\\n    let [dx, dy] = location, count = 0, arr = [];\\n    for ([x,y] of points) {\\n        if (x == dx && y == dy) count++;\\n        else arr.push(Math.atan2(y-dy, x-dx) * 180 / Math.PI);\\n    }\\n    for (a of arr) if (a<0) arr.push(a+360);\\n    arr.sort((a,b) => a-b);\\n    let l = r = res = 0;\\n    while (r < arr.length) {\\n        while (arr[r] - arr[l] > angle) l++;\\n        res = Math.max(res, r-l+1);\\n        r++; \\n    }\\n    return res + count; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1695804,
                "title": "clean-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\nTime: O(NLogN), N is the number of points.\\nSpace: O(N)\\n\\n1. Get the angle of each point relative to the \"location\"\\n2. Sort the angles\\n3. Do a sliding window to angles to see what the maximum number of angles within the interval \"angle\"\\n\\n[1] For example, angles = [10, 20, 360], angle = 20 we will count 2, but actually it will be 3.\\n\"\"\"\\nclass Solution(object):\\n    def visiblePoints(self, points, angle, location):\\n        def getAngle(x, y):\\n            #4 axis\\n            if x>0 and y==0:\\n                return 0\\n            elif x==0 and y>0:\\n                return 90\\n            elif x<0 and y==0:\\n                return 180\\n            elif x==0 and y<0:\\n                return 270\\n            \\n            #4 quadrant\\n            if x>0 and y>0:\\n                return math.degrees(math.atan2(abs(y), abs(x)))\\n            elif x<0 and y>0:\\n                return 180-math.degrees(math.atan2(abs(y), abs(x)))\\n            elif x<0 and y<0:\\n                return 180+math.degrees(math.atan2(abs(y), abs(x)))\\n            else:\\n                return 360-math.degrees(math.atan2(abs(y), abs(x)))\\n            \\n        ans = 0\\n        onLocation = 0\\n        angles = []\\n        \\n        for x, y in points:\\n            if x==location[0] and y==location[1]:\\n                onLocation += 1\\n            else:\\n                a = getAngle(x-location[0], y-location[1])\\n                angles.append(a)\\n                if a<=angle: angles.append(360+a) #[1]\\n        \\n        angles.sort()\\n        \\n        i = 0\\n        for j in xrange(len(angles)):\\n            while angles[j]-angles[i]>angle:\\n                i += 1\\n            ans = max(ans, j-i+1)\\n                \\n        return ans+onLocation\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(NLogN), N is the number of points.\\nSpace: O(N)\\n\\n1. Get the angle of each point relative to the \"location\"\\n2. Sort the angles\\n3. Do a sliding window to angles to see what the maximum number of angles within the interval \"angle\"\\n\\n[1] For example, angles = [10, 20, 360], angle = 20 we will count 2, but actually it will be 3.\\n\"\"\"\\nclass Solution(object):\\n    def visiblePoints(self, points, angle, location):\\n        def getAngle(x, y):\\n            #4 axis\\n            if x>0 and y==0:\\n                return 0\\n            elif x==0 and y>0:\\n                return 90\\n            elif x<0 and y==0:\\n                return 180\\n            elif x==0 and y<0:\\n                return 270\\n            \\n            #4 quadrant\\n            if x>0 and y>0:\\n                return math.degrees(math.atan2(abs(y), abs(x)))\\n            elif x<0 and y>0:\\n                return 180-math.degrees(math.atan2(abs(y), abs(x)))\\n            elif x<0 and y<0:\\n                return 180+math.degrees(math.atan2(abs(y), abs(x)))\\n            else:\\n                return 360-math.degrees(math.atan2(abs(y), abs(x)))\\n            \\n        ans = 0\\n        onLocation = 0\\n        angles = []\\n        \\n        for x, y in points:\\n            if x==location[0] and y==location[1]:\\n                onLocation += 1\\n            else:\\n                a = getAngle(x-location[0], y-location[1])\\n                angles.append(a)\\n                if a<=angle: angles.append(360+a) #[1]\\n        \\n        angles.sort()\\n        \\n        i = 0\\n        for j in xrange(len(angles)):\\n            while angles[j]-angles[i]>angle:\\n                i += 1\\n            ans = max(ans, j-i+1)\\n                \\n        return ans+onLocation\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592246,
                "title": "java-95-faster-sliding-window-approach",
                "content": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int pointer = 0;\\n        List<Double> lis = new ArrayList<>();\\n        for(List<Integer> point : points){\\n            if(point.get(0) - location.get(0) == 0 && point.get(1) - location.get(1) == 0) {\\n                pointer++; continue;\\n            }\\n            lis.add(Math.toDegrees(Math.atan2(point.get(0) - location.get(0), point.get(1) - location.get(1))));\\n        }\\n        \\n        double[] arr = new double[lis.size() * 2];\\n        int counter = 0, output = pointer;\\n        for(Double v : lis){\\n            arr[counter++] = v; arr[counter++] = v + 360;\\n        }\\n        Arrays.sort(arr);\\n        for(int i=0,j=i+1;i<arr.length;i++){\\n            while(arr[i] - arr[j] > angle) j++;\\n            output = Math.max(output, pointer+i-j+1);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int pointer = 0;\\n        List<Double> lis = new ArrayList<>();\\n        for(List<Integer> point : points){\\n            if(point.get(0) - location.get(0) == 0 && point.get(1) - location.get(1) == 0) {\\n                pointer++; continue;\\n            }\\n            lis.add(Math.toDegrees(Math.atan2(point.get(0) - location.get(0), point.get(1) - location.get(1))));\\n        }\\n        \\n        double[] arr = new double[lis.size() * 2];\\n        int counter = 0, output = pointer;\\n        for(Double v : lis){\\n            arr[counter++] = v; arr[counter++] = v + 360;\\n        }\\n        Arrays.sort(arr);\\n        for(int i=0,j=i+1;i<arr.length;i++){\\n            while(arr[i] - arr[j] > angle) j++;\\n            output = Math.max(output, pointer+i-j+1);\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455600,
                "title": "c-sort-sliding-window-time-o-nlogn-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> thetas;\\n        int numPtInLocation = 0;\\n        \\n        for (vector<int>& point : points) {\\n            int dx = point[0] - location[0], dy = point[1] - location[1];\\n            \\n            if (dx == 0 && dy ==0) {\\n                ++numPtInLocation;\\n                continue;\\n            }\\n            \\n            // Take the location of the person as the new origin of the coordinate\\n            // and calculate the theta of each point.\\n            thetas.push_back(atan2(dx, dy));\\n            \\n            // Because the person is going to rotate 360 degree to decide the maximum\\n            // number of points that he/she can see, the left and right limit of his/her\\n            // visible range will beyond 360. \\n            thetas.push_back(thetas.back() + 2 * M_PI);\\n        }\\n        \\n        // Sort the points by the thetas.\\n        sort(begin(thetas), end(thetas));\\n        \\n        // Use sliding window algorithm to decide the maximum number of points that\\n        // the person can see.\\n        int maxCnt = 0, left = 0, right = 0;\\n        double angle2 = static_cast<double>(angle) * M_PI / 180;\\n        while (right < thetas.size()) {\\n            while (right < thetas.size() && thetas[right] - thetas[left] <= angle2) {\\n                ++right;\\n            }\\n            maxCnt = max(maxCnt, right - left);\\n            ++left;\\n        }\\n        \\n        return maxCnt + numPtInLocation;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> thetas;\\n        int numPtInLocation = 0;\\n        \\n        for (vector<int>& point : points) {\\n            int dx = point[0] - location[0], dy = point[1] - location[1];\\n            \\n            if (dx == 0 && dy ==0) {\\n                ++numPtInLocation;\\n                continue;\\n            }\\n            \\n            // Take the location of the person as the new origin of the coordinate\\n            // and calculate the theta of each point.\\n            thetas.push_back(atan2(dx, dy));\\n            \\n            // Because the person is going to rotate 360 degree to decide the maximum\\n            // number of points that he/she can see, the left and right limit of his/her\\n            // visible range will beyond 360. \\n            thetas.push_back(thetas.back() + 2 * M_PI);\\n        }\\n        \\n        // Sort the points by the thetas.\\n        sort(begin(thetas), end(thetas));\\n        \\n        // Use sliding window algorithm to decide the maximum number of points that\\n        // the person can see.\\n        int maxCnt = 0, left = 0, right = 0;\\n        double angle2 = static_cast<double>(angle) * M_PI / 180;\\n        while (right < thetas.size()) {\\n            while (right < thetas.size() && thetas[right] - thetas[left] <= angle2) {\\n                ++right;\\n            }\\n            maxCnt = max(maxCnt, right - left);\\n            ++left;\\n        }\\n        \\n        return maxCnt + numPtInLocation;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893950,
                "title": "c-sliding-window-binary-search-tc-o-nlongn-sc-o-n",
                "content": "```\\nclass Solution{\\n  public:    \\n    int visiblePoints(vector<vector<int>>& points, int looking_angle, vector<int>& location){\\n\\t // Calculate angle of each point\\n      auto Get_Angle = [](vector<int>& p1, vector<int>& p2){\\n        double angle = atan2(p1[1] - p2[1], p1[0] - p2[0]);\\n        return (angle >= 0 ? angle : 2 * M_PI + angle) * 180.0 / M_PI;\\n      };\\n      vector<double> angles;\\n      int always_visible = 0;\\n      for(auto& point : points){\\n        if(point == location){\\n          always_visible++;\\n        }else{\\n          angles.emplace_back(Get_Angle(point, location));\\n        }\\n      }\\n      sort(angles.begin(), angles.end());      \\n      int res = 0;\\t  \\n      for(auto& start_angle : angles){\\n\\t    // find all the points between [start_angle, end_angle] (both inclusive)\\n        double end_angle = start_angle + looking_angle;\\n        auto lb = lower_bound(angles.begin(), angles.end(), start_angle);\\n        auto ub = upper_bound(angles.begin(), angles.end(), end_angle);\\n        int dist = ub - lb;\\n        if(end_angle >= 360.0){\\n\\t\\t  // when end_angle is more than 360.0 we search from the beginning after subtracting 360.0\\n          dist += (upper_bound(angles.begin(), angles.end(), end_angle - 360.0) - angles.begin());          \\n        }\\n        res = max(res, dist);\\n      }\\n      return res + always_visible;\\n    }    \\n};\\n",
                "solutionTags": [],
                "code": "class Solution{\\n  public:    \\n    int visiblePoints(vector<vector<int>>& points, int looking_angle, vector<int>& location){\\n\\t // Calculate angle of each point\\n      auto Get_Angle = [](vector<int>& p1, vector<int>& p2){\\n        double angle = atan2(p1[1] - p2[1], p1[0] - p2[0]);\\n        return (angle >= 0 ? angle : 2 * M_PI + angle) * 180.0 / M_PI;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 878117,
                "title": "easy-to-visualize-using-only-tan-1-dely-delx",
                "content": "**If you like the post please upvote and for any queries comment down**\\n```\\nclass Solution {\\npublic:\\n    double PI=3.141592653589793238;\\n    double findangle(vector<int> l,vector<int> p)\\n    {     \\n        int q=0;\\n        //point x axis is greater than location x axis\\n        if(p[0]>=l[0])//quadrant 1 or quadrant 4\\n        {\\n            if(p[1]>=l[1]) //if point y axis is greater\\n                q=1;       //then it belong to quadrant 1\\n            else\\n                q=4;       //else belong to quadrant 4\\n            \\n        }//point x axis is lesser than location x axis\\n        else//it belong to quadrant 2 or quadrant 3\\n        {\\n            if(p[1]>=l[1]) //if point y axis is greater\\n                q=2;       //then it belong to quadrant 2\\n            else\\n                q=3;       //else belong to quadrant 3\\n        }    \\n        double dely=abs(p[1]-l[1]);\\n        double delx=abs(p[0]-l[0]);\\n        //This is basic tan-1(dely/delx) for finding angle between them\\n        double angle=atan(dely/delx);\\n        angle*=(double)180;\\n        angle/=PI;\\n        double r=angle;\\n        //This is illustated in given daigram\\n        if(q==4)\\n            r=360.0-angle;\\n        if(q==2)\\n            r=180.0-angle;\\n        if(q==3)\\n            r=180.0+angle;\\n        \\n        if(r>=360.0)\\n          r-=360.0;\\n        \\n        return r;\\n    }\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> deg;\\n        int common=0;\\n        int ans=0;\\n        for(auto v: points)\\n        {\\n        if(v==location)common++;  //same point as location\\n        else\\n        deg.push_back(findangle(location,v)); //differnt point from location\\n        }\\n        \\n        //Basic sliding window technique \\n        //For finding answer\\n        sort(deg.begin(),deg.end());\\n        vector<double> temp=deg;\\n        for(int i=0;i<temp.size();i++)\\n            temp[i]+=360.0;\\n        \\n        deg.insert(deg.end(),temp.begin(),temp.end());\\n        \\n        for(int i=0,j=0;i<deg.size();i++)\\n        {\\n            while(j<deg.size() && deg[j]-deg[i]<=(double)(angle)+1e-6)\\n            j++;\\n            \\n            ans=max(ans,j-i);\\n        }\\n        \\n        return ans+common;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/336dcb2a-b4a4-4660-8b26-130257210f7d_1601796327.6685004.png)\\n![image](https://assets.leetcode.com/users/images/84a6d8f6-88fb-45d5-a6c2-39dde2c6eab0_1601796327.9293.png)\\n![image](https://assets.leetcode.com/users/images/18142a54-30e0-453c-80cf-dbcddfde27e8_1601796328.0298386.png)\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double PI=3.141592653589793238;\\n    double findangle(vector<int> l,vector<int> p)\\n    {     \\n        int q=0;\\n        //point x axis is greater than location x axis\\n        if(p[0]>=l[0])//quadrant 1 or quadrant 4\\n        {\\n            if(p[1]>=l[1]) //if point y axis is greater\\n                q=1;       //then it belong to quadrant 1\\n            else\\n                q=4;       //else belong to quadrant 4\\n            \\n        }//point x axis is lesser than location x axis\\n        else//it belong to quadrant 2 or quadrant 3\\n        {\\n            if(p[1]>=l[1]) //if point y axis is greater\\n                q=2;       //then it belong to quadrant 2\\n            else\\n                q=3;       //else belong to quadrant 3\\n        }    \\n        double dely=abs(p[1]-l[1]);\\n        double delx=abs(p[0]-l[0]);\\n        //This is basic tan-1(dely/delx) for finding angle between them\\n        double angle=atan(dely/delx);\\n        angle*=(double)180;\\n        angle/=PI;\\n        double r=angle;\\n        //This is illustated in given daigram\\n        if(q==4)\\n            r=360.0-angle;\\n        if(q==2)\\n            r=180.0-angle;\\n        if(q==3)\\n            r=180.0+angle;\\n        \\n        if(r>=360.0)\\n          r-=360.0;\\n        \\n        return r;\\n    }\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> deg;\\n        int common=0;\\n        int ans=0;\\n        for(auto v: points)\\n        {\\n        if(v==location)common++;  //same point as location\\n        else\\n        deg.push_back(findangle(location,v)); //differnt point from location\\n        }\\n        \\n        //Basic sliding window technique \\n        //For finding answer\\n        sort(deg.begin(),deg.end());\\n        vector<double> temp=deg;\\n        for(int i=0;i<temp.size();i++)\\n            temp[i]+=360.0;\\n        \\n        deg.insert(deg.end(),temp.begin(),temp.end());\\n        \\n        for(int i=0,j=0;i<deg.size();i++)\\n        {\\n            while(j<deg.size() && deg[j]-deg[i]<=(double)(angle)+1e-6)\\n            j++;\\n            \\n            ans=max(ans,j-i);\\n        }\\n        \\n        return ans+common;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152319,
                "title": "c-solution-using-atan2-and-sliding-window",
                "content": "```\\n#define pi 3.14159265\\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& loc) {\\n        vector<double> arr;\\n        int count=0;\\n        for(auto &temp: points){\\n            if(temp==loc){\\n                count++;\\n                continue;\\n            }\\n            double x= temp[0]-loc[0], y= temp[1]-loc[1];\\n            double toPush= atan2(y, x)*180/pi ;\\n            arr.push_back((toPush<0)? toPush+360: toPush);\\n        }\\n        \\n        sort(arr.begin(),arr.end());\\n        int ln= arr.size(),i=0,j=0,ans=0;\\n        for(int i=0;i<ln;i++) arr.push_back(360+ arr[i]);\\n        \\n        \\n        while(j<(2*ln)){\\n            while(j<(2*ln) && ((arr[j]- arr[i])<= angle)) j++;\\n            ans= max(ans, j-i);\\n            i++;\\n        }\\n        \\n        return ans+count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Geometry",
                    "Sliding Window"
                ],
                "code": "```\\n#define pi 3.14159265\\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& loc) {\\n        vector<double> arr;\\n        int count=0;\\n        for(auto &temp: points){\\n            if(temp==loc){\\n                count++;\\n                continue;\\n            }\\n            double x= temp[0]-loc[0], y= temp[1]-loc[1];\\n            double toPush= atan2(y, x)*180/pi ;\\n            arr.push_back((toPush<0)? toPush+360: toPush);\\n        }\\n        \\n        sort(arr.begin(),arr.end());\\n        int ln= arr.size(),i=0,j=0,ans=0;\\n        for(int i=0;i<ln;i++) arr.push_back(360+ arr[i]);\\n        \\n        \\n        while(j<(2*ln)){\\n            while(j<(2*ln) && ((arr[j]- arr[i])<= angle)) j++;\\n            ans= max(ans, j-i);\\n            i++;\\n        }\\n        \\n        return ans+count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115123,
                "title": "simple-intuitive-java-sliding-window-with-comments",
                "content": "```\\nclass Solution {\\n    // https://leetcode.com/problems/maximum-number-of-visible-points/\\n    // Shift origin to the the location, then get angle (polar coordinates) with respect to nre origin.\\n    // for -ve angles, add 360, so that we can cover cases like 2nd and 3rd quadrant are together.\\n    // sort by angles and slide window to get max. visible points\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> pointsWithAngles = new ArrayList<>();\\n        int pointsOnLocation = 0;\\n        for (int i = 0; i < points.size(); ++i) {\\n            int x = points.get(i).get(0) - location.get(0);\\n            int y = points.get(i).get(1) - location.get(1);\\n            // they are always visible\\n            if (x == 0 && y == 0) {\\n                pointsOnLocation++;\\n                continue;\\n            }\\n            Double pointAngle = Math.toDegrees(Math.atan2(y, x));\\n            pointsWithAngles.add(pointAngle);\\n            // if angle is negative, add 360 and add it too.\\n            if (pointAngle < 0) {\\n                pointAngle += 360;\\n                pointsWithAngles.add(pointAngle);\\n            }\\n        }\\n\\n        int maxCount = 0, count = 0;\\n        Collections.sort(pointsWithAngles);\\n        int startIndex = 0;\\n        for (int currIndex = 0; currIndex < pointsWithAngles.size();) {\\n            Double startAngle = pointsWithAngles.get(startIndex);\\n            Double endAngle = startAngle + angle;\\n            Double currAngle = pointsWithAngles.get(currIndex);\\n\\n            if (currAngle <= endAngle) {\\n                count ++;\\n                ++currIndex;\\n                maxCount = Math.max(count, maxCount);\\n            } else {\\n                count--;\\n                ++startIndex;\\n            }\\n        }\\n        return maxCount + pointsOnLocation;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // https://leetcode.com/problems/maximum-number-of-visible-points/\\n    // Shift origin to the the location, then get angle (polar coordinates) with respect to nre origin.\\n    // for -ve angles, add 360, so that we can cover cases like 2nd and 3rd quadrant are together.\\n    // sort by angles and slide window to get max. visible points\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> pointsWithAngles = new ArrayList<>();\\n        int pointsOnLocation = 0;\\n        for (int i = 0; i < points.size(); ++i) {\\n            int x = points.get(i).get(0) - location.get(0);\\n            int y = points.get(i).get(1) - location.get(1);\\n            // they are always visible\\n            if (x == 0 && y == 0) {\\n                pointsOnLocation++;\\n                continue;\\n            }\\n            Double pointAngle = Math.toDegrees(Math.atan2(y, x));\\n            pointsWithAngles.add(pointAngle);\\n            // if angle is negative, add 360 and add it too.\\n            if (pointAngle < 0) {\\n                pointAngle += 360;\\n                pointsWithAngles.add(pointAngle);\\n            }\\n        }\\n\\n        int maxCount = 0, count = 0;\\n        Collections.sort(pointsWithAngles);\\n        int startIndex = 0;\\n        for (int currIndex = 0; currIndex < pointsWithAngles.size();) {\\n            Double startAngle = pointsWithAngles.get(startIndex);\\n            Double endAngle = startAngle + angle;\\n            Double currAngle = pointsWithAngles.get(currIndex);\\n\\n            if (currAngle <= endAngle) {\\n                count ++;\\n                ++currIndex;\\n                maxCount = Math.max(count, maxCount);\\n            } else {\\n                count--;\\n                ++startIndex;\\n            }\\n        }\\n        return maxCount + pointsOnLocation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059475,
                "title": "c-use-taninverse-radian-to-degree-sliding-window",
                "content": "```\\n/* \\n    Time: O(nlogn)\\n    Space: O(n)\\n    Tag: Maths, Geometry (tan inverse and radian to degree conversion), Sorting, Sliding Window\\n    Difficulty: H\\n*/\\n#define PI 3.14159\\n\\nclass Solution {\\n    vector<double> angles;\\n\\n    int findAngles(vector<vector<int>> points, vector<int> loc) {\\n        int x, y;\\n        double angleInRad;\\n        int samePoints = 0;\\n        for (auto &v : points) {\\n            x = v[0] - loc[0];\\n            y = v[1] - loc[1];\\n            if (x == 0 && y == 0) {\\n                samePoints++;\\n            } else {\\n                angles.push_back(atan2(y, x) * 180 / PI);\\n                if (angles.back() < 0) angles.back() = 360 + angles.back();\\n            }\\n        }\\n        return samePoints;\\n    }\\n\\npublic:\\n    int visiblePoints(vector<vector<int>> &points, int angle, vector<int> &location) {\\n        int n = points.size();\\n        angles.reserve(2*n);\\n        int res = findAngles(points, location);\\n        sort(angles.begin(), angles.end());\\n        int size=angles.size();\\n        for(int i=0;i<size;i++){\\n            angles.push_back(360+angles[i]);\\n        }\\n        int ans = 0;\\n        int start = 0;\\n        for (int i = 0; i < angles.size(); i++) {\\n            while (angles[i] - angles[start] > angle || angles[i]-angles[start]>=360) start++;\\n            ans = max(ans, i - start + 1);\\n        }\\n        return res + ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "String",
                    "Geometry",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\n/* \\n    Time: O(nlogn)\\n    Space: O(n)\\n    Tag: Maths, Geometry (tan inverse and radian to degree conversion), Sorting, Sliding Window\\n    Difficulty: H\\n*/\\n#define PI 3.14159\\n\\nclass Solution {\\n    vector<double> angles;\\n\\n    int findAngles(vector<vector<int>> points, vector<int> loc) {\\n        int x, y;\\n        double angleInRad;\\n        int samePoints = 0;\\n        for (auto &v : points) {\\n            x = v[0] - loc[0];\\n            y = v[1] - loc[1];\\n            if (x == 0 && y == 0) {\\n                samePoints++;\\n            } else {\\n                angles.push_back(atan2(y, x) * 180 / PI);\\n                if (angles.back() < 0) angles.back() = 360 + angles.back();\\n            }\\n        }\\n        return samePoints;\\n    }\\n\\npublic:\\n    int visiblePoints(vector<vector<int>> &points, int angle, vector<int> &location) {\\n        int n = points.size();\\n        angles.reserve(2*n);\\n        int res = findAngles(points, location);\\n        sort(angles.begin(), angles.end());\\n        int size=angles.size();\\n        for(int i=0;i<size;i++){\\n            angles.push_back(360+angles[i]);\\n        }\\n        int ans = 0;\\n        int start = 0;\\n        for (int i = 0; i < angles.size(); i++) {\\n            while (angles[i] - angles[start] > angle || angles[i]-angles[start]>=360) start++;\\n            ans = max(ans, i - start + 1);\\n        }\\n        return res + ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1398751,
                "title": "c-98-on-runtime-and-96-on-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int inplace = 0;\\n        vector<float> angles;\\n        for(int i=0; i<points.size(); i++)\\n        {\\n            if(points[i][0] == location[0] && points[i][1] == location[1]) \\n            {\\n                inplace++;\\n            }\\n            else\\n            {\\n                angles.push_back(calculate(points[i][0], points[i][1], location[0], location[1]));               \\n            }\\n        }\\n        \\n        int n = angles.size();\\n        sort(angles.begin(), angles.end());\\n        angles.insert(angles.end(), angles.begin(), angles.end());\\n        \\n        int ans = 0;\\n        int l = 0, r = 0, cur = 0;\\n        while(l<n && r<2*n)\\n        {\\n            while(l<n && r<2*n)\\n            {\\n                if(diff(angles[r], angles[l]) <= angle)\\n                {\\n                    cur++;\\n                    r++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                \\n                if((r%n)==l)\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            ans = max(ans, cur);\\n            l++;\\n            cur--;\\n        }\\n        \\n        return ans + inplace;\\n    }\\n    \\n    float diff(float angle1, float angle2)\\n    {\\n        return angle1 - angle2 < 0 ? angle1 -angle2 + (float)360.0 : angle1 - angle2;\\n    }\\n    \\n    float calculate(int x1, int y1, int x2, int y2)\\n    {\\n        float angle = atan2(y1 - y2, x1 - x2);\\n        angle = angle * 180 / M_PI;\\n        return angle >= 0.0 ? angle : angle + 360;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int inplace = 0;\\n        vector<float> angles;\\n        for(int i=0; i<points.size(); i++)\\n        {\\n            if(points[i][0] == location[0] && points[i][1] == location[1]) \\n            {\\n                inplace++;\\n            }\\n            else\\n            {\\n                angles.push_back(calculate(points[i][0], points[i][1], location[0], location[1]));               \\n            }\\n        }\\n        \\n        int n = angles.size();\\n        sort(angles.begin(), angles.end());\\n        angles.insert(angles.end(), angles.begin(), angles.end());\\n        \\n        int ans = 0;\\n        int l = 0, r = 0, cur = 0;\\n        while(l<n && r<2*n)\\n        {\\n            while(l<n && r<2*n)\\n            {\\n                if(diff(angles[r], angles[l]) <= angle)\\n                {\\n                    cur++;\\n                    r++;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n                \\n                if((r%n)==l)\\n                {\\n                    break;\\n                }\\n            }\\n            \\n            ans = max(ans, cur);\\n            l++;\\n            cur--;\\n        }\\n        \\n        return ans + inplace;\\n    }\\n    \\n    float diff(float angle1, float angle2)\\n    {\\n        return angle1 - angle2 < 0 ? angle1 -angle2 + (float)360.0 : angle1 - angle2;\\n    }\\n    \\n    float calculate(int x1, int y1, int x2, int y2)\\n    {\\n        float angle = atan2(y1 - y2, x1 - x2);\\n        angle = angle * 180 / M_PI;\\n        return angle >= 0.0 ? angle : angle + 360;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322630,
                "title": "needed-math-and-library-functions-pictures-links-solution-maximum-number-of-visible-points",
                "content": "**MATH**\\n\\nCredits to : ** https://www.mathsisfun.com/sine-cosine-tangent.html [1] ** they did a fantastic job and even added animation you can play.\\n\\nWhat the image below says, **if tan(a) >= (point[y]-location[y]) / (point[x]-location[x]) you can see the  dammit  point**\\n\\nimportant clues from the resource :\\n1. \"The triangle can be large or small and the ratio of sides stays the same\" : focus on the angle not how far the point is\\n2. \"calculator\" image : use your Math library functions : https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html , maybe most helpful but not known is `double atan2(double y, double x)` which returns you angle when you give coordinates relative to origin\\n\\n![image](https://assets.leetcode.com/users/images/dd598615-739d-4ce9-b756-f624e67e0507_1625666176.08665.png)\\n\\n\\n**SOLUTION**\\n\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n     \\n        int x=0,y=1; // set the coordinate indexes to make it easier to follow\\n        \\n        int alreadyAtLocation = 0;\\n        List<Double> pointAngles = new ArrayList<>();\\n        for(List<Integer> point : points) {    \\n            if(point.get(x).equals(location.get(x)) && point.get(y).equals(location.get(y))) {\\n                 alreadyAtLocation++;\\n             } else {\\n                // tangent to angle : https://stackoverflow.com/a/41085980/2815227\\n                double pointAngle = Math.toDegrees(Math.atan2( point.get(y) - location.get(y),\\n                                                               point.get(x) - location.get(x)));\\n                pointAngles.add(pointAngle);\\n                if(pointAngle <= 0)\\n                    pointAngles.add(pointAngle+360.0); //this is due to angles under x axis\\n            }\\n        }\\n        \\n        // after now on it is no geometry, just sliding window\\n        // check maximum number of different angles in a range of \"angle\"\\n        \\n        Collections.sort(pointAngles); // move the close points (per angle) together  \\n        int left=0, right = 0, maxPoints = 0;\\n        while(right < pointAngles.size() && maxPoints < pointAngles.size()-left) {\\n            if(pointAngles.get(right)-pointAngles.get(left) <= angle ) {\\n                maxPoints = Math.max(right-left+1,maxPoints);\\n                right++;\\n            } else {\\n                left++; \\n            }\\n        }\\n        \\n        return maxPoints+alreadyAtLocation; \\n    }\\n}\\n```\\n\\n\\n**References**\\n[1] Pierce, Rod,  2018, \\'Sine, Cosine, Tangent\\', Math Is Fun, Available at: <http://www.mathsisfun.com/sine-cosine-tangent.html>. [Accessed 7 Jul 2021]",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n     \\n        int x=0,y=1; // set the coordinate indexes to make it easier to follow\\n        \\n        int alreadyAtLocation = 0;\\n        List<Double> pointAngles = new ArrayList<>();\\n        for(List<Integer> point : points) {    \\n            if(point.get(x).equals(location.get(x)) && point.get(y).equals(location.get(y))) {\\n                 alreadyAtLocation++;\\n             } else {\\n                // tangent to angle : https://stackoverflow.com/a/41085980/2815227\\n                double pointAngle = Math.toDegrees(Math.atan2( point.get(y) - location.get(y),\\n                                                               point.get(x) - location.get(x)));\\n                pointAngles.add(pointAngle);\\n                if(pointAngle <= 0)\\n                    pointAngles.add(pointAngle+360.0); //this is due to angles under x axis\\n            }\\n        }\\n        \\n        // after now on it is no geometry, just sliding window\\n        // check maximum number of different angles in a range of \"angle\"\\n        \\n        Collections.sort(pointAngles); // move the close points (per angle) together  \\n        int left=0, right = 0, maxPoints = 0;\\n        while(right < pointAngles.size() && maxPoints < pointAngles.size()-left) {\\n            if(pointAngles.get(right)-pointAngles.get(left) <= angle ) {\\n                maxPoints = Math.max(right-left+1,maxPoints);\\n                right++;\\n            } else {\\n                left++; \\n            }\\n        }\\n        \\n        return maxPoints+alreadyAtLocation; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321057,
                "title": "java-solution-sort-sliding-window",
                "content": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        // only the angle between point and origin matters, the distance doesn\\'t matter\\n        List<Double> angles = new ArrayList<>(); \\n        int atOrigin = 0;\\n        for (List<Integer> p : points) {\\n            int dx = p.get(0) - location.get(0);\\n            int dy = p.get(1) - location.get(1);\\n            if (dx == 0 && dy == 0) { // edge case of same point\\n                atOrigin++;\\n                continue;\\n            } \\n            angles.add(Math.atan2(dy, dx) * (180 / Math.PI));\\n        }\\n        Collections.sort(angles);\\n        List<Double> tmp = new ArrayList<>(angles);\\n        for (double d : angles) {\\n            tmp.add(d + 360); // concatenate to handle edge case\\n        }\\n        int res = atOrigin;\\n        int j = 0;\\n        for (int i = 0; i < tmp.size(); i++) { // sliding window with two pointers\\n            while (j < tmp.size()) {\\n                if (tmp.get(j) - tmp.get(i) <= angle) {\\n                    j++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            res = Math.max(res, atOrigin + j - i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        // only the angle between point and origin matters, the distance doesn\\'t matter\\n        List<Double> angles = new ArrayList<>(); \\n        int atOrigin = 0;\\n        for (List<Integer> p : points) {\\n            int dx = p.get(0) - location.get(0);\\n            int dy = p.get(1) - location.get(1);\\n            if (dx == 0 && dy == 0) { // edge case of same point\\n                atOrigin++;\\n                continue;\\n            } \\n            angles.add(Math.atan2(dy, dx) * (180 / Math.PI));\\n        }\\n        Collections.sort(angles);\\n        List<Double> tmp = new ArrayList<>(angles);\\n        for (double d : angles) {\\n            tmp.add(d + 360); // concatenate to handle edge case\\n        }\\n        int res = atOrigin;\\n        int j = 0;\\n        for (int i = 0; i < tmp.size(); i++) { // sliding window with two pointers\\n            while (j < tmp.size()) {\\n                if (tmp.get(j) - tmp.get(i) <= angle) {\\n                    j++;\\n                } else {\\n                    break;\\n                }\\n            }\\n            res = Math.max(res, atOrigin + j - i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147348,
                "title": "python-sliding-binary-search-beats-100",
                "content": "\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        def points_to_degrees(start, points):\\n            sx,sy = start\\n            l = []\\n            offset = 0\\n            for x,y in points:\\n                if x == sx and y == sy:\\n                    offset +=1\\n                else:\\n                    l.append((math.degrees(math.atan2(y-sy, x-sx))+720)%360)\\n            return offset, l\\n\\n        def solve(degs, angle):\\n            max_count = 0\\n            for i in range(len(degs)):\\n\\t\\t\\t\\t# we dont need to binsearch what we\\'ve seen\\n                if i > 0 and degs[i-1] == degs[i]:continue\\n                end_idx = bisect_right(degs, (degs[i]+angle)%360)\\n\\t\\t\\t\\t# if we have come more than full circle \\n                if end_idx <= i:\\n                    count = len(degs)-i+end_idx\\n                else:\\n                    count = end_idx-i\\n                max_count = max(max_count, count)\\n            return max_count\\n\\n        offset, degs = points_to_degrees(location, points)\\n        return offset+solve(sorted(degs), angle)",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Binary Tree"
                ],
                "code": "\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        def points_to_degrees(start, points):\\n            sx,sy = start\\n            l = []\\n            offset = 0\\n            for x,y in points:\\n                if x == sx and y == sy:\\n                    offset +=1\\n                else:\\n                    l.append((math.degrees(math.atan2(y-sy, x-sx))+720)%360)\\n            return offset, l\\n\\n        def solve(degs, angle):\\n            max_count = 0\\n            for i in range(len(degs)):\\n\\t\\t\\t\\t# we dont need to binsearch what we\\'ve seen\\n                if i > 0 and degs[i-1] == degs[i]:continue\\n                end_idx = bisect_right(degs, (degs[i]+angle)%360)\\n\\t\\t\\t\\t# if we have come more than full circle \\n                if end_idx <= i:\\n                    count = len(degs)-i+end_idx\\n                else:\\n                    count = end_idx-i\\n                max_count = max(max_count, count)\\n            return max_count\\n\\n        offset, degs = points_to_degrees(location, points)\\n        return offset+solve(sorted(degs), angle)",
                "codeTag": "Python3"
            },
            {
                "id": 1131330,
                "title": "python-sliding-window",
                "content": "# Idea\\nWe first find the angles of all points, then we sort all the angles and do a sliding window over them. The points whose angle is `<= angle` are added twice, to simulate the circling behavior.\\n```\\ndef visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        a, b = location\\n        to_360 = lambda angl: 180 + angl * 180 / pi\\n        onpoint = 0\\n        maxvisible = 0\\n        degrees = []\\n        for x, y in points:\\n            if [x, y] == location: \\n                onpoint += 1\\n                continue\\n            deg = to_360(atan2(y - b, x - a))\\n            degrees.append(deg)\\n            if deg <= angle:\\n                degrees.append(deg + 360)\\n        \\n        degrees.sort()\\n        left = 0\\n        for right in range(len(degrees)):\\n            while degrees[right] - degrees[left] > angle:\\n                left += 1\\n            maxvisible = max(maxvisible, right - left + 1)\\n            \\n        return maxvisible + onpoint\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        a, b = location\\n        to_360 = lambda angl: 180 + angl * 180 / pi\\n        onpoint = 0\\n        maxvisible = 0\\n        degrees = []\\n        for x, y in points:\\n            if [x, y] == location: \\n                onpoint += 1\\n                continue\\n            deg = to_360(atan2(y - b, x - a))\\n            degrees.append(deg)\\n            if deg <= angle:\\n                degrees.append(deg + 360)\\n        \\n        degrees.sort()\\n        left = 0\\n        for right in range(len(degrees)):\\n            while degrees[right] - degrees[left] > angle:\\n                left += 1\\n            maxvisible = max(maxvisible, right - left + 1)\\n            \\n        return maxvisible + onpoint\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1116323,
                "title": "python-trignometry-sort-sliding-window",
                "content": "```\\nimport math\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int: \\n        angles = [ ]\\n        maxcount = 0\\n        always_visible = 0\\n        x1, y1 = location\\n        for x2, y2 in points:\\n            # we always need to include this point, irrespective of the angle\\n            if x1== x2 and y2 == y1:\\n                always_visible +=1\\n            else:\\n                ang_rad = math.atan2((y2-y1),(x2-x1))  \\n                angles.append(math.degrees(ang_rad))\\n                # create a continuously increasing sequence by\\n                #converting -ve angles to +ve by adding 360\\n                if angles[-1] < 0:\\n                    angles.append(angles[-1] + 360)\\n        angles.sort()\\n        left, right = 0,0\\n        #sliding window\\n        while right < len(angles):\\n            while (angles[right] - angles[left]) > angle:\\n                left += 1\\n                #print (\"L\",left,right)\\n            maxcount  = max (maxcount, right -left +1)\\n            right +=1\\n        return maxcount + always_visible\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int: \\n        angles = [ ]\\n        maxcount = 0\\n        always_visible = 0\\n        x1, y1 = location\\n        for x2, y2 in points:\\n            # we always need to include this point, irrespective of the angle\\n            if x1== x2 and y2 == y1:\\n                always_visible +=1\\n            else:\\n                ang_rad = math.atan2((y2-y1),(x2-x1))  \\n                angles.append(math.degrees(ang_rad))\\n                # create a continuously increasing sequence by\\n                #converting -ve angles to +ve by adding 360\\n                if angles[-1] < 0:\\n                    angles.append(angles[-1] + 360)\\n        angles.sort()\\n        left, right = 0,0\\n        #sliding window\\n        while right < len(angles):\\n            while (angles[right] - angles[left]) > angle:\\n                left += 1\\n                #print (\"L\",left,right)\\n            maxcount  = max (maxcount, right -left +1)\\n            right +=1\\n        return maxcount + always_visible\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1112958,
                "title": "c-cleaner-code",
                "content": "Same idea as in the other solutions, just cleaner code.\\n```\\n  int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n    vector<double> angles;\\n    int numOnSameLocation = 0;\\n    for (const auto& p : points) {\\n      if (p == location) {\\n        ++numOnSameLocation;\\n        continue;\\n      }\\n      angles.push_back(estimateAngle(location, p));\\n    }\\n\\n    sort(angles.begin(), angles.end());\\n    angles.resize(angles.size() * 2);\\n    transform(angles.begin(), angles.begin() + angles.size() / 2,\\n                              angles.begin() + angles.size() / 2,\\n              [](double a){ return a + 360; });\\n    return numOnSameLocation + maxPointsWithinFOV(angles, angle);\\n  }\\n\\n  double estimateAngle(const vector<int>& origin, const vector<int>& point) {\\n    int x = point[0] - origin[0];\\n    int y = point[1] - origin[1];\\n    double at = atan2(y, x);\\n    if (at < 0)\\n      at += 2 * M_PI;\\n    return at * 180 / M_PI;\\n  }\\n\\n  int maxPointsWithinFOV(const vector<double>& angles, double fov) {\\n    int maxWithinFOV = 0;\\n    \\n    size_t left = 0;\\n    for (size_t right = 0; right < angles.size(); ++right) {\\n      while (angles[right] - angles[left] > fov)\\n        ++left;\\n      maxWithinFOV = max(maxWithinFOV, static_cast<int>(right - left + 1));\\n    }\\n\\n    return maxWithinFOV;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n    vector<double> angles;\\n    int numOnSameLocation = 0;\\n    for (const auto& p : points) {\\n      if (p == location) {\\n        ++numOnSameLocation;\\n        continue;\\n      }\\n      angles.push_back(estimateAngle(location, p));\\n    }\\n\\n    sort(angles.begin(), angles.end());\\n    angles.resize(angles.size() * 2);\\n    transform(angles.begin(), angles.begin() + angles.size() / 2,\\n                              angles.begin() + angles.size() / 2,\\n              [](double a){ return a + 360; });\\n    return numOnSameLocation + maxPointsWithinFOV(angles, angle);\\n  }\\n\\n  double estimateAngle(const vector<int>& origin, const vector<int>& point) {\\n    int x = point[0] - origin[0];\\n    int y = point[1] - origin[1];\\n    double at = atan2(y, x);\\n    if (at < 0)\\n      at += 2 * M_PI;\\n    return at * 180 / M_PI;\\n  }\\n\\n  int maxPointsWithinFOV(const vector<double>& angles, double fov) {\\n    int maxWithinFOV = 0;\\n    \\n    size_t left = 0;\\n    for (size_t right = 0; right < angles.size(); ++right) {\\n      while (angles[right] - angles[left] > fov)\\n        ++left;\\n      maxWithinFOV = max(maxWithinFOV, static_cast<int>(right - left + 1));\\n    }\\n\\n    return maxWithinFOV;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 996194,
                "title": "java-circular-sliding-window-with-explanation",
                "content": "The idea is to convert all points into an array of angles to the original location, and perform sliding window on the circular array to find the one maximum points.\\n\\nThe tricky part is to handle the sliding window on the circular array, I see some post doing this by adding another set of 360 degree and make it from 0-720. my way of doing this is little bit complicated by judging if the second point is out of the array and add 360 to it.  \\n\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<Double>();\\n        int count = 0;\\n        \\n        for(List<Integer> point:points){\\n            double y = (double)(point.get(1)-location.get(1));\\n            double x = (double)(point.get(0)-location.get(0));\\n            if(x==0&&y==0){\\n                count++;\\n                continue;\\n            }\\n            double thisAngle = 180*Math.atan(y/x)/Math.PI;\\n            if(x<0) thisAngle = 180.0 + thisAngle;\\n            else if(y<0) thisAngle = 360.0 + thisAngle;\\n            angles.add(thisAngle);  \\n        }\\n\\n        \\n        Collections.sort(angles);\\n        //System.out.println(Arrays.toString(angles.toArray()));\\n        \\n        int max=0, start=0,end=0, n=angles.size();\\n        double window=0.0;\\n        \\n        // circular sliding window\\n        while(start<n){\\n            //end = start;\\n            while((end>=n?angles.get(end%n)+360:angles.get(end))-angles.get(start)<=angle){\\n                end++;\\n            }\\n            if(end>start){\\n                max = Math.max(end-start,max);\\n            }else{\\n                max = Math.max(end+n-start-1,max);\\n            }\\n            \\n            start++;\\n        }\\n        \\n        return max+count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<Double>();\\n        int count = 0;\\n        \\n        for(List<Integer> point:points){\\n            double y = (double)(point.get(1)-location.get(1));\\n            double x = (double)(point.get(0)-location.get(0));\\n            if(x==0&&y==0){\\n                count++;\\n                continue;\\n            }\\n            double thisAngle = 180*Math.atan(y/x)/Math.PI;\\n            if(x<0) thisAngle = 180.0 + thisAngle;\\n            else if(y<0) thisAngle = 360.0 + thisAngle;\\n            angles.add(thisAngle);  \\n        }\\n\\n        \\n        Collections.sort(angles);\\n        //System.out.println(Arrays.toString(angles.toArray()));\\n        \\n        int max=0, start=0,end=0, n=angles.size();\\n        double window=0.0;\\n        \\n        // circular sliding window\\n        while(start<n){\\n            //end = start;\\n            while((end>=n?angles.get(end%n)+360:angles.get(end))-angles.get(start)<=angle){\\n                end++;\\n            }\\n            if(end>start){\\n                max = Math.max(end-start,max);\\n            }else{\\n                max = Math.max(end+n-start-1,max);\\n            }\\n            \\n            start++;\\n        }\\n        \\n        return max+count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931572,
                "title": "straightforward-java-solution-sort-and-sliding-window",
                "content": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int atOrigin = 0;\\n        List<Double> list = new ArrayList<>();\\n        for (List<Integer> point : points) {\\n            if (point.get(0) == location.get(0) && point.get(1) == location.get(1)) {\\n                atOrigin++;\\n            } else {\\n                list.add(Math.atan2(point.get(1) - location.get(1), point.get(0) - location.get(0)));\\n            }\\n        }\\n        Collections.sort(list);\\n        int n = list.size();\\n        for (int i = 0; i < n; i++) {\\n            list.add(list.get(i) + 2 * Math.PI);\\n        }\\n        int ans = 0;\\n        double fov = angle * Math.PI / 180;\\n        int l = 0;\\n        for (int r = 0; r < list.size(); r++) {\\n            while (list.get(r) - list.get(l) > fov) {\\n                l++;\\n            }\\n            ans = Math.max(ans, r - l + 1);\\n        }\\n        return ans + atOrigin;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int atOrigin = 0;\\n        List<Double> list = new ArrayList<>();\\n        for (List<Integer> point : points) {\\n            if (point.get(0) == location.get(0) && point.get(1) == location.get(1)) {\\n                atOrigin++;\\n            } else {\\n                list.add(Math.atan2(point.get(1) - location.get(1), point.get(0) - location.get(0)));\\n            }\\n        }\\n        Collections.sort(list);\\n        int n = list.size();\\n        for (int i = 0; i < n; i++) {\\n            list.add(list.get(i) + 2 * Math.PI);\\n        }\\n        int ans = 0;\\n        double fov = angle * Math.PI / 180;\\n        int l = 0;\\n        for (int r = 0; r < list.size(); r++) {\\n            while (list.get(r) - list.get(l) > fov) {\\n                l++;\\n            }\\n            ans = Math.max(ans, r - l + 1);\\n        }\\n        return ans + atOrigin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878193,
                "title": "c-o-nlogn-cyclical-sliding-window",
                "content": "Steps: \\n1. Calculate the angles between the vector [location,points[i]] and Ox and insert them in a vector.\\n2. Sort the vector\\n3. Caculate maximum sliding window [current angle - angle, current angle]. I used a queue to retain all the elements in the window, but two indices can be used insted.\\n4. Be aware that the sliding window can be cyclical. Ex. angle = 90, the angles 340, 345, 355, 0, 15, 70 belongs to a sliding window.\\n5. The points at the same coordinates with the location can be included in the result since can be included in any sliding window.\\nCode:\\n```\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> v;\\n        int same = 0;\\n        for (int i = 0; i < points.size(); i++) {\\n            if (points[i][1] == location[1] && points[i][0] == location[0]) {\\n                same++;\\n                continue;\\n            }\\n            int y = points[i][1] - location[1];\\n            int x = points[i][0] - location[0];\\n            \\n            double theta_rad = atan2((double)y, (double)x);\\n            double theta_deg = (theta_rad/M_PI*180) + (theta_rad > 0 ? 0 : 360);\\n            v.push_back((theta_deg == 360 ? 0 : theta_deg));\\n            \\n        }\\n        sort(v.begin(), v.end());\\n        \\n        queue<double>q;\\n        int r = 0;\\n        //calculate sliding window from 0, 360\\n        for (int i = 0; i < v.size(); i++) {\\n            double c = v[i];\\n            while (q.size() > 0 && c - q.front() > angle)\\n                q.pop();\\n            q.push(c);\\n            int h = q.size();\\n            r = max(r, h );\\n        }\\n        int kk = 0;\\n        //calculate cyclical part of sliding window\\n        for (int i = 0; i < v.size(); i++) {\\n            double c = v[i];\\n            if (c > angle) \\n                break;\\n            int j = kk;\\n            for (j = kk; j < v.size() && v[j] < 360 - (angle-c); j++);\\n            kk = j;\\n            if (kk >= n) break;\\n            r = max(r, i+1+(n-kk));\\n        }\\n        return r + same;\\n    }\\n```\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> v;\\n        int same = 0;\\n        for (int i = 0; i < points.size(); i++) {\\n            if (points[i][1] == location[1] && points[i][0] == location[0]) {\\n                same++;\\n                continue;\\n            }\\n            int y = points[i][1] - location[1];\\n            int x = points[i][0] - location[0];\\n            \\n            double theta_rad = atan2((double)y, (double)x);\\n            double theta_deg = (theta_rad/M_PI*180) + (theta_rad > 0 ? 0 : 360);\\n            v.push_back((theta_deg == 360 ? 0 : theta_deg));\\n            \\n        }\\n        sort(v.begin(), v.end());\\n        \\n        queue<double>q;\\n        int r = 0;\\n        //calculate sliding window from 0, 360\\n        for (int i = 0; i < v.size(); i++) {\\n            double c = v[i];\\n            while (q.size() > 0 && c - q.front() > angle)\\n                q.pop();\\n            q.push(c);\\n            int h = q.size();\\n            r = max(r, h );\\n        }\\n        int kk = 0;\\n        //calculate cyclical part of sliding window\\n        for (int i = 0; i < v.size(); i++) {\\n            double c = v[i];\\n            if (c > angle) \\n                break;\\n            int j = kk;\\n            for (j = kk; j < v.size() && v[j] < 360 - (angle-c); j++);\\n            kk = j;\\n            if (kk >= n) break;\\n            r = max(r, i+1+(n-kk));\\n        }\\n        return r + same;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878055,
                "title": "java-use-math-api",
                "content": "```\\n    public int visiblePoints(List<List<Integer>> ps, int a, List<Integer> l) {\\n        int same = 0, res = 0;\\n        List<Double> as = new ArrayList<>();\\n        for (List<Integer> p : ps) {\\n            int dy = p.get(1) - l.get(1), dx = p.get(0) - l.get(0);\\n            if (dy == 0 && dx == 0) {\\n                same++; // same point with location l;\\n                continue;\\n            }\\n            double agl = Math.atan2(dy, dx) * (180 / Math.PI);\\n            as.add(agl);\\n            as.add(agl + 360); // get rid of negative;\\n        }\\n        Collections.sort(as);\\n        for (int i = 0, j = 0; i < as.size(); i++) {\\n            while(as.get(i) - as.get(j) > a) j++;\\n            res = Math.max(res, i - j + 1);\\n        }\\n        return res + same;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int visiblePoints(List<List<Integer>> ps, int a, List<Integer> l) {\\n        int same = 0, res = 0;\\n        List<Double> as = new ArrayList<>();\\n        for (List<Integer> p : ps) {\\n            int dy = p.get(1) - l.get(1), dx = p.get(0) - l.get(0);\\n            if (dy == 0 && dx == 0) {\\n                same++; // same point with location l;\\n                continue;\\n            }\\n            double agl = Math.atan2(dy, dx) * (180 / Math.PI);\\n            as.add(agl);\\n            as.add(agl + 360); // get rid of negative;\\n        }\\n        Collections.sort(as);\\n        for (int i = 0, j = 0; i < as.size(); i++) {\\n            while(as.get(i) - as.get(j) > a) j++;\\n            res = Math.max(res, i - j + 1);\\n        }\\n        return res + same;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877707,
                "title": "java-prefix-sum-sliding-window",
                "content": "* Find each angle between the points and location.\\n* Use prefix sum to find the max interval.\\n* Special Case is if the point is on top of the location. We count this separately because all rotations can see these points.\\n\\n**Prefix Sum**\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        //strategy: find angle & prefix sum\\n        int locX = location.get(0);\\n        int locY = location.get(1);\\n        int onTop = 0;\\n        TreeMap<Double, Integer> map = new TreeMap<>();\\n        //find all the angles between the different points and the location\\n        for (List<Integer> p : points) {\\n            //find how many points are on top of location\\n            //problem said we can see these points regardless of rotation\\n            if (p.get(0) == locX && p.get(1) == locY) {\\n                onTop++;\\n                continue;\\n            }\\n            //calculate our angle\\n            double a = (Math.atan2(p.get(1) - locY, p.get(0) - locX) * 180 / Math.PI + 360) % 360;\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        } \\n        //starting from 0 degrees on Cartesian plane & CCW\\n        //prefix sum: including means we include up to the angle & not including means we don\\'t include up to the angle\\n        TreeMap<Double, Integer> including = new TreeMap<>();\\n        TreeMap<Double, Integer> notIncluding = new TreeMap<>();\\n        int count = 0;\\n        for (Double key : map.keySet()) {\\n            notIncluding.put(key, count);\\n            count += map.get(key);\\n            including.put(key, count);\\n        }\\n        //do it a second time so we can include angles greater than 360 in case our interval stretches past 360\\n        //example would be starting at 270 and the angle is 170\\n        for (Double key : map.keySet()) {\\n            notIncluding.put(key + 360.0, count);\\n            count += map.get(key);\\n            including.put(key + 360.0, count);\\n        }\\n        //prefix sum and find max interval\\n        int max = 0;\\n        for (List<Integer> p : points) {\\n            //find angle\\n            double a = (Math.atan2(p.get(1) - locY, p.get(0) - locX) * 180 / Math.PI + 360) % 360;\\n            //can only do floor because it can\\'t go past the viewing angle\\n            Double endingAngle = including.floorKey(a + angle);\\n            if (endingAngle != null) {\\n                //find the largest interval from not including angle a to including ending angle\\n                max = Math.max(max, including.get(endingAngle) - notIncluding.get(a));\\n            }\\n        }\\n        //max interval + points on top of location\\n        return max + onTop;\\n    }\\n}\\n```\\n**Sliding Window**\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        //strategy: find angle & prefix sum\\n        int onTop = 0;\\n        int locX = location.get(0);\\n        int locY = location.get(1);\\n        List<Double> angles = new ArrayList<>();\\n        //find all the angles between the different points and the location\\n        for (List<Integer> p : points) {\\n            //find how many points are on top of location\\n            //problem said we can see these points regardless of rotation\\n            if (p.get(0) == locX && p.get(1) == locY) {\\n                onTop++;\\n                continue;\\n            }\\n            //calculate our angle\\n            double a = (Math.atan2(p.get(1) - locY, p.get(0) - locX) * 180 / Math.PI + 360) % 360;\\n            angles.add(a);\\n            angles.add(a + 360.0);\\n        } \\n        //sliding window\\n        Collections.sort(angles);\\n        int max = 0;\\n        Queue<Double> q = new LinkedList<>();\\n        for (Double a : angles) {\\n            q.add(a);\\n            while (a > q.peek() + angle) {\\n                q.poll();\\n            }\\n            max = Math.max(max, q.size());\\n        }\\n        //max interval + points on top of location\\n        return max + onTop;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        //strategy: find angle & prefix sum\\n        int locX = location.get(0);\\n        int locY = location.get(1);\\n        int onTop = 0;\\n        TreeMap<Double, Integer> map = new TreeMap<>();\\n        //find all the angles between the different points and the location\\n        for (List<Integer> p : points) {\\n            //find how many points are on top of location\\n            //problem said we can see these points regardless of rotation\\n            if (p.get(0) == locX && p.get(1) == locY) {\\n                onTop++;\\n                continue;\\n            }\\n            //calculate our angle\\n            double a = (Math.atan2(p.get(1) - locY, p.get(0) - locX) * 180 / Math.PI + 360) % 360;\\n            map.put(a, map.getOrDefault(a, 0) + 1);\\n        } \\n        //starting from 0 degrees on Cartesian plane & CCW\\n        //prefix sum: including means we include up to the angle & not including means we don\\'t include up to the angle\\n        TreeMap<Double, Integer> including = new TreeMap<>();\\n        TreeMap<Double, Integer> notIncluding = new TreeMap<>();\\n        int count = 0;\\n        for (Double key : map.keySet()) {\\n            notIncluding.put(key, count);\\n            count += map.get(key);\\n            including.put(key, count);\\n        }\\n        //do it a second time so we can include angles greater than 360 in case our interval stretches past 360\\n        //example would be starting at 270 and the angle is 170\\n        for (Double key : map.keySet()) {\\n            notIncluding.put(key + 360.0, count);\\n            count += map.get(key);\\n            including.put(key + 360.0, count);\\n        }\\n        //prefix sum and find max interval\\n        int max = 0;\\n        for (List<Integer> p : points) {\\n            //find angle\\n            double a = (Math.atan2(p.get(1) - locY, p.get(0) - locX) * 180 / Math.PI + 360) % 360;\\n            //can only do floor because it can\\'t go past the viewing angle\\n            Double endingAngle = including.floorKey(a + angle);\\n            if (endingAngle != null) {\\n                //find the largest interval from not including angle a to including ending angle\\n                max = Math.max(max, including.get(endingAngle) - notIncluding.get(a));\\n            }\\n        }\\n        //max interval + points on top of location\\n        return max + onTop;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888784,
                "title": "99-fast-c-solution-using-conversions-to-angles-then-begin-end-sector-sweeping",
                "content": "# Intuition\\nAs with other solutions, points are converted to angles using `atan2`, the angles are sorted, and then we sweep across the array tracking the starting and ending points.\\n\\n# Approach\\nPoints are converted to angles using `atan2`, with any points right at the camera tracked separately and added in later. It then sorts them, then marches `i` and `j` (which indicate the inclusive start and exclusive end of the current circular sector) across the array. \\n\\nAt all points, I have `j > i`, but I allow `j` to exceed the array size. When it does so, the array access using `j` is wrapped around to the other side, and the retrieved angle is increased by 360 degrees, allowing the `j` angle to remain larger than the `i` angle. This makes the counting easy (just `j - i`) as well as the angle comparison (just `thetas_j <= thetas[i] + angle`).\\n\\nAs an optimization, I use `upper_bound()` (binary search) to find the initial value of `j`, which is faster for large angles.\\n\\n# Complexity\\n- Time complexity:\\nBoth the point-to-angle conversion and the `while` loop make just one pass through the array in linear time, so time is dominated by the sort ($$O(n \\\\log n)$$).\\n\\n- Space complexity:\\nLinear ($$O(n)$$) space is needed to hold the temporary `thetas` array. This could be avoided by sorting the points array in place by their angles, but this would require recomputing the angles many times which is not really worth it.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> thetas;\\n        thetas.reserve(points.size());\\n        int count_offset = 0;\\n        for (const vector<int>& p : points) {\\n            if (p[0] == location[0] && p[1] == location[1]) {\\n                count_offset++;\\n            } else {\\n                double theta = atan2(p[1] - location[1], p[0] - location[0]);\\n                thetas.push_back(theta * 360.0 / (2.0*M_PI));\\n            }\\n        }\\n\\n        sort(thetas.begin(), thetas.end());\\n\\n        int i=0;\\n        int j = upper_bound(thetas.begin(), thetas.end(), thetas[i] + angle) - thetas.begin();\\n        int max_count = 0;\\n        while (true) {\\n            max_count = max(max_count, j - i);\\n            i++;\\n            if (i >= (int)thetas.size()) {\\n                break;\\n            }\\n\\n            double thetas_j;\\n            while (thetas_j = (j < (int)thetas.size()) ? thetas[j] : 360.0 + thetas[j - thetas.size()],\\n                   thetas_j <= thetas[i] + angle) {\\n                j++;\\n            }\\n        }\\n        return max_count + count_offset;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<double> thetas;\\n        thetas.reserve(points.size());\\n        int count_offset = 0;\\n        for (const vector<int>& p : points) {\\n            if (p[0] == location[0] && p[1] == location[1]) {\\n                count_offset++;\\n            } else {\\n                double theta = atan2(p[1] - location[1], p[0] - location[0]);\\n                thetas.push_back(theta * 360.0 / (2.0*M_PI));\\n            }\\n        }\\n\\n        sort(thetas.begin(), thetas.end());\\n\\n        int i=0;\\n        int j = upper_bound(thetas.begin(), thetas.end(), thetas[i] + angle) - thetas.begin();\\n        int max_count = 0;\\n        while (true) {\\n            max_count = max(max_count, j - i);\\n            i++;\\n            if (i >= (int)thetas.size()) {\\n                break;\\n            }\\n\\n            double thetas_j;\\n            while (thetas_j = (j < (int)thetas.size()) ? thetas[j] : 360.0 + thetas[j - thetas.size()],\\n                   thetas_j <= thetas[i] + angle) {\\n                j++;\\n            }\\n        }\\n        return max_count + count_offset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690919,
                "title": "golang-sliding-window",
                "content": "```\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n    res := 0\\n    \\n    degrees := []float64{}\\n    for _, point := range points {\\n        xDiff := point[0] - location[0]\\n        yDiff := point[1] - location[1]\\n        \\n        // if point is at given location, it is always visible\\n        if xDiff == 0 && yDiff == 0 {\\n            res++\\n            continue\\n        }\\n        \\n        // Add all degree of the remaining points\\n        degrees = append(degrees, getAngle(xDiff, yDiff))\\n    }\\n    \\n    sort.Float64s(degrees)\\n    \\n    // Add Just same points over again with adding 360 to form circle, so we can turn and see\\n    l := len(degrees)\\n    for i := 0; i < l; i++ {\\n        degrees = append(degrees, degrees[i]+360)\\n    }\\n    \\n    start := 0\\n    maxPoints := 0   \\n    \\n    // Sliding window\\n    // Get angle range which fits in given angle\\n    // Then increment end to expand window\\n    // And increase start correspondingly\\n    for end := 0; end < len(degrees); end++ {\\n        for degrees[end] - degrees[start] > float64(angle) {\\n            start++\\n        }\\n        maxPoints = max(maxPoints, end-start+1)\\n    }\\n    \\n    return res + maxPoints\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc getAngle(x, y int) float64 {\\n    d := math.Atan2(float64 (y), float64 (x))   // Gives angle in radians\\n    d *= float64(180) / math.Pi                 // Convert to degrees\\n    return d\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n    res := 0\\n    \\n    degrees := []float64{}\\n    for _, point := range points {\\n        xDiff := point[0] - location[0]\\n        yDiff := point[1] - location[1]\\n        \\n        // if point is at given location, it is always visible\\n        if xDiff == 0 && yDiff == 0 {\\n            res++\\n            continue\\n        }\\n        \\n        // Add all degree of the remaining points\\n        degrees = append(degrees, getAngle(xDiff, yDiff))\\n    }\\n    \\n    sort.Float64s(degrees)\\n    \\n    // Add Just same points over again with adding 360 to form circle, so we can turn and see\\n    l := len(degrees)\\n    for i := 0; i < l; i++ {\\n        degrees = append(degrees, degrees[i]+360)\\n    }\\n    \\n    start := 0\\n    maxPoints := 0   \\n    \\n    // Sliding window\\n    // Get angle range which fits in given angle\\n    // Then increment end to expand window\\n    // And increase start correspondingly\\n    for end := 0; end < len(degrees); end++ {\\n        for degrees[end] - degrees[start] > float64(angle) {\\n            start++\\n        }\\n        maxPoints = max(maxPoints, end-start+1)\\n    }\\n    \\n    return res + maxPoints\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc getAngle(x, y int) float64 {\\n    d := math.Atan2(float64 (y), float64 (x))   // Gives angle in radians\\n    d *= float64(180) / math.Pi                 // Convert to degrees\\n    return d\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2238668,
                "title": "java-o-n",
                "content": "Why is this wrong.\\nIsn\\'t this O(360N) ~= O(N)\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int maxPoints = 0;\\n        \\n        for(int d = 0; d < 360; d++){\\n            double lowerSlope = FindSlope(d-angle/2);\\n            double higherSlope = FindSlope(d+angle/2);\\n            double lowerC = location.get(1) - lowerSlope*location.get(0);\\n            double higherC = location.get(1) - higherSlope*location.get(0);\\n            int pointsFound = 0;\\n            for(List<Integer> p: points){\\n                if(aboveLower(lowerSlope, p.get(0), lowerC,  p.get(1)) \\n                   && belowUpper(higherSlope, p.get(0), higherC,  p.get(1))){\\n                    pointsFound++;\\n                }\\n            }\\n            \\n            maxPoints = Math.max(maxPoints, pointsFound);\\n        }\\n        \\n        return maxPoints;\\n        \\n    }\\n    \\n\\t// if point is a,b and equation is y=-1/2x+3 then we inject x=a and compare y and b. If y < b then point is above the line.\\n    private boolean aboveLower(double slope, int x, double c, int y){\\n        return y >= slope*x + c;\\n    }\\n    \\n\\t// if point is a,b and equation is y=-1/2x+3 then we inject x=a and compare y and b. If y > b then point is below the line.\\n    private boolean belowUpper(double slope, int x, double c, int y){\\n        return y <= slope*x + c;\\n    }\\n    \\n    private double FindSlope(int degree){\\n        double deg = Math.toRadians(degree);\\n        return Math.ceil(Math.tan(deg));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int maxPoints = 0;\\n        \\n        for(int d = 0; d < 360; d++){\\n            double lowerSlope = FindSlope(d-angle/2);\\n            double higherSlope = FindSlope(d+angle/2);\\n            double lowerC = location.get(1) - lowerSlope*location.get(0);\\n            double higherC = location.get(1) - higherSlope*location.get(0);\\n            int pointsFound = 0;\\n            for(List<Integer> p: points){\\n                if(aboveLower(lowerSlope, p.get(0), lowerC,  p.get(1)) \\n                   && belowUpper(higherSlope, p.get(0), higherC,  p.get(1))){\\n                    pointsFound++;\\n                }\\n            }\\n            \\n            maxPoints = Math.max(maxPoints, pointsFound);\\n        }\\n        \\n        return maxPoints;\\n        \\n    }\\n    \\n\\t// if point is a,b and equation is y=-1/2x+3 then we inject x=a and compare y and b. If y < b then point is above the line.\\n    private boolean aboveLower(double slope, int x, double c, int y){\\n        return y >= slope*x + c;\\n    }\\n    \\n\\t// if point is a,b and equation is y=-1/2x+3 then we inject x=a and compare y and b. If y > b then point is below the line.\\n    private boolean belowUpper(double slope, int x, double c, int y){\\n        return y <= slope*x + c;\\n    }\\n    \\n    private double FindSlope(int degree){\\n        double deg = Math.toRadians(degree);\\n        return Math.ceil(Math.tan(deg));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226102,
                "title": "java-reflection-track-min-max",
                "content": "### Edge Cases\\nI didn\\'t think to add 360 to the angle to handle the edge cases where it crosses the boundary.\\nI came up with something else - \\n- Reflection: reflect all the points across `x` and `y` axis. Do it 4 times.\\n- Mode Switch: If `angle > 180`, we switch to tracking the minimum of what we can see in `360 - angle`. \\nAnswer would be that substracted from num of points.\\n\\nThis means that when we are doing the sliding window, we have to track the minimum and maximum.\\n\\n### Why aren\\'t 4 reflections enough?\\nBecause when `angle > 270`, it won\\'t be able to cover all the boundaries.\\nOn a sidenote: **who in the world can see 359 degrees???**\\n\\n### Some Details\\n- `Math.atan2()` is such a good function for this problem. My first Accepted submission I computed the degree myself ... saved me 15 lines of code! \\n- Tracking the minimum with sliding window is a bit tricky. We must update the min outside the while loop because there can be cases where there are no points across a huge angle.\\n\\n```Java\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int[][] A = new int[points.size()][2];\\n        for (int i = 0; i < points.size(); i++){\\n            A[i][0]=points.get(i).get(0)-location.get(0);\\n            A[i][1]=points.get(i).get(1)-location.get(1);\\n        }\\n        boolean can = angle <= 180;\\n        angle = Math.min(360-angle, angle); // handling 300 degrees is troublesome, switch to 60 instead.\\n        int extra = 0;\\n        int ans = can? 0 : Integer.MAX_VALUE;\\n        for (int k = 0; k < 4; k++){ // 3 reflections in total \\n            Arrays.sort(A, Comparator.comparingDouble(o -> deg(o)));\\n            Deque<int[]> deque = new ArrayDeque<>();\\n            extra = 0;\\n            for (int i = 0; i < points.size(); i++){\\n                if (A[i][0]==0&&A[i][1]==0){\\n                    extra++;\\n                }else{\\n                    double prev = 0; // prev begins at 0 (IMPORTANT)\\n                    while(!deque.isEmpty() && deg(A[i]) - deg(deque.peekFirst()) > angle){\\n                        prev = deg(deque.pollFirst());\\n                    }\\n                    if (!can && deg(A[i])-prev>=angle){ // update min outside the while loop, not inside.\\n                        ans = Math.min(ans, deque.size());\\n                    }\\n                    deque.offerLast(A[i]);\\n                    if (can){\\n                        ans = Math.max(ans, deque.size());\\n                    }\\n                }\\n            }\\n            for (int i = 0; i < points.size(); i++){ // reflect it 4 times because why not.\\n                A[i][k&1]*=-1;\\n            }\\n        }\\n        return can? ans+extra : points.size()-ans;\\n    }\\n\\n    private double deg(int[] A){\\n        return (Math.toDegrees(Math.atan2(A[1], A[0])) + 360)%360;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int[][] A = new int[points.size()][2];\\n        for (int i = 0; i < points.size(); i++){\\n            A[i][0]=points.get(i).get(0)-location.get(0);\\n            A[i][1]=points.get(i).get(1)-location.get(1);\\n        }\\n        boolean can = angle <= 180;\\n        angle = Math.min(360-angle, angle); // handling 300 degrees is troublesome, switch to 60 instead.\\n        int extra = 0;\\n        int ans = can? 0 : Integer.MAX_VALUE;\\n        for (int k = 0; k < 4; k++){ // 3 reflections in total \\n            Arrays.sort(A, Comparator.comparingDouble(o -> deg(o)));\\n            Deque<int[]> deque = new ArrayDeque<>();\\n            extra = 0;\\n            for (int i = 0; i < points.size(); i++){\\n                if (A[i][0]==0&&A[i][1]==0){\\n                    extra++;\\n                }else{\\n                    double prev = 0; // prev begins at 0 (IMPORTANT)\\n                    while(!deque.isEmpty() && deg(A[i]) - deg(deque.peekFirst()) > angle){\\n                        prev = deg(deque.pollFirst());\\n                    }\\n                    if (!can && deg(A[i])-prev>=angle){ // update min outside the while loop, not inside.\\n                        ans = Math.min(ans, deque.size());\\n                    }\\n                    deque.offerLast(A[i]);\\n                    if (can){\\n                        ans = Math.max(ans, deque.size());\\n                    }\\n                }\\n            }\\n            for (int i = 0; i < points.size(); i++){ // reflect it 4 times because why not.\\n                A[i][k&1]*=-1;\\n            }\\n        }\\n        return can? ans+extra : points.size()-ans;\\n    }\\n\\n    private double deg(int[] A){\\n        return (Math.toDegrees(Math.atan2(A[1], A[0])) + 360)%360;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098285,
                "title": "java-sliding-window-over-sorted-polar-angles-usage-of-math-todegrees-math-atan2-dy-dx",
                "content": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<>();\\n        int answer = 0;\\n        \\n        // find the required polar angle with respect to the location\\n        for (var point : points) {\\n            int dx = point.get(0) - location.get(0);\\n            int dy = point.get(1) - location.get(1);\\n            \\n            if (dx == 0 && dy == 0) { // points at same position as location\\n                answer++;\\n                continue;\\n            }\\n            \\n            angles.add(Math.toDegrees(Math.atan2(dy, dx)));\\n        }\\n        \\n        // Sorting the angles will make sure that the required count is a \\n        // contiguous length of angles\\n        Collections.sort(angles);\\n        \\n        /*\\n            -> Push angles again by adding 360 to handle the case of consecutive points\\n            being after a complete cycle.\\n            -> Example: -345 and 14 (if angle >= 29)\\n        */\\n        int n = angles.size();\\n        for (int i = 0; i < n; ++i) {\\n            angles.add(angles.get(i) + 360);\\n        }\\n        \\n        int start = 0;\\n        int count = 0;\\n        \\n        // Sliding window to find the maximum widow covered by the given angle\\n        for (int end = 0; end < angles.size(); ++end) {\\n            while (angles.get(end) - angles.get(start) > angle) {\\n                start++;\\n            }\\n            \\n            count = Math.max(count, end - start + 1);\\n        }\\n        \\n        // adding the count to the number of overlapping points with the given location\\n        // computed earlier.\\n        answer += count;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angles = new ArrayList<>();\\n        int answer = 0;\\n        \\n        // find the required polar angle with respect to the location\\n        for (var point : points) {\\n            int dx = point.get(0) - location.get(0);\\n            int dy = point.get(1) - location.get(1);\\n            \\n            if (dx == 0 && dy == 0) { // points at same position as location\\n                answer++;\\n                continue;\\n            }\\n            \\n            angles.add(Math.toDegrees(Math.atan2(dy, dx)));\\n        }\\n        \\n        // Sorting the angles will make sure that the required count is a \\n        // contiguous length of angles\\n        Collections.sort(angles);\\n        \\n        /*\\n            -> Push angles again by adding 360 to handle the case of consecutive points\\n            being after a complete cycle.\\n            -> Example: -345 and 14 (if angle >= 29)\\n        */\\n        int n = angles.size();\\n        for (int i = 0; i < n; ++i) {\\n            angles.add(angles.get(i) + 360);\\n        }\\n        \\n        int start = 0;\\n        int count = 0;\\n        \\n        // Sliding window to find the maximum widow covered by the given angle\\n        for (int end = 0; end < angles.size(); ++end) {\\n            while (angles.get(end) - angles.get(start) > angle) {\\n                start++;\\n            }\\n            \\n            count = Math.max(count, end - start + 1);\\n        }\\n        \\n        // adding the count to the number of overlapping points with the given location\\n        // computed earlier.\\n        answer += count;\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2084973,
                "title": "c-lazy-method-to-avoid-circular-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    #define to_rad 0.0174532925199432957692369\\n    #define TWOPI 6.28318530717958647692528676655    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        for (auto &i: points){\\n            i[0] -= location[0];\\n            i[1] -= location[1];\\n        }\\n        //number of points with undefined angle\\n        int offset = 0;\\n        vector<float> angles;\\n        float view = (angle * to_rad) + 0.0000000001; \\n        for (auto i: points){\\n            if (i[0] == 0 && i[1] == 0){\\n                ++offset;\\n            }\\n            else {\\n                angles.push_back(i[1] >= 0 ? acos(i[0]/(sqrt(i[0] * i[0] + i[1] * i[1]))) : TWOPI - acos(i[0]/(sqrt(i[0] * i[0] + i[1] * i[1]))));\\n            }\\n        }\\n        int n = angles.size(), N = 2*n;\\n        sort(angles.begin(),angles.end());\\n        //easy way of not dealing with circular sliding window, just append the entire vector over itself adding 2 * pi to the second half\\n        for (int i = 0; i < n; ++i) angles.push_back(angles[i] + TWOPI);\\n        \\n        int output = 0;\\n        for (int i = 0, j = 0; i < n; ++i){\\n            while (angles[j] <= angles[i] + view ){\\n                ++j;\\n            }\\n            output = max(output,j - i); \\n        }\\n        return output + offset;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define to_rad 0.0174532925199432957692369\\n    #define TWOPI 6.28318530717958647692528676655    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        for (auto &i: points){\\n            i[0] -= location[0];\\n            i[1] -= location[1];\\n        }\\n        //number of points with undefined angle\\n        int offset = 0;\\n        vector<float> angles;\\n        float view = (angle * to_rad) + 0.0000000001; \\n        for (auto i: points){\\n            if (i[0] == 0 && i[1] == 0){\\n                ++offset;\\n            }\\n            else {\\n                angles.push_back(i[1] >= 0 ? acos(i[0]/(sqrt(i[0] * i[0] + i[1] * i[1]))) : TWOPI - acos(i[0]/(sqrt(i[0] * i[0] + i[1] * i[1]))));\\n            }\\n        }\\n        int n = angles.size(), N = 2*n;\\n        sort(angles.begin(),angles.end());\\n        //easy way of not dealing with circular sliding window, just append the entire vector over itself adding 2 * pi to the second half\\n        for (int i = 0; i < n; ++i) angles.push_back(angles[i] + TWOPI);\\n        \\n        int output = 0;\\n        for (int i = 0, j = 0; i < n; ++i){\\n            while (angles[j] <= angles[i] + view ){\\n                ++j;\\n            }\\n            output = max(output,j - i); \\n        }\\n        return output + offset;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029720,
                "title": "java-solution-using-sorted-degree-angles-list-and-sliding-window",
                "content": "1, Transform all pointers to the direction vertexes to the starting point. \\n2, Using arc cosine to get the angle. Note you need to use the sign of pointer.y - origin.y to determine if the pointer is within [0, 180] or (180, 360) to the original pointer.\\n3, sort the pointers angle\\n4, duplicate the pointers angle within [0, scanning_angle]  with  + 360 degree and adding them to sorted angle in order to make sure the scan is actually turnning 360 degree from start to end. \\n5, This code set the start of scanning angle to degree 0 instead of middle of scanning angle starting from 0.\\n\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angulars = new ArrayList<Double>();\\n        int localPointsCount = 0;\\n        \\n        for (List<Integer> p: points) {\\n            if (p.get(0) - location.get(0) == 0 && p.get(1) - location.get(1) == 0) {\\n                localPointsCount++;\\n                continue;\\n            }\\n            double deltaX = (double)(p.get(0) - location.get(0));\\n            double deltaY = (double)(p.get(1) - location.get(1));\\n            double val = deltaX / Math.sqrt(deltaX*deltaX + deltaY*deltaY);\\n            double a = Math.toDegrees(Math.acos(val));\\n            if(location.get(1) <= p.get(1)){\\n                angulars.add(a);\\n            }else {\\n                angulars.add(360.0-a);\\n            }\\n            \\n        }\\n        Collections.sort(angulars);\\n        List<Double> extraAngulars = new ArrayList<Double>();\\n        Queue<Double> queue = new LinkedList<Double>();\\n        int i = 0;\\n        while (i<angulars.size()) {\\n            if (angulars.get(i)<=angle){\\n                queue.add(angulars.get(i));\\n                extraAngulars.add(angulars.get(i)+360.0);\\n                i++;\\n            } else {\\n                break;\\n            }\\n        }\\n        angulars.addAll(extraAngulars);\\n        int maxlength = queue.size();\\n        while (i<angulars.size()){\\n            queue.add(angulars.get(i));\\n            double minimal = angulars.get(i)-angle;\\n            while(queue.peek() - minimal < -0.000001) queue.poll();\\n            maxlength = Math.max(maxlength, queue.size());\\n            i++;\\n        }\\n        return maxlength+localPointsCount;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> angulars = new ArrayList<Double>();\\n        int localPointsCount = 0;\\n        \\n        for (List<Integer> p: points) {\\n            if (p.get(0) - location.get(0) == 0 && p.get(1) - location.get(1) == 0) {\\n                localPointsCount++;\\n                continue;\\n            }\\n            double deltaX = (double)(p.get(0) - location.get(0));\\n            double deltaY = (double)(p.get(1) - location.get(1));\\n            double val = deltaX / Math.sqrt(deltaX*deltaX + deltaY*deltaY);\\n            double a = Math.toDegrees(Math.acos(val));\\n            if(location.get(1) <= p.get(1)){\\n                angulars.add(a);\\n            }else {\\n                angulars.add(360.0-a);\\n            }\\n            \\n        }\\n        Collections.sort(angulars);\\n        List<Double> extraAngulars = new ArrayList<Double>();\\n        Queue<Double> queue = new LinkedList<Double>();\\n        int i = 0;\\n        while (i<angulars.size()) {\\n            if (angulars.get(i)<=angle){\\n                queue.add(angulars.get(i));\\n                extraAngulars.add(angulars.get(i)+360.0);\\n                i++;\\n            } else {\\n                break;\\n            }\\n        }\\n        angulars.addAll(extraAngulars);\\n        int maxlength = queue.size();\\n        while (i<angulars.size()){\\n            queue.add(angulars.get(i));\\n            double minimal = angulars.get(i)-angle;\\n            while(queue.peek() - minimal < -0.000001) queue.poll();\\n            maxlength = Math.max(maxlength, queue.size());\\n            i++;\\n        }\\n        return maxlength+localPointsCount;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989925,
                "title": "100-faster-clean-python-solution",
                "content": "```\\nclass Solution(object):\\n    def visiblePoints(self, points, angle, location):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type angle: int\\n        :type location: List[int]\\n        :rtype: int\\n        \"\"\"\\n        x0,y0 = location\\n\\t\\t# to radians\\n        angle *= pi/180\\n        # transform points to location + filter + transform to polar angle\\n        angles = sorted([atan2(x-x0,y-y0) for x,y in points if x!=x0 or y!=y0])\\n        n = len(angles)\\n        angles += [2*pi+a for a in angles]\\n        l,r = 0,0\\n        maxview=0\\n        while l<n:\\n            while r<2*n and angles[r]-angles[l]<=angle:\\n                r+=1\\n            maxview = max(maxview,r-l)\\n            while l<n and angles[r]-angles[l]>angle:            \\n                l+=1\\n        return maxview + len(points)-n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def visiblePoints(self, points, angle, location):\\n        \"\"\"\\n        :type points: List[List[int]]\\n        :type angle: int\\n        :type location: List[int]\\n        :rtype: int\\n        \"\"\"\\n        x0,y0 = location\\n\\t\\t# to radians\\n        angle *= pi/180\\n        # transform points to location + filter + transform to polar angle\\n        angles = sorted([atan2(x-x0,y-y0) for x,y in points if x!=x0 or y!=y0])\\n        n = len(angles)\\n        angles += [2*pi+a for a in angles]\\n        l,r = 0,0\\n        maxview=0\\n        while l<n:\\n            while r<2*n and angles[r]-angles[l]<=angle:\\n                r+=1\\n            maxview = max(maxview,r-l)\\n            while l<n and angles[r]-angles[l]>angle:            \\n                l+=1\\n        return maxview + len(points)-n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974212,
                "title": "java-simple-sliding-window-with-comments",
                "content": "```\\nclass Solution { \\n    List<Double> angles;\\n    double angle;\\n    double diff;\\n    int ans;\\n    int pointsAtLocation;\\n    \\n    // Get the angle between current location and point in question\\n    private double getAngle(List<Integer> point, List<Integer> location) {\\n        double angle = Math.toDegrees(Math.atan2(point.get(0) - location.get(0), point.get(1) - location.get(1)));\\n        \\n        // If the angle is negative, let\\'s add 360 to keep the angles in range 0 - 359.9...\\n        angle += angle < 0 ? 360 : 0;\\n        return angle;\\n    }\\n    \\n    // Method to get the difference in first and last angles of current window\\n    private double getDiff(int start, int end) {\\n        diff = angles.get(end) - angles.get(start);\\n        if(diff < 0) diff += 360.0;\\n        return diff;\\n    }\\n    \\n    // Initialize \\n    private void initialize() {\\n        angles = new ArrayList<>();\\n        int ans = 0;\\n        int pointsAtLocation = 0;\\n    }\\n    \\n    // Drive method\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        initialize();\\n        \\n        for(List<Integer> point : points) {\\n            // If the point is same as location there is no need to check this\\n            // From problem statement: \"There may be points at your location, and you can always see these points regardless of your rotation.\"\\n            if(point.get(0) == location.get(0) && point.get(1) == location.get(1))\\n                pointsAtLocation++;\\n            else\\n                angles.add(getAngle(point, location));\\n        }\\n        \\n        // Sorting helps us convert this problem into sliding window\\n        Collections.sort(angles);\\n        int n = angles.size();\\n        \\n        // This is where all the magic happens\\n        for(int end = 0, start = 0; start < n; end++) {\\n            // If all of the points are visible, let\\'s terminate! This will avoid start never crossing n and ending up in an infinite loop\\n            if(ans == n) return ans + pointsAtLocation;\\n            \\n            // If the difference in angle of first and last points of window is greater than threshold, we need to shrink the window\\n            while(start < angles.size() && getDiff(start, end % n) > angle) {\\n                start++;\\n            }\\n            ans = Math.max(ans, end - start + 1);\\n        }\\n        \\n        return ans + pointsAtLocation;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution { \\n    List<Double> angles;\\n    double angle;\\n    double diff;\\n    int ans;\\n    int pointsAtLocation;\\n    \\n    // Get the angle between current location and point in question\\n    private double getAngle(List<Integer> point, List<Integer> location) {\\n        double angle = Math.toDegrees(Math.atan2(point.get(0) - location.get(0), point.get(1) - location.get(1)));\\n        \\n        // If the angle is negative, let\\'s add 360 to keep the angles in range 0 - 359.9...\\n        angle += angle < 0 ? 360 : 0;\\n        return angle;\\n    }\\n    \\n    // Method to get the difference in first and last angles of current window\\n    private double getDiff(int start, int end) {\\n        diff = angles.get(end) - angles.get(start);\\n        if(diff < 0) diff += 360.0;\\n        return diff;\\n    }\\n    \\n    // Initialize \\n    private void initialize() {\\n        angles = new ArrayList<>();\\n        int ans = 0;\\n        int pointsAtLocation = 0;\\n    }\\n    \\n    // Drive method\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        initialize();\\n        \\n        for(List<Integer> point : points) {\\n            // If the point is same as location there is no need to check this\\n            // From problem statement: \"There may be points at your location, and you can always see these points regardless of your rotation.\"\\n            if(point.get(0) == location.get(0) && point.get(1) == location.get(1))\\n                pointsAtLocation++;\\n            else\\n                angles.add(getAngle(point, location));\\n        }\\n        \\n        // Sorting helps us convert this problem into sliding window\\n        Collections.sort(angles);\\n        int n = angles.size();\\n        \\n        // This is where all the magic happens\\n        for(int end = 0, start = 0; start < n; end++) {\\n            // If all of the points are visible, let\\'s terminate! This will avoid start never crossing n and ending up in an infinite loop\\n            if(ans == n) return ans + pointsAtLocation;\\n            \\n            // If the difference in angle of first and last points of window is greater than threshold, we need to shrink the window\\n            while(start < angles.size() && getDiff(start, end % n) > angle) {\\n                start++;\\n            }\\n            ans = Math.max(ans, end - start + 1);\\n        }\\n        \\n        return ans + pointsAtLocation;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929891,
                "title": "simple-python-binary-search",
                "content": "```\\nimport numpy as np\\nimport bisect\\n\\ndef get_ang(x, y):\\n    innerp = x\\n    length = np.sqrt(x**2 + y**2)\\n    ang = np.arccos(innerp/length)\\n    if y < 0:\\n        ang = 2*np.pi - ang\\n    return 180 * ang / np.pi\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        if angle >= 360:\\n            return len(points)\\n        cx, cy = location\\n        \\n        rst = 0\\n        ags = []\\n        for x, y in points:\\n            dx, dy = x-cx, y-cy\\n            if dx == 0 and dy == 0:\\n                rst += 1\\n                continue\\n            ang = get_ang(dx, dy)\\n            ags.append(ang)\\n            ags.append(ang+360)\\n        \\n        #print(ags)\\n        ags.sort()\\n        #print(ags)\\n        epsl = 1e-9\\n        to_add = 0\\n        for i, v in enumerate(ags):\\n            tgt = v + angle + epsl\\n            to_add = max(to_add, bisect.bisect_right(ags, tgt) - i)\\n        \\n        return rst + to_add\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nimport numpy as np\\nimport bisect\\n\\ndef get_ang(x, y):\\n    innerp = x\\n    length = np.sqrt(x**2 + y**2)\\n    ang = np.arccos(innerp/length)\\n    if y < 0:\\n        ang = 2*np.pi - ang\\n    return 180 * ang / np.pi\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        if angle >= 360:\\n            return len(points)\\n        cx, cy = location\\n        \\n        rst = 0\\n        ags = []\\n        for x, y in points:\\n            dx, dy = x-cx, y-cy\\n            if dx == 0 and dy == 0:\\n                rst += 1\\n                continue\\n            ang = get_ang(dx, dy)\\n            ags.append(ang)\\n            ags.append(ang+360)\\n        \\n        #print(ags)\\n        ags.sort()\\n        #print(ags)\\n        epsl = 1e-9\\n        to_add = 0\\n        for i, v in enumerate(ags):\\n            tgt = v + angle + epsl\\n            to_add = max(to_add, bisect.bisect_right(ags, tgt) - i)\\n        \\n        return rst + to_add\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890573,
                "title": "python-binary-search-no-way-i-could-do-it-in-an-interview",
                "content": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        \\n        angles = []\\n        add = 0\\n        for p in points:\\n            dy = p[1] - location[1]\\n            dx = p[0] - location[0]\\n            if dx == dy == 0:\\n                add += 1\\n                continue\\n            cur_angle = math.atan2(dy, dx) * 180 / math.pi\\n            angles.append( cur_angle if cur_angle >= 0 else 360 + cur_angle)\\n        \\n        angles.sort()\\n        n = len(angles)\\n        res = 0\\n        for i in range(n):\\n            if angles[i] + angle >= 360:\\n                j  =  bisect_left(angles, angles[i] + angle -360 + 0.0001)\\n                res = max(res,n - i + j )\\n            else:\\n                j = bisect_left(angles, angles[i] + angle + 0.0001)\\n                res = max(res, max(j -i,1))\\n            \\n        return res + add\\n                \\n                \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        \\n        angles = []\\n        add = 0\\n        for p in points:\\n            dy = p[1] - location[1]\\n            dx = p[0] - location[0]\\n            if dx == dy == 0:\\n                add += 1\\n                continue\\n            cur_angle = math.atan2(dy, dx) * 180 / math.pi\\n            angles.append( cur_angle if cur_angle >= 0 else 360 + cur_angle)\\n        \\n        angles.sort()\\n        n = len(angles)\\n        res = 0\\n        for i in range(n):\\n            if angles[i] + angle >= 360:\\n                j  =  bisect_left(angles, angles[i] + angle -360 + 0.0001)\\n                res = max(res,n - i + j )\\n            else:\\n                j = bisect_left(angles, angles[i] + angle + 0.0001)\\n                res = max(res, max(j -i,1))\\n            \\n        return res + add\\n                \\n                \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830512,
                "title": "kotlin-functional-programming",
                "content": "# Steps:\\n**Step 1: Map Points to Angles**\\t (this part we do with functional programming)\\n* center points to origin\\n* filter out points on center/where you stand\\n* use atan2 to get full 360 degres not just 180\\n* sort\\n* append same array with +360 for each element\\n\\n**Step 2: Use sliding window to go over array**\\n* whenever your window is too large for your view, increase left pointer\\n* otherwise increase right pointer (make window larger)\\n* count points you see and compare against opt found\\n\\n**Step 3: Return result**\\n* return with `+points.size - a.size / 2` to account for the filtered out origin points\\n\\n**Total Complexity**\\nRuntime: `O(n*lg2(n))` due to sorting\\nSpace: `O(n)`\\n\\n**Code**\\n```\\nfun visiblePoints(points: List<List<Int>>, angle: Int, loc: List<Int>): Int {\\n    val a = points.map { listOf(it[0] - loc[0], it[1] - loc[1]) } // center\\n        .filter { it[0] != 0 || it[1] != 0 } // filter same loc/standpoint points\\n        .map { Math.atan2(it[1].toDouble(), it[0].toDouble()) } // map to angles\\n        .sorted() // sort\\n        .let { it + it.map { it + Math.PI*2 } } // expand\\n    var l = 0\\n    var r = 0\\n    var vis = 0\\n    while (r <= a.lastIndex) {\\n        if (a[r] - a[l] <= angle.toDouble()/180*Math.PI) {\\n            vis = maxOf(vis, r - l + 1)\\n            r++\\n        } else l++\\n    }\\n    return vis + points.size - a.size / 2\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun visiblePoints(points: List<List<Int>>, angle: Int, loc: List<Int>): Int {\\n    val a = points.map { listOf(it[0] - loc[0], it[1] - loc[1]) } // center\\n        .filter { it[0] != 0 || it[1] != 0 } // filter same loc/standpoint points\\n        .map { Math.atan2(it[1].toDouble(), it[0].toDouble()) } // map to angles\\n        .sorted() // sort\\n        .let { it + it.map { it + Math.PI*2 } } // expand\\n    var l = 0\\n    var r = 0\\n    var vis = 0\\n    while (r <= a.lastIndex) {\\n        if (a[r] - a[l] <= angle.toDouble()/180*Math.PI) {\\n            vis = maxOf(vis, r - l + 1)\\n            r++\\n        } else l++\\n    }\\n    return vis + points.size - a.size / 2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1820440,
                "title": "python-o-nlogn",
                "content": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        x0, y0 = location[0], location[1]\\n        sameN = 0\\n        \\n        angles = []\\n        for p in points:\\n            x, y = p[0]-x0, p[1]-y0\\n            if x == 0:\\n                if y > 0:\\n                    angles.append(90)\\n                elif y < 0:\\n                    angles.append(270)\\n                else:\\n                    sameN += 1\\n            else:\\n                x = math.degrees(math.atan2(y, x))\\n                if x < 0: x += 360\\n                angles.append(x)\\n        angles.sort()\\n        # Note: double the angles\\n        angles = angles + [a + 360 for a in angles]\\n        ret = 0\\n        j = 0\\n        for i in range(len(angles)//2):\\n            maxAngle = angles[i] + angle\\n            while j < len(angles) and angles[j] <= maxAngle:\\n                j += 1\\n            ret = max(ret, j - i)\\n        return ret + sameN\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        x0, y0 = location[0], location[1]\\n        sameN = 0\\n        \\n        angles = []\\n        for p in points:\\n            x, y = p[0]-x0, p[1]-y0\\n            if x == 0:\\n                if y > 0:\\n                    angles.append(90)\\n                elif y < 0:\\n                    angles.append(270)\\n                else:\\n                    sameN += 1\\n            else:\\n                x = math.degrees(math.atan2(y, x))\\n                if x < 0: x += 360\\n                angles.append(x)\\n        angles.sort()\\n        # Note: double the angles\\n        angles = angles + [a + 360 for a in angles]\\n        ret = 0\\n        j = 0\\n        for i in range(len(angles)//2):\\n            maxAngle = angles[i] + angle\\n            while j < len(angles) and angles[j] <= maxAngle:\\n                j += 1\\n            ret = max(ret, j - i)\\n        return ret + sameN\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806556,
                "title": "my-two-bits-about-question",
                "content": "If we remove the frustrating constraints due to using doubles and forget about getting slope and value of \\'pi\\' by C++ functions, It\\'s a very good problem. If asked in interview main point won\\'t be to solve it bug free, but getting the idea of how this problem should be approached. I mean, first idea that comes in mind is for every angle we will check how many points are in it\\'s field of view, and then take maximum of them. This can lead to idea that we can sweep circularily exactly as we do in \"sliding window in circular array\" problem, getting intuition from there is very big deal. Once you see this and know C++ functions, writing solution is piece of cake.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    double pi = acos(-1.0);\\n    \\n    double getAngle(double y, double x)\\n    {\\n        return (atan2(y,x)*180)/pi;\\n    }\\n    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int answer = 0;\\n        vector<double> pointAngles;\\n        for(auto p : points){\\n            if(p[0] == location[0] && p[1] == location[1]){\\n                answer += 1;\\n            }else {\\n                double dx = p[0] - location[0];\\n                double dy = p[1] - location[1];\\n                double angle = getAngle(dy,dx);\\n                pointAngles.push_back(angle);\\n            }\\n        }\\n        sort(pointAngles.begin(),pointAngles.end());\\n        int n = pointAngles.size();\\n        for(int i= 0; i < n ; ++i) {\\n            pointAngles.push_back(pointAngles[i] + 360);\\n        }\\n        int start = 0;\\n        int cnt = 0;\\n        for(int i = 0; i < pointAngles.size(); ++i) {\\n            if(pointAngles[i] - pointAngles[start] > angle){\\n                start++;\\n            }\\n            cnt = max(cnt, i - start + 1);\\n        }\\n        answer += cnt; \\n        return answer;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    double pi = acos(-1.0);\\n    \\n    double getAngle(double y, double x)\\n    {\\n        return (atan2(y,x)*180)/pi;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1502236,
                "title": "python-clean-sliding-window",
                "content": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:\\n        \\n        array = []\\n        nloc = 0\\n        for p in points:\\n            if p == l:\\n                nloc += 1\\n            else:\\n                array.append(math.degrees(atan2(p[1]-l[1], p[0]-l[0])))\\n        array.sort()\\n        angles = array + [a+360 for a in array]\\n        left, maxm = 0, 0\\n        for right, a in enumerate(angles):\\n            if a-angles[left] > angle:\\n                left += 1\\n            maxm = max(right-left+1, maxm)\\n        \\n        return maxm + nloc\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, l: List[int]) -> int:\\n        \\n        array = []\\n        nloc = 0\\n        for p in points:\\n            if p == l:\\n                nloc += 1\\n            else:\\n                array.append(math.degrees(atan2(p[1]-l[1], p[0]-l[0])))\\n        array.sort()\\n        angles = array + [a+360 for a in array]\\n        left, maxm = 0, 0\\n        for right, a in enumerate(angles):\\n            if a-angles[left] > angle:\\n                left += 1\\n            maxm = max(right-left+1, maxm)\\n        \\n        return maxm + nloc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465932,
                "title": "go-faster-than-100-smaller-than-100",
                "content": "```\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n\\tif angle == 360 {\\n\\t\\treturn len(points)\\n\\t}\\n\\n\\tsamePoint := 0\\n\\n\\t//Transform points into relative angles\\n\\tangs := make([]float64, 0, len(points))\\n\\tfor i := range points {\\n\\t\\tx := float64(points[i][0] - location[0])\\n\\t\\ty := float64(points[i][1] - location[1])\\n\\n\\t\\tif x == 0 && y == 0 {\\n\\t\\t\\tsamePoint++\\n\\t\\t} else {\\n\\t\\t\\tangs = append(angs, math.Atan2(y, x))\\n\\t\\t}\\n\\t}\\n\\n\\t//Sort\\n\\tsort.Float64s(angs)\\n\\n\\tvision := float64(angle) * math.Pi / 180.0\\n\\tmaxi := 0\\n\\tloop := false\\n\\taddPi := 0.0\\n\\tfor lead, follow := 0, 0; follow < len(angs); {\\n\\t\\tif loop {\\n\\t\\t\\taddPi = 2 * math.Pi\\n\\t\\t}\\n\\t\\tif angs[lead]+addPi-angs[follow] <= vision {\\n\\t\\t\\tif lead >= follow {\\n\\t\\t\\t\\tmaxi = max(maxi, lead-follow+1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmaxi = max(maxi, len(angs)-follow+1+lead)\\n\\t\\t\\t}\\n\\n\\t\\t\\tlead++\\n\\t\\t} else {\\n\\t\\t\\tfollow++\\n\\t\\t}\\n\\n\\t\\tif lead >= len(angs) {\\n\\t\\t\\tlead = 0\\n\\t\\t\\tloop = true\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn samePoint + maxi\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n\\tif angle == 360 {\\n\\t\\treturn len(points)\\n\\t}\\n\\n\\tsamePoint := 0\\n\\n\\t//Transform points into relative angles\\n\\tangs := make([]float64, 0, len(points))\\n\\tfor i := range points {\\n\\t\\tx := float64(points[i][0] - location[0])\\n\\t\\ty := float64(points[i][1] - location[1])\\n\\n\\t\\tif x == 0 && y == 0 {\\n\\t\\t\\tsamePoint++\\n\\t\\t} else {\\n\\t\\t\\tangs = append(angs, math.Atan2(y, x))\\n\\t\\t}\\n\\t}\\n\\n\\t//Sort\\n\\tsort.Float64s(angs)\\n\\n\\tvision := float64(angle) * math.Pi / 180.0\\n\\tmaxi := 0\\n\\tloop := false\\n\\taddPi := 0.0\\n\\tfor lead, follow := 0, 0; follow < len(angs); {\\n\\t\\tif loop {\\n\\t\\t\\taddPi = 2 * math.Pi\\n\\t\\t}\\n\\t\\tif angs[lead]+addPi-angs[follow] <= vision {\\n\\t\\t\\tif lead >= follow {\\n\\t\\t\\t\\tmaxi = max(maxi, lead-follow+1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmaxi = max(maxi, len(angs)-follow+1+lead)\\n\\t\\t\\t}\\n\\n\\t\\t\\tlead++\\n\\t\\t} else {\\n\\t\\t\\tfollow++\\n\\t\\t}\\n\\n\\t\\tif lead >= len(angs) {\\n\\t\\t\\tlead = 0\\n\\t\\t\\tloop = true\\n\\t\\t}\\n\\n\\t}\\n\\n\\treturn samePoint + maxi\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419387,
                "title": "clean-python-97-fast",
                "content": "```\\nfrom math import atan2\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], viewangle: int, location: List[int]) -> int:\\n        lx, ly = location\\n        def anglefromme(x, y): return 180/math.pi * atan2(y-ly,x-lx)\\n        \\n        same_aslocation = sum(x==lx and y==ly for x,y in points)\\n        angles = sorted(anglefromme(x,y) for x, y in points if (x,y) != (lx, ly) ) # just need angles\\n        angles += [x + 360 for x in angles if x < 0]  # because points below x axis (Q3, Q4) also can be after the points in Q2\\n         \\n        ans = left = 0\\n        for idx, angle in enumerate(angles): \\n            while angle - angles[left] > viewangle:\\n                left += 1\\n            # else:\\n            ans = max(ans, idx - left + 1)\\n                \\n        return ans+same_aslocation\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import atan2\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], viewangle: int, location: List[int]) -> int:\\n        lx, ly = location\\n        def anglefromme(x, y): return 180/math.pi * atan2(y-ly,x-lx)\\n        \\n        same_aslocation = sum(x==lx and y==ly for x,y in points)\\n        angles = sorted(anglefromme(x,y) for x, y in points if (x,y) != (lx, ly) ) # just need angles\\n        angles += [x + 360 for x in angles if x < 0]  # because points below x axis (Q3, Q4) also can be after the points in Q2\\n         \\n        ans = left = 0\\n        for idx, angle in enumerate(angles): \\n            while angle - angles[left] > viewangle:\\n                left += 1\\n            # else:\\n            ans = max(ans, idx - left + 1)\\n                \\n        return ans+same_aslocation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390959,
                "title": "geometry-2pointer-sliding-window-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n    int i, j;\\n\\tvector<double>incline;\\n\\tdouble pi = atan(1) * 4;\\n\\tint origin = 0;\\n\\tfor(i = 0; i < points.size(); i++){\\n        points[i][0] -= location[0];\\n        points[i][1] -= location[1];\\n        double x = points[i][0];\\n        double y = points[i][1];\\n        if(x == 0 && y == 0){\\n            origin++;\\n        }\\n        else if(x == 0){\\n            if(y > 0){\\n                incline.push_back(90);\\n                incline.push_back(450);\\n            }\\n            else{\\n                incline.push_back(270);\\n                incline.push_back(630);\\n            }\\n        }\\n        else if(y == 0){\\n            if(x > 0){\\n                incline.push_back(0);\\n                incline.push_back(360);\\n            }\\n            else{\\n                incline.push_back(180);\\n                incline.push_back(540);\\n            }\\n        }\\n        else{\\n            double ang = atan2(y, x) * (180 / pi);\\n            if(ang < 0){\\n                ang += 360;\\n            }\\n            incline.push_back(ang);\\n            incline.push_back(ang + 360);\\n        }\\n    }\\n    \\n    sort(incline.begin(), incline.end());\\n    \\n    int start = 0;\\n    int end = 0;\\n    int maxVisiblePoints = 0;\\n    while(start < incline.size() && incline[start] < 360){\\n        while(end + 1 < incline.size() && incline[end + 1] <= incline[start] + angle){\\n            end++;\\n        }\\n        maxVisiblePoints  = max(maxVisiblePoints, end - start + 1);\\n        start++;\\n    }\\n    return origin + maxVisiblePoints;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n    int i, j;\\n\\tvector<double>incline;\\n\\tdouble pi = atan(1) * 4;\\n\\tint origin = 0;\\n\\tfor(i = 0; i < points.size(); i++){\\n        points[i][0] -= location[0];\\n        points[i][1] -= location[1];\\n        double x = points[i][0];\\n        double y = points[i][1];\\n        if(x == 0 && y == 0){\\n            origin++;\\n        }\\n        else if(x == 0){\\n            if(y > 0){\\n                incline.push_back(90);\\n                incline.push_back(450);\\n            }\\n            else{\\n                incline.push_back(270);\\n                incline.push_back(630);\\n            }\\n        }\\n        else if(y == 0){\\n            if(x > 0){\\n                incline.push_back(0);\\n                incline.push_back(360);\\n            }\\n            else{\\n                incline.push_back(180);\\n                incline.push_back(540);\\n            }\\n        }\\n        else{\\n            double ang = atan2(y, x) * (180 / pi);\\n            if(ang < 0){\\n                ang += 360;\\n            }\\n            incline.push_back(ang);\\n            incline.push_back(ang + 360);\\n        }\\n    }\\n    \\n    sort(incline.begin(), incline.end());\\n    \\n    int start = 0;\\n    int end = 0;\\n    int maxVisiblePoints = 0;\\n    while(start < incline.size() && incline[start] < 360){\\n        while(end + 1 < incline.size() && incline[end + 1] <= incline[start] + angle){\\n            end++;\\n        }\\n        maxVisiblePoints  = max(maxVisiblePoints, end - start + 1);\\n        start++;\\n    }\\n    return origin + maxVisiblePoints;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302925,
                "title": "swift-clean-solution",
                "content": "```\\nclass Solution {\\n    func visiblePoints(_ points: [[Int]], _ angle: Int, _ location: [Int]) -> Int {\\n        var count = 0\\n        \\n        var angles: [Double] = points.compactMap { \\n            if $0 == location {\\n                count += 1 \\n                return nil\\n            }\\n            \\n            return createAngle(fromPoint: $0, origin: location)\\n        }\\n        \\n        angles = angles.sorted()\\n        angles += angles.map { $0 + 360 }\\n        \\n        var l = 0\\n        var maxCount = 0\\n        \\n        for r in 0..<angles.count {\\n            while angles[r] - angles[l] > Double(angle) { l += 1 }\\n            maxCount = max(maxCount, r - l + 1)\\n        }\\n        \\n        return maxCount + count\\n    }\\n    \\n    func createAngle(fromPoint point: [Int], origin: [Int]) -> Double {\\n        let x = point[0] - origin[0]\\n        let y = point[1] - origin[1]\\n        \\n        let res = atan(Double(y) / Double(x)) / Double.pi * 180\\n        \\n        if x < 0 { return res + 180 }\\n        if y < 0 { return res + 360 }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func visiblePoints(_ points: [[Int]], _ angle: Int, _ location: [Int]) -> Int {\\n        var count = 0\\n        \\n        var angles: [Double] = points.compactMap { \\n            if $0 == location {\\n                count += 1 \\n                return nil\\n            }\\n            \\n            return createAngle(fromPoint: $0, origin: location)\\n        }\\n        \\n        angles = angles.sorted()\\n        angles += angles.map { $0 + 360 }\\n        \\n        var l = 0\\n        var maxCount = 0\\n        \\n        for r in 0..<angles.count {\\n            while angles[r] - angles[l] > Double(angle) { l += 1 }\\n            maxCount = max(maxCount, r - l + 1)\\n        }\\n        \\n        return maxCount + count\\n    }\\n    \\n    func createAngle(fromPoint point: [Int], origin: [Int]) -> Double {\\n        let x = point[0] - origin[0]\\n        let y = point[1] - origin[1]\\n        \\n        let res = atan(Double(y) / Double(x)) / Double.pi * 180\\n        \\n        if x < 0 { return res + 180 }\\n        if y < 0 { return res + 360 }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293254,
                "title": "java-clean-solution-for-reference",
                "content": "```\\nclass Solution {\\n    private int origin = 0;\\n    private List<Double> angles = new ArrayList<>();\\n    \\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        checkAngle(location, points);\\n        Collections.sort(angles);\\n        \\n        int res = 0;\\n        for (int i = 0, j = 0; j < angles.size(); j++) {\\n            while (angles.get(j) - angles.get(i) > (double) angle + 1e-9) i++;\\n            res = Math.max(res, j - i + 1);\\n        }\\n        \\n        return res + origin;\\n    }\\n    \\n    private void checkAngle(List<Integer> loc, List<List<Integer>> points) {\\n        for (List<Integer> point : points) {\\n            int dy = point.get(1) - loc.get(1);\\n            int dx = point.get(0) - loc.get(0);\\n            \\n            if (dy == 0 && dx == 0) {\\n                origin++;\\n                continue;\\n            }\\n            \\n            double temp = Math.atan((double) dy / dx) / Math.PI * 180.0;\\n            if (dx < 0) temp += 180.0;\\n            else if (dy < 0) temp += 360.0;\\n            \\n            angles.add(temp);\\n            angles.add(temp + 360.0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int origin = 0;\\n    private List<Double> angles = new ArrayList<>();\\n    \\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        checkAngle(location, points);\\n        Collections.sort(angles);\\n        \\n        int res = 0;\\n        for (int i = 0, j = 0; j < angles.size(); j++) {\\n            while (angles.get(j) - angles.get(i) > (double) angle + 1e-9) i++;\\n            res = Math.max(res, j - i + 1);\\n        }\\n        \\n        return res + origin;\\n    }\\n    \\n    private void checkAngle(List<Integer> loc, List<List<Integer>> points) {\\n        for (List<Integer> point : points) {\\n            int dy = point.get(1) - loc.get(1);\\n            int dx = point.get(0) - loc.get(0);\\n            \\n            if (dy == 0 && dx == 0) {\\n                origin++;\\n                continue;\\n            }\\n            \\n            double temp = Math.atan((double) dy / dx) / Math.PI * 180.0;\\n            if (dx < 0) temp += 180.0;\\n            else if (dy < 0) temp += 360.0;\\n            \\n            angles.add(temp);\\n            angles.add(temp + 360.0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227873,
                "title": "java-concise-solution",
                "content": "\\n\\n    class Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        \\n        int minVisiblePoints = 0;\\n        List<Double> pointAngles = new ArrayList<>();\\n        \\n        for(List<Integer> point : points){\\n            if(point.equals(location)){\\n                minVisiblePoints++;\\n                continue;\\n            }\\n            \\n            double alpha = Math.atan2(point.get(1) - location.get(1) ,point.get(0) - location.get(0))*180/Math.PI;           \\n            pointAngles.add(alpha);\\n        }\\n        \\n        \\n        Collections.sort(pointAngles);\\n        List<Double> temp = pointAngles.stream().map(x->(360+x)).collect(Collectors.toList());\\n        pointAngles.addAll(temp);\\n        \\n        int maxVisiblePoints = 0;\\n        for(int l=0, r = 0; l<pointAngles.size()/2; l++){\\n            \\n\\t\\t\\twhile( r<pointAngles.size() && pointAngles.get(r)-pointAngles.get(l) <= angle)\\n                r++;\\n            \\n            maxVisiblePoints = Math.max(maxVisiblePoints, r-l);\\n        }\\n        \\n        return maxVisiblePoints + minVisiblePoints;\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        \\n        int minVisiblePoints = 0;\\n        List<Double> pointAngles = new ArrayList<>();\\n        \\n        for(List<Integer> point : points){\\n            if(point.equals(location)){\\n                minVisiblePoints++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1219683,
                "title": "c-sliding-window-over-polar-coordinates",
                "content": "**Idea**\\nEach coordinate can transformed to the Polar Coordinate System(r,theta) with respect to a line parallel to x-axis and passing through ```location```. We only care about theta in this problem.\\n\\nThe idea is to form a sliding window over the 4 quadrants and detect points lying within the arc formed by the current window. This space is cyclic in nature, hence  ```it2``` is used to account for arcs which start from 4th quadrant and go into the 1st quadrant.\\n\\n**Time Complexity**\\nSorting is the costliest operation, hence ```O(NlogN)```.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    double max( double a, double b)\\n    {\\n        return a>b?a:b;\\n    }\\n    double findAngle(vector<int> & dest, vector<int> & src)\\n    {\\n         return atan2(dest[1]-src[1], dest[0]-src[0]);\\n    }\\n    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        \\n        vector<double> ang;\\n        vector<double>::iterator it, it2;\\n        int ans = 0;\\n        int dup = 0;\\n        double end;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(location[0]==points[i][0] && location[1]==points[i][1])\\n                dup++;\\n            else\\n                ang.push_back(findAngle(points[i], location));\\n        }\\n        \\n        sort(ang.begin(), ang.end());\\n        double angle_radian = angle*M_PI/180.0;\\n\\n        for(auto start=ang.begin();start!=ang.end();start++)\\n        {\\n            end = *start + angle_radian;\\n            \\n            it = upper_bound(ang.begin(), ang.end(), end);\\n            it2 = upper_bound(ang.begin(), ang.end(), end-2*M_PI);\\n            \\n            ans = max(ans, it-start + it2 - ang.begin());\\n        }\\n        return ans+dup;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```location```\n```it2```\n```O(NlogN)```\n```\\nclass Solution {\\npublic:\\n    double max( double a, double b)\\n    {\\n        return a>b?a:b;\\n    }\\n    double findAngle(vector<int> & dest, vector<int> & src)\\n    {\\n         return atan2(dest[1]-src[1], dest[0]-src[0]);\\n    }\\n    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        \\n        vector<double> ang;\\n        vector<double>::iterator it, it2;\\n        int ans = 0;\\n        int dup = 0;\\n        double end;\\n        \\n        for(int i=0;i<points.size();i++)\\n        {\\n            if(location[0]==points[i][0] && location[1]==points[i][1])\\n                dup++;\\n            else\\n                ang.push_back(findAngle(points[i], location));\\n        }\\n        \\n        sort(ang.begin(), ang.end());\\n        double angle_radian = angle*M_PI/180.0;\\n\\n        for(auto start=ang.begin();start!=ang.end();start++)\\n        {\\n            end = *start + angle_radian;\\n            \\n            it = upper_bound(ang.begin(), ang.end(), end);\\n            it2 = upper_bound(ang.begin(), ang.end(), end-2*M_PI);\\n            \\n            ans = max(ans, it-start + it2 - ang.begin());\\n        }\\n        return ans+dup;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203518,
                "title": "python-binary-search-o-n-log-n-gotchas",
                "content": "# Algorithm\\n1. Converthe Cartesian coordinates to points (`phi`) on the [unit circle](https://en.wikipedia.org/wiki/Unit_circle).\\n2. Sort the points to facilate binary search\\n3. Apply binary search over a sliding window\\n\\n# Complexity\\n`O(n log n)`.\\nConverting to Cartesian coordinates is `O(n)`. (`math.atan2()` is slow, so this is the longest step in practice.)\\n\\nSorting is `O(n log n)`\\n\\nWe invoke binary search at most `2n` times, so the final step is `O(n log n)`.\\n\\n# Gotchas\\n## Wrapping the binary search.\\nThe binary search needs to handle intervals that include the singularity `phi = 0`. The standard trick is to break the interval into two intervals on each side of the singularity.\\n\\n## Points at origin\\nNote that `math.atan2(x,y)` is undefined when `x = 0` and `y = 0`. We need to count such points seperately.\\n\\n# Code\\n\\n```python\\nimport bisect\\nclass Solution:\\n    # Counts points between r1 and r2 clockwise.\\n    # Eg assume r1 <= r2 unless range includes phi = 0\\n    def countVisiblePoints(self, r1: float, r2: float) -> int:\\n        # Normalize any overflow.\\n        r1 = r1 % 1\\n        r2 = r2 % 1\\n        # Count points, but assume phi = 0 is NOT included in span.\\n        def countHelper(r1: float, r2: float) ->int:\\n            leftIndex = bisect.bisect_left(self.phiVals, r1)\\n            rightIndex = bisect.bisect_right(self.phiVals, r2)\\n            return rightIndex - leftIndex\\n        if r1 > r2:\\n            return countHelper(r1, 1) + countHelper(0, r2)\\n        else:\\n            return countHelper(r1, r2)\\n        \\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        # Convert to the unit circle.\\n        angle = angle / 360.0\\n        \\n        # Step 1:Adjust points so viewpoint is at origin.\\n        for point in points:\\n            point[0] -= location[0]\\n            point[1] -= location[1]\\n        # Points at orgin are always visible.\\n        self.phiZeroCount = 0\\n        \\n        # Convert to polar coordinates and normalize phi to a point on the unit circle.\\n        # By abuse of notation, we still use phi to refer to the resulting value.\\n        self.phiVals = []\\n        pointsAtOrigin = 0\\n        for point in points:\\n            if point[0] == 0 and point[1] == 0:\\n                pointsAtOrigin += 1\\n                continue\\n            phi = (math.pi + math.atan2(point[1],point[0])) / (2*math.pi)\\n            self.phiVals += [ phi ]\\n\\t\\t\\t\\n        # Step 2: Sort to facilitate binary search.\\n        self.phiVals.sort()\\n\\n\\t\\t# Step 3:\\n        maxVis = 0\\n        for phi in self.phiVals:\\n            # Case 1: Consider slices [phi,phi + angle]\\n            visiblePoints = self.countVisiblePoints(phi, phi + angle)\\n            maxVis = max(maxVis,visiblePoints)\\n            \\n        return maxVis + pointsAtOrigin\\n```",
                "solutionTags": [],
                "code": "```python\\nimport bisect\\nclass Solution:\\n    # Counts points between r1 and r2 clockwise.\\n    # Eg assume r1 <= r2 unless range includes phi = 0\\n    def countVisiblePoints(self, r1: float, r2: float) -> int:\\n        # Normalize any overflow.\\n        r1 = r1 % 1\\n        r2 = r2 % 1\\n        # Count points, but assume phi = 0 is NOT included in span.\\n        def countHelper(r1: float, r2: float) ->int:\\n            leftIndex = bisect.bisect_left(self.phiVals, r1)\\n            rightIndex = bisect.bisect_right(self.phiVals, r2)\\n            return rightIndex - leftIndex\\n        if r1 > r2:\\n            return countHelper(r1, 1) + countHelper(0, r2)\\n        else:\\n            return countHelper(r1, r2)\\n        \\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        # Convert to the unit circle.\\n        angle = angle / 360.0\\n        \\n        # Step 1:Adjust points so viewpoint is at origin.\\n        for point in points:\\n            point[0] -= location[0]\\n            point[1] -= location[1]\\n        # Points at orgin are always visible.\\n        self.phiZeroCount = 0\\n        \\n        # Convert to polar coordinates and normalize phi to a point on the unit circle.\\n        # By abuse of notation, we still use phi to refer to the resulting value.\\n        self.phiVals = []\\n        pointsAtOrigin = 0\\n        for point in points:\\n            if point[0] == 0 and point[1] == 0:\\n                pointsAtOrigin += 1\\n                continue\\n            phi = (math.pi + math.atan2(point[1],point[0])) / (2*math.pi)\\n            self.phiVals += [ phi ]\\n\\t\\t\\t\\n        # Step 2: Sort to facilitate binary search.\\n        self.phiVals.sort()\\n\\n\\t\\t# Step 3:\\n        maxVis = 0\\n        for phi in self.phiVals:\\n            # Case 1: Consider slices [phi,phi + angle]\\n            visiblePoints = self.countVisiblePoints(phi, phi + angle)\\n            maxVis = max(maxVis,visiblePoints)\\n            \\n        return maxVis + pointsAtOrigin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193355,
                "title": "optimal-c-solution-that-uses-radians-and-only-duplicates-points-in-quadrant-3-4",
                "content": "![image](https://assets.leetcode.com/users/images/1d19007b-c699-4bb6-b906-33cdc3ac43ae_1620250278.6814792.png)\\n\\n```\\nclass Solution\\n{\\npublic:\\n\\n    // This code uses radians instead of degrees\\n    // double is used because float won\\'t work for a few test cases.\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location)\\n    {\\n    \\t// no need to compute\\n        if (angle == 360)\\n        {\\n            return points.size();\\n        }\\n\\n        // no need to compute\\n        if (points.empty())\\n        {\\n            return 0;\\n        }\\n    \\t\\n\\t\\t// this will give a precise value of PI = 3.14159\\n        const double pi = acos(-1); \\n\\n    \\t// field of view, converted to radian from degree\\n        const double fov = angle * pi / 180.0;\\n\\n    \\t// array of radian values\\n        vector<double> v;\\n\\n    \\t// variable that stores all points at the location\\n        int num_zero = 0;\\n\\n    \\t// compute radian values\\n    \\tfor (int i = 0; i < points.size(); i++)\\n        {\\n        \\t// if a point is at the location then atan2(0, 0) = 0 \\n\\t\\t\\t// and it can mess up with the sliding window computation\\n            if(points[i][0] == location[0] && points[i][1] == location[1])\\n            {\\t\\n                num_zero++;\\n                continue;\\n            }\\n        \\t\\n            int x = points[i][0] - location[0];\\n            int y = points[i][1] - location[1];\\n\\n    \\t\\t// save radian value to array v\\n    \\t\\t// note that in C++ atan2(y, x)\\n            double rad = atan2(y, x);\\n            v.push_back(rad);\\n        }\\n\\n        // sorting\\n        // the order is quadrant 4 --> quadrant 3 --> quadrant 1 --> quadrant 2\\n    \\t// elements in v are in range [-PI, PI]\\n        sort(v.begin(), v.end());\\n\\n    \\t// looking for the first occurrence of a point in quadrant 1 or 2 (0 to PI)\\n        int i_positive = 0;\\n        for (int i = 0; i < v.size(); i++)\\n        {\\n            if (v[i] >= 0)\\n            {\\n                i_positive = i;\\n                break;\\n            }\\n        }\\n\\n        // Points in quadrant 3 and quadrant 4 are then appended to v\\n        if (i_positive > 0)\\n        {\\n            double pi_2 = pi * 2; // PI*2\\n            int ori_sz = v.size();\\n            v.insert(v.end(),  // add to the end of array v\\n\\t\\t\\t\\t\\t    v.begin(), // first index of duplicated point\\n\\t\\t\\t\\t\\t    v.begin() + i_positive); // last index of duplicated point\\n\\n            // To deal with a cycle,\\n            // we need to add PI*2 to the duplicated values\\n            // because the fov can intersect both quadrant 2 and quadrant 3\\n        \\t//\\n            // elements in v are now in range [-PI, PI*2]\\n            for (int i = ori_sz; i < v.size(); i++)\\n            {\\n                v[i] += pi_2;\\n            }\\n        }\\n\\n        // max points inside fov\\n        int max_pt = 0;\\n\\n    \\t// sliding window using two pointers left and right\\n    \\tint left = 0;\\n        for(int right = 0; right < v.size(); right++)\\n    \\t{\\n    \\t\\twhile((v[right] - v[left]) > fov)\\n    \\t\\t{\\n                left++;\\n    \\t\\t}\\n            max_pt = max(max_pt, right - left + 1);\\n    \\t}\\n\\n    \\t// result\\n        return max_pt + num_zero;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\n    // This code uses radians instead of degrees\\n    // double is used because float won\\'t work for a few test cases.\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location)\\n    {\\n    \\t// no need to compute\\n        if (angle == 360)\\n        {\\n            return points.size();\\n        }\\n\\n        // no need to compute\\n        if (points.empty())\\n        {\\n            return 0;\\n        }\\n    \\t\\n\\t\\t// this will give a precise value of PI = 3.14159\\n        const double pi = acos(-1); \\n\\n    \\t// field of view, converted to radian from degree\\n        const double fov = angle * pi / 180.0;\\n\\n    \\t// array of radian values\\n        vector<double> v;\\n\\n    \\t// variable that stores all points at the location\\n        int num_zero = 0;\\n\\n    \\t// compute radian values\\n    \\tfor (int i = 0; i < points.size(); i++)\\n        {\\n        \\t// if a point is at the location then atan2(0, 0) = 0 \\n\\t\\t\\t// and it can mess up with the sliding window computation\\n            if(points[i][0] == location[0] && points[i][1] == location[1])\\n            {\\t\\n                num_zero++;\\n                continue;\\n            }\\n        \\t\\n            int x = points[i][0] - location[0];\\n            int y = points[i][1] - location[1];\\n\\n    \\t\\t// save radian value to array v\\n    \\t\\t// note that in C++ atan2(y, x)\\n            double rad = atan2(y, x);\\n            v.push_back(rad);\\n        }\\n\\n        // sorting\\n        // the order is quadrant 4 --> quadrant 3 --> quadrant 1 --> quadrant 2\\n    \\t// elements in v are in range [-PI, PI]\\n        sort(v.begin(), v.end());\\n\\n    \\t// looking for the first occurrence of a point in quadrant 1 or 2 (0 to PI)\\n        int i_positive = 0;\\n        for (int i = 0; i < v.size(); i++)\\n        {\\n            if (v[i] >= 0)\\n            {\\n                i_positive = i;\\n                break;\\n            }\\n        }\\n\\n        // Points in quadrant 3 and quadrant 4 are then appended to v\\n        if (i_positive > 0)\\n        {\\n            double pi_2 = pi * 2; // PI*2\\n            int ori_sz = v.size();\\n            v.insert(v.end(),  // add to the end of array v\\n\\t\\t\\t\\t\\t    v.begin(), // first index of duplicated point\\n\\t\\t\\t\\t\\t    v.begin() + i_positive); // last index of duplicated point\\n\\n            // To deal with a cycle,\\n            // we need to add PI*2 to the duplicated values\\n            // because the fov can intersect both quadrant 2 and quadrant 3\\n        \\t//\\n            // elements in v are now in range [-PI, PI*2]\\n            for (int i = ori_sz; i < v.size(); i++)\\n            {\\n                v[i] += pi_2;\\n            }\\n        }\\n\\n        // max points inside fov\\n        int max_pt = 0;\\n\\n    \\t// sliding window using two pointers left and right\\n    \\tint left = 0;\\n        for(int right = 0; right < v.size(); right++)\\n    \\t{\\n    \\t\\twhile((v[right] - v[left]) > fov)\\n    \\t\\t{\\n                left++;\\n    \\t\\t}\\n            max_pt = max(max_pt, right - left + 1);\\n    \\t}\\n\\n    \\t// result\\n        return max_pt + num_zero;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069082,
                "title": "python-sliding-window-and-sort",
                "content": "The key is to deal with periodic property of angles. Append the sorted angle array to its self, but offset by 360 will do the trick.\\nNotice there is an edge case, if a point overlaps with the observer, it is always visible.\\n\\n```\\nclass Solution:\\n    import math\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        n = len(points)\\n        pi = 4.0*math.atan(1.0)\\n        points1 = []\\n        \\n        n_over = 0\\n        for i in range(n):\\n            dx = points[i][0]-location[0]\\n            dy = points[i][1]-location[1]\\n            \\n            if(dx==0 and dy==0): \\n                n_over += 1\\n                continue\\n            \\n            r = (dx*dx+dy*dy)**0.5\\n            phi = math.acos(dx/r)*180/pi\\n            if(dy<0):\\n                phi *= -1\\n            #print(dx, dy, phi)\\n            points1.append(phi)\\n        points1 = sorted(points1)\\n        points1 = points1 + [x+360 for x in points1]\\n        \\n        \\n        ## sliding window\\n        i = 0; j = 0\\n        ans = 0\\n        n1 = len(points1)\\n        #print(points1, n1)\\n        while(i<n1 and j<n1):\\n            while(j<n1 and points1[j]-points1[i]<angle+1e-8):\\n                ans = max(ans, j-i+1)\\n                j+=1\\n            #print(i, j)\\n            if(j==n1): break\\n            if(i<j): i += 1\\n        return ans+n_over\\n    ```        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    import math\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        n = len(points)\\n        pi = 4.0*math.atan(1.0)\\n        points1 = []\\n        \\n        n_over = 0\\n        for i in range(n):\\n            dx = points[i][0]-location[0]\\n            dy = points[i][1]-location[1]\\n            \\n            if(dx==0 and dy==0): \\n                n_over += 1\\n                continue\\n            \\n            r = (dx*dx+dy*dy)**0.5\\n            phi = math.acos(dx/r)*180/pi\\n            if(dy<0):\\n                phi *= -1\\n            #print(dx, dy, phi)\\n            points1.append(phi)\\n        points1 = sorted(points1)\\n        points1 = points1 + [x+360 for x in points1]\\n        \\n        \\n        ## sliding window\\n        i = 0; j = 0\\n        ans = 0\\n        n1 = len(points1)\\n        #print(points1, n1)\\n        while(i<n1 and j<n1):\\n            while(j<n1 and points1[j]-points1[i]<angle+1e-8):\\n                ans = max(ans, j-i+1)\\n                j+=1\\n            #print(i, j)\\n            if(j==n1): break\\n            if(i<j): i += 1\\n        return ans+n_over\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 1001858,
                "title": "slow-but-clear-python-3-2-pointer-circular-angle-list-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angles = []\\n        count = 0\\n        \\n        for point in points:\\n            # center point coordinates at location\\n            x = point[0] - location[0]\\n            y = point[1] - location[1]\\n            # pre-count the number of points at the start location and keep as\\n            # an offset to add to the final result; do not calculate angles\\n            # for these offset points\\n            if x == 0 and y == 0:\\n                count += 1\\n                continue\\n            # get the angle for each point (which can be viewed as a vector from origin and its angle with the X axis) in degrees; the range of atan2 is (-pi, pi).\\n            ang = math.degrees(math.atan2(y, x))\\n            angles.append(ang)\\n            # The trick is that the list of angles must be viewed as circular and\\n            # the easiest way to circle back the angles is to add the 360 offset\\n            angles.append(ang + 360)\\n        \\n        angles.sort()\\n        \\n        # standard two-pointer pattern to process all points\\' angles that can\\n        # be seen in the same view and take the view with the highest num of points\\n        # which is equivalent with the longest stretch within the angle span\\n        start, end, maxn = 0, 0, 0\\n        while end < len(angles) - 1:\\n            end += 1\\n            if start < end and angles[end] - angles[start] > angle:\\n                start += 1\\n            maxn = max(maxn, end - start + 1)\\n    \\n        return maxn + count",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angles = []\\n        count = 0\\n        \\n        for point in points:\\n            # center point coordinates at location\\n            x = point[0] - location[0]\\n            y = point[1] - location[1]\\n            # pre-count the number of points at the start location and keep as\\n            # an offset to add to the final result; do not calculate angles\\n            # for these offset points\\n            if x == 0 and y == 0:\\n                count += 1\\n                continue\\n            # get the angle for each point (which can be viewed as a vector from origin and its angle with the X axis) in degrees; the range of atan2 is (-pi, pi).\\n            ang = math.degrees(math.atan2(y, x))\\n            angles.append(ang)\\n            # The trick is that the list of angles must be viewed as circular and\\n            # the easiest way to circle back the angles is to add the 360 offset\\n            angles.append(ang + 360)\\n        \\n        angles.sort()\\n        \\n        # standard two-pointer pattern to process all points\\' angles that can\\n        # be seen in the same view and take the view with the highest num of points\\n        # which is equivalent with the longest stretch within the angle span\\n        start, end, maxn = 0, 0, 0\\n        while end < len(angles) - 1:\\n            end += 1\\n            if start < end and angles[end] - angles[start] > angle:\\n                start += 1\\n            maxn = max(maxn, end - start + 1)\\n    \\n        return maxn + count",
                "codeTag": "Java"
            },
            {
                "id": 916607,
                "title": "my-c-code-using-sort-and-two-pointer",
                "content": "This problem requires the precision to be double. We first find all the point angles from location. Then sort the angles. Finally, we find the ans using two-pointer technique. One thing to be noted is that the angles are rounded.\\n```\\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        double PI = 3.141592653;\\n        double angleRad = angle * 2 * PI / 360;\\n        vector<double> pointsRad;\\n        int res = 0, n = (int)points.size();\\n        for (int i = 0; i < n; i++) {\\n            if (points[i][0] == location[0] && points[i][1] == location[1]) {\\n                res++;\\n                continue;\\n            }\\n            pointsRad.push_back(atan2(points[i][1] - location[1], points[i][0] - location[0]));\\n        }\\n        if (!pointsRad.size()) return res;\\n        sort(pointsRad.begin(), pointsRad.end());\\n        int cur = 0;\\n        while (pointsRad[cur] < 0) {\\n            pointsRad.push_back(2 * PI + pointsRad[cur]);\\n            cur++;\\n        }\\n        if (!pointsRad.size()) return res;\\n        int left = 0, maxCur = 0;\\n        for (int i = 0; i < pointsRad.size(); i++) {\\n            while (pointsRad[i] - pointsRad[left] > angleRad)  left++;\\n            maxCur = max(maxCur, i - left + 1);\\n        }\\n        res += maxCur;\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "This problem requires the precision to be double. We first find all the point angles from location. Then sort the angles. Finally, we find the ans using two-pointer technique. One thing to be noted is that the angles are rounded.\\n```\\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        double PI = 3.141592653;\\n        double angleRad = angle * 2 * PI / 360;\\n        vector<double> pointsRad;\\n        int res = 0, n = (int)points.size();\\n        for (int i = 0; i < n; i++) {\\n            if (points[i][0] == location[0] && points[i][1] == location[1]) {\\n                res++;\\n                continue;\\n            }\\n            pointsRad.push_back(atan2(points[i][1] - location[1], points[i][0] - location[0]));\\n        }\\n        if (!pointsRad.size()) return res;\\n        sort(pointsRad.begin(), pointsRad.end());\\n        int cur = 0;\\n        while (pointsRad[cur] < 0) {\\n            pointsRad.push_back(2 * PI + pointsRad[cur]);\\n            cur++;\\n        }\\n        if (!pointsRad.size()) return res;\\n        int left = 0, maxCur = 0;\\n        for (int i = 0; i < pointsRad.size(); i++) {\\n            while (pointsRad[i] - pointsRad[left] > angleRad)  left++;\\n            maxCur = max(maxCur, i - left + 1);\\n        }\\n        res += maxCur;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 880285,
                "title": "java-o-nlogn-solution",
                "content": "Basic idea is to find translate all points w.r.t our location by doing (x - x0, y - y0). Then all points are w.r.t. origin (0, 0). We find angle of each point and sort all points by angles. Then we do a sliding window to find window with max no of points.\\nWe are going round the circle 2 times to cover wraparound (if we are almost near 360 deg and this is our window start, so the points above x-axis will have lesser angle but shud still be part of window, so we add 360 for this to diff).\\n\\n```\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.List;\\n\\nclass Solution {\\n\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int extra = 0;\\n        List<Double> pts = new ArrayList<>();\\n        for (List<Integer> point : points) {\\n            int x = point.get(0) - location.get(0);\\n            int y = point.get(1) - location.get(1);\\n            if (x == 0 && y == 0) { // POINT ON ITSELF EDGE CASE\\n                extra++;\\n                continue;\\n            }\\n            double pt = Math.atan2(y, x) * (180 / Math.PI); // WILL GIVE FROM -PI TO +PI\\n            pt = pt < 0 ? pt + 360 : pt; // WILL MAKE ALL ANGLES FROM 0 TO 2 * PI\\n            pts.add(pt);\\n        }\\n        Collections.sort(pts);\\n\\n        // SLIDING WINDOW\\n        int n = pts.size(), s = 0, ans = 0, i = 0;\\n        while (i < 2 * n) { // 2N TO COVER WRAPAROUND\\n\\n            // KEEP INCL POINTS IN WINDOW IF <= ANGLE\\n            while (i < 2 * n && diff(pts, n, s, i) <= (double) angle) {\\n                ans = Math.max(ans, (i - s) % n + 1);\\n                i++;\\n            }\\n\\n            // KEEP REMOVING POINTS FROM WINDOW IF > ANGLE\\n            while (s < i && i < 2 * n && (diff(pts, n, s, i)) > (double) angle) {\\n                s++;\\n            }\\n        }\\n        return ans + extra;\\n    }\\n\\n    private double diff(List<Double> pts, int n, int s, int i) {\\n        i = i % n;\\n        s = s % n;\\n        double diff = pts.get(i) - pts.get(s);\\n        return diff < 0 ? diff + 360 : diff;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.List;\\n\\nclass Solution {\\n\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int extra = 0;\\n        List<Double> pts = new ArrayList<>();\\n        for (List<Integer> point : points) {\\n            int x = point.get(0) - location.get(0);\\n            int y = point.get(1) - location.get(1);\\n            if (x == 0 && y == 0) { // POINT ON ITSELF EDGE CASE\\n                extra++;\\n                continue;\\n            }\\n            double pt = Math.atan2(y, x) * (180 / Math.PI); // WILL GIVE FROM -PI TO +PI\\n            pt = pt < 0 ? pt + 360 : pt; // WILL MAKE ALL ANGLES FROM 0 TO 2 * PI\\n            pts.add(pt);\\n        }\\n        Collections.sort(pts);\\n\\n        // SLIDING WINDOW\\n        int n = pts.size(), s = 0, ans = 0, i = 0;\\n        while (i < 2 * n) { // 2N TO COVER WRAPAROUND\\n\\n            // KEEP INCL POINTS IN WINDOW IF <= ANGLE\\n            while (i < 2 * n && diff(pts, n, s, i) <= (double) angle) {\\n                ans = Math.max(ans, (i - s) % n + 1);\\n                i++;\\n            }\\n\\n            // KEEP REMOVING POINTS FROM WINDOW IF > ANGLE\\n            while (s < i && i < 2 * n && (diff(pts, n, s, i)) > (double) angle) {\\n                s++;\\n            }\\n        }\\n        return ans + extra;\\n    }\\n\\n    private double diff(List<Double> pts, int n, int s, int i) {\\n        i = i % n;\\n        s = s % n;\\n        double diff = pts.get(i) - pts.get(s);\\n        return diff < 0 ? diff + 360 : diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878945,
                "title": "clean-java-solution-with-comments",
                "content": "\\n```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nimport static java.lang.Math.max;\\n\\n\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int originCount = 0;\\n        var angles = new ArrayList<Double>(points.size());\\n        for (List<Integer> p : points) {\\n            // translation of p with respect to location:\\n            var x = p.get(0) - location.get(0);\\n            var y = p.get(1) - location.get(1);\\n\\n            if (x == 0 && y == 0) {\\n                originCount++;\\n            } else { // if x,y is not origin:\\n                var degrees = Math.toDegrees(Math.atan2(y, x));\\n                angles.add(degrees);\\n                angles.add(degrees + 360); // to avoid modulo arithmetic!\\n            }\\n        }\\n        angles.sort(Double::compareTo);\\n        var size = angles.size();\\n\\n        int mx = 0;\\n        int slow = 0;\\n        for (int fast = 0; fast < size && slow < size/2;) {\\n            if (angles.get(fast) - angles.get(slow) <= angle) {\\n                mx = max(fast - slow + 1, mx);\\n                if (mx >= size/2) {\\n                    // all possible points in view\\n                    break;\\n                }\\n                fast++;\\n            } else {\\n                slow++;\\n            }\\n        }\\n        return mx + originCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nimport static java.lang.Math.max;\\n\\n\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int originCount = 0;\\n        var angles = new ArrayList<Double>(points.size());\\n        for (List<Integer> p : points) {\\n            // translation of p with respect to location:\\n            var x = p.get(0) - location.get(0);\\n            var y = p.get(1) - location.get(1);\\n\\n            if (x == 0 && y == 0) {\\n                originCount++;\\n            } else { // if x,y is not origin:\\n                var degrees = Math.toDegrees(Math.atan2(y, x));\\n                angles.add(degrees);\\n                angles.add(degrees + 360); // to avoid modulo arithmetic!\\n            }\\n        }\\n        angles.sort(Double::compareTo);\\n        var size = angles.size();\\n\\n        int mx = 0;\\n        int slow = 0;\\n        for (int fast = 0; fast < size && slow < size/2;) {\\n            if (angles.get(fast) - angles.get(slow) <= angle) {\\n                mx = max(fast - slow + 1, mx);\\n                if (mx >= size/2) {\\n                    // all possible points in view\\n                    break;\\n                }\\n                fast++;\\n            } else {\\n                slow++;\\n            }\\n        }\\n        return mx + originCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878153,
                "title": "python-simple-data-scientist-s-numpy-approach",
                "content": "Tricks:\\n* Shift the coordinate to `location`.\\n* Remove points that located at origin after the shift\\n* Use numpy `angle` instead of `arctan` and specify `deg=True` to get the degree directly\\n* Periodicity is handled by extending the angles list by the same array + 360\\n* Sliding window count takes O(N)\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        x0, y0 = location\\n\\t\\t# since the points at the origin won\\'t be handled properly, we count them seperately\\n        n_zeros = 0\\n        for x, y in points:\\n            if x == x0 and y == y0:\\n                n_zeros += 1\\n\\t\\t# turn coordinates into complex numbers for np.angle\\n        compl = [(x - x0) + (y - y0)*1j for x, y in points if not (x == x0 and y == y0)]\\n        angles = np.angle(compl, deg=True)  # output -180 to 180\\n        angles = np.sort(angles)\\n        angles = list(angles) + list(angles + 360)  # so that we can handle the periodicity\\n\\t\\t# Sliding window count (Time complexity O(N))\\n        max_count = 0\\n        j = 0  # index for left point\\n        for i, r in enumerate(angles):\\n            l = angles[j]\\n\\t\\t\\t# move the left by 1 if r - l not within the angle\\n            while r - l > angle:\\n                j += 1\\n                l = angles[j]\\n            max_count = max(max_count, i - j + 1)\\n        return max_count + n_zeros\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        x0, y0 = location\\n\\t\\t# since the points at the origin won\\'t be handled properly, we count them seperately\\n        n_zeros = 0\\n        for x, y in points:\\n            if x == x0 and y == y0:\\n                n_zeros += 1\\n\\t\\t# turn coordinates into complex numbers for np.angle\\n        compl = [(x - x0) + (y - y0)*1j for x, y in points if not (x == x0 and y == y0)]\\n        angles = np.angle(compl, deg=True)  # output -180 to 180\\n        angles = np.sort(angles)\\n        angles = list(angles) + list(angles + 360)  # so that we can handle the periodicity\\n\\t\\t# Sliding window count (Time complexity O(N))\\n        max_count = 0\\n        j = 0  # index for left point\\n        for i, r in enumerate(angles):\\n            l = angles[j]\\n\\t\\t\\t# move the left by 1 if r - l not within the angle\\n            while r - l > angle:\\n                j += 1\\n                l = angles[j]\\n            max_count = max(max_count, i - j + 1)\\n        return max_count + n_zeros\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878007,
                "title": "javascript-atan2-sliding-window",
                "content": "[atan2](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2) is the key to this problem. When you know about it, the rest is pretty simple.\\n\\nThe algorithm:\\n1. count all points equal to the location\\n2. count angle for others\\n3. sort angles\\n4. calculate the number of points in view using the sliding window (going through angles twice)\\n\\n```\\n\\tvar visiblePoints = function(points, angle, location) {\\n\\t\\tfunction calcAngleDegrees(a, b) {\\n\\t\\t\\treturn Math.atan2(a, b) * 180 / Math.PI;\\n\\t\\t}\\n\\n\\t\\tlet atLocation = 0;\\n\\t\\tconst x = location[0];\\n\\t\\tconst y = location[1];\\n\\t\\tconst angles = [];\\n\\n\\t\\tfor (const [px, py] of points) {\\n\\t\\t\\tif (px === x && py === y) {\\n\\t\\t\\t\\tatLocation++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tangles.push(calcAngleDegrees(px - x, py - y));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tangles.sort((a, b) => a-b);\\n\\n\\t\\tconst n = angles.length;\\n\\t\\tconst lim = 2 * n;\\n\\t\\tlet k = 0;\\n\\t\\tlet inView = 0;\\n\\t\\tconst val = (i) => i >= n ? angles[i % n] + 360 : angles[i % n];\\n\\t\\tfor (let i = 0; i < lim; i++) {\\n\\t\\t\\twhile (val(i) - val(k) > angle) k++;\\n\\t\\t\\tinView = Math.max(inView, i-k+1);\\n\\t\\t}\\n\\n\\t\\treturn atLocation + inView;\\n\\t};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n\\tvar visiblePoints = function(points, angle, location) {\\n\\t\\tfunction calcAngleDegrees(a, b) {\\n\\t\\t\\treturn Math.atan2(a, b) * 180 / Math.PI;\\n\\t\\t}\\n\\n\\t\\tlet atLocation = 0;\\n\\t\\tconst x = location[0];\\n\\t\\tconst y = location[1];\\n\\t\\tconst angles = [];\\n\\n\\t\\tfor (const [px, py] of points) {\\n\\t\\t\\tif (px === x && py === y) {\\n\\t\\t\\t\\tatLocation++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tangles.push(calcAngleDegrees(px - x, py - y));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tangles.sort((a, b) => a-b);\\n\\n\\t\\tconst n = angles.length;\\n\\t\\tconst lim = 2 * n;\\n\\t\\tlet k = 0;\\n\\t\\tlet inView = 0;\\n\\t\\tconst val = (i) => i >= n ? angles[i % n] + 360 : angles[i % n];\\n\\t\\tfor (let i = 0; i < lim; i++) {\\n\\t\\t\\twhile (val(i) - val(k) > angle) k++;\\n\\t\\t\\tinView = Math.max(inView, i-k+1);\\n\\t\\t}\\n\\n\\t\\treturn atLocation + inView;\\n\\t};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 877866,
                "title": "python3-angular-sweep",
                "content": "\\n```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        x0, y0 = location\\n        ans = ovlp = 0\\n        theta = [] \\n        for x, y in points: \\n            if x == x0 and y == y0: ovlp += 1\\n            else: theta.append(atan2(y-y0, x-x0)) # (x, y) wrt (x0, y0)\\n        \\n        theta.sort()\\n        theta += [x+2*pi for x in theta]\\n        ii = 0\\n        for i in range(len(theta)): \\n            while theta[i] - theta[ii] > angle*pi/180: ii += 1\\n            ans = max(ans, i-ii+1)\\n        return ans + ovlp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        x0, y0 = location\\n        ans = ovlp = 0\\n        theta = [] \\n        for x, y in points: \\n            if x == x0 and y == y0: ovlp += 1\\n            else: theta.append(atan2(y-y0, x-x0)) # (x, y) wrt (x0, y0)\\n        \\n        theta.sort()\\n        theta += [x+2*pi for x in theta]\\n        ii = 0\\n        for i in range(len(theta)): \\n            while theta[i] - theta[ii] > angle*pi/180: ii += 1\\n            ans = max(ans, i-ii+1)\\n        return ans + ovlp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877814,
                "title": "simple-sliding-window-over-degrees-c",
                "content": "```\\nclass Solution {\\n    const double RAD_TO_DEGREES = 180.0 / M_PI;\\n\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        std::vector<double> degrees;\\n        int result = 0;\\n        \\n        int lx = location.front();\\n        int ly = location.back();\\n        for (const vector<int> & point : points) {\\n            int px = point.front();\\n            int py = point.back();\\n            if (lx == px && ly == py) {\\n                result++;\\n                continue;\\n            }\\n            \\n            double degree = std::atan2(py - ly, px - lx) * RAD_TO_DEGREES;\\n            degrees.push_back(degree);\\n        }\\n        \\n        std::sort(degrees.begin(), degrees.end());\\n        \\n        size_t size = degrees.size();\\n        degrees.reserve(2 * size);\\n        for (int i = 0; i < size; i++) {\\n            degrees.push_back(degrees[i] + 360);\\n        }\\n        \\n        int beg = 0;\\n        int end = 0;\\n        int max_points = 0;\\n        while (end < degrees.size()) {\\n            while (end - beg >= size) {\\n                beg++;\\n            }\\n\\n            double diff = degrees[ end ] - degrees[ beg ];            \\n            while (diff > angle) {\\n                diff = degrees[ end ] - degrees[ ++beg ];\\n            }\\n\\n            max_points = std::max(max_points, end - beg + 1);\\n            end++;\\n        }\\n        \\n        result += max_points;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    const double RAD_TO_DEGREES = 180.0 / M_PI;\\n\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        std::vector<double> degrees;\\n        int result = 0;\\n        \\n        int lx = location.front();\\n        int ly = location.back();\\n        for (const vector<int> & point : points) {\\n            int px = point.front();\\n            int py = point.back();\\n            if (lx == px && ly == py) {\\n                result++;\\n                continue;\\n            }\\n            \\n            double degree = std::atan2(py - ly, px - lx) * RAD_TO_DEGREES;\\n            degrees.push_back(degree);\\n        }\\n        \\n        std::sort(degrees.begin(), degrees.end());\\n        \\n        size_t size = degrees.size();\\n        degrees.reserve(2 * size);\\n        for (int i = 0; i < size; i++) {\\n            degrees.push_back(degrees[i] + 360);\\n        }\\n        \\n        int beg = 0;\\n        int end = 0;\\n        int max_points = 0;\\n        while (end < degrees.size()) {\\n            while (end - beg >= size) {\\n                beg++;\\n            }\\n\\n            double diff = degrees[ end ] - degrees[ beg ];            \\n            while (diff > angle) {\\n                diff = degrees[ end ] - degrees[ ++beg ];\\n            }\\n\\n            max_points = std::max(max_points, end - beg + 1);\\n            end++;\\n        }\\n        \\n        result += max_points;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877810,
                "title": "c-use-degree-between-point-and-1-0-use-acos-but-not-atan",
                "content": "1. Count the degree between the vector formed by `point` and `location` and the vector (1, 0).\\n2. Sort the degrees\\n3. Pick every point as the start point and count how many points are within the angle\\n\\n```\\n#define PI 3.1415926\\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& l) {\\n        int sz_pt = points.size();\\n\\t\\t// deg -> rad\\n        double a = angle * PI / 180.0;\\n\\t\\t// store rad between (1, 0), range = [0, 2 x PI]\\n        vector<double> v;\\n\\t\\t// count the points which position are same as the location\\n        int cnt_o = 0;\\n        for (int i = 0; i < sz_pt; ++i) {\\n            if (points[i][0] == l[0] && points[i][1] == l[1]) {\\n                ++cnt_o;\\n            }\\n            else {\\n                double dx = 1.0 * (points[i][0] - l[0]), dy = 1.0 * (points[i][1] - l[1]);\\n                double tmp = acos(dx / sqrt(pow(dx, 2) + pow(dy, 2)));\\n                if (dy < 0.0)\\n                    v.emplace_back(2 * PI - tmp);\\n                else\\n                    v.emplace_back(tmp);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        const double ep = 1e-10;\\n\\t\\t// i: start point, j: end point within valid field of view\\n        int i = 0, j = 0;\\n        int res = 0;\\n        bool fg_o = false;\\n        while (i < v.size()) {\\n\\t\\t    // add 2xPI if j go to the end\\n            auto d = v[j] - v[i] + (fg_o ? PI * 2 : 0.0);\\n            if ((d <= a + ep) || (abs(d - a) < ep)) {\\n                ++j;\\n                if (j < i)\\n                    res = max(res, j + (int)v.size() - i);\\n                else\\n                    res = max(res, j - i);\\n\\t\\t\\t\\t// go the begin if j hit the end to cover when start point plus angle is greater than 2 x PI\\n                if (j == v.size()) {\\n                    j = 0;\\n                    fg_o = true;\\n                }\\n            }\\n            else {\\n                ++i;\\n            }\\n        }\\n        \\n        return res + cnt_o;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define PI 3.1415926\\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& l) {\\n        int sz_pt = points.size();\\n\\t\\t// deg -> rad\\n        double a = angle * PI / 180.0;\\n\\t\\t// store rad between (1, 0), range = [0, 2 x PI]\\n        vector<double> v;\\n\\t\\t// count the points which position are same as the location\\n        int cnt_o = 0;\\n        for (int i = 0; i < sz_pt; ++i) {\\n            if (points[i][0] == l[0] && points[i][1] == l[1]) {\\n                ++cnt_o;\\n            }\\n            else {\\n                double dx = 1.0 * (points[i][0] - l[0]), dy = 1.0 * (points[i][1] - l[1]);\\n                double tmp = acos(dx / sqrt(pow(dx, 2) + pow(dy, 2)));\\n                if (dy < 0.0)\\n                    v.emplace_back(2 * PI - tmp);\\n                else\\n                    v.emplace_back(tmp);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        const double ep = 1e-10;\\n\\t\\t// i: start point, j: end point within valid field of view\\n        int i = 0, j = 0;\\n        int res = 0;\\n        bool fg_o = false;\\n        while (i < v.size()) {\\n\\t\\t    // add 2xPI if j go to the end\\n            auto d = v[j] - v[i] + (fg_o ? PI * 2 : 0.0);\\n            if ((d <= a + ep) || (abs(d - a) < ep)) {\\n                ++j;\\n                if (j < i)\\n                    res = max(res, j + (int)v.size() - i);\\n                else\\n                    res = max(res, j - i);\\n\\t\\t\\t\\t// go the begin if j hit the end to cover when start point plus angle is greater than 2 x PI\\n                if (j == v.size()) {\\n                    j = 0;\\n                    fg_o = true;\\n                }\\n            }\\n            else {\\n                ++i;\\n            }\\n        }\\n        \\n        return res + cnt_o;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085528,
                "title": "java-100-sliding-window",
                "content": "# Intuition\\npoints can be converted to the angle from the given location. and those angle will be from 0 to n360, we can apply sliding window over the cyclic list of angle.\\n\\n# Approach\\n convert points to the angle\\n for sliding window approch will need cyclic view of given angle. that we can get by adding 360 to the angle we have in list. \\n\\n# Complexity\\n- Time complexity:\\n  O(nlog(n))\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> positions = new ArrayList<>();\\n\\n        int count = 0;\\n        for(List<Integer> point: points){\\n\\n            int delX = point.get(0) - location.get(0);\\n            int delY = point.get(1) - location.get(1);\\n            if(delX == 0 &&  delY == 0){\\n                count++;\\n                continue;\\n            }\\n\\n            var v = (Math.atan2(delY,delX) * 180 / Math.PI);\\n            positions.add(v);\\n        }\\n        Collections.sort(positions);\\n\\n        List<Double> list = new ArrayList<>(positions);\\n\\n        for(int i =0; i < positions.size();i++){\\n            list.add(360+ positions.get(i));\\n        }\\n\\n        int low = 0, high =0;\\n        int max = 0;\\n\\n        while(high < list.size()){\\n            // if out of rang \\n            double lowAngle = list.get(low);\\n            double highAngle = list.get(high);\\n            if(highAngle - lowAngle <= angle){\\n                max = Math.max(high - low +1,max);\\n                high++;\\n            }else{\\n               low++; \\n            }\\n        }\\n\\n        return max + count;\\n\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> positions = new ArrayList<>();\\n\\n        int count = 0;\\n        for(List<Integer> point: points){\\n\\n            int delX = point.get(0) - location.get(0);\\n            int delY = point.get(1) - location.get(1);\\n            if(delX == 0 &&  delY == 0){\\n                count++;\\n                continue;\\n            }\\n\\n            var v = (Math.atan2(delY,delX) * 180 / Math.PI);\\n            positions.add(v);\\n        }\\n        Collections.sort(positions);\\n\\n        List<Double> list = new ArrayList<>(positions);\\n\\n        for(int i =0; i < positions.size();i++){\\n            list.add(360+ positions.get(i));\\n        }\\n\\n        int low = 0, high =0;\\n        int max = 0;\\n\\n        while(high < list.size()){\\n            // if out of rang \\n            double lowAngle = list.get(low);\\n            double highAngle = list.get(high);\\n            if(highAngle - lowAngle <= angle){\\n                max = Math.max(high - low +1,max);\\n                high++;\\n            }else{\\n               low++; \\n            }\\n        }\\n\\n        return max + count;\\n\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012974,
                "title": "java-solution-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int count = 0;\\n        List<Double> current = new ArrayList<>();\\n        for(List<Integer> point: points){\\n\\n            if(point.get(1) == location.get(1) && point.get(0) == location.get(0)){\\n                count++;\\n                continue;\\n            }\\n            double ang = Math.atan(((double)point.get(1) - location.get(1))/ ((double)point.get(0) - location.get(0))) * 180 / Math.PI;\\n            // System.out.println(ang);\\n            if(ang >= 0 &&   point.get(1)  <= location.get(1) && point.get(0)  <= location.get(0) ){\\n                ang += 180;\\n            }\\n            else if(ang <= 0 && point.get(1) > location.get(1) && point.get(0)  <= location.get(0)  ){\\n                ang = ang + 180;\\n            }\\n            else if(ang <= 0 && point.get(1) < location.get(1) && point.get(0)  >= location.get(0) ){\\n                ang = ang + 360;\\n            }\\n\\n            current.add(ang);\\n        }\\n\\n        // System.out.println(current);\\n        Collections.sort(current);\\n        int size = current.size();\\n        for(int i = 0; i < size; i++){\\n            current.add(current.get(i) + 360);\\n        }\\n\\n        int left = 0;\\n        int right = 0;\\n\\n        int leftOA = 0;\\n        int rightOA = angle;\\n\\n        int leftA = leftOA;\\n        int rightA = rightOA;\\n\\n        int count1 = 0;\\n        // System.out.println(current);\\n        // System.out.println(count);\\n        \\n        do{\\n            // while(left < current.size() && !((current.get(left)  >= leftA && current.get(left) <= rightA) || (current.get(left) + 360 >= leftA && current.get(right) + 360 <= rightA))){\\n            //     left++;\\n            // }\\n\\n            \\n            // while(left < current.size() &&  current.get(left) < leftA){\\n            //     left++;\\n            // }\\n\\n            // while(right < current.size() && current.get(right) <= rightA){\\n            //     right++;\\n            // }\\n            \\n            // while(right < current.size() && ((current.get(right)  >= leftA && current.get(right) <= rightA) || (current.get(right) + 360 >= leftA && current.get(right) + 360 <= rightA))){\\n            //     right++;\\n            // }\\n\\n            while(right < current.size() && current.get(left) + angle >= current.get(right)){\\n                right++;\\n            }\\n\\n            \\n            // System.out.println(leftA + \",\" + rightA + \",\" + left + \",\" + right);\\n\\n\\n            count1 = Math.max((right - left), count1);\\n\\n            left++;\\n        }while(left < current.size() && right < current.size());\\n        return count1 + count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int count = 0;\\n        List<Double> current = new ArrayList<>();\\n        for(List<Integer> point: points){\\n\\n            if(point.get(1) == location.get(1) && point.get(0) == location.get(0)){\\n                count++;\\n                continue;\\n            }\\n            double ang = Math.atan(((double)point.get(1) - location.get(1))/ ((double)point.get(0) - location.get(0))) * 180 / Math.PI;\\n            // System.out.println(ang);\\n            if(ang >= 0 &&   point.get(1)  <= location.get(1) && point.get(0)  <= location.get(0) ){\\n                ang += 180;\\n            }\\n            else if(ang <= 0 && point.get(1) > location.get(1) && point.get(0)  <= location.get(0)  ){\\n                ang = ang + 180;\\n            }\\n            else if(ang <= 0 && point.get(1) < location.get(1) && point.get(0)  >= location.get(0) ){\\n                ang = ang + 360;\\n            }\\n\\n            current.add(ang);\\n        }\\n\\n        // System.out.println(current);\\n        Collections.sort(current);\\n        int size = current.size();\\n        for(int i = 0; i < size; i++){\\n            current.add(current.get(i) + 360);\\n        }\\n\\n        int left = 0;\\n        int right = 0;\\n\\n        int leftOA = 0;\\n        int rightOA = angle;\\n\\n        int leftA = leftOA;\\n        int rightA = rightOA;\\n\\n        int count1 = 0;\\n        // System.out.println(current);\\n        // System.out.println(count);\\n        \\n        do{\\n            // while(left < current.size() && !((current.get(left)  >= leftA && current.get(left) <= rightA) || (current.get(left) + 360 >= leftA && current.get(right) + 360 <= rightA))){\\n            //     left++;\\n            // }\\n\\n            \\n            // while(left < current.size() &&  current.get(left) < leftA){\\n            //     left++;\\n            // }\\n\\n            // while(right < current.size() && current.get(right) <= rightA){\\n            //     right++;\\n            // }\\n            \\n            // while(right < current.size() && ((current.get(right)  >= leftA && current.get(right) <= rightA) || (current.get(right) + 360 >= leftA && current.get(right) + 360 <= rightA))){\\n            //     right++;\\n            // }\\n\\n            while(right < current.size() && current.get(left) + angle >= current.get(right)){\\n                right++;\\n            }\\n\\n            \\n            // System.out.println(leftA + \",\" + rightA + \",\" + left + \",\" + right);\\n\\n\\n            count1 = Math.max((right - left), count1);\\n\\n            left++;\\n        }while(left < current.size() && right < current.size());\\n        return count1 + count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975270,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int visiblePoints(vector<vector<int>>& points, int angle,\\n                    vector<int>& location) {\\n    const int posX = location[0];\\n    const int posY = location[1];\\n    int maxVisible = 0;\\n    int same = 0;\\n    vector<double> pointAngles;\\n\\n    for (const vector<int>& p : points) {\\n      const int x = p[0];\\n      const int y = p[1];\\n      if (x == posX && y == posY)\\n        ++same;\\n      else\\n        pointAngles.push_back(getAngle(y - posY, x - posX));\\n    }\\n\\n    sort(pointAngles.begin(), pointAngles.end());\\n\\n    const int n = pointAngles.size();\\n    for (int i = 0; i < n; ++i)\\n      pointAngles.push_back(pointAngles[i] + 360);\\n\\n    for (int l = 0, r = 0; r < pointAngles.size(); ++r) {\\n      while (pointAngles[r] - pointAngles[l] > angle)\\n        ++l;\\n      maxVisible = max(maxVisible, r - l + 1);\\n    }\\n\\n    return maxVisible + same;\\n  }\\n\\n private:\\n  double getAngle(int dy, int dx) {\\n    return atan2(dy, dx) * 180 / M_PI;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int visiblePoints(vector<vector<int>>& points, int angle,\\n                    vector<int>& location) {\\n    const int posX = location[0];\\n    const int posY = location[1];\\n    int maxVisible = 0;\\n    int same = 0;\\n    vector<double> pointAngles;\\n\\n    for (const vector<int>& p : points) {\\n      const int x = p[0];\\n      const int y = p[1];\\n      if (x == posX && y == posY)\\n        ++same;\\n      else\\n        pointAngles.push_back(getAngle(y - posY, x - posX));\\n    }\\n\\n    sort(pointAngles.begin(), pointAngles.end());\\n\\n    const int n = pointAngles.size();\\n    for (int i = 0; i < n; ++i)\\n      pointAngles.push_back(pointAngles[i] + 360);\\n\\n    for (int l = 0, r = 0; r < pointAngles.size(); ++r) {\\n      while (pointAngles[r] - pointAngles[l] > angle)\\n        ++l;\\n      maxVisible = max(maxVisible, r - l + 1);\\n    }\\n\\n    return maxVisible + same;\\n  }\\n\\n private:\\n  double getAngle(int dy, int dx) {\\n    return atan2(dy, dx) * 180 / M_PI;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812100,
                "title": "sliding-window-on-a-circle",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        vectors = [(p1-location[0],p2-location[1]) for p1,p2 in points]\\n        pi = 3.141592653589793238462643383279502884197\\n        def myatan(a1,a2):\\n            if a1 > 0:\\n                return atan(a2/a1) / pi*180\\n            elif a1<0:\\n                return atan(a2/a1) / pi*180 + 180\\n            else:\\n                return 90 if a2>0 else -90\\n        myvectors = [v for v in vectors if v!=(0,0)]\\n        angles = sorted([myatan(a1,a2) for a1,a2 in myvectors])\\n        \\n        i,j = 0,0\\n        n = len(angles)\\n        less = len(vectors) - n\\n        res = 0\\n        angles += [x+360 for x in angles] // this line is crucial for sliding windows to work on a circle\\n        n = len(angles)\\n        while j<n:\\n            while angles[j]-angles[i] > angle:\\n                i += 1\\n            j += 1\\n            res = max(res,j-i)\\n        return res+less\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        vectors = [(p1-location[0],p2-location[1]) for p1,p2 in points]\\n        pi = 3.141592653589793238462643383279502884197\\n        def myatan(a1,a2):\\n            if a1 > 0:\\n                return atan(a2/a1) / pi*180\\n            elif a1<0:\\n                return atan(a2/a1) / pi*180 + 180\\n            else:\\n                return 90 if a2>0 else -90\\n        myvectors = [v for v in vectors if v!=(0,0)]\\n        angles = sorted([myatan(a1,a2) for a1,a2 in myvectors])\\n        \\n        i,j = 0,0\\n        n = len(angles)\\n        less = len(vectors) - n\\n        res = 0\\n        angles += [x+360 for x in angles] // this line is crucial for sliding windows to work on a circle\\n        n = len(angles)\\n        while j<n:\\n            while angles[j]-angles[i] > angle:\\n                i += 1\\n            j += 1\\n            res = max(res,j-i)\\n        return res+less\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738763,
                "title": "easy-python-sliding-solution",
                "content": "Wrap the angles to 360 to cover 0 degress as well\\n```\\nclass Solution:\\n    def visiblePoints(self, points, angle, location):\\n        max_points = 0\\n        angles = []\\n        same_location = 0\\n        \\n        for x, y in points:\\n            if x == location[0] and y == location[1]:\\n                same_location += 1\\n            else:\\n                angles.append(degrees(atan2(y - location[1], x - location[0])))\\n        \\n        angles.sort()\\n\\n        # Handle angle wrapping\\n        angles += [a + 360 for a in angles]\\n\\n        start = end = 0\\n        while end < len(angles):\\n            while angles[end] - angles[start] > angle:\\n                start += 1\\n            max_points = max(max_points, end - start + 1)\\n            end += 1\\n        \\n        return max_points + same_location\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points, angle, location):\\n        max_points = 0\\n        angles = []\\n        same_location = 0\\n        \\n        for x, y in points:\\n            if x == location[0] and y == location[1]:\\n                same_location += 1\\n            else:\\n                angles.append(degrees(atan2(y - location[1], x - location[0])))\\n        \\n        angles.sort()\\n\\n        # Handle angle wrapping\\n        angles += [a + 360 for a in angles]\\n\\n        start = end = 0\\n        while end < len(angles):\\n            while angles[end] - angles[start] > angle:\\n                start += 1\\n            max_points = max(max_points, end - start + 1)\\n            end += 1\\n        \\n        return max_points + same_location\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3720113,
                "title": "c-max-number-of-points-in-angle-of-vision",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int answer = 0;\\n        double pi = acos(-1.0);\\n        vector<double> pointAngles;\\n        for(auto p : points){\\n            if(p[0] == location[0] && p[1] == location[1]){\\n                answer += 1;\\n            }else {\\n                int dx = p[0] - location[0];\\n                int dy = p[1] - location[1];\\n                double angle = atan2(dy,dx); //tan inverse\\n                double angle1 = angle * (180) / pi;\\n                pointAngles.push_back(angle1);\\n                pointAngles.push_back(angle1+360);\\n            }\\n        }\\n        sort(pointAngles.begin(),pointAngles.end());\\n        \\n        int n = pointAngles.size();\\n        int start = 0,cnt = 0;\\n        for(int i =0; i < pointAngles.size(); ++i) {\\n            if(pointAngles[i] - pointAngles[start] > angle){\\n                start++;\\n            }\\n            cnt = max(cnt, i - start + 1);\\n        }\\n        return answer+cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int answer = 0;\\n        double pi = acos(-1.0);\\n        vector<double> pointAngles;\\n        for(auto p : points){\\n            if(p[0] == location[0] && p[1] == location[1]){\\n                answer += 1;\\n            }else {\\n                int dx = p[0] - location[0];\\n                int dy = p[1] - location[1];\\n                double angle = atan2(dy,dx); //tan inverse\\n                double angle1 = angle * (180) / pi;\\n                pointAngles.push_back(angle1);\\n                pointAngles.push_back(angle1+360);\\n            }\\n        }\\n        sort(pointAngles.begin(),pointAngles.end());\\n        \\n        int n = pointAngles.size();\\n        int start = 0,cnt = 0;\\n        for(int i =0; i < pointAngles.size(); ++i) {\\n            if(pointAngles[i] - pointAngles[start] > angle){\\n                start++;\\n            }\\n            cnt = max(cnt, i - start + 1);\\n        }\\n        return answer+cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710112,
                "title": "conver-to-polar-sort-scan-rolling-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const double PI = 2*acos(0.0);\\n\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        // convert point to polar coordinates\\n        int alwaysVisible = 0;\\n        vector<double> polar;\\n        float radians = PI * double(angle) / 180.0;\\n        for (int i = 0; i < points.size(); ++i) {\\n            // handle atan asymptotes along the y axis\\n            if (points[i][0] == location[0]) {\\n                if (points[i][1] > location[1])\\n                    polar.push_back(PI);\\n                else if (points[i][1] < location[1])\\n                    polar.push_back(0.0);\\n                else alwaysVisible++;\\n            } else {\\n                double vectorX = points[i][0] - location[0], vectorY = points[i][1] - location[1];                \\n                double length = sqrt(vectorX * vectorX + vectorY * vectorY);\\n                vectorX /= length, vectorY /= length;\\n                double angle = atan(vectorY / vectorX);\\n                // map angles to a continuous range from 0 to 2*pi, starting from the bottom and running counter clockwise.\\n                if (points[i][0] < location[0])\\n                    angle += PI * 1.5; // map left side from -pi/2..pi/2 to pi..2*pi\\n                else angle += PI * 0.5; // map right side from -pi/2..pi/2 to 0..pi \\n                polar.push_back(angle);\\n            }\\n        }\\n        sort(polar.begin(), polar.end());\\n        int maxVisible = alwaysVisible;\\n        int pointsInRange = 1;\\n        for (int i = 0; i < polar.size(); ++i) {\\n            // align our \"camera\"\\'s left side with point i\\n            bool done = false;\\n            while (pointsInRange < polar.size() && !done) {\\n                double diff = polar[(i + pointsInRange) % polar.size()] - polar[i];\\n                if (diff < 0.0)\\n                    diff += PI * 2.0;\\n                if (diff <= radians)\\n                    pointsInRange++;\\n                else done = true;\\n            }\\n            maxVisible = max(maxVisible, pointsInRange + alwaysVisible);\\n            pointsInRange = max(1, pointsInRange - 1); // we lose one point in range while going to the next one\\n        }\\n        return maxVisible;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const double PI = 2*acos(0.0);\\n\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        // convert point to polar coordinates\\n        int alwaysVisible = 0;\\n        vector<double> polar;\\n        float radians = PI * double(angle) / 180.0;\\n        for (int i = 0; i < points.size(); ++i) {\\n            // handle atan asymptotes along the y axis\\n            if (points[i][0] == location[0]) {\\n                if (points[i][1] > location[1])\\n                    polar.push_back(PI);\\n                else if (points[i][1] < location[1])\\n                    polar.push_back(0.0);\\n                else alwaysVisible++;\\n            } else {\\n                double vectorX = points[i][0] - location[0], vectorY = points[i][1] - location[1];                \\n                double length = sqrt(vectorX * vectorX + vectorY * vectorY);\\n                vectorX /= length, vectorY /= length;\\n                double angle = atan(vectorY / vectorX);\\n                // map angles to a continuous range from 0 to 2*pi, starting from the bottom and running counter clockwise.\\n                if (points[i][0] < location[0])\\n                    angle += PI * 1.5; // map left side from -pi/2..pi/2 to pi..2*pi\\n                else angle += PI * 0.5; // map right side from -pi/2..pi/2 to 0..pi \\n                polar.push_back(angle);\\n            }\\n        }\\n        sort(polar.begin(), polar.end());\\n        int maxVisible = alwaysVisible;\\n        int pointsInRange = 1;\\n        for (int i = 0; i < polar.size(); ++i) {\\n            // align our \"camera\"\\'s left side with point i\\n            bool done = false;\\n            while (pointsInRange < polar.size() && !done) {\\n                double diff = polar[(i + pointsInRange) % polar.size()] - polar[i];\\n                if (diff < 0.0)\\n                    diff += PI * 2.0;\\n                if (diff <= radians)\\n                    pointsInRange++;\\n                else done = true;\\n            }\\n            maxVisible = max(maxVisible, pointsInRange + alwaysVisible);\\n            pointsInRange = max(1, pointsInRange - 1); // we lose one point in range while going to the next one\\n        }\\n        return maxVisible;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421476,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n_points * log(n_points))\\n * Space Complexity: O(n_points)\\n * where `n_points` is the length of the vector `points`\\n */\\nclass Solution {\\n public:\\n  int visiblePoints(const vector<vector<int>> &points,\\n                    const int angle,\\n                    const vector<int> &location) {\\n    constexpr double degrees_per_pi = 180.0;\\n    const double pi = atan2(0, -1);\\n    const double cycle = 2 * pi;\\n    vector<double> angles;\\n    int same_points = 0;\\n    for (const vector<int> &point : points) {\\n      if (point == location) {\\n        ++same_points;\\n      } else {\\n        angles.emplace_back(atan2(point.back() - location.back(), point.front() - location.front()));\\n      }\\n    }\\n    \\n    sort(angles.begin(), angles.end());\\n    const double covered_angle = pi * (angle / degrees_per_pi);\\n    const int n = static_cast<int>(angles.size());\\n    int begin = 0;\\n    int end = 0;\\n    for (; begin < n; ++end) {\\n      const double angle_between_begin_end = (end >= n ? cycle + angles[end - n] : angles[end]) - angles[begin];\\n      if (angle_between_begin_end > covered_angle) {\\n        ++begin;\\n      }\\n    }\\n    return same_points + (end - begin);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n_points * log(n_points))\\n * Space Complexity: O(n_points)\\n * where `n_points` is the length of the vector `points`\\n */\\nclass Solution {\\n public:\\n  int visiblePoints(const vector<vector<int>> &points,\\n                    const int angle,\\n                    const vector<int> &location) {\\n    constexpr double degrees_per_pi = 180.0;\\n    const double pi = atan2(0, -1);\\n    const double cycle = 2 * pi;\\n    vector<double> angles;\\n    int same_points = 0;\\n    for (const vector<int> &point : points) {\\n      if (point == location) {\\n        ++same_points;\\n      } else {\\n        angles.emplace_back(atan2(point.back() - location.back(), point.front() - location.front()));\\n      }\\n    }\\n    \\n    sort(angles.begin(), angles.end());\\n    const double covered_angle = pi * (angle / degrees_per_pi);\\n    const int n = static_cast<int>(angles.size());\\n    int begin = 0;\\n    int end = 0;\\n    for (; begin < n; ++end) {\\n      const double angle_between_begin_end = (end >= n ? cycle + angles[end - n] : angles[end]) - angles[begin];\\n      if (angle_between_begin_end > covered_angle) {\\n        ++begin;\\n      }\\n    }\\n    return same_points + (end - begin);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417016,
                "title": "python-simple-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def visiblePoints(self, points, angle, location):\\n        a, b, angle = location[0], location[1], radians(angle)\\n\\n        n = sum([1 for x,y in points if x == a and y == b])\\n        ans = sorted([atan2(y-b,x-a) for x,y in points if x!=a or y!=b])\\n        ans += [k+2*pi for k in ans]\\n\\n        high, max_val, m = 0, 0, len(ans)\\n\\n        for low in range(m):\\n            while (high < m and ans[high] - ans[low] <= angle):\\n                high += 1\\n            max_val = max(max_val,high-low)\\n\\n        return max_val + n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points, angle, location):\\n        a, b, angle = location[0], location[1], radians(angle)\\n\\n        n = sum([1 for x,y in points if x == a and y == b])\\n        ans = sorted([atan2(y-b,x-a) for x,y in points if x!=a or y!=b])\\n        ans += [k+2*pi for k in ans]\\n\\n        high, max_val, m = 0, 0, len(ans)\\n\\n        for low in range(m):\\n            while (high < m and ans[high] - ans[low] <= angle):\\n                high += 1\\n            max_val = max(max_val,high-low)\\n\\n        return max_val + n\\n\\n\\n        \\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413159,
                "title": "rust-sliding-window-fastest-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst, some intermediary knowledge: \\n- To find the angle of a point on the unit circle, you can use the ```atan2``` method. Since the point is relative to a position, we would have to first subtract the location from the point. \\n- When computing a sliding window that fits maximally, you only need to check intervals that start on points. If you have 100 points, you only need to check 100 intervals. \\n- we can discard points that are at the same location as the player, and add them at the end \\n\\nThe intuition is that we compute the angle of each point, sort them, then we go counter clock-wise on the circle checking an interval that would start at point i and is as long as i\\'s angle + field of view angle. \\nTo make sure we consider rotations, we can increase each point\\'s angle by 2 pi after we considered it. The angle does not change, but it puts the value of the angle bigger then the last point. As such we always consider the full circle. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n1st compute the angle of each point, normalized between [-pi/2;pi/2]\\n2nd sort the resulting angles increasing. \\n3rd. Define a sliding window that starts at l_index, and ends at r_index.\\nStart the sliding window at 0, and the angle to the point starting at that index at grow it until no more point fit. Take note of the size of the window. \\nMove the window by 1 point. The old boundary (r_index) is the same since the window either doesn\\'t fit r_index either or fits it, and has to move it forward. \\n\\nRepeat for all the intervals, return the biggest size. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAngles: O(n)\\nSorting: O(n log n)\\nChecking the intervals: O(2n) = O(n)\\n\\nTotal: O(3n + n log n) = O(n log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nimpl Solution {\\n    pub fn visible_points(points: Vec<Vec<i32>>, angle: i32, location: Vec<i32>) -> i32 {\\n        let mut perma_points = 0;\\n        let mut angles: Vec<f64> = Vec::new();\\n        let mut angle = (angle as f64).to_radians();\\n        for i in points.iter() {\\n            if i[0] == location[0] && i[1] == location[1] {\\n                perma_points += 1;\\n            } else {\\n                let x_diff = (-i[0] + location[0]) as f64;\\n                let y_diff = (-i[1] + location[1]) as f64;\\n                angles.push(\\n                    y_diff.atan2(x_diff)\\n                );\\n            }\\n        }\\n\\n        angles.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());\\n        let mut r_index = 0;\\n        let mut max_size = 0;\\n        let mut n = angles.len();\\n\\n        let mut l_index = 0;\\n        let mut point_angle: f64 = 0.0;\\n        while l_index < n {\\n            point_angle = angles[l_index];\\n            while angles[r_index] <= point_angle + angle {\\n                r_index = (r_index + 1) % n;\\n                if r_index == l_index {\\n                    return angles.len() as i32 + perma_points;\\n                }\\n            }\\n            if r_index < l_index {\\n                max_size = max_size.max(r_index + n - l_index);\\n            } else {\\n                max_size = max_size.max(r_index - l_index);\\n            }\\n            angles[l_index] += 2.0 * std::f64::consts::PI;\\n            l_index += 1;\\n        }\\n        return max_size as i32 + perma_points;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```atan2```\n```\\nimpl Solution {\\n    pub fn visible_points(points: Vec<Vec<i32>>, angle: i32, location: Vec<i32>) -> i32 {\\n        let mut perma_points = 0;\\n        let mut angles: Vec<f64> = Vec::new();\\n        let mut angle = (angle as f64).to_radians();\\n        for i in points.iter() {\\n            if i[0] == location[0] && i[1] == location[1] {\\n                perma_points += 1;\\n            } else {\\n                let x_diff = (-i[0] + location[0]) as f64;\\n                let y_diff = (-i[1] + location[1]) as f64;\\n                angles.push(\\n                    y_diff.atan2(x_diff)\\n                );\\n            }\\n        }\\n\\n        angles.sort_unstable_by(|a, b| a.partial_cmp(b).unwrap());\\n        let mut r_index = 0;\\n        let mut max_size = 0;\\n        let mut n = angles.len();\\n\\n        let mut l_index = 0;\\n        let mut point_angle: f64 = 0.0;\\n        while l_index < n {\\n            point_angle = angles[l_index];\\n            while angles[r_index] <= point_angle + angle {\\n                r_index = (r_index + 1) % n;\\n                if r_index == l_index {\\n                    return angles.len() as i32 + perma_points;\\n                }\\n            }\\n            if r_index < l_index {\\n                max_size = max_size.max(r_index + n - l_index);\\n            } else {\\n                max_size = max_size.max(r_index - l_index);\\n            }\\n            angles[l_index] += 2.0 * std::f64::consts::PI;\\n            l_index += 1;\\n        }\\n        return max_size as i32 + perma_points;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3280662,
                "title": "c-2-pointer",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        const double d = angle / 180.0 * M_PI;\\n        vector<double> v;\\n        int res = 0, countOrigin = 0;\\n        for (auto& p : points){\\n            auto x = p[0] - location[0], y = p[1] - location[1];\\n            if(x == 0 && y==0) countOrigin++;\\n            else v.push_back(atan2(x, y));\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0, n=v.size(); i<n;i++) v.push_back(v[i] + 2*M_PI);\\n        for(int i=0,j=0,n=v.size();j<n;i++){\\n            while(j<n && v[j] - v[i] <= d) {\\n                res = max(res, j-i+1);\\n                j++;\\n            }\\n        }\\n        return res + countOrigin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        const double d = angle / 180.0 * M_PI;\\n        vector<double> v;\\n        int res = 0, countOrigin = 0;\\n        for (auto& p : points){\\n            auto x = p[0] - location[0], y = p[1] - location[1];\\n            if(x == 0 && y==0) countOrigin++;\\n            else v.push_back(atan2(x, y));\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0, n=v.size(); i<n;i++) v.push_back(v[i] + 2*M_PI);\\n        for(int i=0,j=0,n=v.size();j<n;i++){\\n            while(j<n && v[j] - v[i] <= d) {\\n                res = max(res, j-i+1);\\n                j++;\\n            }\\n        }\\n        return res + countOrigin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260483,
                "title": "kotlin-solution-with-sliding-window",
                "content": "# Intuition\\nThe main idea is calculating angles as arctangle between the current location and a point from points. We need to keep in mind cases when our angle could be more than 360. \\n\\n# Approach\\n1. Calculating count of the same points as the location, otherwise calculate the angle between the point and location\\n2. Sort angles and keep angles from 2PI + angle\\n3. Iterate angles in order to calculate the max count of applicable points to the target angle using the classical sliding window approach\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nimport kotlin.math.atan2\\n\\nclass Solution {\\n    fun visiblePoints(points: List<List<Int>>, angle: Int, location: List<Int>): Int {\\n        val angles = mutableListOf<Double>()\\n        var centerPoint = 0\\n\\n        for (point in points) {\\n            if (point == location) {\\n                centerPoint++\\n            } else {\\n                angles.add(calculateAngle(point, location))\\n            }\\n        }\\n\\n        angles.sort()\\n        angles.addAll(angles.map { it + 360 })\\n\\n        var max = 0\\n\\n        var start = 0\\n        for (end in angles.indices) {\\n            if (angles[end] - angles[start] > angle) {\\n                start++\\n            }\\n            max = maxOf(max, end - start + 1)\\n        }\\n\\n\\n        return max + centerPoint\\n    }\\n\\n    private fun calculateAngle(point: List<Int>, location: List<Int>): Double {\\n        val angle = atan2((point.last() - location.last()).toFloat(), (point.first() - location.first()).toFloat()).degree()\\n\\n        return if (angle < 0) angle + 360 else angle\\n    }\\n    \\n    private fun Float.degree() = this * 180 / Math.PI\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Sliding Window"
                ],
                "code": "```\\nimport kotlin.math.atan2\\n\\nclass Solution {\\n    fun visiblePoints(points: List<List<Int>>, angle: Int, location: List<Int>): Int {\\n        val angles = mutableListOf<Double>()\\n        var centerPoint = 0\\n\\n        for (point in points) {\\n            if (point == location) {\\n                centerPoint++\\n            } else {\\n                angles.add(calculateAngle(point, location))\\n            }\\n        }\\n\\n        angles.sort()\\n        angles.addAll(angles.map { it + 360 })\\n\\n        var max = 0\\n\\n        var start = 0\\n        for (end in angles.indices) {\\n            if (angles[end] - angles[start] > angle) {\\n                start++\\n            }\\n            max = maxOf(max, end - start + 1)\\n        }\\n\\n\\n        return max + centerPoint\\n    }\\n\\n    private fun calculateAngle(point: List<Int>, location: List<Int>): Double {\\n        val angle = atan2((point.last() - location.last()).toFloat(), (point.first() - location.first()).toFloat()).degree()\\n\\n        return if (angle < 0) angle + 360 else angle\\n    }\\n    \\n    private fun Float.degree() = this * 180 / Math.PI\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184639,
                "title": "python3-sliding-window-over-circular-angles",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to solve this, one needs to figure out how to compute the angles of points to our current position.\\n\\nOnce you have this array of angles, you can sort it and just do a typical sliding window maximization.\\n\\nThe tangens of the angle from us to our points is the distance in y divided by the distance in x. As we need to calculate the angle, we need to use the inverted tanges: arcus tangens. Normally the arcus tangens is only defined from (-90, 90)\\xB0, but in python we can use the atan2 function, which takes the y and x separately and already returns the angle in the right quadrant (-180, 180)\\xB0.\\n\\nOther than that one needs to know, that the geometrical functions (tan, cos, sin) in most programming languages return the angle in radians (multiples of pi). One pi corresponds to 180\\xB0.\\n\\nTherefore we either convert the radians to angles (* 180/pi) or the field of view to radians (* pi/189).\\n\\nAfter that we can do a sliding window maximization with the constraint of the difference of the minimum and the maximum angle beeing equal or smaller than our field of view.\\n\\nOne needs to keep in mind, that the angles are mod360 circular, so we need to extend our sliding window over the end of the real array until the left pointer (smaller angles) hits the end. angles where the pointer has left the end of the array and goes back in the front need to be increassed by 360.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGeometrical functions and sliding window over circular array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN) for the sorting\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) for the angles\\n# Code\\n```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], fov: int, location: List[int]) -> int:\\n\\n        # compute the angle of all points to myself\\n        angles = []\\n        equal = 0\\n        rad2angle = 180/math.pi\\n        for point in points:\\n\\n            # check whether the point is the same as we are\\n            if point == location:\\n                equal += 1\\n                continue\\n            \\n            # get the arcus tangens for the angle with the correct quadrant information\\n            angles.append(math.atan2(point[1] - location[1], point[0] - location[0])*rad2angle)\\n        \\n        # sort the angles\\n        angles.sort()\\n\\n        # compute a sliding window, while doing that we need to keep in mind that the angles\\n        # are mod360 degree circular, so we need to extend our range check over the end of the\\n        # array\\n        result = 0\\n        left = 0\\n        right = 0\\n        while left < len(angles):\\n\\n            # get the current angle\\n            angle = angles[right] if right < len(angles) else angles[right % len(angles)] + 360\\n            \\n            # update the sliding window\\n            left_angle = angles[left] if left < len(angles) else angles[left % len(angles)] + 360\\n            while angle - left_angle > fov:\\n                left += 1\\n                left_angle = angles[left] if left < len(angles) else angles[left % len(angles)] + 360\\n            \\n            # update the result\\n            result = max(result, right-left+1)\\n\\n            # update the right pointer\\n            right += 1\\n        return result + equal\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], fov: int, location: List[int]) -> int:\\n\\n        # compute the angle of all points to myself\\n        angles = []\\n        equal = 0\\n        rad2angle = 180/math.pi\\n        for point in points:\\n\\n            # check whether the point is the same as we are\\n            if point == location:\\n                equal += 1\\n                continue\\n            \\n            # get the arcus tangens for the angle with the correct quadrant information\\n            angles.append(math.atan2(point[1] - location[1], point[0] - location[0])*rad2angle)\\n        \\n        # sort the angles\\n        angles.sort()\\n\\n        # compute a sliding window, while doing that we need to keep in mind that the angles\\n        # are mod360 degree circular, so we need to extend our range check over the end of the\\n        # array\\n        result = 0\\n        left = 0\\n        right = 0\\n        while left < len(angles):\\n\\n            # get the current angle\\n            angle = angles[right] if right < len(angles) else angles[right % len(angles)] + 360\\n            \\n            # update the sliding window\\n            left_angle = angles[left] if left < len(angles) else angles[left % len(angles)] + 360\\n            while angle - left_angle > fov:\\n                left += 1\\n                left_angle = angles[left] if left < len(angles) else angles[left % len(angles)] + 360\\n            \\n            # update the result\\n            result = max(result, right-left+1)\\n\\n            # update the right pointer\\n            right += 1\\n        return result + equal\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122146,
                "title": "js-sliding-window-technique-with-o-n-log-n",
                "content": "\\n# Approach\\n Sliding window technique.\\n- The code first initializes an array called `arr` to store the angles between each point and the given location.\\n- The code calculates the angle between each point and the given location using the `Math.atan2` function.\\n- If the point has the same location as the given location, it increments the extra variable.\\n- The code then sorts the `arr` in ascending order.\\n- The `arr` is then concatenated with itself with each angle increased by `2 * pi`.\\n- The given angle is converted from degrees to radians.\\n- The code then uses two pointers `l` and `r`, to find the maximum number of points in the `arr` that have an angle difference less than or equal to the given angle.\\n- If the angle difference between `arr[r]` and `arr[l]` is greater than the given angle,`l` is incremented.\\n- The `ans` variable stores the maximum number of points with an angle difference less than or equal to the given angle.\\n- The final result is the sum of `ans` and extra.\\n\\n# Complexity\\nTime Complexity: O(n log n) where n is the number of points. The sorting of the arr takes O(n log n) time and the two-pointer approach takes O(n) time.\\n\\nSpace Complexity: O(n). The code uses an array of size n to store the angles between each point and the given location.\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} points\\n * @param {number} angle\\n * @param {number[]} location\\n * @return {number}\\n */\\nvar visiblePoints = function(points, angle, location) {\\n    let arr = [], extra = 0\\n    let [xx, yy] = location\\n    \\n    for (let [x, y] of points) {\\n        if (x == xx && y == yy) {\\n            extra += 1\\n            continue\\n        }\\n        arr.push(Math.atan2(y - yy, x - xx))\\n    }\\n    \\n    arr.sort((a, b) => a - b)\\n    arr = arr.concat(arr.map(x => x + 2.0 * Math.PI))\\n    angle = Math.PI * angle / 180\\n    \\n    let l = ans = 0\\n    for (let r = 0; r < arr.length; r++) {\\n        while (arr[r] - arr[l] > angle) {\\n            l += 1\\n        }\\n        ans = Math.max(ans, r - l + 1)\\n    }\\n    \\n    return ans + extra\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} angle\\n * @param {number[]} location\\n * @return {number}\\n */\\nvar visiblePoints = function(points, angle, location) {\\n    let arr = [], extra = 0\\n    let [xx, yy] = location\\n    \\n    for (let [x, y] of points) {\\n        if (x == xx && y == yy) {\\n            extra += 1\\n            continue\\n        }\\n        arr.push(Math.atan2(y - yy, x - xx))\\n    }\\n    \\n    arr.sort((a, b) => a - b)\\n    arr = arr.concat(arr.map(x => x + 2.0 * Math.PI))\\n    angle = Math.PI * angle / 180\\n    \\n    let l = ans = 0\\n    for (let r = 0; r < arr.length; r++) {\\n        while (arr[r] - arr[l] > angle) {\\n            l += 1\\n        }\\n        ans = Math.max(ans, r - l + 1)\\n    }\\n    \\n    return ans + extra\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3018057,
                "title": "angles-are-converted-to-rad-and-then-modified-binary-search-applied-to-find-the-points",
                "content": "# Intuition\\nFirst the tanget wrt the location is calculated. All the points that have the same coordinates as the location is removed from the list. They are common points to all the possible angle spread.\\nThe angles are obtained from the tangent in [-pi, pi] range. They are converted into [0, 2pi] range. \\nThe list of angles is sorted in ascending order \\nfor each angle in the list, a window of possible points is generated based on the angle provided in the problem. \\nIf the angle spread is within 2pi range, then modified binary search is applied on the whole range to find max points.\\nElse all the points till the end of the list are added and the binary search is applied on the starting of the list till the iterated angle. The logic here is that points closer to the x axis can have some points in the starting of the list due to circular nature of angles.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlog n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n# import numpy as np\\nfrom math import atan2, pi, floor\\nclass Solution:\\n    def binary_search(self, arr, start_index, end_index, value):\\n        if start_index < 0:\\n            return -1\\n        if start_index <= end_index:\\n            mid = floor((start_index + end_index)/2)\\n            # print(start_index, end_index, mid)\\n            if arr[mid] <= value:\\n                search_index = self.binary_search(arr, mid + 1, end_index, value)\\n                if search_index != -1:\\n                    return search_index\\n                else:\\n                    return mid\\n            else:\\n                return self.binary_search(arr, start_index, mid - 1, value)\\n        else:\\n            return -1\\n    def get_angle(self, point, location):\\n        angle_in_rad = atan2((point[1] - location[1]),(point[0] - location[0]))\\n        if angle_in_rad < 0:\\n            return 2*pi + angle_in_rad\\n        else:\\n            return angle_in_rad\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angles = [self.get_angle(point, location) for point in points if not (point[0] == location[0] and point[1] == location[1])]\\n        angle_in_rad = pi * angle/180\\n        points_at_base = 0\\n        for point in points:\\n            if point[0] == location[0] and point[1] == location[1]:\\n                points_at_base += 1\\n        _angles = sorted(angles)\\n        # print(_angles)\\n        max_points = 0\\n        for i in range(len(_angles)):\\n            curr_max_points = 0\\n            if _angles[i] + angle_in_rad <= 2*pi:\\n                index = self.binary_search(_angles, i + 1, len(_angles) - 1, _angles[i] + angle_in_rad)\\n                curr_max_points += 1\\n                if index != -1:\\n                    curr_max_points += index - i\\n                # for j in range(i, len(_angles)):\\n                #     if _angles[j] - _angles[i] <= angle_in_rad:\\n                #         curr_max_points += 1\\n                #     else:\\n                #         break\\n            else:\\n                curr_max_points = len(_angles) - i\\n                index = self.binary_search(_angles, 0, i - 1, _angles[i] + angle_in_rad - 2*pi)\\n                if index != -1:\\n                    curr_max_points += index + 1\\n                # for j in range(0, i):\\n                #     if _angles[j] <= _angles[i] + angle_in_rad - 2*pi:\\n                #         curr_max_points += 1\\n                #     else:\\n                #         break\\n            if curr_max_points > max_points:\\n                        max_points = curr_max_points\\n            \\n        return max_points + points_at_base\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# import numpy as np\\nfrom math import atan2, pi, floor\\nclass Solution:\\n    def binary_search(self, arr, start_index, end_index, value):\\n        if start_index < 0:\\n            return -1\\n        if start_index <= end_index:\\n            mid = floor((start_index + end_index)/2)\\n            # print(start_index, end_index, mid)\\n            if arr[mid] <= value:\\n                search_index = self.binary_search(arr, mid + 1, end_index, value)\\n                if search_index != -1:\\n                    return search_index\\n                else:\\n                    return mid\\n            else:\\n                return self.binary_search(arr, start_index, mid - 1, value)\\n        else:\\n            return -1\\n    def get_angle(self, point, location):\\n        angle_in_rad = atan2((point[1] - location[1]),(point[0] - location[0]))\\n        if angle_in_rad < 0:\\n            return 2*pi + angle_in_rad\\n        else:\\n            return angle_in_rad\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angles = [self.get_angle(point, location) for point in points if not (point[0] == location[0] and point[1] == location[1])]\\n        angle_in_rad = pi * angle/180\\n        points_at_base = 0\\n        for point in points:\\n            if point[0] == location[0] and point[1] == location[1]:\\n                points_at_base += 1\\n        _angles = sorted(angles)\\n        # print(_angles)\\n        max_points = 0\\n        for i in range(len(_angles)):\\n            curr_max_points = 0\\n            if _angles[i] + angle_in_rad <= 2*pi:\\n                index = self.binary_search(_angles, i + 1, len(_angles) - 1, _angles[i] + angle_in_rad)\\n                curr_max_points += 1\\n                if index != -1:\\n                    curr_max_points += index - i\\n                # for j in range(i, len(_angles)):\\n                #     if _angles[j] - _angles[i] <= angle_in_rad:\\n                #         curr_max_points += 1\\n                #     else:\\n                #         break\\n            else:\\n                curr_max_points = len(_angles) - i\\n                index = self.binary_search(_angles, 0, i - 1, _angles[i] + angle_in_rad - 2*pi)\\n                if index != -1:\\n                    curr_max_points += index + 1\\n                # for j in range(0, i):\\n                #     if _angles[j] <= _angles[i] + angle_in_rad - 2*pi:\\n                #         curr_max_points += 1\\n                #     else:\\n                #         break\\n            if curr_max_points > max_points:\\n                        max_points = curr_max_points\\n            \\n        return max_points + points_at_base\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975982,
                "title": "tangent-adding-after-sorting-the-edge-cases",
                "content": "# Intuition\\nTo solve the execrise you must:\\n1. Transform the point into angles (radians in my case)\\n2. Sort the points\\n3. Add smaller than angle to the end, for edge cases `[2*pi-angle,2*pi]`\\n4.1. As we are adding points plus a constant, and the constant is greater than the biggest item in the list ensures that the result is sorted, and avoid you of having a greater `n` in the `n*log(n)` sorting\\n4. Perform a \"no-shrink\" moving window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(2*n)$$ = $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> points2 = new ArrayList<>();\\n        double angle2=(angle*Math.PI)/180, shift=2*Math.PI;\\n        int x=location.get(0), y=location.get(1);\\n        int z=0;\\n        for(List<Integer> g : points) {\\n            int t1=g.get(0)-x, t2=g.get(1)-y;\\n            if(t1==0&&t2==0) {\\n                z++;\\n                continue;\\n            }\\n            double next=Math.atan2(t1,t2);\\n            points2.add(next);\\n        }\\n        Collections.sort(points2);\\n        for(int i=0;i<points2.size()&&points2.get(i)<=angle2;i++) points2.add(points2.get(i)+shift);\\n        int a=0, b=0;\\n        while(a<points2.size()) {\\n            if(points2.get(a)-points2.get(b)>angle2) b++;\\n            a++;\\n        }\\n        return a-b+z;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        List<Double> points2 = new ArrayList<>();\\n        double angle2=(angle*Math.PI)/180, shift=2*Math.PI;\\n        int x=location.get(0), y=location.get(1);\\n        int z=0;\\n        for(List<Integer> g : points) {\\n            int t1=g.get(0)-x, t2=g.get(1)-y;\\n            if(t1==0&&t2==0) {\\n                z++;\\n                continue;\\n            }\\n            double next=Math.atan2(t1,t2);\\n            points2.add(next);\\n        }\\n        Collections.sort(points2);\\n        for(int i=0;i<points2.size()&&points2.get(i)<=angle2;i++) points2.add(points2.get(i)+shift);\\n        int a=0, b=0;\\n        while(a<points2.size()) {\\n            if(points2.get(a)-points2.get(b)>angle2) b++;\\n            a++;\\n        }\\n        return a-b+z;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971722,
                "title": "c-easy-level-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int n= points.size();\\n        vector<double>angles;\\n        double pi= acos(-1.0);\\n        double x,y;\\n        int ans=0;\\n        double temp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(points[i][0]==location[0] && points[i][1]==location[1])\\n            {\\n                ans++;\\n                continue;\\n            }\\n            x= points[i][0]-location[0];\\n            y= points[i][1]-location[1];\\n            temp= atan2(y,x);\\n            temp= temp*(180)/pi;\\n            angles.push_back(temp);\\n        }\\n        sort(angles.begin(), angles.end());\\n        n=angles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            angles.push_back(angles[i]+360);\\n        }\\n        int cnt=0;\\n        int i=0, j=0;\\n        n=angles.size();\\n        double sum=0;\\n        while(j<n)\\n        {\\n            sum= angles[j]-angles[i];\\n            if(sum>angle)\\n            {\\n                while(sum>angle)\\n                {\\n                    i++;\\n                    sum= angles[j]-angles[i];\\n                }\\n            }\\n            cnt= max(cnt, j-i+1); \\n            j++;\\n        }\\n        ans=ans+cnt;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int n= points.size();\\n        vector<double>angles;\\n        double pi= acos(-1.0);\\n        double x,y;\\n        int ans=0;\\n        double temp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(points[i][0]==location[0] && points[i][1]==location[1])\\n            {\\n                ans++;\\n                continue;\\n            }\\n            x= points[i][0]-location[0];\\n            y= points[i][1]-location[1];\\n            temp= atan2(y,x);\\n            temp= temp*(180)/pi;\\n            angles.push_back(temp);\\n        }\\n        sort(angles.begin(), angles.end());\\n        n=angles.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            angles.push_back(angles[i]+360);\\n        }\\n        int cnt=0;\\n        int i=0, j=0;\\n        n=angles.size();\\n        double sum=0;\\n        while(j<n)\\n        {\\n            sum= angles[j]-angles[i];\\n            if(sum>angle)\\n            {\\n                while(sum>angle)\\n                {\\n                    i++;\\n                    sum= angles[j]-angles[i];\\n                }\\n            }\\n            cnt= max(cnt, j-i+1); \\n            j++;\\n        }\\n        ans=ans+cnt;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960562,
                "title": "sort-sliding-window",
                "content": "Sort + Sliding Window, O(NlgN + N).\\n\\n\\n# Code\\n```\\n# define M_PI           3.14159265358979323846 \\n# define ANG(a)         (a > M_PI ? a - M_PI : a) \\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int a, vector<int>& location) {\\n        int left = 0, right = 0, ans = 0, count = 0;\\n\\n        vector<double> collect;\\n        for (auto& it: points) {\\n            if (it == location) {\\n                count ++;\\n                continue;\\n            }\\n            collect.push_back(get(location, it));\\n        }\\n        sort(collect.begin(), collect.end());\\n        \\n        double angle = (double)a / 180 * M_PI;\\n        for (; left < collect.size(); ++ left) {\\n            while (right < collect.size() && collect[right] - collect[left] <= angle) {\\n                ans = max(ans, right - left + 1);\\n                right ++;\\n            }\\n            if (right == collect.size()) break;\\n        }\\n        right = 0;\\n        for (; left < collect.size(); ++ left) {\\n            while (right < collect.size() && collect[right] - collect[left] + 2 * M_PI <= angle) {\\n                ans = max(ans, right + 1 + (int)collect.size() - left);\\n                right ++;\\n            }\\n            if (right == collect.size()) break;\\n        }\\n\\n        return ans + count;\\n    }\\n\\n    double get(vector<int>& a, vector<int>& b) {\\n        double store;\\n\\n        if (a[0] == b[0]) {\\n            store =  b[1] >= a[1] ? M_PI / 2 : - M_PI / 2;\\n        } else {\\n            store = atan2(b[1] - a[1], b[0] - a[0]);\\n        }\\n               \\n        return store < 0 ? store + 2 * M_PI : store;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n# define M_PI           3.14159265358979323846 \\n# define ANG(a)         (a > M_PI ? a - M_PI : a) \\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int a, vector<int>& location) {\\n        int left = 0, right = 0, ans = 0, count = 0;\\n\\n        vector<double> collect;\\n        for (auto& it: points) {\\n            if (it == location) {\\n                count ++;\\n                continue;\\n            }\\n            collect.push_back(get(location, it));\\n        }\\n        sort(collect.begin(), collect.end());\\n        \\n        double angle = (double)a / 180 * M_PI;\\n        for (; left < collect.size(); ++ left) {\\n            while (right < collect.size() && collect[right] - collect[left] <= angle) {\\n                ans = max(ans, right - left + 1);\\n                right ++;\\n            }\\n            if (right == collect.size()) break;\\n        }\\n        right = 0;\\n        for (; left < collect.size(); ++ left) {\\n            while (right < collect.size() && collect[right] - collect[left] + 2 * M_PI <= angle) {\\n                ans = max(ans, right + 1 + (int)collect.size() - left);\\n                right ++;\\n            }\\n            if (right == collect.size()) break;\\n        }\\n\\n        return ans + count;\\n    }\\n\\n    double get(vector<int>& a, vector<int>& b) {\\n        double store;\\n\\n        if (a[0] == b[0]) {\\n            store =  b[1] >= a[1] ? M_PI / 2 : - M_PI / 2;\\n        } else {\\n            store = atan2(b[1] - a[1], b[0] - a[0]);\\n        }\\n               \\n        return store < 0 ? store + 2 * M_PI : store;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899701,
                "title": "sort-and-sweep-two-pointers",
                "content": "# Intuition\\nSort all points by their angle to you and +x, counter-clockwise. Then it\\'s quick to look around, counting points that come into view and subtracting those that go out of view.\\n\\n# Approach\\nKeep two indices i and j, move j forwards until just before the FOV ($$angle$$) to see both i and j breaches the threshold. The points i to j, inclusive, are a possible maximum to return. Increment i and repeat for all points.\\n\\nThe remaining complexity is to be able to wrap j so that you can start including/\"seeing\" points back at the start towards the end of your full turn.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log{n})$$, due to sorting\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nimport math\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        # degrees are bad for maths\\n        fov = math.radians(angle)\\n\\n        # Make the points relative to the viewer\\n        relpoints = list((p[0]- location[0], p[1]- location[1]) for p in points)\\n\\n        # count the number of points we\\'re standing on, to be added at the end\\n        standing_on = relpoints.count((0, 0))\\n\\n        # make a list of sorted angles to every point that we\\'re not standing on\\n        # uses atan2(), which automatically figures out which quadrant the angle is in and gives a full 0 to 2 pi range\\n        angles = sorted(math.atan2(p[0], p[1]) for p in relpoints if p != (0, 0))\\n\\n        # returns angles[i], accounting for wrapping back to the start and adding 2 pi each time it does\\n        wrap_angle = lambda i: angles[i % len(angles)] + (i // len(angles)) * math.pi * 2.0\\n\\n        # Sweep a view in a full circle (all points) between angles[i] and angles[j] such that it\\'s never bigger than fov\\n        j = 0\\n        result = 0\\n        for i, start in enumerate(angles):\\n            # increase j until incrementing one more time would breach the fov angle\\n            while j + 1 - i < len(angles) and wrap_angle(j + 1) - start <= fov:\\n                j += 1\\n\\n                # debugging\\n                #print(i, math.degrees(start), j, math.degrees(angles[j % len(angles)]))\\n            \\n            # Placing point i on the right, the max points we can currently see is from i to j inclusive\\n            result = max(result, j - i + 1)\\n\\n            #print(i, j)\\n\\n        return result + standing_on\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        # degrees are bad for maths\\n        fov = math.radians(angle)\\n\\n        # Make the points relative to the viewer\\n        relpoints = list((p[0]- location[0], p[1]- location[1]) for p in points)\\n\\n        # count the number of points we\\'re standing on, to be added at the end\\n        standing_on = relpoints.count((0, 0))\\n\\n        # make a list of sorted angles to every point that we\\'re not standing on\\n        # uses atan2(), which automatically figures out which quadrant the angle is in and gives a full 0 to 2 pi range\\n        angles = sorted(math.atan2(p[0], p[1]) for p in relpoints if p != (0, 0))\\n\\n        # returns angles[i], accounting for wrapping back to the start and adding 2 pi each time it does\\n        wrap_angle = lambda i: angles[i % len(angles)] + (i // len(angles)) * math.pi * 2.0\\n\\n        # Sweep a view in a full circle (all points) between angles[i] and angles[j] such that it\\'s never bigger than fov\\n        j = 0\\n        result = 0\\n        for i, start in enumerate(angles):\\n            # increase j until incrementing one more time would breach the fov angle\\n            while j + 1 - i < len(angles) and wrap_angle(j + 1) - start <= fov:\\n                j += 1\\n\\n                # debugging\\n                #print(i, math.degrees(start), j, math.degrees(angles[j % len(angles)]))\\n            \\n            # Placing point i on the right, the max points we can currently see is from i to j inclusive\\n            result = max(result, j - i + 1)\\n\\n            #print(i, j)\\n\\n        return result + standing_on\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894291,
                "title": "plain-and-simple-polar-coordinates",
                "content": "```\\n#include <cmath>\\n\\ntypedef int Quadrant;\\n#define I 1\\n#define II 2\\n#define III 3\\n#define IV 4\\nstatic inline Quadrant quadrant(int x, int y) {\\n    if (x >= 0 && y >= 0) return I;\\n    if (x < 0 && y > 0) return II;\\n    if (x <= 0 && y <= 0) return III;\\n    return IV;\\n}\\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle_deg, vector<int>& location) {\\n        if (points.size() == 0) return 0;\\n        // Due to the way that atan works in C++ (between neg pi/2 and pos pi/2, we need to\\n        // add pi or 2pi sometimes)\\n        vector<vector<int>> shifted_points;\\n        for (vector<int>& point : points) {\\n            if (point[0] != location[0] || point[1] != location[1]) {\\n                shifted_points.push_back(vector<int>{point[0] - location[0], point[1] - location[1]});\\n            }\\n        }\\n\\n        int N = shifted_points.size(); \\n        int max_cnt = 0;\\n        int superposition_cnt = points.size() - shifted_points.size();\\n        double angle = M_PI * angle_deg / 180.0;\\n\\n        vector<double> angles(N);\\n        for (int i = 0; i < N; i++) {\\n            // Everyone is as if the guy was at 0,0 \\n            int pointy = shifted_points[i][1];\\n            int pointx = shifted_points[i][0];\\n            // Vertical bar gets positive angle because tangent would yield positive ratio\\n            // (and then quadrants will find how to shift)\\n            angles[i] = pointx == 0 ? M_PI_2 : atan(((double)(pointy))/pointx);\\n            Quadrant q = quadrant(pointx, pointy);\\n            if (angles[i] >= 0) {\\n                assert(q == I || q == III);\\n                if (q == III) {\\n                    angles[i] += M_PI;\\n                }\\n            } else {\\n                cout << pointx << \" \" << pointy << \"\\\\n\";\\n                assert(q == II || q == IV);\\n                if (q == II) {\\n                    angles[i] += M_PI;\\n                } else {\\n                    angles[i] += 2 * M_PI;\\n                }\\n            }\\n        }\\n        sort(angles.begin(), angles.end());\\n        for (int i = 0; i < N; i++) { angles.push_back(angles[i] + 2 * M_PI); }\\n\\n        int hi = 1;\\n        for (int lo = 0; lo < N; lo++) {\\n            while (hi <= lo || (hi < N + lo && angles[hi] <= angles[lo] + angle)) { hi++; }\\n            max_cnt = max(max_cnt, hi - lo);\\n        }\\n        return max_cnt + superposition_cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <cmath>\\n\\ntypedef int Quadrant;\\n#define I 1\\n#define II 2\\n#define III 3\\n#define IV 4\\nstatic inline Quadrant quadrant(int x, int y) {\\n    if (x >= 0 && y >= 0) return I;\\n    if (x < 0 && y > 0) return II;\\n    if (x <= 0 && y <= 0) return III;\\n    return IV;\\n}\\n\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle_deg, vector<int>& location) {\\n        if (points.size() == 0) return 0;\\n        // Due to the way that atan works in C++ (between neg pi/2 and pos pi/2, we need to\\n        // add pi or 2pi sometimes)\\n        vector<vector<int>> shifted_points;\\n        for (vector<int>& point : points) {\\n            if (point[0] != location[0] || point[1] != location[1]) {\\n                shifted_points.push_back(vector<int>{point[0] - location[0], point[1] - location[1]});\\n            }\\n        }\\n\\n        int N = shifted_points.size(); \\n        int max_cnt = 0;\\n        int superposition_cnt = points.size() - shifted_points.size();\\n        double angle = M_PI * angle_deg / 180.0;\\n\\n        vector<double> angles(N);\\n        for (int i = 0; i < N; i++) {\\n            // Everyone is as if the guy was at 0,0 \\n            int pointy = shifted_points[i][1];\\n            int pointx = shifted_points[i][0];\\n            // Vertical bar gets positive angle because tangent would yield positive ratio\\n            // (and then quadrants will find how to shift)\\n            angles[i] = pointx == 0 ? M_PI_2 : atan(((double)(pointy))/pointx);\\n            Quadrant q = quadrant(pointx, pointy);\\n            if (angles[i] >= 0) {\\n                assert(q == I || q == III);\\n                if (q == III) {\\n                    angles[i] += M_PI;\\n                }\\n            } else {\\n                cout << pointx << \" \" << pointy << \"\\\\n\";\\n                assert(q == II || q == IV);\\n                if (q == II) {\\n                    angles[i] += M_PI;\\n                } else {\\n                    angles[i] += 2 * M_PI;\\n                }\\n            }\\n        }\\n        sort(angles.begin(), angles.end());\\n        for (int i = 0; i < N; i++) { angles.push_back(angles[i] + 2 * M_PI); }\\n\\n        int hi = 1;\\n        for (int lo = 0; lo < N; lo++) {\\n            while (hi <= lo || (hi < N + lo && angles[hi] <= angles[lo] + angle)) { hi++; }\\n            max_cnt = max(max_cnt, hi - lo);\\n        }\\n        return max_cnt + superposition_cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2795046,
                "title": "python-o-nlogn-transfer-to-polar-coordinates-sort-by-angle-and-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we calulate the polar coordinates angle of all points, with the location as origin point. Then sort all points by angle. Two pointer linear scan is later used, which time comlpexity is O(N). During the process, we keep *last* to mark the previous angle between i and j to avoid j cross i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom math import atan2, pi\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        origin, cnt = 0, defaultdict(int)\\n        for x, y in points:\\n            if x == location[0] and y == location[1]: origin += 1\\n            else: cnt[atan2(y - location[1], x - location[0])] += 1\\n        cnt = sorted(cnt.items())\\n        ans, cur, j = 0, 0, 0\\n        angle *= pi / 180\\n        for i in range(len(cnt)):\\n            if i > 0: cur -= cnt[i - 1][1]\\n            j, last = max(j, i), float(\\'-inf\\')\\n            while  True:\\n                iangle = cnt[j % len(cnt)][0] - cnt[i][0]\\n                if iangle < 0: iangle += 2 * pi\\n                if iangle <= last or iangle > angle: break\\n                last = iangle\\n                cur += cnt[j % len(cnt)][1]\\n                j += 1\\n            ans = max(ans, cur)\\n        return ans + origin\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom math import atan2, pi\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        origin, cnt = 0, defaultdict(int)\\n        for x, y in points:\\n            if x == location[0] and y == location[1]: origin += 1\\n            else: cnt[atan2(y - location[1], x - location[0])] += 1\\n        cnt = sorted(cnt.items())\\n        ans, cur, j = 0, 0, 0\\n        angle *= pi / 180\\n        for i in range(len(cnt)):\\n            if i > 0: cur -= cnt[i - 1][1]\\n            j, last = max(j, i), float(\\'-inf\\')\\n            while  True:\\n                iangle = cnt[j % len(cnt)][0] - cnt[i][0]\\n                if iangle < 0: iangle += 2 * pi\\n                if iangle <= last or iangle > angle: break\\n                last = iangle\\n                cur += cnt[j % len(cnt)][1]\\n                j += 1\\n            ans = max(ans, cur)\\n        return ans + origin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692298,
                "title": "c-compact",
                "content": "First move the position to origin, and eliminate all the points on origin. Those points will be added to final result no matter how many other points are included.\\nThen form a sorted list of angles the points make with the X axis. I used lower and upper bound to find the range of points within the view angle, for which each point\\'s angle was added twice - once the actual angle, again the angle +360.\\nN.B. using multiset with \\'distance\\' timed out. So had to use multimap tracking index positions.\\n```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n      int ret = 0, pre = 0;\\n      multimap<double,int> angles;\\n      double pi = 3.14159;\\n      // shift location to origin\\n      for(auto& p:points){\\n        p[0] -= location[0];\\n        p[1] -= location[1];\\n        if(p[0] == 0 && p[1] == 0){pre++;continue;}\\n        double aa = atan2(double(p[1]),double(p[0]))*180.0/pi;\\n        angles.insert({aa,0});\\n        angles.insert({360.0+aa,0});\\n      }\\n      if(angles.empty())return pre;\\n      int idx = 0;\\n      for(auto&e:angles)e.second = idx++;\\n      \\n      for(auto& p:points){\\n        double aa = atan2(double(p[1]),double(p[0]))*180.0/pi;\\n        double bb = aa + double(angle);\\n        auto X = angles.lower_bound(aa);\\n        auto Y = angles.upper_bound(bb);\\n        int dist = Y->second - X->second;\\n        ret = max(ret,dist);\\n      }\\n      return ret+pre;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n      int ret = 0, pre = 0;\\n      multimap<double,int> angles;\\n      double pi = 3.14159;\\n      // shift location to origin\\n      for(auto& p:points){\\n        p[0] -= location[0];\\n        p[1] -= location[1];\\n        if(p[0] == 0 && p[1] == 0){pre++;continue;}\\n        double aa = atan2(double(p[1]),double(p[0]))*180.0/pi;\\n        angles.insert({aa,0});\\n        angles.insert({360.0+aa,0});\\n      }\\n      if(angles.empty())return pre;\\n      int idx = 0;\\n      for(auto&e:angles)e.second = idx++;\\n      \\n      for(auto& p:points){\\n        double aa = atan2(double(p[1]),double(p[0]))*180.0/pi;\\n        double bb = aa + double(angle);\\n        auto X = angles.lower_bound(aa);\\n        auto Y = angles.upper_bound(bb);\\n        int dist = Y->second - X->second;\\n        ret = max(ret,dist);\\n      }\\n      return ret+pre;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633318,
                "title": "simple-hindi-solution-ezz-language-c-code-india",
                "content": "Iska ek simple question bnae to ye bnta h ki tumhe ek array dia h usme angles dale h , or ek integer value di h angle ki tumko btana h ki kitne max angle is vale me aa skte h , ye problem hm sliding window se kr skte h -\\nsort array kr do or suru se start ho jao , start =0, ab chekc kro arr[i]-arr[start]<=angle h to res me store kr le window size agar bda ho jata h to start ko ++ krte jao jb tk difference less than angle na ho jata ;\\n\\nThis problem :- isme hme point diye h to inko angle me change kr lo respect to location point .\\n\\nek corner case ho skta h isliye mne 2 bar traversal ki h window size wale array ko for example \\n0,1,2,359 angles array and angle ki value 3 h , uper wali approach se to iski value 3 aani chahiye :- 0,1,2\\nbut isme 359 bhi pass me h to 0 ke iska difference 1 h zero ke sath to ye bhi include hoga to mne sb me 360 add kr dia \\n0,1,2,359,0+359,1+359,2+359,359+359\\nresulted array :- 0,1,2,**359,359,360,361**,718 :- ans window me ye store ho jaega \\n\\n```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int n=points.size();\\n        int x=location[0];\\n        int y=location[1];\\n        vector<double>angles;\\n        int same=0;\\n        for(int i=0;i<n;i++){\\n            if(x==points[i][0] && y==points[i][1]){\\n                same++;\\n                continue;\\n            }\\n            int dx=points[i][0]-x;\\n            int dy=points[i][1]-y;\\n            double ang = atan2(dy,dx) * 180.0 /M_PI;\\n                if(ang<0){\\n                    ang+=360;\\n                }\\n            angles.push_back(ang);\\n        }\\n        sort(angles.begin(),angles.end());\\n        int xi=angles.size();\\n        for(int i=0;i<xi;i++){\\n            angles.push_back(angles[i]+360);\\n        }\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<angles.size()){\\n            while(angles[j]-angles[i]>angle){\\n                i++;\\n            }\\n         ans=max(ans,j-i+1);\\n         j++;  \\n       }\\n       return ans+same;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int n=points.size();\\n        int x=location[0];\\n        int y=location[1];\\n        vector<double>angles;\\n        int same=0;\\n        for(int i=0;i<n;i++){\\n            if(x==points[i][0] && y==points[i][1]){\\n                same++;\\n                continue;\\n            }\\n            int dx=points[i][0]-x;\\n            int dy=points[i][1]-y;\\n            double ang = atan2(dy,dx) * 180.0 /M_PI;\\n                if(ang<0){\\n                    ang+=360;\\n                }\\n            angles.push_back(ang);\\n        }\\n        sort(angles.begin(),angles.end());\\n        int xi=angles.size();\\n        for(int i=0;i<xi;i++){\\n            angles.push_back(angles[i]+360);\\n        }\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<angles.size()){\\n            while(angles[j]-angles[i]>angle){\\n                i++;\\n            }\\n         ans=max(ans,j-i+1);\\n         j++;  \\n       }\\n       return ans+same;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568849,
                "title": "python-90-faster-95-less-space",
                "content": "![image](https://assets.leetcode.com/users/images/9938ddff-d0b4-46b6-ab61-77e102bc73e4_1663034456.6296792.png)\\n\\n```\\nclass Solution:\\n    \\n    def getAngle(self,point1,point2):\\n        # get the counterclockwise angle of the vector from point1 to point2\\n        \\n        delta_y, delta_x = point2[1] - point1[1], point2[0] - point1[0]\\n        \\n        if delta_x > 0 and delta_y >= 0: # quadrant 1\\n            return math.atan(delta_y/delta_x)*180/math.pi\\n        elif delta_y >= 0 and delta_x < 0 : # quadrant 2\\n            return (math.pi - math.atan(-delta_y/delta_x))*180/math.pi\\n        elif delta_y <= 0 and delta_x < 0: # quadrant 3\\n            return (math.pi + math.atan(delta_y/delta_x))*180/math.pi\\n        elif delta_y <= 0 and delta_x > 0: # quadrant 4\\n            return (2 * math.pi - math.atan(-delta_y/delta_x))*180/math.pi\\n        elif delta_x == 0:\\n            if delta_y > 0:\\n                return 90\\n            else:\\n                return 270\\n            \\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        \\n        angles = [] # use to store the polar angles of each point from location (pseudo-origin)\\n        origin = 0 # use to encode if origin point is included in points\\n        \\n        for point in points:\\n            if point == location:\\n                origin += 1\\n            else:\\n                angles.append(self.getAngle(location,point))\\n        \\n        for current_angle in angles:\\n            if current_angle > 180: # handle wraparound for angles > 180 (in 3rd and 4th quadrants)\\n                angles.append(- (360-current_angle) )\\n        \\n        angles.sort()\\n        \\n        i = 0\\n        max_points = 0\\n        \\n        for j in range(len(angles)):    \\n            while angles[j]-angles[i] > angle and i<j:\\n                i += 1\\n            \\n            max_points = max(max_points,j-i+1)\\n        \\n        return max_points + origin\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def getAngle(self,point1,point2):\\n        # get the counterclockwise angle of the vector from point1 to point2\\n        \\n        delta_y, delta_x = point2[1] - point1[1], point2[0] - point1[0]\\n        \\n        if delta_x > 0 and delta_y >= 0: # quadrant 1\\n            return math.atan(delta_y/delta_x)*180/math.pi\\n        elif delta_y >= 0 and delta_x < 0 : # quadrant 2\\n            return (math.pi - math.atan(-delta_y/delta_x))*180/math.pi\\n        elif delta_y <= 0 and delta_x < 0: # quadrant 3\\n            return (math.pi + math.atan(delta_y/delta_x))*180/math.pi\\n        elif delta_y <= 0 and delta_x > 0: # quadrant 4\\n            return (2 * math.pi - math.atan(-delta_y/delta_x))*180/math.pi\\n        elif delta_x == 0:\\n            if delta_y > 0:\\n                return 90\\n            else:\\n                return 270\\n            \\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        \\n        angles = [] # use to store the polar angles of each point from location (pseudo-origin)\\n        origin = 0 # use to encode if origin point is included in points\\n        \\n        for point in points:\\n            if point == location:\\n                origin += 1\\n            else:\\n                angles.append(self.getAngle(location,point))\\n        \\n        for current_angle in angles:\\n            if current_angle > 180: # handle wraparound for angles > 180 (in 3rd and 4th quadrants)\\n                angles.append(- (360-current_angle) )\\n        \\n        angles.sort()\\n        \\n        i = 0\\n        max_points = 0\\n        \\n        for j in range(len(angles)):    \\n            while angles[j]-angles[i] > angle and i<j:\\n                i += 1\\n            \\n            max_points = max(max_points,j-i+1)\\n        \\n        return max_points + origin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513848,
                "title": "javascript-solution-faster-than-most-submissions",
                "content": "I just found this Github repository with solutions to Leetcode problems https://github.com/AnasImloul/Leetcode-solutions\\nThe ability to find every solution in one location is very helpful, I hope it helps you too\\n```\\n// basically First i transform my points into degrees in regards to my location as the center\\n// I need to perform a sliding window to see how many points can fit within my window of length\\n// angle \\nvar visiblePoints = function(points, angle, location) {\\n    \\n    //Math.atan2(y,x) returns the ANGLE in RADIANS between the point (X,Y), the CENTER (0,0) and x\\'x\\n    // so Math.atan2(5,5) * (180/Math.pi) === 45 //transforms it from radians to degrees instead\\n    let [sx,sy]=location\\n    let onCenter=points.filter(([x,y])=>(x==sx&&y==sy)).length //if i m standing on a point i always count it\\n\\n    points=points.filter(([x,y])=>!(x==sx&&y==sy)) //other than that i dont want it messing with my result\\n\\n                 .map(([x,y])=>{\\n                    // i need to transform my center from (0,0) to location, hence (y-sy,x-sx)\\n                         return Math.atan2(y-sy,x-sx)*(180/Math.PI) //returns the degrees\\n                    })\\n                 .sort((a,b)=>a-b) \\n\\n    //I will now perform the circular array duplication trick in order to consider points from different view\\n    points=[...points,...points.map(d=>d+360)] \\n    // so for example if a point is 340, it can go with a point that is 15\\n    // example : [0,60,230,250,359], angle=200\\n    // would become     [0,60,230,250,359,360,420,590,610,719]\\n    // would allow me to pick  *   *   *   *   * ,which is practically [230,250,359,0,60] \\n    // (every element of my starting array), which are obviously visible with anangle fo 200 deg\\n\\n\\n    //now i will perform a sliding window that tracks the points visible from my current degree-my angle degrees\\n    let start=0,n=points.length,result=0\\n    for (let end = 0; end < n; end++) {\\n        while(start<end&&points[start]<points[end]-angle) //if the point of start is no bueno\\n            start++ // shrink the window until all the points are within angle degrees \\n        result=Math.max(result,end-start+1)\\n    }\\n    return result+onCenter //the points i can see + the ones i ms tanding on\\n\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// basically First i transform my points into degrees in regards to my location as the center\\n// I need to perform a sliding window to see how many points can fit within my window of length\\n// angle \\nvar visiblePoints = function(points, angle, location) {\\n    \\n    //Math.atan2(y,x) returns the ANGLE in RADIANS between the point (X,Y), the CENTER (0,0) and x\\'x\\n    // so Math.atan2(5,5) * (180/Math.pi) === 45 //transforms it from radians to degrees instead\\n    let [sx,sy]=location\\n    let onCenter=points.filter(([x,y])=>(x==sx&&y==sy)).length //if i m standing on a point i always count it\\n\\n    points=points.filter(([x,y])=>!(x==sx&&y==sy)) //other than that i dont want it messing with my result\\n\\n                 .map(([x,y])=>{\\n                    // i need to transform my center from (0,0) to location, hence (y-sy,x-sx)\\n                         return Math.atan2(y-sy,x-sx)*(180/Math.PI) //returns the degrees\\n                    })\\n                 .sort((a,b)=>a-b) \\n\\n    //I will now perform the circular array duplication trick in order to consider points from different view\\n    points=[...points,...points.map(d=>d+360)] \\n    // so for example if a point is 340, it can go with a point that is 15\\n    // example : [0,60,230,250,359], angle=200\\n    // would become     [0,60,230,250,359,360,420,590,610,719]\\n    // would allow me to pick  *   *   *   *   * ,which is practically [230,250,359,0,60] \\n    // (every element of my starting array), which are obviously visible with anangle fo 200 deg\\n\\n\\n    //now i will perform a sliding window that tracks the points visible from my current degree-my angle degrees\\n    let start=0,n=points.length,result=0\\n    for (let end = 0; end < n; end++) {\\n        while(start<end&&points[start]<points[end]-angle) //if the point of start is no bueno\\n            start++ // shrink the window until all the points are within angle degrees \\n        result=Math.max(result,end-start+1)\\n    }\\n    return result+onCenter //the points i can see + the ones i ms tanding on\\n\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2430887,
                "title": "maximum-number-of-visible-points-python3-using-angles",
                "content": "```\\nfrom queue import deque\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        safe_points = 0\\n        angles = []\\n        ans = 0\\n        \\n        for point in points:\\n            if(point == location):\\n                safe_points += 1\\n            else:\\n                # Get angle for all locations and sort the array\\n                angles.append(self.get_angle(location, point))\\n        \\n        angles.sort()\\n        \\n        # Using queue enter values and remove them if the condition is false\\n        q = deque()\\n        for a in angles:\\n            q.append(a)\\n            while(a - q[0] > angle):\\n                q.popleft()\\n            ans = max(ans, len(q))\\n\\n        # Another loop to capture the remaining area\\n        for a in angles:\\n            a += 360\\n            q.append(a)\\n            while(a - q[0] > angle):\\n                q.popleft()\\n            ans = max(ans, len(q))\\n\\n        return ans + safe_points\\n\\n    def get_angle(self, location, point):\\n        angle = math.atan2(point[0] - location[0], point[1] - location[1]) / (2 * math.pi) * 360\\n\\n        if angle < 0:\\n            angle += 360\\n        return angle\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```\\nfrom queue import deque\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        safe_points = 0\\n        angles = []\\n        ans = 0\\n        \\n        for point in points:\\n            if(point == location):\\n                safe_points += 1\\n            else:\\n                # Get angle for all locations and sort the array\\n                angles.append(self.get_angle(location, point))\\n        \\n        angles.sort()\\n        \\n        # Using queue enter values and remove them if the condition is false\\n        q = deque()\\n        for a in angles:\\n            q.append(a)\\n            while(a - q[0] > angle):\\n                q.popleft()\\n            ans = max(ans, len(q))\\n\\n        # Another loop to capture the remaining area\\n        for a in angles:\\n            a += 360\\n            q.append(a)\\n            while(a - q[0] > angle):\\n                q.popleft()\\n            ans = max(ans, len(q))\\n\\n        return ans + safe_points\\n\\n    def get_angle(self, location, point):\\n        angle = math.atan2(point[0] - location[0], point[1] - location[1]) / (2 * math.pi) * 360\\n\\n        if angle < 0:\\n            angle += 360\\n        return angle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417450,
                "title": "python-simple-sliding-window-solution",
                "content": "I see some solutions duplicate the size of array to accomodate the circle. Here I use modulo instead.\\n\\n```\\nfrom math import atan2, degrees\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        pointDegrees = [degrees(atan2(point[1] - location[1], point[0] - location[0])) for point in points if point[0] != location[0] or point[1] != location[1]]\\n        pointDegrees.sort()\\n        \\n        j = 0\\n        result = 0\\n        for i in range(len(pointDegrees)):\\n            while (pointDegrees[j % len(pointDegrees)] - pointDegrees[i]) % 360 <= angle and j < i + len(pointDegrees):\\n                j += 1\\n            result = max(result, j - i)\\n            if result == len(pointDegrees):\\n                break\\n        return result + len(points) - len(pointDegrees)\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nfrom math import atan2, degrees\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        pointDegrees = [degrees(atan2(point[1] - location[1], point[0] - location[0])) for point in points if point[0] != location[0] or point[1] != location[1]]\\n        pointDegrees.sort()\\n        \\n        j = 0\\n        result = 0\\n        for i in range(len(pointDegrees)):\\n            while (pointDegrees[j % len(pointDegrees)] - pointDegrees[i]) % 360 <= angle and j < i + len(pointDegrees):\\n                j += 1\\n            result = max(result, j - i)\\n            if result == len(pointDegrees):\\n                break\\n        return result + len(points) - len(pointDegrees)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297039,
                "title": "java-sliding-window-faster-than-99-82-less-than-99-11-memory",
                "content": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int same = 0;\\n        for(List<Integer> list : points){\\n            if(list.get(0) == location.get(0) && list.get(1) == location.get(1)){\\n                same++;\\n            }\\n        }\\n        double[] theta = new double[points.size() - same];\\n        int ind = 0;\\n        double px = (double)location.get(0);\\n        double py = (double)location.get(1);\\n        for(List<Integer> list : points){\\n            if(!(list.get(0) == location.get(0) && list.get(1) == location.get(1))){\\n                double lx = (double)list.get(0) - px;\\n                double ly = (double)list.get(1) - py;\\n                theta[ind] = Math.atan2(ly, lx);\\n                ind++;\\n            }\\n            \\n        }\\n        Arrays.sort(theta);\\n        double rad = Math.toRadians((double)angle);\\n        double[] twice = new double[theta.length*2];\\n        for(int i = 0; i < twice.length; i++){\\n            twice[i] = theta[i%theta.length];\\n        }\\n        for(int i = theta.length; i < twice.length; i++){\\n            twice[i] += 2.0 * Math.PI;\\n        }\\n        int max = 0;\\n        int lead = 0;\\n        int trail = 0;\\n        while(lead < twice.length){\\n            if(lead == trail){\\n                max = Math.max(max, 1);\\n                lead++;\\n                continue;\\n            }\\n            if(twice[lead] - twice[trail] <= rad){\\n                max = Math.max(max, lead - trail + 1);\\n                lead++;\\n            }else{\\n                trail++;\\n            }\\n        }\\n        return max+same;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int same = 0;\\n        for(List<Integer> list : points){\\n            if(list.get(0) == location.get(0) && list.get(1) == location.get(1)){\\n                same++;\\n            }\\n        }\\n        double[] theta = new double[points.size() - same];\\n        int ind = 0;\\n        double px = (double)location.get(0);\\n        double py = (double)location.get(1);\\n        for(List<Integer> list : points){\\n            if(!(list.get(0) == location.get(0) && list.get(1) == location.get(1))){\\n                double lx = (double)list.get(0) - px;\\n                double ly = (double)list.get(1) - py;\\n                theta[ind] = Math.atan2(ly, lx);\\n                ind++;\\n            }\\n            \\n        }\\n        Arrays.sort(theta);\\n        double rad = Math.toRadians((double)angle);\\n        double[] twice = new double[theta.length*2];\\n        for(int i = 0; i < twice.length; i++){\\n            twice[i] = theta[i%theta.length];\\n        }\\n        for(int i = theta.length; i < twice.length; i++){\\n            twice[i] += 2.0 * Math.PI;\\n        }\\n        int max = 0;\\n        int lead = 0;\\n        int trail = 0;\\n        while(lead < twice.length){\\n            if(lead == trail){\\n                max = Math.max(max, 1);\\n                lead++;\\n                continue;\\n            }\\n            if(twice[lead] - twice[trail] <= rad){\\n                max = Math.max(max, lead - trail + 1);\\n                lead++;\\n            }else{\\n                trail++;\\n            }\\n        }\\n        return max+same;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201973,
                "title": "c-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double getAngle(int x, int y)\\n    {\\n        return atan2(y, x) * (180 / M_PI);\\n    }\\n    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) \\n    {\\n        int result = 0;\\n        vector<double> angels;\\n        for (int i = 0; i < points.size(); i++)\\n        {\\n            int xDiff = points[i][0] - location[0];\\n            int yDiff = points[i][1] - location[1];\\n            \\n            if (xDiff == 0 && yDiff == 0)\\n            {\\n                result++;\\n            }\\n            else\\n            {\\n                double angle = getAngle(xDiff, yDiff);\\n                if (angle < 0)\\n                {\\n                    angle += 360;\\n                }\\n                \\n                angels.push_back(angle);\\n            }\\n        }\\n        \\n        sort(angels.begin(), angels.end());\\n        int n = angels.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            angels.push_back(angels[i] + 360);\\n        }\\n        \\n        int start = 0;\\n        int end = 0;\\n        int maxPoints = 0;\\n        for (end = 0; end < 2*n; end++)\\n        {\\n            while (angels[end] - angels[start] > (double)angle)\\n            {\\n                start++;\\n            }\\n            \\n            maxPoints = max(maxPoints, end - start + 1);\\n        }\\n        \\n        return result + maxPoints;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double getAngle(int x, int y)\\n    {\\n        return atan2(y, x) * (180 / M_PI);\\n    }\\n    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) \\n    {\\n        int result = 0;\\n        vector<double> angels;\\n        for (int i = 0; i < points.size(); i++)\\n        {\\n            int xDiff = points[i][0] - location[0];\\n            int yDiff = points[i][1] - location[1];\\n            \\n            if (xDiff == 0 && yDiff == 0)\\n            {\\n                result++;\\n            }\\n            else\\n            {\\n                double angle = getAngle(xDiff, yDiff);\\n                if (angle < 0)\\n                {\\n                    angle += 360;\\n                }\\n                \\n                angels.push_back(angle);\\n            }\\n        }\\n        \\n        sort(angels.begin(), angels.end());\\n        int n = angels.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            angels.push_back(angels[i] + 360);\\n        }\\n        \\n        int start = 0;\\n        int end = 0;\\n        int maxPoints = 0;\\n        for (end = 0; end < 2*n; end++)\\n        {\\n            while (angels[end] - angels[start] > (double)angle)\\n            {\\n                start++;\\n            }\\n            \\n            maxPoints = max(maxPoints, end - start + 1);\\n        }\\n        \\n        return result + maxPoints;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155974,
                "title": "js-prefix-sum",
                "content": "```\\nvar visiblePoints = function (points, angle, location) {\\n\\tlet pointsByAngle = {},\\tpointAngle,\\ti = 0, rangeStart = -1,\\trangeEnd = 0, \\n\\t    max = 0, numberOfPointsAtMylocation = 0;\\n\\tconst [x1, y1] = location,\\n\\t\\tprefixSum = { [-1]: 0 },\\n\\t\\tgetAngle = (x2, y2) => {\\n\\t\\t\\t//if point is equal to my location, I have to add it to every range, because it is always visible\\n\\t\\t\\tif (x1 === x2 && y1 === y2) {\\n\\t\\t\\t\\tnumberOfPointsAtMylocation++;\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tconst angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\\n\\t\\t\\treturn angle < 0 ? angle + 360 : angle;\\n\\t\\t};\\n\\t//aggregate points according to their angles\\n\\tfor (const point of points) {\\n\\t\\tpointAngle = getAngle(...point);\\n\\t\\tif (pointAngle === false) continue;\\n\\t\\tpointsByAngle[pointAngle]\\n\\t\\t\\t? pointsByAngle[pointAngle][1]++\\n\\t\\t\\t: (pointsByAngle[pointAngle] = [pointAngle, 1]);\\n\\t}\\n\\tpointsByAngle = Object.values(pointsByAngle).sort((a, b) => a[0] - b[0]);\\n\\tif (!pointsByAngle.length) return numberOfPointsAtMylocation;\\n\\t//max range may start at last angle, so add points between last angle and last angle + angle\\n\\tconst lastIndex = pointsByAngle.length - 1,\\n\\t\\tcircularLastAngle = (pointsByAngle[lastIndex][0] + angle) % 360;\\n\\twhile (pointsByAngle[i][0] <= circularLastAngle)\\n\\t\\tpointsByAngle.push([pointsByAngle[i][0] + 360, pointsByAngle[i++][1]]);\\n\\t//prefixSum\\n\\tfor (i = 0; i < pointsByAngle.length; i++)\\n\\t\\tprefixSum[i] = prefixSum[i - 1] + pointsByAngle[i][1];\\n\\twhile (rangeStart++ < lastIndex) {\\n\\t\\tpointAngle = pointsByAngle[rangeStart][0] + angle;\\n\\t\\twhile (pointsByAngle[rangeEnd] && pointsByAngle[rangeEnd][0] <= pointAngle)\\n\\t\\t\\trangeEnd++;\\n\\t\\t//number of points in the range\\n\\t\\tmax = Math.max(max, prefixSum[rangeEnd - 1] - prefixSum[rangeStart - 1]);\\n\\t}\\n\\treturn max + numberOfPointsAtMylocation;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar visiblePoints = function (points, angle, location) {\\n\\tlet pointsByAngle = {},\\tpointAngle,\\ti = 0, rangeStart = -1,\\trangeEnd = 0, \\n\\t    max = 0, numberOfPointsAtMylocation = 0;\\n\\tconst [x1, y1] = location,\\n\\t\\tprefixSum = { [-1]: 0 },\\n\\t\\tgetAngle = (x2, y2) => {\\n\\t\\t\\t//if point is equal to my location, I have to add it to every range, because it is always visible\\n\\t\\t\\tif (x1 === x2 && y1 === y2) {\\n\\t\\t\\t\\tnumberOfPointsAtMylocation++;\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tconst angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);\\n\\t\\t\\treturn angle < 0 ? angle + 360 : angle;\\n\\t\\t};\\n\\t//aggregate points according to their angles\\n\\tfor (const point of points) {\\n\\t\\tpointAngle = getAngle(...point);\\n\\t\\tif (pointAngle === false) continue;\\n\\t\\tpointsByAngle[pointAngle]\\n\\t\\t\\t? pointsByAngle[pointAngle][1]++\\n\\t\\t\\t: (pointsByAngle[pointAngle] = [pointAngle, 1]);\\n\\t}\\n\\tpointsByAngle = Object.values(pointsByAngle).sort((a, b) => a[0] - b[0]);\\n\\tif (!pointsByAngle.length) return numberOfPointsAtMylocation;\\n\\t//max range may start at last angle, so add points between last angle and last angle + angle\\n\\tconst lastIndex = pointsByAngle.length - 1,\\n\\t\\tcircularLastAngle = (pointsByAngle[lastIndex][0] + angle) % 360;\\n\\twhile (pointsByAngle[i][0] <= circularLastAngle)\\n\\t\\tpointsByAngle.push([pointsByAngle[i][0] + 360, pointsByAngle[i++][1]]);\\n\\t//prefixSum\\n\\tfor (i = 0; i < pointsByAngle.length; i++)\\n\\t\\tprefixSum[i] = prefixSum[i - 1] + pointsByAngle[i][1];\\n\\twhile (rangeStart++ < lastIndex) {\\n\\t\\tpointAngle = pointsByAngle[rangeStart][0] + angle;\\n\\t\\twhile (pointsByAngle[rangeEnd] && pointsByAngle[rangeEnd][0] <= pointAngle)\\n\\t\\t\\trangeEnd++;\\n\\t\\t//number of points in the range\\n\\t\\tmax = Math.max(max, prefixSum[rangeEnd - 1] - prefixSum[rangeStart - 1]);\\n\\t}\\n\\treturn max + numberOfPointsAtMylocation;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2135758,
                "title": "rust-sliding-window",
                "content": "\\n### Sliding window\\n\\n* Use `arctan2` to calculate the relative angle of each point to the origin\\n* Use a sliding window to maintain a view of X degrees\\n* Loop twice over the array in order to handle the case where there points near\\n  0 degrees and near 360 degrees\\n\\n```rust\\nconst ACCURACY: f64 = 0.000_000_000_001;\\n\\npub fn visible_points(points: Vec<Vec<i32>>, angle: i32, origin: Vec<i32>) -> i32 {\\n    if points.is_empty() {\\n        return 0;\\n    }\\n\\n    let field_of_view = ACCURACY + angle as f64;\\n\\n    let mut origin_in_points = 0;\\n    let mut angles_from_origin = points\\n        .iter()\\n        // Count any points that overlap the origin point and always add them to the answer\\n        .inspect(|x| {\\n            if origin[0] == x[0] && origin[1] == x[1] {\\n                origin_in_points += 1;\\n            }\\n        })\\n        // Skip any points that are the same as the origin point,\\n        //because they are always in the FoV regardless of the angle\\n        .filter(|x| origin[0] != x[0] || origin[1] != x[1])\\n        .map(|p| {\\n            let dx = (p[0] - origin[0]) as f64;\\n            let dy = (p[1] - origin[1]) as f64;\\n            dy.atan2(dx)\\n        })\\n        // Normalize the angle to be in the range [0; TAU)\\n        .map(|radians| (radians + std::f64::consts::TAU) % std::f64::consts::TAU)\\n        // Use degrees, because it\\'s easier to visualize and debug\\n        .map(|radians| radians.to_degrees())\\n        .collect::<Vec<_>>();\\n\\n    // If the list of points contained only the origin point, we can return immediately\\n    if angles_from_origin.is_empty() {\\n        return origin_in_points;\\n    }\\n\\n    // Sort them in incresaing order in order to use the sliding window technique\\n    angles_from_origin.sort_unstable_by(|&a, b| a.partial_cmp(b).unwrap());\\n\\n    // Sliding window \"from\" and \"to\"\\n    let mut l = 0;\\n    let mut r = 0;\\n\\n    // Field of view \"from\" and \"to\"\\n    let mut fov_l = angles_from_origin[0];\\n    let mut fov_r;\\n\\n    let mut answer = 0;\\n\\n    // iterate twice in order to count points that are at the 0-360 degrees border\\n    for iter in 0..2 {\\n        while r < angles_from_origin.len() {\\n            // If we were using radians, then we should have used TAU instead of 360.0\\n            //\\n            // We need to add 2*PI on the second iteration.\\n            // We can do it with an IF statement like that:\\n            // ```rust\\n            //  fov_r = angles_from_origin[l] + std::f64::consts::TAU * (iter as f64);\\n            // ```\\n            // but we can also take advantage of FMA instructions which might be faster :)\\n            fov_r = 360.0f64.mul_add(iter as f64, angles_from_origin[r]);\\n            r += 1;\\n\\n            while fov_r - fov_l > field_of_view {\\n                l = (l + 1) % angles_from_origin.len();\\n\\n                // We need to add 2*PI on the second iteration, but only if L < R\\n                // in other words - when L has started its own second iteration\\n                // We can do it with an IF statement like that:\\n                // ```rust\\n                //  fov_l = angles_from_origin[l];\\n                //  if iter != 0 && l < r{\\n                //      fov_l += std::f64::consts::TAU * (iter as f64)\\n                //  }\\n                // ```\\n                // but we can also take advantage of FMA instructions and branch-less code :)\\n                let mul = ((iter != 0 && l < r) as usize * iter) as f64;\\n                fov_l = 360.0f64.mul_add(mul, angles_from_origin[l]);\\n            }\\n\\n            // handle the case when we are iterating for a second time and R < L\\n            let r_add = angles_from_origin.len() * iter;\\n            let l_add = angles_from_origin.len() * iter * ((l < r) as usize);\\n            answer = answer.max((r + r_add) - (l + l_add));\\n        }\\n\\n        r = 0;\\n    }\\n\\n    answer as i32 + origin_in_points\\n}\\n```\\n\\nIf you like this solution you can find my other solutions at [github](https://github.com/SvetlinZarev/coding-challenges)",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Sliding Window"
                ],
                "code": "```rust\\nconst ACCURACY: f64 = 0.000_000_000_001;\\n\\npub fn visible_points(points: Vec<Vec<i32>>, angle: i32, origin: Vec<i32>) -> i32 {\\n    if points.is_empty() {\\n        return 0;\\n    }\\n\\n    let field_of_view = ACCURACY + angle as f64;\\n\\n    let mut origin_in_points = 0;\\n    let mut angles_from_origin = points\\n        .iter()\\n        // Count any points that overlap the origin point and always add them to the answer\\n        .inspect(|x| {\\n            if origin[0] == x[0] && origin[1] == x[1] {\\n                origin_in_points += 1;\\n            }\\n        })\\n        // Skip any points that are the same as the origin point,\\n        //because they are always in the FoV regardless of the angle\\n        .filter(|x| origin[0] != x[0] || origin[1] != x[1])\\n        .map(|p| {\\n            let dx = (p[0] - origin[0]) as f64;\\n            let dy = (p[1] - origin[1]) as f64;\\n            dy.atan2(dx)\\n        })\\n        // Normalize the angle to be in the range [0; TAU)\\n        .map(|radians| (radians + std::f64::consts::TAU) % std::f64::consts::TAU)\\n        // Use degrees, because it\\'s easier to visualize and debug\\n        .map(|radians| radians.to_degrees())\\n        .collect::<Vec<_>>();\\n\\n    // If the list of points contained only the origin point, we can return immediately\\n    if angles_from_origin.is_empty() {\\n        return origin_in_points;\\n    }\\n\\n    // Sort them in incresaing order in order to use the sliding window technique\\n    angles_from_origin.sort_unstable_by(|&a, b| a.partial_cmp(b).unwrap());\\n\\n    // Sliding window \"from\" and \"to\"\\n    let mut l = 0;\\n    let mut r = 0;\\n\\n    // Field of view \"from\" and \"to\"\\n    let mut fov_l = angles_from_origin[0];\\n    let mut fov_r;\\n\\n    let mut answer = 0;\\n\\n    // iterate twice in order to count points that are at the 0-360 degrees border\\n    for iter in 0..2 {\\n        while r < angles_from_origin.len() {\\n            // If we were using radians, then we should have used TAU instead of 360.0\\n            //\\n            // We need to add 2*PI on the second iteration.\\n            // We can do it with an IF statement like that:\\n            // ```\n```\\n            // but we can also take advantage of FMA instructions which might be faster :)\\n            fov_r = 360.0f64.mul_add(iter as f64, angles_from_origin[r]);\\n            r += 1;\\n\\n            while fov_r - fov_l > field_of_view {\\n                l = (l + 1) % angles_from_origin.len();\\n\\n                // We need to add 2*PI on the second iteration, but only if L < R\\n                // in other words - when L has started its own second iteration\\n                // We can do it with an IF statement like that:\\n                // ```\n```\\n                // but we can also take advantage of FMA instructions and branch-less code :)\\n                let mul = ((iter != 0 && l < r) as usize * iter) as f64;\\n                fov_l = 360.0f64.mul_add(mul, angles_from_origin[l]);\\n            }\\n\\n            // handle the case when we are iterating for a second time and R < L\\n            let r_add = angles_from_origin.len() * iter;\\n            let l_add = angles_from_origin.len() * iter * ((l < r) as usize);\\n            answer = answer.max((r + r_add) - (l + l_add));\\n        }\\n\\n        r = 0;\\n    }\\n\\n    answer as i32 + origin_in_points\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2110075,
                "title": "python3-sliding-window-in-polar-coordinates",
                "content": "```\\n\"\"\"https://leetcode.com/problems/maximum-number-of-visible-points/\"\"\"\\nfrom math import pi, atan2\\n\\n\\nclass Solution(object):\\n    def visiblePoints(self, points, angle, location):\\n        # original location\\n        x0, y0 = location\\n\\n        # transform points to polar co-ordinates\\n        angle *= pi / 180\\n        angles = sorted([atan2(x - x0, y - y0) for x, y in points if x != x0 or y != y0])\\n        n = len(angles)\\n        # add 360 degrees to each angle\\n        angles += [2 * pi + a for a in angles]\\n\\n        # window sliding\\n        left = right = max_visible_points = 0\\n        while left < n:\\n            while right < 2 * n and angles[right] - angles[left] <= angle:\\n                right += 1\\n            max_visible_points = max(max_visible_points, right - left)\\n            while left < n and angles[right] - angles[left] > angle:\\n                left += 1\\n        return max_visible_points + len(points) - n\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/maximum-number-of-visible-points/\"\"\"\\nfrom math import pi, atan2\\n\\n\\nclass Solution(object):\\n    def visiblePoints(self, points, angle, location):\\n        # original location\\n        x0, y0 = location\\n\\n        # transform points to polar co-ordinates\\n        angle *= pi / 180\\n        angles = sorted([atan2(x - x0, y - y0) for x, y in points if x != x0 or y != y0])\\n        n = len(angles)\\n        # add 360 degrees to each angle\\n        angles += [2 * pi + a for a in angles]\\n\\n        # window sliding\\n        left = right = max_visible_points = 0\\n        while left < n:\\n            while right < 2 * n and angles[right] - angles[left] <= angle:\\n                right += 1\\n            max_visible_points = max(max_visible_points, right - left)\\n            while left < n and angles[right] - angles[left] > angle:\\n                left += 1\\n        return max_visible_points + len(points) - n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1935547,
                "title": "deque-sliding-window",
                "content": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        \\n        //this is a sliding window problem\\n        //the key idea is to convert these points to angles and sweep across points\\n        //with a sliding window\\n        \\n        int overlap = 0;\\n        List<Double> list = new ArrayList<>(points.size());\\n        for (List<Integer> p : points) {\\n            if (p.get(0) == location.get(0) && p.get(1) == location.get(1)) overlap++;\\n            else \\n                list.add(angle(p.get(1) - location.get(1), p.get(0) - location.get(0)));\\n        }\\n        Collections.sort(list);\\n        \\n        int max = 0, n = list.size();\\n        Deque<Double> dq = new ArrayDeque<>();\\n        \\n        for(int lower=0, upper=0; lower < n && dq.size() < n; upper++){\\n            dq.offerLast(list.get(upper%n));\\n            \\n            while(canRemove(lower, upper, n, angle, dq)){\\n                dq.pollFirst();\\n                lower++;\\n            }\\n            \\n            max = Math.max(max, dq.size());\\n        } \\n        \\n        return max + overlap;       \\n    }\\n    \\n    private double angle(int dy, int dx) {\\n         double a = Math.toDegrees(Math.atan2(dy, dx));\\n        return a < 0 ? a + 360 : a;\\n    }\\n    \\n    private boolean canRemove(int lower, int upper, int n, int angle, Deque<Double> dq){\\n        double decidingAngle = dq.peekLast() - dq.peekFirst();\\n        decidingAngle = decidingAngle < 0 ? decidingAngle + 360 : decidingAngle;\\n        if(decidingAngle > angle) return true;\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        \\n        //this is a sliding window problem\\n        //the key idea is to convert these points to angles and sweep across points\\n        //with a sliding window\\n        \\n        int overlap = 0;\\n        List<Double> list = new ArrayList<>(points.size());\\n        for (List<Integer> p : points) {\\n            if (p.get(0) == location.get(0) && p.get(1) == location.get(1)) overlap++;\\n            else \\n                list.add(angle(p.get(1) - location.get(1), p.get(0) - location.get(0)));\\n        }\\n        Collections.sort(list);\\n        \\n        int max = 0, n = list.size();\\n        Deque<Double> dq = new ArrayDeque<>();\\n        \\n        for(int lower=0, upper=0; lower < n && dq.size() < n; upper++){\\n            dq.offerLast(list.get(upper%n));\\n            \\n            while(canRemove(lower, upper, n, angle, dq)){\\n                dq.pollFirst();\\n                lower++;\\n            }\\n            \\n            max = Math.max(max, dq.size());\\n        } \\n        \\n        return max + overlap;       \\n    }\\n    \\n    private double angle(int dy, int dx) {\\n         double a = Math.toDegrees(Math.atan2(dy, dx));\\n        return a < 0 ? a + 360 : a;\\n    }\\n    \\n    private boolean canRemove(int lower, int upper, int n, int angle, Deque<Double> dq){\\n        double decidingAngle = dq.peekLast() - dq.peekFirst();\\n        decidingAngle = decidingAngle < 0 ? decidingAngle + 360 : decidingAngle;\\n        if(decidingAngle > angle) return true;\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924110,
                "title": "efficient-sliding-window-solution-with-comments",
                "content": "Spent a while playing around with this problem to see if there\\'s a more optimal solution. I later [developed a bout of temporary insanity](https://leetcode.com/problems/maximum-number-of-visible-points/discuss/1924097/I-have-done-something-awful-no-sort-%22O(N)%22-solution) but this was the best performance I could reach using a sensible solution.\\n\\n```\\nconst getDegrees = (p1, p2) => Math.atan2(p1[1] - p2[1], p1[0] - p2[0]) * 180 / Math.PI;\\n\\nvar visiblePoints = function(points, angle, location) {\\n    // Early offramp if there aren\\'t enough points for this to be a complex problem\\n    if(points.length < 2) return points.length;\\n    \\n    // Separate the points into the ones which we\\'re already standing on\\n    // vs the ones that we need to actually look at, and convert both into\\n    // more directly usable values\\n    let angles = [];\\n    let onCenter = 0;\\n    for(let p of points) {\\n        if(p[0] === location[0] && p[1] === location[1]) {\\n            onCenter++;\\n        } else {\\n            angles.push(getDegrees(p, location));\\n        }\\n    }\\n    \\n    // No need to do any more work if we\\'re standing on every available angle\\n    if(!angles.length) return onCenter;\\n    \\n    angles.sort((a,b)=>a-b);\\n    const N = angles.length;\\n\\n    const makeCircular = (arr) => {\\n        // NOTE: I extracted this code so that I could comment it out. \\n        // This *should* be an optimization but in practice seems to slow things down\\n\\n        // const highest = arr[arr.length-1];\\n        // for(let i = 0; i < N; i++) {\\n        //     if(arr[i] + 360 > highest + angle) break;\\n        //     arr.push(arr[i] + 360);\\n        // }\\n        // return arr;\\n\\n        // NOTE: This seems to be faster and use less memory. Good warning about the \\n        // perils of micro-optimization.\\n        return arr.concat(arr.map(p => p + 360));\\n    }\\n    angles = makeCircular(angles);\\n    \\n    // It is actually possible that there\\'s no remaining angles to check here\\n    let best = 0;\\n    // Maintain a sliding window of valid points\\n    let right = 1;\\n    // LHS of the window only needs to get through the base array length\\n    for(let left = 0; left < N; left++) {\\n        const start = angles[left];\\n        while(start + angle >= angles[right++]) {\\n            // Doing all the work in the loop condition, nothing inside of it\\n        }\\n        best = Math.max(best, right-left-1);\\n    }\\n    \\n    return best + onCenter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getDegrees = (p1, p2) => Math.atan2(p1[1] - p2[1], p1[0] - p2[0]) * 180 / Math.PI;\\n\\nvar visiblePoints = function(points, angle, location) {\\n    // Early offramp if there aren\\'t enough points for this to be a complex problem\\n    if(points.length < 2) return points.length;\\n    \\n    // Separate the points into the ones which we\\'re already standing on\\n    // vs the ones that we need to actually look at, and convert both into\\n    // more directly usable values\\n    let angles = [];\\n    let onCenter = 0;\\n    for(let p of points) {\\n        if(p[0] === location[0] && p[1] === location[1]) {\\n            onCenter++;\\n        } else {\\n            angles.push(getDegrees(p, location));\\n        }\\n    }\\n    \\n    // No need to do any more work if we\\'re standing on every available angle\\n    if(!angles.length) return onCenter;\\n    \\n    angles.sort((a,b)=>a-b);\\n    const N = angles.length;\\n\\n    const makeCircular = (arr) => {\\n        // NOTE: I extracted this code so that I could comment it out. \\n        // This *should* be an optimization but in practice seems to slow things down\\n\\n        // const highest = arr[arr.length-1];\\n        // for(let i = 0; i < N; i++) {\\n        //     if(arr[i] + 360 > highest + angle) break;\\n        //     arr.push(arr[i] + 360);\\n        // }\\n        // return arr;\\n\\n        // NOTE: This seems to be faster and use less memory. Good warning about the \\n        // perils of micro-optimization.\\n        return arr.concat(arr.map(p => p + 360));\\n    }\\n    angles = makeCircular(angles);\\n    \\n    // It is actually possible that there\\'s no remaining angles to check here\\n    let best = 0;\\n    // Maintain a sliding window of valid points\\n    let right = 1;\\n    // LHS of the window only needs to get through the base array length\\n    for(let left = 0; left < N; left++) {\\n        const start = angles[left];\\n        while(start + angle >= angles[right++]) {\\n            // Doing all the work in the loop condition, nothing inside of it\\n        }\\n        best = Math.max(best, right-left-1);\\n    }\\n    \\n    return best + onCenter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1924097,
                "title": "i-have-done-something-awful-no-sort-o-n-solution",
                "content": "I keep seeing people post JS solutions where they rely on the map implementation to keep their integer keys sorted for them and claim that makes it O(N). \\n\\nI\\'m going to go on record as being pretty damn skeptical about those claims - presumably the underlying interface must either maintain an integer sort order or generate one on the fly. Regardless of my distate, I experienced a bout of temporary insanity and wound up actually writing one of those \"O(N)\" implementations for this problem.\\n\\nAt one point there was actually a sensible idea in here: you could potentially improve the base algorithm by maintaining a count of identical points. It\\'s probably not a practical improvement considering the increased code complexity and how unlikely it is to actually happen in the real world. But hey, if you want to repurpose it in some *actually sensible* code then go ahead.\\n\\n##### \"Does it work?\" \\nWho cares, it passes all tests! You could argue that this means the test cases are insufficient but honestly I think they\\'re fine. It\\'s not strictly 100% accurate but the edge cases are incredibly tiny.\\n##### Is it faster than other approaches? \\nHahaha hell no!\\n##### Could it be improved further? \\nAlmost certainly! You might even trim it down to being a viable algorithm! But please don\\'t!\\n##### Should you improve it yourself? \\nPlease do not! I suffered to prevent others from writing code this **incredibly stupid**.\\n\\n[I also posted a real solution if you\\'re more interested in that kind of thing.](https://leetcode.com/problems/maximum-number-of-visible-points/discuss/1924110/Efficient-sliding-window-solution-with-comments)\\n\\n```\\n/**\\n * @param {number[][]} points\\n * @param {number} angle\\n * @param {number[]} location\\n * @return {number}\\n */\\nconst getDegrees = (p1, p2) => (Math.atan2(p1[1] - p2[1], p1[0] - p2[0]) * 180 / Math.PI) + 180;\\n\\n// Maximum amount we can multiply a float by before it is no longer treated as an int\\nconst SCALING_FACTOR = 10000000;\\n\\nvar visiblePoints = function(points, angle, location) {\\n    angle = angle * SCALING_FACTOR;\\n    // Early offramp if there aren\\'t enough points for this to be a complex problem\\n    if(points.length < 2) return points.length;\\n    \\n    // Separate the points into the ones which we\\'re already standing on\\n    // vs the ones that we need to actually look at, and convert both into\\n    // more directly usable values\\n    let angles = {};\\n    let onCenter = 0;\\n    for(let p of points) {\\n        if(p[0] === location[0] && p[1] === location[1]) {\\n            onCenter++;\\n        } else {\\n            const deg = Math.round(getDegrees(p, location) * SCALING_FACTOR);\\n            angles[deg] = (angles[deg] || 0) + 1; \\n        }\\n    }\\n    \\n    let keys = Object.keys(angles); \\n    const N = keys.length;\\n    // No need to do any more work if we\\'re standing on every available angle\\n    if(!N) return onCenter;\\n    \\n    const diff = SCALING_FACTOR * 360;\\n    const highest = keys[N-1] + angle;\\n    for(let key of keys) {\\n        const newKey = new Number(key) + diff;\\n        if(newKey > highest) break;\\n        angles[newKey] = angles[key];\\n    }\\n    keys = Object.keys(angles);\\n    \\n    // It is actually possible that there\\'s no remaining angles to check here\\n    let best = 0;\\n    // Maintain a sliding window of valid points\\n    let right = 1;\\n\\n    let current = 0;\\n    let stretched = false;\\n    \\n    for(let left = 0; left < N; left++) {\\n        const start = keys[left];\\n\\n        // Ensure that we\\'re not about to use an invalid window\\n        if(keys[right] <= start) {\\n            current = 0;\\n            right = left + 1;\\n            stretched = false;\\n        }\\n        current += angles[start];\\n\\n        // Attempt to continue the existing window (or the freshly constructed one!)\\n        while(right < keys.length) {\\n            if(new Number(start) + angle >= keys[right]) {\\n                current += angles[keys[right++]];\\n                stretched = true;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        best = Math.max(best, current);\\n        current -= angles[start];\\n        if (stretched) {\\n            current -= angles[keys[left+1]];\\n            if(left+1 === right) {\\n                stretched = false;\\n            }\\n        }\\n    }\\n    \\n    return best + onCenter;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} angle\\n * @param {number[]} location\\n * @return {number}\\n */\\nconst getDegrees = (p1, p2) => (Math.atan2(p1[1] - p2[1], p1[0] - p2[0]) * 180 / Math.PI) + 180;\\n\\n// Maximum amount we can multiply a float by before it is no longer treated as an int\\nconst SCALING_FACTOR = 10000000;\\n\\nvar visiblePoints = function(points, angle, location) {\\n    angle = angle * SCALING_FACTOR;\\n    // Early offramp if there aren\\'t enough points for this to be a complex problem\\n    if(points.length < 2) return points.length;\\n    \\n    // Separate the points into the ones which we\\'re already standing on\\n    // vs the ones that we need to actually look at, and convert both into\\n    // more directly usable values\\n    let angles = {};\\n    let onCenter = 0;\\n    for(let p of points) {\\n        if(p[0] === location[0] && p[1] === location[1]) {\\n            onCenter++;\\n        } else {\\n            const deg = Math.round(getDegrees(p, location) * SCALING_FACTOR);\\n            angles[deg] = (angles[deg] || 0) + 1; \\n        }\\n    }\\n    \\n    let keys = Object.keys(angles); \\n    const N = keys.length;\\n    // No need to do any more work if we\\'re standing on every available angle\\n    if(!N) return onCenter;\\n    \\n    const diff = SCALING_FACTOR * 360;\\n    const highest = keys[N-1] + angle;\\n    for(let key of keys) {\\n        const newKey = new Number(key) + diff;\\n        if(newKey > highest) break;\\n        angles[newKey] = angles[key];\\n    }\\n    keys = Object.keys(angles);\\n    \\n    // It is actually possible that there\\'s no remaining angles to check here\\n    let best = 0;\\n    // Maintain a sliding window of valid points\\n    let right = 1;\\n\\n    let current = 0;\\n    let stretched = false;\\n    \\n    for(let left = 0; left < N; left++) {\\n        const start = keys[left];\\n\\n        // Ensure that we\\'re not about to use an invalid window\\n        if(keys[right] <= start) {\\n            current = 0;\\n            right = left + 1;\\n            stretched = false;\\n        }\\n        current += angles[start];\\n\\n        // Attempt to continue the existing window (or the freshly constructed one!)\\n        while(right < keys.length) {\\n            if(new Number(start) + angle >= keys[right]) {\\n                current += angles[keys[right++]];\\n                stretched = true;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        best = Math.max(best, current);\\n        current -= angles[start];\\n        if (stretched) {\\n            current -= angles[keys[left+1]];\\n            if(left+1 === right) {\\n                stretched = false;\\n            }\\n        }\\n    }\\n    \\n    return best + onCenter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918309,
                "title": "kotlin-o-n-sliding-window-oop",
                "content": "1. Convert `points` to `angles` from the `location`\\n2. Duplicate the `angles` and + 360 to each duplicated `angles` \\n3. Using sliding window to check if the `angles` is within `angle`\\n\\n```\\nclass Solution {\\n    fun visiblePoints(points: List<List<Int>>, angle: Int, location: List<Int>): Int {\\n        val locationPoint = Point(location[0], location[1])\\n        val angles = points.map { Point(it[0], it[1]) }.filter { it.x != locationPoint.x || it.y != locationPoint.y }\\n            .map { it.toAngle(locationPoint) }.sorted()\\n\\n        val alwaysSeePointCount = points.count() - angles.count()\\n\\n        val doubledAngles = listOf(angles, angles.map { it + 360 }).flatten()\\n        var maxPointCount = alwaysSeePointCount\\n        var r = 0\\n        for (l in 0 until doubledAngles.count()) {\\n            if(doubledAngles[l] >= 360) break\\n            if (l > 0 && doubledAngles[l] == doubledAngles[l - 1]) continue\\n            while (r < doubledAngles.count() - 1 && doubledAngles[r + 1] - doubledAngles[l] <= angle) {\\n                r++\\n            }\\n            val pointCount = r - l + 1 + alwaysSeePointCount\\n            if (maxPointCount < pointCount) maxPointCount = pointCount\\n        }\\n        return maxPointCount\\n    }\\n\\n    class Point(val x: Int, val y: Int) {\\n        fun toAngle(fromPoint: Point): Double {\\n            val deltaY: Int = y - fromPoint.y\\n            val deltaX: Int = x - fromPoint.x\\n            return Math.toDegrees(Math.atan2(deltaX.toDouble(), deltaY.toDouble()))\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    fun visiblePoints(points: List<List<Int>>, angle: Int, location: List<Int>): Int {\\n        val locationPoint = Point(location[0], location[1])\\n        val angles = points.map { Point(it[0], it[1]) }.filter { it.x != locationPoint.x || it.y != locationPoint.y }\\n            .map { it.toAngle(locationPoint) }.sorted()\\n\\n        val alwaysSeePointCount = points.count() - angles.count()\\n\\n        val doubledAngles = listOf(angles, angles.map { it + 360 }).flatten()\\n        var maxPointCount = alwaysSeePointCount\\n        var r = 0\\n        for (l in 0 until doubledAngles.count()) {\\n            if(doubledAngles[l] >= 360) break\\n            if (l > 0 && doubledAngles[l] == doubledAngles[l - 1]) continue\\n            while (r < doubledAngles.count() - 1 && doubledAngles[r + 1] - doubledAngles[l] <= angle) {\\n                r++\\n            }\\n            val pointCount = r - l + 1 + alwaysSeePointCount\\n            if (maxPointCount < pointCount) maxPointCount = pointCount\\n        }\\n        return maxPointCount\\n    }\\n\\n    class Point(val x: Int, val y: Int) {\\n        fun toAngle(fromPoint: Point): Double {\\n            val deltaY: Int = y - fromPoint.y\\n            val deltaX: Int = x - fromPoint.x\\n            return Math.toDegrees(Math.atan2(deltaX.toDouble(), deltaY.toDouble()))\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853857,
                "title": "c-o-nlogn-using-complex-double",
                "content": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        typedef complex<double> pt;\\n        vector<double> angles;\\n        angles.reserve(2 * points.size());\\n        pt origin(location[0], location[1]);\\n        int extra = 0;\\n        for (auto &v : points) {\\n            pt z(v[0], v[1]);\\n            if (z == origin) {\\n                extra++;\\n                continue;\\n            }\\n            z -= origin;\\n            double a = (arg(z) * 180.0 / M_PI);\\n            if (a < 0) a += 360;\\n            angles.push_back(a);\\n        }\\n        int l = 0, r = 0, n = angles.size(), ans = 0;\\n        sort(angles.begin(), angles.end());\\n        for (int i = 0; i < n; i++) {\\n            angles.push_back(angles[i] + 360);\\n        }\\n        n *= 2;\\n        while (r < n) {\\n            double diff = angles[r] - angles[l];\\n            if (diff <= angle) {\\n                ans = max(ans, r - l + 1);\\n                r++;\\n            } else {\\n                l++;\\n            }\\n        }\\n        return ans + extra;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        typedef complex<double> pt;\\n        vector<double> angles;\\n        angles.reserve(2 * points.size());\\n        pt origin(location[0], location[1]);\\n        int extra = 0;\\n        for (auto &v : points) {\\n            pt z(v[0], v[1]);\\n            if (z == origin) {\\n                extra++;\\n                continue;\\n            }\\n            z -= origin;\\n            double a = (arg(z) * 180.0 / M_PI);\\n            if (a < 0) a += 360;\\n            angles.push_back(a);\\n        }\\n        int l = 0, r = 0, n = angles.size(), ans = 0;\\n        sort(angles.begin(), angles.end());\\n        for (int i = 0; i < n; i++) {\\n            angles.push_back(angles[i] + 360);\\n        }\\n        n *= 2;\\n        while (r < n) {\\n            double diff = angles[r] - angles[l];\\n            if (diff <= angle) {\\n                ans = max(ans, r - l + 1);\\n                r++;\\n            } else {\\n                l++;\\n            }\\n        }\\n        return ans + extra;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792684,
                "title": "why-no-one-mentioned-this-description-for-direct-east",
                "content": "I got confused by this line:\\n\\n\"You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.\"\\n\\nDoes that mean that you can not turn to west for looking at your back? Seems like the example test cases don\\'t care it and you can rotate 360 degree?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1752851,
                "title": "can-we-have-a-solution-with-o-n-time-complexity",
                "content": "As we have seen in all the solutions provided in discuss forum, everyone has used sort function but I think we can leverage hashmap to reduce time complexity O(nlong(n)) for sorting to O(n).\\nUsing hashmap with sliding window we can achieve linear time complexity.\\n\\nI wanted to know, if my understanding is correct or not.\\n\\nAppreaciate your pov.\\n\\n",
                "solutionTags": [],
                "code": "As we have seen in all the solutions provided in discuss forum, everyone has used sort function but I think we can leverage hashmap to reduce time complexity O(nlong(n)) for sorting to O(n).\\nUsing hashmap with sliding window we can achieve linear time complexity.\\n\\nI wanted to know, if my understanding is correct or not.\\n\\nAppreaciate your pov.\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1666161,
                "title": "o-n-log-n-solution-c",
                "content": "#define all(c) c.begin(),c.end()\\n#define EPS 1e-6\\n\\ntypedef vector<int> vi;\\ntypedef vector<vi> vvi;\\n\\nfloat calcAngle(vi &a, vi &b){\\n    return atan2(b[1]-a[1],b[0]-a[0])*180/acos(-1);\\n}\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location)      {\\n        vector<float> angles;\\n        int sameAsLoc = 0;\\n        for(auto point:points){\\n            if(location[0]==point[0] && location[1]==point[1])\\n                sameAsLoc++;\\n            else{\\n                float ang = calcAngle(location,point);\\n                angles.push_back( ang );\\n                angles.push_back( 360 + ang );\\n            }\\n        }\\n        sort(all(angles));\\n        int p = 0, x = 0, y = 0;\\n        int ans = sameAsLoc;\\n        for(;x<angles.size();x++,p--){\\n            while(  y<angles.size() && \\\\\\n                  (angles[y] - angles[x] - angle) < EPS ){\\n                p++; y++;\\n            }\\n            ans = max(p+sameAsLoc,ans);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location)      {\\n        vector<float> angles;\\n        int sameAsLoc = 0;\\n        for(auto point:points){\\n            if(location[0]==point[0] && location[1]==point[1])\\n                sameAsLoc++;\\n            else{\\n                float ang = calcAngle(location,point);\\n                angles.push_back( ang );\\n                angles.push_back( 360 + ang );\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1648994,
                "title": "ruby-solution",
                "content": "I think the major challenge is the math in this problem. \\n\\nHere are the steps \\n\\n1. Calculate angle of line between every point & start location. y2 - y1 / x2 - x1 gives you tan(theta). So you need to find tan inverse of it. The angle will be in radian. So multiple it with 180/pi to get the angle in degrees. \\n2. Apply sliding window. Start from 1st point & keep including points till the angle covered is > given angle. Then start discarding points from the start. Use a queue (pretty standard sliding window implementation). \\n\\n**Gotchas**\\n1. If a point coincide with the start point, the angle will come out to be 0 but it will be included in all the views. Hence count them at the start & exclude them from calculation. `same_as_location_point_count` variable in the code. \\n2. Since angles are round in nature, if you have 2 points with angles - [-135 & 135] & given angle is 90, you need to come to -135 again. Something like [-135, 135, -135, 135]. But -135 - 135 will be smaller than 90. So when you repeat the angles, add 360 to it. So this will become [-135, 135, 225, 495] . Now 225 - 135 = 90 & these 2 points will come under the view. The complexity will still be O(n)\\n\\nCode below \\n```\\ndef visible_points(points, angle, location)\\n    angles = []\\n    same_as_location_point_count = 0\\n    points.each do |point|\\n        if point == location\\n            same_as_location_point_count += 1\\n            next\\n        end\\n        angles << Math.atan2(point[1] - location[1], point[0] - location[0]) * 180 / Math::PI\\n    end\\n\\n    angles.sort!\\n    #puts angles.inspect\\n    angles += angles.map {|val| val + 360}\\n    \\n    queue = []\\n    count = 0\\n    max_count = 0\\n    angles.each do |_angle|\\n        \\n        while queue.length > 0 and _angle - queue[0] > angle\\n            queue.shift\\n        end\\n        queue.push(_angle)\\n        \\n        #puts queue.inspect\\n        count = queue.size\\n        max_count = count if max_count < count\\n    end\\n    max_count + same_as_location_point_count\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef visible_points(points, angle, location)\\n    angles = []\\n    same_as_location_point_count = 0\\n    points.each do |point|\\n        if point == location\\n            same_as_location_point_count += 1\\n            next\\n        end\\n        angles << Math.atan2(point[1] - location[1], point[0] - location[0]) * 180 / Math::PI\\n    end\\n\\n    angles.sort!\\n    #puts angles.inspect\\n    angles += angles.map {|val| val + 360}\\n    \\n    queue = []\\n    count = 0\\n    max_count = 0\\n    angles.each do |_angle|\\n        \\n        while queue.length > 0 and _angle - queue[0] > angle\\n            queue.shift\\n        end\\n        queue.push(_angle)\\n        \\n        #puts queue.inspect\\n        count = queue.size\\n        max_count = count if max_count < count\\n    end\\n    max_count + same_as_location_point_count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1640594,
                "title": "commented-solution-sorting-sliding-window-my-maths-are-bad",
                "content": "```\\nclass Solution {\\nprivate:\\n    const int x = 0;\\n    const int y = 1;\\npublic:\\n    // Time complexity: O(nlogn) because of sorting\\n    // Space complexity: O(n)\\n    // NOTE: 0 degrees means you can see points in a line\\n    int visiblePoints(vector<vector<int>>& pts, int angle, vector<int>& loc) {\\n        vector<double> angles;\\n        int res = 0;\\n        int samePt = 0;\\n        \\n        // Case where we see the entire grid\\n        if (angle == 360) return pts.size();\\n        \\n        // For each point, convert it to angles in degrees (relative to [0, 0])\\n        for (vector<int> &pt : pts) {\\n            \\n            // off set the points so that our origin begins with (0, 0)\\n            int currX = pt[x] - loc[x];\\n            int currY = pt[y] - loc[y];\\n            \\n            // special case where point and origin are the same, always see\\n            if (currX == 0 && currY == 0) {\\n                samePt++;\\n                continue;\\n            }\\n            \\n            // case where points laying on the quadrant border\\n            if (currX == 0) {\\n                if (currY > 0) {\\n                    angles.push_back(90.0);\\n                } else if (currY < 0) {\\n                    angles.push_back(270.0);\\n                }\\n                continue;\\n            }\\n            if (currY == 0) {\\n                if (currX > 0) {\\n                    angles.push_back(0.0);\\n                } else if (currX < 0) {\\n                    angles.push_back(180.0);\\n                }\\n                continue;\\n            }\\n            \\n            // calculate the relative angle after shifting to origin\\n            double currAngle = atan((double)abs(currY) / (double)abs(currX));\\n            currAngle *= (180 / M_PI);\\n            \\n            if (currX > 0 && currY > 0) { // Q1\\n                angles.push_back(currAngle);\\n            } else if (currX < 0 && currY > 0) { // Q2\\n                angles.push_back(180.0 - currAngle);\\n            } else if (currX < 0 && currY < 0) { // Q3\\n                angles.push_back(180.0 + currAngle);\\n            } else if (currX > 0 && currY < 0) { // Q4\\n                angles.push_back(360.0 - currAngle);\\n            }\\n        }\\n        \\n        // All points are the same as origin\\n        if (angles.empty()) {\\n            return samePt;\\n        }\\n        \\n        sort(angles.begin(), angles.end()); // small to large, O(nlogn) time complexity\\n        \\n        // get initial j, where j represents the first point we see in vision\\n        double jStartAngle = angles[0] - (double)angle;\\n        int j = 0;\\n        if (jStartAngle < 0) {\\n            jStartAngle += 360.0;\\n        }\\n        for (int k = 0; k < angles.size() - 1; k++) {\\n            if (angles[k] < jStartAngle && angles[k + 1] >= jStartAngle) {\\n                j = k + 1;\\n                break;\\n            }\\n        }\\n        \\n        // For each angle, check how many points we can see.\\n        // Note that two pointer approach is used to determine how many points are in vision\\n        for (int i = 0; i < angles.size(); i++) {\\n            \\n            double visionStart = angles[i] - (double)angle;\\n            if (visionStart < 0) {\\n                visionStart += 360.0;\\n            }\\n            \\n            while ((angles[i] > visionStart && (angles[j] < visionStart || angles[j] > angles[i])) ||\\n                   (angles[i] < visionStart && (angles[j] > angles[i] && angles[j] < visionStart)) ||\\n                   (angles[i] == visionStart && angles[j] != angles[i])) {\\n                if (++j == angles.size()) j = 0;\\n            }\\n            \\n            int currRes;\\n            if (j > i) {\\n                currRes = angles.size() - j + i + 1;\\n            } else {\\n                currRes = (i - j) + 1;\\n            }\\n            \\n            res = max(res, currRes);\\n        }\\n        \\n        return res + samePt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    const int x = 0;\\n    const int y = 1;\\npublic:\\n    // Time complexity: O(nlogn) because of sorting\\n    // Space complexity: O(n)\\n    // NOTE: 0 degrees means you can see points in a line\\n    int visiblePoints(vector<vector<int>>& pts, int angle, vector<int>& loc) {\\n        vector<double> angles;\\n        int res = 0;\\n        int samePt = 0;\\n        \\n        // Case where we see the entire grid\\n        if (angle == 360) return pts.size();\\n        \\n        // For each point, convert it to angles in degrees (relative to [0, 0])\\n        for (vector<int> &pt : pts) {\\n            \\n            // off set the points so that our origin begins with (0, 0)\\n            int currX = pt[x] - loc[x];\\n            int currY = pt[y] - loc[y];\\n            \\n            // special case where point and origin are the same, always see\\n            if (currX == 0 && currY == 0) {\\n                samePt++;\\n                continue;\\n            }\\n            \\n            // case where points laying on the quadrant border\\n            if (currX == 0) {\\n                if (currY > 0) {\\n                    angles.push_back(90.0);\\n                } else if (currY < 0) {\\n                    angles.push_back(270.0);\\n                }\\n                continue;\\n            }\\n            if (currY == 0) {\\n                if (currX > 0) {\\n                    angles.push_back(0.0);\\n                } else if (currX < 0) {\\n                    angles.push_back(180.0);\\n                }\\n                continue;\\n            }\\n            \\n            // calculate the relative angle after shifting to origin\\n            double currAngle = atan((double)abs(currY) / (double)abs(currX));\\n            currAngle *= (180 / M_PI);\\n            \\n            if (currX > 0 && currY > 0) { // Q1\\n                angles.push_back(currAngle);\\n            } else if (currX < 0 && currY > 0) { // Q2\\n                angles.push_back(180.0 - currAngle);\\n            } else if (currX < 0 && currY < 0) { // Q3\\n                angles.push_back(180.0 + currAngle);\\n            } else if (currX > 0 && currY < 0) { // Q4\\n                angles.push_back(360.0 - currAngle);\\n            }\\n        }\\n        \\n        // All points are the same as origin\\n        if (angles.empty()) {\\n            return samePt;\\n        }\\n        \\n        sort(angles.begin(), angles.end()); // small to large, O(nlogn) time complexity\\n        \\n        // get initial j, where j represents the first point we see in vision\\n        double jStartAngle = angles[0] - (double)angle;\\n        int j = 0;\\n        if (jStartAngle < 0) {\\n            jStartAngle += 360.0;\\n        }\\n        for (int k = 0; k < angles.size() - 1; k++) {\\n            if (angles[k] < jStartAngle && angles[k + 1] >= jStartAngle) {\\n                j = k + 1;\\n                break;\\n            }\\n        }\\n        \\n        // For each angle, check how many points we can see.\\n        // Note that two pointer approach is used to determine how many points are in vision\\n        for (int i = 0; i < angles.size(); i++) {\\n            \\n            double visionStart = angles[i] - (double)angle;\\n            if (visionStart < 0) {\\n                visionStart += 360.0;\\n            }\\n            \\n            while ((angles[i] > visionStart && (angles[j] < visionStart || angles[j] > angles[i])) ||\\n                   (angles[i] < visionStart && (angles[j] > angles[i] && angles[j] < visionStart)) ||\\n                   (angles[i] == visionStart && angles[j] != angles[i])) {\\n                if (++j == angles.size()) j = 0;\\n            }\\n            \\n            int currRes;\\n            if (j > i) {\\n                currRes = angles.size() - j + i + 1;\\n            } else {\\n                currRes = (i - j) + 1;\\n            }\\n            \\n            res = max(res, currRes);\\n        }\\n        \\n        return res + samePt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631314,
                "title": "golang-binary-polar-angle",
                "content": "```\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n    origin := 0\\n    // \\u6C42\\u5404\\u70B9\\u76F8\\u5BF9\\u4E8Elocation\\u7684\\u6781\\u89D2\\u5EA6\\uFF0C \\u5E76\\u6392\\u5E8F\\n    res := []float64{}\\n    for _, point := range points {\\n        if point[0] == location[0] && point[1] == location[1] {\\n            // \\u53CD\\u6B63\\u5207\\u503C (-\\u03C0/2,\\u03C0/2)\\n            origin++\\n        } else {\\n            res = append(res, math.Atan2(float64(point[1]-location[1]), float64(point[0]-location[0])))\\n        }\\n    }\\n\\n    sort.Float64s(res)\\n\\n    n := len(res)\\n    for i:=0;i<n;i++ {\\n        res = append(res, res[i]+2*math.Pi)\\n    }\\n\\n\\n    maxCnt, degree := 0, float64(angle) * math.Pi / 180\\n    for start, polarAngle := range res[:n] {\\n        end := sort.Search(n*2, func(j int) bool { return res[j] > polarAngle + degree })\\n        if end-start > maxCnt {\\n            maxCnt = end - start\\n        }\\n    }\\n    return origin + maxCnt\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n    origin := 0\\n    // \\u6C42\\u5404\\u70B9\\u76F8\\u5BF9\\u4E8Elocation\\u7684\\u6781\\u89D2\\u5EA6\\uFF0C \\u5E76\\u6392\\u5E8F\\n    res := []float64{}\\n    for _, point := range points {\\n        if point[0] == location[0] && point[1] == location[1] {\\n            // \\u53CD\\u6B63\\u5207\\u503C (-\\u03C0/2,\\u03C0/2)\\n            origin++\\n        } else {\\n            res = append(res, math.Atan2(float64(point[1]-location[1]), float64(point[0]-location[0])))\\n        }\\n    }\\n\\n    sort.Float64s(res)\\n\\n    n := len(res)\\n    for i:=0;i<n;i++ {\\n        res = append(res, res[i]+2*math.Pi)\\n    }\\n\\n\\n    maxCnt, degree := 0, float64(angle) * math.Pi / 180\\n    for start, polarAngle := range res[:n] {\\n        end := sort.Search(n*2, func(j int) bool { return res[j] > polarAngle + degree })\\n        if end-start > maxCnt {\\n            maxCnt = end - start\\n        }\\n    }\\n    return origin + maxCnt\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534072,
                "title": "sorted-hash-map-sliding-window",
                "content": "```\\nclass Solution {\\n    double get_angle(int x_diff, int y_diff) {\\n        return atan2(y_diff, x_diff) * 180 / M_PI;\\n    }\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        //find degrees for points\\n        map<double,int> pts;\\n        int overlap=0;\\n        for (int i=0;i<points.size();i++){\\n            int x=points[i][0]-location[0];\\n            int y=points[i][1]-location[1];\\n            if (x==0 &&y==0) overlap++;\\n            else{\\n                double d=get_angle(x,y);\\n                //if (d<-180) d+=360;\\n                pts[d]++;   \\n            }\\n        }\\n        \\n        //find a range(direction) that can see max num of points\\n        bool lsecond=false;//use flags to record if it is first or second round\\n        bool rsecond=false;\\n        auto left=pts.begin(), right=pts.begin();\\n        int maxnum=0;\\n        int sum=0;\\n        while (right!=pts.end()){\\n            sum+= right->second;\\n            double diff= right->first- left->first;\\n            if (rsecond) diff+=360.0;\\n            if (lsecond) diff-=360.0;\\n            while (diff>angle){\\n                sum-=left->second; \\n                left++; \\n                if (left==pts.end()) break;\\n                diff= right->first- left->first;\\n                if (rsecond) diff+=360.0;\\n                if (lsecond) diff-=360.0;\\n            }\\n            maxnum= max(maxnum, sum);\\n            right++;\\n\\n            if (left==pts.end()&& !lsecond){ left=pts.begin(); lsecond=true;}\\n            if (right==pts.end()&& !rsecond){ right=pts.begin(); rsecond=true;}\\n        }\\n        return maxnum+overlap;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    double get_angle(int x_diff, int y_diff) {\\n        return atan2(y_diff, x_diff) * 180 / M_PI;\\n    }\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        //find degrees for points\\n        map<double,int> pts;\\n        int overlap=0;\\n        for (int i=0;i<points.size();i++){\\n            int x=points[i][0]-location[0];\\n            int y=points[i][1]-location[1];\\n            if (x==0 &&y==0) overlap++;\\n            else{\\n                double d=get_angle(x,y);\\n                //if (d<-180) d+=360;\\n                pts[d]++;   \\n            }\\n        }\\n        \\n        //find a range(direction) that can see max num of points\\n        bool lsecond=false;//use flags to record if it is first or second round\\n        bool rsecond=false;\\n        auto left=pts.begin(), right=pts.begin();\\n        int maxnum=0;\\n        int sum=0;\\n        while (right!=pts.end()){\\n            sum+= right->second;\\n            double diff= right->first- left->first;\\n            if (rsecond) diff+=360.0;\\n            if (lsecond) diff-=360.0;\\n            while (diff>angle){\\n                sum-=left->second; \\n                left++; \\n                if (left==pts.end()) break;\\n                diff= right->first- left->first;\\n                if (rsecond) diff+=360.0;\\n                if (lsecond) diff-=360.0;\\n            }\\n            maxnum= max(maxnum, sum);\\n            right++;\\n\\n            if (left==pts.end()&& !lsecond){ left=pts.begin(); lsecond=true;}\\n            if (right==pts.end()&& !rsecond){ right=pts.begin(); rsecond=true;}\\n        }\\n        return maxnum+overlap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524570,
                "title": "c-solution-o-nlogn",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) \\n    {\\n        auto locx = location[0];\\n        auto locy = location[1];\\n        \\n        vector<double> angles;\\n        for (auto& point : points)\\n        {\\n            if (point[0] == locx && point[1] == locy)\\n                continue;\\n            \\n            auto angle = calcAngle(locx, locy, point[0], point[1]);\\n            angles.push_back(angle);\\n        }\\n        \\n        auto pointInLocation = points.size() - angles.size();\\n        \\n        sort(begin(angles), end(angles));\\n        \\n        auto maxPoints = 0;\\n        for (int i = 0; i < angles.size(); i++)\\n        {\\n            auto startAngle = angles[i];\\n            auto endAngle = startAngle + angle;\\n            auto pointInAngle = pointsCountInAngle(angles, startAngle, min(endAngle, 360.0));\\n            if (endAngle >= 360)\\n                pointInAngle += pointsCountInAngle(angles, 0, endAngle - 360);\\n            \\n            maxPoints = max(pointInAngle, maxPoints);\\n        }\\n        \\n        return maxPoints + pointInLocation;\\n    }\\n    \\nprivate:    \\n    int pointsCountInAngle(vector<double>& sortedAngles, double startA, double endA)\\n    {        \\n        auto lower = lower_bound(begin(sortedAngles), end(sortedAngles), startA);\\n        auto upper = upper_bound(begin(sortedAngles), end(sortedAngles), endA + 1e-5);\\n        auto dist = distance(lower, upper);\\n        return dist;\\n    }\\n    \\n    double calcAngle(int locx, int locy, int x, int y)\\n    {\\n        int vx = x - locx;\\n        int vy = y - locy;\\n        \\n        double vlen = sqrt(vx * vx + vy * vy);\\n        auto cosangle = vx / vlen;\\n        \\n        auto angle = acos(cosangle) / M_PI * 180;       \\n        if (vy < 0)\\n            angle = 360 - angle;\\n        \\n        return angle;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) \\n    {\\n        auto locx = location[0];\\n        auto locy = location[1];\\n        \\n        vector<double> angles;\\n        for (auto& point : points)\\n        {\\n            if (point[0] == locx && point[1] == locy)\\n                continue;\\n            \\n            auto angle = calcAngle(locx, locy, point[0], point[1]);\\n            angles.push_back(angle);\\n        }\\n        \\n        auto pointInLocation = points.size() - angles.size();\\n        \\n        sort(begin(angles), end(angles));\\n        \\n        auto maxPoints = 0;\\n        for (int i = 0; i < angles.size(); i++)\\n        {\\n            auto startAngle = angles[i];\\n            auto endAngle = startAngle + angle;\\n            auto pointInAngle = pointsCountInAngle(angles, startAngle, min(endAngle, 360.0));\\n            if (endAngle >= 360)\\n                pointInAngle += pointsCountInAngle(angles, 0, endAngle - 360);\\n            \\n            maxPoints = max(pointInAngle, maxPoints);\\n        }\\n        \\n        return maxPoints + pointInLocation;\\n    }\\n    \\nprivate:    \\n    int pointsCountInAngle(vector<double>& sortedAngles, double startA, double endA)\\n    {        \\n        auto lower = lower_bound(begin(sortedAngles), end(sortedAngles), startA);\\n        auto upper = upper_bound(begin(sortedAngles), end(sortedAngles), endA + 1e-5);\\n        auto dist = distance(lower, upper);\\n        return dist;\\n    }\\n    \\n    double calcAngle(int locx, int locy, int x, int y)\\n    {\\n        int vx = x - locx;\\n        int vy = y - locy;\\n        \\n        double vlen = sqrt(vx * vx + vy * vy);\\n        auto cosangle = vx / vlen;\\n        \\n        auto angle = acos(cosangle) / M_PI * 180;       \\n        if (vy < 0)\\n            angle = 360 - angle;\\n        \\n        return angle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1502192,
                "title": "c-sliding-window-with-explanation",
                "content": "```\\nclass Solution \\n{\\n\\tpublic:\\n\\t\\tint visiblePoints(vector<vector<int> > const &points, int angle, vector<int> const &location) \\n\\t\\t{\\n\\t\\t\\tsize_t n = points.size();\\n\\t\\t\\tmap<double, size_t> angleCounts;\\n\\t\\t\\tint nPointsAtLocation = 0;\\n\\n\\t\\t\\t// calculate theta angles and store in angleCount map\\n\\t\\t\\tfor (size_t idx = 0; idx < n; ++idx)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if point is at location -> this can be seen at all times, store in nPointsAtLocation\\n\\t\\t\\t\\tif (points[idx][0] == location[0] && points[idx][1] == location[1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++nPointsAtLocation;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdouble length = sqrt(pow(points[idx][0] - location[0], 2) + \\n                                     pow(points[idx][1] - location[1], 2));\\n\\t\\t\\t\\tdouble theta = acos((points[idx][0] - location[0]) / length) * 180 / M_PI;\\n\\n\\t\\t\\t\\t// if point y-coordinate is lower than location y-coordinate, angle is between 180-160 degrees\\n\\t\\t\\t\\tif (points[idx][1] < location[1])\\n\\t\\t\\t\\t\\ttheta = 360 - theta;\\n\\n\\t\\t\\t\\t// round theta to certain precision\\n\\t\\t\\t\\ttheta = round(1e5 * theta) / 1e5;\\n\\n\\t\\t\\t\\t// store theta angle in map and update frequency of that angle\\n\\t\\t\\t\\tangleCounts[theta] += 1;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// iterate theta angles in map, and build cumulative count map\\n\\t\\t\\tmap<double, int> angleCumCounts;\\n\\t\\t\\tint currCount = 0;\\n\\t\\t\\tfor (auto it : angleCounts)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdouble theta = it.first;\\n\\t\\t\\t\\tcurrCount += it.second;\\n\\t\\t\\t\\tangleCumCounts[theta] = currCount;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// max number of points stored in angleCumCounts\\n\\t\\t\\tint maxAngleCumCount = (angleCumCounts.size() == 0) ? 0 : prev(angleCumCounts.end())->second;\\n\\n\\t\\t\\tint maxNPoints = 0;\\n\\t\\t\\tfor (auto it : angleCumCounts)\\n\\t\\t\\t{\\n\\t\\t\\t\\tdouble theta = it.first;\\n\\t\\t\\t\\tint currCount = it.second;\\n\\n\\t\\t\\t\\tint refCount = 0;\\n\\t\\t\\t\\tif (theta - angle >= 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// answer is angleCumCounts[theta] - angleCumCounts[theta - angle]\\n\\t\\t\\t\\t\\t// lower_bound will find matching theta angle equal to or larger than requested theta - angle\\n\\t\\t\\t\\t\\t// this defines the longest sliding window possible\\n\\t\\t\\t\\t\\tdouble refTheta = theta - angle;\\n\\t\\t\\t\\t\\tauto ref_it = angleCumCounts.lower_bound(refTheta);\\n\\n\\t\\t\\t\\t\\t// include points at lowest possible theta angle -> go one iteration back before subtraction\\n\\t\\t\\t\\t\\tif (ref_it != angleCumCounts.begin())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t--ref_it;\\n\\t\\t\\t\\t\\t\\trefCount = ref_it->second;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmaxNPoints = max(maxNPoints, currCount - refCount);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t// answer is angleCumCounts[theta] + maxAngleCumCount - angleCumCounts[360 + theta - angle]\\n\\t\\t\\t\\t\\tdouble refTheta = 360 + theta - angle;\\n\\t\\t\\t\\t\\tauto ref_it = angleCumCounts.lower_bound(refTheta);\\n\\n\\t\\t\\t\\t\\tif (ref_it != angleCumCounts.begin())\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t--ref_it;\\n\\t\\t\\t\\t\\t\\trefCount = ref_it->second;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tmaxNPoints = max(maxNPoints, currCount + maxAngleCumCount - refCount);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxNPoints + nPointsAtLocation;\\n\\t\\t}\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\n\\tpublic:\\n\\t\\tint visiblePoints(vector<vector<int> > const &points, int angle, vector<int> const &location) \\n\\t\\t{\\n\\t\\t\\tsize_t n = points.size();\\n\\t\\t\\tmap<double, size_t> angleCounts;\\n\\t\\t\\tint nPointsAtLocation = 0;\\n\\n\\t\\t\\t// calculate theta angles and store in angleCount map\\n\\t\\t\\tfor (size_t idx = 0; idx < n; ++idx)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// if point is at location -> this can be seen at all times, store in nPointsAtLocation\\n\\t\\t\\t\\tif (points[idx][0] == location[0] && points[idx][1] == location[1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++nPointsAtLocation;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1502122,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int VisiblePoints(IList<IList<int>> points, int angle, IList<int> location) {\\n        List<double> store = new List<double>();\\n        int result = 0;\\n        foreach(IList<int> point in points) {\\n            int dx = point[0] - location[0];\\n            int dy = point[1] - location[1];\\n            \\n            if (dx == 0 && dy == 0) {\\n                result ++;\\n                continue;\\n            }\\n            double angleRad = Math.Atan2(dy, dx) * (180.0 / Math.PI);\\n            store.Add(angleRad);\\n        }\\n        store.Sort();\\n        \\n        List<double> temp = new List<double>(store);\\n        \\n        foreach(double angleT in store) {\\n            temp.Add(angleT + 360.0);\\n        }\\n        int finalResult = result;\\n        for(int i=0, j=0; i< temp.Count(); i++) {\\n            while(temp[i] - temp[j] > angle) {\\n                j++;\\n            }\\n            finalResult = Math.Max(finalResult, result + i - j + 1);\\n        }\\n        return finalResult;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int VisiblePoints(IList<IList<int>> points, int angle, IList<int> location) {\\n        List<double> store = new List<double>();\\n        int result = 0;\\n        foreach(IList<int> point in points) {\\n            int dx = point[0] - location[0];\\n            int dy = point[1] - location[1];\\n            \\n            if (dx == 0 && dy == 0) {\\n                result ++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1473211,
                "title": "java-sorting-sliding-window-binary-search-170-ms-based-on-hints-and-idea-from-another-post",
                "content": "this solution is a slightly optimized version of https://leetcode.com/problems/maximum-number-of-visible-points/discuss/1321057/Java-Solution-Sort-%2B-Sliding-window\\n\\n1. Used binary search \\n2. Put a check on for-loop to prevent unnecessary checks beyond a certain limit (refer to comments in code)\\n\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int targetAngle, List<Integer> location) {\\n        int n = points.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        int i, j, sameAsBase = 0, dx, dy;\\n        double angle;\\n        \\n        List<Double> angles = new ArrayList<Double>(n << 1);\\n        for(i = 0; i < n; i++){\\n            dx = points.get(i).get(0) - location.get(0);\\n            dy = points.get(i).get(1) - location.get(1);\\n            if(dx == 0 && dy == 0){\\n                ++sameAsBase;\\n            }else{\\n                angle = Math.atan2(dy, dx) * 180.0 / Math.PI;\\n                angles.add(angle);\\n            }\\n        }\\n        \\n        \\n        int result = sameAsBase;\\n        \\n        if(!angles.isEmpty()){\\n            Collections.sort(angles);\\n            n = angles.size();\\n            for(i = 0; i < n; i++){\\n                angles.add(angles.get(i) + 360.0); // for cyclic looping\\n            }\\n            \\n            n = (n << 1);\\n            \\n            for(i = 0; i + result < n; i++){\\n                j = binarySearch(angles, i, n, angles.get(i) + targetAngle);\\n                result = Math.max(result, sameAsBase + j - i + 1);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int binarySearch(List<Double> angles, int start, int length, double target){\\n        int left = start, right = length - 1;\\n        int mid;\\n        int result = -1;\\n        while(left <= right){\\n            mid = left + ((right - left) >> 1);\\n            if(angles.get(mid) <= target){\\n                result = mid;\\n                left = mid + 1;\\n            }else{\\n                right = mid - 1;\\n            }\\n        } \\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int targetAngle, List<Integer> location) {\\n        int n = points.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        int i, j, sameAsBase = 0, dx, dy;\\n        double angle;\\n        \\n        List<Double> angles = new ArrayList<Double>(n << 1);\\n        for(i = 0; i < n; i++){\\n            dx = points.get(i).get(0) - location.get(0);\\n            dy = points.get(i).get(1) - location.get(1);\\n            if(dx == 0 && dy == 0){\\n                ++sameAsBase;\\n            }else{\\n                angle = Math.atan2(dy, dx) * 180.0 / Math.PI;\\n                angles.add(angle);\\n            }\\n        }\\n        \\n        \\n        int result = sameAsBase;\\n        \\n        if(!angles.isEmpty()){\\n            Collections.sort(angles);\\n            n = angles.size();\\n            for(i = 0; i < n; i++){\\n                angles.add(angles.get(i) + 360.0); // for cyclic looping\\n            }\\n            \\n            n = (n << 1);\\n            \\n            for(i = 0; i + result < n; i++){\\n                j = binarySearch(angles, i, n, angles.get(i) + targetAngle);\\n                result = Math.max(result, sameAsBase + j - i + 1);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int binarySearch(List<Double> angles, int start, int length, double target){\\n        int left = start, right = length - 1;\\n        int mid;\\n        int result = -1;\\n        while(left <= right){\\n            mid = left + ((right - left) >> 1);\\n            if(angles.get(mid) <= target){\\n                result = mid;\\n                left = mid + 1;\\n            }else{\\n                right = mid - 1;\\n            }\\n        } \\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452991,
                "title": "c-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int inplace = 0;\\n        vector<double> thetas;\\n        \\n        // Count points on `location` and calculate angles\\n        for (const auto& p: points) {\\n            if (p == location) {\\n                ++inplace;\\n            } else {\\n                auto v = atan2((double)p[1] - location[1], (double)p[0] - location[0]) * 180 / M_PI;\\n                thetas.push_back(v < 0 ? v + 360 : v);   \\n            }\\n        }\\n        \\n        // Wraparound logic: essentially double the array elements and add 360\\n        int n = thetas.size();\\n        for (int i = 0; i < n; ++i) {\\n            thetas.push_back(thetas[i] + 360);\\n        }\\n        \\n        // Sort angles and do sliding window\\n        sort(thetas.begin(), thetas.end());\\n        \\n        int maxPoints = 0;\\n        for (int i = 0, j = 0; j < thetas.size(); ++j) {\\n            while (i <= j && thetas[j] - thetas[i] > angle) {\\n                ++i;\\n            }\\n            \\n            maxPoints = max(maxPoints, j - i + 1);\\n        }\\n        \\n        return inplace + maxPoints;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int inplace = 0;\\n        vector<double> thetas;\\n        \\n        // Count points on `location` and calculate angles\\n        for (const auto& p: points) {\\n            if (p == location) {\\n                ++inplace;\\n            } else {\\n                auto v = atan2((double)p[1] - location[1], (double)p[0] - location[0]) * 180 / M_PI;\\n                thetas.push_back(v < 0 ? v + 360 : v);   \\n            }\\n        }\\n        \\n        // Wraparound logic: essentially double the array elements and add 360\\n        int n = thetas.size();\\n        for (int i = 0; i < n; ++i) {\\n            thetas.push_back(thetas[i] + 360);\\n        }\\n        \\n        // Sort angles and do sliding window\\n        sort(thetas.begin(), thetas.end());\\n        \\n        int maxPoints = 0;\\n        for (int i = 0, j = 0; j < thetas.size(); ++j) {\\n            while (i <= j && thetas[j] - thetas[i] > angle) {\\n                ++i;\\n            }\\n            \\n            maxPoints = max(maxPoints, j - i + 1);\\n        }\\n        \\n        return inplace + maxPoints;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445541,
                "title": "go-solution-with-explanation",
                "content": "import ( \\n    \"sort\"\\n    \"math\"\\n)\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n    slopes,samePoint:=CalculateAngles(points,location)\\n    sort.Slice(slopes,func(i,j int)bool{\\n        return slopes[i] < slopes [j]\\n    })\\n    //change angle to radian angle\\n    radAngle := (float64(angle)*math.Pi)/180\\n    start:=0\\n    count:=0 \\n    maxCount:=0\\n    //Now we got all the angles use sliding window to check how many points we can have at our field of view\\n    for i:=0;i<len(slopes);i++{\\n        if slopes[i] <= slopes[start] + radAngle {\\n            count++\\n        }else {\\n            start++\\n            for start < len(slopes) {\\n                if slopes[i] <= slopes[start] + radAngle {\\n                    break\\n                }\\n                start++\\n            }\\n            count = i - start + 1\\n        }\\n        maxCount = max(maxCount,count)\\n    }\\n    //Add samePoint -> if location and points[i] are same include it\\n    return maxCount + samePoint\\n}\\n\\nfunc max(i,j int)int {\\n    if i > j {\\n        return i\\n    }\\n    return j\\n}\\n\\n\\nfunc CalculateAngles(points [][]int,location []int)([]float64,int){\\n    slopes:=[]float64{}\\n    x:=location[0]\\n    y:=location[1]\\n    count:=0\\n//Find the All angles made by lines consisting of location and point[i]\\n//Formula tan0 = (y2-x1)/x2-x1\\n// To find angle that is theta use inverse tan function i.e atan2\\n    for _,val :=range points {\\n        diffY:=float64(val[1]-y)\\n        diffX:=float64(val[0]-x)\\n        if x == val[0] && y == val[1]{\\n            count++\\n        }else {\\n            slope:=math.Atan2(diffY,diffX)\\n            slopes = append(slopes,slope)    \\n        }\\n    }\\n//Duplicate the array to make a circular array.So that point we can also start from 4th quad to reach 1st quad \\n    for _,val := range slopes{\\n        dup:=val + 2*math.Pi\\n        slopes = append(slopes,dup)\\n    }\\n    return slopes,count\\n}",
                "solutionTags": [],
                "code": "import ( \\n    \"sort\"\\n    \"math\"\\n)\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n    slopes,samePoint:=CalculateAngles(points,location)\\n    sort.Slice(slopes,func(i,j int)bool{\\n        return slopes[i] < slopes [j]\\n    })\\n    //change angle to radian angle\\n    radAngle := (float64(angle)*math.Pi)/180\\n    start:=0\\n    count:=0 \\n    maxCount:=0\\n    //Now we got all the angles use sliding window to check how many points we can have at our field of view\\n    for i:=0;i<len(slopes);i++{\\n        if slopes[i] <= slopes[start] + radAngle {\\n            count++\\n        }else {\\n            start++\\n            for start < len(slopes) {\\n                if slopes[i] <= slopes[start] + radAngle {\\n                    break\\n                }\\n                start++\\n            }\\n            count = i - start + 1\\n        }\\n        maxCount = max(maxCount,count)\\n    }\\n    //Add samePoint -> if location and points[i] are same include it\\n    return maxCount + samePoint\\n}\\n\\nfunc max(i,j int)int {\\n    if i > j {\\n        return i\\n    }\\n    return j\\n}\\n\\n\\nfunc CalculateAngles(points [][]int,location []int)([]float64,int){\\n    slopes:=[]float64{}\\n    x:=location[0]\\n    y:=location[1]\\n    count:=0\\n//Find the All angles made by lines consisting of location and point[i]\\n//Formula tan0 = (y2-x1)/x2-x1\\n// To find angle that is theta use inverse tan function i.e atan2\\n    for _,val :=range points {\\n        diffY:=float64(val[1]-y)\\n        diffX:=float64(val[0]-x)\\n        if x == val[0] && y == val[1]{\\n            count++\\n        }else {\\n            slope:=math.Atan2(diffY,diffX)\\n            slopes = append(slopes,slope)    \\n        }\\n    }\\n//Duplicate the array to make a circular array.So that point we can also start from 4th quad to reach 1st quad \\n    for _,val := range slopes{\\n        dup:=val + 2*math.Pi\\n        slopes = append(slopes,dup)\\n    }\\n    return slopes,count\\n}",
                "codeTag": "Python3"
            },
            {
                "id": 1436629,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<long double> angles;\\n        long long x=location[0], y=location[1];\\n        long double pi=2*acos(0);\\n        int ans=0;\\n        for(int i=0;i<points.size();i++){\\n            long long x1=points[i][0], y1=points[i][1];\\n            if(x1==x && y1==y)ans++;\\n            else if(x1==x && y1>y){\\n                angles.push_back(90);\\n            } else if(x1==x && y1<y){\\n                angles.push_back(270);\\n            } else if(y1==y && x1>x){\\n                angles.push_back(0);\\n            } else if(y1==y && x1<x){\\n                angles.push_back(180);\\n            } else if(x1>x && y1>y){\\n                angles.push_back(180.0/pi*atan((long double)abs(y1-y)/abs(x1-x)));\\n            } else if(x1<x && y1>y){\\n                angles.push_back(180-180.0/pi*atan((long double)abs(y1-y)/abs(x1-x)));\\n            } else if(x1<x && y1<y){\\n                angles.push_back(180+180.0/pi*atan((long double)abs(y1-y)/abs(x1-x)));\\n            } else if(x1>x && y1<y){\\n                angles.push_back(360-180.0/pi*atan((long double)abs(y1-y)/abs(x1-x)));\\n            }\\n        }\\n        sort(angles.begin(),angles.end());\\n        int max1=(angles.size()>0);\\n        \\n        for(int i=0;i<angles.size();i++){\\n            if(angles[angles.size()-1]<=angles[i]+angle+0.00001){\\n                if(angles[i]+angle+0.00001<360){\\n                    max1=max((long long)max1,(long long)angles.size()-i);\\n                }\\n                else {\\n                    if(i==0){\\n                        return points.size();\\n                    }\\n                    long double an=angles[i]+angle+0.00001-360;\\n                    auto itr=upper_bound(angles.begin(),angles.end(),an);\\n                    max1=max((long long)max1,(long long)angles.size()-i+(long long)(itr-angles.begin()));\\n                }\\n            } else {\\n                auto itr=upper_bound(angles.begin(),angles.end(),angles[i]+angle+0.00001);\\n                max1=max((long long)max1,(long long)(itr-angles.begin()-i));\\n            }\\n        }\\n        \\n        return ans+max1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector<long double> angles;\\n        long long x=location[0], y=location[1];\\n        long double pi=2*acos(0);\\n        int ans=0;\\n        for(int i=0;i<points.size();i++){\\n            long long x1=points[i][0], y1=points[i][1];\\n            if(x1==x && y1==y)ans++;\\n            else if(x1==x && y1>y){\\n                angles.push_back(90);\\n            } else if(x1==x && y1<y){\\n                angles.push_back(270);\\n            } else if(y1==y && x1>x){\\n                angles.push_back(0);\\n            } else if(y1==y && x1<x){\\n                angles.push_back(180);\\n            } else if(x1>x && y1>y){\\n                angles.push_back(180.0/pi*atan((long double)abs(y1-y)/abs(x1-x)));\\n            } else if(x1<x && y1>y){\\n                angles.push_back(180-180.0/pi*atan((long double)abs(y1-y)/abs(x1-x)));\\n            } else if(x1<x && y1<y){\\n                angles.push_back(180+180.0/pi*atan((long double)abs(y1-y)/abs(x1-x)));\\n            } else if(x1>x && y1<y){\\n                angles.push_back(360-180.0/pi*atan((long double)abs(y1-y)/abs(x1-x)));\\n            }\\n        }\\n        sort(angles.begin(),angles.end());\\n        int max1=(angles.size()>0);\\n        \\n        for(int i=0;i<angles.size();i++){\\n            if(angles[angles.size()-1]<=angles[i]+angle+0.00001){\\n                if(angles[i]+angle+0.00001<360){\\n                    max1=max((long long)max1,(long long)angles.size()-i);\\n                }\\n                else {\\n                    if(i==0){\\n                        return points.size();\\n                    }\\n                    long double an=angles[i]+angle+0.00001-360;\\n                    auto itr=upper_bound(angles.begin(),angles.end(),an);\\n                    max1=max((long long)max1,(long long)angles.size()-i+(long long)(itr-angles.begin()));\\n                }\\n            } else {\\n                auto itr=upper_bound(angles.begin(),angles.end(),angles[i]+angle+0.00001);\\n                max1=max((long long)max1,(long long)(itr-angles.begin()-i));\\n            }\\n        }\\n        \\n        return ans+max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369544,
                "title": "python-sorting-sliding-window",
                "content": "```\\nclass Solution:\\n  def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n    # Points that are same as this location will always be visible, remove them\\n    num_points_same = len([p for p in points if p == location])\\n    points = [p for p in points if p != location]\\n    \\n    # Sort points by their polar angles with respect to east direction\\n    angles = sorted([self.get_angle(location, pt) for pt in points])\\n    \\n    # Initialize window ends \\n    window_start = 0\\n    window_end = 0\\n      \\n    max_window_len = 0\\n    n = len(angles)\\n    while window_start < n: # The window can wrap around the end\\n      # Increment start until the span of the window is within limits\\n      while self.span(angles[window_start % n], angles[window_end % n]) > angle:\\n        window_start += 1\\n      window_len = window_end - window_start + 1\\n      max_window_len = max(max_window_len, window_len)\\n      window_end += 1\\n      # Window length cannot exceed n otherwise we are repeating some points\\n      if window_end - window_start >= n:\\n        window_start += 1\\n    return num_points_same + max_window_len\\n  \\n  def span(self, angle1, angle2):\\n    if angle1 <= angle2:\\n      return angle2 - angle1\\n    return 360 - (angle1 - angle2)\\n  \\n  def get_angle(self, p1, p2):\\n    diff = [p2[0] - p1[0], p2[1] - p1[1]]\\n    if diff[0] == 0:\\n      return 90 * (1 if diff[1] > 0 else -1)\\n    if diff[1] == 0:\\n      return 0 if diff[0] > 0 else 180\\n    angle = atan(abs(diff[1]) / abs(diff[0])) * 180 / pi\\n    if diff[0] > 0 and diff[1] > 0:\\n      return angle\\n    if diff[0] > 0 and diff[1] < 0:\\n      return -angle\\n    if diff[0] < 0 and diff[1] > 0:\\n      return (180 - angle)\\n    if diff[0] < 0 and diff[1] < 0:\\n      return -(180 - angle)\\n    return angle\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n    # Points that are same as this location will always be visible, remove them\\n    num_points_same = len([p for p in points if p == location])\\n    points = [p for p in points if p != location]\\n    \\n    # Sort points by their polar angles with respect to east direction\\n    angles = sorted([self.get_angle(location, pt) for pt in points])\\n    \\n    # Initialize window ends \\n    window_start = 0\\n    window_end = 0\\n      \\n    max_window_len = 0\\n    n = len(angles)\\n    while window_start < n: # The window can wrap around the end\\n      # Increment start until the span of the window is within limits\\n      while self.span(angles[window_start % n], angles[window_end % n]) > angle:\\n        window_start += 1\\n      window_len = window_end - window_start + 1\\n      max_window_len = max(max_window_len, window_len)\\n      window_end += 1\\n      # Window length cannot exceed n otherwise we are repeating some points\\n      if window_end - window_start >= n:\\n        window_start += 1\\n    return num_points_same + max_window_len\\n  \\n  def span(self, angle1, angle2):\\n    if angle1 <= angle2:\\n      return angle2 - angle1\\n    return 360 - (angle1 - angle2)\\n  \\n  def get_angle(self, p1, p2):\\n    diff = [p2[0] - p1[0], p2[1] - p1[1]]\\n    if diff[0] == 0:\\n      return 90 * (1 if diff[1] > 0 else -1)\\n    if diff[1] == 0:\\n      return 0 if diff[0] > 0 else 180\\n    angle = atan(abs(diff[1]) / abs(diff[0])) * 180 / pi\\n    if diff[0] > 0 and diff[1] > 0:\\n      return angle\\n    if diff[0] > 0 and diff[1] < 0:\\n      return -angle\\n    if diff[0] < 0 and diff[1] > 0:\\n      return (180 - angle)\\n    if diff[0] < 0 and diff[1] < 0:\\n      return -(180 - angle)\\n    return angle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368961,
                "title": "python-sorting-binary-search",
                "content": "```\\nimport math, bisect\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        degrees = []\\n        n_ovlp = 0\\n        for x, y in points:\\n            if x == location[0] and y == location[1]:\\n                n_ovlp += 1\\n                continue\\n            degree = (math.atan2(y-location[1], x-location[0]) * 180 / math.pi) % 360\\n            degrees.append(degree)\\n        degrees.sort()\\n        res = 0\\n        for i, degree in enumerate(degrees):\\n            ub = (degree + angle) % 360\\n            ub_idx = bisect.bisect_right(degrees, ub)\\n            if ub_idx > i:\\n                npoints = bisect.bisect_right(degrees, ub) - i\\n            else:\\n                npoints = ub_idx + len(degrees) - i\\n            res = max(npoints, res)\\n        return res + n_ovlp\\n```",
                "solutionTags": [],
                "code": "```\\nimport math, bisect\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        degrees = []\\n        n_ovlp = 0\\n        for x, y in points:\\n            if x == location[0] and y == location[1]:\\n                n_ovlp += 1\\n                continue\\n            degree = (math.atan2(y-location[1], x-location[0]) * 180 / math.pi) % 360\\n            degrees.append(degree)\\n        degrees.sort()\\n        res = 0\\n        for i, degree in enumerate(degrees):\\n            ub = (degree + angle) % 360\\n            ub_idx = bisect.bisect_right(degrees, ub)\\n            if ub_idx > i:\\n                npoints = bisect.bisect_right(degrees, ub) - i\\n            else:\\n                npoints = ub_idx + len(degrees) - i\\n            res = max(npoints, res)\\n        return res + n_ovlp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303915,
                "title": "python-clean-code",
                "content": "just converting angle to radians and using sliding window\\n\\n```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        def convert():\\n            pass\\n        \\n        count = 0\\n        xx, yy = location\\n        points_in_radians = list()\\n        for point in points:\\n            x = point[0] - xx\\n            y = point[1] - yy\\n            \\n            if x == 0 and y == 0:\\n                count += 1\\n                continue\\n                \\n            points_in_radians.append(math.atan2(y, x))\\n        \\n        n = len(points_in_radians)\\n        for i in range(n):\\n            points_in_radians.append(points_in_radians[i] + 2 * math.pi)\\n        \\n        points_in_radians.sort()\\n        angle_in_radian = angle * math.pi / 180\\n        \\n\\n        i = 0\\n        j = 0\\n        res = 0\\n        while i < len(points_in_radians):\\n            if points_in_radians[i] - points_in_radians[j] > angle_in_radian:\\n                j += 1\\n            res = max(res, i - j + 1)\\n            i += 1\\n        return res + count\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        def convert():\\n            pass\\n        \\n        count = 0\\n        xx, yy = location\\n        points_in_radians = list()\\n        for point in points:\\n            x = point[0] - xx\\n            y = point[1] - yy\\n            \\n            if x == 0 and y == 0:\\n                count += 1\\n                continue\\n                \\n            points_in_radians.append(math.atan2(y, x))\\n        \\n        n = len(points_in_radians)\\n        for i in range(n):\\n            points_in_radians.append(points_in_radians[i] + 2 * math.pi)\\n        \\n        points_in_radians.sort()\\n        angle_in_radian = angle * math.pi / 180\\n        \\n\\n        i = 0\\n        j = 0\\n        res = 0\\n        while i < len(points_in_radians):\\n            if points_in_radians[i] - points_in_radians[j] > angle_in_radian:\\n                j += 1\\n            res = max(res, i - j + 1)\\n            i += 1\\n        return res + count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256198,
                "title": "javascript-o-nlogn-by-sliding-window-on-circular-space",
                "content": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} angle\\n * @param {number[]} location\\n * @return {number}\\n */\\nvar visiblePoints = function(points, angle, location) {\\n    /* sliding window in circular array. Since we need to sort the array, so O(nlogn) */\\n    /* turn all points into degree */\\n    const r2d = 180 / Math.PI;\\n    let selfCount = 0;\\n    const pointDegs = [];\\n    \\n    points.forEach((p) => {\\n        if (p[1] === location[1] && p[0] === location[0]) {\\n            selfCount++;\\n            return;\\n        }\\n        pointDegs.push(Math.atan2(\\n            p[1] - location[1],\\n            p[0] - location[0],\\n        ) * r2d);\\n    });\\n    \\n    pointDegs.sort((a, b) => (a - b));\\n    \\n    /* make it double so that we can cover this circular array */\\n    pointDegs.slice(0).forEach((d) => {\\n        pointDegs.push(d + 360);\\n    });\\n    \\n    let maxCount = 0;\\n    let left = 0, right = 0;\\n    \\n    while (right < pointDegs.length) {\\n        if (pointDegs[right] - pointDegs[left] <= angle) {\\n            if (maxCount < right - left + 1) {\\n                maxCount = right - left + 1;\\n            }\\n            right++;\\n            continue;\\n        }\\n        \\n        while (left <= right) {\\n            if (pointDegs[right] - pointDegs[left] <= angle) { break; }\\n            left++;\\n        }\\n        \\n        right++;\\n    }\\n    \\n    return maxCount + selfCount;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} points\\n * @param {number} angle\\n * @param {number[]} location\\n * @return {number}\\n */\\nvar visiblePoints = function(points, angle, location) {\\n    /* sliding window in circular array. Since we need to sort the array, so O(nlogn) */\\n    /* turn all points into degree */\\n    const r2d = 180 / Math.PI;\\n    let selfCount = 0;\\n    const pointDegs = [];\\n    \\n    points.forEach((p) => {\\n        if (p[1] === location[1] && p[0] === location[0]) {\\n            selfCount++;\\n            return;\\n        }\\n        pointDegs.push(Math.atan2(\\n            p[1] - location[1],\\n            p[0] - location[0],\\n        ) * r2d);\\n    });\\n    \\n    pointDegs.sort((a, b) => (a - b));\\n    \\n    /* make it double so that we can cover this circular array */\\n    pointDegs.slice(0).forEach((d) => {\\n        pointDegs.push(d + 360);\\n    });\\n    \\n    let maxCount = 0;\\n    let left = 0, right = 0;\\n    \\n    while (right < pointDegs.length) {\\n        if (pointDegs[right] - pointDegs[left] <= angle) {\\n            if (maxCount < right - left + 1) {\\n                maxCount = right - left + 1;\\n            }\\n            right++;\\n            continue;\\n        }\\n        \\n        while (left <= right) {\\n            if (pointDegs[right] - pointDegs[left] <= angle) { break; }\\n            left++;\\n        }\\n        \\n        right++;\\n    }\\n    \\n    return maxCount + selfCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1226532,
                "title": "python-o-n-log-n-by-sorting-and-two-pointers",
                "content": "One has to deal with the points at location in a special way, because their angle is undefined. They are always in the cone.\\n```\\nimport math\\n\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angle = angle * math.pi / 180  # convert to radians\\n        # convert points to angles\\n        centered_points = ([p[0] - location[0], p[1] - location[1]] for p in points if p != location)\\n        angles = [math.atan2(p[1], p[0]) for p in centered_points]\\n        zero_points = len(points) - len(angles)\\n        nonzero_points = len(angles)\\n        # Sort by angle\\n        angles.sort()\\n        # add copy of angles + 2*pi to the end so range is [-pi, 3*pi)\\n        angles = angles + [ang + 2 * math.pi for ang in angles]\\n        \\n        # for each point determine how many points are in cone, if that point is on the right side of the cone\\n        max_points = zero_points\\n        end_index = 0\\n        for i in range(nonzero_points):\\n            left_angle = angles[i] + angle\\n            # to determine the left point use binary search\\n            while angles[end_index] <= left_angle:\\n                end_index += 1\\n            max_points = max(end_index - i + zero_points, max_points)\\n            \\n        return max_points",
                "solutionTags": [],
                "code": "One has to deal with the points at location in a special way, because their angle is undefined. They are always in the cone.\\n```\\nimport math\\n\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angle = angle * math.pi / 180  # convert to radians\\n        # convert points to angles\\n        centered_points = ([p[0] - location[0], p[1] - location[1]] for p in points if p != location)\\n        angles = [math.atan2(p[1], p[0]) for p in centered_points]\\n        zero_points = len(points) - len(angles)\\n        nonzero_points = len(angles)\\n        # Sort by angle\\n        angles.sort()\\n        # add copy of angles + 2*pi to the end so range is [-pi, 3*pi)\\n        angles = angles + [ang + 2 * math.pi for ang in angles]\\n        \\n        # for each point determine how many points are in cone, if that point is on the right side of the cone\\n        max_points = zero_points\\n        end_index = 0\\n        for i in range(nonzero_points):\\n            left_angle = angles[i] + angle\\n            # to determine the left point use binary search\\n            while angles[end_index] <= left_angle:\\n                end_index += 1\\n            max_points = max(end_index - i + zero_points, max_points)\\n            \\n        return max_points",
                "codeTag": "Java"
            },
            {
                "id": 1204149,
                "title": "python3-beats-92-uses-atan2-and-binarysearch",
                "content": "Uses field of vision from current points angle to get a rotating window approach. \\nFor angles close to 360, remaining angle greater than 0 degree found separately.\\n\\n(please let me know in comments if code is not explanatory, I will add more explanation)\\n\\n```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        \\n        def getAngle(x,y):\\n            d = math.degrees(math.atan2(y,x))\\n            if 0 <= d <= 180:\\n                return d\\n            else:\\n                return 360+d\\n        \\n        \\n        angle_counts = collections.Counter()\\n        own = 0\\n        \\n        for p in points:\\n            y = p[0]-location[0]\\n            x = p[1]-location[1]\\n            if x == 0 and y == 0:\\n                own += 1\\n            else:\\n                angle_counts[getAngle(x,y)] += 1\\n            \\n\\n        angles = []\\n        counts = []\\n        for k in sorted(list(angle_counts.keys())):\\n            angles.append(k)\\n            counts.append(angle_counts[k])\\n\\n            \\n        s = 0\\n        sums = []\\n        for c in counts:\\n            s += c\\n            sums.append(s)\\n        \\n        def query(i,j):\\n            if i == 0:\\n                return sums[j]\\n            else:\\n                return sums[j] - sums[i-1]\\n        \\n        mx = 0\\n        for i,a in enumerate(angles):\\n            if a + angle <= 360:\\n                idx = bisect.bisect_left(angles,a+angle)\\n                if idx == len(angles) or angles[idx] > (a+angle):\\n                    idx -= 1\\n                mx = max(mx,query(i,idx))\\n            else:\\n                rem = (a+angle)-360\\n                pts = query(i,len(angles)-1)\\n                idx = bisect.bisect_left(angles,rem)\\n                if idx == 0 and angles[idx] > rem:\\n                    pts += 0\\n                else:\\n                    if idx == len(angles) or angles[idx] > rem:\\n                        idx -= 1\\n                    pts += query(0,idx)\\n                mx = max(pts,mx)\\n        return mx+own\\n                \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        \\n        def getAngle(x,y):\\n            d = math.degrees(math.atan2(y,x))\\n            if 0 <= d <= 180:\\n                return d\\n            else:\\n                return 360+d\\n        \\n        \\n        angle_counts = collections.Counter()\\n        own = 0\\n        \\n        for p in points:\\n            y = p[0]-location[0]\\n            x = p[1]-location[1]\\n            if x == 0 and y == 0:\\n                own += 1\\n            else:\\n                angle_counts[getAngle(x,y)] += 1\\n            \\n\\n        angles = []\\n        counts = []\\n        for k in sorted(list(angle_counts.keys())):\\n            angles.append(k)\\n            counts.append(angle_counts[k])\\n\\n            \\n        s = 0\\n        sums = []\\n        for c in counts:\\n            s += c\\n            sums.append(s)\\n        \\n        def query(i,j):\\n            if i == 0:\\n                return sums[j]\\n            else:\\n                return sums[j] - sums[i-1]\\n        \\n        mx = 0\\n        for i,a in enumerate(angles):\\n            if a + angle <= 360:\\n                idx = bisect.bisect_left(angles,a+angle)\\n                if idx == len(angles) or angles[idx] > (a+angle):\\n                    idx -= 1\\n                mx = max(mx,query(i,idx))\\n            else:\\n                rem = (a+angle)-360\\n                pts = query(i,len(angles)-1)\\n                idx = bisect.bisect_left(angles,rem)\\n                if idx == 0 and angles[idx] > rem:\\n                    pts += 0\\n                else:\\n                    if idx == len(angles) or angles[idx] > rem:\\n                        idx -= 1\\n                    pts += query(0,idx)\\n                mx = max(pts,mx)\\n        return mx+own\\n                \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193427,
                "title": "c-beats-91-time",
                "content": "```\\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) \\n{\\n\\tint count_same = 0, count = 0;\\n\\tvector<double> angles;\\n\\n\\t// We need to count the points which are at the same location as the camera\\n\\t// and seperate them out\\n\\tfor (auto &elem : points)\\n\\t{\\n\\t\\tif (elem == location)\\n\\t\\t{\\n\\t\\t\\tcount_same++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tangles.push_back(atan2((elem[1] - location[1]), (elem[0] - location[0])) * 180.0/M_PI);\\n\\t\\t}\\n\\t}\\n\\n\\tsort(angles.begin(), angles.end());\\n\\n\\tint i = 0, j = 0;\\n\\tint N = angles.size();\\n\\n\\t// From the top comment, here we cannot include the points in the same location as the camera\\n\\t// instead of counting them at the top because here we are updating the count as length between points.\\n\\t// It won\\'t get updated correctly if same location points are included here itself\\n\\twhile (i < N && j < N*2)\\n\\t{\\n\\t\\tdouble angleDiff = (angles[j % N] - angles[i] + ((j >= N) ? 360.0 : 0.0));\\n\\n\\t\\tif (angleDiff <= (double)angle)\\n\\t\\t{\\n\\t\\t\\tcount = max(count, j - i + 1);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count_same + count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) \\n{\\n\\tint count_same = 0, count = 0;\\n\\tvector<double> angles;\\n\\n\\t// We need to count the points which are at the same location as the camera\\n\\t// and seperate them out\\n\\tfor (auto &elem : points)\\n\\t{\\n\\t\\tif (elem == location)\\n\\t\\t{\\n\\t\\t\\tcount_same++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tangles.push_back(atan2((elem[1] - location[1]), (elem[0] - location[0])) * 180.0/M_PI);\\n\\t\\t}\\n\\t}\\n\\n\\tsort(angles.begin(), angles.end());\\n\\n\\tint i = 0, j = 0;\\n\\tint N = angles.size();\\n\\n\\t// From the top comment, here we cannot include the points in the same location as the camera\\n\\t// instead of counting them at the top because here we are updating the count as length between points.\\n\\t// It won\\'t get updated correctly if same location points are included here itself\\n\\twhile (i < N && j < N*2)\\n\\t{\\n\\t\\tdouble angleDiff = (angles[j % N] - angles[i] + ((j >= N) ? 360.0 : 0.0));\\n\\n\\t\\tif (angleDiff <= (double)angle)\\n\\t\\t{\\n\\t\\t\\tcount = max(count, j - i + 1);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn count_same + count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1192029,
                "title": "python-o-nlogn-solution-simple",
                "content": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angles = []\\n        amount = 0\\n        same = 0\\n        # O(n)\\n        for x, y in points:\\n            dx = x - location[0]\\n            dy = y - location[1]\\n            if dx == 0 and dy == 0:\\n                same += 1\\n            else:\\n                degree = math.atan2(dx, dy) * (180 / math.pi)\\n                angles.append(degree)\\n            \\n        # O(nlogn)\\n        angles.sort()\\n        start, slider = 0, 0\\n        \\n        # O(n)\\n        for a in list(angles):\\n            angles.append(a+360)\\n            \\n        # O(n)\\n        while slider < len(angles):\\n            if angles[slider] - angles[start] <= angle:\\n                slider += 1\\n            else:\\n                start += 1\\n            amount = max(amount, slider - start + same)\\n        \\n        return max(amount, same)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        angles = []\\n        amount = 0\\n        same = 0\\n        # O(n)\\n        for x, y in points:\\n            dx = x - location[0]\\n            dy = y - location[1]\\n            if dx == 0 and dy == 0:\\n                same += 1\\n            else:\\n                degree = math.atan2(dx, dy) * (180 / math.pi)\\n                angles.append(degree)\\n            \\n        # O(nlogn)\\n        angles.sort()\\n        start, slider = 0, 0\\n        \\n        # O(n)\\n        for a in list(angles):\\n            angles.append(a+360)\\n            \\n        # O(n)\\n        while slider < len(angles):\\n            if angles[slider] - angles[start] <= angle:\\n                slider += 1\\n            else:\\n                start += 1\\n            amount = max(amount, slider - start + same)\\n        \\n        return max(amount, same)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190815,
                "title": "java-o-n-log-n-circular-sliding-window",
                "content": "Calculate angles ranging from 0-359, sort them, and run the Sliding Window in a circular fashion, with every angle as starting point.\\n\\n```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int max = 0;\\n        int count = 0;\\n\\n        List<Double> angles = new ArrayList<>(points.size());\\n        for(int i=0; i<points.size(); i++) {\\n            double a = calculateAngle(location, points.get(i));// Calculate angle made with the location (0-359)\\n            if(a == 360.0) {\\n                count++; // Edge case if point is the same as the location. Will be added to the final sum\\n            } else {\\n                angles.add(a);\\n            }\\n        };\\n        Collections.sort(angles); // Sort to use Sliding window\\n\\n        int s = 0;\\n        int e = 0;\\n        int size;\\n        int n = angles.size();\\n\\n        while(s < n && max < n) { // Circular Sliding window, where s to e has angle difference <= angle\\n            while(true) {\\n                int index = (e+1) % n; // e should move to the next index, only if it is in the angle, so that calculated size from s to e is always in the angle\\n                if(s == index || (360 + angles.get(index) - angles.get(s)) % 360 > angle) { // Check for angle and also that e should not cross s\\n                    break;\\n                }\\n                e = index;\\n            }\\n            size = e >= s ? (e-s+1) : (n-s+e+1); // Size of the circular sliding window\\n            max = Math.max(max, size);\\n            \\n            if(e == s) { // Increment e, as it will not be done in the while loop if e == s\\n                e++;\\n            }\\n            s++;\\n        }\\n\\n        return max + count;\\n    }\\n\\n    public double calculateAngle(List<Integer> location, List<Integer> point) {\\n        int x1 = location.get(0);\\n        int y1 = location.get(1);\\n        int x2 = point.get(0);\\n        int y2 = point.get(1);\\n\\n        if(x1 == x2) {\\n            if(y2>y1) {\\n                return 90.0;\\n            } if(y2<y1) {\\n                return 270.0;\\n            }\\n            return 360.0;\\n        }\\n\\n        double angle = Math.toDegrees(Math.atan((double)(y2-y1)/(x2-x1)));\\n\\n        if(x2 > x1) {\\n            angle = (angle + 360.0) % 360.0;\\n        } else {\\n            angle += 180.0;\\n        }\\n        return angle;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n        int max = 0;\\n        int count = 0;\\n\\n        List<Double> angles = new ArrayList<>(points.size());\\n        for(int i=0; i<points.size(); i++) {\\n            double a = calculateAngle(location, points.get(i));// Calculate angle made with the location (0-359)\\n            if(a == 360.0) {\\n                count++; // Edge case if point is the same as the location. Will be added to the final sum\\n            } else {\\n                angles.add(a);\\n            }\\n        };\\n        Collections.sort(angles); // Sort to use Sliding window\\n\\n        int s = 0;\\n        int e = 0;\\n        int size;\\n        int n = angles.size();\\n\\n        while(s < n && max < n) { // Circular Sliding window, where s to e has angle difference <= angle\\n            while(true) {\\n                int index = (e+1) % n; // e should move to the next index, only if it is in the angle, so that calculated size from s to e is always in the angle\\n                if(s == index || (360 + angles.get(index) - angles.get(s)) % 360 > angle) { // Check for angle and also that e should not cross s\\n                    break;\\n                }\\n                e = index;\\n            }\\n            size = e >= s ? (e-s+1) : (n-s+e+1); // Size of the circular sliding window\\n            max = Math.max(max, size);\\n            \\n            if(e == s) { // Increment e, as it will not be done in the while loop if e == s\\n                e++;\\n            }\\n            s++;\\n        }\\n\\n        return max + count;\\n    }\\n\\n    public double calculateAngle(List<Integer> location, List<Integer> point) {\\n        int x1 = location.get(0);\\n        int y1 = location.get(1);\\n        int x2 = point.get(0);\\n        int y2 = point.get(1);\\n\\n        if(x1 == x2) {\\n            if(y2>y1) {\\n                return 90.0;\\n            } if(y2<y1) {\\n                return 270.0;\\n            }\\n            return 360.0;\\n        }\\n\\n        double angle = Math.toDegrees(Math.atan((double)(y2-y1)/(x2-x1)));\\n\\n        if(x2 > x1) {\\n            angle = (angle + 360.0) % 360.0;\\n        } else {\\n            angle += 180.0;\\n        }\\n        return angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168911,
                "title": "c-runtime-faster-than-100-00-memory-usage-less-than-100-00",
                "content": "```\\npublic class Solution {\\n    public int VisiblePoints(IList<IList<int>> points, int angle, IList<int> location) {\\n        \\n        int pointsAtOrigin;\\n        \\n        List<double> angles = getSortedListOfAngles(points, location, out pointsAtOrigin);\\n\\n        int max = getMaxAnglesInGivenDiapason(angles, angle);\\n        \\n        return max + pointsAtOrigin;\\n    }\\n    \\n    private int getMaxAnglesInGivenDiapason(List<double> angles, int angle) {\\n        \\n        if (angles.Count == 0)\\n            return 0;\\n        \\n        int max = 0;\\n        int left = 0;\\n        int right = 0;\\n        int currentCount = 1;\\n        \\n        while (left != angles.Count-1) {\\n            \\n            double leftValue = angles[left];\\n            double currentLimit = leftValue + angle;\\n            double sortedRightIndex = getSortedRightIndex(right, angles);\\n            \\n            while (sortedRightIndex <= currentLimit) {\\n                currentCount++;\\n                right++;\\n                \\n                sortedRightIndex = getSortedRightIndex(right, angles);\\n            }\\n            currentCount--;\\n            max = Math.Max(max, currentCount);\\n            left++;\\n        }\\n        return max;\\n    }\\n    \\n    private List<double> getSortedListOfAngles(IList<IList<int>> points, IList<int> location, out int pointsAtOrigin) {\\n        \\n        List<double> angles = new List<double>();\\n        \\n        pointsAtOrigin  = 0;      \\n        \\n        for (int i=0; i<points.Count; i++) {\\n            \\n            var currentPoint = points[i];\\n            \\n            if (currentPoint[0] == location[0] && currentPoint[1] == location[1]) {\\n                pointsAtOrigin++;\\n                continue;\\n            }\\n            \\n            int triangleXLength = currentPoint[0] - location[0];\\n            int triangleYLength = currentPoint[1] - location[1];\\n\\n            double degrees = Math.Atan2(triangleXLength,triangleYLength) * (180.0 / Math.PI);\\n            \\n            angles.Add(degrees);\\n        }\\n        \\n        angles.Sort();\\n        \\n        return angles;\\n    }\\n    \\n    private double getSortedRightIndex(int right, List<double> angles) {\\n        if (right <angles.Count)\\n            return angles[right];\\n        \\n        return 360 + angles[right - angles.Count];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int VisiblePoints(IList<IList<int>> points, int angle, IList<int> location) {\\n        \\n        int pointsAtOrigin;\\n        \\n        List<double> angles = getSortedListOfAngles(points, location, out pointsAtOrigin);\\n\\n        int max = getMaxAnglesInGivenDiapason(angles, angle);\\n        \\n        return max + pointsAtOrigin;\\n    }\\n    \\n    private int getMaxAnglesInGivenDiapason(List<double> angles, int angle) {\\n        \\n        if (angles.Count == 0)\\n            return 0;\\n        \\n        int max = 0;\\n        int left = 0;\\n        int right = 0;\\n        int currentCount = 1;\\n        \\n        while (left != angles.Count-1) {\\n            \\n            double leftValue = angles[left];\\n            double currentLimit = leftValue + angle;\\n            double sortedRightIndex = getSortedRightIndex(right, angles);\\n            \\n            while (sortedRightIndex <= currentLimit) {\\n                currentCount++;\\n                right++;\\n                \\n                sortedRightIndex = getSortedRightIndex(right, angles);\\n            }\\n            currentCount--;\\n            max = Math.Max(max, currentCount);\\n            left++;\\n        }\\n        return max;\\n    }\\n    \\n    private List<double> getSortedListOfAngles(IList<IList<int>> points, IList<int> location, out int pointsAtOrigin) {\\n        \\n        List<double> angles = new List<double>();\\n        \\n        pointsAtOrigin  = 0;      \\n        \\n        for (int i=0; i<points.Count; i++) {\\n            \\n            var currentPoint = points[i];\\n            \\n            if (currentPoint[0] == location[0] && currentPoint[1] == location[1]) {\\n                pointsAtOrigin++;\\n                continue;\\n            }\\n            \\n            int triangleXLength = currentPoint[0] - location[0];\\n            int triangleYLength = currentPoint[1] - location[1];\\n\\n            double degrees = Math.Atan2(triangleXLength,triangleYLength) * (180.0 / Math.PI);\\n            \\n            angles.Add(degrees);\\n        }\\n        \\n        angles.Sort();\\n        \\n        return angles;\\n    }\\n    \\n    private double getSortedRightIndex(int right, List<double> angles) {\\n        if (right <angles.Count)\\n            return angles[right];\\n        \\n        return 360 + angles[right - angles.Count];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125707,
                "title": "c-compact",
                "content": "\\n   \\n    const long double PI = 3.14159265;\\n    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector <long double> degrees;\\n        int originCount = 0;\\n        for(auto each : points){\\n            if(each == location)originCount++;\\n            else degrees.push_back(atan2(each[1] - location[1], each[0] - location[0]) * 180.0 / PI);\\n        }\\n        sort(degrees.begin(), degrees.end());\\n        degrees.insert(degrees.end(), degrees.begin(), degrees.end());\\n        int n = degrees.size(), l = 0, r = 0, result = 0;\\n        while(l < n/2 && r < n){\\n            if(degrees[r] - degrees[l] + ((r >= n/2) ? 360 : 0) <= (long double)angle){\\n                result = max(result, r-l+1);\\n                r++;\\n            }\\n            else l++;\\n        }\\n        return result + originCount;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n   \\n    const long double PI = 3.14159265;\\n    \\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        vector <long double> degrees;\\n        int originCount = 0;\\n        for(auto each : points){\\n            if(each == location)originCount++;\\n            else degrees.push_back(atan2(each[1] - location[1], each[0] - location[0]) * 180.0 / PI);\\n        }\\n        sort(degrees.begin(), degrees.end());\\n        degrees.insert(degrees.end(), degrees.begin(), degrees.end());\\n        int n = degrees.size(), l = 0, r = 0, result = 0;\\n        while(l < n/2 && r < n){\\n            if(degrees[r] - degrees[l] + ((r >= n/2) ? 360 : 0) <= (long double)angle){\\n                result = max(result, r-l+1);\\n                r++;\\n            }\\n            else l++;\\n        }\\n        return result + originCount;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1113061,
                "title": "golang-78-simple-math-with-rounded-sliding-window",
                "content": "```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n    r2d := float64(180) / math.Pi\\n    l := len(points)\\n    \\n    if angle < 0 { angle *= -1 }\\n    if angle == 360 { return l }\\n    \\n    /* turn all points into degrees against location, exclude points at locations */\\n    degrees := make([]float64, 0, l * 2)\\n    result := 0\\n    \\n    for _, p := range points {\\n        if p[0] == location[0] && p[1] == location[1] {\\n            result++\\n            continue\\n        }\\n        \\n        d := math.Atan2(\\n            float64(p[1] - location[1]),\\n            float64(p[0] - location[0]),\\n        ) - math.Pi // [-2Pi, 0]\\n        d *= r2d\\n        degrees = append(degrees, d)\\n    }\\n    \\n    sort.Float64s(degrees)\\n    \\n    l = len(degrees)\\n    \\n    /* append values range from [0, 2Pi] */\\n    for i := 0; i < l; i++ {\\n        degrees = append(degrees, degrees[i] + 360)\\n    }\\n    \\n    l *= 2\\n    pf, pb := 0, 0\\n    max := 0\\n    \\n    for pf < l {\\n        cut := degrees[pf] - float64(angle)\\n        \\n        if degrees[pb] >= cut {\\n            if pf - pb + 1 > max { max = pf - pb + 1 }\\n            pf++\\n            continue\\n        }\\n        \\n        for pb <= pf && degrees[pb] < cut  {\\n            pb++\\n        }\\n        \\n        pf++\\n    }\\n    \\n    return result + max\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n    \"math\"\\n    \"sort\"\\n)\\n\\nfunc visiblePoints(points [][]int, angle int, location []int) int {\\n    r2d := float64(180) / math.Pi\\n    l := len(points)\\n    \\n    if angle < 0 { angle *= -1 }\\n    if angle == 360 { return l }\\n    \\n    /* turn all points into degrees against location, exclude points at locations */\\n    degrees := make([]float64, 0, l * 2)\\n    result := 0\\n    \\n    for _, p := range points {\\n        if p[0] == location[0] && p[1] == location[1] {\\n            result++\\n            continue\\n        }\\n        \\n        d := math.Atan2(\\n            float64(p[1] - location[1]),\\n            float64(p[0] - location[0]),\\n        ) - math.Pi // [-2Pi, 0]\\n        d *= r2d\\n        degrees = append(degrees, d)\\n    }\\n    \\n    sort.Float64s(degrees)\\n    \\n    l = len(degrees)\\n    \\n    /* append values range from [0, 2Pi] */\\n    for i := 0; i < l; i++ {\\n        degrees = append(degrees, degrees[i] + 360)\\n    }\\n    \\n    l *= 2\\n    pf, pb := 0, 0\\n    max := 0\\n    \\n    for pf < l {\\n        cut := degrees[pf] - float64(angle)\\n        \\n        if degrees[pb] >= cut {\\n            if pf - pb + 1 > max { max = pf - pb + 1 }\\n            pf++\\n            continue\\n        }\\n        \\n        for pb <= pf && degrees[pb] < cut  {\\n            pb++\\n        }\\n        \\n        pf++\\n    }\\n    \\n    return result + max\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1087321,
                "title": "c-slow",
                "content": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int zeros = 0;\\n        double small = 1e-3;\\n        vector<double> v;\\n        for(auto p : points) {\\n            if(p[0] == location[0] && p[1] == location[1]) {\\n                zeros++;\\n                continue;\\n            }\\n            \\n            double dx = p[0] - location[0];\\n            double dy = p[1] - location[1];\\n            \\n            double degree = (atan2(dy, dx) * 180) / acos(-1); \\n            v.push_back(degree);\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        int ans = 0;\\n        for(int i=0; i<v.size(); i++) {\\n            double start = v[i]; // start degree\\n            double end = start + angle + small; // end degree. \\n\\n            auto itEnd = lower_bound(v.begin(), v.end(), end);\\n            auto itStart = lower_bound(v.begin(), v.end(), start);\\n            int num = itEnd - itStart;\\n            \\n            // Rotate if end degree > 180, we need to count another range, which starts from -180.\\n            if(end > 180.0 + small) {\\n                double nEnd = -180.0 + (end - 180);\\n                num += lower_bound(v.begin(), v.end(), nEnd) - v.begin();\\n                \\n            }\\n            ans = max(ans, num);\\n            \\n        }\\n        return ans + zeros;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {\\n        int zeros = 0;\\n        double small = 1e-3;\\n        vector<double> v;\\n        for(auto p : points) {\\n            if(p[0] == location[0] && p[1] == location[1]) {\\n                zeros++;\\n                continue;\\n            }\\n            \\n            double dx = p[0] - location[0];\\n            double dy = p[1] - location[1];\\n            \\n            double degree = (atan2(dy, dx) * 180) / acos(-1); \\n            v.push_back(degree);\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        int ans = 0;\\n        for(int i=0; i<v.size(); i++) {\\n            double start = v[i]; // start degree\\n            double end = start + angle + small; // end degree. \\n\\n            auto itEnd = lower_bound(v.begin(), v.end(), end);\\n            auto itStart = lower_bound(v.begin(), v.end(), start);\\n            int num = itEnd - itStart;\\n            \\n            // Rotate if end degree > 180, we need to count another range, which starts from -180.\\n            if(end > 180.0 + small) {\\n                double nEnd = -180.0 + (end - 180);\\n                num += lower_bound(v.begin(), v.end(), nEnd) - v.begin();\\n                \\n            }\\n            ans = max(ans, num);\\n            \\n        }\\n        return ans + zeros;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067957,
                "title": "share-my-java-solution-using-sliding-window-algorithm",
                "content": "```\\nimport java.lang.*;\\nclass Solution {\\n    public int org_point = 0;\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n         List<Double> radian_list = new ArrayList<>();\\n         for(List<Integer> point: points){\\n             double val = get_radian(point, location);\\n             if(val != -2){\\n                 radian_list.add(val);\\n             }\\n         }\\n         Collections.sort(radian_list);\\n         int size = radian_list.size();\\n         for(int i=0;i<size;i++){\\n             radian_list.add(radian_list.get(i) + 2*Math.PI);\\n         }\\n        \\n         double threshold = (angle/180.0)*Math.PI;\\n         int start = 0;\\n         int max_count = 0;\\n         for(int i=0;i<radian_list.size();i++){\\n             double cur_radian = radian_list.get(i);\\n             while(cur_radian - radian_list.get(start)>threshold+0.00000001){\\n                 start++;\\n             }\\n             max_count = Math.max(max_count, i-start+1);\\n         }\\n        \\n        \\n        \\n         return max_count + org_point;\\n         \\n    }\\n    \\n    \\n    public double get_radian(List<Integer> input, List<Integer> location){\\n        List<Integer> point = new ArrayList<>();\\n        double x = input.get(0) - location.get(0);\\n        double y = input.get(1) - location.get(1);\\n        //System.out.println(\"y: \" + y);\\n        if(x==0 && y==0){\\n            org_point++;\\n            return -2;\\n        }\\n        double cos_val = x/Math.sqrt(x*x+y*y);\\n        double radian = Math.acos(cos_val);\\n        if(y<0){\\n            return -radian;\\n        }\\n\\n        return radian;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.lang.*;\\nclass Solution {\\n    public int org_point = 0;\\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\\n         List<Double> radian_list = new ArrayList<>();\\n         for(List<Integer> point: points){\\n             double val = get_radian(point, location);\\n             if(val != -2){\\n                 radian_list.add(val);\\n             }\\n         }\\n         Collections.sort(radian_list);\\n         int size = radian_list.size();\\n         for(int i=0;i<size;i++){\\n             radian_list.add(radian_list.get(i) + 2*Math.PI);\\n         }\\n        \\n         double threshold = (angle/180.0)*Math.PI;\\n         int start = 0;\\n         int max_count = 0;\\n         for(int i=0;i<radian_list.size();i++){\\n             double cur_radian = radian_list.get(i);\\n             while(cur_radian - radian_list.get(start)>threshold+0.00000001){\\n                 start++;\\n             }\\n             max_count = Math.max(max_count, i-start+1);\\n         }\\n        \\n        \\n        \\n         return max_count + org_point;\\n         \\n    }\\n    \\n    \\n    public double get_radian(List<Integer> input, List<Integer> location){\\n        List<Integer> point = new ArrayList<>();\\n        double x = input.get(0) - location.get(0);\\n        double y = input.get(1) - location.get(1);\\n        //System.out.println(\"y: \" + y);\\n        if(x==0 && y==0){\\n            org_point++;\\n            return -2;\\n        }\\n        double cos_val = x/Math.sqrt(x*x+y*y);\\n        double radian = Math.acos(cos_val);\\n        if(y<0){\\n            return -radian;\\n        }\\n\\n        return radian;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564958,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1564766,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1570401,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1574443,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1711216,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1679853,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1996952,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1574442,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1997911,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1913421,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1564958,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1564766,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1570401,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1574443,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1711216,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1679853,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1996952,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1574442,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1997911,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            },
            {
                "id": 1913421,
                "content": [
                    {
                        "username": "Tikli",
                        "content": "It took me some time to understand the code that everyone has posted here, so I have tried to put down my thoughts in this post. If you understand the logic, it is a fairly easy implementation. Please do comment for further clarifications or improvements.\\n\\nCode reference: https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877822/Python-clean-sliding-window-solution-with-explanation (Python) or https://leetcode.com/problems/maximum-number-of-visible-points/discuss/877845/JAVA-Sliding-Window (Java). Open in new tab to check the code and my points together.\\n\\n1. First, we find all the angles that the points make with respect to our central point. Since this is atan2, this is measured counterclockwise from the positive x-axis. We store all these angles for our next computation. For duplicate central points, we only store their counts and do not calculate angles for them. As mentioned in the question, these are part of the view, so we will just have to return it as an addition to our answer. Imagine the central point is now origin and axes pass through it.\\n\\n![image](https://assets.leetcode.com/users/images/e185ff6e-5ff9-4829-993f-a016ff28bb76_1601806825.3893652.png)\\n\\n\\n2. Sort this angles array. Angles with points closer to x-axis towards the right of the central point will come first. Basically, arrangement is counterclockwise as discussed above.\\n3. If you draw all this on a sheet of paper and extend all lines from the centre to each point to infinity, you will notice that all angles are basically sectors of an imaginary circle. Now, we need to start with a line and see how many portions of these irregular pizza slices we can include such that the total angle is less than or equal to given target angle. We will start from the first angle of our array that represents the first line above positive x-axis (wrt central point). Now all we have to do is go around this circle and calculate differences between these array values. Each angle value is wrt +ve x-axis, so the difference represents angle formed between two points with central point, which is what we need. \\n4. What is important is the +360 step. This is because our array is no longer linear, it\\'s circular. So the first element could be a part of the calculation we are performing towards the end of the array. Basically meaning points below the +ve-axis, now going counterclockwise, can include array elements at the beginning. So we just add extra data where each angle is extended by 360. So we go around the circle twice and include all cases.\\n(Imagine we are coming around, the first circular path has completed in our calculation. When we run into the elements at the start of the array again, they will have to be greater since we are subtracting the prev value from the next. Let\\'s say last angle in the first round was 300 degrees and we are back to 30 degrees at the start. But 30-300 won\\'t make any sense. That 30 is basically a full circle +30, so it should be 360+30=390, and then 390-300 = 90 degrees difference, which is how it intuitively looks when you see the graph. That\\'s it).\\n\\n![image](https://assets.leetcode.com/users/images/14e19c19-bcc7-44d4-8cab-3bc619601bd9_1601807292.3661292.png)\\n\\n\\n5. If there is any confusion regarding the final loop, I will explain that too. Let\\'s say we start with the first angle and move counter-clockwise. The difference is within limits, so we add it to our counter. How? Difference of indexes + 1. We start with j=0 and i goes on incrementing as it satisfies the condition, so the indexes are basically the points. First, second, third, all the points satisfy difference with first value within target angle. Now comes an angle where difference with our very first angle is greater than required. So obviously, we need to move forward. A naive way of this would be to break, assuming we are done with the first angle and now we will start with the second angle (Second angle wrt third angle, second angle wrt fourth angle, second angle wrt fifth angle and so on, basically your quadratic O(n^2)). But if you see closely, these are duplicate calculations. If the difference between first and third angle was within limits, so will be the difference between second and third angles, because it is obviously lesser. So, if the difference between fourth angle and first angle is not satisfied, we can check the difference of fourth angle and the second angle. If it is within limits, we add a counter and check if it is better than our maximum, using the same logic as above for the first angle. And so on and so forth we go, twice around this circle, finding differences, calculating number of points and comparing it with the max. At the end of this, we have our final answer. Don\\'t forget to add the extra duplicate points at the end!\\n\\nSo all in all, this is a circular sliding window solution to this problem. (Apologies for awful MS Paint artwork)"
                    },
                    {
                        "username": "Wizmann",
                        "content": "![image](https://assets.leetcode.com/users/images/3ea94186-75b0-41c8-8faf-fac0d504a719_1612001794.9732597.png)\\n\\n1. Incredibly hard to debug.\\n2. Need some long gone math knowledge.\\n3. Precision problem that the correctness is depend on which math function you are using. \\n\\nShame on you, problem setter."
                    },
                    {
                        "username": "f1re",
                        "content": "Please go through this example to understand how angle calculation between 2 points is done w.r.t x-axis:\\nhttps://math.stackexchange.com/a/1201367"
                    },
                    {
                        "username": "anecdote",
                        "content": "I had some test cases where the answer was around 11000 and the answer was off by one. I did some rounding and then other off-by-1 kind of cases occured. How do you generally fix such problems?"
                    },
                    {
                        "username": "bkchang8",
                        "content": "I feel like the problem can just provide the points in polar angles rather than in (x, y) and it will still give the same measure of the programming ability of an interviewee. Transforming (x, y) into polar angles requires specific math package to achieve and it is not relevant to an interviewee\\'s logic and coding ability whatsoever."
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "This is one of the first questions in leet code where i didn\\'t even make out what question wants even on paper forget writing code."
                    },
                    {
                        "username": "Deimvis",
                        "content": "Recipe for that problem:\n1. Little math knowledge (calculate angles of points)\n2. [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n3. [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/?envType=list&envId=e1ydeux7)"
                    },
                    {
                        "username": "GeminiC",
                        "content": "counter-clock wise.\\n\\nfor example.  location: [1,1],   P1[0,0] -> 225\\nlocation:[1,1], P2[0,2] -> 315\\n\\nI searched many post, didn\\'t find anything that can give me 225 for the first pair"
                    },
                    {
                        "username": "kaustubhmjb",
                        "content": "1. Translate origin\n2. Use sorted Polar coordinates\n3. Find longest subarray with maximum difference angle"
                    },
                    {
                        "username": "Maang-io",
                        "content": "\"Return the maximum number of points you can see\" should be changed to \"Return the maximum number of points you can see AT ANY GIVEN TIME\", otherwise I would be able to see all the points just by rotating."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Compatibility Score Sum",
        "question_content": "<p>There is a survey that consists of <code>n</code> questions where each question&#39;s answer is either <code>0</code> (no) or <code>1</code> (yes).</p>\n\n<p>The survey was given to <code>m</code> students numbered from <code>0</code> to <code>m - 1</code> and <code>m</code> mentors numbered from <code>0</code> to <code>m - 1</code>. The answers of the students are represented by a 2D integer array <code>students</code> where <code>students[i]</code> is an integer array that contains the answers of the <code>i<sup>th</sup></code> student (<strong>0-indexed</strong>). The answers of the mentors are represented by a 2D integer array <code>mentors</code> where <code>mentors[j]</code> is an integer array that contains the answers of the <code>j<sup>th</sup></code> mentor (<strong>0-indexed</strong>).</p>\n\n<p>Each student will be assigned to <strong>one</strong> mentor, and each mentor will have <strong>one</strong> student assigned to them. The <strong>compatibility score</strong> of a student-mentor pair is the number of answers that are the same for both the student and the mentor.</p>\n\n<ul>\n\t<li>For example, if the student&#39;s answers were <code>[1, <u>0</u>, <u>1</u>]</code> and the mentor&#39;s answers were <code>[0, <u>0</u>, <u>1</u>]</code>, then their compatibility score is 2 because only the second and the third answers are the same.</li>\n</ul>\n\n<p>You are tasked with finding the optimal student-mentor pairings to <strong>maximize</strong> the<strong> sum of the compatibility scores</strong>.</p>\n\n<p>Given <code>students</code> and <code>mentors</code>, return <em>the <strong>maximum compatibility score sum</strong> that can be achieved.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong>&nbsp;We assign students to mentors in the following way:\n- student 0 to mentor 2 with a compatibility score of 3.\n- student 1 to mentor 0 with a compatibility score of 2.\n- student 2 to mentor 1 with a compatibility score of 3.\nThe compatibility score sum is 3 + 2 + 3 = 8.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The compatibility score of any student-mentor pair is 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == students.length == mentors.length</code></li>\n\t<li><code>n == students[i].length == mentors[j].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 8</code></li>\n\t<li><code>students[i][k]</code> is either <code>0</code> or <code>1</code>.</li>\n\t<li><code>mentors[j][k]</code> is either <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1360805,
                "title": "backtracking-with-stl-10-lines-of-code-c",
                "content": "As constraints ```1 <= m, n <= 8```  are very small, we can easily get our answer by evaluating all possible combinations. \\nTo generate all possible combinations of students and mentors, we can shuffle any one of them in all possible way.\\n\\nIn below code i m trying to shuffle students, but shuffling of vector can be costly so I have shuffled their index and evaluated their responses by using shuffled index.\\n\\n**C++ code:**\\n```\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tint ans = 0;\\n\\tvector<int> pos;\\n\\tfor(int i=0;i<students.size();i++) pos.push_back(i);\\n\\tdo{\\n\\t\\tint curr = 0;\\n\\t\\tfor(int i = 0;i<students.size(); i++)\\n\\t\\t\\tfor(int j=0;j<students[pos[i]].size();j++)\\n\\t\\t\\t\\tcurr += (students[pos[i]][j] == mentors[i][j]);\\n\\t\\tans = max(ans, curr);\\n\\t} while(next_permutation(pos.begin(), pos.end()) );\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```1 <= m, n <= 8```\n```\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tint ans = 0;\\n\\tvector<int> pos;\\n\\tfor(int i=0;i<students.size();i++) pos.push_back(i);\\n\\tdo{\\n\\t\\tint curr = 0;\\n\\t\\tfor(int i = 0;i<students.size(); i++)\\n\\t\\t\\tfor(int j=0;j<students[pos[i]].size();j++)\\n\\t\\t\\t\\tcurr += (students[pos[i]][j] == mentors[i][j]);\\n\\t\\tans = max(ans, curr);\\n\\t} while(next_permutation(pos.begin(), pos.end()) );\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360853,
                "title": "java-backtracking-easy-to-understand",
                "content": "\\t\\n\\tclass Solution {\\n\\t\\tint max;\\n\\t\\tpublic int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n\\t\\t\\tboolean[] visited = new boolean[students.length];\\n\\t\\t\\thelper(visited, students, mentors, 0, 0);\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t\\tpublic void helper(boolean[] visited, int[][] students, int[][] mentors, int pos, int score){\\n\\t\\t\\tif(pos >= students.length){\\n\\t\\t\\t\\tmax = Math.max(max, score);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < mentors.length; i++)\\n\\t\\t\\t\\tif(!visited[i]){\\n\\t\\t\\t\\t\\tvisited[i] = true;\\n\\t\\t\\t\\t\\thelper(visited, students, mentors, pos + 1, score + score(students[pos], mentors[i]));\\n\\t\\t\\t\\t\\tvisited[i] = false;\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpublic int score(int[] a, int[] b){\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\tfor(int i = 0; i < b.length; i++)\\n\\t\\t\\t\\tif(a[i] == b[i]) count += 1;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\tint max;\\n\\t\\tpublic int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n\\t\\t\\tboolean[] visited = new boolean[students.length];\\n\\t\\t\\thelper(visited, students, mentors, 0, 0);\\n\\t\\t\\treturn max;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1360742,
                "title": "c-dp-bitmask-4ms",
                "content": "Time Complexity: `O((2^n)*n*m)`\\n\\n```\\n\\nint dp[300];      //dp-array\\nclass Solution {\\npublic:\\n    int solve(vector<int> &a, vector<int> &b, int i, int mask, int n, int m){\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[mask]!=-1){\\n            return dp[mask];\\n        }\\n        int ans=0;\\n        for(int k=0; k<n; k++){    //for each mentor\\n            if((mask&(1<<k))){                     //check if mentor has not chosen yet\\n                int new_mask=mask^(1<<k);\\n                \\n                int current_ans=0;\\n                for(int x=0; x<m; x++){\\n                    if((a[i]&(1<<x)) == (b[k]&(1<<x))){      //if xth bit of student and mentor is same, increase the answer\\n                        current_ans++;\\n                    }\\n                }\\n                ans=max(ans, current_ans + solve(a, b, i+1, new_mask, n, m) );\\n            }\\n        }\\n        return dp[mask]=ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& mr){\\n        int n = s.size();\\n        int m = s[0].size();\\n        vector<int> a, b;\\n        //convert to decimal e.g. [1,1,0] = 6\\n        for(auto v: s){                                //for students array\\n            int x=0;\\n            for(int i=0; i<m; i++){\\n                x+=(v[i]<<((m-i)-1));\\n            }\\n            a.push_back(x);\\n        }\\n        \\n        for(auto v: mr){                               //for mentor array\\n            int x=0;\\n            for(int i=0; i<m; i++){\\n                x+=(v[i]<<((m-i)-1));\\n            }\\n            b.push_back(x);\\n        }\\n        \\n        int mask = pow(2, n)-1;                          //all set bit   1 -> mentor not chosen, 0 -> mentor chosen\\n        //initialise dp array with -1\\n        for(int j=0; j<=mask; j++){\\n            dp[j]=-1;\\n        }\\n        \\n        return solve(a, b, 0, mask, n, m);\\n    }\\n};\\n\\n```\\n\\n*If you like the solution, please **Upvote** \\uD83D\\uDC4D!!*\\n\\n***Similar concept problem*** : [1879. Minimum XOR Sum of Two Arrays](https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/discuss/1238778/c-bitmaskdp)",
                "solutionTags": [],
                "code": "```\\n\\nint dp[300];      //dp-array\\nclass Solution {\\npublic:\\n    int solve(vector<int> &a, vector<int> &b, int i, int mask, int n, int m){\\n        if(i>=n){\\n            return 0;\\n        }\\n        if(dp[mask]!=-1){\\n            return dp[mask];\\n        }\\n        int ans=0;\\n        for(int k=0; k<n; k++){    //for each mentor\\n            if((mask&(1<<k))){                     //check if mentor has not chosen yet\\n                int new_mask=mask^(1<<k);\\n                \\n                int current_ans=0;\\n                for(int x=0; x<m; x++){\\n                    if((a[i]&(1<<x)) == (b[k]&(1<<x))){      //if xth bit of student and mentor is same, increase the answer\\n                        current_ans++;\\n                    }\\n                }\\n                ans=max(ans, current_ans + solve(a, b, i+1, new_mask, n, m) );\\n            }\\n        }\\n        return dp[mask]=ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& mr){\\n        int n = s.size();\\n        int m = s[0].size();\\n        vector<int> a, b;\\n        //convert to decimal e.g. [1,1,0] = 6\\n        for(auto v: s){                                //for students array\\n            int x=0;\\n            for(int i=0; i<m; i++){\\n                x+=(v[i]<<((m-i)-1));\\n            }\\n            a.push_back(x);\\n        }\\n        \\n        for(auto v: mr){                               //for mentor array\\n            int x=0;\\n            for(int i=0; i<m; i++){\\n                x+=(v[i]<<((m-i)-1));\\n            }\\n            b.push_back(x);\\n        }\\n        \\n        int mask = pow(2, n)-1;                          //all set bit   1 -> mentor not chosen, 0 -> mentor chosen\\n        //initialise dp array with -1\\n        for(int j=0; j<=mask; j++){\\n            dp[j]=-1;\\n        }\\n        \\n        return solve(a, b, 0, mask, n, m);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360748,
                "title": "c-brute-force-dfs",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Brute Force (DFS)\\n\\nThe brute force solution is generating all the permuntations of the mentors and calculate the score of this permutation and the students.\\n\\nThe permutation generation process with DFS takes `O(M! * M)` time and calculating the score takes `O(N)` time, so the overall time complexity is `O(M! * MN)`.\\n\\nSince `M` and `N` are at most `8` and `8! * 8^2 = 2,580,480 ~= 2.6e6`, such solution should be able to pass.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-251/problems/maximum-compatibility-score-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(M! * MN)\\n// Space: O(N)\\nclass Solution {\\n    int used[9] = {}, ans = 0, m, n;\\n    void dfs(vector<vector<int>>& S, vector<vector<int>>& M, int i, int score) {\\n        if (i == m) {\\n            ans = max(ans, score);\\n            return;\\n        }\\n        for (int j = 0; j < m; ++j) {\\n            if (used[j]) continue;\\n            used[j] = 1;\\n            int s = 0;\\n            for (int k = 0; k < n; ++k) s += S[i][k] == M[j][k]; // calculate the compatibility score of student `i` and mentor `j`.\\n            dfs(S, M, i + 1, score + s);\\n            used[j] = 0;\\n        }\\n    }\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& S, vector<vector<int>>& M) {\\n        m = S.size(), n = S[0].size();\\n        dfs(S, M, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-251/problems/maximum-compatibility-score-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(M! * MN)\\n// Space: O(N)\\nclass Solution {\\n    int used[9] = {}, ans = 0, m, n;\\n    void dfs(vector<vector<int>>& S, vector<vector<int>>& M, int i, int score) {\\n        if (i == m) {\\n            ans = max(ans, score);\\n            return;\\n        }\\n        for (int j = 0; j < m; ++j) {\\n            if (used[j]) continue;\\n            used[j] = 1;\\n            int s = 0;\\n            for (int k = 0; k < n; ++k) s += S[i][k] == M[j][k]; // calculate the compatibility score of student `i` and mentor `j`.\\n            dfs(S, M, i + 1, score + s);\\n            used[j] = 0;\\n        }\\n    }\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& S, vector<vector<int>>& M) {\\n        m = S.size(), n = S[0].size();\\n        dfs(S, M, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360769,
                "title": "c-backtracking-solution",
                "content": "```\\nclass Solution {\\n    // Calculating compatibility scores of ith student and jth mentor\\n    int cal(int i,int j,vector<vector<int>>& arr1,vector<vector<int>>& arr2){\\n        int cnt=0;\\n        for(int k=0;k<arr1[0].size();k++){\\n            if(arr1[i][k]==arr2[j][k]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int helper(int i,int m,vector<vector<int>>& arr1,vector<vector<int>>& arr2,vector<bool>& vis){\\n        if(i==m){\\n            return 0;\\n        }\\n        int ans = 0;\\n        for(int j=0;j<m;j++){\\n            if(!vis[j]){\\n                vis[j]=1;\\n                ans = max(ans,cal(i,j,arr1,arr2) + helper(i+1,m,arr1,arr2,vis));\\n                vis[j]=0; // Backtracking\\n            }\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        vector<bool> vis(m,0); // To keep track of which mentor is already paired up\\n        return helper(0,m,students,mentors,vis);\\n    }\\n};\\n```\\n**Hit upvote if you like :)**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    // Calculating compatibility scores of ith student and jth mentor\\n    int cal(int i,int j,vector<vector<int>>& arr1,vector<vector<int>>& arr2){\\n        int cnt=0;\\n        for(int k=0;k<arr1[0].size();k++){\\n            if(arr1[i][k]==arr2[j][k]){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int helper(int i,int m,vector<vector<int>>& arr1,vector<vector<int>>& arr2,vector<bool>& vis){\\n        if(i==m){\\n            return 0;\\n        }\\n        int ans = 0;\\n        for(int j=0;j<m;j++){\\n            if(!vis[j]){\\n                vis[j]=1;\\n                ans = max(ans,cal(i,j,arr1,arr2) + helper(i+1,m,arr1,arr2,vis));\\n                vis[j]=0; // Backtracking\\n            }\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        vector<bool> vis(m,0); // To keep track of which mentor is already paired up\\n        return helper(0,m,students,mentors,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360746,
                "title": "python3-permutations",
                "content": "**Approach 1 - brute force**\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        \\n        score = [[0]*m for _ in range(m)]\\n        for i in range(m): \\n            for j in range(m): \\n                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))\\n        \\n        ans = 0 \\n        for perm in permutations(range(m)): \\n            ans = max(ans, sum(score[i][j] for i, j in zip(perm, range(m))))\\n        return ans \\n```\\n\\nEdited on 7/26/2021\\n**Approach 2 - dp**\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        \\n        score = [[0]*m for _ in range(m)]\\n        for i in range(m): \\n            for j in range(m): \\n                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))\\n        \\n        @cache \\n        def fn(mask, j): \\n            \"\"\"Return max score of assigning students in mask to first j mentors.\"\"\"\\n            ans = 0 \\n            for i in range(m): \\n                if not mask & (1<<i): \\n                    ans = max(ans, fn(mask^(1<<i), j-1) + score[i][j])\\n            return ans \\n        \\n        return fn(1<<m, m-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        \\n        score = [[0]*m for _ in range(m)]\\n        for i in range(m): \\n            for j in range(m): \\n                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))\\n        \\n        ans = 0 \\n        for perm in permutations(range(m)): \\n            ans = max(ans, sum(score[i][j] for i, j in zip(perm, range(m))))\\n        return ans \\n```\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        \\n        score = [[0]*m for _ in range(m)]\\n        for i in range(m): \\n            for j in range(m): \\n                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))\\n        \\n        @cache \\n        def fn(mask, j): \\n            \"\"\"Return max score of assigning students in mask to first j mentors.\"\"\"\\n            ans = 0 \\n            for i in range(m): \\n                if not mask & (1<<i): \\n                    ans = max(ans, fn(mask^(1<<i), j-1) + score[i][j])\\n            return ans \\n        \\n        return fn(1<<m, m-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360737,
                "title": "mask-dp",
                "content": "With `m` and `n` constrained to `8`, it\\'s feasible to just check all permutations.\\n \\nWe just check all possible assignments for each student `i`, using `mask` to track mentors that have been assigned. We track and return the maximum score.\\n \\nTo speed things up, we can use memoisation, where we store interim results for each `i` and `mask`.\\n\\n**C++**\\n```cpp\\nint dp[256] = {[0 ... 255] = -1};\\nint maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& m, int i = 0, int mask = 0) {\\n    if (i == s.size())\\n        return 0;\\n    if (dp[mask] < 0)\\n        for (int j = 0; j < m.size(); ++j) {\\n            if ((mask & (1 << j)) == 0)\\n                dp[mask] = max(dp[mask], \\n                    inner_product(begin(s[i]), end(s[i]), begin(m[j]), 0, plus<int>(), equal_to<int>())\\n                    + maxCompatibilitySum(s, m, i + 1, mask + (1 << j)));\\n        }\\n    return dp[mask];\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[256] = {[0 ... 255] = -1};\\nint maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& m, int i = 0, int mask = 0) {\\n    if (i == s.size())\\n        return 0;\\n    if (dp[mask] < 0)\\n        for (int j = 0; j < m.size(); ++j) {\\n            if ((mask & (1 << j)) == 0)\\n                dp[mask] = max(dp[mask], \\n                    inner_product(begin(s[i]), end(s[i]), begin(m[j]), 0, plus<int>(), equal_to<int>())\\n                    + maxCompatibilitySum(s, m, i + 1, mask + (1 << j)));\\n        }\\n    return dp[mask];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361588,
                "title": "javascript-optimal-hungarian-algorithm-in-o-m-m-n",
                "content": "**Intuition**:\\n\\nThis may strike one as a bipartite graph problem, where the nodes of the left part are the students and the nodes of the right part are the mentors. Each node on the left is connected with every node on the right, with a cost equal to the count of the same answers for the student and each mentor respectively. Essentially we want to make an assignment such that the total cost is maximized. This is known as the assignment problem, and the fastest way of solving such a problem is the Kuhn Munkres algorithm, better known as the Hungarian algorithm. There are a ton of resources online for studying the Hungarian algorithm but I am not going to delve into its theory here, as it\\'s quite lengthy. \\n\\nIn any way, the assignment problem can be solved with easier ( yet less optimal complexity-wise) algorithms like Ford Fulkerson, and Hopcroft Karp.\\n\\n**Process**\\n\\nI first create an adjacency list between the students and the mentors, where A[i][j]= - (the count of the same answers of student i and mentor j).\\nThe assignment problem is used to minimize the total cost, so in order to maximize it I need the edges to be negative.\\nI then execute the Hungarian algorithm and return the negative result. \\n```\\nlet HunFast=(GRAPH)=>{\\n    let a=[...Array(GRAPH.length)].map((d,i)=>[...GRAPH[i]])\\n    let A=(len)=>[...Array(len)].map(d=>0)\\n    a.unshift(A(a[0].length))\\n    for(let i=0;i< a.length;i++)\\n        a[i].unshift(0)\\n    let n=a.length-1,m=a[0].length-1,u=A(n+1), v=A(m+1), p=A(m+1), way=A(m+1);\\n    for (let i=1; i<=n; i++) {\\n        p[0] = i;\\n        var j0 = 0,minv=A(m+1).map(d=>Infinity),used=A(m+1).map(d=>false)\\n        do {\\n            used[j0] = true;\\n            var i0 = p[j0] ,  delta = Infinity,  j1;\\n            for (let j=1; j<=m;j++)\\n                if (!used[j]) {\\n                    let cur = a[i0][j]-u[i0]-v[j];\\n                    if (cur < minv[j])\\n                        minv[j] = cur,  way[j] = j0;\\n                    if (minv[j] < delta)\\n                        delta = minv[j],  j1 = j;\\n                }\\n            for (let j=0; j<=m;j++)\\n                if (used[j])\\n                    u[p[j]] += delta,  v[j] -= delta;\\n                else\\n                    minv[j] -= delta;\\n            j0 = j1;\\n        } while (p[j0] != 0);\\n        do {\\n            let j1 = way[j0];\\n            p[j0] = p[j1],j0 = j1\\n        } while (j0);\\n    }\\n    return -v[0]\\n}\\nvar maxCompatibilitySum = function(S, M) {\\n    let m=S.length, A=[...Array(m)].map(d=>[...Array(m)])\\n    for(let i=0;i<m;i++ )\\n        for(let j=0;j<m;j++)\\n            A[i][j]=-S[i].reduce((a,c,k)=> a+ Number(c===M[j][k]),0)\\n    return -HunFast(A)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\nlet HunFast=(GRAPH)=>{\\n    let a=[...Array(GRAPH.length)].map((d,i)=>[...GRAPH[i]])\\n    let A=(len)=>[...Array(len)].map(d=>0)\\n    a.unshift(A(a[0].length))\\n    for(let i=0;i< a.length;i++)\\n        a[i].unshift(0)\\n    let n=a.length-1,m=a[0].length-1,u=A(n+1), v=A(m+1), p=A(m+1), way=A(m+1);\\n    for (let i=1; i<=n; i++) {\\n        p[0] = i;\\n        var j0 = 0,minv=A(m+1).map(d=>Infinity),used=A(m+1).map(d=>false)\\n        do {\\n            used[j0] = true;\\n            var i0 = p[j0] ,  delta = Infinity,  j1;\\n            for (let j=1; j<=m;j++)\\n                if (!used[j]) {\\n                    let cur = a[i0][j]-u[i0]-v[j];\\n                    if (cur < minv[j])\\n                        minv[j] = cur,  way[j] = j0;\\n                    if (minv[j] < delta)\\n                        delta = minv[j],  j1 = j;\\n                }\\n            for (let j=0; j<=m;j++)\\n                if (used[j])\\n                    u[p[j]] += delta,  v[j] -= delta;\\n                else\\n                    minv[j] -= delta;\\n            j0 = j1;\\n        } while (p[j0] != 0);\\n        do {\\n            let j1 = way[j0];\\n            p[j0] = p[j1],j0 = j1\\n        } while (j0);\\n    }\\n    return -v[0]\\n}\\nvar maxCompatibilitySum = function(S, M) {\\n    let m=S.length, A=[...Array(m)].map(d=>[...Array(m)])\\n    for(let i=0;i<m;i++ )\\n        for(let j=0;j<m;j++)\\n            A[i][j]=-S[i].reduce((a,c,k)=> a+ Number(c===M[j][k]),0)\\n    return -HunFast(A)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360825,
                "title": "classical-dijkstra-in-python-with-clear-explanation-similar-with-1066",
                "content": "This questions is similar to [1066. Campus Bike II](https://leetcode.com/problems/campus-bikes-ii/). Please also refer to my post: [Classical Dijkstra in Python with clear explanation](https://leetcode.com/problems/campus-bikes-ii/discuss/478958/classical-dijkstra-in-python-with-clear-explanation)\\n\\n`Workers` -> `Students`, `Bikes` -> `Mentors`, Manhattan distance -> Hamming distance   \\n\\nHere I reimplemented the same idea with a classical Dijkstra algorithm with explanations, for those who are interested in this classical algorithm. \\n\\nThe code basically performs a state-based search, with certain kinds of `state` space and `cost`, with an `initial state` and a `termination condition`: \\n\\n`state` : a scheme of mentor assignment for the first `i` students, which can be denoted as a tuple (number of assigned students, status of all mentors). The status of all students can be denoted in multiple ways, here we use a bit string. (e.g. total 4 mentors, the first taken while the rest 3 available, \\'1000\\')\\n\\n`cost` : total sum of Hanmming distances between the students and mentors assigned following a scheme.\\n\\n`initial state`:  no students assigned any mentor, all mentors are in available status. (e.g. (0, \\'0000\\'))\\n\\n`termination condition`: each student assigned a mentor. Since Dijkstra algorithm guarantees optimal cost when a node is closed, as well as BFS, so we can terminate the search when a scheme appears with last student assigned a mentor. \\n\\nThe final results is `m*n - total sum of Hamming distances`.\\n\\nHere is the code: \\n\\n```\\nimport heapq\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n        def hamming(student, mentor):\\n            return sum([int(student[i] != mentor[i]) for i in range(n)])\\n        \\n        pq = [(0, 0, \\'0\\'*m)] # state: (n-comp_score aka Hamming distance, number of assigned students, mentor status)\\n        optimal = defaultdict(lambda:float(\\'inf\\'))\\n        \\n        while pq: # O(V)\\n            cost, i, mentor_status = heapq.heappop(pq) # O(logV)\\n            \\n            # early stopping with termination condition \\n            if i == m:\\n                return m * n - cost\\n            \\n            # generate successors. The next student to be assigned is at index i\\n            for j, mentor in enumerate(mentors): # O(m)\\n                if mentor_status[j] != \\'1\\':\\n                    new_cost = cost + hamming(students[i], mentor)\\n                    new_mentor_status = mentor_status[:j] + \\'1\\' + mentor_status[j+1:]\\n                    \\n                    # update optimal cost if a new successor appears with lower cost to the same node\\n                    if new_cost < optimal[(i+1, new_mentor_status)]:\\n                        optimal[(i+1, new_mentor_status)] = new_cost\\n                        heapq.heappush(pq, (new_cost, i+1, new_mentor_status)) # O(logV)\\n                        \\n        return 0\\n```\\n\\n**Complexity**\\nGiven `V` is the number of vertices, `E` is the number of edges in the graph, the time complexity of Dijkstra with min Heap is `O(V*logV + V*E/V*logV) = O((V+E)logV)`. Here the `O(E/V)` denotes the average number of neighbors of a vertex, where the neighbors of each vertices is stored in an adjacency list. In this problem, the average number of neighbors of a vertex is bounded by `O(m)`, since at each step we are looking for a mentor for the next step. \\n\\nSo the time complexity becomes: `O(V*logV + V*m*logV) = O(V(m+1)logV) = O(mVlogV)`, where `V`, the number of vertices, is bounded by O(`m!`), the number of permutations of `m` students, becasue each vertex denotes one possible way to assign at most `m`students to at most `m` mentors. And further more, `O(m!) <= O(m^m)`, so the time complexity is bounded as `<= O(m^(m+2)*log(m))`.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n        def hamming(student, mentor):\\n            return sum([int(student[i] != mentor[i]) for i in range(n)])\\n        \\n        pq = [(0, 0, \\'0\\'*m)] # state: (n-comp_score aka Hamming distance, number of assigned students, mentor status)\\n        optimal = defaultdict(lambda:float(\\'inf\\'))\\n        \\n        while pq: # O(V)\\n            cost, i, mentor_status = heapq.heappop(pq) # O(logV)\\n            \\n            # early stopping with termination condition \\n            if i == m:\\n                return m * n - cost\\n            \\n            # generate successors. The next student to be assigned is at index i\\n            for j, mentor in enumerate(mentors): # O(m)\\n                if mentor_status[j] != \\'1\\':\\n                    new_cost = cost + hamming(students[i], mentor)\\n                    new_mentor_status = mentor_status[:j] + \\'1\\' + mentor_status[j+1:]\\n                    \\n                    # update optimal cost if a new successor appears with lower cost to the same node\\n                    if new_cost < optimal[(i+1, new_mentor_status)]:\\n                        optimal[(i+1, new_mentor_status)] = new_cost\\n                        heapq.heappush(pq, (new_cost, i+1, new_mentor_status)) # O(logV)\\n                        \\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360845,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        n = len(students)\\n        \\n        def dfs(i, used, score):\\n            if i == n: return score\\n            \\n            res = float(-inf)\\n            \\n            for j, mentor in enumerate(mentors):\\n                if j in used: continue\\n                    \\n                ss = sum(int(a == b) for a, b in zip(students[i], mentor))\\n                used.add(j)\\n                score += ss\\n                \\n                res = max(res, dfs(i + 1, used, score))\\n\\n                used.remove(j)\\n                score -= ss\\n            \\n            return res\\n        \\n        return dfs(0, set(), 0)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        n = len(students)\\n        \\n        def dfs(i, used, score):\\n            if i == n: return score\\n            \\n            res = float(-inf)\\n            \\n            for j, mentor in enumerate(mentors):\\n                if j in used: continue\\n                    \\n                ss = sum(int(a == b) for a, b in zip(students[i], mentor))\\n                used.add(j)\\n                score += ss\\n                \\n                res = max(res, dfs(i + 1, used, score))\\n\\n                used.remove(j)\\n                score -= ss\\n            \\n            return res\\n        \\n        return dfs(0, set(), 0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1360780,
                "title": "java-dp-bitmasking-2ms",
                "content": "\\nTimeComplexity : (m * 2 ^ m) * n\\nSpace Complexity: m * (2 ^ m)\\n\\n```\\nclass Solution {\\n\\n\\tstatic int dp[][] = null;\\n\\tstatic int all_visited = 0;\\n\\tint fun(int pos, int mask, int[][] students, int[][] mentors, int m, int n) {\\n\\n\\n\\t\\tif (mask == all_visited) {\\n\\t\\t\\tdp[pos][mask] = 0;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tif (dp[pos][mask] != -1)\\n\\t\\t\\treturn dp[pos][mask];\\n\\n\\n\\t\\tint max1 = 0;\\n\\t\\tfor (int i = 0; i < m; i++) {   // try to find best matching between student and mentor\\n\\n\\t\\t\\tif ((mask & (1 << i)) == 0) {\\n\\n\\t\\t\\t\\tint cal = 0;            // used for calculating how many answers matched in student and mentor\\n\\t\\t\\t\\tfor (int k = 0; k < n; k++) {\\n\\t\\t\\t\\t\\tif (students[pos][k] == mentors[i][k])\\n\\t\\t\\t\\t\\t\\tcal++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmax1 = Math.max(max1, cal + fun(pos + 1, (mask | (1 << i)), students, mentors, m, n));\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tdp[pos][mask] = max1;\\n\\t\\treturn max1;\\n\\t}\\n\\n\\n\\tpublic int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n\\n\\n\\t\\tint m = students.length;\\n\\t\\tint n = students[0].length;\\n\\t\\tall_visited = (1 << m) - 1;       // to mark that all students all matched with all mentors\\n\\t\\tdp  = new int[m + 1][1 << (m + 1)];\\n\\n\\t\\tfor (int i = 0; i < dp.length; i++) {\\n\\t\\t\\tfor (int j = 0; j < dp[0].length; j++)\\n\\t\\t\\t\\tdp[i][j] = -1;            // for marked all as unvisited/uncalculated\\n\\t\\t}\\n\\n\\t\\treturn fun(0, 0, students, mentors, m, n);\\n\\t}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tstatic int dp[][] = null;\\n\\tstatic int all_visited = 0;\\n\\tint fun(int pos, int mask, int[][] students, int[][] mentors, int m, int n) {\\n\\n\\n\\t\\tif (mask == all_visited) {\\n\\t\\t\\tdp[pos][mask] = 0;\\n\\t\\t\\treturn 0;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1360759,
                "title": "c-optimized-backtracking-solution-include-complexity-analysis-beats-100",
                "content": "```\\nint res;\\n\\nvoid backtracking(vector<vector<int>> &vec, int pos, vector<int> &visited, int count) {\\n\\tif (pos == vec.size()) {\\n\\t\\tres = max(res, count);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = 0; i < vec.size() ; i++) {\\n\\t\\tif (visited[i] == 1)\\n\\t\\t\\tcontinue;\\n\\t\\tvisited[i] = 1;\\n\\t\\tbacktracking(vec, pos + 1, visited, count + vec[pos][i]);\\n\\t\\tvisited[i] = 0;\\n\\t}\\n}\\n\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tres = 0;\\n\\tvector<vector<int>> sVec (students.size(), vector<int> (mentors.size(), 0));\\n\\tfor (int i = 0; i < students.size(); i++) {\\n\\t\\tfor (int j = 0; j < mentors.size(); j++) {\\n\\t\\t\\tint score(0);    \\n\\t\\t\\tfor (int n = 0; n < students[0].size(); n++) {\\n\\t\\t\\t\\tif (students[i][n] == mentors[j][n])\\n\\t\\t\\t\\t\\tscore++;\\n\\t\\t\\t}\\n\\t\\t\\tsVec[i][j] = score;\\n\\t\\t}\\n\\t}\\n\\tvector<int> visited (mentors.size(), 0);\\n\\tbacktracking(sVec, 0, visited, 0);\\n\\treturn res;\\n}\\n```\\n\\t\\nUsing backtracking to try out all the possibilities is intuitive. However, the total complexity and possibilities will be O(m! * n) \\n(Imagine there are 4 students, 4 mentors and 2 questions. Student[0] can try 4 mentors; student[1] can try 3 mentors\\u2026\\u2026 And each pair takes O(n) to get the sum of compatibility score.)\\n\\n\\n\\n\\nTherefore, we can generate a matrix of size m by m, called sVec.\\nsVec[i][j] represents compatibility score of student[i] and mentor[j]. Using such a 2D vector, we could cut the backtracking time complexity to O(m!), because we don\\u2019t have to iterate the n questions and calculate the score again. Calculate the matrix takes O(m*m*n); Backtracking takes O(m!). The final time complexity will be O(m*m*n + m!), which is equivalent to O(m!).\\n\\n",
                "solutionTags": [],
                "code": "```\\nint res;\\n\\nvoid backtracking(vector<vector<int>> &vec, int pos, vector<int> &visited, int count) {\\n\\tif (pos == vec.size()) {\\n\\t\\tres = max(res, count);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = 0; i < vec.size() ; i++) {\\n\\t\\tif (visited[i] == 1)\\n\\t\\t\\tcontinue;\\n\\t\\tvisited[i] = 1;\\n\\t\\tbacktracking(vec, pos + 1, visited, count + vec[pos][i]);\\n\\t\\tvisited[i] = 0;\\n\\t}\\n}\\n\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tres = 0;\\n\\tvector<vector<int>> sVec (students.size(), vector<int> (mentors.size(), 0));\\n\\tfor (int i = 0; i < students.size(); i++) {\\n\\t\\tfor (int j = 0; j < mentors.size(); j++) {\\n\\t\\t\\tint score(0);    \\n\\t\\t\\tfor (int n = 0; n < students[0].size(); n++) {\\n\\t\\t\\t\\tif (students[i][n] == mentors[j][n])\\n\\t\\t\\t\\t\\tscore++;\\n\\t\\t\\t}\\n\\t\\t\\tsVec[i][j] = score;\\n\\t\\t}\\n\\t}\\n\\tvector<int> visited (mentors.size(), 0);\\n\\tbacktracking(sVec, 0, visited, 0);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360771,
                "title": "python3-straightforward-top-down-dp",
                "content": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        pair_score = defaultdict(int)\\n        n = len(students)\\n\\n        # build compatibilty score for every possible student-mentor pair\\n        for i in range(n):\\n            for j in range(n):\\n                pair_score[i, j] = sum(s_ans == m_ans for s_ans, m_ans in zip(students[i], mentors[j]))\\n        \\n        # try to pair student[i] with every unused mentor\\n        # mentor[j] is unused if \\'j\\'th bit in mask is \\'1\\'\\n        @cache\\n        def dfs(i, mask):\\n            if i == len(students):\\n                return 0\\n            return max(dfs(i + 1, mask - (1 << j)) + pair_score[i, j] for j in range(n) if (1 << j) & mask)\\n                    \\n        return dfs(0, (1 << len(students)) - 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        pair_score = defaultdict(int)\\n        n = len(students)\\n\\n        # build compatibilty score for every possible student-mentor pair\\n        for i in range(n):\\n            for j in range(n):\\n                pair_score[i, j] = sum(s_ans == m_ans for s_ans, m_ans in zip(students[i], mentors[j]))\\n        \\n        # try to pair student[i] with every unused mentor\\n        # mentor[j] is unused if \\'j\\'th bit in mask is \\'1\\'\\n        @cache\\n        def dfs(i, mask):\\n            if i == len(students):\\n                return 0\\n            return max(dfs(i + 1, mask - (1 << j)) + pair_score[i, j] for j in range(n) if (1 << j) & mask)\\n                    \\n        return dfs(0, (1 << len(students)) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360916,
                "title": "dp-bitmask-100-fast-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[15][5000],m;\\n    \\n    int sol(vector<int>&stud,vector<int>&ment,int i,int mask){\\n        //cout<<\"here\\\\n\";\\n        if(i>=size(stud))\\n            return 0;\\n        \\n        if(dp[i][mask]!=-1)\\n            return dp[i][mask];\\n        \\n        int ans=0,score;\\n        for (int j=0;j<size(ment);++j) {\\n            if ((mask>>j)&1) \\n                continue;\\n            score = m-__builtin_popcount(stud[i]^ment[j]);\\n            //cout<<score<<\" \"<<m<<\\'\\\\n\\';\\n            ans=max(ans,score+sol(stud,ment,i+1,mask|(1<<j)));\\n        }\\n        return dp[i][mask]=ans;\\n    }\\n        \\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        m = size(students[0]);\\n        \\n        memset(dp,-1,sizeof dp);\\n        vector<int>stud,ment;\\n        int x;\\n    \\n        for (int i=0;i<size(students);++i){\\n            //cout<<\"here\\\\n\";\\n            x=0;\\n            for (int b:students[i]){\\n                x+=b;\\n                x<<=1;\\n            }\\n            x>>=1;\\n            stud.push_back(x);\\n            x=0;\\n            for (int b:mentors[i]){\\n                x+=b;\\n                x<<=1;\\n            }\\n            x>>=1;\\n            ment.push_back(x);\\n        }\\n        \\n        \\n        return sol(stud,ment,0,0);\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[15][5000],m;\\n    \\n    int sol(vector<int>&stud,vector<int>&ment,int i,int mask){\\n        //cout<<\"here\\\\n\";\\n        if(i>=size(stud))\\n            return 0;\\n        \\n        if(dp[i][mask]!=-1)\\n            return dp[i][mask];\\n        \\n        int ans=0,score;\\n        for (int j=0;j<size(ment);++j) {\\n            if ((mask>>j)&1) \\n                continue;\\n            score = m-__builtin_popcount(stud[i]^ment[j]);\\n            //cout<<score<<\" \"<<m<<\\'\\\\n\\';\\n            ans=max(ans,score+sol(stud,ment,i+1,mask|(1<<j)));\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1360899,
                "title": "python-simple-solution-using-itertools-permutations",
                "content": "Since this was originally a contest problem, we want to find a solution that\\'s simple to code.\\n\\nFirst thing to do is look at the constraints and when we do we notice that both m and n are at most 8. When the constraints are this small (less than 10/11) this means we can likely use a factorial time solution (or a polynomial solution with a high power.)\\n\\nAnd 8! is only 40k, so we can just try all pairings of mentor and student, since there are 8! of them.\\n\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        ans = 0\\n        for perm in itertools.permutations(range(len(students))):\\n            cur = 0\\n            for i in range(len(students)):\\n                for j in range(len(students[0])):\\n                    cur += 1 if students[i][j] == mentors[perm[i]][j] else 0\\n            ans = max(ans, cur)\\n        return ans\\n```\\n\\nThis uses `O(m! * n * m)` time and the extra memory use is `O(m)`.\\n\\n### Bonus One-Line version\\nGranted it\\'s split over multiple lines for readabilty.\\n\\nThe one trick I use is that `sum(array_of_bools)` returns the number of `True`s in the array.\\n\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        return max(\\n            sum(\\n                students[i][j] == mentors[perm[i]][j]\\n                for i in range(len(students)) \\n                for j in range(len(students[0]))\\n            ) \\n            for perm in itertools.permutations(range(len(students)))\\n        )\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        ans = 0\\n        for perm in itertools.permutations(range(len(students))):\\n            cur = 0\\n            for i in range(len(students)):\\n                for j in range(len(students[0])):\\n                    cur += 1 if students[i][j] == mentors[perm[i]][j] else 0\\n            ans = max(ans, cur)\\n        return ans\\n```\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        return max(\\n            sum(\\n                students[i][j] == mentors[perm[i]][j]\\n                for i in range(len(students)) \\n                for j in range(len(students[0]))\\n            ) \\n            for perm in itertools.permutations(range(len(students)))\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360733,
                "title": "c-simple-dp-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n   int dp[10];\\n    int comp(vector<vector<int>>& students, vector<vector<int>>& mentors,int i,int j){\\n        int k,l,count=0;\\n        for( k=0;k<students[i].size();k++){\\n            if(students[i][k]==mentors[j][k])\\n                count++;\\n        }\\n        return count;\\n    }\\n    int find(vector<vector<int>>& students, vector<vector<int>>& mentors,int ind){\\n        if(ind==students.size())\\n            return 0;\\n        int ans=-1;\\n       \\n         for(int j=0;j<students.size();j++){\\n         if(dp[j]==0){\\n             dp[j]=1;\\n            ans=max(comp(students,mentors,ind,j)+find(students,mentors,ind+1),ans);\\n             dp[j]=0;\\n             }\\n         }\\n         return ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n         return find(students,mentors,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   int dp[10];\\n    int comp(vector<vector<int>>& students, vector<vector<int>>& mentors,int i,int j){\\n        int k,l,count=0;\\n        for( k=0;k<students[i].size();k++){\\n            if(students[i][k]==mentors[j][k])\\n                count++;\\n        }\\n        return count;\\n    }\\n    int find(vector<vector<int>>& students, vector<vector<int>>& mentors,int ind){\\n        if(ind==students.size())\\n            return 0;\\n        int ans=-1;\\n       \\n         for(int j=0;j<students.size();j++){\\n         if(dp[j]==0){\\n             dp[j]=1;\\n            ans=max(comp(students,mentors,ind,j)+find(students,mentors,ind+1),ans);\\n             dp[j]=0;\\n             }\\n         }\\n         return ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n         return find(students,mentors,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2524379,
                "title": "go-solution-with-backtracking",
                "content": "```\\nfunc maxCompatibilitySum(students [][]int, mentors [][]int) int {\\n    result, m, mentorVisit := int(0), len(students), make([]bool, len(students))\\n    \\n    var backtrack func(int, int)\\n    backtrack = func(index int, currentCompatibility int) {\\n        if index == m {\\n            result = max(result, currentCompatibility)\\n            return\\n        }\\n        \\n        for i := 0; i < m; i++ {\\n            if mentorVisit[i] == false {\\n                mentorVisit[i] = true\\n                backtrack(index + 1, currentCompatibility + getCompatibility(students[index], mentors[i])) \\n                mentorVisit[i] = false\\n            }  \\n        }\\n    }\\n    \\n    backtrack(0, 0)\\n    \\n    return result\\n}\\n\\nfunc getCompatibility(sAnswers, mAnswers []int) int {\\n    sum := 0\\n    \\n    for i := 0; i < len(sAnswers); i++ {\\n        if sAnswers[i] == mAnswers[i] {\\n            sum++\\n        }\\n    }\\n    \\n    return sum\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nfunc maxCompatibilitySum(students [][]int, mentors [][]int) int {\\n    result, m, mentorVisit := int(0), len(students), make([]bool, len(students))\\n    \\n    var backtrack func(int, int)\\n    backtrack = func(index int, currentCompatibility int) {\\n        if index == m {\\n            result = max(result, currentCompatibility)\\n            return\\n        }\\n        \\n        for i := 0; i < m; i++ {\\n            if mentorVisit[i] == false {\\n                mentorVisit[i] = true\\n                backtrack(index + 1, currentCompatibility + getCompatibility(students[index], mentors[i])) \\n                mentorVisit[i] = false\\n            }  \\n        }\\n    }\\n    \\n    backtrack(0, 0)\\n    \\n    return result\\n}\\n\\nfunc getCompatibility(sAnswers, mAnswers []int) int {\\n    sum := 0\\n    \\n    for i := 0; i < len(sAnswers); i++ {\\n        if sAnswers[i] == mAnswers[i] {\\n            sum++\\n        }\\n    }\\n    \\n    return sum\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836564,
                "title": "c-dp-bitmasking-beats-95",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[8][1<<8];\\n    int ans = 0;\\n    int dfs(vector<vector<int>>& students, vector<vector<int>>&mentors, int idx, int mask){\\n        if(idx == students.size()) return 0;\\n        if(dp[idx][mask]!=-1)return dp[idx][mask]; \\n        int ans = 0;\\n        for(int i = 0; i < mentors.size(); i++){\\n            if(mask&(1<<i)) continue;\\n            int marks = 0;\\n            for(int j = 0; j < students[0].size(); j++){\\n                if(students[idx][j]==mentors[i][j])marks++;\\n            }\\n            ans=max(ans,marks + dfs(students, mentors, idx+1, mask|1<<i));\\n        }\\n        return dp[idx][mask]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(students, mentors, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[8][1<<8];\\n    int ans = 0;\\n    int dfs(vector<vector<int>>& students, vector<vector<int>>&mentors, int idx, int mask){\\n        if(idx == students.size()) return 0;\\n        if(dp[idx][mask]!=-1)return dp[idx][mask]; \\n        int ans = 0;\\n        for(int i = 0; i < mentors.size(); i++){\\n            if(mask&(1<<i)) continue;\\n            int marks = 0;\\n            for(int j = 0; j < students[0].size(); j++){\\n                if(students[idx][j]==mentors[i][j])marks++;\\n            }\\n            ans=max(ans,marks + dfs(students, mentors, idx+1, mask|1<<i));\\n        }\\n        return dp[idx][mask]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        memset(dp,-1,sizeof(dp));\\n        return dfs(students, mentors, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360966,
                "title": "very-simple-c-code-with-all-possible-combinations-simply-use-of-stl",
                "content": "```\\n// As m and n are too small so that we can check every possible combination.\\n// As it hard to shuffle complete so just use their indexes. And with stl function permutation\\n// check ans with next permutation. Continue till all permutation done.\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& stud, vector<vector<int>>& ment) {\\n        int r=stud.size(),c=stud[0].size(),ans=0,i=0;\\n        vector<int> idx;\\n        while(i<r)\\n        {\\n            idx.push_back(i);\\n            i++;\\n        }\\n        do\\n        {\\n            int curr=0;\\n            i=0;\\n            while(i<r)\\n            {\\n                int j=0;\\n                while(j<c)\\n                {\\n                    curr+=(stud[idx[i]][j]==ment[i][j]);\\n                    j++;\\n                }\\n                i++;\\n            }\\n            ans=max(ans,curr);\\n        }while(next_permutation(idx.begin(),idx.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// As m and n are too small so that we can check every possible combination.\\n// As it hard to shuffle complete so just use their indexes. And with stl function permutation\\n// check ans with next permutation. Continue till all permutation done.\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& stud, vector<vector<int>>& ment) {\\n        int r=stud.size(),c=stud[0].size(),ans=0,i=0;\\n        vector<int> idx;\\n        while(i<r)\\n        {\\n            idx.push_back(i);\\n            i++;\\n        }\\n        do\\n        {\\n            int curr=0;\\n            i=0;\\n            while(i<r)\\n            {\\n                int j=0;\\n                while(j<c)\\n                {\\n                    curr+=(stud[idx[i]][j]==ment[i][j]);\\n                    j++;\\n                }\\n                i++;\\n            }\\n            ans=max(ans,curr);\\n        }while(next_permutation(idx.begin(),idx.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631196,
                "title": "dp-with-bitmasking-easy-intuititive-c",
                "content": "**Explanation and intuition** :\\n* At first, the noticing fact are the problem contraints. Both m and n are less than or equals to 8.\\n* Also, we have to keep a track of the subset from the mentors array who have been already assigned to a particular student (can be done in the other way too).\\n* Thus, these facts enhance our idea that we can use DP with bitmasks. \\n* At first, make two vectors to store for each student and mentor their answer sum in decimal (as n<=8, the number will definitely fit in int).\\n* e.g., [1,0,1,0,0] for a student turns 16+4=20\\n* For a mentor with [1,0,0,0,1], the sum is 16+1=17\\n* Thus, doing ```__builtin_popcount``` of XOR of the two sums, we get number of different bits. So just subtract it from n to get the compatibility score !\\n\\n* Now, coming to DP, let we will be assigning each student a particular mentor one by one. \\n* Thus, f(index,mentors) -> max compatibility score for assigning students from index till end when the mentors present in \"mentors\" have already been assigned. \\n* Let, mentor 1,2,5 have been assigned among 5 mentors. We can keep track using mask 10011 having set bits indicating the already assigned mentors (starting from right, 0-based indexing)\\n* Thus, state change from index to index+1 happens ->\\n\\t\\tFrom 1 to m, when that bit of the mask is unset. We just set it, add the compatibility score and call for next index.\\n\\t\\tFinally, we take the max of all the sums !\\n\\t\\t\\n\\t**The code :**\\n\\t\\n\\t```class Solution {\\npublic:\\n    \\n    int dp[9][1<<8];\\n    \\n    int f(vector<int> &s_sum, vector<int> &t_sum, int index, int mask, int m, int n){\\n        // from this index with mask \\'mask\\', find the max result\\n        \\n        if (index==m){\\n            return 0;\\n        }\\n        \\n        if (dp[index][mask]!=-1) return dp[index][mask];\\n        \\n        int ans=0;\\n        \\n        for (int j=0;j<m;j++){\\n            // which teacher\\n            if (mask & (1<<j)) continue;\\n            // mask set\\n            \\n            int s_score=s_sum[index];\\n            int t_score=t_sum[j];\\n            int temp=s_score^t_score;\\n            int to_add=n-(__builtin_popcount(temp));\\n            // number of same bits\\n            \\n            ans=max(ans, to_add + f(s_sum, t_sum, index+1, mask|(1<<j), m, n));\\n        }\\n        \\n        return dp[index][mask]=ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m=students.size();\\n        int n=students[0].size();\\n        \\n        vector<int> s_sum(m,0);\\n        for (int i=0;i<m;i++){\\n            int sum=0;\\n            for (int j=0;j<n;j++){\\n                sum=sum*2;\\n                sum+=students[i][j];\\n            }\\n            s_sum[i]=sum;\\n        }\\n        // [6,5,1] for example 1\\n        \\n        vector<int> t_sum(m,0);\\n        for (int i=0;i<m;i++){\\n            int sum=0;\\n            for (int j=0;j<n;j++){\\n                sum*=2;\\n                sum+=mentors[i][j];\\n            }\\n            t_sum[i]=sum;\\n        }\\n        // [4,1,6] for example 1\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int res=f(s_sum,t_sum,0,0,m,n);\\n        \\n        return res;\\n    }\\n};```\\n\\n**Time complexity** :\\n\\nTime complexity in DP : No. of states * transition time between states \\n\\nHere, no. of states = No. of indices * Total possible mask size\\n\\t\\t\\t\\t\\t\\t\\t= m*(2^m)\\nTransition time is in order of O(m), basically work done in each state\\n\\nPrecomputation time of binary to decimal conversion : O(m*n)\\n\\nThus total complexity : O(m*n) + O((m^2) * (2^m)) = O(m^2 * 2^m)\\n\\n**Hope you like it !**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```__builtin_popcount```\n```class Solution {\\npublic:\\n    \\n    int dp[9][1<<8];\\n    \\n    int f(vector<int> &s_sum, vector<int> &t_sum, int index, int mask, int m, int n){\\n        // from this index with mask \\'mask\\', find the max result\\n        \\n        if (index==m){\\n            return 0;\\n        }\\n        \\n        if (dp[index][mask]!=-1) return dp[index][mask];\\n        \\n        int ans=0;\\n        \\n        for (int j=0;j<m;j++){\\n            // which teacher\\n            if (mask & (1<<j)) continue;\\n            // mask set\\n            \\n            int s_score=s_sum[index];\\n            int t_score=t_sum[j];\\n            int temp=s_score^t_score;\\n            int to_add=n-(__builtin_popcount(temp));\\n            // number of same bits\\n            \\n            ans=max(ans, to_add + f(s_sum, t_sum, index+1, mask|(1<<j), m, n));\\n        }\\n        \\n        return dp[index][mask]=ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m=students.size();\\n        int n=students[0].size();\\n        \\n        vector<int> s_sum(m,0);\\n        for (int i=0;i<m;i++){\\n            int sum=0;\\n            for (int j=0;j<n;j++){\\n                sum=sum*2;\\n                sum+=students[i][j];\\n            }\\n            s_sum[i]=sum;\\n        }\\n        // [6,5,1] for example 1\\n        \\n        vector<int> t_sum(m,0);\\n        for (int i=0;i<m;i++){\\n            int sum=0;\\n            for (int j=0;j<n;j++){\\n                sum*=2;\\n                sum+=mentors[i][j];\\n            }\\n            t_sum[i]=sum;\\n        }\\n        // [4,1,6] for example 1\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        int res=f(s_sum,t_sum,0,0,m,n);\\n        \\n        return res;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2288804,
                "title": "c-backtracking-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void backtrack(vector<vector<int>>& students, vector<vector<int>>& mentors,int idx,int curr_res,vector<int> &vis)\\n    {\\n        if(idx>=mentors.size())\\n        {\\n            ans=max(ans,curr_res);\\n                return ;\\n        }\\n        for(int i=0;i<students.size();i++)\\n        {\\n            if(vis[i]!=0)\\n                continue;\\n            int temp=0;\\n            vis[i]=1;\\n            for(int j=0;j<students[i].size();j++)\\n            {\\n                if(students[i][j]==mentors[idx][j])\\n                {\\n                    temp++;\\n                }\\n            }\\n            backtrack(students,mentors,idx+1,curr_res+temp,vis);\\n            vis[i]=0;\\n        }\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors)\\n    {\\n        vector<int> vis(students.size(),0);\\n        backtrack(students,mentors,0,0,vis);\\n        return ans;\\n        \\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    void backtrack(vector<vector<int>>& students, vector<vector<int>>& mentors,int idx,int curr_res,vector<int> &vis)\\n    {\\n        if(idx>=mentors.size())\\n        {\\n            ans=max(ans,curr_res);\\n                return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1361660,
                "title": "c-backtracking-solution-faster-than-100",
                "content": "The idea is simple :-\\n1) I made a 2D matrix of size M*M for every possible combination.\\n2) then find \"Maximum sum of a Matrix where each value is from a unique row and column\".\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> col;\\n    int mx = INT32_MIN;\\n    void maxSum(int n, vector<vector<int>> &matrix, int idx, int sum)\\n    {\\n        if (idx == n)\\n        {\\n            mx = max(mx, sum);\\n            return;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!col[i])\\n            {\\n                col[i] = true;\\n                maxSum(n, matrix, idx + 1, sum + matrix[idx][i]);\\n                col[i] = false;\\n            }\\n        }\\n    }\\n    void fillMatrix(vector<int>&s,vector<int>&m, int i, int j, vector<vector<int>>&matrix)\\n    {\\n        int x = 0;\\n        for(int k = 0; k<s.size(); k++)\\n        {\\n            if(s[k]==m[k])\\n                x++;\\n        }\\n        matrix[i][j] = x;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        vector<vector<int>>matrix(m,vector<int>(m,0));\\n        for(int i = 0; i<m; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                fillMatrix(students[i],mentors[j], i, j, matrix);\\n            }\\n        }\\n        col.assign(m, false);\\n        maxSum(m, matrix, 0, 0);\\n        return mx;\\n    }\\n};\\n```\\n\\n\\n**Upvote if you like!!!**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> col;\\n    int mx = INT32_MIN;\\n    void maxSum(int n, vector<vector<int>> &matrix, int idx, int sum)\\n    {\\n        if (idx == n)\\n        {\\n            mx = max(mx, sum);\\n            return;\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!col[i])\\n            {\\n                col[i] = true;\\n                maxSum(n, matrix, idx + 1, sum + matrix[idx][i]);\\n                col[i] = false;\\n            }\\n        }\\n    }\\n    void fillMatrix(vector<int>&s,vector<int>&m, int i, int j, vector<vector<int>>&matrix)\\n    {\\n        int x = 0;\\n        for(int k = 0; k<s.size(); k++)\\n        {\\n            if(s[k]==m[k])\\n                x++;\\n        }\\n        matrix[i][j] = x;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        vector<vector<int>>matrix(m,vector<int>(m,0));\\n        for(int i = 0; i<m; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                fillMatrix(students[i],mentors[j], i, j, matrix);\\n            }\\n        }\\n        col.assign(m, false);\\n        maxSum(m, matrix, 0, 0);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361130,
                "title": "c-backtracking-commented-faster-than-100",
                "content": "For every student try to pair it with every mentor, and for all these combinations, save the maximum resultant.\\n```\\nclass Solution {\\npublic:\\n    \\nvoid find(vector<vector<int> > &students,vector<vector<int >> &mentors,int st,int n,vector<int> &used,int &temp,int &ans)\\n{\\n    if(st == n)\\n    {\\n        ans = max(ans,temp);\\n        return;\\n    }\\n    \\n    for(int i = 0 ;i < n;i++)\\n    {\\n        if(used[i] == 0)//got a mentor thats still free, so pair it\\n        {\\n            used[i] = 1;\\n            int score = 0;\\n            for(int j = 0 ;j < students[st].size();j++)\\n            {\\n                if(students[st][j] == mentors[i][j])\\n                    score++;\\n            }\\n            temp += score;//add the score\\n            find(students,mentors,st+1,n,used,temp,ans);//recur for remaining students\\n            used[i] = 0;//backtrack\\n            temp -= score;\\n        }\\n    }\\n}\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n = students.size();\\n        vector<int> used(n,0);//to keep track of fee mentors\\n        int temp = 0;//temp ans for a specific combination\\n        int i = 0;//start with the first student\\n        int ans = 0;//final ans\\n        find(students,mentors,i,n,used,temp,ans);\\n        return ans;\\n        \\n    }\\n};\\n```\\nConsider Upvoting ..!!!!",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nvoid find(vector<vector<int> > &students,vector<vector<int >> &mentors,int st,int n,vector<int> &used,int &temp,int &ans)\\n{\\n    if(st == n)\\n    {\\n        ans = max(ans,temp);\\n        return;\\n    }\\n    \\n    for(int i = 0 ;i < n;i++)\\n    {\\n        if(used[i] == 0)//got a mentor thats still free, so pair it\\n        {\\n            used[i] = 1;\\n            int score = 0;\\n            for(int j = 0 ;j < students[st].size();j++)\\n            {\\n                if(students[st][j] == mentors[i][j])\\n                    score++;\\n            }\\n            temp += score;//add the score\\n            find(students,mentors,st+1,n,used,temp,ans);//recur for remaining students\\n            used[i] = 0;//backtrack\\n            temp -= score;\\n        }\\n    }\\n}\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n = students.size();\\n        vector<int> used(n,0);//to keep track of fee mentors\\n        int temp = 0;//temp ans for a specific combination\\n        int i = 0;//start with the first student\\n        int ans = 0;//final ans\\n        find(students,mentors,i,n,used,temp,ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360793,
                "title": "naive-brute-force-using-next-permutation-68ms",
                "content": "Here is a pretty naive implementation ,hope it helps\\n```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& student, vector<vector<int>>& mentors) {\\n        int m=student.size();\\n        int n=student[0].size();\\n        //This matrix com stores the compatibility score between i th student and jth mentor\\n        int com[m][m];\\n        memset(com,0,sizeof com);\\n        //We fill out every student-teacher compatibility scores\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                int   res=0;\\n                for(int k=0;k<n;k++)\\n                {\\n                    res+=(student[i][k]==mentors[j][k]);\\n                }\\n                com[i][j]=res;\\n            }\\n        //allot vector is used to assign students to mentors in such a way that every student is assigned to one teacher\\n        //We try out every such possibility using next_permutation\\n        //For example if we have 5 students initially the allot=[0,1,2,3,4]\\n        //which means ith student is assigned to allot[i] teacher \\n        \\n        vector<int> allot;\\n        for(int i=0;i<m;i++) allot.push_back(i);\\n        int ans=0;\\n        for(int i=0;i<m;i++) ans+=(com[i][allot[i]]);\\n        //Here we check every possible assignment of m students to m teachers\\n        do{  int temp=0;\\n            for(int i=0;i<m;i++) temp+=(com[i][allot[i]]);\\n           ans=max(ans,temp);\\n                \\n        }while(next_permutation(allot.begin(),allot.end()));\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& student, vector<vector<int>>& mentors) {\\n        int m=student.size();\\n        int n=student[0].size();\\n        //This matrix com stores the compatibility score between i th student and jth mentor\\n        int com[m][m];\\n        memset(com,0,sizeof com);\\n        //We fill out every student-teacher compatibility scores\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                int   res=0;\\n                for(int k=0;k<n;k++)\\n                {\\n                    res+=(student[i][k]==mentors[j][k]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1360732,
                "title": "bitmask-dp-java",
                "content": "```\\n\\nclass Solution {\\n    Integer[][]dp;\\n    int m, n;\\n    int[][] S;\\n    int[][] M;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        m = students.length;\\n        n = students[0].length;\\n        S = students;\\n        M = mentors;\\n        dp = new Integer[m][1 << 8];\\n        return dfs(0, 0);\\n    }\\n\\n    // m : no of students\\n    // n : no of Questions\\n    public int dfs(int i, int mask){\\n        if(i == m)\\n            return 0;\\n        \\n        if(dp[i][mask] != null) return dp[i][mask];\\n        \\n        int maxScore = 0;\\n        for (int j = 0; j < m; j++){\\n            if((mask & (1 << j)) == 0){\\n                int score = 0;\\n                for (int k = 0; k < n; k++){\\n                    score += S[i][k] == M[j][k] ? 1 : 0;\\n                }\\n                score += dfs(i + 1, mask | (1 << j));\\n                maxScore = Math.max(maxScore, score);\\n            }\\n        }\\n        dp[i][mask] = maxScore;\\n        return maxScore;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    Integer[][]dp;\\n    int m, n;\\n    int[][] S;\\n    int[][] M;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        m = students.length;\\n        n = students[0].length;\\n        S = students;\\n        M = mentors;\\n        dp = new Integer[m][1 << 8];\\n        return dfs(0, 0);\\n    }\\n\\n    // m : no of students\\n    // n : no of Questions\\n    public int dfs(int i, int mask){\\n        if(i == m)\\n            return 0;\\n        \\n        if(dp[i][mask] != null) return dp[i][mask];\\n        \\n        int maxScore = 0;\\n        for (int j = 0; j < m; j++){\\n            if((mask & (1 << j)) == 0){\\n                int score = 0;\\n                for (int k = 0; k < n; k++){\\n                    score += S[i][k] == M[j][k] ? 1 : 0;\\n                }\\n                score += dfs(i + 1, mask | (1 << j));\\n                maxScore = Math.max(maxScore, score);\\n            }\\n        }\\n        dp[i][mask] = maxScore;\\n        return maxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657168,
                "title": "easy-c-solution-bitmask-dp-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[8][256];\\n    int calcSum(vector<int> &v1,vector<int> &v2){\\n        int cnt=0;\\n        for(int i=0;i<v1.size();i++) cnt+=(v1[i]==v2[i]);\\n        return cnt;\\n    }\\n    int help(int idx,int mask, vector<vector<int>>& students, vector<vector<int>>& mentors,int m){\\n        if(idx==m) return 0;\\n        if(dp[idx][mask]!=-1) return dp[idx][mask];\\n        int sum=0;\\n        for(int  i=0;i<m;i++){\\n            if(mask&(1<<i)){\\n                sum=max(sum,calcSum(students[idx],mentors[i])+help(idx+1,mask^(1<<i),students,mentors,m));\\n            }\\n        }\\n        return dp[idx][mask]=sum;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m=students.size();\\n        memset(dp,-1,sizeof dp);\\n        return help(0,(1<<m)-1,students,mentors,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[8][256];\\n    int calcSum(vector<int> &v1,vector<int> &v2){\\n        int cnt=0;\\n        for(int i=0;i<v1.size();i++) cnt+=(v1[i]==v2[i]);\\n        return cnt;\\n    }\\n    int help(int idx,int mask, vector<vector<int>>& students, vector<vector<int>>& mentors,int m){\\n        if(idx==m) return 0;\\n        if(dp[idx][mask]!=-1) return dp[idx][mask];\\n        int sum=0;\\n        for(int  i=0;i<m;i++){\\n            if(mask&(1<<i)){\\n                sum=max(sum,calcSum(students[idx],mentors[i])+help(idx+1,mask^(1<<i),students,mentors,m));\\n            }\\n        }\\n        return dp[idx][mask]=sum;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m=students.size();\\n        memset(dp,-1,sizeof dp);\\n        return help(0,(1<<m)-1,students,mentors,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320470,
                "title": "permutations-backtracking-c",
                "content": "```\\nclass Solution {\\n    void dfs(int i, int n, int m, vector<vector<int>>& students, vector<vector<int>>& mentors, int &ans) {\\n        if(i == n) {\\n            int cnt = 0;\\n            for(int j=0; j<n; j++) {\\n                for(int k=0; k<m; k++) cnt += students[j][k] == mentors[j][k];\\n            }\\n            ans = max(ans, cnt);\\n            return;\\n        }\\n        for(int j=i; j<n; j++) {\\n            swap(students[i],students[j]);\\n            dfs(i + 1, n, m, students, mentors, ans);\\n            swap(students[i],students[j]);\\n        }\\n    }\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size(), m = students[0].size(), ans = 0;\\n        dfs(0, n, m, students, mentors, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int n, int m, vector<vector<int>>& students, vector<vector<int>>& mentors, int &ans) {\\n        if(i == n) {\\n            int cnt = 0;\\n            for(int j=0; j<n; j++) {\\n                for(int k=0; k<m; k++) cnt += students[j][k] == mentors[j][k];\\n            }\\n            ans = max(ans, cnt);\\n            return;\\n        }\\n        for(int j=i; j<n; j++) {\\n            swap(students[i],students[j]);\\n            dfs(i + 1, n, m, students, mentors, ans);\\n            swap(students[i],students[j]);\\n        }\\n    }\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size(), m = students[0].size(), ans = 0;\\n        dfs(0, n, m, students, mentors, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728542,
                "title": "c-easy-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) \\n    {\\n        int idx=0;\\n        int n=students.size();\\n        vector<bool>vis(n,false);\\n        int currscore=0;\\n        fun(idx,students,mentors,n,vis,currscore);\\n        return ans;\\n    }               //student        //mentor\\n    void fun(int idx,vector<vector<int>>&student,vector<vector<int>>&mentor,int &n,vector<bool>&vis,int currscore)\\n    {\\n        //base\\n        if(idx >= n)\\n        {\\n            if(currscore > ans)\\n            {\\n                ans=currscore;\\n            }\\n            return;\\n        }\\n        //for the curr ith studen we have the choise for all the mentors\\n        //we will try to match the curr student with every mentor individulally\\n        //so to avoid the clash in matching we will make that mentor visited after considerration and will run the loop from the starting\\n        //we have choise of m mentors\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==true)\\n            {\\n                continue;\\n            }\\n            else if(vis[i]==false)  //then only we can match the ith student with the curr mentor\\n            {\\n                vis[i]=true;   //making the curr mentor vis as it got matched now with curr ith student\\n                int temp = match(student[idx],mentor[i]);       \\t        \\t\\t\\n                fun(idx+1,student,mentor,n,vis,currscore+temp);\\n                vis[i]=false;  //backtracking\\n            }\\n        }\\n    }\\n    int match(vector<int>&student,vector<int>&mentor)\\n    {\\n        int n=student.size();\\n        int count=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(student[i]==mentor[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN;\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) \\n    {\\n        int idx=0;\\n        int n=students.size();\\n        vector<bool>vis(n,false);\\n        int currscore=0;\\n        fun(idx,students,mentors,n,vis,currscore);\\n        return ans;\\n    }               //student        //mentor\\n    void fun(int idx,vector<vector<int>>&student,vector<vector<int>>&mentor,int &n,vector<bool>&vis,int currscore)\\n    {\\n        //base\\n        if(idx >= n)\\n        {\\n            if(currscore > ans)\\n            {\\n                ans=currscore;\\n            }\\n            return;\\n        }\\n        //for the curr ith studen we have the choise for all the mentors\\n        //we will try to match the curr student with every mentor individulally\\n        //so to avoid the clash in matching we will make that mentor visited after considerration and will run the loop from the starting\\n        //we have choise of m mentors\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==true)\\n            {\\n                continue;\\n            }\\n            else if(vis[i]==false)  //then only we can match the ith student with the curr mentor\\n            {\\n                vis[i]=true;   //making the curr mentor vis as it got matched now with curr ith student\\n                int temp = match(student[idx],mentor[i]);       \\t        \\t\\t\\n                fun(idx+1,student,mentor,n,vis,currscore+temp);\\n                vis[i]=false;  //backtracking\\n            }\\n        }\\n    }\\n    int match(vector<int>&student,vector<int>&mentor)\\n    {\\n        int n=student.size();\\n        int count=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(student[i]==mentor[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452022,
                "title": "easy-brute-force-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    int count(int i,int j,vector<vector<int>>&s,vector<vector<int>>&m){\\n        int ct=0;\\n        for(int k=0;k<s[i].size();k++){\\n            if(s[i][k]==m[j][k])ct++;\\n        }\\n        \\n        return ct;\\n    }\\n    \\n    int func(int i,vector<int>&vis,vector<vector<int>>&st,vector<vector<int>>&men){\\n        if(i==st.size())return 0;\\n        \\n        int ans=0;\\n        for(int j=0;j<vis.size();j++){\\n            int comp=0;\\n            if(!vis[j]){\\n                vis[j]=1;\\n                comp=count(i,j,st,men)+func(i+1,vis,st,men);\\n                \\n                vis[j]=0;\\n            }\\n            ans=max(ans,comp);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n=students.size(),m=students[0].size();\\n        vector<int>vis(n);\\n        \\n        return func(0,vis,students,mentors);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int count(int i,int j,vector<vector<int>>&s,vector<vector<int>>&m){\\n        int ct=0;\\n        for(int k=0;k<s[i].size();k++){\\n            if(s[i][k]==m[j][k])ct++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2211024,
                "title": "c-recursive-dp-bitmasking-3ms-10-mb-beats-99-62",
                "content": "![image](https://assets.leetcode.com/users/images/96c61c85-7568-4b3c-88c1-3f25642df2b9_1656442425.8650923.png)\\n\\n```\\nint score[8][8];\\nint dp[8][1<<8];\\nint n;\\nint backtrack(int i, int mask){\\n\\tif(i==n) return 0;\\n\\tif(dp[i][mask]!=-1) return dp[i][mask];\\n\\tint ret=INT_MIN;\\n\\tfor(int j=0; j<n; j++)\\n\\t\\tif(mask&(1<<j))\\n\\t\\tret = max(ret, score[i][j] + backtrack(i+1, mask^(1<<j)));\\n\\treturn dp[i][mask] = ret;\\n}\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tmemset(dp, -1, sizeof dp);\\n\\tmemset(score, 0, sizeof score);\\n\\tn=students.size();\\n\\tfor(int i=0; i<n; i++)\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t\\tfor(int k=0; k<students[0].size(); k++)\\n\\t\\t\\t\\tscore[i][j] += students[i][k]==mentors[j][k];\\n\\treturn backtrack(0, (1<<n)-1); //start with 1st student; with all the mentors available to assign\\n//(1<<n-1 has all the n bits ON)\\n}\\n/*\\nHint:\\n\\tSimilar to job assignment problem.\\n*/\\n```\\n\\nThanks \\u270C",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nint score[8][8];\\nint dp[8][1<<8];\\nint n;\\nint backtrack(int i, int mask){\\n\\tif(i==n) return 0;\\n\\tif(dp[i][mask]!=-1) return dp[i][mask];\\n\\tint ret=INT_MIN;\\n\\tfor(int j=0; j<n; j++)\\n\\t\\tif(mask&(1<<j))\\n\\t\\tret = max(ret, score[i][j] + backtrack(i+1, mask^(1<<j)));\\n\\treturn dp[i][mask] = ret;\\n}\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tmemset(dp, -1, sizeof dp);\\n\\tmemset(score, 0, sizeof score);\\n\\tn=students.size();\\n\\tfor(int i=0; i<n; i++)\\n\\t\\tfor(int j=0; j<n; j++)\\n\\t\\t\\tfor(int k=0; k<students[0].size(); k++)\\n\\t\\t\\t\\tscore[i][j] += students[i][k]==mentors[j][k];\\n\\treturn backtrack(0, (1<<n)-1); //start with 1st student; with all the mentors available to assign\\n//(1<<n-1 has all the n bits ON)\\n}\\n/*\\nHint:\\n\\tSimilar to job assignment problem.\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1929791,
                "title": "c-from-backtracking-to-dp-bit-masking",
                "content": "Approch 1 : Using Backtracking\\n```\\nclass Solution {\\npublic:\\n    \\n    int calculate_score(vector<int> &a, vector<int> &b)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            ans += (a[i] == b[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    int mx_sum(int i, vector<bool> used, vector<vector<int>> &score, int n,int m)\\n    {\\n        if(i >= n) return 0;\\n        int ans = 0;\\n        for(int j = 0; j < m; j++)\\n        {\\n            if(used[j]) continue;\\n            used[j] = 1;\\n            ans = max(ans, score[i][j] + mx_sum(i + 1, used, score, n, m));\\n            used[j] = 0;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) \\n    {\\n        int n = students.size();\\n        int m = mentors.size();\\n        \\n        vector<vector<int>> score(n, vector<int> (m, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                score[i][j] = calculate_score(students[i], mentors[j]);\\n        \\n        vector<bool> used(m, 0);\\n        return mx_sum(0, used, score, n, m);\\n    }\\n    \\n};\\n```\\n\\nApproach 2 : Using DP + mask (using mask to replace used  and to memoize results)\\n```\\nconst int N = 9;\\nint dp[N][1 << 8];\\nclass Solution {\\npublic:\\n    \\n    int calculate_score(vector<int> &a, vector<int> &b)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            ans += (a[i] == b[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    int mx_sum(int i, int mask, vector<vector<int>> &score, int n,int m)\\n    {\\n        if(i >= n) return 0;\\n        \\n        if(dp[i][mask] != -1) return dp[i][mask];\\n        \\n        int ans = 0;\\n        for(int j = 0; j < m; j++)\\n        {\\n            if(mask & (1 << j)) continue;\\n            ans = max(ans, score[i][j] + mx_sum(i + 1, mask + (1 << j), score, n, m));\\n        }\\n        return dp[i][mask] = ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) \\n    {\\n        int n = students.size();\\n        int m = mentors.size();\\n        \\n        vector<vector<int>> score(n, vector<int> (m, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                score[i][j] = calculate_score(students[i], mentors[j]);\\n        \\n        //global\\n        for(int i = 0; i < N; i++)\\n            for(int j = 0; j < (1 << 8); j++)\\n                dp[i][j] = -1;\\n        \\n        int mask = 0;\\n        return mx_sum(0, mask, score, n, m);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate_score(vector<int> &a, vector<int> &b)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            ans += (a[i] == b[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    int mx_sum(int i, vector<bool> used, vector<vector<int>> &score, int n,int m)\\n    {\\n        if(i >= n) return 0;\\n        int ans = 0;\\n        for(int j = 0; j < m; j++)\\n        {\\n            if(used[j]) continue;\\n            used[j] = 1;\\n            ans = max(ans, score[i][j] + mx_sum(i + 1, used, score, n, m));\\n            used[j] = 0;\\n        }\\n        return ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) \\n    {\\n        int n = students.size();\\n        int m = mentors.size();\\n        \\n        vector<vector<int>> score(n, vector<int> (m, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                score[i][j] = calculate_score(students[i], mentors[j]);\\n        \\n        vector<bool> used(m, 0);\\n        return mx_sum(0, used, score, n, m);\\n    }\\n    \\n};\\n```\n```\\nconst int N = 9;\\nint dp[N][1 << 8];\\nclass Solution {\\npublic:\\n    \\n    int calculate_score(vector<int> &a, vector<int> &b)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            ans += (a[i] == b[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    int mx_sum(int i, int mask, vector<vector<int>> &score, int n,int m)\\n    {\\n        if(i >= n) return 0;\\n        \\n        if(dp[i][mask] != -1) return dp[i][mask];\\n        \\n        int ans = 0;\\n        for(int j = 0; j < m; j++)\\n        {\\n            if(mask & (1 << j)) continue;\\n            ans = max(ans, score[i][j] + mx_sum(i + 1, mask + (1 << j), score, n, m));\\n        }\\n        return dp[i][mask] = ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) \\n    {\\n        int n = students.size();\\n        int m = mentors.size();\\n        \\n        vector<vector<int>> score(n, vector<int> (m, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                score[i][j] = calculate_score(students[i], mentors[j]);\\n        \\n        //global\\n        for(int i = 0; i < N; i++)\\n            for(int j = 0; j < (1 << 8); j++)\\n                dp[i][j] = -1;\\n        \\n        int mask = 0;\\n        return mx_sum(0, mask, score, n, m);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441792,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        res = [-1]\\n        visited = [False]*len(students)\\n        #ssf ===> score so far\\n        #res ==> final result. It is a list as it acts as a global variable\\n        #idx ====> index over students array.\\n        self.maxCompatibilityUtil(students,mentors,0,visited,res,0)\\n        return res[0]\\n    \\n    \\n    def maxCompatibilityUtil(self,students,mentors,ssf,visited,res,idx):\\n        if idx==len(students):\\n            res[0] = max(res[0],ssf)\\n            return \\n        \\n        for i in range(len(mentors)):\\n            if visited[i]==False:\\n                visited[i]=True\\n                temp = 0\\n                for j in range(len(mentors[i])):\\n                    if mentors[i][j]==students[idx][j]:\\n                        temp = temp+1\\n                self.maxCompatibilityUtil(students,mentors,ssf+temp,visited,res,idx+1)\\n                visited[i]=False\\n\\t\\t\\t\\t\\n\\t```\\n\\t\\nWe have to check for every student-mentor pair. \\nCan someone please tell me how to post any image? Or maybe some tool that can help me draw and post on leetcode. With Euler tree, this can be understood pretty easily.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        res = [-1]\\n        visited = [False]*len(students)\\n        #ssf ===> score so far\\n        #res ==> final result. It is a list as it acts as a global variable\\n        #idx ====> index over students array.\\n        self.maxCompatibilityUtil(students,mentors,0,visited,res,0)\\n        return res[0]\\n    \\n    \\n    def maxCompatibilityUtil(self,students,mentors,ssf,visited,res,idx):\\n        if idx==len(students):\\n            res[0] = max(res[0],ssf)\\n            return \\n        \\n        for i in range(len(mentors)):\\n            if visited[i]==False:\\n                visited[i]=True\\n                temp = 0\\n                for j in range(len(mentors[i])):\\n                    if mentors[i][j]==students[idx][j]:\\n                        temp = temp+1\\n                self.maxCompatibilityUtil(students,mentors,ssf+temp,visited,res,idx+1)\\n                visited[i]=False\\n\\t\\t\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1404210,
                "title": "python-3-one-line",
                "content": "There\\'s only a max of 8 students and mentors, so we can just try every permutation. Easy peasy.\\n\\n```python\\nclass Solution:\\n  def maxCompatibilitySum(self, S, M):\\n    return max(sum(sum(map(eq, *z)) for z in zip(S, P)) for P in permutations(M))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def maxCompatibilitySum(self, S, M):\\n    return max(sum(sum(map(eq, *z)) for z in zip(S, P)) for P in permutations(M))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402242,
                "title": "python-bitmask-memoization-solution",
                "content": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        n = len(students)\\n        m = len(students[0])\\n        full = 1<<n\\n        dp = [[-1 for i in range(full)] for j in range(n)]\\n        def rec(mentorMask, studentIndex):\\n            if mentorMask==full-1 or studentIndex==n:\\n                return 0\\n            if dp[studentIndex][mentorMask]!=-1:\\n                return dp[studentIndex][mentorMask]\\n            ans = 0\\n            for j in range(n):\\n                if mentorMask&(1<<j)==0:\\n                    score = 0\\n                    for i in range(m):\\n                        if students[studentIndex][i]==mentors[j][i]:\\n                            score+=1                   \\n                    ans = max(ans, score + rec(mentorMask^(1<<j), studentIndex+1))\\n            dp[studentIndex][mentorMask] = ans\\n            return ans\\n        return rec(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        n = len(students)\\n        m = len(students[0])\\n        full = 1<<n\\n        dp = [[-1 for i in range(full)] for j in range(n)]\\n        def rec(mentorMask, studentIndex):\\n            if mentorMask==full-1 or studentIndex==n:\\n                return 0\\n            if dp[studentIndex][mentorMask]!=-1:\\n                return dp[studentIndex][mentorMask]\\n            ans = 0\\n            for j in range(n):\\n                if mentorMask&(1<<j)==0:\\n                    score = 0\\n                    for i in range(m):\\n                        if students[studentIndex][i]==mentors[j][i]:\\n                            score+=1                   \\n                    ans = max(ans, score + rec(mentorMask^(1<<j), studentIndex+1))\\n            dp[studentIndex][mentorMask] = ans\\n            return ans\\n        return rec(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388417,
                "title": "c-stl-next-permutation",
                "content": "The brute force solution is generating all the permuntations of the students and calculates the score of this permutation and the students.\\nTime Complexity : ``` O(n! * nm) ``` **n!** for permutations and **nm** for calculating score.\\nSince , ``` n, m <= 8 ```  and  ``` 8! * 8 * 8 == 2,580,480 ```  which should pass.\\n\\n```\\nclass Solution {\\npublic:\\n    int factorial(int n){\\n        vector<int> arr(n + 1);\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        for (int i = 2; i <= n; i++){\\n            arr[i] = arr[i - 1] * i;\\n        }\\n        return arr[n];\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int max_ = 0, curr_max = 0;\\n        int row = students.size(), col = students[0].size();\\n        int total_permutations = factorial(row);\\n        for (int k = 0; k < total_permutations; k++){\\n            \\n            next_permutation(students.begin(), students.end());\\n            curr_max = 0;\\n            \\n            for (int i = 0; i < row; i++){\\n                for (int j = 0; j < col; j++){\\n                    if (mentors[i][j] == students[i][j]) curr_max++;\\n                }\\n            }\\n            \\n            max_ = max(max_ , curr_max);\\n        }\\n        return max_;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` O(n! * nm) ```\n``` n, m <= 8 ```\n``` 8! * 8 * 8 == 2,580,480 ```\n```\\nclass Solution {\\npublic:\\n    int factorial(int n){\\n        vector<int> arr(n + 1);\\n        arr[0] = 1;\\n        arr[1] = 1;\\n        for (int i = 2; i <= n; i++){\\n            arr[i] = arr[i - 1] * i;\\n        }\\n        return arr[n];\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int max_ = 0, curr_max = 0;\\n        int row = students.size(), col = students[0].size();\\n        int total_permutations = factorial(row);\\n        for (int k = 0; k < total_permutations; k++){\\n            \\n            next_permutation(students.begin(), students.end());\\n            curr_max = 0;\\n            \\n            for (int i = 0; i < row; i++){\\n                for (int j = 0; j < col; j++){\\n                    if (mentors[i][j] == students[i][j]) curr_max++;\\n                }\\n            }\\n            \\n            max_ = max(max_ , curr_max);\\n        }\\n        return max_;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379915,
                "title": "python-simple-dfs-solution",
                "content": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        \\n        n, m = len(students), len(students[0])\\n        out = []\\n\\t\\t\\n        def dfs(i, used, score):\\n            \\n            if i == n:\\n                out.append(score)\\n                return\\n            \\n            for mentor in range(n):\\n                if str(mentor) not in used:\\n                    curr = sum(a==b for a, b in zip(students[i], mentors[mentor]))\\n                    dfs(i+1, used+str(mentor), score+curr)\\n            \\n        dfs(0, \\'\\', 0)\\n        return max(out)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        \\n        n, m = len(students), len(students[0])\\n        out = []\\n\\t\\t\\n        def dfs(i, used, score):\\n            \\n            if i == n:\\n                out.append(score)\\n                return\\n            \\n            for mentor in range(n):\\n                if str(mentor) not in used:\\n                    curr = sum(a==b for a, b in zip(students[i], mentors[mentor]))\\n                    dfs(i+1, used+str(mentor), score+curr)\\n            \\n        dfs(0, \\'\\', 0)\\n        return max(out)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368398,
                "title": "c-with-comments-bitmask-dp-easy",
                "content": "```\\n    int dp[9][265];\\n\\t// function to calculate value for some matrix a of students and other matrix b of mentors  --- \\n\\t\\t\\t\\t\\t// a == students[i]   && b ==  mentors[j] \\n    int ch(vector<int> a, vector<int> b){\\n        int n=a.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==b[i])\\n                ans++;\\n        }\\n        return ans;\\n    }\\n    int fun(vector<vector<int>>& students, vector<vector<int>>& mentors,int j,int mask){\\n        int n=mentors.size();\\n        if(j<0)\\n            return 0;\\n\\t\\t\\t// normal dp condition \\n        if(dp[j][mask]!=-1)\\n            return dp[j][mask];\\n\\t\\t\\t// we will traverse for element and check the score for each students[i] and mentors[j] \\n\\t\\t\\t// and choose if and only if i is not taken already which is represented by the mask\\n        for(int i=0;i<n;i++){\\n\\t\\t// this is checking condition to check if i was already taken or not.   \\n\\t\\t// eg. is mask was 6 then its binary representation is 110 and we want to check if i==2 is present or not \\n\\t\\t// i.e is there 1 at the 2nd index from right. hence we take & of 110 and 100(1<< i )\\n            if(mask&(1<<i)){\\n                dp[j][mask]=max(dp[j][mask],ch(students[i],mentors[j])+fun(students,mentors,j-1,mask^(1<<i)));\\n\\t\\t\\t\\t//  because we are now using the i th array of students we have to mark its index in the mask as 0 --- \\n\\t\\t\\t\\t// mask^(1<<i) converts the index at i position to 0 \\n            }\\n        }\\n        return dp[j][mask];\\n    }\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=mentors.size();\\n        memset(dp,-1,sizeof dp);\\n\\t\\t// initially all the indices (i.e n indices) of mask should be set to 1 hence the -1\\n        int mask=pow(2,n)-1;\\n        return fun(students,mentors,n-1,mask);\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n    int dp[9][265];\\n\\t// function to calculate value for some matrix a of students and other matrix b of mentors  --- \\n\\t\\t\\t\\t\\t// a == students[i]   && b ==  mentors[j] \\n    int ch(vector<int> a, vector<int> b){\\n        int n=a.size(),ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==b[i])\\n                ans++;\\n        }\\n        return ans;\\n    }\\n    int fun(vector<vector<int>>& students, vector<vector<int>>& mentors,int j,int mask){\\n        int n=mentors.size();\\n        if(j<0)\\n            return 0;\\n\\t\\t\\t// normal dp condition \\n        if(dp[j][mask]!=-1)\\n            return dp[j][mask];\\n\\t\\t\\t// we will traverse for element and check the score for each students[i] and mentors[j] \\n\\t\\t\\t// and choose if and only if i is not taken already which is represented by the mask\\n        for(int i=0;i<n;i++){\\n\\t\\t// this is checking condition to check if i was already taken or not.   \\n\\t\\t// eg. is mask was 6 then its binary representation is 110 and we want to check if i==2 is present or not \\n\\t\\t// i.e is there 1 at the 2nd index from right. hence we take & of 110 and 100(1<< i )\\n            if(mask&(1<<i)){\\n                dp[j][mask]=max(dp[j][mask],ch(students[i],mentors[j])+fun(students,mentors,j-1,mask^(1<<i)));\\n\\t\\t\\t\\t//  because we are now using the i th array of students we have to mark its index in the mask as 0 --- \\n\\t\\t\\t\\t// mask^(1<<i) converts the index at i position to 0 \\n            }\\n        }\\n        return dp[j][mask];\\n    }\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=mentors.size();\\n        memset(dp,-1,sizeof dp);\\n\\t\\t// initially all the indices (i.e n indices) of mask should be set to 1 hence the -1\\n        int mask=pow(2,n)-1;\\n        return fun(students,mentors,n-1,mask);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367287,
                "title": "1ms-100-java-backtracking-bitmask-solution",
                "content": "```\\n        public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n            int n = students.length;\\n            return helper(0, 0, students, mentors, new Integer[n][1 << n]);\\n        }\\n\\n\\n        private int helper(int pos, int mask, int[][] students, int[][] mentors, Integer[][] memo) {\\n            int n = students.length;\\n            if (mask == (1 << n) - 1)\\n                return 0;\\n            if (memo[pos][mask] != null)\\n                return memo[pos][mask];\\n\\n            int maxScore = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((mask & (1 << i)) == 0) {\\n                    int score = getScore(students[pos], mentors[i]);\\n                    maxScore = Math.max(maxScore, score + helper(pos + 1, (mask | (1 << i)), students, mentors, memo));\\n                }\\n            }\\n\\n            return memo[pos][mask] = maxScore;\\n        }\\n\\n        private int getScore(int[] a, int[] b) {\\n            int count = 0;\\n            for (int i = 0; i < b.length; i++)\\n                if (a[i] == b[i]) count++;\\n            return count;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n            int n = students.length;\\n            return helper(0, 0, students, mentors, new Integer[n][1 << n]);\\n        }\\n\\n\\n        private int helper(int pos, int mask, int[][] students, int[][] mentors, Integer[][] memo) {\\n            int n = students.length;\\n            if (mask == (1 << n) - 1)\\n                return 0;\\n            if (memo[pos][mask] != null)\\n                return memo[pos][mask];\\n\\n            int maxScore = 0;\\n            for (int i = 0; i < n; i++) {\\n                if ((mask & (1 << i)) == 0) {\\n                    int score = getScore(students[pos], mentors[i]);\\n                    maxScore = Math.max(maxScore, score + helper(pos + 1, (mask | (1 << i)), students, mentors, memo));\\n                }\\n            }\\n\\n            return memo[pos][mask] = maxScore;\\n        }\\n\\n        private int getScore(int[] a, int[] b) {\\n            int count = 0;\\n            for (int i = 0; i < b.length; i++)\\n                if (a[i] == b[i]) count++;\\n            return count;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365921,
                "title": "c-solution-using-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int cal(vector<vector<int>> &mentors, vector<vector<int>> &students)\\n    {\\n      int n=students.size(),m=students[0].size(),sum=0;\\n        \\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              sum+=(students[i][j]==mentors[i][j])?1:0;\\n          }\\n      }\\n        \\n      return sum;\\n    }\\n    \\n    int permutation(vector<vector<int>>&mentors, vector<vector<int>>&students, int index, int maxSum)\\n    {\\n        if(index==mentors.size())\\n        {\\n            maxSum=max(maxSum,cal(mentors,students));\\n            return maxSum;\\n        }\\n        \\n        for(int i=index;i<mentors.size();i++)\\n        {\\n            swap(mentors[i],mentors[index]);\\n            \\n            maxSum=max(maxSum,permutation(mentors,students,index+1,maxSum));\\n            \\n            swap(mentors[i],mentors[index]);\\n        }\\n        \\n        return maxSum;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=students.size(),maxSum=INT_MIN;\\n        \\n        maxSum=permutation(mentors,students,0,maxSum);\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(vector<vector<int>> &mentors, vector<vector<int>> &students)\\n    {\\n      int n=students.size(),m=students[0].size(),sum=0;\\n        \\n      for(int i=0;i<n;i++)\\n      {\\n          for(int j=0;j<m;j++)\\n          {\\n              sum+=(students[i][j]==mentors[i][j])?1:0;\\n          }\\n      }\\n        \\n      return sum;\\n    }\\n    \\n    int permutation(vector<vector<int>>&mentors, vector<vector<int>>&students, int index, int maxSum)\\n    {\\n        if(index==mentors.size())\\n        {\\n            maxSum=max(maxSum,cal(mentors,students));\\n            return maxSum;\\n        }\\n        \\n        for(int i=index;i<mentors.size();i++)\\n        {\\n            swap(mentors[i],mentors[index]);\\n            \\n            maxSum=max(maxSum,permutation(mentors,students,index+1,maxSum));\\n            \\n            swap(mentors[i],mentors[index]);\\n        }\\n        \\n        return maxSum;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=students.size(),maxSum=INT_MIN;\\n        \\n        maxSum=permutation(mentors,students,0,maxSum);\\n        \\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365654,
                "title": "c-backtracking-beginner-friendly",
                "content": "Since constraints were very small\\n```\\nm == students.length == mentors.length\\nn == students[i].length == mentors[j].length\\n1 <= m, n <= 8\\nstudents[i][k] is either 0 or 1.\\nmentors[j][k] is either 0 or 1.\\n```\\n\\nthat\\'s why I decided to go with the backtracking approach.\\n\\n```\\nclass Solution {\\npublic:\\n\\t// to calculate score of the student-mentor pair\\n    int score(vector<int>&s, vector<int>&m){\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==m[i]) cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int solve(vector<vector<int>>& s, vector<vector<int>>& m, int student, int sz, vector<bool>&vis){\\n \\xA0 \\xA0 \\xA0 \\xA0if(student==sz) return 0; // if all pairs are done\\n        int ans=0;\\n        for(int i=0;i<sz;i++){\\n            if(!vis[i]){\\n                vis[i]=1;\\n                ans=max(ans,score(s[student],m[i])+solve(s,m,student+1,sz,vis)); // pass next student(student+1)\\n                vis[i]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& m) {\\n        int ans=0;\\n        vector<bool>vis(m.size(),0); // to keep track of already selected mentors\\n        for(int i=0;i<m.size();i++){\\n            vis[i]=1; // select ith mentor\\n            ans=max(ans,score(s[0],m[i])+solve(s,m,1,s.size(),vis)); // calculate score of student and selected mentor and then solve for other pairs\\n            vis[i]=0; // deselect(backtrack)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nm == students.length == mentors.length\\nn == students[i].length == mentors[j].length\\n1 <= m, n <= 8\\nstudents[i][k] is either 0 or 1.\\nmentors[j][k] is either 0 or 1.\\n```\n```\\nclass Solution {\\npublic:\\n\\t// to calculate score of the student-mentor pair\\n    int score(vector<int>&s, vector<int>&m){\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==m[i]) cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    int solve(vector<vector<int>>& s, vector<vector<int>>& m, int student, int sz, vector<bool>&vis){\\n \\xA0 \\xA0 \\xA0 \\xA0if(student==sz) return 0; // if all pairs are done\\n        int ans=0;\\n        for(int i=0;i<sz;i++){\\n            if(!vis[i]){\\n                vis[i]=1;\\n                ans=max(ans,score(s[student],m[i])+solve(s,m,student+1,sz,vis)); // pass next student(student+1)\\n                vis[i]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& m) {\\n        int ans=0;\\n        vector<bool>vis(m.size(),0); // to keep track of already selected mentors\\n        for(int i=0;i<m.size();i++){\\n            vis[i]=1; // select ith mentor\\n            ans=max(ans,score(s[0],m[i])+solve(s,m,1,s.size(),vis)); // calculate score of student and selected mentor and then solve for other pairs\\n            vis[i]=0; // deselect(backtrack)\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362462,
                "title": "c-faster-than-100-backtracking-and-bit-mask-comments-added",
                "content": "We calculate compatibility between every student and mentor. Since the number of mentors and students are capped at 8, we can check every possible combination of mentor and student. To keep a track of mentor assigned to student, we use bit masking.\\n\\nRefer to the code below for the above approach - \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> v;\\n    int n;\\n    int res=0;\\n    \\n\\t// function to calucate compatibility between two vectors.\\n    int compat(vector<int> a, vector<int> b) {\\n        int ans = 0;\\n        for(int i=0 ; i<a.size() ; i++) {\\n            if(a[i]==b[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    void check(int idx, int bits, int sum) {\\n       // if all students have been assinged a mentor, check whether resultant sum is maximum.\\n\\t   if(idx==n) {\\n            res = max(res,sum);\\n        }\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            // select an unassigned mentor \\n\\t\\t\\tif(bits & 1<<i) {\\n\\t\\t\\t    // mark mentor as assigned\\n                bits = (bits ^ (1<<i));\\n                sum = sum + v[idx][i];\\n                // recur for next student\\n\\t\\t\\t\\tcheck(idx+1,bits,sum);\\n\\t\\t\\t\\t// backtrack\\n                sum = sum - v[idx][i];\\n                bits = bits | 1<<i;\\n            }\\n        }\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<vector<int>> temp (8, vector<int> (8,0));\\n        v = temp;\\n        n = students.size();\\n        \\n\\t\\t// vector v store the compatibility between each student mentor pair.\\n\\t\\tfor(int i=0 ; i<students.size() ; i++) {\\n            for(int j=0 ; j<mentors.size() ; j++) {\\n                v[i][j] = compat(students[i], mentors[j]);\\n            }\\n        }\\n\\t\\t// the bit value is intialized at 255 as 255 = \"11111111\" in binary.\\n        check(0,255,0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> v;\\n    int n;\\n    int res=0;\\n    \\n\\t// function to calucate compatibility between two vectors.\\n    int compat(vector<int> a, vector<int> b) {\\n        int ans = 0;\\n        for(int i=0 ; i<a.size() ; i++) {\\n            if(a[i]==b[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    void check(int idx, int bits, int sum) {\\n       // if all students have been assinged a mentor, check whether resultant sum is maximum.\\n\\t   if(idx==n) {\\n            res = max(res,sum);\\n        }\\n        \\n        for(int i=0 ; i<n ; i++) {\\n            // select an unassigned mentor \\n\\t\\t\\tif(bits & 1<<i) {\\n\\t\\t\\t    // mark mentor as assigned\\n                bits = (bits ^ (1<<i));\\n                sum = sum + v[idx][i];\\n                // recur for next student\\n\\t\\t\\t\\tcheck(idx+1,bits,sum);\\n\\t\\t\\t\\t// backtrack\\n                sum = sum - v[idx][i];\\n                bits = bits | 1<<i;\\n            }\\n        }\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<vector<int>> temp (8, vector<int> (8,0));\\n        v = temp;\\n        n = students.size();\\n        \\n\\t\\t// vector v store the compatibility between each student mentor pair.\\n\\t\\tfor(int i=0 ; i<students.size() ; i++) {\\n            for(int j=0 ; j<mentors.size() ; j++) {\\n                v[i][j] = compat(students[i], mentors[j]);\\n            }\\n        }\\n\\t\\t// the bit value is intialized at 255 as 255 = \"11111111\" in binary.\\n        check(0,255,0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361103,
                "title": "my-very-slow-4224ms-brute-force-python",
                "content": "This is my very slow, but lovely brute force solution.\\nIt\\'s so straightforward, so I think it\\'s self-explanatory.\\n\\n```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def maxCompatibilitySum(self, students, mentors) -> int:\\n        def calc(lst1, lst2):\\n            res = 0\\n            for num1, num2 in zip(lst1, lst2):\\n                res += num1 == num2\\n            return res\\n\\n        R = len(students)\\n        all_pairs = list(permutations(range(R)))\\n\\n        res = 0\\n        for pair in all_pairs:\\n            score = 0\\n            for idx1, idx2 in enumerate(pair):\\n                score += calc(students[idx1], mentors[idx2])\\n            res = max(res, score)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import permutations\\n\\nclass Solution:\\n    def maxCompatibilitySum(self, students, mentors) -> int:\\n        def calc(lst1, lst2):\\n            res = 0\\n            for num1, num2 in zip(lst1, lst2):\\n                res += num1 == num2\\n            return res\\n\\n        R = len(students)\\n        all_pairs = list(permutations(range(R)))\\n\\n        res = 0\\n        for pair in all_pairs:\\n            score = 0\\n            for idx1, idx2 in enumerate(pair):\\n                score += calc(students[idx1], mentors[idx2])\\n            res = max(res, score)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360762,
                "title": "java-simple-dfs-check-all-permutations",
                "content": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        return dfs(students,mentors,new boolean[mentors.length],0);\\n    }\\n    int dfs(int[][] s,int[][] m,boolean[] b,int o){\\n        int sum=0;\\n        if(o==s.length){\\n            return 0;\\n        }\\n        for(int i=0; i<m.length; i++){\\n            if(b[i]){\\n                continue;\\n            }\\n            int ss=0;\\n            for(int j=0; j<m[0].length; j++){\\n                if(s[o][j]==m[i][j]){\\n                    ss++;\\n                }\\n            }\\n            b[i]=true;\\n            sum=Math.max(sum,ss+dfs(s,m,b,o+1));\\n            b[i]=false;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        return dfs(students,mentors,new boolean[mentors.length],0);\\n    }\\n    int dfs(int[][] s,int[][] m,boolean[] b,int o){\\n        int sum=0;\\n        if(o==s.length){\\n            return 0;\\n        }\\n        for(int i=0; i<m.length; i++){\\n            if(b[i]){\\n                continue;\\n            }\\n            int ss=0;\\n            for(int j=0; j<m[0].length; j++){\\n                if(s[o][j]==m[i][j]){\\n                    ss++;\\n                }\\n            }\\n            b[i]=true;\\n            sum=Math.max(sum,ss+dfs(s,m,b,o+1));\\n            b[i]=false;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360756,
                "title": "permutation-of-m-with-explanation",
                "content": "Thought process:\\nFind match of students and mentors is the same as keep students in original order, but match them with permutated mentors order.\\ni.e. m = 3, perms = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 1, 0], [2, 0, 1]]\\n\\nTime: O(m! + m!*n*m)\\nSpace: O(m!)\\n\\n```\\nclass Solution(object):\\n    def maxCompatibilitySum(self, students, mentors):\\n\\t\\tm = len(students)\\n        n = len(students[0])\\n        ori = [i for i in range(m)]\\n        perms = []\\n        def perm(ori, i):\\n            if i == len(ori): \\n                perms.append(ori[:])\\n                return\\n            for j in range(i, len(ori)):\\n                ori[j], ori[i] = ori[i], ori[j]\\n                perm(ori, i+1)\\n                ori[j], ori[i] = ori[i], ori[j]\\n        perm(ori, 0)\\n        res = 0\\n        for p in perms:\\n            cur = 0\\n            for i in range(m):\\n                match = p[i]\\n                for j in range(n):\\n                    cur += 1 if students[i][j] == mentors[match][j] else 0\\n            res = max(res, cur)\\n        return res",
                "solutionTags": [],
                "code": "Thought process:\\nFind match of students and mentors is the same as keep students in original order, but match them with permutated mentors order.\\ni.e. m = 3, perms = [[0, 1, 2], [0, 2, 1], [1, 0, 2], [1, 2, 0], [2, 1, 0], [2, 0, 1]]\\n\\nTime: O(m! + m!*n*m)\\nSpace: O(m!)\\n\\n```\\nclass Solution(object):\\n    def maxCompatibilitySum(self, students, mentors):\\n\\t\\tm = len(students)\\n        n = len(students[0])\\n        ori = [i for i in range(m)]\\n        perms = []\\n        def perm(ori, i):\\n            if i == len(ori): \\n                perms.append(ori[:])\\n                return\\n            for j in range(i, len(ori)):\\n                ori[j], ori[i] = ori[i], ori[j]\\n                perm(ori, i+1)\\n                ori[j], ori[i] = ori[i], ori[j]\\n        perm(ori, 0)\\n        res = 0\\n        for p in perms:\\n            cur = 0\\n            for i in range(m):\\n                match = p[i]\\n                for j in range(n):\\n                    cur += 1 if students[i][j] == mentors[match][j] else 0\\n            res = max(res, cur)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1360754,
                "title": "c-next-permutation-solution",
                "content": "\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\t\\n        int m = students.size() ;       // number of students\\n        int n = students[0].size() ;    // number of questions\\n        int chos[m] ;                   // this array select mentors to students\\n        iota( chos , chos+m , 0 ) ;     // fill every mentor with the opposite student\\n        ll ans = 0 , curans = 0 ; \\n        do{\\n            curans = 0 ;\\n            for ( int i = 0 ; i < m ; i ++ ){\\n                for ( int j = 0 ; j < n ; j ++ ){\\n                    curans += ( students[i][j] == mentors[chos[i]][j] ) ; // add one if they are equal\\n                }\\n            }\\n            ans = max ( ans , curans ) ;    // if the current answer larger than the answer \\n                                            // make the answer equals the current answer        \\n        }while ( next_permutation(chos , chos+m ) ) ;   // keep track all the permutations of chos\\n        return ans ;\\n    }\\n};\\n\\'\\'\\'\\nfill free to ask any questions.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\t\\n        int m = students.size() ;       // number of students\\n        int n = students[0].size() ;    // number of questions\\n        int chos[m] ;                   // this array select mentors to students\\n        iota( chos , chos+m , 0 ) ;     // fill every mentor with the opposite student\\n        ll ans = 0 , curans = 0 ; \\n        do{\\n            curans = 0 ;\\n            for ( int i = 0 ; i < m ; i ++ ){\\n                for ( int j = 0 ; j < n ; j ++ ){\\n                    curans += ( students[i][j] == mentors[chos[i]][j] ) ; // add one if they are equal\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4047054,
                "title": "recursion-solution",
                "content": "# Intuition\\nInitially, I considered a greedy approach for solving the problem, where I would always chreoose the maximum compatibility score. However, I realized that this approach may not yield the correct result. Instead, I decided to adopt a recursive approach to solve the problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe code finds the maximum compatibility sum between students and mentors by exploring all possible pairings using a recursive approach. It calculates compatibility scores for each pairing and tracks visited mentors to ensure each student gets paired only once. The maximum score is returned as the result. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2 * M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<pair<int, int>>> &pq, int index, vector<int>& visited) {\\n        if (index == pq.size()) {\\n            return 0;\\n        }\\n        int score = 0;\\n        for (int i = 0; i < pq[index].size(); i++) {\\n            if (visited[i] != 1) {\\n                visited[i] = 1;\\n                score = max(score, pq[index][i].second + f(pq, index + 1, visited));\\n                visited[i] = 0; \\n            }\\n        }\\n        return score;\\n    }\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        vector<vector<pair<int, int>>> pq(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int score = 0;\\n                for (int k = 0; k < m; k++) {\\n                    if (students[i][k] == mentors[j][k]) {\\n                        score++;\\n                    }\\n                }\\n                pq[i].push_back({j, score});\\n            }\\n        }\\n        vector<int> visited(n, 0);\\n        return f(pq, 0, visited);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<pair<int, int>>> &pq, int index, vector<int>& visited) {\\n        if (index == pq.size()) {\\n            return 0;\\n        }\\n        int score = 0;\\n        for (int i = 0; i < pq[index].size(); i++) {\\n            if (visited[i] != 1) {\\n                visited[i] = 1;\\n                score = max(score, pq[index][i].second + f(pq, index + 1, visited));\\n                visited[i] = 0; \\n            }\\n        }\\n        return score;\\n    }\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        vector<vector<pair<int, int>>> pq(n);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int score = 0;\\n                for (int k = 0; k < m; k++) {\\n                    if (students[i][k] == mentors[j][k]) {\\n                        score++;\\n                    }\\n                }\\n                pq[i].push_back({j, score});\\n            }\\n        }\\n        vector<int> visited(n, 0);\\n        return f(pq, 0, visited);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730675,
                "title": "easy-to-understand-c-solution-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int score(vector<int>&v1, vector<int>&v2, int m){\\n        int cnt = 0;\\n        for(int i=0; i<m; i++){\\n            cnt += (v1[i] == v2[i]);\\n        }\\n        return cnt;\\n    }\\n    void solve(int idx, vector<int>&arr, vector<vector<int>>& ss , vector<vector<int>>& mrs, int n, int m){\\n        if(idx == arr.size()){\\n            int sum = 0;\\n            for(int i=0; i<n; i++){\\n                sum += score(ss[i],mrs[arr[i]],m);\\n            }\\n            ans = max(ans,sum);\\n            return;\\n        }\\n        for(int i=idx; i<arr.size(); i++){\\n            swap(arr[idx],arr[i]);\\n            solve(idx+1,arr,ss,mrs,n,m);\\n            swap(arr[idx],arr[i]);\\n        }\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        vector<int>arr(n);\\n        for(int i=0; i<n; i++) arr[i] = i;\\n        solve(0,arr,students,mentors,n,m);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int score(vector<int>&v1, vector<int>&v2, int m){\\n        int cnt = 0;\\n        for(int i=0; i<m; i++){\\n            cnt += (v1[i] == v2[i]);\\n        }\\n        return cnt;\\n    }\\n    void solve(int idx, vector<int>&arr, vector<vector<int>>& ss , vector<vector<int>>& mrs, int n, int m){\\n        if(idx == arr.size()){\\n            int sum = 0;\\n            for(int i=0; i<n; i++){\\n                sum += score(ss[i],mrs[arr[i]],m);\\n            }\\n            ans = max(ans,sum);\\n            return;\\n        }\\n        for(int i=idx; i<arr.size(); i++){\\n            swap(arr[idx],arr[i]);\\n            solve(idx+1,arr,ss,mrs,n,m);\\n            swap(arr[idx],arr[i]);\\n        }\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        vector<int>arr(n);\\n        for(int i=0; i<n; i++) arr[i] = i;\\n        solve(0,arr,students,mentors,n,m);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306702,
                "title": "python-brute-force-dfs-bitmask-dp-solution-with-explanation",
                "content": "### backtrack (permutation)\\nlist all permutation of student to enumearte all of student-teacher pairs.\\n### python\\n```python\\n\\'\\'\\'\\nPrecalculate the score for each student-teacher pairing, and enumerate all of the pairing using permutation to find max score\\ntc is O(n * (m^2) + m * m!), sc is O(m^2)\\n\\'\\'\\'\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        backtrack = []\\n        ans = 0\\n        scores = [[0] * len(students) for _ in range(len(students))]\\n        for i, vec_i in enumerate(students):\\n            for j, vec_j in enumerate(mentors):\\n                scores[i][j] = sum(x == y for x, y in zip(vec_i, vec_j))\\n        def dfs(used_st):\\n            if len(backtrack) == len(students):\\n                nonlocal ans\\n                ans = max(ans, sum(scores[backtrack[i]][i] for i in range(len(students))))\\n                return\\n            \\n            for i in range(len(students)):\\n                if used_st >> i & 1: continue\\n                backtrack.append(i)\\n                dfs(used_st | (1 << i))\\n                backtrack.pop()\\n        dfs(0)\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int size = students.size();\\n        vector<vector<int>> scores (size, vector<int>(size));\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = 0, sub; j < size; j+=1) {\\n                sub = 0;\\n                for (int k = 0; k < students[0].size(); k+=1)\\n                    sub += (students[i][k] == mentors[j][k]);\\n                scores[i][j] = sub;\\n            }\\n        }\\n        vector<int> backtrack;\\n        int ans = 0;\\n        function<void(int)> dfs = [&] (int used) {\\n            if (backtrack.size() == size) {\\n                int sub = 0;\\n                for (int i = 0; i < size; i+=1)\\n                    sub += scores[backtrack[i]][i];\\n                if (sub > ans) ans = sub;\\n                return;\\n            }\\n            for (int i = 0; i < size; i+=1) {\\n                if (used >> i & 1) continue;\\n                backtrack.emplace_back(i);\\n                dfs(used | (1 << i));\\n                backtrack.pop_back();\\n            }\\n        };\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```\\n\\n### bitmask dp\\ndp[mask] is max score of matched some , a bit of 1 means a student is matched.\\ncount how many matched student in mask = cnt,\\nfor each matched students in mask,\\nwe try to match cnt-th mentor with a matched student and calculate score.\\n\\ndp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + scores[j][cnt-1]),\\nwhere j is a matched student.\\n\\ntc is O(n * 2 ^n), sc is O(2^n + n* n).\\n\\n### python\\n```python\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        size = len(students)\\n        scores = [[0] * size for _ in range(size)]\\n        for i, vec_i in enumerate(students):\\n            for j, vec_j in enumerate(mentors):\\n                scores[i][j] = sum(x == y for x, y in zip(vec_i, vec_j))\\n        dp = [0] * (1 << size)\\n        for mask in range(1, 1 << size):\\n            cnt = sum(mask >> j & 1 for j in range(size))\\n            for j in range(size):\\n                if mask >> j & 1:\\n                    dp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + scores[j][cnt-1])\\n        return dp[(1 << size) - 1]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int size = students.size();\\n        vector<vector<int>> scores (size, vector<int>(size));\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = 0, sub; j < size; j+=1) {\\n                sub = 0;\\n                for (int k = 0; k < students[0].size(); k+=1)\\n                    sub += (students[i][k] == mentors[j][k]);\\n                scores[i][j] = sub;\\n            }\\n        }\\n        vector<int> dp (1 << size);\\n        for (int mask = 1, cnt; mask < 1 << size; mask+=1) {\\n            cnt = 0;\\n            for (int j = 0; j < size; j+=1) cnt += mask >> j & 1;\\n            for (int j = 0; j < size; j+=1) {\\n                if (mask >> j & 1)\\n                    dp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + scores[j][cnt-1]);\\n            }\\n        }\\n        return dp[(1 << size) - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```python\\n\\'\\'\\'\\nPrecalculate the score for each student-teacher pairing, and enumerate all of the pairing using permutation to find max score\\ntc is O(n * (m^2) + m * m!), sc is O(m^2)\\n\\'\\'\\'\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        backtrack = []\\n        ans = 0\\n        scores = [[0] * len(students) for _ in range(len(students))]\\n        for i, vec_i in enumerate(students):\\n            for j, vec_j in enumerate(mentors):\\n                scores[i][j] = sum(x == y for x, y in zip(vec_i, vec_j))\\n        def dfs(used_st):\\n            if len(backtrack) == len(students):\\n                nonlocal ans\\n                ans = max(ans, sum(scores[backtrack[i]][i] for i in range(len(students))))\\n                return\\n            \\n            for i in range(len(students)):\\n                if used_st >> i & 1: continue\\n                backtrack.append(i)\\n                dfs(used_st | (1 << i))\\n                backtrack.pop()\\n        dfs(0)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int size = students.size();\\n        vector<vector<int>> scores (size, vector<int>(size));\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = 0, sub; j < size; j+=1) {\\n                sub = 0;\\n                for (int k = 0; k < students[0].size(); k+=1)\\n                    sub += (students[i][k] == mentors[j][k]);\\n                scores[i][j] = sub;\\n            }\\n        }\\n        vector<int> backtrack;\\n        int ans = 0;\\n        function<void(int)> dfs = [&] (int used) {\\n            if (backtrack.size() == size) {\\n                int sub = 0;\\n                for (int i = 0; i < size; i+=1)\\n                    sub += scores[backtrack[i]][i];\\n                if (sub > ans) ans = sub;\\n                return;\\n            }\\n            for (int i = 0; i < size; i+=1) {\\n                if (used >> i & 1) continue;\\n                backtrack.emplace_back(i);\\n                dfs(used | (1 << i));\\n                backtrack.pop_back();\\n            }\\n        };\\n        dfs(0);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        size = len(students)\\n        scores = [[0] * size for _ in range(size)]\\n        for i, vec_i in enumerate(students):\\n            for j, vec_j in enumerate(mentors):\\n                scores[i][j] = sum(x == y for x, y in zip(vec_i, vec_j))\\n        dp = [0] * (1 << size)\\n        for mask in range(1, 1 << size):\\n            cnt = sum(mask >> j & 1 for j in range(size))\\n            for j in range(size):\\n                if mask >> j & 1:\\n                    dp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + scores[j][cnt-1])\\n        return dp[(1 << size) - 1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int size = students.size();\\n        vector<vector<int>> scores (size, vector<int>(size));\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = 0, sub; j < size; j+=1) {\\n                sub = 0;\\n                for (int k = 0; k < students[0].size(); k+=1)\\n                    sub += (students[i][k] == mentors[j][k]);\\n                scores[i][j] = sub;\\n            }\\n        }\\n        vector<int> dp (1 << size);\\n        for (int mask = 1, cnt; mask < 1 << size; mask+=1) {\\n            cnt = 0;\\n            for (int j = 0; j < size; j+=1) cnt += mask >> j & 1;\\n            for (int j = 0; j < size; j+=1) {\\n                if (mask >> j & 1)\\n                    dp[mask] = max(dp[mask], dp[mask ^ (1 << j)] + scores[j][cnt-1]);\\n            }\\n        }\\n        return dp[(1 << size) - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642839,
                "title": "c-permutation-easy-to-understand-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>visited;\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        visited.resize(n+1, 0);\\n        return permutation(students, mentors, 0, n, m);\\n    }\\n    int permutation(vector<vector<int>>& students, vector<vector<int>>& mentors, int pos, int n, int m) {\\n        if(pos>=n) {\\n            return 0;\\n        }\\n        int mx = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!visited[i]) {\\n                int cnt = 0;\\n                for(int j = 0; j < m; j++) {\\n                    if(students[pos][j] == mentors[i][j]) cnt++;\\n                }\\n                visited[i] = 1;\\n                mx = max(mx, cnt+permutation(students, mentors, pos+1, n, m));\\n                visited[i] = 0;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>visited;\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        visited.resize(n+1, 0);\\n        return permutation(students, mentors, 0, n, m);\\n    }\\n    int permutation(vector<vector<int>>& students, vector<vector<int>>& mentors, int pos, int n, int m) {\\n        if(pos>=n) {\\n            return 0;\\n        }\\n        int mx = 0;\\n        for(int i=0; i<n; i++) {\\n            if(!visited[i]) {\\n                int cnt = 0;\\n                for(int j = 0; j < m; j++) {\\n                    if(students[pos][j] == mentors[i][j]) cnt++;\\n                }\\n                visited[i] = 1;\\n                mx = max(mx, cnt+permutation(students, mentors, pos+1, n, m));\\n                visited[i] = 0;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565337,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Backtracking***\\n\\n* ***Time Complexity :- O(N * N!)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int calculate(vector<vector<int>>& students, vector<vector<int>>& mentors, vector<int>& arr)\\n    {\\n        int n = students.size();\\n        \\n        // find the compatability for curr_combination\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {   \\n            for(int j = 0; j < students[i].size(); j++)\\n            {\\n                if(students[i][j] == mentors[arr[i]][j])\\n                    sum++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n = students.size();\\n        \\n        // store the indexo of all mentors into array\\n        \\n        vector<int> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = i;\\n        }\\n        \\n        int maxi = INT_MIN;\\n        \\n        // for every combination of mentor find the comapatability and take maximum of it\\n        \\n        do\\n        {\\n            // calculate compatability\\n            \\n            int ans = calculate(students, mentors, arr);\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, ans);\\n        }\\n        \\n        while(next_permutation(arr.begin(), arr.end()));\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int calculate(vector<vector<int>>& students, vector<vector<int>>& mentors, vector<int>& arr)\\n    {\\n        int n = students.size();\\n        \\n        // find the compatability for curr_combination\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {   \\n            for(int j = 0; j < students[i].size(); j++)\\n            {\\n                if(students[i][j] == mentors[arr[i]][j])\\n                    sum++;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n = students.size();\\n        \\n        // store the indexo of all mentors into array\\n        \\n        vector<int> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = i;\\n        }\\n        \\n        int maxi = INT_MIN;\\n        \\n        // for every combination of mentor find the comapatability and take maximum of it\\n        \\n        do\\n        {\\n            // calculate compatability\\n            \\n            int ans = calculate(students, mentors, arr);\\n            \\n            // update maxi\\n            \\n            maxi = max(maxi, ans);\\n        }\\n        \\n        while(next_permutation(arr.begin(), arr.end()));\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396390,
                "title": "easy-recursion-bitmask-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[9][1<<9];\\n    int n,m;\\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& ma) {\\n        m=s.size(),n=ma[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return fun(m,0,s,ma);\\n    }\\n    int fun(int i,int mask,vector<vector<int>>& s,vector<vector<int>>& ma){\\n        if(i==0){\\n            return 0;\\n        }\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n        int ans=0;\\n        vector<int>temp=s[i-1];\\n        for(int j=0;j<m;j++){\\n            int mask1=mask&(1<<j);\\n            if(!mask1){\\n                int sum=0;\\n                for(int p=0;p<n;p++) sum+=(ma[j][p]==temp[p]);\\n                ans=max(ans,sum+fun(i-1,mask|(1<<j),s,ma));\\n            }\\n        }\\n        return dp[i][mask]=ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[9][1<<9];\\n    int n,m;\\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& ma) {\\n        m=s.size(),n=ma[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return fun(m,0,s,ma);\\n    }\\n    int fun(int i,int mask,vector<vector<int>>& s,vector<vector<int>>& ma){\\n        if(i==0){\\n            return 0;\\n        }\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n        int ans=0;\\n        vector<int>temp=s[i-1];\\n        for(int j=0;j<m;j++){\\n            int mask1=mask&(1<<j);\\n            if(!mask1){\\n                int sum=0;\\n                for(int p=0;p<n;p++) sum+=(ma[j][p]==temp[p]);\\n                ans=max(ans,sum+fun(i-1,mask|(1<<j),s,ma));\\n            }\\n        }\\n        return dp[i][mask]=ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251610,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        vector<int> stuMask;\\n        vector<int> menMask;\\n        \\n        for(int i=0;i<students.size();i++){\\n            int mask=0;\\n            for(int j=0;j<students[i].size();j++){\\n                if(students[i][j]==1)\\n                    mask=mask|(1<<j);\\n            }\\n            stuMask.push_back(mask);\\n        }\\n        \\n        for(int i=0;i<mentors.size();i++){\\n            int mask=0;\\n            for(int j=0;j<mentors[i].size();j++){\\n                if(mentors[i][j]==1)\\n                    mask=mask|(1<<j);\\n            }\\n            menMask.push_back(mask);\\n        }\\n        \\n        vector<vector<int>> dp(students.size(),vector<int>(mentors.size(),0));\\n        for(int i=0;i<stuMask.size();i++){\\n            for(int j=0;j<menMask.size();j++){\\n                int val=0;\\n                for(int k=0;k<students[0].size();k++){\\n                    if((stuMask[i]&(1<<k)) == (menMask[j]&(1<<k))){\\n                        val++;\\n                    }\\n                }\\n                dp[i][j]=val;\\n            }\\n        }\\n        \\n        int ans=0;\\n        vector<bool> stuVisited(students.size(),false);\\n        helper(dp,ans,0,stuVisited,0);\\n        return ans;\\n    }\\n    \\n    void helper(vector<vector<int>> &dp,int &ans,int val,vector<bool> &stuVisited,int idx){\\n        \\n        if(idx==stuVisited.size()){\\n            ans=max(ans,val);\\n            return;\\n        }\\n        \\n        for(int i=0;i<stuVisited.size();i++){\\n            if(!stuVisited[i]){\\n                stuVisited[i]=true;\\n                helper(dp,ans,val+dp[i][idx],stuVisited,idx+1);\\n                stuVisited[i]=false;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        vector<int> stuMask;\\n        vector<int> menMask;\\n        \\n        for(int i=0;i<students.size();i++){\\n            int mask=0;\\n            for(int j=0;j<students[i].size();j++){\\n                if(students[i][j]==1)\\n                    mask=mask|(1<<j);\\n            }\\n            stuMask.push_back(mask);\\n        }\\n        \\n        for(int i=0;i<mentors.size();i++){\\n            int mask=0;\\n            for(int j=0;j<mentors[i].size();j++){\\n                if(mentors[i][j]==1)\\n                    mask=mask|(1<<j);\\n            }\\n            menMask.push_back(mask);\\n        }\\n        \\n        vector<vector<int>> dp(students.size(),vector<int>(mentors.size(),0));\\n        for(int i=0;i<stuMask.size();i++){\\n            for(int j=0;j<menMask.size();j++){\\n                int val=0;\\n                for(int k=0;k<students[0].size();k++){\\n                    if((stuMask[i]&(1<<k)) == (menMask[j]&(1<<k))){\\n                        val++;\\n                    }\\n                }\\n                dp[i][j]=val;\\n            }\\n        }\\n        \\n        int ans=0;\\n        vector<bool> stuVisited(students.size(),false);\\n        helper(dp,ans,0,stuVisited,0);\\n        return ans;\\n    }\\n    \\n    void helper(vector<vector<int>> &dp,int &ans,int val,vector<bool> &stuVisited,int idx){\\n        \\n        if(idx==stuVisited.size()){\\n            ans=max(ans,val);\\n            return;\\n        }\\n        \\n        for(int i=0;i<stuVisited.size();i++){\\n            if(!stuVisited[i]){\\n                stuVisited[i]=true;\\n                helper(dp,ans,val+dp[i][idx],stuVisited,idx+1);\\n                stuVisited[i]=false;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178438,
                "title": "c-dp-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[9][(1<<8)+1];\\n    int n,m;\\n\\n    int rec(int lev,int mask,vector<vector<int>>& st, vector<vector<int>>& mt){\\n        if(lev==n) return 0;\\n        if(dp[lev][mask]!=-1) return dp[lev][mask];\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(!(mask&(1<<i))){\\n                int score=0;\\n                for(int j=0;j<m;j++){score+=(st[lev][j]==mt[i][j]);}\\n                ans=max(ans,score+rec(lev+1,mask|(1<<i),st,mt));\\n            }\\n        }\\n        return dp[lev][mask]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& st, vector<vector<int>>& mt) {\\n        n=st.size();\\n        m=st[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,st,mt);\\n    }\\n};```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[9][(1<<8)+1];\\n    int n,m;\\n\\n    int rec(int lev,int mask,vector<vector<int>>& st, vector<vector<int>>& mt){\\n        if(lev==n) return 0;\\n        if(dp[lev][mask]!=-1) return dp[lev][mask];\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            \\n            if(!(mask&(1<<i))){\\n                int score=0;\\n                for(int j=0;j<m;j++){score+=(st[lev][j]==mt[i][j]);}\\n                ans=max(ans,score+rec(lev+1,mask|(1<<i),st,mt));\\n            }\\n        }\\n        return dp[lev][mask]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& st, vector<vector<int>>& mt) {\\n        n=st.size();\\n        m=st[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,st,mt);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 1922240,
                "title": "python-dp-bitmask-with-explanation-faster-than-92",
                "content": "Solution from @ye15 https://leetcode.com/problems/maximum-compatibility-score-sum/discuss/1360746/Python3-permutations\\n\\nBut I use dp dict instead of python @cache decorator.\\nIt took me a while to understand the solution. So I want to write an explantaion to save some time for other.\\n\\nFirst step is easy. Calculate the score for all pairs of student and mentor.\\n\\nBut trying all the permutations is tricky.\\nBecause the total number of students is m. 1 <= m <= 8.\\nWe can use integer instead of bit. Max mask is 1 << 8 == 256\\n\\n**For example:**\\n\\nn = 3\\nMask 000 means three students are not assigned.\\nMask 100 means student 2 is assigned.\\n\\nSo basically assign all possible students to mentor 2 and then mentor 1 and then mentor 0.\\nUse mask to record the visited concept of DFS.\\nUse dp to record the calculated result for same input.\\n\\n**Most tricky parts:**\\n\\nif not (mask & (1 << i)):\\nIf student i is not assigned.\\n\\nmask ^ (1<<i)   \\nFlip the bit to 1. Mark the student assigned.\\n\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        score = [[0] * m for _ in range(m)]\\n\\t\\t\\n\\t\\t# Calculate the score for all pairs of student and mentor\\n        for i in range(m): \\n            for j in range(m): \\n                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))\\n        \\n\\t\\t# Memorize the max result for same input (mask, j)\\n        dp = {}\\n\\t\\t\\n\\t\\t# Find all possible student i. Assign student i to mentor j.\\n\\t\\t# Mask is used to record assigned students.\\n        def assign(mask, j): \\n\\t\\t\\t# This if can be removed. Assign function will stop when all students are assigned.\\n\\t\\t\\t# But it\\'s easier to understand.\\n\\t\\t\\tif j < 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t# Mask, j calculated. Return the result from dp dict.\\n            if (mask,j) in dp:\\n                return dp[(mask,j)]\\n\\t\\t\\t\\t\\n            ans = 0\\n            for i in range(m): \\n\\t\\t\\t\\t# Find all unassigned students\\n                if not (mask & (1<<i)): \\n\\t\\t\\t\\t\\t# Flip the unassigned student index to 1 in mask\\n\\t\\t\\t\\t\\t# Assign student i to mentor j\\n                    ans = max(ans, assign(mask ^ (1 << i), j - 1) + score[i][j])\\n            dp[(mask,j)] = ans        \\n            return ans \\n        \\n        return assign(0, m-1)\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        score = [[0] * m for _ in range(m)]\\n\\t\\t\\n\\t\\t# Calculate the score for all pairs of student and mentor\\n        for i in range(m): \\n            for j in range(m): \\n                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))\\n        \\n\\t\\t# Memorize the max result for same input (mask, j)\\n        dp = {}\\n\\t\\t\\n\\t\\t# Find all possible student i. Assign student i to mentor j.\\n\\t\\t# Mask is used to record assigned students.\\n        def assign(mask, j): \\n\\t\\t\\t# This if can be removed. Assign function will stop when all students are assigned.\\n\\t\\t\\t# But it\\'s easier to understand.\\n\\t\\t\\tif j < 0:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t# Mask, j calculated. Return the result from dp dict.\\n            if (mask,j) in dp:\\n                return dp[(mask,j)]\\n\\t\\t\\t\\t\\n            ans = 0\\n            for i in range(m): \\n\\t\\t\\t\\t# Find all unassigned students\\n                if not (mask & (1<<i)): \\n\\t\\t\\t\\t\\t# Flip the unassigned student index to 1 in mask\\n\\t\\t\\t\\t\\t# Assign student i to mentor j\\n                    ans = max(ans, assign(mask ^ (1 << i), j - 1) + score[i][j])\\n            dp[(mask,j)] = ans        \\n            return ans \\n        \\n        return assign(0, m-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778615,
                "title": "c-solution-with-explanation-faster-than-80",
                "content": "```\\n//We have m different students and m different mentors. So, there are m! different ways of mapping students\\n//with the mentors. This is what I\\'ve done and at last took the maximum of it. This is kind of brute force but \\n//before that I converted every row to a binary number because bitwise operations are very fast\\n\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        int n = students[0].size();\\n        \\n        /*Converting the 2D vector to a 1D vector*/\\n        vector<int> st(m);\\n        vector<int> me(m);\\n        for(int i=0; i<m; i++){\\n            int num1 = 0, num2 = 0;\\n            for(int j=0; j<n; j++){\\n                num1*=2;\\n                num1+=students[i][j];\\n                num2*=2;\\n                num2+=mentors[i][j];\\n            }\\n            st[i] = num1; //student\\n            me[i] = num2; //mentor\\n        }\\n        /*I\\'ve converted every row to a number whose binary representation is same as that of the row*/\\n        \\n        vector<int> perm(m); //created an array to map students to mentors\\n        for(int i=0; i<m; i++) perm[i] = i; //first permutation -> 0,1,2,3,...,m\\n        int res = 0; //result = maximum of all scores obtained from m! different permutations (or mappings)\\n        do{\\n            //this is a permutation\\n            int score = 0;\\n            for(int i=0; i<m; i++){\\n                int k = st[i]^me[perm[i]]; //xor between student and mentor will turn OFF matching bits\\n                //there are n bits in total and suppose p out of them are not matching\\n                //so the score = (n-p)\\n                score+=(n - __builtin_popcount(k));\\n                //__builtin_popcount(...) is an inbuilt function to count the number of ON bits in a number\\n            }\\n            res = max(score, res);\\n        }\\n        while(next_permutation(perm.begin(), perm.end())); //we iterate to the next permutation (or mapping)\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//We have m different students and m different mentors. So, there are m! different ways of mapping students\\n//with the mentors. This is what I\\'ve done and at last took the maximum of it. This is kind of brute force but \\n//before that I converted every row to a binary number because bitwise operations are very fast\\n\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        int n = students[0].size();\\n        \\n        /*Converting the 2D vector to a 1D vector*/\\n        vector<int> st(m);\\n        vector<int> me(m);\\n        for(int i=0; i<m; i++){\\n            int num1 = 0, num2 = 0;\\n            for(int j=0; j<n; j++){\\n                num1*=2;\\n                num1+=students[i][j];\\n                num2*=2;\\n                num2+=mentors[i][j];\\n            }\\n            st[i] = num1; //student\\n            me[i] = num2; //mentor\\n        }\\n        /*I\\'ve converted every row to a number whose binary representation is same as that of the row*/\\n        \\n        vector<int> perm(m); //created an array to map students to mentors\\n        for(int i=0; i<m; i++) perm[i] = i; //first permutation -> 0,1,2,3,...,m\\n        int res = 0; //result = maximum of all scores obtained from m! different permutations (or mappings)\\n        do{\\n            //this is a permutation\\n            int score = 0;\\n            for(int i=0; i<m; i++){\\n                int k = st[i]^me[perm[i]]; //xor between student and mentor will turn OFF matching bits\\n                //there are n bits in total and suppose p out of them are not matching\\n                //so the score = (n-p)\\n                score+=(n - __builtin_popcount(k));\\n                //__builtin_popcount(...) is an inbuilt function to count the number of ON bits in a number\\n            }\\n            res = max(score, res);\\n        }\\n        while(next_permutation(perm.begin(), perm.end())); //we iterate to the next permutation (or mapping)\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1736080,
                "title": "c-recursion-memorization-beats-93",
                "content": "Time Complexity: O((2^m)*n*m)\\nHelper function if not skipped takes O(mn) and will only be called 2^m times. \\n```\\nclass Solution {\\npublic:    \\n    int helper(vector<vector<int>>& s, vector<vector<int>>& me, int mask, vector<int>& dp){\\n        int idx = bitset<8>(mask).count(), m = s.size(), n = s[0].size();\\n        if(idx>=m) return 0;\\n        if(dp[mask]!=-1) return dp[mask];\\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            if(mask&(1<<i))continue;\\n            int cnt=0;\\n            for(int j=0; j<n; j++){\\n                if(s[idx][j]==me[i][j]) cnt++;\\n            }\\n            ans=max(ans,cnt+helper(s, me, mask|(1<<i), dp));\\n        }\\n        return dp[mask]=ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& me) {\\n        vector<int> dp(256/*2^8*/, -1);\\n        return helper(s, me, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int helper(vector<vector<int>>& s, vector<vector<int>>& me, int mask, vector<int>& dp){\\n        int idx = bitset<8>(mask).count(), m = s.size(), n = s[0].size();\\n        if(idx>=m) return 0;\\n        if(dp[mask]!=-1) return dp[mask];\\n        int ans=0;\\n        for(int i=0; i<m; i++){\\n            if(mask&(1<<i))continue;\\n            int cnt=0;\\n            for(int j=0; j<n; j++){\\n                if(s[idx][j]==me[i][j]) cnt++;\\n            }\\n            ans=max(ans,cnt+helper(s, me, mask|(1<<i), dp));\\n        }\\n        return dp[mask]=ans;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& me) {\\n        vector<int> dp(256/*2^8*/, -1);\\n        return helper(s, me, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650428,
                "title": "backtracking-solution-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(vector<int>&student,vector<int>&mentor){\\n        int i=0,sum=0;\\n        while(i<student.size()){\\n            if(student[i]==mentor[i])sum++;\\n            i++;\\n        }\\n        return sum;\\n    }\\n    void solve(vector<vector<int>>&students,vector<vector<int>>&mentors,int sum,int i, int &max_compat){\\n        if(i==students.size()){\\n            max_compat=fmax(sum,max_compat);\\n            return;\\n        }\\n        int n=students.size();\\n        for(int j=i;j<n;j++){\\n            swap(mentors[i],mentors[j]);\\n            solve(students,mentors,sum+check(students[i],mentors[i]),i+1,max_compat);\\n            swap(mentors[i],mentors[j]);\\n        }\\n        return;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int max_compat=0;\\n        solve(students,mentors,0,0,max_compat);\\n        return max_compat;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    int check(vector<int>&student,vector<int>&mentor){\\n        int i=0,sum=0;\\n        while(i<student.size()){\\n            if(student[i]==mentor[i])sum++;\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1542580,
                "title": "c-next-permutation",
                "content": "```\\n\\tint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int maxScore = 0;\\n        \\n        vector<int> studentId, mentorId;\\n        for (int i = 0; i < students.size(); i++) {\\n            studentId.push_back(i);\\n            mentorId.push_back(i);\\n        }\\n        \\n        int n = mentors[0].size();\\n        int maxSum = 0;\\n        \\n        do {\\n            int sum = 0;\\n            for (int j = 0; j < mentorId.size(); j++) {\\n                int cnt = 0;\\n                for (int k = 0; k < n; k++) {\\n                    if (mentors[mentorId[j]][k] == students[studentId[j]][k]) {\\n                        cnt++;\\n                    }\\n                }\\n                sum += cnt;\\n            }\\n            if (maxSum < sum) {\\n                maxSum = sum;\\n            }\\n            \\n        } while (next_permutation(studentId.begin(), studentId.end()));\\n        \\n        return maxSum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int maxScore = 0;\\n        \\n        vector<int> studentId, mentorId;\\n        for (int i = 0; i < students.size(); i++) {\\n            studentId.push_back(i);\\n            mentorId.push_back(i);\\n        }\\n        \\n        int n = mentors[0].size();\\n        int maxSum = 0;\\n        \\n        do {\\n            int sum = 0;\\n            for (int j = 0; j < mentorId.size(); j++) {\\n                int cnt = 0;\\n                for (int k = 0; k < n; k++) {\\n                    if (mentors[mentorId[j]][k] == students[studentId[j]][k]) {\\n                        cnt++;\\n                    }\\n                }\\n                sum += cnt;\\n            }\\n            if (maxSum < sum) {\\n                maxSum = sum;\\n            }\\n            \\n        } while (next_permutation(studentId.begin(), studentId.end()));\\n        \\n        return maxSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436566,
                "title": "dp-bitmask-0ms-solution-with-complete-explanation",
                "content": "Here in this problem out of all the combinations between students and mentor, we have to find the optimal combination in which the score is maximum.\\n\\nTo do so we can use recursion to explore all the combinations.\\nNow, while doing this we need to maintain track of all the mentors which have already been assigned to students, so that the new student look for only the remaining mentors.\\n\\nWe can easily acheive this using the visited array, by marking the mentors already assigned, but due to constraints being small we can instead easily use an integer whose ith bit will denote whether the ith mentor is aready assigned or not.\\n\\nTo faster up the recursion we can use memoisation on the mask, and **i need not be included in the dp** as from the mask we can easily determin the i by looking at the number of set bits.\\n\\nAlso finding the score between student[a] and mentor[b] takes O(n) time we can do precomputations to already store the result in DP[i][j] which denote the score between student[i] and mentor[j].\\n\\n```\\nclass Solution {\\n    int DP[8][8];\\n    int dp[256] = {[0 ... 255] = -1};\\n    int getMaxCompatibility(int i, int mask, vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size(), n = students[0].size();\\n        \\n        if (i == m) return 0;\\n        if (dp[mask] != -1) return dp[mask];\\n        \\n        int score = 0;\\n        for(int j = 0;j<m;j++) {\\n            if ((mask & (1 << j)) == 0) {\\n                score = max(score, DP[i][j] + getMaxCompatibility(i+1, mask + (1 << j), students, mentors));\\n            }\\n        }\\n        \\n        return dp[mask] = score;\\n    }\\n    \\n    \\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size(), n = students[0].size();\\n\\t\\t\\n        for(int i = 0;i<m;i++) {\\n            for(int j = 0;j<m;j++) {\\n                int sc = 0;\\n                for(int k = 0;k<n;k++) {\\n                    sc += (students[i][k] == mentors[j][k] ? 1 : 0);\\n                }\\n                DP[i][j] = sc;\\n            }\\n        }\\n        \\n        return getMaxCompatibility(0, 0, students, mentors);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int DP[8][8];\\n    int dp[256] = {[0 ... 255] = -1};\\n    int getMaxCompatibility(int i, int mask, vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size(), n = students[0].size();\\n        \\n        if (i == m) return 0;\\n        if (dp[mask] != -1) return dp[mask];\\n        \\n        int score = 0;\\n        for(int j = 0;j<m;j++) {\\n            if ((mask & (1 << j)) == 0) {\\n                score = max(score, DP[i][j] + getMaxCompatibility(i+1, mask + (1 << j), students, mentors));\\n            }\\n        }\\n        \\n        return dp[mask] = score;\\n    }\\n    \\n    \\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size(), n = students[0].size();\\n\\t\\t\\n        for(int i = 0;i<m;i++) {\\n            for(int j = 0;j<m;j++) {\\n                int sc = 0;\\n                for(int k = 0;k<n;k++) {\\n                    sc += (students[i][k] == mentors[j][k] ? 1 : 0);\\n                }\\n                DP[i][j] = sc;\\n            }\\n        }\\n        \\n        return getMaxCompatibility(0, 0, students, mentors);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376253,
                "title": "scala-extremely-simple-easy-to-understand-and-ineffective",
                "content": "```\\n  def maxCompatibilitySum(students: Array[Array[Int]], mentors: Array[Array[Int]]): Int =\\n    search(students.toList, mentors.toSet)\\n\\n  def search(students: List[Array[Int]], mentors: Set[Array[Int]]): Int =\\n    students match {\\n      case Nil => 0\\n      case s :: tail => mentors.map(m => compatibility(s, m) + search(tail, mentors - m)).max\\n    }\\n\\n  def compatibility(s: Array[Int], m: Array[Int]): Int = s.zip(m).count { case(s, m) => s == m } \\n  ```",
                "solutionTags": [],
                "code": "```\\n  def maxCompatibilitySum(students: Array[Array[Int]], mentors: Array[Array[Int]]): Int =\\n    search(students.toList, mentors.toSet)\\n\\n  def search(students: List[Array[Int]], mentors: Set[Array[Int]]): Int =\\n    students match {\\n      case Nil => 0\\n      case s :: tail => mentors.map(m => compatibility(s, m) + search(tail, mentors - m)).max\\n    }\\n\\n  def compatibility(s: Array[Int], m: Array[Int]): Int = s.zip(m).count { case(s, m) => s == m } \\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1373059,
                "title": "c-dsf-solution-100-120ms-25mb",
                "content": "```public class Solution {\\n    public int MaxCompatibilitySum(int[][] students, int[][] mentors) \\n    {\\n         int rows = students.Length;\\n            int cols = students[0].Length;\\n\\n            int[,] compatability = new int[rows, rows];\\n\\n            for (int i = 0; i < rows; i++) //student\\n            {\\n                int[] s = students[i];\\n                for (int j = 0; j < rows; j++) //mentor\\n                {\\n                    int[] t = mentors[j];\\n\\n                    int comp = 0;\\n                    for (int k = 0; k < cols; k++)\\n                    {\\n                        if (s[k] == t[k]) comp++;\\n                    }\\n\\n                    compatability[i, j] = comp;\\n                }\\n            }\\n\\n            int maxsum = 0;\\n            return MaxCompatibilitySumDFS(compatability, 0, new bool[rows], ref maxsum, 0);\\n    }\\n    \\n    public  int MaxCompatibilitySumDFS(int[,] compatability, int i,  bool[] visited, ref int maxsum, int sum)\\n        {\\n            int n = compatability.GetLength(0);\\n            \\n            maxsum = Math.Max(sum, maxsum);\\n            if (i >= n) return maxsum;\\n\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (visited[j]) continue;\\n                int sum1 = sum + compatability[i, j];              \\n                visited[j]=true;\\n                maxsum = MaxCompatibilitySumDFS(compatability, i + 1, visited, ref maxsum, sum1);\\n                visited[j] = false;\\n            }\\n\\n            return maxsum;\\n        }\\n}```",
                "solutionTags": [],
                "code": "```public class Solution {\\n    public int MaxCompatibilitySum(int[][] students, int[][] mentors) \\n    {\\n         int rows = students.Length;\\n            int cols = students[0].Length;\\n\\n            int[,] compatability = new int[rows, rows];\\n\\n            for (int i = 0; i < rows; i++) //student\\n            {\\n                int[] s = students[i];\\n                for (int j = 0; j < rows; j++) //mentor\\n                {\\n                    int[] t = mentors[j];\\n\\n                    int comp = 0;\\n                    for (int k = 0; k < cols; k++)\\n                    {\\n                        if (s[k] == t[k]) comp++;\\n                    }\\n\\n                    compatability[i, j] = comp;\\n                }\\n            }\\n\\n            int maxsum = 0;\\n            return MaxCompatibilitySumDFS(compatability, 0, new bool[rows], ref maxsum, 0);\\n    }\\n    \\n    public  int MaxCompatibilitySumDFS(int[,] compatability, int i,  bool[] visited, ref int maxsum, int sum)\\n        {\\n            int n = compatability.GetLength(0);\\n            \\n            maxsum = Math.Max(sum, maxsum);\\n            if (i >= n) return maxsum;\\n\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (visited[j]) continue;\\n                int sum1 = sum + compatability[i, j];              \\n                visited[j]=true;\\n                maxsum = MaxCompatibilitySumDFS(compatability, i + 1, visited, ref maxsum, sum1);\\n                visited[j] = false;\\n            }\\n\\n            return maxsum;\\n        }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1372948,
                "title": "c-easy-brute-force-using-xor-property",
                "content": "```\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size(), m = students[0].size();\\n        // n = number of students, m = number of questions\\n        vector<int> st(n), men(n);\\n        for(int i = 0; i < n; ++i) {\\n            int num1 = 0, num2 = 0;\\n            for(int j = 0; j < m; ++j) {\\n                if(students[i][j]) num1 += (1 << (m - 1 - j));\\n                if(mentors[i][j]) num2 += (1 << (m - 1 - j));\\n            }\\n            st[i] = num1; men[i] = num2;\\n        }\\n        vector<int> perm(n);\\n        int ans = 0;\\n        iota(perm.begin(), perm.end(), 0);\\n        do {\\n            int cur_score = 0;\\n            for(int i = 0; i < n; ++i) {\\n               int cur = st[i] ^ men[perm[i]];\\n                cur_score += m - __builtin_popcount(cur);\\n               \\n            }\\n            ans = max(ans, cur_score);\\n        }\\n        while(next_permutation(perm.begin(), perm.end()));\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size(), m = students[0].size();\\n        // n = number of students, m = number of questions\\n        vector<int> st(n), men(n);\\n        for(int i = 0; i < n; ++i) {\\n            int num1 = 0, num2 = 0;\\n            for(int j = 0; j < m; ++j) {\\n                if(students[i][j]) num1 += (1 << (m - 1 - j));\\n                if(mentors[i][j]) num2 += (1 << (m - 1 - j));\\n            }\\n            st[i] = num1; men[i] = num2;\\n        }\\n        vector<int> perm(n);\\n        int ans = 0;\\n        iota(perm.begin(), perm.end(), 0);\\n        do {\\n            int cur_score = 0;\\n            for(int i = 0; i < n; ++i) {\\n               int cur = st[i] ^ men[perm[i]];\\n                cur_score += m - __builtin_popcount(cur);\\n               \\n            }\\n            ans = max(ans, cur_score);\\n        }\\n        while(next_permutation(perm.begin(), perm.end()));\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367786,
                "title": "simple-c-sol-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int res = INT_MIN, n = students.size(), m = students[0].size();\\n        \\n        vector<bool> visited(n, false);\\n        f(0, 0,students, mentors, visited, res, n, m);\\n        \\n        return res;\\n    }\\n    \\n    void f(int start, int sum, vector<vector<int> > &students, vector<vector<int>  >&mentors, vector<bool> &visited, int &res, int n, int m) {\\n        if(start == n) {\\n            res = max(res, sum);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) {\\n                int count = 0;\\n                for(int j = 0; j < m; j++) {\\n                    if(students[start][j] == mentors[i][j])\\n                        count++;\\n                }\\n                visited[i] = true;\\n                f(start+1, sum+count, students, mentors, visited, res, n, m);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int res = INT_MIN, n = students.size(), m = students[0].size();\\n        \\n        vector<bool> visited(n, false);\\n        f(0, 0,students, mentors, visited, res, n, m);\\n        \\n        return res;\\n    }\\n    \\n    void f(int start, int sum, vector<vector<int> > &students, vector<vector<int>  >&mentors, vector<bool> &visited, int &res, int n, int m) {\\n        if(start == n) {\\n            res = max(res, sum);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) {\\n                int count = 0;\\n                for(int j = 0; j < m; j++) {\\n                    if(students[start][j] == mentors[i][j])\\n                        count++;\\n                }\\n                visited[i] = true;\\n                f(start+1, sum+count, students, mentors, visited, res, n, m);\\n                visited[i] = false;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366282,
                "title": "with-bitmasking",
                "content": "```\\nclass Solution {\\n    int dp[10][1<<10];\\npublic:\\n    int check(vector<vector<int>>&st,vector<vector<int>>&mt,int i,int j)\\n    {\\n        int ans=0;\\n        \\n        for(int k=0;k<st[i].size();k++)\\n        {\\n            if(st[i][k]==mt[j][k])\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int get(vector<vector<int>>&st,vector<vector<int>>&mt,int index,int mask)\\n    {\\n        if(mask==0||(index>st.size()))\\n        {\\n            return 0;\\n        }\\n        if(dp[index][mask]!=-1)\\n        {\\n            return dp[index][mask];\\n        }\\n        int ans=0;\\n        for(int i=0;i<mt.size();i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                int res=check(st,mt,index,i)+get(st,mt,index+1,mask^(1<<i));\\n                ans=max(ans,res);\\n            }\\n        }\\n        return dp[index][mask]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& st, vector<vector<int>>& me) {\\n        \\n        int n=st.size();\\n        int m=me.size();\\n        int mask=(1<<m)-1;\\n        memset(dp,-1,sizeof(dp));\\n        return get(st,me,0,mask);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[10][1<<10];\\npublic:\\n    int check(vector<vector<int>>&st,vector<vector<int>>&mt,int i,int j)\\n    {\\n        int ans=0;\\n        \\n        for(int k=0;k<st[i].size();k++)\\n        {\\n            if(st[i][k]==mt[j][k])\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int get(vector<vector<int>>&st,vector<vector<int>>&mt,int index,int mask)\\n    {\\n        if(mask==0||(index>st.size()))\\n        {\\n            return 0;\\n        }\\n        if(dp[index][mask]!=-1)\\n        {\\n            return dp[index][mask];\\n        }\\n        int ans=0;\\n        for(int i=0;i<mt.size();i++)\\n        {\\n            if(mask&(1<<i))\\n            {\\n                int res=check(st,mt,index,i)+get(st,mt,index+1,mask^(1<<i));\\n                ans=max(ans,res);\\n            }\\n        }\\n        return dp[index][mask]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& st, vector<vector<int>>& me) {\\n        \\n        int n=st.size();\\n        int m=me.size();\\n        int mask=(1<<m)-1;\\n        memset(dp,-1,sizeof(dp));\\n        return get(st,me,0,mask);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365578,
                "title": "3-line-python",
                "content": "An alternative optimization is to decorate function `score()` with `@cache` to avoid duplicated computations.\\n\\n```python\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        def score(s_id: int, m_id: int) -> int:\\n            return sum(map(lambda x, y: 1^x^y, students[s_id], mentors[m_id]))\\n        return max(sum(score(i, j) for i, j in enumerate(p)) for p in permutations(range(len(students))))\\n```",
                "solutionTags": [],
                "code": "```python\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        def score(s_id: int, m_id: int) -> int:\\n            return sum(map(lambda x, y: 1^x^y, students[s_id], mentors[m_id]))\\n        return max(sum(score(i, j) for i, j in enumerate(p)) for p in permutations(range(len(students))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1363212,
                "title": "java-74-ms-permutation-beats-100-time-and-100-memory",
                "content": "```\\nclass Solution {\\n    private int max;\\n    \\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        max = 0;\\n        permute(students, mentors, 0, students.length);\\n        return max;\\n    }\\n    \\n    private void permute(int[][] students, int[][] mentors, int index, int N){\\n        if(index == N){\\n            int score = 0;\\n            for(int i = 0; i < N; i++){\\n                score += compatibility(students[i], mentors[i]);\\n            }\\n            \\n            max = Math.max(max, score);\\n        }else{\\n            for(int i = index; i < N; i++){\\n                swap(students, index, i);\\n                permute(students, mentors, index + 1, N);\\n                swap(students, index, i);\\n            }\\n        }\\n    }\\n    \\n    private void swap(int[][] students, int i, int j){\\n        int[] temp = students[i];\\n        students[i] = students[j];\\n        students[j] = temp;\\n    }\\n    \\n    private int compatibility(int[] a, int[] b){\\n        int i, N = a.length;\\n        int sum = 0;\\n        \\n        for(i = 0; i < N; i++){\\n            if(a[i] == b[i]){\\n                ++sum;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int max;\\n    \\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        max = 0;\\n        permute(students, mentors, 0, students.length);\\n        return max;\\n    }\\n    \\n    private void permute(int[][] students, int[][] mentors, int index, int N){\\n        if(index == N){\\n            int score = 0;\\n            for(int i = 0; i < N; i++){\\n                score += compatibility(students[i], mentors[i]);\\n            }\\n            \\n            max = Math.max(max, score);\\n        }else{\\n            for(int i = index; i < N; i++){\\n                swap(students, index, i);\\n                permute(students, mentors, index + 1, N);\\n                swap(students, index, i);\\n            }\\n        }\\n    }\\n    \\n    private void swap(int[][] students, int i, int j){\\n        int[] temp = students[i];\\n        students[i] = students[j];\\n        students[j] = temp;\\n    }\\n    \\n    private int compatibility(int[] a, int[] b){\\n        int i, N = a.length;\\n        int sum = 0;\\n        \\n        for(i = 0; i < N; i++){\\n            if(a[i] == b[i]){\\n                ++sum;\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362857,
                "title": "c-dp-bitmask-15-lines-of-code-with-explanation-0ms-beats-100",
                "content": "We assign j-th mentor to i-th student from the set of mentors available.  We iterate with a fixed mentors available. For every mentor_set, if we calculate the compatibility score of assigning j-th mentor to i-th student then what is important for us is the compatibility score of assigning all other mentors (exept j-th) from current mentor-set to all other students (exept i-th). Also, if we have k mentors available then k students only can be used since exactly one mentor must be assigned to each student. Hence, finally our answer is when all (m) mentors are considered in mentor-set.\\n\\n```\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size(), n = students[0].size();\\n        vector<int> dp((1 << m), 0);\\n        for (int mentor_set = 0; mentor_set < (1 << m); ++mentor_set) {\\n            int i = __builtin_popcount(mentor_set) - 1;\\n            for (int j = 0; j < m; ++j) {\\n                if (mentor_set & (1 << j)) {\\n                    int curr = 0;\\n                    for (int k = 0; k < n; ++k)\\n                        if (students[i][k] == mentors[j][k])\\n                            ++curr;\\n                    dp[mentor_set] = max(dp[mentor_set], curr + dp[mentor_set & ~(1 << j)]);\\n                }\\n            }\\n        }\\n        return dp[(1 << m) - 1];\\n    }\\n  \\n  ```",
                "solutionTags": [],
                "code": "```\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size(), n = students[0].size();\\n        vector<int> dp((1 << m), 0);\\n        for (int mentor_set = 0; mentor_set < (1 << m); ++mentor_set) {\\n            int i = __builtin_popcount(mentor_set) - 1;\\n            for (int j = 0; j < m; ++j) {\\n                if (mentor_set & (1 << j)) {\\n                    int curr = 0;\\n                    for (int k = 0; k < n; ++k)\\n                        if (students[i][k] == mentors[j][k])\\n                            ++curr;\\n                    dp[mentor_set] = max(dp[mentor_set], curr + dp[mentor_set & ~(1 << j)]);\\n                }\\n            }\\n        }\\n        return dp[(1 << m) - 1];\\n    }\\n  \\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361633,
                "title": "easy-bitmask-and-backtracking",
                "content": "**Why backtracking**\\nThe contraints are only till 8, so we can explore all the paths.\\n**Why bitmask**\\nRecursive call consumes less space, so, it is easy to keep track of which mentor is assigned and which isn\\'t.\\n\\n```\\n    /**\\n        Find compatablilty scores for each student to each mentor.\\n        \\n        Try to explore all the possibilites of assigning a student to a mentor.\\n        Start with \"mask = 0\", means, all bits are 0 in 0, means all mentors are free.\\n        \"mask and (1 shl j) == 0\", means, is \\'jth\\' bit in the mask is \\'0\\'?, means, \\'jth\\' mentor is free.\\n            - assign the mentor and explore other paths\\n            - new mask will be updated as \"mask or (1 shl j)\", means, we have to set the \\'jth\\' bit in mask\\n    **/\\n    \\n    fun maxCompatibilitySum(A: Array<IntArray>, B: Array<IntArray>): Int {\\n        val n = A.size\\n        val compat = Array(n) { IntArray(n) }\\n        var ans = 0\\n        for ((i, row1) in A.withIndex()) {\\n            for ((j, row2) in B.withIndex()) {\\n                var score = 0\\n                for (k in 0 until row1.size)\\n                    score += if (row1[k] == row2[k]) 1 else 0 // if both are same, score increases\\n                compat[i][j] = score // ith student with jth mentor\\n            }\\n        }\\n        fun dfs(i: Int, mask: Int, total: Int) {\\n            if (i == n) { // all students are explored\\n                ans = maxOf(ans, total)\\n                return\\n            }\\n            for (j in 0 until n) { // explore all mentors for \\'ith\\' student\\n                if (mask and (1 shl j) == 0) // is \\'jth\\' mentor free?\\n                    dfs(i + 1, mask or (1 shl j), total + compat[i][j])\\n            }\\n        }\\n        \\n        dfs(0, 0, 0)\\n        return ans\\n    }\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Bitmask"
                ],
                "code": "```\\n    /**\\n        Find compatablilty scores for each student to each mentor.\\n        \\n        Try to explore all the possibilites of assigning a student to a mentor.\\n        Start with \"mask = 0\", means, all bits are 0 in 0, means all mentors are free.\\n        \"mask and (1 shl j) == 0\", means, is \\'jth\\' bit in the mask is \\'0\\'?, means, \\'jth\\' mentor is free.\\n            - assign the mentor and explore other paths\\n            - new mask will be updated as \"mask or (1 shl j)\", means, we have to set the \\'jth\\' bit in mask\\n    **/\\n    \\n    fun maxCompatibilitySum(A: Array<IntArray>, B: Array<IntArray>): Int {\\n        val n = A.size\\n        val compat = Array(n) { IntArray(n) }\\n        var ans = 0\\n        for ((i, row1) in A.withIndex()) {\\n            for ((j, row2) in B.withIndex()) {\\n                var score = 0\\n                for (k in 0 until row1.size)\\n                    score += if (row1[k] == row2[k]) 1 else 0 // if both are same, score increases\\n                compat[i][j] = score // ith student with jth mentor\\n            }\\n        }\\n        fun dfs(i: Int, mask: Int, total: Int) {\\n            if (i == n) { // all students are explored\\n                ans = maxOf(ans, total)\\n                return\\n            }\\n            for (j in 0 until n) { // explore all mentors for \\'ith\\' student\\n                if (mask and (1 shl j) == 0) // is \\'jth\\' mentor free?\\n                    dfs(i + 1, mask or (1 shl j), total + compat[i][j])\\n            }\\n        }\\n        \\n        dfs(0, 0, 0)\\n        return ans\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361427,
                "title": "java-bitmask-dp-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    Integer[] dp;\\n    int ALL;\\n    int[][] students;\\n    int[][] mentors;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        final int nStudents = students.length;\\n        final int nAnswers = students[0].length;\\n        this.students = students;\\n        this.mentors = mentors;\\n\\n        ALL = (1<<nStudents)-1;\\n        dp = new Integer[ALL + 1];\\n        return dfs(0,0, nAnswers);\\n    }\\n\\n    int dfs(int iStudent, int assignedMentors, int nAnswers){\\n        if (assignedMentors == ALL) return 0;\\n        if(iStudent >= students.length) return 0;\\n        if(dp[assignedMentors] != null) return dp[assignedMentors];\\n        int max = 0;\\n        for (int iMentor = 0; iMentor < mentors.length; iMentor++) {\\n            if ((assignedMentors & (1 << iMentor)) == 0) {\\n                final int curr = getScore(students[iStudent], mentors[iMentor], nAnswers);\\n                final int right = dfs(iStudent + 1, assignedMentors | (1 << iMentor), nAnswers);\\n                max = Math.max(max, curr + right);\\n            }\\n        }\\n        return dp[assignedMentors] = max;\\n    }\\n\\n    int getBits(int[] A){\\n        int res = 0;\\n        for (int a : A) {\\n            res |= a;\\n            res <<= 1;\\n        }\\n        res = res >> 1;\\n        return res;\\n    }\\n\\n    int getScore(int[] a, int[] b, int size){\\n        return Integer.bitCount(getBits(a) ^ ~getBits(b)) -32 + size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    Integer[] dp;\\n    int ALL;\\n    int[][] students;\\n    int[][] mentors;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        final int nStudents = students.length;\\n        final int nAnswers = students[0].length;\\n        this.students = students;\\n        this.mentors = mentors;\\n\\n        ALL = (1<<nStudents)-1;\\n        dp = new Integer[ALL + 1];\\n        return dfs(0,0, nAnswers);\\n    }\\n\\n    int dfs(int iStudent, int assignedMentors, int nAnswers){\\n        if (assignedMentors == ALL) return 0;\\n        if(iStudent >= students.length) return 0;\\n        if(dp[assignedMentors] != null) return dp[assignedMentors];\\n        int max = 0;\\n        for (int iMentor = 0; iMentor < mentors.length; iMentor++) {\\n            if ((assignedMentors & (1 << iMentor)) == 0) {\\n                final int curr = getScore(students[iStudent], mentors[iMentor], nAnswers);\\n                final int right = dfs(iStudent + 1, assignedMentors | (1 << iMentor), nAnswers);\\n                max = Math.max(max, curr + right);\\n            }\\n        }\\n        return dp[assignedMentors] = max;\\n    }\\n\\n    int getBits(int[] A){\\n        int res = 0;\\n        for (int a : A) {\\n            res |= a;\\n            res <<= 1;\\n        }\\n        res = res >> 1;\\n        return res;\\n    }\\n\\n    int getScore(int[] a, int[] b, int size){\\n        return Integer.bitCount(getBits(a) ^ ~getBits(b)) -32 + size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361322,
                "title": "java",
                "content": "```\\nclass Solution {\\n    int max=0;\\n    Set<Integer>set=new HashSet<>();\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        \\n        solve(students,mentors,\"\");\\n        return max;\\n    }\\n    \\n    void solve(int[][]students,int[][]mentor,String s){\\n\\t\\n\\t//find the ans from each permutation and return the ,max answer\\n        if(students.length==set.size()){\\n            int sum=0;\\n            for(int i=0;i<students.length;i++){\\n                \\n                int p=0;\\n                int[]z=students[i];\\n                int[]z1=mentor[s.charAt(i)-\\'0\\'];\\n                \\n                for(int j=0;j<z.length;j++){\\n                    if(z[j]==z1[j]){\\n                        p++;\\n                    }\\n                }\\n                sum=sum+p;\\n            }\\n            max=Math.max(max,sum);\\n            return;\\n        }\\n\\t\\t// Calculate all permutations\\n        for(int i=0;i<students.length;i++){\\n            if(set.contains(i)){\\n                continue;\\n            }\\n            set.add(i);\\n            solve(students,mentor,s+i);\\n            set.remove(i);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    Set<Integer>set=new HashSet<>();\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        \\n        solve(students,mentors,\"\");\\n        return max;\\n    }\\n    \\n    void solve(int[][]students,int[][]mentor,String s){\\n\\t\\n\\t//find the ans from each permutation and return the ,max answer\\n        if(students.length==set.size()){\\n            int sum=0;\\n            for(int i=0;i<students.length;i++){\\n                \\n                int p=0;\\n                int[]z=students[i];\\n                int[]z1=mentor[s.charAt(i)-\\'0\\'];\\n                \\n                for(int j=0;j<z.length;j++){\\n                    if(z[j]==z1[j]){\\n                        p++;\\n                    }\\n                }\\n                sum=sum+p;\\n            }\\n            max=Math.max(max,sum);\\n            return;\\n        }\\n\\t\\t// Calculate all permutations\\n        for(int i=0;i<students.length;i++){\\n            if(set.contains(i)){\\n                continue;\\n            }\\n            set.add(i);\\n            solve(students,mentor,s+i);\\n            set.remove(i);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361283,
                "title": "c-simple-backtracking-solution",
                "content": "```\\nint res = 0;\\n    \\nvoid countScore(vector<vector<int> >& mentors, vector<vector<int> >& students) {\\n\\tint count = 0;\\n\\tfor(int i = 0; i<students.size(); i++) {\\n\\t\\tfor(int j = 0; j<students[i].size(); j++) {\\n\\t\\t\\tif(students[i][j] == mentors[i][j]) count++;\\n\\t\\t}\\n\\t}\\n\\tres = max(res, count);\\n}\\n\\nvoid permute(vector<vector<int> >& mentors, vector<vector<int> >& students, int j) {\\n\\tif(j == mentors.size()-1) {\\n\\t\\tcountScore(mentors, students);\\n\\t\\treturn;\\n\\t}\\n\\n\\tfor(int i = j; i<mentors.size(); i++) {\\n\\t\\tswap(mentors[j], mentors[i]);\\n\\t\\tpermute(mentors, students, j+1);\\n\\t\\tswap(mentors[j], mentors[i]); //Backtracking\\n\\t}\\n}\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tpermute(mentors, students, 0);\\n\\treturn res;\\n}\\n\\n",
                "solutionTags": [],
                "code": "```\\nint res = 0;\\n    \\nvoid countScore(vector<vector<int> >& mentors, vector<vector<int> >& students) {\\n\\tint count = 0;\\n\\tfor(int i = 0; i<students.size(); i++) {\\n\\t\\tfor(int j = 0; j<students[i].size(); j++) {\\n\\t\\t\\tif(students[i][j] == mentors[i][j]) count++;\\n\\t\\t}\\n\\t}\\n\\tres = max(res, count);\\n}\\n\\nvoid permute(vector<vector<int> >& mentors, vector<vector<int> >& students, int j) {\\n\\tif(j == mentors.size()-1) {\\n\\t\\tcountScore(mentors, students);\\n\\t\\treturn;\\n\\t}\\n\\n\\tfor(int i = j; i<mentors.size(); i++) {\\n\\t\\tswap(mentors[j], mentors[i]);\\n\\t\\tpermute(mentors, students, j+1);\\n\\t\\tswap(mentors[j], mentors[i]); //Backtracking\\n\\t}\\n}\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tpermute(mentors, students, 0);\\n\\treturn res;\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1361074,
                "title": "simple-backtracking-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int calculate(vector<int>v1,vector<int>v2)\\n    {\\n        int s=0;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i]==v2[i])\\n                s+=1;\\n        }\\n        return s;\\n    }\\n    int maxscore=0;\\n    \\n    void allcombo(vector<vector<int>>& students, vector<vector<int>>& mentors,vector<int>&done,int i=0,int sum=0)//i is for students\\n    {\\n        if(i==mentors.size())\\n        {\\n            maxscore=max(maxscore,sum);\\n            return ;\\n        }\\n        for(int j=0;j<mentors.size();j++)\\n        {\\n            if(done[j]==0)\\n            {\\n                done[j]=1;\\n                allcombo(students,mentors,done,i+1,sum+calculate(students[i],mentors[j]));\\n                done[j]=0;\\n            }\\n        }\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<int>done(mentors.size(),0);\\n        allcombo(students,mentors,done);\\n        return maxscore;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int calculate(vector<int>v1,vector<int>v2)\\n    {\\n        int s=0;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i]==v2[i])\\n                s+=1;\\n        }\\n        return s;\\n    }\\n    int maxscore=0;\\n    \\n    void allcombo(vector<vector<int>>& students, vector<vector<int>>& mentors,vector<int>&done,int i=0,int sum=0)//i is for students\\n    {\\n        if(i==mentors.size())\\n        {\\n            maxscore=max(maxscore,sum);\\n            return ;\\n        }\\n        for(int j=0;j<mentors.size();j++)\\n        {\\n            if(done[j]==0)\\n            {\\n                done[j]=1;\\n                allcombo(students,mentors,done,i+1,sum+calculate(students[i],mentors[j]));\\n                done[j]=0;\\n            }\\n        }\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<int>done(mentors.size(),0);\\n        allcombo(students,mentors,done);\\n        return maxscore;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360976,
                "title": "python-2-lines-brute-force-with-permutations",
                "content": "```python\\nn = len(students)\\nsums = []\\nfor s in students:\\n\\ttemp = []\\n\\tfor m in mentors:\\n\\t\\ttemp.append(sum([s[i] == m[i] for i in range(len(s))]))\\n\\tsums.append(temp)\\nperm = list(permutations(range(0, n)))\\nresult = 0\\nfor p in perm:\\n\\tresult = max(result, sum([sums[i][p[i]] for i in range(n)]))\\nreturn result\\n```\\n\\n2 lines version:\\n```python\\nsums = [[sum([s[i] == m[i] for i in range(len(s))]) for m in mentors] for s in students]\\nreturn max(sum([sums[i][x[i]] for i in range(len(students))]) for x in list(permutations(range(0, len(students)))))\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nn = len(students)\\nsums = []\\nfor s in students:\\n\\ttemp = []\\n\\tfor m in mentors:\\n\\t\\ttemp.append(sum([s[i] == m[i] for i in range(len(s))]))\\n\\tsums.append(temp)\\nperm = list(permutations(range(0, n)))\\nresult = 0\\nfor p in perm:\\n\\tresult = max(result, sum([sums[i][p[i]] for i in range(n)]))\\nreturn result\\n```\n```python\\nsums = [[sum([s[i] == m[i] for i in range(len(s))]) for m in mentors] for s in students]\\nreturn max(sum([sums[i][x[i]] for i in range(len(students))]) for x in list(permutations(range(0, len(students)))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360970,
                "title": "c-optimized-backtracking-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    inline int score(vector<int> &a, vector<int> &b, int &size)\\n    {\\n        int s=0;\\n        for(int i=0;i<size;++i)\\n            if(a[i]==b[i])\\n                s++;\\n        return s;\\n    }\\n    inline void solve(int arr[], vector<bool> &a, int &m, int &n, int &ms, int l, int sum)\\n    {\\n        if(l==m)\\n            ms=max(ms,sum);\\n        else if(sum+((m-l)*n)>ms)\\n        {\\n            for(int i=0;i<m;++i)\\n            {\\n                if(a[i])\\n                {\\n                    a[i]=0;\\n                    solve(arr,a,m,n,ms,l+1,sum+arr[(l*m)+i]);\\n                    a[i]=1;\\n                }\\n            }\\n        }\\n    }\\n    inline int maxCompatibilitySum(vector<vector<int>>& stu, vector<vector<int>>& men) \\n    {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        int ms=0,m=stu.size(),n=stu[0].size(),t=m*m;\\n        vector<bool> a(m,1);\\n        int *arr=new int[t];\\n        \\n        for(int i=0;i<m;++i)\\n            for(int j=0;j<m;++j)\\n                arr[(i*m)+j]=score(stu[i],men[j],n);\\n        \\n        solve(arr,a,m,n,ms,0,0);\\n        return ms;\\n    }\\n};\\n```\\n***Do Hit Upvote if you like the Solution***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    inline int score(vector<int> &a, vector<int> &b, int &size)\\n    {\\n        int s=0;\\n        for(int i=0;i<size;++i)\\n            if(a[i]==b[i])\\n                s++;\\n        return s;\\n    }\\n    inline void solve(int arr[], vector<bool> &a, int &m, int &n, int &ms, int l, int sum)\\n    {\\n        if(l==m)\\n            ms=max(ms,sum);\\n        else if(sum+((m-l)*n)>ms)\\n        {\\n            for(int i=0;i<m;++i)\\n            {\\n                if(a[i])\\n                {\\n                    a[i]=0;\\n                    solve(arr,a,m,n,ms,l+1,sum+arr[(l*m)+i]);\\n                    a[i]=1;\\n                }\\n            }\\n        }\\n    }\\n    inline int maxCompatibilitySum(vector<vector<int>>& stu, vector<vector<int>>& men) \\n    {\\n        ios::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n        \\n        int ms=0,m=stu.size(),n=stu[0].size(),t=m*m;\\n        vector<bool> a(m,1);\\n        int *arr=new int[t];\\n        \\n        for(int i=0;i<m;++i)\\n            for(int j=0;j<m;++j)\\n                arr[(i*m)+j]=score(stu[i],men[j],n);\\n        \\n        solve(arr,a,m,n,ms,0,0);\\n        return ms;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1360954,
                "title": "python-dfs-recursion",
                "content": "```\\ndef cscore(a,b):\\n    ans=0\\n    for i in range(len(a)):\\n        if a[i]==b[i]:\\n            ans+=1\\n    return ans    \\ndef function(students,mentors,n,score,ans,visited):\\n    \\n    if n==0:\\n        ans.append(score)\\n        return\\n    for i in range(len(students)):\\n        if not visited[i]:\\n            visited[i]=True\\n            function(students,mentors,n-1,score+cscore(students[n-1],mentors[i]),ans,visited)\\n            visited[i]=False\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        ans=[]\\n        score=0\\n        n=len(students)\\n        visited=[False]*(len(students))\\n        function(students,mentors,n,score,ans,visited)\\n        #print(ans)\\n        return(max(ans))",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef cscore(a,b):\\n    ans=0\\n    for i in range(len(a)):\\n        if a[i]==b[i]:\\n            ans+=1\\n    return ans    \\ndef function(students,mentors,n,score,ans,visited):\\n    \\n    if n==0:\\n        ans.append(score)\\n        return\\n    for i in range(len(students)):\\n        if not visited[i]:\\n            visited[i]=True\\n            function(students,mentors,n-1,score+cscore(students[n-1],mentors[i]),ans,visited)\\n            visited[i]=False\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        ans=[]\\n        score=0\\n        n=len(students)\\n        visited=[False]*(len(students))\\n        function(students,mentors,n,score,ans,visited)\\n        #print(ans)\\n        return(max(ans))",
                "codeTag": "Java"
            },
            {
                "id": 1360879,
                "title": "java-dfs-memorization-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        int[][] scores = new int[students.length][students.length];\\n        for (int i = 0; i < scores.length; i++) {\\n            for (int j = 0; j < scores[0].length; j++) {\\n                scores[i][j] = getCompatibilityScore(students[i], mentors[j]);\\n            }\\n        }\\n        boolean[][] states = new boolean[2][students.length];\\n\\t\\t// Use list of indexes to represent whethe current state has been visited or not\\n        Map<List<Integer>, Integer> cache = new HashMap<>();\\n        return getMaxScore(scores, cache, states);\\n    }\\n    \\n    private int getMaxScore(int[][] scores, Map<List<Integer>, Integer> cache, boolean[][] states) {\\n        List<Integer> indexes = getIndexes(states);\\n\\t\\t// If visited, directly return\\n        if (cache.containsKey(indexes)) {\\n            return cache.get(indexes);\\n        }\\n        // there is only one element\\n        if (indexes.size() == 2) {\\n            cache.put(indexes, scores[indexes.get(0)][indexes.get(1)]);\\n            return cache.get(indexes);\\n        }\\n        // there are a lot element\\n        int currMax = 0;\\n        for (int i = 0; i < indexes.size() / 2; i++) {\\n            int row = indexes.get(0);\\n            states[0][row] = true;\\n            for (int j = 0; j < indexes.size() / 2; j++) {\\n                int col = indexes.get(j + indexes.size() / 2);\\n                states[1][col] = true;\\n                currMax = Math.max(currMax, scores[row][col] + getMaxScore(scores, cache, states));\\n                states[1][col] = false;\\n            }\\n            states[0][row] = false;\\n        }\\n        cache.put(indexes, currMax);\\n        return cache.get(indexes);\\n    }\\n    \\n    private List<Integer> getIndexes(boolean[][] states) {\\n        List<Integer> indexes = new ArrayList<>();\\n        for (int i = 0; i < states.length; i++) {\\n            for (int j = 0; j < states[0].length; j++) {\\n                if (states[i][j] == false) {\\n                    indexes.add(j);\\n                }\\n            }\\n        }\\n        return indexes;\\n    }\\n    \\n    private int getCompatibilityScore(int[] student, int[] mentor) {\\n        int sum = 0;\\n        for (int i = 0; i < student.length; i++) {\\n            if (student[i] == mentor[i]) {\\n                sum++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        int[][] scores = new int[students.length][students.length];\\n        for (int i = 0; i < scores.length; i++) {\\n            for (int j = 0; j < scores[0].length; j++) {\\n                scores[i][j] = getCompatibilityScore(students[i], mentors[j]);\\n            }\\n        }\\n        boolean[][] states = new boolean[2][students.length];\\n\\t\\t// Use list of indexes to represent whethe current state has been visited or not\\n        Map<List<Integer>, Integer> cache = new HashMap<>();\\n        return getMaxScore(scores, cache, states);\\n    }\\n    \\n    private int getMaxScore(int[][] scores, Map<List<Integer>, Integer> cache, boolean[][] states) {\\n        List<Integer> indexes = getIndexes(states);\\n\\t\\t// If visited, directly return\\n        if (cache.containsKey(indexes)) {\\n            return cache.get(indexes);\\n        }\\n        // there is only one element\\n        if (indexes.size() == 2) {\\n            cache.put(indexes, scores[indexes.get(0)][indexes.get(1)]);\\n            return cache.get(indexes);\\n        }\\n        // there are a lot element\\n        int currMax = 0;\\n        for (int i = 0; i < indexes.size() / 2; i++) {\\n            int row = indexes.get(0);\\n            states[0][row] = true;\\n            for (int j = 0; j < indexes.size() / 2; j++) {\\n                int col = indexes.get(j + indexes.size() / 2);\\n                states[1][col] = true;\\n                currMax = Math.max(currMax, scores[row][col] + getMaxScore(scores, cache, states));\\n                states[1][col] = false;\\n            }\\n            states[0][row] = false;\\n        }\\n        cache.put(indexes, currMax);\\n        return cache.get(indexes);\\n    }\\n    \\n    private List<Integer> getIndexes(boolean[][] states) {\\n        List<Integer> indexes = new ArrayList<>();\\n        for (int i = 0; i < states.length; i++) {\\n            for (int j = 0; j < states[0].length; j++) {\\n                if (states[i][j] == false) {\\n                    indexes.add(j);\\n                }\\n            }\\n        }\\n        return indexes;\\n    }\\n    \\n    private int getCompatibilityScore(int[] student, int[] mentor) {\\n        int sum = 0;\\n        for (int i = 0; i < student.length; i++) {\\n            if (student[i] == mentor[i]) {\\n                sum++;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360872,
                "title": "java-backtracking-dfs",
                "content": "```\\nclass Solution {\\n    public int max = 0;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        List<Integer> scores = new ArrayList<>();  \\n        boolean[] visited = new boolean[students.length];\\n        backtrack(students, mentors, 0, 0, visited);\\n        return max;\\n    }\\n    public void backtrack(int[][] students, int[][] mentors, int ind, int curScore, boolean[] visited) {\\n        \\n        if (ind == students.length) {\\n            max = Math.max(max, curScore);\\n            return;\\n        }\\n        \\n        int[] student = students[ind];\\n        for (int i = 0; i < mentors.length; i++) {\\n            if (visited[i]) {continue;}\\n            int comp = getComp(student, mentors[i]);\\n            visited[i] = true;\\n      \\n            backtrack(students, mentors, ind + 1, curScore + comp, visited);\\n            visited[i] = false;\\n        }\\n    }\\n    public int getComp(int[] a, int[] b) {\\n        int score = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == b[i]) {score++;}\\n        }\\n        return score;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int max = 0;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        List<Integer> scores = new ArrayList<>();  \\n        boolean[] visited = new boolean[students.length];\\n        backtrack(students, mentors, 0, 0, visited);\\n        return max;\\n    }\\n    public void backtrack(int[][] students, int[][] mentors, int ind, int curScore, boolean[] visited) {\\n        \\n        if (ind == students.length) {\\n            max = Math.max(max, curScore);\\n            return;\\n        }\\n        \\n        int[] student = students[ind];\\n        for (int i = 0; i < mentors.length; i++) {\\n            if (visited[i]) {continue;}\\n            int comp = getComp(student, mentors[i]);\\n            visited[i] = true;\\n      \\n            backtrack(students, mentors, ind + 1, curScore + comp, visited);\\n            visited[i] = false;\\n        }\\n    }\\n    public int getComp(int[] a, int[] b) {\\n        int score = 0;\\n        for (int i = 0; i < a.length; i++) {\\n            if (a[i] == b[i]) {score++;}\\n        }\\n        return score;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360833,
                "title": "python3-simple-bitmask-dp",
                "content": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        n = len(students[0])\\n        complete = (1 << m) - 1\\n        scores = [[0] * m for _ in range(m)]\\n        def calc(st, me):\\n            score = 0\\n            for i in range(n):\\n                if st[i] == me[i]:\\n                    score += 1\\n            return score\\n        for i in range(m):\\n            for j in range(m):\\n                scores[i][j] = calc(students[i], mentors[j])\\n        @lru_cache(None)\\n        def dfs(mask1, mask2):\\n            if mask1 == complete:\\n                return 0\\n            res = 0\\n            for i in range(m):\\n                if (mask1 >> i) & 1:\\n                    continue\\n                for j in range(m):\\n                    if (mask2 >> j) & 1:\\n                        continue\\n                    res = max(res, dfs(mask1 ^ (1 << i), mask2 ^ (1 << j)) + scores[i][j])\\n            return res\\n        res = dfs(0, 0)\\n        dfs.cache_clear()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        n = len(students[0])\\n        complete = (1 << m) - 1\\n        scores = [[0] * m for _ in range(m)]\\n        def calc(st, me):\\n            score = 0\\n            for i in range(n):\\n                if st[i] == me[i]:\\n                    score += 1\\n            return score\\n        for i in range(m):\\n            for j in range(m):\\n                scores[i][j] = calc(students[i], mentors[j])\\n        @lru_cache(None)\\n        def dfs(mask1, mask2):\\n            if mask1 == complete:\\n                return 0\\n            res = 0\\n            for i in range(m):\\n                if (mask1 >> i) & 1:\\n                    continue\\n                for j in range(m):\\n                    if (mask2 >> j) & 1:\\n                        continue\\n                    res = max(res, dfs(mask1 ^ (1 << i), mask2 ^ (1 << j)) + scores[i][j])\\n            return res\\n        res = dfs(0, 0)\\n        dfs.cache_clear()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360831,
                "title": "python-3-easy-understand-backtracking-solution",
                "content": "The first thing we need to do is to initialize the `student-teacher` compatibility score matrix:\\n`mat[i][j] = n - sum(abs(students[i][x] - mentors[j][x]) for x in range(n))`\\n\\nAfter we build the compatibility score matrix, than it becomes the standard backtracking problem.\\nCode:\\n```python\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n\\t\\t# mat[i][j] represents compatibility Score between students i and mentor j\\n        mat = [[0] * m for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(m):\\n                mat[i][j] = n - sum(abs(students[i][x] - mentors[j][x]) for x in range(n))\\n                \\n        self.res = 0\\n        seen = set()\\n        \\n        def backtrack(step, score):\\n            if step == m:\\n                self.res = max(self.res, score)\\n                return\\n            \\n            for i in range(m):\\n                if i not in seen:\\n                    # pair students and mentor\\n\\t\\t\\t\\t\\t# add mentor\\'s index to seen set\\n                    seen.add(i)\\n                    # move to next state\\n                    backtrack(step + 1, score + mat[step][i])\\n                    # backtrack\\n                    seen.remove(i)\\n                    \\n        backtrack(0, 0)\\n        return self.res\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n\\t\\t# mat[i][j] represents compatibility Score between students i and mentor j\\n        mat = [[0] * m for _ in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(m):\\n                mat[i][j] = n - sum(abs(students[i][x] - mentors[j][x]) for x in range(n))\\n                \\n        self.res = 0\\n        seen = set()\\n        \\n        def backtrack(step, score):\\n            if step == m:\\n                self.res = max(self.res, score)\\n                return\\n            \\n            for i in range(m):\\n                if i not in seen:\\n                    # pair students and mentor\\n\\t\\t\\t\\t\\t# add mentor\\'s index to seen set\\n                    seen.add(i)\\n                    # move to next state\\n                    backtrack(step + 1, score + mat[step][i])\\n                    # backtrack\\n                    seen.remove(i)\\n                    \\n        backtrack(0, 0)\\n        return self.res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360823,
                "title": "c-concise-code-using-next-permutation-o-n-n-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        vector<int>pos;\\n        \\n        for(int i = 0; i<n;i++){\\n            pos.push_back(i);\\n        }\\n        \\n        int ans = 0;\\n        \\n        do{\\n            int cur = 0;\\n            for(int i = 0; i<n;i++){\\n                for(int j = 0; j<m; j++){\\n                    if(students[i][j]==mentors[pos[i]][j])cur++;\\n                }\\n            }\\n            ans = max(cur,ans);\\n        }while(next_permutation(pos.begin(), pos.end()));\\n        return ans;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        vector<int>pos;\\n        \\n        for(int i = 0; i<n;i++){\\n            pos.push_back(i);\\n        }\\n        \\n        int ans = 0;\\n        \\n        do{\\n            int cur = 0;\\n            for(int i = 0; i<n;i++){\\n                for(int j = 0; j<m; j++){\\n                    if(students[i][j]==mentors[pos[i]][j])cur++;\\n                }\\n            }\\n            ans = max(cur,ans);\\n        }while(next_permutation(pos.begin(), pos.end()));\\n        return ans;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360783,
                "title": "python-solution-with-backtracking",
                "content": "```\\nclass Solution:\\n    \\n    def check_commonality(self, student, mentor):\\n        i = 0\\n        count = 0\\n        while i < len(student):\\n            if student[i] == mentor[i]:\\n                count+=1\\n            i+=1\\n        return count\\n    \\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        matrix = [[0 for x in range(len(mentors))] for y in range(len(students))]\\n        \\n        for i in range(len(students)):\\n            for j in range(len(mentors)):\\n                matrix[i][j] = self.check_commonality(students[i], mentors[j])\\n        nums_ = []\\n        def dfs(i, sum_, visited):\\n            if i == len(matrix):\\n                nums_.append(sum_)\\n                return\\n            max_ = 0\\n            for j in range(len(matrix[0])):\\n                if j not in visited:\\n                    visited.append(j)\\n                    dfs(i+1, sum_ + matrix[i][j], visited)\\n                    visited.pop()\\n        dfs(0, 0, [])\\n        \\n        return max(nums_)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def check_commonality(self, student, mentor):\\n        i = 0\\n        count = 0\\n        while i < len(student):\\n            if student[i] == mentor[i]:\\n                count+=1\\n            i+=1\\n        return count\\n    \\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        matrix = [[0 for x in range(len(mentors))] for y in range(len(students))]\\n        \\n        for i in range(len(students)):\\n            for j in range(len(mentors)):\\n                matrix[i][j] = self.check_commonality(students[i], mentors[j])\\n        nums_ = []\\n        def dfs(i, sum_, visited):\\n            if i == len(matrix):\\n                nums_.append(sum_)\\n                return\\n            max_ = 0\\n            for j in range(len(matrix[0])):\\n                if j not in visited:\\n                    visited.append(j)\\n                    dfs(i+1, sum_ + matrix[i][j], visited)\\n                    visited.pop()\\n        dfs(0, 0, [])\\n        \\n        return max(nums_)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360763,
                "title": "easy-backtracking-solution",
                "content": "\\n\\t class Solution {\\n\\t\\t public:\\n\\t\\t\\tvoid sol( vector<vector<int>>& arr ,unordered_set<int>&vis , int row ,  int count , int &ans){\\n\\t\\t\\t\\tif(row == arr.size()){\\n\\t\\t\\t\\t\\tans = max(count ,ans );\\n\\t\\t\\t\\t\\treturn ; \\n            \\n        }\\n        \\n        for(int i =  0;i<arr[0].size();i++){\\n            if(vis.count(i)){\\n                continue ;\\n            }else {\\n                \\n                vis.insert(i);\\n                sol(arr,vis , row+1,count + arr[row][i],ans );\\n                vis.erase(i);\\n            }\\n        }\\n        \\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s, vector<vector<int>>& m) {\\n        vector<vector<int>>arr(s.size(),vector<int>(m.size())) ;\\n        for(int i = 0;i<s.size();i++){\\n            \\n            for(int j = 0;j<m.size();j++){\\n               int val = 0 ;\\n                \\n                for(int k = 0 ;k<s[0].size();k++ ){\\n                   if(m[i][k] == s[j][k]){\\n                       val++;\\n                   } \\n                }\\n                arr[i][j] = val ;\\n            }\\n        }\\n        // for checking visited column\\n        unordered_set<int>vis ; \\n        \\n        int ans = 0 ;\\n        sol(arr,vis,0,0,ans);\\n        return ans ;\\n        \\n    }};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t public:\\n\\t\\t\\tvoid sol( vector<vector<int>>& arr ,unordered_set<int>&vis , int row ,  int count , int &ans){\\n\\t\\t\\t\\tif(row == arr.size()){\\n\\t\\t\\t\\t\\tans = max(count ,ans );\\n\\t\\t\\t\\t\\treturn ; \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1360757,
                "title": "backtracking-with-dp-and-bit-manipulation-explanation-in-comments-c",
                "content": "```\\nclass Solution {\\npublic:\\n     int dp[10][18000];\\n    int helper(int idx,int taken,vector<vector<int>>& student,vector<vector<int>>& mentor)\\n    {\\n        if(idx>=student.size()) return 0;\\n        if(dp[idx][taken]!=-1) return dp[idx][taken];\\n        int ans=-1e8;\\n        for(int i=0;i<student.size();i++)\\n        {\\n            //taken will tell us about the indexes that have been taken, e.g. taken=000101 in bit reprenstation tells index 0 and 2 have been taken\\n            if(taken&(1<<i)) continue; //if this index is already taken then continue\\n            taken^=(1<<i);             //take the current index ,xor will  set the bit  at index i\\n            int curr=0;\\n            for(int k=0;k<student[idx].size();k++){ //calculate current score\\n                if(student[idx][k]==mentor[i][k]) curr++;\\n            }\\n            ans=max(ans,(curr)+helper(idx+1,taken,student,mentor));//take maximum of all possibilities\\n            taken^=(1<<i); //backtrack the previous taken index, xor will reset the bit at index i\\n        }\\n        return dp[idx][taken]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& student, vector<vector<int>>& mentor) {\\n        int n=student.size();int q=student[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int ans=helper(0,0,student,mentor);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     int dp[10][18000];\\n    int helper(int idx,int taken,vector<vector<int>>& student,vector<vector<int>>& mentor)\\n    {\\n        if(idx>=student.size()) return 0;\\n        if(dp[idx][taken]!=-1) return dp[idx][taken];\\n        int ans=-1e8;\\n        for(int i=0;i<student.size();i++)\\n        {\\n            //taken will tell us about the indexes that have been taken, e.g. taken=000101 in bit reprenstation tells index 0 and 2 have been taken\\n            if(taken&(1<<i)) continue; //if this index is already taken then continue\\n            taken^=(1<<i);             //take the current index ,xor will  set the bit  at index i\\n            int curr=0;\\n            for(int k=0;k<student[idx].size();k++){ //calculate current score\\n                if(student[idx][k]==mentor[i][k]) curr++;\\n            }\\n            ans=max(ans,(curr)+helper(idx+1,taken,student,mentor));//take maximum of all possibilities\\n            taken^=(1<<i); //backtrack the previous taken index, xor will reset the bit at index i\\n        }\\n        return dp[idx][taken]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& student, vector<vector<int>>& mentor) {\\n        int n=student.size();int q=student[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        int ans=helper(0,0,student,mentor);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360728,
                "title": "brute-force-c-permutations",
                "content": "```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxCompatibilitySum(VVI& A, VVI& B, int best = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        sort(A.begin(), A.end());\\n        do {\\n            auto cand = 0;\\n            for (auto i{ 0 }; i < M; ++i)\\n                for (auto j{ 0 }; j < N; ++j)\\n                    cand += A[i][j] == B[i][j];\\n            best = max(best, cand);\\n        } while (next_permutation(A.begin(), A.end()));\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int maxCompatibilitySum(VVI& A, VVI& B, int best = 0) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        sort(A.begin(), A.end());\\n        do {\\n            auto cand = 0;\\n            for (auto i{ 0 }; i < M; ++i)\\n                for (auto j{ 0 }; j < N; ++j)\\n                    cand += A[i][j] == B[i][j];\\n            best = max(best, cand);\\n        } while (next_permutation(A.begin(), A.end()));\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086345,
                "title": "c-bitmasks-permutations",
                "content": "# Intuition\\n- Looked at constraints - m,n <=8 that usually means that bitmasks are on the table.\\n- After bit of a thought realized how to efficiently calculate score from 2 bitmasks.\\n- Permutations generation pattern - again possible due to low m and n. Similar as in question #46 for example.\\n\\n# Approach\\n1. Prepare bitmasks for all the students and mentors\\n2. Generate permutations either from students or mentors - calculate score for each generated permutation.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n!)$$ This dominated by the permutations, which means  bitmask tricks just allow to make it slightly less horrible. Bitmask tricks make this ~8 times faster or so in the worst case.\\n\\n- Space complexity:\\n$$O(n)$$ roughly, we reduce input questions to bitmasks & use stack in recursion for finding permutations, but we do not store them.\\n\\n# Code\\n```\\npublic class Solution {\\n    // bitmask of answers\\n    uint calcMask(int[] A)\\n    {\\n        uint V = 0;\\n        for (int j = 0; j < A.Length; j++)\\n            if (A[j] != 0)\\n            {\\n                V |= (1u << j);\\n            }\\n\\n        return V;\\n\\n    }\\n    // score between a and b bitmasks\\n    // mask = integer with m least bits set\\n    int score(uint a, uint b, uint mask)\\n    {\\n        // AND and Popcntz\\n        return BitOperations.PopCount(a&b) + \\n              // Invert A and B, apply masks get M/N bits, AND, popcnt\\n              BitOperations.PopCount(((~a) & mask)&((~b) & mask));\\n    }\\n\\n    // Score for all the array\\n    int scoreAll(uint[] S, uint[] M, uint mask)\\n    {\\n        int result = 0;\\n        for (int i = 0; i < S.Length; i++)\\n        {\\n            result += score(S[i], M[i], mask);\\n        }\\n        return result;\\n    }\\n\\n    void swap(uint[] nums, int a, int b)\\n    {\\n        var tmp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = tmp;        \\n    }    \\n    // Permutations generating pattern (#46)\\n    int solve(int n, uint[] S, uint[] M, uint mask)\\n    {\\n        int answer = 0;\\n\\n        if (n < 0)\\n        {\\n            return scoreAll(S,M, mask);\\n        }\\n\\n        for (int i = n; i >=0 ; i--)\\n        {\\n            swap(S, n, i);\\n            answer = Math.Max(answer, solve(n-1, S, M, mask)); \\n            swap(S, n, i);            \\n        }\\n        return answer;\\n    }\\n\\n    public int MaxCompatibilitySum(int[][] students, int[][] mentors)\\n    {\\n        uint[] S = new uint[students.Length];\\n        uint[] M = new uint[mentors.Length];\\n\\n        uint mask = 0;\\n        // precalculate mask that sets N/M least bits\\n        for (int i = 0; i < students[0].Length; i++)\\n            mask |= (1u << i);\\n\\n        // precalculate bitmasks for students and mentors \\n        for (int i = 0; i < S.Length; i++)\\n        {\\n            S[i] = calcMask(students[i]);\\n            M[i] = calcMask(mentors[i]);\\n        }\\n        \\n        return solve(S.Length-1, S, M, mask);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    // bitmask of answers\\n    uint calcMask(int[] A)\\n    {\\n        uint V = 0;\\n        for (int j = 0; j < A.Length; j++)\\n            if (A[j] != 0)\\n            {\\n                V |= (1u << j);\\n            }\\n\\n        return V;\\n\\n    }\\n    // score between a and b bitmasks\\n    // mask = integer with m least bits set\\n    int score(uint a, uint b, uint mask)\\n    {\\n        // AND and Popcntz\\n        return BitOperations.PopCount(a&b) + \\n              // Invert A and B, apply masks get M/N bits, AND, popcnt\\n              BitOperations.PopCount(((~a) & mask)&((~b) & mask));\\n    }\\n\\n    // Score for all the array\\n    int scoreAll(uint[] S, uint[] M, uint mask)\\n    {\\n        int result = 0;\\n        for (int i = 0; i < S.Length; i++)\\n        {\\n            result += score(S[i], M[i], mask);\\n        }\\n        return result;\\n    }\\n\\n    void swap(uint[] nums, int a, int b)\\n    {\\n        var tmp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = tmp;        \\n    }    \\n    // Permutations generating pattern (#46)\\n    int solve(int n, uint[] S, uint[] M, uint mask)\\n    {\\n        int answer = 0;\\n\\n        if (n < 0)\\n        {\\n            return scoreAll(S,M, mask);\\n        }\\n\\n        for (int i = n; i >=0 ; i--)\\n        {\\n            swap(S, n, i);\\n            answer = Math.Max(answer, solve(n-1, S, M, mask)); \\n            swap(S, n, i);            \\n        }\\n        return answer;\\n    }\\n\\n    public int MaxCompatibilitySum(int[][] students, int[][] mentors)\\n    {\\n        uint[] S = new uint[students.Length];\\n        uint[] M = new uint[mentors.Length];\\n\\n        uint mask = 0;\\n        // precalculate mask that sets N/M least bits\\n        for (int i = 0; i < students[0].Length; i++)\\n            mask |= (1u << i);\\n\\n        // precalculate bitmasks for students and mentors \\n        for (int i = 0; i < S.Length; i++)\\n        {\\n            S[i] = calcMask(students[i]);\\n            M[i] = calcMask(mentors[i]);\\n        }\\n        \\n        return solve(S.Length-1, S, M, mask);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078240,
                "title": "c-solution-using-backtacking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstraints are very low, so it can be done using backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& s, vector<vector<int>>& m, int i, int j, int n, unordered_set<int>& st,int m2){\\n        if(i>=n || j>=n){\\n            return 0;\\n        }\\n\\n        int ans = 0;\\n        for(int k = 0;k<n;k++){\\n            int temp = 0;\\n            if(st.find(k) == st.end()){\\n                int x = 0;\\n                for(int c = 0;c<m2;c++){\\n                    if(s[i][c] == m[k][c]){\\n                        x++;\\n                    }\\n                }\\n                st.insert(k);\\n                temp = x + solve(s,m,i+1,j,n,st,m2);\\n                st.erase(k);\\n            }\\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n = students.size(), m = mentors[0].size();\\n        unordered_set<int> st;\\n        return solve(students,mentors,0,0,n,st,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(vector<vector<int>>& s, vector<vector<int>>& m, int i, int j, int n, unordered_set<int>& st,int m2){\\n        if(i>=n || j>=n){\\n            return 0;\\n        }\\n\\n        int ans = 0;\\n        for(int k = 0;k<n;k++){\\n            int temp = 0;\\n            if(st.find(k) == st.end()){\\n                int x = 0;\\n                for(int c = 0;c<m2;c++){\\n                    if(s[i][c] == m[k][c]){\\n                        x++;\\n                    }\\n                }\\n                st.insert(k);\\n                temp = x + solve(s,m,i+1,j,n,st,m2);\\n                st.erase(k);\\n            }\\n            ans = max(ans,temp);\\n        }\\n        return ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n = students.size(), m = mentors[0].size();\\n        unordered_set<int> st;\\n        return solve(students,mentors,0,0,n,st,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039393,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int getscore(int score,int mscore,int size){\\n        int res=size;\\n        int n=score^mscore;\\n        while(n!=0){\\n            if(n%2==1){\\n                res-=1;\\n            }\\n            n/=2;\\n        }\\n        return res;\\n    }\\n    void helper(vector<int>& studentscore,vector<int>& mentorscore,vector<bool>& visited,int pos,int score,int maxsize,int& maxn){\\n        if(pos>=studentscore.size()){\\n            printf(\"Get score :%d\\\\n\",score);\\n            maxn=max(maxn,score);\\n            return;\\n        }\\n        \\n        for(int i=0;i<mentorscore.size();i++){\\n            if(!visited[i]){\\n                visited[i]=true;\\n                int s=getscore(studentscore[pos],mentorscore[i],maxsize);\\n                helper(studentscore,mentorscore,visited,pos+1,score+s,maxsize,maxn);\\n                visited[i]=false;\\n            }\\n        }\\n        return;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=students.size();\\n        int maxn=0;\\n        vector<int> studentsScore(n,0);\\n        vector<int> mentorsScore(n,0);\\n        vector<bool> visited(n,false);\\n        int scoremax=students[0].size();\\n        for(int i=0;i<n;i++){\\n            int score1=0,score2=0;\\n            for(int j=0;j<students[i].size();j++){\\n                score1=score1*2+students[i][j];\\n                score2=score2*2+mentors[i][j];\\n            }\\n            // printf(\"score1 :%d |score2: %d\\\\n\",score1,score2);\\n            studentsScore[i]=score1;\\n            mentorsScore[i]=score2;\\n        }\\n        helper(studentsScore,mentorsScore,visited,0,0,scoremax,maxn);\\n        return maxn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getscore(int score,int mscore,int size){\\n        int res=size;\\n        int n=score^mscore;\\n        while(n!=0){\\n            if(n%2==1){\\n                res-=1;\\n            }\\n            n/=2;\\n        }\\n        return res;\\n    }\\n    void helper(vector<int>& studentscore,vector<int>& mentorscore,vector<bool>& visited,int pos,int score,int maxsize,int& maxn){\\n        if(pos>=studentscore.size()){\\n            printf(\"Get score :%d\\\\n\",score);\\n            maxn=max(maxn,score);\\n            return;\\n        }\\n        \\n        for(int i=0;i<mentorscore.size();i++){\\n            if(!visited[i]){\\n                visited[i]=true;\\n                int s=getscore(studentscore[pos],mentorscore[i],maxsize);\\n                helper(studentscore,mentorscore,visited,pos+1,score+s,maxsize,maxn);\\n                visited[i]=false;\\n            }\\n        }\\n        return;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=students.size();\\n        int maxn=0;\\n        vector<int> studentsScore(n,0);\\n        vector<int> mentorsScore(n,0);\\n        vector<bool> visited(n,false);\\n        int scoremax=students[0].size();\\n        for(int i=0;i<n;i++){\\n            int score1=0,score2=0;\\n            for(int j=0;j<students[i].size();j++){\\n                score1=score1*2+students[i][j];\\n                score2=score2*2+mentors[i][j];\\n            }\\n            // printf(\"score1 :%d |score2: %d\\\\n\",score1,score2);\\n            studentsScore[i]=score1;\\n            mentorsScore[i]=score2;\\n        }\\n        helper(studentsScore,mentorsScore,visited,0,0,scoremax,maxn);\\n        return maxn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968967,
                "title": "c-next-permutation-easy",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>> &s, vector<vector<int>> &m)\\n    {\\n        int n=s.size();\\n        int n2=s[0].size();\\n        int ans=0;\\n        \\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            int cand=0;\\n            for(int i{0};i<n;i++)\\n            {\\n                for(int j{0};j<n2;j++)\\n                {\\n                    if(s[i][j]==m[i][j])\\n                        cand++;\\n                }\\n            }\\n            ans=max(best,cand);\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>> &s, vector<vector<int>> &m)\\n    {\\n        int n=s.size();\\n        int n2=s[0].size();\\n        int ans=0;\\n        \\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            int cand=0;\\n            for(int i{0};i<n;i++)\\n            {\\n                for(int j{0};j<n2;j++)\\n                {\\n                    if(s[i][j]==m[i][j])\\n                        cand++;\\n                }\\n            }\\n            ans=max(best,cand);\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968964,
                "title": "c-next-permutation-easy-code",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>> &s, vector<vector<int>> &m)\\n    {\\n        int n=s.size();\\n        int n2=s[0].size();\\n        int ans=0;\\n        \\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            int cand=0;\\n            for(int i{0};i<n;i++)\\n            {\\n                for(int j{0};j<n2;j++)\\n                {\\n                    if(s[i][j]==m[i][j])\\n                        cand++;\\n                }\\n            }\\n            ans=max(best,cand);\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>> &s, vector<vector<int>> &m)\\n    {\\n        int n=s.size();\\n        int n2=s[0].size();\\n        int ans=0;\\n        \\n        sort(s.begin(),s.end());\\n        \\n        do{\\n            int cand=0;\\n            for(int i{0};i<n;i++)\\n            {\\n                for(int j{0};j<n2;j++)\\n                {\\n                    if(s[i][j]==m[i][j])\\n                        cand++;\\n                }\\n            }\\n            ans=max(best,cand);\\n        }while(next_permutation(s.begin(),s.end()));\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943399,
                "title": "c-easy-solution-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans ;\\n    map<pair<int ,int >, int >mm ; \\n    int dp[1<<9][1<<9] ;\\n    int cal(int n, vector<vector<int>>& s , vector<vector<int>>& m , int m1 , int m2  )\\n    {\\n          if(m1==(1<<n)-1 && m2==(1<<n)-1)\\n          {\\n            return 0 ; \\n          }\\n        \\n        if(dp[m1][m2]!=-1)\\n            return dp[m1][m2] ;\\n         \\n        int ans =0 , maxi = 0 ; \\n        \\n        for(int i = 0 ;i<n ;i++ )\\n        {\\n            for(int j= 0; j<n ;j++ )\\n            {\\n                if((m1&(1<<i))==0 && (m2&(1<<j))==0)\\n                {\\n                  ans = mm[{i,j}] + cal(n , s, m ,m1|(1<<i) , m2|(1<<j)  );\\n                    maxi = max(maxi ,ans ) ;\\n                }\\n            }\\n        }\\n        return dp[m1][m2] = maxi ; \\n    }   \\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s , vector<vector<int>>& m ) {\\n    \\n        \\n        int n = s.size() ; \\n        \\n          for(int i = 0 ;i<n ;i++ )\\n        {\\n            for(int j= 0; j<n ;j++ )\\n            {\\n                int ans = 0; \\n             for(int k=0 ; k<s[i].size(); k++ )\\n             {\\n                 if(s[i][k]==m[j][k])\\n                     ans++ ; \\n             }\\n                mm[{i, j}]= ans  ;\\n            }\\n        }\\n        memset(dp ,-1, sizeof(dp)) ;\\n        return cal(n, s , m , 0  , 0 ) ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans ;\\n    map<pair<int ,int >, int >mm ; \\n    int dp[1<<9][1<<9] ;\\n    int cal(int n, vector<vector<int>>& s , vector<vector<int>>& m , int m1 , int m2  )\\n    {\\n          if(m1==(1<<n)-1 && m2==(1<<n)-1)\\n          {\\n            return 0 ; \\n          }\\n        \\n        if(dp[m1][m2]!=-1)\\n            return dp[m1][m2] ;\\n         \\n        int ans =0 , maxi = 0 ; \\n        \\n        for(int i = 0 ;i<n ;i++ )\\n        {\\n            for(int j= 0; j<n ;j++ )\\n            {\\n                if((m1&(1<<i))==0 && (m2&(1<<j))==0)\\n                {\\n                  ans = mm[{i,j}] + cal(n , s, m ,m1|(1<<i) , m2|(1<<j)  );\\n                    maxi = max(maxi ,ans ) ;\\n                }\\n            }\\n        }\\n        return dp[m1][m2] = maxi ; \\n    }   \\n    \\n    int maxCompatibilitySum(vector<vector<int>>& s , vector<vector<int>>& m ) {\\n    \\n        \\n        int n = s.size() ; \\n        \\n          for(int i = 0 ;i<n ;i++ )\\n        {\\n            for(int j= 0; j<n ;j++ )\\n            {\\n                int ans = 0; \\n             for(int k=0 ; k<s[i].size(); k++ )\\n             {\\n                 if(s[i][k]==m[j][k])\\n                     ans++ ; \\n             }\\n                mm[{i, j}]= ans  ;\\n            }\\n        }\\n        memset(dp ,-1, sizeof(dp)) ;\\n        return cal(n, s , m , 0  , 0 ) ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940854,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findCompScore(vector<vector<int>>& students, vector<vector<int>>& mentors , int student , int mentor){\\n        int sum = 0;\\n        for (int i=0 ; i<students[0].size() ; i++){\\n            if (students[student][i] == mentors[mentor][i])\\n                sum++;\\n        }\\n        return sum;\\n    }\\n\\n    void solve(vector<vector<int>>& students, vector<vector<int>>& mentors , vector<int>& vis, int student , int& res , int score){\\n        if (student >= students.size()){\\n            res = max(res , score);\\n            return;\\n        }\\n\\n        for (int i=0 ; i<students.size() ; i++){\\n            if (vis[i] == 0){\\n                vis[i] = 1;\\n                int compatibility = findCompScore(students , mentors , student , i);\\n                solve(students , mentors , vis , student+1 , res , score + compatibility);\\n                vis[i] = 0;\\n            }\\n        }\\n    }\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<int> vis(mentors.size(),0);\\n        int index = 0;\\n        int res = 0;\\n        int score = 0;\\n        solve(students , mentors , vis , index , res , score);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findCompScore(vector<vector<int>>& students, vector<vector<int>>& mentors , int student , int mentor){\\n        int sum = 0;\\n        for (int i=0 ; i<students[0].size() ; i++){\\n            if (students[student][i] == mentors[mentor][i])\\n                sum++;\\n        }\\n        return sum;\\n    }\\n\\n    void solve(vector<vector<int>>& students, vector<vector<int>>& mentors , vector<int>& vis, int student , int& res , int score){\\n        if (student >= students.size()){\\n            res = max(res , score);\\n            return;\\n        }\\n\\n        for (int i=0 ; i<students.size() ; i++){\\n            if (vis[i] == 0){\\n                vis[i] = 1;\\n                int compatibility = findCompScore(students , mentors , student , i);\\n                solve(students , mentors , vis , student+1 , res , score + compatibility);\\n                vis[i] = 0;\\n            }\\n        }\\n    }\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<int> vis(mentors.size(),0);\\n        int index = 0;\\n        int res = 0;\\n        int score = 0;\\n        solve(students , mentors , vis , index , res , score);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940305,
                "title": "basic-recursion-and-memorization-using-map-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(m*n*log(m*n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> visitedMentors;\\n    unordered_map<string,int> mp;\\n    int compatibilityScore(vector<vector<int>>& students,vector<vector<int>>& mentors,int i,int j){\\n        int count=0;\\n        for(int k=0;k<students[i].size();k++){\\n            if(students[i][k]==mentors[j][k]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    int maxCompatibilitySumHelper(int i,vector<vector<int>>& students,vector<vector<int>>& mentors){\\n        if(i>=students.size()){\\n            return 0;\\n        }\\n        string key=to_string(i);\\n        for(int k=0;k<visitedMentors.size();k++){\\n            key+=to_string(visitedMentors[k]);\\n        }\\n        if(mp.find(key)!=mp.end()){\\n            return mp[key];\\n        }\\n        int maxCompatibility=0;\\n        for(int j=0;j<mentors.size();j++){\\n            if(!visitedMentors[j]){\\n                int score=compatibilityScore(students,mentors,i,j);\\n                visitedMentors[j]=1;\\n                int compatibility=score+maxCompatibilitySumHelper(i+1,students,mentors);\\n                maxCompatibility=max(maxCompatibility,compatibility);\\n                visitedMentors[j]=0;\\n            }\\n        }\\n        return mp[key]=maxCompatibility;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=students.size();\\n        visitedMentors=vector<bool> (n,0);\\n        return maxCompatibilitySumHelper(0,students,mentors);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> visitedMentors;\\n    unordered_map<string,int> mp;\\n    int compatibilityScore(vector<vector<int>>& students,vector<vector<int>>& mentors,int i,int j){\\n        int count=0;\\n        for(int k=0;k<students[i].size();k++){\\n            if(students[i][k]==mentors[j][k]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    int maxCompatibilitySumHelper(int i,vector<vector<int>>& students,vector<vector<int>>& mentors){\\n        if(i>=students.size()){\\n            return 0;\\n        }\\n        string key=to_string(i);\\n        for(int k=0;k<visitedMentors.size();k++){\\n            key+=to_string(visitedMentors[k]);\\n        }\\n        if(mp.find(key)!=mp.end()){\\n            return mp[key];\\n        }\\n        int maxCompatibility=0;\\n        for(int j=0;j<mentors.size();j++){\\n            if(!visitedMentors[j]){\\n                int score=compatibilityScore(students,mentors,i,j);\\n                visitedMentors[j]=1;\\n                int compatibility=score+maxCompatibilitySumHelper(i+1,students,mentors);\\n                maxCompatibility=max(maxCompatibility,compatibility);\\n                visitedMentors[j]=0;\\n            }\\n        }\\n        return mp[key]=maxCompatibility;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=students.size();\\n        visitedMentors=vector<bool> (n,0);\\n        return maxCompatibilitySumHelper(0,students,mentors);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861854,
                "title": "matching-problem",
                "content": "# Intuition\\n\\nThe problem is equivalent to find an assignment of students to teachers that maximizes the compatibility scores.\\n\\nSince the input is small (upto 8 students and mentors) even the brute force method gives an acceptable running time (~450 ms) in python. \\n\\nBetter algorithm exists, e.g. in scipy optimize there is a linear_sum_assignment function which has time complexity below $$O(n^4)$$. Suprisingly it gives ~200 ms runtime. Probably due to library loading and converting list to numpy array, but it is only a guess.\\n\\nEven more suprisingly my not optimized implementation of the algorithm gives ~40ms run time and beats 100% of Python solutions at the time of writing.\\n\\nThe code is modified from the Wiki page of the hungarian algorithm, which I think contains a bug.\\n \\n\\n\\n# Complexity\\n- Time complexity: $$O(m^4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m^2)$$ due to the computation of the cost matrix, all other space requierements are linear in $m$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# from scipy.optimize import linear_sum_assignment\\n\\ndef min_matching(cost):\\n    m, n = len(cost), len(cost[0])\\n    assert m <= n\\n    worker2job = [-1]*(n+1)\\n    job_pot = [0]*m\\n    worker_pot = [0]*(n+1)\\n    answer = []\\n    inf = int(10**9)\\n    dummy_worker = n\\n\\n    for curr_job in range(m):\\n        curr_workers = [dummy_worker]\\n        worker2job[dummy_worker] = curr_job\\n\\n        prev = [-1]*(n+1)\\n        in_Z = [False]*(n+1)\\n\\n        while curr_workers and all(worker2job[worker] != -1 for worker in curr_workers):\\n            for worker in curr_workers:\\n                in_Z[worker] = True\\n\\n            delta = inf\\n            min_reduced_cost = [inf] * (n + 1)\\n            for curr_worker in range(n+1):\\n                if not in_Z[curr_worker]:\\n                    continue\\n                job = worker2job[curr_worker]\\n                for worker in range(n):\\n                    if not in_Z[worker]:\\n                        reduced_cost = cost[job][worker]-job_pot[job]-worker_pot[worker]\\n                        if reduced_cost < min_reduced_cost[worker]:\\n                            min_reduced_cost[worker] = reduced_cost\\n                            prev[worker] = curr_worker\\n                        if reduced_cost < delta:\\n                            delta = reduced_cost\\n\\n            curr_workers.clear()\\n            for worker in range(n+1):\\n                if in_Z[worker]:\\n                    job_pot[worker2job[worker]] += delta\\n                    worker_pot[worker] -= delta\\n                else:\\n                    min_reduced_cost[worker] -= delta\\n                    if min_reduced_cost[worker] == 0:\\n                        curr_workers.append(worker)\\n        # print(f\"{curr_workers=},\\\\n{worker2job=},\\\\n{prev=},\\\\n{in_Z=},\\\\n{min_reduced_cost=},\\\\n{delta=}\")\\n        curr_workers = [worker for worker in curr_workers if worker2job[worker] == -1]\\n        # print(f\"filtered {curr_workers=}\")\\n        curr_worker = curr_workers[0]\\n\\n        while curr_worker != -1:\\n            worker2job[curr_worker] = worker2job[prev[curr_worker]]\\n            curr_worker = prev[curr_worker]\\n        answer.append(-worker_pot[n])\\n    # print(f\"{worker2job=}\")\\n    return answer\\n\\n\\n\\nclass Solution:\\n    \\n    def maxCompatibilitySumSlow(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n        scores = [[sum(xi==yi for xi, yi in zip(mentor, student)) for mentor in mentors] for student in students]\\n        return max(sum(scores[i][j] for i, j in enumerate(p)) for p in itertools.permutations(range(m)))\\n\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n        scores = [[sum(xi != yi for xi, yi in zip(mentor, student)) for mentor in mentors] for student in students]\\n        value = min_matching(scores)\\n        return m*n - value[-1]\\n\\n    # def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n    #     scores = [[sum(xi == yi for xi, yi in zip(mentor, student)) for mentor in mentors] for student in students]\\n    #     return sum(scores[i][j] for i, j in zip(*linear_sum_assignment(scores, maximize=True))) \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# from scipy.optimize import linear_sum_assignment\\n\\ndef min_matching(cost):\\n    m, n = len(cost), len(cost[0])\\n    assert m <= n\\n    worker2job = [-1]*(n+1)\\n    job_pot = [0]*m\\n    worker_pot = [0]*(n+1)\\n    answer = []\\n    inf = int(10**9)\\n    dummy_worker = n\\n\\n    for curr_job in range(m):\\n        curr_workers = [dummy_worker]\\n        worker2job[dummy_worker] = curr_job\\n\\n        prev = [-1]*(n+1)\\n        in_Z = [False]*(n+1)\\n\\n        while curr_workers and all(worker2job[worker] != -1 for worker in curr_workers):\\n            for worker in curr_workers:\\n                in_Z[worker] = True\\n\\n            delta = inf\\n            min_reduced_cost = [inf] * (n + 1)\\n            for curr_worker in range(n+1):\\n                if not in_Z[curr_worker]:\\n                    continue\\n                job = worker2job[curr_worker]\\n                for worker in range(n):\\n                    if not in_Z[worker]:\\n                        reduced_cost = cost[job][worker]-job_pot[job]-worker_pot[worker]\\n                        if reduced_cost < min_reduced_cost[worker]:\\n                            min_reduced_cost[worker] = reduced_cost\\n                            prev[worker] = curr_worker\\n                        if reduced_cost < delta:\\n                            delta = reduced_cost\\n\\n            curr_workers.clear()\\n            for worker in range(n+1):\\n                if in_Z[worker]:\\n                    job_pot[worker2job[worker]] += delta\\n                    worker_pot[worker] -= delta\\n                else:\\n                    min_reduced_cost[worker] -= delta\\n                    if min_reduced_cost[worker] == 0:\\n                        curr_workers.append(worker)\\n        # print(f\"{curr_workers=},\\\\n{worker2job=},\\\\n{prev=},\\\\n{in_Z=},\\\\n{min_reduced_cost=},\\\\n{delta=}\")\\n        curr_workers = [worker for worker in curr_workers if worker2job[worker] == -1]\\n        # print(f\"filtered {curr_workers=}\")\\n        curr_worker = curr_workers[0]\\n\\n        while curr_worker != -1:\\n            worker2job[curr_worker] = worker2job[prev[curr_worker]]\\n            curr_worker = prev[curr_worker]\\n        answer.append(-worker_pot[n])\\n    # print(f\"{worker2job=}\")\\n    return answer\\n\\n\\n\\nclass Solution:\\n    \\n    def maxCompatibilitySumSlow(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n        scores = [[sum(xi==yi for xi, yi in zip(mentor, student)) for mentor in mentors] for student in students]\\n        return max(sum(scores[i][j] for i, j in enumerate(p)) for p in itertools.permutations(range(m)))\\n\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n        scores = [[sum(xi != yi for xi, yi in zip(mentor, student)) for mentor in mentors] for student in students]\\n        value = min_matching(scores)\\n        return m*n - value[-1]\\n\\n    # def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n    #     scores = [[sum(xi == yi for xi, yi in zip(mentor, student)) for mentor in mentors] for student in students]\\n    #     return sum(scores[i][j] for i, j in zip(*linear_sum_assignment(scores, maximize=True))) \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857851,
                "title": "dp-bitmasking-no-recursion-tc-o-2-n-n-2",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& stu, vector<vector<int>>& men) {\\n        int n = stu.size();\\n        int m = stu[0].size();\\n        int dp[1 << (2 * n)];\\n        memset(dp, 0, sizeof(dp));\\n        int res = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int m1 = 1 << i;\\n            for(int j = 0; j < n; j++)\\n            {\\n                int m2 = 1 << j;\\n                int cnt = 0;\\n                for(int k = 0; k < m; k++)cnt += (stu[i][k] == men[j][k]);\\n                int mask = (m1 << n) | (m2);\\n                dp[mask] = max(dp[mask], cnt);\\n                res = max(dp[mask], res);\\n            }\\n        }\\n        for(int i = (1 << n) + 1; i < (1 << (2 * n)); i++)\\n        {\\n            if(__builtin_popcount(i) & 1)continue;\\n            for(int j = 0; j < n; j++)\\n            {\\n                for(int k = 0; k < n; k++)\\n                {\\n                    int m = 1 << (j + n) | (1 << k);\\n                    if(i & m)continue;\\n                    dp[i | m] = max(dp[i | m], dp[i] + dp[m]);\\n                    res = max(res, dp[i | m]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& stu, vector<vector<int>>& men) {\\n        int n = stu.size();\\n        int m = stu[0].size();\\n        int dp[1 << (2 * n)];\\n        memset(dp, 0, sizeof(dp));\\n        int res = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int m1 = 1 << i;\\n            for(int j = 0; j < n; j++)\\n            {\\n                int m2 = 1 << j;\\n                int cnt = 0;\\n                for(int k = 0; k < m; k++)cnt += (stu[i][k] == men[j][k]);\\n                int mask = (m1 << n) | (m2);\\n                dp[mask] = max(dp[mask], cnt);\\n                res = max(dp[mask], res);\\n            }\\n        }\\n        for(int i = (1 << n) + 1; i < (1 << (2 * n)); i++)\\n        {\\n            if(__builtin_popcount(i) & 1)continue;\\n            for(int j = 0; j < n; j++)\\n            {\\n                for(int k = 0; k < n; k++)\\n                {\\n                    int m = 1 << (j + n) | (1 << k);\\n                    if(i & m)continue;\\n                    dp[i | m] = max(dp[i | m], dp[i] + dp[m]);\\n                    res = max(res, dp[i | m]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852050,
                "title": "easy-to-understand-4ms-solution-with-neat-comments",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int getCurScore(vector<int> &student, vector<int> &mentor) {\\n        int score = 0;\\n        for (int i = 0; i < student.size(); i++) {\\n            score += student[i] == mentor[i];\\n        }\\n        return score;\\n    }\\n    int assign(int student, int mask, vector<vector<int>>& students, vector<vector<int>>& mentors, vector<int> &dp) {\\n        // If all the students are assigned to each mentor we can\\'t get further score\\n        if (student == students.size()) {\\n            return 0;\\n        }\\n        if (dp[mask] != -1) return dp[mask];\\n        \\n        int res = 0;\\n        // Try on all mentors to the current student and find optimal mentor.\\n        for (int mentor = 0; mentor < mentors.size(); mentor++) {\\n            // If we want to assign this mentor to current student if that bit is 0 and calculate cur score and call for next student.\\n            if (((1 << mentor) & mask) == 0) {\\n                int score = getCurScore(students[student], mentors[mentor]);\\n                res = max(res, score + assign(student + 1, mask | (1 << mentor), students, mentors, dp));\\n            }\\n        }\\n        return dp[mask] = res;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        // mask is to track which mentors are assigned till now and which are not since we can only assign mentor to only one student. (1 means assigned)\\n        int m = students.size();\\n\\n        // of size 2^m since at the end we will assign all mentors so all m bits will set to 1.\\n        vector<int> dp(1 << m, -1);\\n        return assign(0, 0, students, mentors, dp); // [student, mask, [], []]\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getCurScore(vector<int> &student, vector<int> &mentor) {\\n        int score = 0;\\n        for (int i = 0; i < student.size(); i++) {\\n            score += student[i] == mentor[i];\\n        }\\n        return score;\\n    }\\n    int assign(int student, int mask, vector<vector<int>>& students, vector<vector<int>>& mentors, vector<int> &dp) {\\n        // If all the students are assigned to each mentor we can\\'t get further score\\n        if (student == students.size()) {\\n            return 0;\\n        }\\n        if (dp[mask] != -1) return dp[mask];\\n        \\n        int res = 0;\\n        // Try on all mentors to the current student and find optimal mentor.\\n        for (int mentor = 0; mentor < mentors.size(); mentor++) {\\n            // If we want to assign this mentor to current student if that bit is 0 and calculate cur score and call for next student.\\n            if (((1 << mentor) & mask) == 0) {\\n                int score = getCurScore(students[student], mentors[mentor]);\\n                res = max(res, score + assign(student + 1, mask | (1 << mentor), students, mentors, dp));\\n            }\\n        }\\n        return dp[mask] = res;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        // mask is to track which mentors are assigned till now and which are not since we can only assign mentor to only one student. (1 means assigned)\\n        int m = students.size();\\n\\n        // of size 2^m since at the end we will assign all mentors so all m bits will set to 1.\\n        vector<int> dp(1 << m, -1);\\n        return assign(0, 0, students, mentors, dp); // [student, mask, [], []]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810671,
                "title": "c-implementation-using-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int i,vector<vector<int>>& students, vector<vector<int>>& mentors,set<int> &st,set<int> &st2){\\n        if(i==students.size())\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int k=0;k<mentors.size();k++){\\n            if(st.find(k)==st.end()){\\n                st.insert(k);\\n                int cmp=0;\\n                for(int l=0;l<mentors[k].size();l++){\\n                    cmp+=(mentors[k][l]==students[i][l]);\\n                }\\n                ans=max(ans,cmp+f(i+1,students,mentors,st,st2));\\n                st.erase(k);\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int ans=0;\\n        set<int>st;\\n        set<int>st2;\\n            ans=max(ans,f(0,students,mentors,st,st2));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int i,vector<vector<int>>& students, vector<vector<int>>& mentors,set<int> &st,set<int> &st2){\\n        if(i==students.size())\\n        {\\n            return 0;\\n        }\\n        int ans=0;\\n        for(int k=0;k<mentors.size();k++){\\n            if(st.find(k)==st.end()){\\n                st.insert(k);\\n                int cmp=0;\\n                for(int l=0;l<mentors[k].size();l++){\\n                    cmp+=(mentors[k][l]==students[i][l]);\\n                }\\n                ans=max(ans,cmp+f(i+1,students,mentors,st,st2));\\n                st.erase(k);\\n            }\\n        }\\n        return ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int ans=0;\\n        set<int>st;\\n        set<int>st2;\\n            ans=max(ans,f(0,students,mentors,st,st2));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808306,
                "title": "recursion-all-permutations-c-easy-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void backtracking(int compatibility,int index,int m,int n,vector<vector<int>>&students,vector<vector<int>>&mentors,vector<bool>&bitmask){\\n        if(index<0){\\n            ans = max(ans,compatibility);\\n            return;\\n        }\\n        for(int i=0;i<m;i++){\\n            if(bitmask[i]) continue;\\n            bitmask[i] = true;\\n            int score = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(students[index][j]==mentors[i][j]) score++;\\n            }\\n            backtracking(compatibility+score,index-1,m,n,students,mentors,bitmask);\\n            bitmask[i] = false;\\n        }\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size(); // no of students and mentors\\n        int n = students[0].size(); // subjects\\n        this->ans = 0;\\n        vector<bool>bitmask(m,false);\\n        backtracking(0,m-1,m,n,students,mentors,bitmask);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void backtracking(int compatibility,int index,int m,int n,vector<vector<int>>&students,vector<vector<int>>&mentors,vector<bool>&bitmask){\\n        if(index<0){\\n            ans = max(ans,compatibility);\\n            return;\\n        }\\n        for(int i=0;i<m;i++){\\n            if(bitmask[i]) continue;\\n            bitmask[i] = true;\\n            int score = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(students[index][j]==mentors[i][j]) score++;\\n            }\\n            backtracking(compatibility+score,index-1,m,n,students,mentors,bitmask);\\n            bitmask[i] = false;\\n        }\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size(); // no of students and mentors\\n        int n = students[0].size(); // subjects\\n        this->ans = 0;\\n        vector<bool>bitmask(m,false);\\n        backtracking(0,m-1,m,n,students,mentors,bitmask);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748475,
                "title": "easy-detailed-explanation-c-backtracking",
                "content": "# Intuition\\nfor every student we will try all possibiites and all possibilites means factorial n which boils down our thinking to use bitmask and backtracking \\n\\n# Approach\\nnow we will make a bitmask which will tell me the available mentors currently and we will make a solve function to take the maximum values of all \\nin solve function we need a index which will tell me the current student for which i am alloting the mentor and using bitmask i wll check which mentors are available and add there score to the count using the comp function and call the function for the further indexes \\nand once all mentors are alloted or all students are exhausted we reach the base case and return \\n\\n# Complexity\\n- Time complexity:\\nO(n*n!)\\n\\n- Space complexity:\\nO(n) due to the recursive stack space and the bitmask.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int comp(vector<int> &v1, vector<int> &v2){\\n        int ans=0;\\n        for(int i=0; i<v1.size(); i++){\\n            if(v1[i]==v2[i]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    void solve(int index,vector<vector<int>>& students, vector<vector<int>>& mentors,int bitmask,int count,int & ans){\\n         int n=mentors.size();\\n         if(bitmask==0 || index==n){\\n             ans=max(ans,count);\\n             return;\\n         }\\n         for(int j=0; j<n; j++){\\n          if(bitmask & (1<<j)){\\n          int temp=comp(students[index],mentors[j]);\\n          solve(index+1,students,mentors,bitmask^(1<<j),count+temp,ans);\\n           }\\n          }\\n    }\\n  \\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=mentors.size();\\n        int bitmask=(1<<n)-1;\\n        int ans=0;\\n        int count=0;\\n        solve(0,students,mentors,bitmask,count,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int comp(vector<int> &v1, vector<int> &v2){\\n        int ans=0;\\n        for(int i=0; i<v1.size(); i++){\\n            if(v1[i]==v2[i]){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n\\n    void solve(int index,vector<vector<int>>& students, vector<vector<int>>& mentors,int bitmask,int count,int & ans){\\n         int n=mentors.size();\\n         if(bitmask==0 || index==n){\\n             ans=max(ans,count);\\n             return;\\n         }\\n         for(int j=0; j<n; j++){\\n          if(bitmask & (1<<j)){\\n          int temp=comp(students[index],mentors[j]);\\n          solve(index+1,students,mentors,bitmask^(1<<j),count+temp,ans);\\n           }\\n          }\\n    }\\n  \\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=mentors.size();\\n        int bitmask=(1<<n)-1;\\n        int ans=0;\\n        int count=0;\\n        solve(0,students,mentors,bitmask,count,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712413,
                "title": "backtracing-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\nint findCompatibility(vector<vector<int>>& mentors,vector<vector<int>>& students,int i,int j){\\n    int ct=0;\\n       for(int x=0;x<students[i].size();x++){\\n           if(students[i][x]==mentors[j][x]) ct++;\\n       }\\nreturn ct;\\n\\n}\\nvoid solve(int ind,int score,vector<vector<int>>& students, vector<vector<int>>& mentors,   vector<int>&visitedMentor){\\n//Base case\\nif(ind==students.size()){\\nans=max(ans,score);\\n}\\n  int comp=0;\\nfor(int j=0;j<mentors.size();j++){\\n    if(visitedMentor[j]==0){\\n        visitedMentor[j]=1;\\n        comp=findCompatibility(mentors,students,ind,j);\\n        solve(ind+1,score+comp,students,mentors,visitedMentor);\\n        visitedMentor[j]=0;\\n    }\\n}\\n\\n\\n\\n}\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<int>visitedMentor(mentors.size(),0);\\n      solve(0,0,students,mentors,visitedMentor);\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\nint findCompatibility(vector<vector<int>>& mentors,vector<vector<int>>& students,int i,int j){\\n    int ct=0;\\n       for(int x=0;x<students[i].size();x++){\\n           if(students[i][x]==mentors[j][x]) ct++;\\n       }\\nreturn ct;\\n\\n}\\nvoid solve(int ind,int score,vector<vector<int>>& students, vector<vector<int>>& mentors,   vector<int>&visitedMentor){\\n//Base case\\nif(ind==students.size()){\\nans=max(ans,score);\\n}\\n  int comp=0;\\nfor(int j=0;j<mentors.size();j++){\\n    if(visitedMentor[j]==0){\\n        visitedMentor[j]=1;\\n        comp=findCompatibility(mentors,students,ind,j);\\n        solve(ind+1,score+comp,students,mentors,visitedMentor);\\n        visitedMentor[j]=0;\\n    }\\n}\\n\\n\\n\\n}\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<int>visitedMentor(mentors.size(),0);\\n      solve(0,0,students,mentors,visitedMentor);\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676964,
                "title": "dp-bitmask-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[8][1<<8];\\npublic:\\n    int solve(int i, int mask, int &m, vector<vector<int>> &scores){\\n        if(i==m) return 0;\\n\\n        if(dp[i][mask] != -1) return dp[i][mask];\\n\\n        dp[i][mask]=0;\\n        for(int j=0; j<m; j++){\\n            if( mask & (1<<j)){\\n                dp[i][mask] = max( dp[i][mask], scores[i][j] + solve(i+1, mask^(1<<j), m, scores));\\n            }\\n        }\\n       return dp[i][mask];\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        int n = students[0].size();\\n        vector<vector<int>> scores(m, vector<int>(m));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<m; j++){\\n                scores[i][j]=0;\\n              for(int k=0; k<n; k++){\\n                  scores[i][j] += students[i][k] == mentors[j][k];\\n              }\\n            }\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, (1<<m)-1, m, scores);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[8][1<<8];\\npublic:\\n    int solve(int i, int mask, int &m, vector<vector<int>> &scores){\\n        if(i==m) return 0;\\n\\n        if(dp[i][mask] != -1) return dp[i][mask];\\n\\n        dp[i][mask]=0;\\n        for(int j=0; j<m; j++){\\n            if( mask & (1<<j)){\\n                dp[i][mask] = max( dp[i][mask], scores[i][j] + solve(i+1, mask^(1<<j), m, scores));\\n            }\\n        }\\n       return dp[i][mask];\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        int n = students[0].size();\\n        vector<vector<int>> scores(m, vector<int>(m));\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<m; j++){\\n                scores[i][j]=0;\\n              for(int k=0; k<n; k++){\\n                  scores[i][j] += students[i][k] == mentors[j][k];\\n              }\\n            }\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, (1<<m)-1, m, scores);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654986,
                "title": "bit-masking-dp",
                "content": "\\n```\\n\\n\\nint comp(vector<int>students,vector<int>mentors)\\n{\\n    int n = students.size();\\n    int count = 0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(students[i] == mentors[i])\\n        count++;\\n    }\\n    return count;\\n}\\n\\n\\nint f(int i,vector<vector<int>>&students,vector<vector<int>>&mentors,int mask,vector<int>&dp)\\n{\\n    if(mask == 0)\\n    return 0;\\n    if(dp[mask] != -1)\\n    return dp[mask];\\n    int res = -1e9;\\n    for(int j=0;j<mentors.size();j++)\\n    {\\n        if(mask & (1<<j))\\n        {\\n            mask = mask ^ (1 << j);\\n            res = max(res,f(i+1,students,mentors,mask,dp) + comp(students[i],mentors[j]));\\n            mask = mask ^ (1 << j);\\n        }\\n    }\\n    return dp[mask] = res;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        int n = students[0].size();\\n        int mask = (1 << m) - 1;\\n        vector<int>dp(mask+1,-1);\\n        return f(0,students,mentors,mask,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nint comp(vector<int>students,vector<int>mentors)\\n{\\n    int n = students.size();\\n    int count = 0;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(students[i] == mentors[i])\\n        count++;\\n    }\\n    return count;\\n}\\n\\n\\nint f(int i,vector<vector<int>>&students,vector<vector<int>>&mentors,int mask,vector<int>&dp)\\n{\\n    if(mask == 0)\\n    return 0;\\n    if(dp[mask] != -1)\\n    return dp[mask];\\n    int res = -1e9;\\n    for(int j=0;j<mentors.size();j++)\\n    {\\n        if(mask & (1<<j))\\n        {\\n            mask = mask ^ (1 << j);\\n            res = max(res,f(i+1,students,mentors,mask,dp) + comp(students[i],mentors[j]));\\n            mask = mask ^ (1 << j);\\n        }\\n    }\\n    return dp[mask] = res;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size();\\n        int n = students[0].size();\\n        int mask = (1 << m) - 1;\\n        vector<int>dp(mask+1,-1);\\n        return f(0,students,mentors,mask,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624375,
                "title": "intuitive-and-simple-dp-with-bitmasking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the constraints are small and we have to go through every combination to find the maximum sum of compatibility score we go recursively to check all combinations. But there is one problem how to we store the state of every student and mentor array. To do that we use bitmask for each array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[1<<8][1<<8];\\n    int compatibility(vector<int>& a, vector<int>& b) {\\n        int c = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            if (a[i] == b[i]) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n    int f(int ind, vector<vector<int>>& s, vector<vector<int>>& m, int masks, int maskm) {\\n        if (ind >= s.size()) {\\n            return 0;\\n        }\\n        if (dp[masks][maskm] != -1) {\\n            return dp[masks][maskm];\\n        }\\n        int res = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (((1<<i)&masks) == 0) {\\n                masks |= (1<<i);\\n                for (int j = 0; j < m.size(); j++) {\\n                    if (((1<<j)&maskm) == 0) {\\n                        maskm |= (1<<j);\\n                        int t = compatibility(s[i], m[j]);\\n                        t += f(ind+1, s, m, masks, maskm);\\n                        res = max(res, t);\\n                        maskm ^= (1<<j);\\n                    }\\n                }\\n                masks ^= (1<<i);\\n            }\\n        }\\n        return dp[masks][maskm] = res;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        memset(dp, -1, sizeof(dp));\\n        return f(0, students, mentors, 0, 0);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1<<8][1<<8];\\n    int compatibility(vector<int>& a, vector<int>& b) {\\n        int c = 0;\\n        for (int i = 0; i < a.size(); i++) {\\n            if (a[i] == b[i]) {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n    int f(int ind, vector<vector<int>>& s, vector<vector<int>>& m, int masks, int maskm) {\\n        if (ind >= s.size()) {\\n            return 0;\\n        }\\n        if (dp[masks][maskm] != -1) {\\n            return dp[masks][maskm];\\n        }\\n        int res = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if (((1<<i)&masks) == 0) {\\n                masks |= (1<<i);\\n                for (int j = 0; j < m.size(); j++) {\\n                    if (((1<<j)&maskm) == 0) {\\n                        maskm |= (1<<j);\\n                        int t = compatibility(s[i], m[j]);\\n                        t += f(ind+1, s, m, masks, maskm);\\n                        res = max(res, t);\\n                        maskm ^= (1<<j);\\n                    }\\n                }\\n                masks ^= (1<<i);\\n            }\\n        }\\n        return dp[masks][maskm] = res;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        memset(dp, -1, sizeof(dp));\\n        return f(0, students, mentors, 0, 0);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621088,
                "title": "easy-java-2-solution-backtracking-dp",
                "content": "# Backtracking Code \\n```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        boolean[] taken=new boolean[mentors.length];\\n        return helper(0,students,mentors,taken);\\n    }\\n    public int helper(int i, int[][] students, int[][] mentors, boolean[] taken){\\n        if(i>=students.length) return 0;\\n        int[] currstudent=students[i];\\n        int max=0;\\n        for(int j=0;j<mentors.length;j++){\\n            if(taken[j]) continue;\\n            taken[j]=true;\\n\\n            int[] currmentor=mentors[j];\\n            int currcomp=compare(currstudent,currmentor);\\n            max=Math.max(max,currcomp+helper(i+1,students,mentors,taken));\\n            taken[j]=false;\\n            \\n        }\\n        return max;\\n    }\\n    public int compare(int[] student, int[] mentor){\\n        int count=0;\\n        for(int i=0;i<student.length;i++){\\n            if(student[i]==mentor[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Dp Code\\n```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        return helper(0, students, mentors, new HashSet<>(), new HashMap<>());\\n    }\\n    \\n    public int helper(int idx, int[][] students, int[][] mentors, Set<Integer> set, Map<Pair<Integer, String>, Integer> dp){\\n        if(idx==students.length){\\n            return 0;\\n        }\\n        \\n        Pair<Integer, String> key = new Pair<>(idx, set.toString());\\n        if(dp.containsKey(key)) return dp.get(key);\\n        \\n        int ans = 0;\\n        for(int i=0; i<mentors.length; i++){\\n            if(set.contains(i)) continue;\\n            \\n            int[] mentor = mentors[i];\\n            int[] student = students[idx];\\n            set.add(i);\\n            ans = Math.max(ans, compatibility(mentor, student) + helper(idx+1, students, mentors, set, dp));\\n            set.remove(i);\\n        }\\n        \\n        dp.put(key, ans);\\n        return ans;\\n    }\\n    \\n    public int compatibility(int[] arr1, int[] arr2){\\n        int n = arr1.length;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(arr1[i] == arr2[i]) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        boolean[] taken=new boolean[mentors.length];\\n        return helper(0,students,mentors,taken);\\n    }\\n    public int helper(int i, int[][] students, int[][] mentors, boolean[] taken){\\n        if(i>=students.length) return 0;\\n        int[] currstudent=students[i];\\n        int max=0;\\n        for(int j=0;j<mentors.length;j++){\\n            if(taken[j]) continue;\\n            taken[j]=true;\\n\\n            int[] currmentor=mentors[j];\\n            int currcomp=compare(currstudent,currmentor);\\n            max=Math.max(max,currcomp+helper(i+1,students,mentors,taken));\\n            taken[j]=false;\\n            \\n        }\\n        return max;\\n    }\\n    public int compare(int[] student, int[] mentor){\\n        int count=0;\\n        for(int i=0;i<student.length;i++){\\n            if(student[i]==mentor[i]) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        return helper(0, students, mentors, new HashSet<>(), new HashMap<>());\\n    }\\n    \\n    public int helper(int idx, int[][] students, int[][] mentors, Set<Integer> set, Map<Pair<Integer, String>, Integer> dp){\\n        if(idx==students.length){\\n            return 0;\\n        }\\n        \\n        Pair<Integer, String> key = new Pair<>(idx, set.toString());\\n        if(dp.containsKey(key)) return dp.get(key);\\n        \\n        int ans = 0;\\n        for(int i=0; i<mentors.length; i++){\\n            if(set.contains(i)) continue;\\n            \\n            int[] mentor = mentors[i];\\n            int[] student = students[idx];\\n            set.add(i);\\n            ans = Math.max(ans, compatibility(mentor, student) + helper(idx+1, students, mentors, set, dp));\\n            set.remove(i);\\n        }\\n        \\n        dp.put(key, ans);\\n        return ans;\\n    }\\n    \\n    public int compatibility(int[] arr1, int[] arr2){\\n        int n = arr1.length;\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(arr1[i] == arr2[i]) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605646,
                "title": "dp-with-bitmask-java-solution",
                "content": "# Intuition\\nDP with bitmasking\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        int m = students.length;\\n        int n = students[0].length;\\n        int[][] dp = new int[1 << 9][1 << 9];\\n        for(int[] d:dp) Arrays.fill(d,-1);\\n        return helper(students,mentors,0,0,dp,m,n);\\n    }\\n    private int helper(int[][] students, int[][] mentors,int mask1,int mask2,int[][] dp,int m,int n){\\n        if(dp[mask1][mask2] != -1) return dp[mask1][mask2];\\n        int score = 0;\\n        for(int i=0;i<m;i++){\\n            int count = 0;\\n            if((mask1 & (1 << i)) == 0){\\n                for(int j=0;j<m;j++){\\n                    if((mask2 & (1 << j)) == 0){\\n                        int newmask1 = mask1 | (1 << i);\\n                        int newmask2 = mask2 | (1 << j);\\n                        int cnt = 0;\\n                        for(int k=0;k<n;k++){\\n                            if(students[i][k] == mentors[j][k]) cnt++;\\n                            count = Math.max(count,cnt + helper(students,mentors,newmask1,newmask2,dp,m,n));\\n                        }\\n                    }\\n                }\\n                score = Math.max(score,count);\\n            }\\n        }\\n        return dp[mask1][mask2] = score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        int m = students.length;\\n        int n = students[0].length;\\n        int[][] dp = new int[1 << 9][1 << 9];\\n        for(int[] d:dp) Arrays.fill(d,-1);\\n        return helper(students,mentors,0,0,dp,m,n);\\n    }\\n    private int helper(int[][] students, int[][] mentors,int mask1,int mask2,int[][] dp,int m,int n){\\n        if(dp[mask1][mask2] != -1) return dp[mask1][mask2];\\n        int score = 0;\\n        for(int i=0;i<m;i++){\\n            int count = 0;\\n            if((mask1 & (1 << i)) == 0){\\n                for(int j=0;j<m;j++){\\n                    if((mask2 & (1 << j)) == 0){\\n                        int newmask1 = mask1 | (1 << i);\\n                        int newmask2 = mask2 | (1 << j);\\n                        int cnt = 0;\\n                        for(int k=0;k<n;k++){\\n                            if(students[i][k] == mentors[j][k]) cnt++;\\n                            count = Math.max(count,cnt + helper(students,mentors,newmask1,newmask2,dp,m,n));\\n                        }\\n                    }\\n                }\\n                score = Math.max(score,count);\\n            }\\n        }\\n        return dp[mask1][mask2] = score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584805,
                "title": "simple-backtracking-solution-in-c-commented-code",
                "content": "# Intuition\\nTry to make all possible score for each and every student - mentor pair. Store them in a grid, solve on pen and paper, you will find out the intuition yourself. After formation of grid, the problem reduces to Find Maximum Path sum in a Grid Starting from any Cell in FIRST Row to END AT ANY CELL IN LAST Row. \\nConstraint : you can not visit a clumn twice.\\nSimilar question: [931. Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans =0;\\n    void f(int i, vector<vector<int>>& grid, vector<int>& vis, int n, int sum){\\n        if(i == n){\\n            ans = max(ans, sum);\\n            return;\\n        }\\n        for(int ind = 0; ind < n; ind++){\\n            if(vis[ind] == 0){\\n                sum += grid[i][ind];\\n                vis[ind] = 1;\\n                f(i+1, grid, vis, n, sum);\\n                vis[ind] =0;\\n                sum -= grid[i][ind];\\n            }\\n        }\\n        return;      \\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size(), m = students[0].size();\\n        \\n        vector<vector<int>>grid(n, vector<int>(n));\\n        // CREATE A GRID FOR EVERY STUENT MENOTR PAIR\\n        for(int i =0; i <n ; i++){\\n            for(int j =0; j < n; j++){\\n                int cnt =0;\\n                for(int idx = 0; idx < m; idx++){\\n                    if(students[i][idx] == mentors[j][idx])cnt++;\\n                }\\n                grid[i][j] = cnt;\\n            }\\n        }\\n        // for(int i =0; i <n ; i++){\\n        //     for(int j =0; j < n; j++){\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n\\n\\n        // NOW THE QUESTION REDUCES TO FIND THE MAX GRID SUM CONSIDERING THE CONSTRAINT THAT YOU CAN NOT VISIT A COLUMN TWICE\\n        vector<int>vis(n,0);\\n        f(0, grid, vis, n, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans =0;\\n    void f(int i, vector<vector<int>>& grid, vector<int>& vis, int n, int sum){\\n        if(i == n){\\n            ans = max(ans, sum);\\n            return;\\n        }\\n        for(int ind = 0; ind < n; ind++){\\n            if(vis[ind] == 0){\\n                sum += grid[i][ind];\\n                vis[ind] = 1;\\n                f(i+1, grid, vis, n, sum);\\n                vis[ind] =0;\\n                sum -= grid[i][ind];\\n            }\\n        }\\n        return;      \\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size(), m = students[0].size();\\n        \\n        vector<vector<int>>grid(n, vector<int>(n));\\n        // CREATE A GRID FOR EVERY STUENT MENOTR PAIR\\n        for(int i =0; i <n ; i++){\\n            for(int j =0; j < n; j++){\\n                int cnt =0;\\n                for(int idx = 0; idx < m; idx++){\\n                    if(students[i][idx] == mentors[j][idx])cnt++;\\n                }\\n                grid[i][j] = cnt;\\n            }\\n        }\\n        // for(int i =0; i <n ; i++){\\n        //     for(int j =0; j < n; j++){\\n        //         cout<<grid[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n\\n\\n        // NOW THE QUESTION REDUCES TO FIND THE MAX GRID SUM CONSIDERING THE CONSTRAINT THAT YOU CAN NOT VISIT A COLUMN TWICE\\n        vector<int>vis(n,0);\\n        f(0, grid, vis, n, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3575845,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students, mentors):\\n        m, n = len(students), len(students[0])\\n\\n        def calc_comp_score(nums):\\n            total = 0\\n\\n            for i in range(m):\\n                for j in range(n):\\n                    if students[i][j] == nums[i][j]:\\n                        total += 1\\n\\n            return total\\n\\n        def backtrack(i,path,visited):\\n            if i == m:\\n                self.res = max(self.res,calc_comp_score(path))\\n                return\\n\\n            for j in range(m):\\n                if j not in visited:\\n                    visited.add(j)\\n                    backtrack(i+1,path+[mentors[j]],visited)\\n                    visited.remove(j)\\n\\n        self.res = 0\\n        backtrack(0,[],set())\\n        return self.res\\n\\n\\n\\n\\n        \\n        \\n    \\n    \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students, mentors):\\n        m, n = len(students), len(students[0])\\n\\n        def calc_comp_score(nums):\\n            total = 0\\n\\n            for i in range(m):\\n                for j in range(n):\\n                    if students[i][j] == nums[i][j]:\\n                        total += 1\\n\\n            return total\\n\\n        def backtrack(i,path,visited):\\n            if i == m:\\n                self.res = max(self.res,calc_comp_score(path))\\n                return\\n\\n            for j in range(m):\\n                if j not in visited:\\n                    visited.add(j)\\n                    backtrack(i+1,path+[mentors[j]],visited)\\n                    visited.remove(j)\\n\\n        self.res = 0\\n        backtrack(0,[],set())\\n        return self.res\\n\\n\\n\\n\\n        \\n        \\n    \\n    \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558411,
                "title": "c-easy-solution-recursion-backtracking-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int solve(int i,vector<vector<int>>& st, vector<vector<int>>& mt,vector<int>& visited)\\n    {\\n        if(i>=st.size())   //base condition\\n        {\\n            return 0;\\n        }\\n        int maxi=0;\\n        for(int j=0;j<mt.size();j++)\\n        {\\n            if(!visited[j])  //if mentor is not assigned then we will do operations\\n            {\\n                visited[j]=1;\\n                int match=0;\\n                for(int k=0;k<st[i].size();k++)\\n                {\\n                    if(st[i][k]==mt[j][k])\\n                    {\\n                        match++;\\n                    }\\n                }\\n\\n                int score=match+solve(i+1,st,mt,visited);\\n                maxi=max(maxi,score);\\n                visited[j]=0;   //backtracking\\n                \\n            }\\n        }\\n        return maxi;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& st, vector<vector<int>>& mt) {\\n        int n1=st.size();\\n        int m1=mt.size();\\n        vector<int>visited(m1,0); //repeated mentor can be avoided.\\n        return solve(0,st,mt,visited);\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int solve(int i,vector<vector<int>>& st, vector<vector<int>>& mt,vector<int>& visited)\\n    {\\n        if(i>=st.size())   //base condition\\n        {\\n            return 0;\\n        }\\n        int maxi=0;\\n        for(int j=0;j<mt.size();j++)\\n        {\\n            if(!visited[j])  //if mentor is not assigned then we will do operations\\n            {\\n                visited[j]=1;\\n                int match=0;\\n                for(int k=0;k<st[i].size();k++)\\n                {\\n                    if(st[i][k]==mt[j][k])\\n                    {\\n                        match++;\\n                    }\\n                }\\n\\n                int score=match+solve(i+1,st,mt,visited);\\n                maxi=max(maxi,score);\\n                visited[j]=0;   //backtracking\\n                \\n            }\\n        }\\n        return maxi;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& st, vector<vector<int>>& mt) {\\n        int n1=st.size();\\n        int m1=mt.size();\\n        vector<int>visited(m1,0); //repeated mentor can be avoided.\\n        return solve(0,st,mt,visited);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549454,
                "title": "brute-force-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int finalcompatibility;\\n    int taken[]=new int[8];\\n    int totalstudents,totalquestions;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        this.finalcompatibility=0;\\n        int m = students.length;\\n        int n = students[0].length;\\n        this.totalstudents = m;\\n        this.totalquestions = n;\\n        Arrays.fill(taken,0);\\n        getmaxcomp(students,mentors,0,0);\\n        return this.finalcompatibility;\\n    }\\n\\n    private void getmaxcomp(int[][] students, int[][] mentors,int m ,int comp){\\n        if(m>=this.totalstudents){\\n            this.finalcompatibility = Math.max(comp,this.finalcompatibility);\\n        }\\n\\n        for(int i=0;i<this.totalstudents;i++){\\n            if(taken[i]==0){\\n                taken[i]=1;\\n                int tempcomp = getcomp(students[m],mentors[i]);\\n                getmaxcomp(students,mentors,m+1,comp+tempcomp);\\n                taken[i]=0;\\n            }\\n        }\\n    }\\n\\n    private int getcomp(int students[],int mentors[]){\\n        int count=0;\\n        for(int i=0;i<students.length;i++){\\n            if(students[i]==mentors[i])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int finalcompatibility;\\n    int taken[]=new int[8];\\n    int totalstudents,totalquestions;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        this.finalcompatibility=0;\\n        int m = students.length;\\n        int n = students[0].length;\\n        this.totalstudents = m;\\n        this.totalquestions = n;\\n        Arrays.fill(taken,0);\\n        getmaxcomp(students,mentors,0,0);\\n        return this.finalcompatibility;\\n    }\\n\\n    private void getmaxcomp(int[][] students, int[][] mentors,int m ,int comp){\\n        if(m>=this.totalstudents){\\n            this.finalcompatibility = Math.max(comp,this.finalcompatibility);\\n        }\\n\\n        for(int i=0;i<this.totalstudents;i++){\\n            if(taken[i]==0){\\n                taken[i]=1;\\n                int tempcomp = getcomp(students[m],mentors[i]);\\n                getmaxcomp(students,mentors,m+1,comp+tempcomp);\\n                taken[i]=0;\\n            }\\n        }\\n    }\\n\\n    private int getcomp(int students[],int mentors[]){\\n        int count=0;\\n        for(int i=0;i<students.length;i++){\\n            if(students[i]==mentors[i])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473885,
                "title": "backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        ans=-10**9\\n        def solve(i,s,visited):\\n            nonlocal ans\\n            if i==len(students):\\n                ans=max(ans,s)\\n            for j in range(len(mentors)):\\n                if j not in visited:\\n                    visited.add(j)\\n                    solve(i+1,s+sum(x == y for x, y in zip(students[i], mentors[j])),visited)\\n                    visited.remove(j)\\n        solve(0,0,set())\\n        return ans\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        ans=-10**9\\n        def solve(i,s,visited):\\n            nonlocal ans\\n            if i==len(students):\\n                ans=max(ans,s)\\n            for j in range(len(mentors)):\\n                if j not in visited:\\n                    visited.add(j)\\n                    solve(i+1,s+sum(x == y for x, y in zip(students[i], mentors[j])),visited)\\n                    visited.remove(j)\\n        solve(0,0,set())\\n        return ans\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374257,
                "title": "simple-c-solution-using-next-permutation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int getScore(vector<int>&arr1 , vector<int>&arr2){\\n        int ct = 0;\\n\\n        for(int i=0 ; i<arr1.size() ; i++){\\n            ct += (arr1[i]==arr2[i]);\\n        }\\n\\n        return ct;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n\\n        int maxx = 0;\\n        sort(mentors.begin() , mentors.end());\\n        do{\\n            int score = 0;\\n            for(int i=0 ; i<n ; i++){\\n                score += getScore(students[i] , mentors[i]);\\n            }\\n\\n            maxx = max(maxx , score);\\n        }while(next_permutation(mentors.begin() , mentors.end()));\\n\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getScore(vector<int>&arr1 , vector<int>&arr2){\\n        int ct = 0;\\n\\n        for(int i=0 ; i<arr1.size() ; i++){\\n            ct += (arr1[i]==arr2[i]);\\n        }\\n\\n        return ct;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n\\n        int maxx = 0;\\n        sort(mentors.begin() , mentors.end());\\n        do{\\n            int score = 0;\\n            for(int i=0 ; i<n ; i++){\\n                score += getScore(students[i] , mentors[i]);\\n            }\\n\\n            maxx = max(maxx , score);\\n        }while(next_permutation(mentors.begin() , mentors.end()));\\n\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364738,
                "title": "python-bit-mask-faster-than-99",
                "content": "\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        N,M = len(students),len(students[0])\\n\\t\\t# transform the answers into mask\\n        st_mask, me_mask = [],[]\\n        for i in range(N):\\n            st_temp = me_temp = 0\\n            st,me = students[i],mentors[i]\\n            for j in range(M):\\n                st_temp |= (st[j] << j)\\n                me_temp |= (me[j] << j)\\n            st_mask.append(st_temp)\\n            me_mask.append(me_temp)\\n            \\n        # here we let student choose mentor\\n        full_mask = (1 << M) - 1    # here full_mask means all answers matched\\n        @cache\\n        def dp(idx,mask):\\n            if idx >= N:\\n                return 0\\n            score = 0\\n            for i in range(N):\\n                if (1 << i) & mask == 0:\\n                    score = max(score,dp(idx + 1,mask | (1 << i)) + \\n                                (full_mask & ~(st_mask[idx] ^ me_mask[i])).bit_count())\\n            return score\\n        \\n        return dp(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        N,M = len(students),len(students[0])\\n\\t\\t# transform the answers into mask\\n        st_mask, me_mask = [],[]\\n        for i in range(N):\\n            st_temp = me_temp = 0\\n            st,me = students[i],mentors[i]\\n            for j in range(M):\\n                st_temp |= (st[j] << j)\\n                me_temp |= (me[j] << j)\\n            st_mask.append(st_temp)\\n            me_mask.append(me_temp)\\n            \\n        # here we let student choose mentor\\n        full_mask = (1 << M) - 1    # here full_mask means all answers matched\\n        @cache\\n        def dp(idx,mask):\\n            if idx >= N:\\n                return 0\\n            score = 0\\n            for i in range(N):\\n                if (1 << i) & mask == 0:\\n                    score = max(score,dp(idx + 1,mask | (1 << i)) + \\n                                (full_mask & ~(st_mask[idx] ^ me_mask[i])).bit_count())\\n            return score\\n        \\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362422,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ;\\nclass Solution {\\n    \\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size() ;\\n        int n = students[0].size() ;\\n        const int Target = (1 << m) - 1 ;\\n        vector<vector<int>>unMatch(m, vector<int>(m)) ;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < m; j++){\\n                for(int k = 0; k < n; k++){\\n                    unMatch[i][j] += students[i][k] ^ mentors[j][k] ;\\n                }\\n            }    \\n        }\\n        vector<int>dp(1 << m, -1) ;\\n        priority_queue<PII, vector<PII>, greater<>>pq ;  //{notMatch, state}\\n        pq.push({0, 0}) ;\\n        \\n        while(!pq.empty()){\\n            auto [notMatch, state] = pq.top() ;\\n            pq.pop() ;\\n            if(dp[state] != -1)\\n                continue ;\\n            dp[state] = notMatch ;\\n            if(state == Target)\\n                return m*n - notMatch ;\\n            \\n            int j = __builtin_popcount(state) ;\\n            for(int i = 0; i < m; i++){\\n                if(((state >> i) & 1 ) == 1)\\n                    continue ;\\n                int next = state + (1 << i) ;\\n                if(dp[next] != -1)\\n                    continue ;\\n                pq.push({notMatch + unMatch[i][j], next}) ;\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nusing PII = pair<int, int> ;\\nclass Solution {\\n    \\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int m = students.size() ;\\n        int n = students[0].size() ;\\n        const int Target = (1 << m) - 1 ;\\n        vector<vector<int>>unMatch(m, vector<int>(m)) ;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < m; j++){\\n                for(int k = 0; k < n; k++){\\n                    unMatch[i][j] += students[i][k] ^ mentors[j][k] ;\\n                }\\n            }    \\n        }\\n        vector<int>dp(1 << m, -1) ;\\n        priority_queue<PII, vector<PII>, greater<>>pq ;  //{notMatch, state}\\n        pq.push({0, 0}) ;\\n        \\n        while(!pq.empty()){\\n            auto [notMatch, state] = pq.top() ;\\n            pq.pop() ;\\n            if(dp[state] != -1)\\n                continue ;\\n            dp[state] = notMatch ;\\n            if(state == Target)\\n                return m*n - notMatch ;\\n            \\n            int j = __builtin_popcount(state) ;\\n            for(int i = 0; i < m; i++){\\n                if(((state >> i) & 1 ) == 1)\\n                    continue ;\\n                int next = state + (1 << i) ;\\n                if(dp[next] != -1)\\n                    continue ;\\n                pq.push({notMatch + unMatch[i][j], next}) ;\\n            }\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337234,
                "title": "java-dp-bitmask",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        ArrayList<Integer> arr1 = new ArrayList<>();\\n        for(int i = 0 ; i < students.length ; i++){\\n            int num = 0;\\n            for(int j = 0 ; j < students[i].length ; j++){\\n                if(students[i][j] == 1){\\n                    num = num | (1 << j);\\n                }\\n            }\\n            arr1.add(num);\\n        }\\n        ArrayList<Integer> arr2 = new ArrayList<>();\\n        for(int i = 0 ; i < mentors.length ; i++){\\n            int num = 0;\\n            for(int j = 0 ; j < mentors[i].length ; j++){\\n                if(mentors[i][j] == 1){\\n                    num = num | (1 << j);\\n                }\\n            }\\n            arr2.add(num);\\n        }\\n        int n = mentors.length;\\n        int[][] dp = new int[n][257];\\n        for(int p = 0 ; p < n ; p++){\\n            for(int o = 0 ; o < 257 ; o++){\\n                dp[p][o] = -1;\\n            }\\n        }\\n        return getMax(0 , arr1 , arr2 , 0 , mentors[0].length , dp);\\n    }\\n    private int getMax(int i , ArrayList<Integer> arr1 , ArrayList<Integer> arr2 , int mask , int n , int[][] dp){\\n        if(i >= arr1.size()) return 0;\\n        if(dp[i][mask] != -1) return dp[i][mask];\\n        int ans = 0;\\n        for(int j = 0 ; j < arr2.size() ; j++){\\n            if((mask | (1 << j)) != mask){\\n                int newMask = (mask | (1 << j));\\n                ans = Math.max(get(arr1.get(i) , arr2.get(j) , n) + getMax(i+1 , arr1 , arr2 , newMask , n  , dp) , ans);\\n                \\n            }\\n        }\\n        return dp[i][mask] = ans;\\n        \\n    }\\n    private int get(int num1 , int num2 , int n){\\n        int xor = num1 ^ num2;\\n        int count = 0;\\n        while(xor > 0){\\n            count++;\\n            xor = xor & (xor-1);\\n        }\\n        //System.out.println(num1 + \" \" + num2 + \" \" + (n - count));\\n        return  n - count;\\n    }\\n}\\n```\\n**Please UpVote, if found useful :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        ArrayList<Integer> arr1 = new ArrayList<>();\\n        for(int i = 0 ; i < students.length ; i++){\\n            int num = 0;\\n            for(int j = 0 ; j < students[i].length ; j++){\\n                if(students[i][j] == 1){\\n                    num = num | (1 << j);\\n                }\\n            }\\n            arr1.add(num);\\n        }\\n        ArrayList<Integer> arr2 = new ArrayList<>();\\n        for(int i = 0 ; i < mentors.length ; i++){\\n            int num = 0;\\n            for(int j = 0 ; j < mentors[i].length ; j++){\\n                if(mentors[i][j] == 1){\\n                    num = num | (1 << j);\\n                }\\n            }\\n            arr2.add(num);\\n        }\\n        int n = mentors.length;\\n        int[][] dp = new int[n][257];\\n        for(int p = 0 ; p < n ; p++){\\n            for(int o = 0 ; o < 257 ; o++){\\n                dp[p][o] = -1;\\n            }\\n        }\\n        return getMax(0 , arr1 , arr2 , 0 , mentors[0].length , dp);\\n    }\\n    private int getMax(int i , ArrayList<Integer> arr1 , ArrayList<Integer> arr2 , int mask , int n , int[][] dp){\\n        if(i >= arr1.size()) return 0;\\n        if(dp[i][mask] != -1) return dp[i][mask];\\n        int ans = 0;\\n        for(int j = 0 ; j < arr2.size() ; j++){\\n            if((mask | (1 << j)) != mask){\\n                int newMask = (mask | (1 << j));\\n                ans = Math.max(get(arr1.get(i) , arr2.get(j) , n) + getMax(i+1 , arr1 , arr2 , newMask , n  , dp) , ans);\\n                \\n            }\\n        }\\n        return dp[i][mask] = ans;\\n        \\n    }\\n    private int get(int num1 , int num2 , int n){\\n        int xor = num1 ^ num2;\\n        int count = 0;\\n        while(xor > 0){\\n            count++;\\n            xor = xor & (xor-1);\\n        }\\n        //System.out.println(num1 + \" \" + num2 + \" \" + (n - count));\\n        return  n - count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279389,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maxCompatibilitySum(_ s: [[Int]], _ m: [[Int]]) -> Int {\\n        \\n        let cs = s.map { s in m.map { zip(s, $0).filter({ $0 == $1 }).count } }\\n        var res = cs.indices.map({ cs[$0][$0] }).reduce(0, +)\\n\\n        func bf(_ v: Int = 0, _ r: [Int] = Array(0..<m.count)) {\\n\\n            guard !r.isEmpty else { return res = max(res, v) }\\n            let i = m.count - r.count\\n            \\n            for j in r.indices {\\n                var nr = r\\n                nr.remove(at: j)\\n                bf(v + cs[i][r[j]], nr)\\n            }\\n        }\\n\\n        bf()\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxCompatibilitySum(_ s: [[Int]], _ m: [[Int]]) -> Int {\\n        \\n        let cs = s.map { s in m.map { zip(s, $0).filter({ $0 == $1 }).count } }\\n        var res = cs.indices.map({ cs[$0][$0] }).reduce(0, +)\\n\\n        func bf(_ v: Int = 0, _ r: [Int] = Array(0..<m.count)) {\\n\\n            guard !r.isEmpty else { return res = max(res, v) }\\n            let i = m.count - r.count\\n            \\n            for j in r.indices {\\n                var nr = r\\n                nr.remove(at: j)\\n                bf(v + cs[i][r[j]], nr)\\n            }\\n        }\\n\\n        bf()\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252146,
                "title": "c-normal-recursive-solution-easy-understanding",
                "content": "```\\n    int f(vector<vector<int>>& vec, vector<vector<int>>& men,vector<int> &taken,int ind){\\n        \\n        if(ind==vec.size()) return 0;\\n        \\n        int maxi = 0;\\n        for(int i=0;i<men.size();i++){\\n            if(!taken[i]){\\n                int ans = 0;\\n                for(int j =0;j<vec[ind].size();j++){\\n                    if(men[i][j]==vec[ind][j]) ans++;\\n                }\\n                taken[i] = 1;\\n                maxi = max(maxi,ans+f(vec,men,taken,ind+1));\\n                taken[i] = 0;\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& stu, vector<vector<int>>& men) {\\n        vector<int>taken(9,0);\\n        return f(stu,men,taken,0);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n    int f(vector<vector<int>>& vec, vector<vector<int>>& men,vector<int> &taken,int ind){\\n        \\n        if(ind==vec.size()) return 0;\\n        \\n        int maxi = 0;\\n        for(int i=0;i<men.size();i++){\\n            if(!taken[i]){\\n                int ans = 0;\\n                for(int j =0;j<vec[ind].size();j++){\\n                    if(men[i][j]==vec[ind][j]) ans++;\\n                }\\n                taken[i] = 1;\\n                maxi = max(maxi,ans+f(vec,men,taken,ind+1));\\n                taken[i] = 0;\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& stu, vector<vector<int>>& men) {\\n        vector<int>taken(9,0);\\n        return f(stu,men,taken,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3246633,
                "title": "python-easy-to-understand-recursive-solution",
                "content": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n        seen = set()\\n        ans = [0]\\n        \\n        def dfs(sIndex, mIndex, total):\\n            while mIndex in seen:\\n                mIndex += 1\\n            if sIndex >= m or mIndex >= m:\\n                ans[0] = max(total, ans[0])\\n                return\\n                \\n            score = sum((1 if students[sIndex][i] == mentors[mIndex][i] else 0) for i in range(n))\\n            \\n            seen.add(mIndex)\\n            dfs(sIndex + 1, 0, total + score)\\n            seen.remove(mIndex)\\n            dfs(sIndex, mIndex + 1, total)\\n            \\n        dfs(0, 0, 0)\\n        return ans[0]\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m, n = len(students), len(students[0])\\n        seen = set()\\n        ans = [0]\\n        \\n        def dfs(sIndex, mIndex, total):\\n            while mIndex in seen:\\n                mIndex += 1\\n            if sIndex >= m or mIndex >= m:\\n                ans[0] = max(total, ans[0])\\n                return\\n                \\n            score = sum((1 if students[sIndex][i] == mentors[mIndex][i] else 0) for i in range(n))\\n            \\n            seen.add(mIndex)\\n            dfs(sIndex + 1, 0, total + score)\\n            seen.remove(mIndex)\\n            dfs(sIndex, mIndex + 1, total)\\n            \\n        dfs(0, 0, 0)\\n        return ans[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233654,
                "title": "backtracking",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    int rating(vector<int> & s, vector<int> & m) {\\n\\n       int res = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == m[i])\\n                res++;\\n        }\\n\\n        return res;        \\n    }\\n\\n    int compat(vector<vector<int>> & students, vector<vector<int>> & mentors, int s, vector<bool> & vis) {\\n\\n        if(s >= students.size()) {\\n            return 0;\\n        }\\n\\n        int res = 0;\\n        \\n        for(int m = 0; m < mentors.size(); m++) {\\n            if(!vis[m]) {\\n                vis[m] = true;\\n                res = max(res, rating(students[s], mentors[m]) + compat(students, mentors, s + 1, vis));\\n                vis[m] = false;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n = students.size();\\n\\n        vector<bool> vis(n + 1, false);\\n\\n        int maxCompatibility = 0;\\n\\n        return compat(students, mentors, 0, vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\n    int rating(vector<int> & s, vector<int> & m) {\\n\\n       int res = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == m[i])\\n                res++;\\n        }\\n\\n        return res;        \\n    }\\n\\n    int compat(vector<vector<int>> & students, vector<vector<int>> & mentors, int s, vector<bool> & vis) {\\n\\n        if(s >= students.size()) {\\n            return 0;\\n        }\\n\\n        int res = 0;\\n        \\n        for(int m = 0; m < mentors.size(); m++) {\\n            if(!vis[m]) {\\n                vis[m] = true;\\n                res = max(res, rating(students[s], mentors[m]) + compat(students, mentors, s + 1, vis));\\n                vis[m] = false;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n = students.size();\\n\\n        vector<bool> vis(n + 1, false);\\n\\n        int maxCompatibility = 0;\\n\\n        return compat(students, mentors, 0, vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228926,
                "title": "c-dp-easy-understanding-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\nlong long helper(vector<int> a,vector<int> b){\\n        int n=a.size();\\n        int i=0;\\n        int j=0;\\n        long long count=0;\\n        while(i<n && j<n){        \\n            if(a[i]==b[j]){\\n                count++;\\n            }\\n            i++;\\n            j++;\\n        }\\n        return count;\\n}\\nlong long helper2(int i,vector<vector<int>>&students,vector<vector<int>>&mentors,vector<bool>&visited,int n){\\n        \\n        if(i>=n){\\n            return 0;\\n        }\\n        long long maxi=-1e9;\\n        for(int j=0;j<n;j++){            \\n            if(visited[j]!=true){             \\n                visited[j]=true;\\n                long long ans=helper(students[i],mentors[j])+helper2(i+1,students,mentors,visited,n);\\n                maxi=max(maxi,ans);\\n                visited[j]=false;\\n            }\\n        }\\n        return maxi;\\n}\\nint maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        \\n        int n=students.size();\\n        vector<bool> visited(n,false);\\n        long long ans=helper2(0,students,mentors,visited,n);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\nlong long helper(vector<int> a,vector<int> b){\\n        int n=a.size();\\n        int i=0;\\n        int j=0;\\n        long long count=0;\\n        while(i<n && j<n){        \\n            if(a[i]==b[j]){\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3140862,
                "title": "dynamic-programming-with-bitmasking-approach",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[10][1<<10];\\n\\n    int get_compatibility(vector<int>& v1, vector<int>& v2, int& m) {\\n        \\n        int ans = 0;\\n        for(int i=0; i<m; i++) if (v1[i] == v2[i]) ans++;\\n        return ans;\\n    }\\n\\n    int func(vector<vector<int>>& students, vector<vector<int>>& mentors, int idx, int mask, int& n, int& m) {\\n        if (idx == n) return 0;\\n\\n        if (dp[idx][mask] != -1) return dp[idx][mask];\\n        int ans = INT_MIN;\\n        for (int i=0; i<n; i++) {\\n            if (mask & (1<<i)) {\\n                int curr_compatibility = get_compatibility(students[idx], mentors[i], m);\\n                ans = max(ans, curr_compatibility + func(students, mentors, idx+1, mask ^ (1<<i), n, m));\\n            }\\n        }\\n\\n        return dp[idx][mask] = ans;\\n    }\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return func(students, mentors, 0, (1<<n)-1, n, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int dp[10][1<<10];\\n\\n    int get_compatibility(vector<int>& v1, vector<int>& v2, int& m) {\\n        \\n        int ans = 0;\\n        for(int i=0; i<m; i++) if (v1[i] == v2[i]) ans++;\\n        return ans;\\n    }\\n\\n    int func(vector<vector<int>>& students, vector<vector<int>>& mentors, int idx, int mask, int& n, int& m) {\\n        if (idx == n) return 0;\\n\\n        if (dp[idx][mask] != -1) return dp[idx][mask];\\n        int ans = INT_MIN;\\n        for (int i=0; i<n; i++) {\\n            if (mask & (1<<i)) {\\n                int curr_compatibility = get_compatibility(students[idx], mentors[i], m);\\n                ans = max(ans, curr_compatibility + func(students, mentors, idx+1, mask ^ (1<<i), n, m));\\n            }\\n        }\\n\\n        return dp[idx][mask] = ans;\\n    }\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n = students.size();\\n        int m = students[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return func(students, mentors, 0, (1<<n)-1, n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103685,
                "title": "simple-java-solution-backtracking",
                "content": "# Intuition\\nin each case we have wither of the two options\\n1.whether match the current one\\n2.skip the current one\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int fun(int[]a ,int[] b)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<a.length;i++) if(a[i]==b[i])  cnt++;\\n        return cnt;\\n    }\\n    public int fun(int i,int[][] a,int[][] b,boolean[] vis)\\n    {\\n        if(i==a.length)  return 0;\\n        int ans=0;\\n        int[] curr=a[i];\\n        for(int j=0;j<b.length;j++)\\n        {\\n            if(vis[j])  continue;\\n            vis[j]=true;\\n            ans=Math.max(ans,fun(curr,b[j])+fun(i+1,a,b,vis));\\n            vis[j]=false;\\n        }\\n        return ans;\\n    }\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) \\n    {\\n        boolean[] s=new boolean[students.length];\\n        return fun(0,students,mentors,s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int fun(int[]a ,int[] b)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<a.length;i++) if(a[i]==b[i])  cnt++;\\n        return cnt;\\n    }\\n    public int fun(int i,int[][] a,int[][] b,boolean[] vis)\\n    {\\n        if(i==a.length)  return 0;\\n        int ans=0;\\n        int[] curr=a[i];\\n        for(int j=0;j<b.length;j++)\\n        {\\n            if(vis[j])  continue;\\n            vis[j]=true;\\n            ans=Math.max(ans,fun(curr,b[j])+fun(i+1,a,b,vis));\\n            vis[j]=false;\\n        }\\n        return ans;\\n    }\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) \\n    {\\n        boolean[] s=new boolean[students.length];\\n        return fun(0,students,mentors,s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103243,
                "title": "easy-simple-java-full-algorithm-explained",
                "content": "# Intuition\\nThis is a simple Backtrack Problem\\n\\n# Approach\\n1.First we will be taking final compatibility , total questions , total students and taken (mentors) as global.\\n2.In the main body we will find out the length of row and column of studnet array , row will become totalstudents and columns will become totalquestions.\\n3.We will fill the taken array with 0 and call our recursive functions passin students,mentors ,student(row),compatibilty.\\n4.Finally will return our finalcompatibility\\n\\n5.In our recursive function we will check if our student no exceeds or becomes equal to student length we will find the max compatibility.\\n6.Then we will perform our recursion , if menotr is not visted we will mark it visited and find the compability count of student and mentor to getcomp recursive function.\\n7.Then we will call the recursive function passing studdents ,mentors,row+1,prev compatibiity + new compability.\\n8.While backtracking we will mark the taken[i]=0.\\n\\n9.In getcomp function we will find the compability score betwee students and mentor. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    int finalcompatibility;\\n    int taken[]=new int[8];\\n    int totalstudents,totalquestions;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        this.finalcompatibility=0;\\n        int m = students.length;\\n        int n = students[0].length;\\n        this.totalstudents = m;\\n        this.totalquestions = n;\\n        Arrays.fill(taken,0);\\n        getmaxcomp(students,mentors,0,0);\\n        return this.finalcompatibility;\\n    }\\n\\n    private void getmaxcomp(int[][] students, int[][] mentors,int m ,int comp){\\n        if(m>=this.totalstudents){\\n            this.finalcompatibility = Math.max(comp,this.finalcompatibility);\\n        }\\n\\n        for(int i=0;i<this.totalstudents;i++){\\n            if(taken[i]==0){\\n                taken[i]=1;\\n                int tempcomp = getcomp(students[m],mentors[i]);\\n                getmaxcomp(students,mentors,m+1,comp+tempcomp);\\n                taken[i]=0;\\n            }\\n        }\\n    }\\n\\n    private int getcomp(int students[],int mentors[]){\\n        int count=0;\\n        for(int i=0;i<students.length;i++){\\n            if(students[i]==mentors[i])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int finalcompatibility;\\n    int taken[]=new int[8];\\n    int totalstudents,totalquestions;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        this.finalcompatibility=0;\\n        int m = students.length;\\n        int n = students[0].length;\\n        this.totalstudents = m;\\n        this.totalquestions = n;\\n        Arrays.fill(taken,0);\\n        getmaxcomp(students,mentors,0,0);\\n        return this.finalcompatibility;\\n    }\\n\\n    private void getmaxcomp(int[][] students, int[][] mentors,int m ,int comp){\\n        if(m>=this.totalstudents){\\n            this.finalcompatibility = Math.max(comp,this.finalcompatibility);\\n        }\\n\\n        for(int i=0;i<this.totalstudents;i++){\\n            if(taken[i]==0){\\n                taken[i]=1;\\n                int tempcomp = getcomp(students[m],mentors[i]);\\n                getmaxcomp(students,mentors,m+1,comp+tempcomp);\\n                taken[i]=0;\\n            }\\n        }\\n    }\\n\\n    private int getcomp(int students[],int mentors[]){\\n        int count=0;\\n        for(int i=0;i<students.length;i++){\\n            if(students[i]==mentors[i])count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098804,
                "title": "simple-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconstraints are too small\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursion and backtracking \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nexponential\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int f(int ind,vector<vector<int>>& students, vector<vector<int>>& mentors,vector<int>&vis){\\n      \\n      int n= students.size();\\n      int m= students[0].size();\\n      if(ind==n) return 0;\\n      int ans=0;\\n      for(int i=0;i<n;i++){\\n          if(!vis[i]){\\n              int d=0;\\n              vis[i]=1;\\n              for(int j=0;j<m;j++) if((students[ind][j]^mentors[i][j])==0) d++;\\n         ans= max(ans,d+f(ind+1,students,mentors,vis));\\n         vis[i]=0;\\n          }\\n      }\\n      return ans;\\n }\\n\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n       int n= students.size();\\n       int m= students[0].size();\\n       vector<int>vis(n);\\n    return f(0,students,mentors,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int f(int ind,vector<vector<int>>& students, vector<vector<int>>& mentors,vector<int>&vis){\\n      \\n      int n= students.size();\\n      int m= students[0].size();\\n      if(ind==n) return 0;\\n      int ans=0;\\n      for(int i=0;i<n;i++){\\n          if(!vis[i]){\\n              int d=0;\\n              vis[i]=1;\\n              for(int j=0;j<m;j++) if((students[ind][j]^mentors[i][j])==0) d++;\\n         ans= max(ans,d+f(ind+1,students,mentors,vis));\\n         vis[i]=0;\\n          }\\n      }\\n      return ans;\\n }\\n\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n       int n= students.size();\\n       int m= students[0].size();\\n       vector<int>vis(n);\\n    return f(0,students,mentors,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092823,
                "title": "brute-force-dfs-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int score(vector<int>&a,vector<int>&b){\\n        int cnt = 0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i] == b[i]) cnt++;\\n        }\\n        return cnt;\\n    }\\n\\n    int solve(vector<vector<int>>&students,vector<vector<int>>& mentors,int ind,vector<int>&vis){\\n        if(ind == n) return 0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            vis[i] = 1;\\n            ans = max(ans,score(students[ind],mentors[i]) + solve(students,mentors,ind+1,vis));\\n            vis[i] = 0;\\n        }\\n        return ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        n = students.size();\\n        vector<int>vis(n,0);\\n        return solve(students,mentors,0,vis);\\n    }\\n};\\n```\\n\\n# upvote if it\\'s help you HAPPY CODING :)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    int score(vector<int>&a,vector<int>&b){\\n        int cnt = 0;\\n        for(int i=0;i<a.size();i++){\\n            if(a[i] == b[i]) cnt++;\\n        }\\n        return cnt;\\n    }\\n\\n    int solve(vector<vector<int>>&students,vector<vector<int>>& mentors,int ind,vector<int>&vis){\\n        if(ind == n) return 0;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            vis[i] = 1;\\n            ans = max(ans,score(students[ind],mentors[i]) + solve(students,mentors,ind+1,vis));\\n            vis[i] = 0;\\n        }\\n        return ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        n = students.size();\\n        vector<int>vis(n,0);\\n        return solve(students,mentors,0,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065904,
                "title": "python-dp-approach",
                "content": "\\n# Complexity\\n- Time complexity: $O(n*2^n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        n = len(students)\\n        pairs = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                pairs[i][j] = sum([s == m for s, m in zip(students[i], mentors[j])])\\n\\n        dp = [0 for _ in range(1<<n)]\\n\\n        for mask in range(pow(2,n)):\\n            i = bin(mask).count(\"1\")\\n            for j in range(n):\\n                if  (1<<j) & mask == 0:\\n                    dp[(1<<j) | mask ] = max(dp[(1<<j) | mask ], dp[mask]+pairs[i][j])\\n\\n\\n        return dp[(1<<n) -1]\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        n = len(students)\\n        pairs = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                pairs[i][j] = sum([s == m for s, m in zip(students[i], mentors[j])])\\n\\n        dp = [0 for _ in range(1<<n)]\\n\\n        for mask in range(pow(2,n)):\\n            i = bin(mask).count(\"1\")\\n            for j in range(n):\\n                if  (1<<j) & mask == 0:\\n                    dp[(1<<j) | mask ] = max(dp[(1<<j) | mask ], dp[mask]+pairs[i][j])\\n\\n\\n        return dp[(1<<n) -1]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061191,
                "title": "java-beats-100",
                "content": "Similar to: 1066 https://leetcode.com/problems/campus-bikes-ii/description/\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        return dfs(students, mentors, 0, 0, new Integer[students.length][256]);\\n    }\\n\\n    private int dfs(int[][] stu, int[][] men, int idx, int status, Integer[][] memo) {\\n        if (idx == stu.length) {\\n            return 0;\\n        }\\n        if (memo[idx][status] != null) {\\n            return memo[idx][status];\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < men.length; i++) {\\n            if ((status & (1 << i)) == 0) {\\n                res = Math.max(res, comp(stu[idx], men[i]) + dfs(stu, men, idx + 1, status | (1 << i), memo));\\n            }\\n        }\\n        memo[idx][status] = res;\\n        return res;\\n    }\\n\\n    private int comp(int[] stu, int[] men) {\\n        int res = 0;\\n        for (int i = 0; i < stu.length; i++) {\\n            if (stu[i] == men[i]) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        return dfs(students, mentors, 0, 0, new Integer[students.length][256]);\\n    }\\n\\n    private int dfs(int[][] stu, int[][] men, int idx, int status, Integer[][] memo) {\\n        if (idx == stu.length) {\\n            return 0;\\n        }\\n        if (memo[idx][status] != null) {\\n            return memo[idx][status];\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < men.length; i++) {\\n            if ((status & (1 << i)) == 0) {\\n                res = Math.max(res, comp(stu[idx], men[i]) + dfs(stu, men, idx + 1, status | (1 << i), memo));\\n            }\\n        }\\n        memo[idx][status] = res;\\n        return res;\\n    }\\n\\n    private int comp(int[] stu, int[] men) {\\n        int res = 0;\\n        for (int i = 0; i < stu.length; i++) {\\n            if (stu[i] == men[i]) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061165,
                "title": "python-dp-bitmask-beats-100-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe wish to represent each state with bitmasking\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first precompute student mentor values using the comp function and store it in comp_dp so we do not waste time recomputing these values.\\n\\nWe represent the state of students that are left with bitmasking. 0 meaning the student has already been assigned and 1 meaning he is still free to be assigned. For example, in a 3 student case 111 means each student has yet to be assigned and 011 means the first student has been assigned and the other two haven\\'t. In the 8 student case we start with 11111111 and end with 00000000. \\n\\nWe go through each mentor 1 by 1 with the mentor variable, and try every student that is still available, updating the score and bitmask as we do so. We return the max score that we acheive from every combination and use the @lru_cache to save values to save time.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO((2^n) * m * n)\\n\\nLike if this helped!\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        n = len(students[0])\\n        comp_dp = [[0 for i in range(m)] for j in range(m)]\\n        \\n        def comp(student, mentor):\\n            count = 0\\n            for an1, an2 in zip(students[student], mentors[mentor]):\\n                if an1 == an2:\\n                    count += 1\\n            return count\\n\\n        @lru_cache(None)\\n        def dp(mask, mentor):\\n            ans = 0\\n            if mask == 0:\\n                return ans\\n            for i in range(m):\\n                if mask & (1 << i):\\n                    ans = max(ans, comp_dp[i][mentor] + dp(mask - (1 << i), mentor + 1))\\n            return ans\\n\\n        for i in range(m):\\n            for j in range(m):\\n                comp_dp[i][j] = comp(i,j)\\n        return dp((1 << (m)) - 1, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        n = len(students[0])\\n        comp_dp = [[0 for i in range(m)] for j in range(m)]\\n        \\n        def comp(student, mentor):\\n            count = 0\\n            for an1, an2 in zip(students[student], mentors[mentor]):\\n                if an1 == an2:\\n                    count += 1\\n            return count\\n\\n        @lru_cache(None)\\n        def dp(mask, mentor):\\n            ans = 0\\n            if mask == 0:\\n                return ans\\n            for i in range(m):\\n                if mask & (1 << i):\\n                    ans = max(ans, comp_dp[i][mentor] + dp(mask - (1 << i), mentor + 1))\\n            return ans\\n\\n        for i in range(m):\\n            for j in range(m):\\n                comp_dp[i][j] = comp(i,j)\\n        return dp((1 << (m)) - 1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057598,
                "title": "java-bactracking-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    boolean[] visited;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        m = students.length;\\n        n = students[0].length;\\n        visited = new boolean[m];\\n        return helper(0,students,mentors);\\n    }\\n    private int helper(int i, int[][] students, int[][] mentors){\\n        if(i == m){\\n            return 0;\\n        }\\n        int maxScore = 0;\\n        int currScore = 0;\\n        for(int k=0; k<m; k++){\\n            if(visited[k] == true){\\n                continue;\\n            }\\n            int compatibiltyScore = 0;\\n            for(int j=0; j<n; j++){\\n                if(students[i][j] == mentors[k][j]){\\n                    compatibiltyScore++;\\n                }\\n            }\\n            visited[k] = true;\\n            currScore = compatibiltyScore + helper(i+1,students,mentors);\\n            visited[k] = false;\\n            maxScore = Math.max(currScore,maxScore);\\n        }\\n        return maxScore;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    boolean[] visited;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        m = students.length;\\n        n = students[0].length;\\n        visited = new boolean[m];\\n        return helper(0,students,mentors);\\n    }\\n    private int helper(int i, int[][] students, int[][] mentors){\\n        if(i == m){\\n            return 0;\\n        }\\n        int maxScore = 0;\\n        int currScore = 0;\\n        for(int k=0; k<m; k++){\\n            if(visited[k] == true){\\n                continue;\\n            }\\n            int compatibiltyScore = 0;\\n            for(int j=0; j<n; j++){\\n                if(students[i][j] == mentors[k][j]){\\n                    compatibiltyScore++;\\n                }\\n            }\\n            visited[k] = true;\\n            currScore = compatibiltyScore + helper(i+1,students,mentors);\\n            visited[k] = false;\\n            maxScore = Math.max(currScore,maxScore);\\n        }\\n        return maxScore;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045914,
                "title": "easy-backtrack-solution-java",
                "content": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors)\\n    {\\n        \\n        int m=students.length;\\n        boolean[] visited=new boolean[m];\\n        \\n        return backtrack(0,students,mentors,visited,m);\\n        \\n    }\\n    \\n    public int backtrack(int index, int[][] students, int[][] mentors, boolean[] visited,int m)\\n    {\\n        if(index==m)\\n        {\\n            return 0;\\n        }\\n        \\n        int max=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            if(visited[i]==true)\\n            {\\n                continue;\\n            }\\n            \\n            visited[i]=true;\\n            \\n            int sum=getsum(students[index],mentors[i])+backtrack(index+1,students,mentors,visited,m);\\n            \\n            visited[i]=false;\\n            max=Math.max(sum,max);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int getsum(int[] a, int[] b)\\n    {\\n        int count=0;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            count+=(a[i]==b[i])?1:0;\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors)\\n    {\\n        \\n        int m=students.length;\\n        boolean[] visited=new boolean[m];\\n        \\n        return backtrack(0,students,mentors,visited,m);\\n        \\n    }\\n    \\n    public int backtrack(int index, int[][] students, int[][] mentors, boolean[] visited,int m)\\n    {\\n        if(index==m)\\n        {\\n            return 0;\\n        }\\n        \\n        int max=0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            if(visited[i]==true)\\n            {\\n                continue;\\n            }\\n            \\n            visited[i]=true;\\n            \\n            int sum=getsum(students[index],mentors[i])+backtrack(index+1,students,mentors,visited,m);\\n            \\n            visited[i]=false;\\n            max=Math.max(sum,max);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int getsum(int[] a, int[] b)\\n    {\\n        int count=0;\\n        \\n        for(int i=0;i<a.length;i++)\\n        {\\n            count+=(a[i]==b[i])?1:0;\\n        }\\n        \\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022476,
                "title": "python-min-cost-perfect-matching",
                "content": "# Code\\n```\\nfrom scipy.optimize import linear_sum_assignment\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        n = len(students)\\n        cost = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                cost[i][j] = -sum(x==y for x,y in zip(students[i], mentors[j]))\\n        row_ind, col_ind = linear_sum_assignment(cost)\\n        return -sum(cost[i][j] for i, j in zip(row_ind, col_ind))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom scipy.optimize import linear_sum_assignment\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        n = len(students)\\n        cost = [[0]*n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                cost[i][j] = -sum(x==y for x,y in zip(students[i], mentors[j]))\\n        row_ind, col_ind = linear_sum_assignment(cost)\\n        return -sum(cost[i][j] for i, j in zip(row_ind, col_ind))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962654,
                "title": "swift-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBacktracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Lock the index\\n* Calculate one pair of student-mentor group\\n* Perform backtracing\\n* Add sum to the result\\n* Unlock the index\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThere are O(mm) student-mentor pairs and for every pair we have to perform O(n) comparisons to compute compatibility. \\nO(nmn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) + O(n)\\nAuxillay stack space + data structure to store result\\n\\n```\\nclass Solution {\\n    func maxCompatibilitySum(_ students: [[Int]], _ mentors: [[Int]]) -> Int {\\n        var result = 0\\n        var flag = [Int: Bool]()\\n        var index = 0\\n        let n = students.count\\n        let m = mentors.count\\n        let sum = 0\\n        f(index, &flag, students, mentors, n, m, sum, &result)\\n        return result\\n    }\\n\\n    private func f(_ index: Int,\\n                    _ flag: inout [Int: Bool],\\n                    _ students: [[Int]],\\n                    _ mentors: [[Int]],\\n                    _ n: Int,\\n                    _ m: Int,\\n                    _ sum: Int,\\n                    _ result: inout Int) {\\n        if index == n {\\n            result = max(result, sum)\\n            return\\n        }\\n\\n        for i in 0..<n {\\n            if flag[i] != true {\\n                flag[i] = true\\n                let temp = calculateCompatibility(index, i, students, mentors)\\n                f(index + 1, &flag, students, mentors, n, m, sum + temp, &result)\\n                flag[i] = false\\n            }\\n        }\\n    }\\n\\n    private func calculateCompatibility(_ index: Int,\\n                                        _ j: Int,\\n                                        _ students: [[Int]],\\n                                        _ mentors: [[Int]]) -> Int {\\n        var sum = 0\\n        let student = students[index]\\n        let mentor = mentors[j]\\n\\n        for i in 0..<student.count {\\n            if student[i] == mentor[i] {\\n                sum += 1\\n            }\\n        }\\n        return sum\\n    }\\n}\\n```\\n\\n\\n```\\n                                              f(idx=0,[0,0,0],i=0)\\n                                            /               |               \\\\\\n                            f([1,0,0],1)        f([0,1,0],1)        f([0,0,1],1)\\n                        /                       /   |\\n            f([1,1,0],2)..f([1,0,1],2)  f([1,1,0],2)  f([0,1,1],2)   f([1,0,1],2)...f([0,1,1],2)\\n            /               /                  /            \\\\\\n f([1,1,1],3)           f([1,1,1],3)    f([1,1,1],3)    f([1,1,1],3)\\n /                      /\\n >m\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxCompatibilitySum(_ students: [[Int]], _ mentors: [[Int]]) -> Int {\\n        var result = 0\\n        var flag = [Int: Bool]()\\n        var index = 0\\n        let n = students.count\\n        let m = mentors.count\\n        let sum = 0\\n        f(index, &flag, students, mentors, n, m, sum, &result)\\n        return result\\n    }\\n\\n    private func f(_ index: Int,\\n                    _ flag: inout [Int: Bool],\\n                    _ students: [[Int]],\\n                    _ mentors: [[Int]],\\n                    _ n: Int,\\n                    _ m: Int,\\n                    _ sum: Int,\\n                    _ result: inout Int) {\\n        if index == n {\\n            result = max(result, sum)\\n            return\\n        }\\n\\n        for i in 0..<n {\\n            if flag[i] != true {\\n                flag[i] = true\\n                let temp = calculateCompatibility(index, i, students, mentors)\\n                f(index + 1, &flag, students, mentors, n, m, sum + temp, &result)\\n                flag[i] = false\\n            }\\n        }\\n    }\\n\\n    private func calculateCompatibility(_ index: Int,\\n                                        _ j: Int,\\n                                        _ students: [[Int]],\\n                                        _ mentors: [[Int]]) -> Int {\\n        var sum = 0\\n        let student = students[index]\\n        let mentor = mentors[j]\\n\\n        for i in 0..<student.count {\\n            if student[i] == mentor[i] {\\n                sum += 1\\n            }\\n        }\\n        return sum\\n    }\\n}\\n```\n```\\n                                              f(idx=0,[0,0,0],i=0)\\n                                            /               |               \\\\\\n                            f([1,0,0],1)        f([0,1,0],1)        f([0,0,1],1)\\n                        /                       /   |\\n            f([1,1,0],2)..f([1,0,1],2)  f([1,1,0],2)  f([0,1,1],2)   f([1,0,1],2)...f([0,1,1],2)\\n            /               /                  /            \\\\\\n f([1,1,1],3)           f([1,1,1],3)    f([1,1,1],3)    f([1,1,1],3)\\n /                      /\\n >m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958516,
                "title": "bitmask-dp-88-42-faster-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[9][1LL<<8];\\n\\n    ll solve(vector<vector<int>>&students,vector<vector<int>>&mentors,ll row,ll mask,ll n,ll m){\\n        if(row==n){\\n            return 0;\\n        }\\n        if(dp[row][mask]!=-1){\\n            return dp[row][mask];\\n        }\\n        ll answer=INT_MIN;\\n        for(ll i=0;i<n;i++){\\n            if(mask&(1LL<<i)){\\n                continue;\\n            }\\n            ll sum=0;\\n            for(ll j=0;j<m;j++){\\n                if(students[row][j]==mentors[i][j]){\\n                    sum++;\\n                }\\n            }\\n            answer=max(answer,sum+solve(students,mentors,row+1,mask|(1LL<<i),n,m));\\n        }\\n        return dp[row][mask]=answer;\\n    }\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        ll n=students.size(),m=students[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(students,mentors,0,0,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[9][1LL<<8];\\n\\n    ll solve(vector<vector<int>>&students,vector<vector<int>>&mentors,ll row,ll mask,ll n,ll m){\\n        if(row==n){\\n            return 0;\\n        }\\n        if(dp[row][mask]!=-1){\\n            return dp[row][mask];\\n        }\\n        ll answer=INT_MIN;\\n        for(ll i=0;i<n;i++){\\n            if(mask&(1LL<<i)){\\n                continue;\\n            }\\n            ll sum=0;\\n            for(ll j=0;j<m;j++){\\n                if(students[row][j]==mentors[i][j]){\\n                    sum++;\\n                }\\n            }\\n            answer=max(answer,sum+solve(students,mentors,row+1,mask|(1LL<<i),n,m));\\n        }\\n        return dp[row][mask]=answer;\\n    }\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        ll n=students.size(),m=students[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(students,mentors,0,0,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856372,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\npub trait LexicalPermutation {\\n  fn next_permutation(&mut self) -> bool;\\n}\\n\\nimpl<T> LexicalPermutation for [T] where T: Ord {\\n  fn next_permutation(&mut self) -> bool {\\n    if self.len() < 2 { return false; }\\n      let mut i = self.len() - 1;\\n      while i > 0 && self[i-1] >= self[i] {\\n        i -= 1;\\n      }\\n\\n      if i == 0 {\\n        return false;\\n      }\\n\\n      let mut j = self.len() - 1;\\n      while j >= i && self[j] <= self[i-1]  {\\n        j -= 1;\\n      }\\n\\n      self.swap(j, i-1);\\n\\n      self[i..].reverse();\\n\\n      true\\n    }\\n}\\n\\nimpl Solution {\\n  pub fn max_compatibility_sum(students: Vec<Vec<i32>>, mentors: Vec<Vec<i32>>) -> i32 {\\n    let mut result = 0;\\n    let n = students.len();\\n    let m = students[0].len();\\n    let mut pattern = (0..n).into_iter().collect::<Vec<usize>>();\\n    \\n    loop {\\n      let next: Vec<usize> = pattern.iter().map(|v| *v).collect();\\n      \\n      let mut temp = 0;\\n      for i in 0..n {\\n        let ti = next[i];\\n        for j in 0..m {\\n          if students[ti][j] == mentors[i][j] {\\n            temp += 1;\\n          }\\n        }\\n      }\\n      \\n      result = result.max(temp);\\n      if !pattern.next_permutation() {\\n        break\\n      }\\n    } \\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\npub trait LexicalPermutation {\\n  fn next_permutation(&mut self) -> bool;\\n}\\n\\nimpl<T> LexicalPermutation for [T] where T: Ord {\\n  fn next_permutation(&mut self) -> bool {\\n    if self.len() < 2 { return false; }\\n      let mut i = self.len() - 1;\\n      while i > 0 && self[i-1] >= self[i] {\\n        i -= 1;\\n      }\\n\\n      if i == 0 {\\n        return false;\\n      }\\n\\n      let mut j = self.len() - 1;\\n      while j >= i && self[j] <= self[i-1]  {\\n        j -= 1;\\n      }\\n\\n      self.swap(j, i-1);\\n\\n      self[i..].reverse();\\n\\n      true\\n    }\\n}\\n\\nimpl Solution {\\n  pub fn max_compatibility_sum(students: Vec<Vec<i32>>, mentors: Vec<Vec<i32>>) -> i32 {\\n    let mut result = 0;\\n    let n = students.len();\\n    let m = students[0].len();\\n    let mut pattern = (0..n).into_iter().collect::<Vec<usize>>();\\n    \\n    loop {\\n      let next: Vec<usize> = pattern.iter().map(|v| *v).collect();\\n      \\n      let mut temp = 0;\\n      for i in 0..n {\\n        let ti = next[i];\\n        for j in 0..m {\\n          if students[ti][j] == mentors[i][j] {\\n            temp += 1;\\n          }\\n        }\\n      }\\n      \\n      result = result.max(temp);\\n      if !pattern.next_permutation() {\\n        break\\n      }\\n    } \\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839807,
                "title": "c-simple-backtracking",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int rec(int st,vector<vector<int>>& students, vector<vector<int>>& mentors,vector<bool> &visit)\\n {\\n     int ans=0;\\n    int n=mentors.size();\\n    int m=mentors[0].size();\\n    if(st>=n)return 0;\\n     for(int i=0;i<mentors.size();i++)\\n     {\\n         if(visit[i])continue;\\n        int curr=0;\\n         for(int j=0;j<m;j++)\\n         {\\n             if(students[st][j]==mentors[i][j])\\n             curr++;\\n         }\\n         visit[i]=true;\\n         ans=max(ans,curr+rec(st+1,students,mentors,visit));\\n         visit[i]=false;\\n     }\\n     return ans;\\n }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=mentors.size();\\n       vector<bool>visit(n,false);\\n        return rec(0,students,mentors,visit);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int rec(int st,vector<vector<int>>& students, vector<vector<int>>& mentors,vector<bool> &visit)\\n {\\n     int ans=0;\\n    int n=mentors.size();\\n    int m=mentors[0].size();\\n    if(st>=n)return 0;\\n     for(int i=0;i<mentors.size();i++)\\n     {\\n         if(visit[i])continue;\\n        int curr=0;\\n         for(int j=0;j<m;j++)\\n         {\\n             if(students[st][j]==mentors[i][j])\\n             curr++;\\n         }\\n         visit[i]=true;\\n         ans=max(ans,curr+rec(st+1,students,mentors,visit));\\n         visit[i]=false;\\n     }\\n     return ans;\\n }\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=mentors.size();\\n       vector<bool>visit(n,false);\\n        return rec(0,students,mentors,visit);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839489,
                "title": "python-simple-dp-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students, mentors):\\n        n, dict1 = len(students), defaultdict(int)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                dict1[i,j] = sum(k == l for k,l in zip(students[i],mentors[j]))\\n\\n        @lru_cache(None)\\n        def dfs(i,mask):\\n            if i == n:\\n                return 0\\n            return max(dfs(i+1,mask-(1<<j)) + dict1[i,j] for j in range(n) if (1<<j)&mask)\\n\\n        return dfs(0,(1<<n)-1)\\n\\n            \\n\\n\\n        \\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n        \\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students, mentors):\\n        n, dict1 = len(students), defaultdict(int)\\n\\n        for i in range(n):\\n            for j in range(n):\\n                dict1[i,j] = sum(k == l for k,l in zip(students[i],mentors[j]))\\n\\n        @lru_cache(None)\\n        def dfs(i,mask):\\n            if i == n:\\n                return 0\\n            return max(dfs(i+1,mask-(1<<j)) + dict1[i,j] for j in range(n) if (1<<j)&mask)\\n\\n        return dfs(0,(1<<n)-1)\\n\\n            \\n\\n\\n        \\n\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n        \\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828400,
                "title": "backtracking",
                "content": "# Approach\\nBack-tracking\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxCompatibilitySum(students: Array<IntArray>, mentors: Array<IntArray>): Int {\\n        val visited = BooleanArray(mentors.size)\\n\\n        return maxCompatibilitySum(students, mentors, 0, visited)\\n    }\\n\\n    fun maxCompatibilitySum(\\n        students: Array<IntArray>, \\n        mentors: Array<IntArray>,\\n        sIndex: Int,\\n        visited: BooleanArray\\n    ): Int {\\n        if(sIndex == students.size) return 0\\n\\n        var ans = 0\\n        for(i in 0 until mentors.size) {\\n            if(visited[i]) continue\\n\\n            visited[i] = true\\n            ans = maxOf(\\n                ans,\\n                score(students[sIndex], mentors[i]) + maxCompatibilitySum(students, mentors, sIndex + 1, visited)\\n            )\\n            visited[i] = false\\n        }\\n\\n        return ans\\n    }\\n\\n    fun score(sAnswers: IntArray, mAnsers: IntArray): Int {\\n        var score = 0\\n        for(i in 0 until sAnswers.size) {\\n            if(sAnswers[i] == mAnsers[i]) {\\n                score++\\n            }\\n        }\\n\\n        return score\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    fun maxCompatibilitySum(students: Array<IntArray>, mentors: Array<IntArray>): Int {\\n        val visited = BooleanArray(mentors.size)\\n\\n        return maxCompatibilitySum(students, mentors, 0, visited)\\n    }\\n\\n    fun maxCompatibilitySum(\\n        students: Array<IntArray>, \\n        mentors: Array<IntArray>,\\n        sIndex: Int,\\n        visited: BooleanArray\\n    ): Int {\\n        if(sIndex == students.size) return 0\\n\\n        var ans = 0\\n        for(i in 0 until mentors.size) {\\n            if(visited[i]) continue\\n\\n            visited[i] = true\\n            ans = maxOf(\\n                ans,\\n                score(students[sIndex], mentors[i]) + maxCompatibilitySum(students, mentors, sIndex + 1, visited)\\n            )\\n            visited[i] = false\\n        }\\n\\n        return ans\\n    }\\n\\n    fun score(sAnswers: IntArray, mAnsers: IntArray): Int {\\n        var score = 0\\n        for(i in 0 until sAnswers.size) {\\n            if(sAnswers[i] == mAnsers[i]) {\\n                score++\\n            }\\n        }\\n\\n        return score\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813578,
                "title": "python-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#bitmask question as n,m<8 \\n#bitmask + dp\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n\\n        m=len(students)\\n        n=len(students[0])\\n        S=[0 for i in range(m)]\\n        M=[0 for i in range(m)]\\n        for i in range(m):\\n            ans_s=0\\n            ans_m=0\\n            for j in range(n):\\n                ans_s+=students[i][j]*(2**(n-1-j))\\n                ans_m+=mentors[i][j]*(2**(n-1-j))\\n            S[i]=ans_s\\n            M[i]=ans_m\\n        D=defaultdict(int)\\n        def sol(stud,avai):\\n            \\n            if stud>=m:\\n                return 0\\n            elif D[avai]:\\n                return D[avai]\\n            else:\\n                comp=0\\n                for i in range(m):\\n                    if avai[i]==\\'0\\':\\n                        a=S[stud]\\n                        b=M[i]\\n                        count=0\\n                        for j in range(n):\\n                            if a&1 == b&1:\\n                                count+=1\\n                            a=a>>1\\n                            b=b>>1\\n                        local=avai[:i]+\\'1\\'+avai[i+1:]\\n                        t=sol(stud+1,local)\\n                        comp=max(comp,t+count)\\n                D[avai]=comp\\n                return comp\\n        t=sol(0,\\'0\\'*m)\\n        return t\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#bitmask question as n,m<8 \\n#bitmask + dp\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n\\n        m=len(students)\\n        n=len(students[0])\\n        S=[0 for i in range(m)]\\n        M=[0 for i in range(m)]\\n        for i in range(m):\\n            ans_s=0\\n            ans_m=0\\n            for j in range(n):\\n                ans_s+=students[i][j]*(2**(n-1-j))\\n                ans_m+=mentors[i][j]*(2**(n-1-j))\\n            S[i]=ans_s\\n            M[i]=ans_m\\n        D=defaultdict(int)\\n        def sol(stud,avai):\\n            \\n            if stud>=m:\\n                return 0\\n            elif D[avai]:\\n                return D[avai]\\n            else:\\n                comp=0\\n                for i in range(m):\\n                    if avai[i]==\\'0\\':\\n                        a=S[stud]\\n                        b=M[i]\\n                        count=0\\n                        for j in range(n):\\n                            if a&1 == b&1:\\n                                count+=1\\n                            a=a>>1\\n                            b=b>>1\\n                        local=avai[:i]+\\'1\\'+avai[i+1:]\\n                        t=sol(stud+1,local)\\n                        comp=max(comp,t+count)\\n                D[avai]=comp\\n                return comp\\n        t=sol(0,\\'0\\'*m)\\n        return t\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805938,
                "title": "easy-and-clean-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        int n = students.length;\\n        int m = n;\\n        boolean [] visited = new boolean[students.length];\\n        return GetMaxCS(students, mentors, n, m, 0, visited);\\n    }\\n\\n    public int GetMaxCS(int [][] students, int [][] mentors, int n, int m, \\n    int ind, boolean [] visited)\\n    {\\n        if(ind == n)\\n        return 0;\\n        int maxSum = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            if(visited[j])\\n            continue;\\n\\n            visited[j] = true;\\n            int sum = GetSum(students[ind], mentors[j]) + \\n                        GetMaxCS(students, mentors, n, m, ind+1, visited);\\n            visited[j] = false;\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        return maxSum;\\n    }\\n\\n    public int GetSum(int [] student, int [] mentor)\\n    {\\n        int sum = 0;\\n        for(int i=0;i<student.length;i++)\\n        {\\n            if(student[i] == mentor[i])\\n            sum++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        int n = students.length;\\n        int m = n;\\n        boolean [] visited = new boolean[students.length];\\n        return GetMaxCS(students, mentors, n, m, 0, visited);\\n    }\\n\\n    public int GetMaxCS(int [][] students, int [][] mentors, int n, int m, \\n    int ind, boolean [] visited)\\n    {\\n        if(ind == n)\\n        return 0;\\n        int maxSum = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            if(visited[j])\\n            continue;\\n\\n            visited[j] = true;\\n            int sum = GetSum(students[ind], mentors[j]) + \\n                        GetMaxCS(students, mentors, n, m, ind+1, visited);\\n            visited[j] = false;\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        return maxSum;\\n    }\\n\\n    public int GetSum(int [] student, int [] mentor)\\n    {\\n        int sum = 0;\\n        for(int i=0;i<student.length;i++)\\n        {\\n            if(student[i] == mentor[i])\\n            sum++;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788947,
                "title": "easy-to-understand-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int as=0;\\n    void ans(vector<vector<int>>&s,vector<vector<int>>&m,int n){\\n        if(n==s.size()){\\n            int cnt=0;\\n            for(int i=0;i<s.size();i++){\\n                int k=s[0].size();\\n                for(int j=0;j<k;j++){\\n                    if(s[i][j]==m[i][j])cnt++;\\n                }\\n            }\\n            as=max(as,cnt);\\n        }\\n        for(int i=n;i<s.size();i++){\\n            swap(m[i],m[n]);\\n            ans(s,m,n+1);\\n            swap(m[i],m[n]);\\n        }\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>&s, vector<vector<int>>&m) {\\n        ans(s,m,0);\\n        return as;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int as=0;\\n    void ans(vector<vector<int>>&s,vector<vector<int>>&m,int n){\\n        if(n==s.size()){\\n            int cnt=0;\\n            for(int i=0;i<s.size();i++){\\n                int k=s[0].size();\\n                for(int j=0;j<k;j++){\\n                    if(s[i][j]==m[i][j])cnt++;\\n                }\\n            }\\n            as=max(as,cnt);\\n        }\\n        for(int i=n;i<s.size();i++){\\n            swap(m[i],m[n]);\\n            ans(s,m,n+1);\\n            swap(m[i],m[n]);\\n        }\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>&s, vector<vector<int>>&m) {\\n        ans(s,m,0);\\n        return as;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780483,
                "title": "c-solution-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int get_score(vector<vector<int>>& students, vector<vector<int>>& mentors,int i,int j){\\n        int match = 0;\\n        for(int k=0;k<students[0].size();k++){\\n            if(students[i][k]==mentors[j][k]) match++;\\n        }\\n        return match;\\n    }\\n\\n    int solve(vector<vector<int>>& students, vector<vector<int>>& mentors,int idx, vector<int> s){\\n        if(idx==students.size()){\\n            return 0;\\n        }\\n        int max_score = INT_MIN;\\n        for(int i=0;i<mentors.size();i++){\\n            if(s[i]==0){\\n                s[i] = 1;   \\n                max_score = max(max_score,solve(students,mentors,idx+1,s)+get_score(students,mentors,idx,i));\\n                s[i] = 0;\\n            }\\n        }\\n        return max_score;\\n    }\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<int> s(mentors.size(),0);\\n        return solve(students, mentors, 0, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int get_score(vector<vector<int>>& students, vector<vector<int>>& mentors,int i,int j){\\n        int match = 0;\\n        for(int k=0;k<students[0].size();k++){\\n            if(students[i][k]==mentors[j][k]) match++;\\n        }\\n        return match;\\n    }\\n\\n    int solve(vector<vector<int>>& students, vector<vector<int>>& mentors,int idx, vector<int> s){\\n        if(idx==students.size()){\\n            return 0;\\n        }\\n        int max_score = INT_MIN;\\n        for(int i=0;i<mentors.size();i++){\\n            if(s[i]==0){\\n                s[i] = 1;   \\n                max_score = max(max_score,solve(students,mentors,idx+1,s)+get_score(students,mentors,idx,i));\\n                s[i] = 0;\\n            }\\n        }\\n        return max_score;\\n    }\\n\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<int> s(mentors.size(),0);\\n        return solve(students, mentors, 0, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775292,
                "title": "backtracking-intuitive-solution-with-description-beats-58-in-runtime-and-92-in-memory",
                "content": "# Intuition\\nAt each step, match a student to an available mentor. Keep track of available mentors (those that haven\\'t been matched to a student yet) and the sum of scores for current (student, mentor) pairs.\\n\\n# Approach\\n\\nUse a set to keep track of still available mentors.\\n\\nDon\\'t recompute scores for the same (student, mentor) pair. In fact, pre-compute the scores for all pairs before calling the backtracking function and keep them in a dictionary.\\n\\n# Complexity\\n- Time complexity: O(N), where N is the number of ways of creating (student, mentor) combinations.\\n\\n- Space complexity:\\nO(n^2), where n is the number of students\\n\\n# Code\\n```\\nclass Solution:\\n    def backtrack(self, current_score, current_student, available_mentors, n, all_scores):\\n        if current_student == n:\\n            return current_score\\n        return max([\\n            self.backtrack(\\n                current_score + all_scores[(current_student, mentor)],\\n                current_student + 1,\\n                available_mentors - {mentor},\\n                n,\\n                all_scores\\n            )\\n            for mentor in available_mentors\\n        ])\\n\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        all_scores = {\\n            (idx, jdx): sum([\\n                int(student_answer == mentor_answer)\\n                for student_answer, mentor_answer\\n                in zip(students[idx], mentors[jdx])\\n            ])\\n            for idx in range(len(students))\\n            for jdx in range(len(mentors))\\n        }\\n        return self.backtrack(0, 0, set(range(len(students))), len(students), all_scores)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def backtrack(self, current_score, current_student, available_mentors, n, all_scores):\\n        if current_student == n:\\n            return current_score\\n        return max([\\n            self.backtrack(\\n                current_score + all_scores[(current_student, mentor)],\\n                current_student + 1,\\n                available_mentors - {mentor},\\n                n,\\n                all_scores\\n            )\\n            for mentor in available_mentors\\n        ])\\n\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        all_scores = {\\n            (idx, jdx): sum([\\n                int(student_answer == mentor_answer)\\n                for student_answer, mentor_answer\\n                in zip(students[idx], mentors[jdx])\\n            ])\\n            for idx in range(len(students))\\n            for jdx in range(len(mentors))\\n        }\\n        return self.backtrack(0, 0, set(range(len(students))), len(students), all_scores)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730489,
                "title": "faster-than-10-09-of-python3-online-submissions",
                "content": "```\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        def comptable(i, j):\\n            student = students[i]\\n            mentor = mentors[j]\\n            result = 0\\n            for j, val in enumerate(student):\\n                if val == mentor[j]:\\n                    result += 1 \\n            return result\\n    \\n        n = len(students)   \\n        def dfs(i: int, visited=[]):\\n            if i == n: return 0\\n            result = 0\\n            for j, mentor in enumerate(mentors):\\n                if not j in visited:\\n                    visited.append(j)\\n                    result = max(result, comptable(i, j)+dfs(i+1, visited))\\n                    visited.pop()\\n            return result\\n\\n        result = dfs(0)\\n        return result",
                "solutionTags": [],
                "code": "```\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        def comptable(i, j):\\n            student = students[i]\\n            mentor = mentors[j]\\n            result = 0\\n            for j, val in enumerate(student):\\n                if val == mentor[j]:\\n                    result += 1 \\n            return result\\n    \\n        n = len(students)   \\n        def dfs(i: int, visited=[]):\\n            if i == n: return 0\\n            result = 0\\n            for j, mentor in enumerate(mentors):\\n                if not j in visited:\\n                    visited.append(j)\\n                    result = max(result, comptable(i, j)+dfs(i+1, visited))\\n                    visited.pop()\\n            return result\\n\\n        result = dfs(0)\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2709498,
                "title": "java-backtracking-checking-all-permutations",
                "content": "```\\nclass Solution {\\n    public int answer=Integer.MIN_VALUE;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        \\n        \\n        maxCompatiblitySumHelper(0, students, mentors, 0);\\n        return answer;\\n    }\\n    public void maxCompatiblitySumHelper(int i,int[][] students, int[][] mentors,int sum){\\n        if(i==students.length){\\n            answer=Math.max(sum, answer);\\n            return ;\\n        }\\n    for(int j=i;j<students.length;j++){\\n            int[] student=students[i];\\n            int[] mentor=mentors[j];\\n        int ans=sum+compatabilityScore(student,mentor);\\n        swap(mentors, i, j);\\n        maxCompatiblitySumHelper(i+1, students, mentors, ans);\\n        swap(mentors, i, j);\\n        }\\n        }\\n    public void swap(int[][] arr, int x, int y){\\n        int[] temp=arr[x];\\n        arr[x]=arr[y];\\n        arr[y]=temp;\\n        return;\\n    }\\n    public int compatabilityScore(int[] student, int [] mentor){\\n        int score=0;\\n        for(int i=0;i<student.length;i++){\\n            if(student[i]==mentor[i]){\\n                score++;\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int answer=Integer.MIN_VALUE;\\n    public int maxCompatibilitySum(int[][] students, int[][] mentors) {\\n        \\n        \\n        maxCompatiblitySumHelper(0, students, mentors, 0);\\n        return answer;\\n    }\\n    public void maxCompatiblitySumHelper(int i,int[][] students, int[][] mentors,int sum){\\n        if(i==students.length){\\n            answer=Math.max(sum, answer);\\n            return ;\\n        }\\n    for(int j=i;j<students.length;j++){\\n            int[] student=students[i];\\n            int[] mentor=mentors[j];\\n        int ans=sum+compatabilityScore(student,mentor);\\n        swap(mentors, i, j);\\n        maxCompatiblitySumHelper(i+1, students, mentors, ans);\\n        swap(mentors, i, j);\\n        }\\n        }\\n    public void swap(int[][] arr, int x, int y){\\n        int[] temp=arr[x];\\n        arr[x]=arr[y];\\n        arr[y]=temp;\\n        return;\\n    }\\n    public int compatabilityScore(int[] student, int [] mentor){\\n        int score=0;\\n        for(int i=0;i<student.length;i++){\\n            if(student[i]==mentor[i]){\\n                score++;\\n            }\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700802,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tint ans = 0;\\n\\tvector<int> pos;\\n\\tfor(int i=0;i<students.size();i++) pos.push_back(i);\\n\\tdo{\\n\\t\\tint curr = 0;\\n\\t\\tfor(int i = 0;i<students.size(); i++)\\n\\t\\t\\tfor(int j=0;j<students[pos[i]].size();j++)\\n\\t\\t\\t\\tcurr += (students[pos[i]][j] == mentors[i][j]);\\n\\t\\tans = max(ans, curr);\\n\\t} while(next_permutation(pos.begin(), pos.end()) );\\n\\treturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n\\tint ans = 0;\\n\\tvector<int> pos;\\n\\tfor(int i=0;i<students.size();i++) pos.push_back(i);\\n\\tdo{\\n\\t\\tint curr = 0;\\n\\t\\tfor(int i = 0;i<students.size(); i++)\\n\\t\\t\\tfor(int j=0;j<students[pos[i]].size();j++)\\n\\t\\t\\t\\tcurr += (students[pos[i]][j] == mentors[i][j]);\\n\\t\\tans = max(ans, curr);\\n\\t} while(next_permutation(pos.begin(), pos.end()) );\\n\\treturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696600,
                "title": "python-commented-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        tot=[]\\n        for i in students:\\n            tot.append([-1]*len(mentors))\\n        def returnCount(a,b):          #function to calculate the compatibilty score of a given student and mentor\\n            count=0\\n            for i in range(len(a)):\\n                res=(a[i])^(b[i])\\n                if res==0:\\n                    count+=1\\n            return count\\n        for i in range(len(students)):\\n            for j in range(len(mentors)):\\n                tot[i][j]=returnCount(students[i],mentors[j]) #stores compability score of ith student and jth mentor in 2d-Array tot\\n    \\n        blocked=set()               #keeps track of all the visited columns and thus blocks them in further recursions\\n        def calcMaxi(blocked,row):  #takes in the blocked set of columns, and the current row number as params\\n            if row>=len(tot):       #termination condition\\n                return 0\\n            ans=-1\\n            for i in range(len(tot[0])):   #iterate through all columns\\n                cap=0\\n                if i not in blocked:       #continue only if that column is not part of the blocked columns\\n                    blocked.add(i)\\n                    ans=max(ans,tot[row][i]+calcMaxi(blocked,row+1)) #performing a DFS\\n                    blocked.remove(i)\\n            return ans\\n        return calcMaxi(blocked,0)\\n                    \\n",
                "solutionTags": [
                    "Bit Manipulation",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        tot=[]\\n        for i in students:\\n            tot.append([-1]*len(mentors))\\n        def returnCount(a,b):          #function to calculate the compatibilty score of a given student and mentor\\n            count=0\\n            for i in range(len(a)):\\n                res=(a[i])^(b[i])\\n                if res==0:\\n                    count+=1\\n            return count\\n        for i in range(len(students)):\\n            for j in range(len(mentors)):\\n                tot[i][j]=returnCount(students[i],mentors[j]) #stores compability score of ith student and jth mentor in 2d-Array tot\\n    \\n        blocked=set()               #keeps track of all the visited columns and thus blocks them in further recursions\\n        def calcMaxi(blocked,row):  #takes in the blocked set of columns, and the current row number as params\\n            if row>=len(tot):       #termination condition\\n                return 0\\n            ans=-1\\n            for i in range(len(tot[0])):   #iterate through all columns\\n                cap=0\\n                if i not in blocked:       #continue only if that column is not part of the blocked columns\\n                    blocked.add(i)\\n                    ans=max(ans,tot[row][i]+calcMaxi(blocked,row+1)) #performing a DFS\\n                    blocked.remove(i)\\n            return ans\\n        return calcMaxi(blocked,0)\\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 2695863,
                "title": "python-dfs-solution-bitmask",
                "content": "```\\nThe mask value begins at 0. \\nwhen jth bit of mask is 0, it means jth element is unused.\\nHow to check whether the jth bit value is 0 ?\\nWith bitwise trick for the mask, the jth bit == mask & (1 << j)\\n```\\n\\n```\\ndef maxCompatibilitySum(self, ss: List[List[int]], ms: List[List[int]]) -> int:\\n\\tm, n = len(ss), len(ss[0])\\n\\tss = [reduce(ior, [1<<i for i in range(n) if s[i]] or [0]) for s in ss]\\n\\tms = [reduce(ior, [1<<i for i in range(n) if m[i]] or [0]) for m in ms]\\n\\tscore = [[n-(ss[i]^ms[j]).bit_count() for j in range(m)] for i in range(m)]\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(i, mask):\\n\\t\\tif i == m:\\n\\t\\t\\treturn 0\\n\\t\\treturn max(dfs(i+1, mask | (1 << j)) + score[i][j] for j in range(m) if not mask & (1 << j))\\n\\n\\treturn dfs(0, 0)\\n```\\nSimilar problem:\\n[1879. Minimum XOR Sum of Two Arrays](https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/discuss/2696658/Python-dfs-solution-or-bitmask)",
                "solutionTags": [],
                "code": "```\\nThe mask value begins at 0. \\nwhen jth bit of mask is 0, it means jth element is unused.\\nHow to check whether the jth bit value is 0 ?\\nWith bitwise trick for the mask, the jth bit == mask & (1 << j)\\n```\n```\\ndef maxCompatibilitySum(self, ss: List[List[int]], ms: List[List[int]]) -> int:\\n\\tm, n = len(ss), len(ss[0])\\n\\tss = [reduce(ior, [1<<i for i in range(n) if s[i]] or [0]) for s in ss]\\n\\tms = [reduce(ior, [1<<i for i in range(n) if m[i]] or [0]) for m in ms]\\n\\tscore = [[n-(ss[i]^ms[j]).bit_count() for j in range(m)] for i in range(m)]\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(i, mask):\\n\\t\\tif i == m:\\n\\t\\t\\treturn 0\\n\\t\\treturn max(dfs(i+1, mask | (1 << j)) + score[i][j] for j in range(m) if not mask & (1 << j))\\n\\n\\treturn dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2672034,
                "title": "naive-python-recursive-solution-using-bitmask-to-represent-assignments",
                "content": "I didn\\'t think this solution would pass, but it did and it actually performs quite well according to the percentiles that LC provides.\\n![image](https://assets.leetcode.com/users/images/a6eb89f7-7863-42a8-912e-414e45aaa0f2_1665137985.4009457.png)\\n\\n\\n\\nIt is broken down into two steps.\\n\\n1. Calculate the matrix `compatibility` which is an `m` by `m` matrix whose entries `compatibility[student][mentor]` represent the scores for the student mentor pair. Maybe there is a faster way to do this, but I\\'ve just done it in the way that is most obvious to me.\\n2. Using `compatibility`, find the largest possible sum of column values such that every column is used. In other words, the largest sum that uses a single column for every row and uses all columns (each student has 1 mentor)\\n\\nThe first part is straightforward. You have two `m` by `n` matrices. Each entry in `compatibility` is the sum of the number of entries for which `students[student][question] == mentors[mentor]question`. This will give you an `m` by `m` matrix.\\n\\nThe second part is not at all obvious to me. I was surprised to find that backtracking, even without memoization, would pass (no TLE).\\n\\nHowever, I added the `@functools.cache` so that in case we get to the same `student` and `assigned` we can reuse the result.\\n\\n```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        n = len(students[0])\\n        compatibility = [[0] * m for _ in range(m)]\\n        \\n        for student in range(m):\\n            for mentor in range(m):\\n                compatibility[student][mentor] = sum(x == y for x, y in zip(students[student], mentors[mentor]))\\n        \\n        print(compatibility)\\n        \\n        @functools.cache\\n        def f(student: int, assigned: int) -> int:\\n            if student == m:\\n                return 0\\n            answer = 0\\n            for mentor in range(m):\\n                if (1 << mentor) & assigned == 0:\\n                    answer = max(answer, compatibility[student][mentor] + f(student + 1, assigned ^ (1 << mentor)))\\n            return answer\\n        \\n        return f(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        n = len(students[0])\\n        compatibility = [[0] * m for _ in range(m)]\\n        \\n        for student in range(m):\\n            for mentor in range(m):\\n                compatibility[student][mentor] = sum(x == y for x, y in zip(students[student], mentors[mentor]))\\n        \\n        print(compatibility)\\n        \\n        @functools.cache\\n        def f(student: int, assigned: int) -> int:\\n            if student == m:\\n                return 0\\n            answer = 0\\n            for mentor in range(m):\\n                if (1 << mentor) & assigned == 0:\\n                    answer = max(answer, compatibility[student][mentor] + f(student + 1, assigned ^ (1 << mentor)))\\n            return answer\\n        \\n        return f(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650872,
                "title": "c-memorization-dp-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[8][256];\\n    int solve(int index,int mask,int n,int m,vector<int> &S,vector<int> &M){\\n\\t\\t// if all pairing are done then return 0;\\n        if(mask==(1<<n)-1){\\n            return 0;\\n        }\\n        if(dp[index][mask]!=-1){\\n            return dp[index][mask];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if((mask&(1<<i))==0){\\n                int val1=S[index];\\n                int val2=M[i];\\n\\t\\t\\t\\t// cnt calculate similarity between 2 valus\\n                int cnt=0;\\n                int k=0;\\n                while(k<m){\\n                    if((val1&(1<<k))==(val2&(1<<k))){\\n                        cnt++;\\n                    }\\n                    if((val1&(1<<k))){\\n                        val1=val1^(1<<k);\\n                    }\\n                    if((val2&(1<<k))){\\n                        val2=val2^(1<<k);\\n                    }                    \\n                    k++;\\n                }\\n\\t\\t\\t\\t// maximize the similarity\\n                ans=max(ans,cnt+solve(index+1,mask|(1<<i),n,m,S,M));\\n            }\\n        }\\n        // cout<<index<<\" \"<<ans<<\"\\\\n\";\\n        return dp[index][mask]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>> &students, vector<vector<int>> &mentors) {\\n        int n=students.size();\\n        vector<int> S(n,0);\\n        vector<int> M(n,0);\\n        int m=students[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\t\\t \\t  // convert 1,0 representation to binary number to reduceing size of 2d vector to 1d vector in recursion\\n                S[i]+=students[i][j]*pow(2,j);\\n                M[i]+=mentors[i][j]*pow(2,j);\\n            }\\n        }\\n        memset(dp,-1,sizeof dp);\\n        // vector<vector<int>> dp(n,vector<int>(1<<n,-1));\\n        int mask=0;\\n        return solve(0,mask,n,m,S,M);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[8][256];\\n    int solve(int index,int mask,int n,int m,vector<int> &S,vector<int> &M){\\n\\t\\t// if all pairing are done then return 0;\\n        if(mask==(1<<n)-1){\\n            return 0;\\n        }\\n        if(dp[index][mask]!=-1){\\n            return dp[index][mask];\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if((mask&(1<<i))==0){\\n                int val1=S[index];\\n                int val2=M[i];\\n\\t\\t\\t\\t// cnt calculate similarity between 2 valus\\n                int cnt=0;\\n                int k=0;\\n                while(k<m){\\n                    if((val1&(1<<k))==(val2&(1<<k))){\\n                        cnt++;\\n                    }\\n                    if((val1&(1<<k))){\\n                        val1=val1^(1<<k);\\n                    }\\n                    if((val2&(1<<k))){\\n                        val2=val2^(1<<k);\\n                    }                    \\n                    k++;\\n                }\\n\\t\\t\\t\\t// maximize the similarity\\n                ans=max(ans,cnt+solve(index+1,mask|(1<<i),n,m,S,M));\\n            }\\n        }\\n        // cout<<index<<\" \"<<ans<<\"\\\\n\";\\n        return dp[index][mask]=ans;\\n    }\\n    int maxCompatibilitySum(vector<vector<int>> &students, vector<vector<int>> &mentors) {\\n        int n=students.size();\\n        vector<int> S(n,0);\\n        vector<int> M(n,0);\\n        int m=students[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n\\t\\t \\t  // convert 1,0 representation to binary number to reduceing size of 2d vector to 1d vector in recursion\\n                S[i]+=students[i][j]*pow(2,j);\\n                M[i]+=mentors[i][j]*pow(2,j);\\n            }\\n        }\\n        memset(dp,-1,sizeof dp);\\n        // vector<vector<int>> dp(n,vector<int>(1<<n,-1));\\n        int mask=0;\\n        return solve(0,mask,n,m,S,M);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2624217,
                "title": "maximum-compatibility-score-sum-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN, sum=0;\\n    \\n    int score(vector<int> &a, vector<int> &b){\\n        int res=0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) res++;\\n        }\\n        return res;\\n    }\\n    \\n    void helper(vector<vector<int>> &stu, vector<vector<int>> &ment, vector<bool> &vis, int i){\\n        \\n        if(stu.size()==i) return;\\n        \\n        for(int j=0; j<ment.size(); j++){\\n            if(!vis[j]){\\n                vis[j]=true;\\n                sum+=score(stu[i], ment[j]);\\n                helper(stu, ment, vis, i+1);\\n                ans=max(ans, sum);\\n                sum-=score(stu[i], ment[j]);\\n                vis[j]=false;\\n            }\\n        }\\n        \\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<bool> vis(mentors.size(), 0);\\n        helper(students, mentors, vis, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MIN, sum=0;\\n    \\n    int score(vector<int> &a, vector<int> &b){\\n        int res=0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) res++;\\n        }\\n        return res;\\n    }\\n    \\n    void helper(vector<vector<int>> &stu, vector<vector<int>> &ment, vector<bool> &vis, int i){\\n        \\n        if(stu.size()==i) return;\\n        \\n        for(int j=0; j<ment.size(); j++){\\n            if(!vis[j]){\\n                vis[j]=true;\\n                sum+=score(stu[i], ment[j]);\\n                helper(stu, ment, vis, i+1);\\n                ans=max(ans, sum);\\n                sum-=score(stu[i], ment[j]);\\n                vis[j]=false;\\n            }\\n        }\\n        \\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        vector<bool> vis(mentors.size(), 0);\\n        helper(students, mentors, vis, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616050,
                "title": "ruby-t-o-2-m-n-s-o-m-2-n-2-m-100-100",
                "content": "```\\n# @param {Integer[][]} students\\n# @param {Integer[][]} mentors\\n# @return {Integer}\\ndef max_compatibility_sum(students, mentors)\\n  m = students.size\\n  n = students[0].size\\n\\n  @memo = []\\n  @memo2 = Array.new(m) { [] }\\n  comp_sum(students, mentors, m, n, 0, 0)\\nend\\n\\ndef comp_sum(students, mentors, m, n, student_index, mentor_bm)\\n  return 0 if student_index == m\\n  if cache = @memo[mentor_bm]\\n    return cache\\n  end\\n\\n  max = 0\\n  \\n  0.upto(m - 1) do |mentor_index|\\n    new_bm = mentor_bm | (1 << mentor_index)\\n    next if new_bm == mentor_bm\\n    max = [\\n      max,\\n      compatibility_score(students, mentors, n, student_index, mentor_index) +\\n        comp_sum(students, mentors, m, n, student_index + 1, new_bm)\\n    ].max\\n  end\\n\\n  @memo[mentor_bm] = max\\nend\\n\\ndef compatibility_score(students, mentors, n, student_index, mentor_index)\\n  @memo2[student_index][mentor_index] ||= begin\\n    score = 0\\n    student = students[student_index]\\n    mentor = mentors[mentor_index]\\n    0.upto(n - 1) do |i|\\n      score += 1 if student[i] == mentor[i]\\n    end\\n    score\\n  end\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} students\\n# @param {Integer[][]} mentors\\n# @return {Integer}\\ndef max_compatibility_sum(students, mentors)\\n  m = students.size\\n  n = students[0].size\\n\\n  @memo = []\\n  @memo2 = Array.new(m) { [] }\\n  comp_sum(students, mentors, m, n, 0, 0)\\nend\\n\\ndef comp_sum(students, mentors, m, n, student_index, mentor_bm)\\n  return 0 if student_index == m\\n  if cache = @memo[mentor_bm]\\n    return cache\\n  end\\n\\n  max = 0\\n  \\n  0.upto(m - 1) do |mentor_index|\\n    new_bm = mentor_bm | (1 << mentor_index)\\n    next if new_bm == mentor_bm\\n    max = [\\n      max,\\n      compatibility_score(students, mentors, n, student_index, mentor_index) +\\n        comp_sum(students, mentors, m, n, student_index + 1, new_bm)\\n    ].max\\n  end\\n\\n  @memo[mentor_bm] = max\\nend\\n\\ndef compatibility_score(students, mentors, n, student_index, mentor_index)\\n  @memo2[student_index][mentor_index] ||= begin\\n    score = 0\\n    student = students[student_index]\\n    mentor = mentors[mentor_index]\\n    0.upto(n - 1) do |i|\\n      score += 1 if student[i] == mentor[i]\\n    end\\n    score\\n  end\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 2606867,
                "title": "c-backtracking-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int sum1=0,sum2=0;\\n\\t\\n    //function to match the student and mentor\\n    int score(vector<int>&a, vector<int>&b){\\n        int ans=0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(int i, vector<vector<int>>& students, vector<vector<int>>& mentors, vector<bool>&vis){\\n        if(i>=students.size()) return; //base condition\\n\\n        for(int k=0; k<mentors.size(); k++){\\n            if( vis[k]==0){\\n                vis[k]=1;\\n                sum1+=score(students[i], mentors[k]); //add score to the sum\\n                solve(i+1,students,mentors, vis); //calculate for next\\n                sum2=max(sum2,sum1); //when reach end take maximum\\n                vis[k]=0; //backtrack\\n                sum1-=score(students[i], mentors[k]); //remove the scores\\n            }\\n        }\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=students.size();\\n        vector<bool>vis(n,0);\\n        solve(0,students,mentors, vis);\\n        return sum2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum1=0,sum2=0;\\n\\t\\n    //function to match the student and mentor\\n    int score(vector<int>&a, vector<int>&b){\\n        int ans=0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(int i, vector<vector<int>>& students, vector<vector<int>>& mentors, vector<bool>&vis){\\n        if(i>=students.size()) return; //base condition\\n\\n        for(int k=0; k<mentors.size(); k++){\\n            if( vis[k]==0){\\n                vis[k]=1;\\n                sum1+=score(students[i], mentors[k]); //add score to the sum\\n                solve(i+1,students,mentors, vis); //calculate for next\\n                sum2=max(sum2,sum1); //when reach end take maximum\\n                vis[k]=0; //backtrack\\n                sum1-=score(students[i], mentors[k]); //remove the scores\\n            }\\n        }\\n    }\\n    \\n    int maxCompatibilitySum(vector<vector<int>>& students, vector<vector<int>>& mentors) {\\n        int n=students.size();\\n        vector<bool>vis(n,0);\\n        solve(0,students,mentors, vis);\\n        return sum2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1731084,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "How is the output for\\n```\\n[[0,1,0,1,1,1],[1,0,0,1,0,1],[1,0,1,1,0,0]]\\n[[1,0,0,0,0,1],[0,1,0,0,1,1],[0,1,0,0,1,1]]\\n```\\n**10** ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "0th with 1st = 5\\n1st with 0th = 5\\n2nd with 2nd = 0"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "How can be solve according to hint. Calculating compatibility score with respect to each mentor given me matrix of same size as student. Then how to proceed ?\\n\\nLike for this testcase:\\nstudents =\\n[[1,1,0],[1,0,1],[0,0,1]]\\nmentors =\\n[[1,0,0],[0,0,1],[1,1,0]]\\n\\nCompatibility score :\\n2 0 3 (student 1 with respect to each mentor)\\n2 2 1 \\n1 3 0 \\n\\nNow how to code for choosing one and eliminate other ?\\nPlease help me out if possible."
                    }
                ]
            },
            {
                "id": 1872911,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "How is the output for\\n```\\n[[0,1,0,1,1,1],[1,0,0,1,0,1],[1,0,1,1,0,0]]\\n[[1,0,0,0,0,1],[0,1,0,0,1,1],[0,1,0,0,1,1]]\\n```\\n**10** ?"
                    },
                    {
                        "username": "c4tdog",
                        "content": "0th with 1st = 5\\n1st with 0th = 5\\n2nd with 2nd = 0"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "How can be solve according to hint. Calculating compatibility score with respect to each mentor given me matrix of same size as student. Then how to proceed ?\\n\\nLike for this testcase:\\nstudents =\\n[[1,1,0],[1,0,1],[0,0,1]]\\nmentors =\\n[[1,0,0],[0,0,1],[1,1,0]]\\n\\nCompatibility score :\\n2 0 3 (student 1 with respect to each mentor)\\n2 2 1 \\n1 3 0 \\n\\nNow how to code for choosing one and eliminate other ?\\nPlease help me out if possible."
                    }
                ]
            }
        ]
    }
]