[
    {
        "title": "Valid Sudoku",
        "question_content": "Determine if a&nbsp;9 x 9 Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;according to the following rules:\n\n\tEach row&nbsp;must contain the&nbsp;digits&nbsp;1-9 without repetition.\n\tEach column must contain the digits&nbsp;1-9&nbsp;without repetition.\n\tEach of the nine&nbsp;3 x 3 sub-boxes of the grid must contain the digits&nbsp;1-9&nbsp;without repetition.\n\nNote:\n\n\tA Sudoku board (partially filled) could be valid but is not necessarily solvable.\n\tOnly the filled cells need to be validated according to the mentioned&nbsp;rules.\n\n&nbsp;\nExample 1:\n\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\n\nExample 2:\n\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n\n&nbsp;\nConstraints:\n\n\tboard.length == 9\n\tboard[i].length == 9\n\tboard[i][j] is a digit 1-9 or '.'.",
        "solutions": [
            {
                "id": 15472,
                "title": "short-simple-java-using-strings",
                "content": "Collect the set of things we see, encoded as strings. For example:\\n\\n- `'4' in row 7` is encoded as `\"(4)7\"`.\\n- `'4' in column 7` is encoded as `\"7(4)\"`.\\n- `'4' in the top-right block` is encoded as `\"0(4)2\"`.\\n\\nScream `false` if we ever fail to add something because it was already added (i.e., seen before).\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != '.') {\\n                    String b = \"(\" + board[i][j] + \")\";\\n                    if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n---\\n\\n**Edit:** Just occurred to me that we can also make it really clear and self-explaining. I'm loving it.\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                char number = board[i][j];\\n                if (number != '.')\\n                    if (!seen.add(number + \" in row \" + i) ||\\n                        !seen.add(number + \" in column \" + j) ||\\n                        !seen.add(number + \" in block \" + i/3 + \"-\" + j/3))\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Collect the set of things we see, encoded as strings. For example:\\n\\n- `'4' in row 7` is encoded as `\"(4)7\"`.\\n- `'4' in column 7` is encoded as `\"7(4)\"`.\\n- `'4' in the top-right block` is encoded as `\"0(4)2\"`.\\n\\nScream `false` if we ever fail to add something because it was already added (i.e., seen before).\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != '.') {\\n                    String b = \"(\" + board[i][j] + \")\";\\n                    if (!seen.add(b + i) || !seen.add(j + b) || !seen.add(i/3 + b + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n---\\n\\n**Edit:** Just occurred to me that we can also make it really clear and self-explaining. I'm loving it.\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set seen = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                char number = board[i][j];\\n                if (number != '.')\\n                    if (!seen.add(number + \" in row \" + i) ||\\n                        !seen.add(number + \" in column \" + j) ||\\n                        !seen.add(number + \" in block \" + i/3 + \"-\" + j/3))\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15464,
                "title": "my-short-solution-by-c-o-n2",
                "content": "Three flags are used to check whether a number appear.\\n\\nused1: check each row\\n\\nused2: check each column\\n\\nused3: check each sub-boxes\\n \\n    class Solution\\n    {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board)\\n        {\\n            int used1[9][9] = {0}, used2[9][9] = {0}, used3[9][9] = {0};\\n            \\n            for(int i = 0; i < board.size(); ++ i)\\n                for(int j = 0; j < board[i].size(); ++ j)\\n                    if(board[i][j] != '.')\\n                    {\\n                        int num = board[i][j] - '0' - 1, k = i / 3 * 3 + j / 3;\\n                        if(used1[i][num] || used2[j][num] || used3[k][num])\\n                            return false;\\n                        used1[i][num] = used2[j][num] = used3[k][num] = 1;\\n                    }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board)\\n        {\\n            int used1[9][9] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 15451,
                "title": "a-readable-python-solution",
                "content": "Apparently not the shortest solution but I think it's easy to follow the logic.\\n\\n    \\n    def isValidSudoku(self, board):\\n        return (self.is_row_valid(board) and\\n                self.is_col_valid(board) and\\n                self.is_square_valid(board))\\n    \\n    def is_row_valid(self, board):\\n        for row in board:\\n            if not self.is_unit_valid(row):\\n                return False\\n        return True\\n    \\n    def is_col_valid(self, board):\\n        for col in zip(*board):\\n            if not self.is_unit_valid(col):\\n                return False\\n        return True\\n        \\n    def is_square_valid(self, board):\\n        for i in (0, 3, 6):\\n            for j in (0, 3, 6):\\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\\n                if not self.is_unit_valid(square):\\n                    return False\\n        return True\\n        \\n    def is_unit_valid(self, unit):\\n        unit = [i for i in unit if i != '.']\\n        return len(set(unit)) == len(unit)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Apparently not the shortest solution but I think it's easy to follow the logic.\\n\\n    \\n    def isValidSudoku(self, board):\\n        return (self.is_row_valid(board) and\\n                self.is_col_valid(board) and\\n                self.is_square_valid(board))\\n    \\n    def is_row_valid(self, board):\\n        for row in board:\\n            if not self.is_unit_valid(row):\\n                return False\\n        return True\\n    \\n    def is_col_valid(self, board):\\n        for col in zip(*board):\\n            if not self.is_unit_valid(col):\\n                return False\\n        return True\\n        \\n    def is_square_valid(self, board):\\n        for i in (0, 3, 6):\\n            for j in (0, 3, 6):\\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\\n                if not self.is_unit_valid(square):\\n                    return False\\n        return True\\n        \\n    def is_unit_valid(self, unit):\\n        unit = [i for i in unit if i != '.']\\n        return len(set(unit)) == len(unit)",
                "codeTag": "Python3"
            },
            {
                "id": 15450,
                "title": "shared-my-concise-java-code",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        for(int i = 0; i<9; i++){\\n            HashSet<Character> rows = new HashSet<Character>();\\n            HashSet<Character> columns = new HashSet<Character>();\\n            HashSet<Character> cube = new HashSet<Character>();\\n            for (int j = 0; j < 9;j++){\\n                if(board[i][j]!='.' && !rows.add(board[i][j]))\\n                    return false;\\n                if(board[j][i]!='.' && !columns.add(board[j][i]))\\n                    return false;\\n                int RowIndex = 3*(i/3);\\n                int ColIndex = 3*(i%3);\\n                if(board[RowIndex + j/3][ColIndex + j%3]!='.' && !cube.add(board[RowIndex + j/3][ColIndex + j%3]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        for(int i = 0; i<9; i++){\\n            HashSet<Character> rows = new HashSet<Character>();\\n            HashSet<Character> columns = new HashSet<Character>();\\n            HashSet<Character> cube = new HashSet<Character>();\\n            for (int j = 0; j < 9;j++){\\n                if(board[i][j]!='.' && !rows.add(board[i][j]))\\n                    return false;\\n                if(board[j][i]!='.' && !columns.add(board[j][i]))\\n                    return false;\\n                int RowIndex = 3*(i/3);\\n                int ColIndex = 3*(i%3);\\n                if(board[RowIndex + j/3][ColIndex + j%3]!='.' && !cube.add(board[RowIndex + j/3][ColIndex + j%3]))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15616,
                "title": "my-12-lines-c-c-solution-with-1-time-traversal-and-9x9x3-memory",
                "content": "\\n    int isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n        int rows[9][9]={0}; //rows[5][0] means whether number 1('0'+1) in row 5 has appeared.\\n    \\tint cols[9][9]={0}; //cols[3][8] means whether number 9('8'+1) in col 3 has appeared.\\n    \\tint blocks[3][3][9]={0};//blocks[0][2][5] means whether number '6' in block 0,2 (row 0~2,col 6~8) has appeared.\\n    \\tfor(int r=0;r<9;r++)    //traverse board r,c\\n    \\t\\tfor(int c=0;c<9;c++)\\n    \\t\\t\\tif(board[r][c]!='.'){   //skip all number '.'\\n    \\t\\t\\t\\tint number=board[r][c]-'1'; //calculate the number's index(board's number minus 1)\\n    \\t\\t\\t\\tif(rows[r][number]++) return 0; //if the number has already appeared once, return false.\\n    \\t\\t\\t\\tif(cols[c][number]++) return 0;\\n    \\t\\t\\t\\tif(blocks[r/3][c/3][number]++) return 0;\\n    \\t\\t\\t}\\n    \\treturn 1;\\n    }",
                "solutionTags": [],
                "code": "\\n    int isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n        int rows[9][9]={0}; //rows[5][0] means whether number 1('0'+1) in row 5 has appeared.\\n    \\tint cols[9][9]={0}; //cols[3][8] means whether number 9('8'+1) in col 3 has appeared.\\n    \\tint blocks[3][3][9]={0};//blocks[0][2][5] means whether number '6' in block 0,2 (row 0~2,col 6~8) has appeared.\\n    \\tfor(int r=0;r<9;r++)    //traverse board r,c\\n    \\t\\tfor(int c=0;c<9;c++)\\n    \\t\\t\\tif(board[r][c]!='.'){   //skip all number '.'\\n    \\t\\t\\t\\tint number=board[r][c]-'1'; //calculate the number's index(board's number minus 1)\\n    \\t\\t\\t\\tif(rows[r][number]++) return 0; //if the number has already appeared once, return false.\\n    \\t\\t\\t\\tif(cols[c][number]++) return 0;\\n    \\t\\t\\t\\tif(blocks[r/3][c/3][number]++) return 0;\\n    \\t\\t\\t}\\n    \\treturn 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 15460,
                "title": "1-7-lines-python-4-solutions",
                "content": "**Idea**\\n\\nJust go through all you see (like \"7 in row 3\") and check for duplicates.\\n\\n**Solution 1**\\n\\nUsing `Counter`. One logical line, seven physical lines.\\n\\n    def isValidSudoku(self, board):\\n        return 1 == max(collections.Counter(\\n            x\\n            for i, row in enumerate(board)\\n            for j, c in enumerate(row)\\n            if c != '.'\\n            for x in ((c, i), (j, c), (i/3, j/3, c))\\n        ).values() + [1])\\n\\nThe ` + [1]` is only for the empty board, where `max` would get an empty list and complain. It's not necessary to get it accepted here, as the empty board isn't among the test cases, but it's good to have.\\n\\n**Solution 2**\\n\\nUsing `len(set)`.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i, row in enumerate(board)\\n                    for j, c in enumerate(row)\\n                    if c != '.'), [])\\n        return len(seen) == len(set(seen))\\n\\n**Solution 3**\\n\\nUsing `any`.\\n\\n    def isValidSudoku(self, board):\\n        seen = set()\\n        return not any(x in seen or seen.add(x)\\n                       for i, row in enumerate(board)\\n                       for j, c in enumerate(row)\\n                       if c != '.'\\n                       for x in ((c, i), (j, c), (i/3, j/3, c)))\\n\\n**Solution 4**\\n\\nIterating a different way.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i in range(9) for j in range(9)\\n                    for c in [board[i][j]] if c != '.'), [])\\n        return len(seen) == len(set(seen))",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Idea**\\n\\nJust go through all you see (like \"7 in row 3\") and check for duplicates.\\n\\n**Solution 1**\\n\\nUsing `Counter`. One logical line, seven physical lines.\\n\\n    def isValidSudoku(self, board):\\n        return 1 == max(collections.Counter(\\n            x\\n            for i, row in enumerate(board)\\n            for j, c in enumerate(row)\\n            if c != '.'\\n            for x in ((c, i), (j, c), (i/3, j/3, c))\\n        ).values() + [1])\\n\\nThe ` + [1]` is only for the empty board, where `max` would get an empty list and complain. It's not necessary to get it accepted here, as the empty board isn't among the test cases, but it's good to have.\\n\\n**Solution 2**\\n\\nUsing `len(set)`.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i, row in enumerate(board)\\n                    for j, c in enumerate(row)\\n                    if c != '.'), [])\\n        return len(seen) == len(set(seen))\\n\\n**Solution 3**\\n\\nUsing `any`.\\n\\n    def isValidSudoku(self, board):\\n        seen = set()\\n        return not any(x in seen or seen.add(x)\\n                       for i, row in enumerate(board)\\n                       for j, c in enumerate(row)\\n                       if c != '.'\\n                       for x in ((c, i), (j, c), (i/3, j/3, c)))\\n\\n**Solution 4**\\n\\nIterating a different way.\\n\\n    def isValidSudoku(self, board):\\n        seen = sum(([(c, i), (j, c), (i/3, j/3, c)]\\n                    for i in range(9) for j in range(9)\\n                    for c in [board[i][j]] if c != '.'), [])\\n        return len(seen) == len(set(seen))",
                "codeTag": "Python3"
            },
            {
                "id": 476369,
                "title": "javascript-solution-beats-100-with-explanation-real-explanations",
                "content": "Adopted from [@Lorraine921](https://leetcode.com/lorraine921)\\'s answer [here](https://leetcode.com/problems/valid-sudoku/discuss/15450/Shared-my-concise-Java-code) if anyone wants to check out the original answer. I wanted to share some of my thoughts as I was going through the solution:\\n\\n**Thinking**\\nBasically we need to check three things:\\n\\n1. Are there duplicates in each row? If yes, `return false`\\n2. Are there duplicates in each column? If yes, `return false`\\n3. Are there duplicates in each 3x3 box? If yes, `return false`\\n\\nif everything passes, `return true` at the end.\\n\\nWhen dealing with checking for duplicates, we use a Hash Set. \\n\\n**Representations**\\nLet\\'s deal with rows and columns first because it\\'s easier to tackle:\\n\\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tlet row = new Set(); /* row Set */\\n\\tlet col = new Set(); /* column Set */\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[i][j] /* iterating row by row */\\n\\t\\tboard[j][i] /* iterating column by column */\\n\\t}\\n}\\n```\\nSo as we go through each row/column we add unseen number to the row/column `Set` accordingly. If `Set` has seen it, we `return false`.\\n```\\n/* example */\\nif (item != \\'.\\') {\\n\\tif (row.has(item)) return false;\\n\\trow.add(item);\\n}\\n```\\nNow let\\'s ace the 3x3 box iterating inside the same loop:\\nThis is a illustration of a sudoku in nine 3x3 boxes with each cell represented by a two-digit number `ij` (`i` means row index and `j` means column index).\\n```\\n00 01 02 | 03 04 05 | 06 07 08\\n10 11 12 | 13 14 15 | 16 17 18  // i = 0, 1, 2\\n20 21 22 | 23 24 25 | 26 27 28\\n------------------------------\\n30 31 32 | 33 34 35 | 36 37 38\\n40 41 42 | 43 44 45 | 46 47 48  // i = 3, 4, 5\\n50 51 52 | 53 54 55 | 56 57 58\\n------------------------------\\n60 61 62 | 63 64 65 | 66 67 68 \\n70 71 72 | 73 74 75 | 76 77 78  // i = 6, 7, 8\\n80 81 82 | 83 84 85 | 86 87 88\\n```\\nHow do we iterate using `i`, `j`, and `3`(because its 3x3)? \\nWe use `/` and `%` to help!\\n```\\t  \\nBecause we only want to start vertical traversal when horizontal traversal is done. \\n\\nUse / for vertical traversal because\\nMath.floor(0 / 3) = 0\\nMath.floor(1 / 3) = 0\\nMath.floor(2 / 3) = 0\\n\\nUse % for horizontal traversal beause \\n0 % 3 = 0\\n1 % 3 = 1\\n2 % 3 = 2\\n```\\nWe can represent the 3x3 box as:\\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[3 * Math.floor(i/3) + Math.floor(j/3)][3 * i%3 + j%3]\\n\\t}\\n}\\n```\\n**Code**\\n```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(),\\n        col = new Set(),\\n        box = new Set();\\n\\n    for (let j = 0; j < 9; j++) {\\n      let _row = board[i][j];\\n      let _col = board[j][i];\\n      let _box = board[3*Math.floor(i/3)+Math.floor(j/3)][3*(i%3)+(j%3)]\\n      \\n      if (_row != \\'.\\') {\\n        if (row.has(_row)) return false;\\n        row.add(_row);\\n      }\\n      if (_col != \\'.\\') {\\n        if (col.has(_col)) return false;\\n        col.add(_col);\\n      }\\n      \\n      if (_box != \\'.\\') {\\n        if (box.has(_box)) return false;\\n        box.add(_box);\\n      } \\n    }\\n  }\\n  return true\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor (let i = 0; i < 9; i++) {\\n\\tlet row = new Set(); /* row Set */\\n\\tlet col = new Set(); /* column Set */\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[i][j] /* iterating row by row */\\n\\t\\tboard[j][i] /* iterating column by column */\\n\\t}\\n}\\n```\n```\\n/* example */\\nif (item != \\'.\\') {\\n\\tif (row.has(item)) return false;\\n\\trow.add(item);\\n}\\n```\n```\\n00 01 02 | 03 04 05 | 06 07 08\\n10 11 12 | 13 14 15 | 16 17 18  // i = 0, 1, 2\\n20 21 22 | 23 24 25 | 26 27 28\\n------------------------------\\n30 31 32 | 33 34 35 | 36 37 38\\n40 41 42 | 43 44 45 | 46 47 48  // i = 3, 4, 5\\n50 51 52 | 53 54 55 | 56 57 58\\n------------------------------\\n60 61 62 | 63 64 65 | 66 67 68 \\n70 71 72 | 73 74 75 | 76 77 78  // i = 6, 7, 8\\n80 81 82 | 83 84 85 | 86 87 88\\n```\n```\\t  \\nBecause we only want to start vertical traversal when horizontal traversal is done. \\n\\nUse / for vertical traversal because\\nMath.floor(0 / 3) = 0\\nMath.floor(1 / 3) = 0\\nMath.floor(2 / 3) = 0\\n\\nUse % for horizontal traversal beause \\n0 % 3 = 0\\n1 % 3 = 1\\n2 % 3 = 2\\n```\n```\\nfor (let i = 0; i < 9; i++) {\\n\\tfor(let j = 0; j < 9; j++) {\\n\\t\\tboard[3 * Math.floor(i/3) + Math.floor(j/3)][3 * i%3 + j%3]\\n\\t}\\n}\\n```\n```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(),\\n        col = new Set(),\\n        box = new Set();\\n\\n    for (let j = 0; j < 9; j++) {\\n      let _row = board[i][j];\\n      let _col = board[j][i];\\n      let _box = board[3*Math.floor(i/3)+Math.floor(j/3)][3*(i%3)+(j%3)]\\n      \\n      if (_row != \\'.\\') {\\n        if (row.has(_row)) return false;\\n        row.add(_row);\\n      }\\n      if (_col != \\'.\\') {\\n        if (col.has(_col)) return false;\\n        col.add(_col);\\n      }\\n      \\n      if (_box != \\'.\\') {\\n        if (box.has(_box)) return false;\\n        box.add(_box);\\n      } \\n    }\\n  }\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332984,
                "title": "c-simple-and-easy-10-short-line-solution",
                "content": "For each row, column and block we keep a set of numbers.\\nIf we find a number that was seen already in that row, column or block - return false.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15452,
                "title": "c-very-simple-and-easy-understand-using-bit-operation",
                "content": "       bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<short> col(9, 0);\\n        vector<short> block(9, 0);\\n        vector<short> row(9, 0);\\n        for (int i = 0; i < 9; i++)\\n         for (int j = 0; j < 9; j++) {\\n             if (board[i][j] != '.') {\\n                 int idx = 1 << (board[i][j] - '0');\\n                 if (row[i] & idx || col[j] & idx || block[i/3 * 3 + j / 3] & idx)\\n                    return false;\\n                row[i] |= idx;\\n                col[j] |= idx;\\n                block[i/3 * 3 + j/3] |= idx;\\n             }\\n         }\\n         return true;\\n      }",
                "solutionTags": [],
                "code": "       bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<short> col(9, 0);\\n        vector<short> block(9, 0);\\n        vector<short> row(9, 0);\\n        for (int i = 0; i < 9; i++)\\n         for (int j = 0; j < 9; j++) {\\n             if (board[i][j] != '.') {\\n                 int idx = 1 << (board[i][j] - '0');\\n                 if (row[i] & idx || col[j] & idx || block[i/3 * 3 + j / 3] & idx)\\n                    return false;\\n                row[i] |= idx;\\n                col[j] |= idx;\\n                block[i/3 * 3 + j/3] |= idx;\\n             }\\n         }\\n         return true;\\n      }",
                "codeTag": "Unknown"
            },
            {
                "id": 15509,
                "title": "clean-and-easy82ms-python",
                "content": "class Solution(object):\\n\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        big = set()\\n        for i in xrange(0,9):\\n            for j in xrange(0,9):\\n                if board[i][j]!='.':\\n                    cur = board[i][j]\\n                    if (i,cur) in big or (cur,j) in big or (i/3,j/3,cur) in big:\\n                        return False\\n                    big.add((i,cur))\\n                    big.add((cur,j))\\n                    big.add((i/3,j/3,cur))\\n        return True",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "class Solution(object):\\n\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        big = set()\\n        for i in xrange(0,9):\\n            for j in xrange(0,9):\\n                if board[i][j]!='.':\\n                    cur = board[i][j]\\n                    if (i,cur) in big or (cur,j) in big or (i/3,j/3,cur) in big:\\n                        return False\\n                    big.add((i,cur))\\n                    big.add((cur,j))\\n                    big.add((i/3,j/3,cur))\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3277043,
                "title": "beats-96-78-short-7-line-python-solution-with-detailed-explanation",
                "content": "\\n1)It initializes an empty list called \"res\", which will be used to store all the valid elements in the board.\\n\\n2)It loops through each cell in the board using two nested \"for\" loops.\\nFor each cell, it retrieves the value of the element in that cell and stores it in a variable called \"element\".\\n\\n3)If the element is not a dot (\\'.\\'), which means it\\'s a valid number, the method adds three tuples to the \"res\" list:\\n\\n- The first tuple contains the row index (i) and the element itself.\\n- The second tuple contains the element itself and the column index (j).\\n- The third tuple contains the floor division of the row index by 3 (i // 3), the floor division of the column index by 3 (j // 3), and the element itself. This tuple represents the 3x3 sub-grid that the current cell belongs to.\\n\\n4)After processing all the cells, the method checks if the length of \"res\" is equal to the length of the set of \"res\".\\n\\n```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        res = []\\n        for i in range(9):\\n            for j in range(9):\\n                element = board[i][j]\\n                if element != \\'.\\':\\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\\n        return len(res) == len(set(res))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        res = []\\n        for i in range(9):\\n            for j in range(9):\\n                element = board[i][j]\\n                if element != \\'.\\':\\n                    res += [(i, element), (element, j), (i // 3, j // 3, element)]\\n        return len(res) == len(set(res))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15634,
                "title": "sharing-my-easy-understand-java-solution-using-set",
                "content": "    public class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int i=0; i<9; i++) {\\n            if (!isParticallyValid(board,i,0,i,8)) return false;\\n            if (!isParticallyValid(board,0,i,8,i)) return false;\\n        }\\n        for (int i=0;i<3;i++){\\n            for(int j=0;j<3;j++){\\n                if (!isParticallyValid(board,i*3,j*3,i*3+2,j*3+2)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isParticallyValid(char[][] board, int x1, int y1,int x2,int y2){\\n        Set singleSet = new HashSet();\\n        for (int i= x1; i<=x2; i++){\\n            for (int j=y1;j<=y2; j++){\\n                if (board[i][j]!='.') if(!singleSet.add(board[i][j])) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\nEach time send the coordinates to check if the board is partially valid.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int i=0; i<9; i++) {\\n            if (!isParticallyValid(board,i,0,i,8)) return false;\\n            if (!isParticallyValid(board,0,i,8,i)) return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1414911,
                "title": "c-java-python-2-solutions-hashset-bitmasking-clean-concise-o-49",
                "content": "**\\u2714\\uFE0F Solution 1: Hash Set**\\n- The idea is super easy.\\n- For each row, we create a HashSet to check for duplicates in each row.\\n- For each column, we also create a HashSet to check for duplicates in each column.\\n- For each square, we also create a HashSet to check for duplicates in each square, but we need to convert the position `(r, c)` in the board to square by:\\n\\t- Square row: `sr = r / 3`.\\n\\t- Square col: `sc = c / 3`.\\n\\t- Square position: `sPos = sr * 3 + sc`.\\n\\n<iframe src=\"https://leetcode.com/playground/kopzUL7z/shared\" frameBorder=\"0\" width=\"100%\" height=\"520\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bitmasking (Beat 100%)**\\n- Since we only need to store 2 states (exist, not exist) and store up to 9 positions.\\n- So to save space, we can store in the bitmask, `i` th bit represent the existence of the number `i`.\\n\\n<iframe src=\"https://leetcode.com/playground/cnqUk6bW/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Hash Set**\\n- The idea is super easy.\\n- For each row, we create a HashSet to check for duplicates in each row.\\n- For each column, we also create a HashSet to check for duplicates in each column.\\n- For each square, we also create a HashSet to check for duplicates in each square, but we need to convert the position `(r, c)` in the board to square by:\\n\\t- Square row: `sr = r / 3`.\\n\\t- Square col: `sc = c / 3`.\\n\\t- Square position: `sPos = sr * 3 + sc`.\\n\\n<iframe src=\"https://leetcode.com/playground/kopzUL7z/shared\" frameBorder=\"0\" width=\"100%\" height=\"520\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N^2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bitmasking (Beat 100%)**\\n- Since we only need to store 2 states (exist, not exist) and store up to 9 positions.\\n- So to save space, we can store in the bitmask, `i` th bit represent the existence of the number `i`.\\n\\n<iframe src=\"https://leetcode.com/playground/cnqUk6bW/shared\" frameBorder=\"0\" width=\"100%\" height=\"450\"></iframe>\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N = 9`. \\n- Space: `O(N)`",
                "codeTag": "Unknown"
            },
            {
                "id": 15560,
                "title": "yet-another-java-2ms-solution",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        int [] vset = new int [9];\\n        int [] hset = new int [9];\\n        int [] bckt = new int [9];\\n        int idx = 0;\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    idx = 1 << (board[i][j] - '0') ;\\n                    if ((hset[i] & idx) > 0 ||\\n                        (vset[j] & idx) > 0 ||\\n                        (bckt[(i / 3) * 3 + j / 3] & idx) > 0) return false;\\n                    hset[i] |= idx;\\n                    vset[j] |= idx;\\n                    bckt[(i / 3) * 3 + j / 3] |= idx;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        int [] vset = new int [9];\\n        int [] hset = new int [9];\\n        int [] bckt = new int [9];\\n        int idx = 0;\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    idx = 1 << (board[i][j] - '0') ;\\n                    if ((hset[i] & idx) > 0 ||\\n                        (vset[j] & idx) > 0 ||\\n                        (bckt[(i / 3) * 3 + j / 3] & idx) > 0) return false;\\n                    hset[i] |= idx;\\n                    vset[j] |= idx;\\n                    bckt[(i / 3) * 3 + j / 3] |= idx;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2572765,
                "title": "python-explained-steps-clean-code-best-method",
                "content": "Hello!\\n\\nTo solve this problem we have to check if each value in sudoku does not repeat in its:\\n1. column\\n2. row\\n3. square\\n\\nTo do this efficiently we will use **sets** to store elements in columns, rows and squares. This is easy to define column and row (by single index), but squares are defined using two indexes. We will use **//** (floor division) operator to know in which square we are right now.\\n\\nIndexes range from **0** to **8**. \\n0 // 3 = 0\\n1 // 3 = 0\\n2 // 3 = 0\\n3 // 3 = 1\\n4 // 3 = 1\\n5 // 3 = 1\\n6 // 3 = 2\\n7 // 3 = 2\\n8 // 3 = 2\\n\\nWe got 3 different values for each range (0-2: **0**, 3-5: **1**, 6-8: **2**), so we can use it to know in which square are currently are (by getting square **x** and **y** coordinate, we need 9 squares with indexes (0, 0), (0, 1), (0, 2), (1,0), ..., (2, 2)).\\n\\nIn code we do nothing if we meet **.** symbol, but if we have **digit** in cell, then we check if it is in cell\\'s row, column or square. \\nIf **yes**, then it means that the value is repeated, so sudoku is not valid one, so we return **False**.\\n\\nAfter checking, we add this value to its row, column and square.\\nIf number occurs 2 times in given row, cell or square, then the 2nd occurence is going to trigger **False** return (because in first occurence we add the value to the **sets**).\\n\\nCode:\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for x in range(9)]\\n        columns = [set() for x in range(9)]\\n        squares = [[set() for x in range(3)] for y in range(3)]\\n        \\n        for x in range(9):\\n            for y in range(9):\\n                cell_value = board[x][y]\\n                if cell_value == \".\":\\n                    continue\\n                if cell_value in rows[x] or cell_value in columns[y] or cell_value in squares[x//3][y//3]:\\n                    return False\\n\\n                rows[x].add(cell_value)\\n                columns[y].add(cell_value)\\n                squares[x//3][y//3].add(cell_value)\\n        \\n        return True\\n```\\n\\nPlease upvote if it was helpful :))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for x in range(9)]\\n        columns = [set() for x in range(9)]\\n        squares = [[set() for x in range(3)] for y in range(3)]\\n        \\n        for x in range(9):\\n            for y in range(9):\\n                cell_value = board[x][y]\\n                if cell_value == \".\":\\n                    continue\\n                if cell_value in rows[x] or cell_value in columns[y] or cell_value in squares[x//3][y//3]:\\n                    return False\\n\\n                rows[x].add(cell_value)\\n                columns[y].add(cell_value)\\n                squares[x//3][y//3].add(cell_value)\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461845,
                "title": "simple-solution-using-set-in-c",
                "content": "**If you understand the approach please upvote!!!**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //since we have to verify that each element is appears once or not... for that purpose here we use \\n        //vector of sets since set stores only unique entries\\n        vector<set<int>> rows(9),cols(9),blocks(9); \\n        \\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                //if board[i][j] entry is \\'.\\' then we just continue as we only care about the duplicate values\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                int curr = board[i][j]; //we can get the value at given index to check that if it is already \\n                // present in set or not\\n                \\n                //here our count function returns 1 if value is already present in row or column or block otherwise it will return 0\\n                \\n                //for block try this formula using pen and paper you will get it..\\n                if(rows[i].count(curr) || cols[j].count(curr) ||\\n                  blocks[(i/3)*3 + j/3].count(curr)){\\n                    return false; //we return false because the value currently we have is already present in set\\n                }\\n                //if we don\\'t found the value then after that we must enter this value in our set\\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3*3) + j/3].insert(curr);\\n            }\\n        }\\n        return true; //after loop finishes our control reaches here that means our sudoko is valid...\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //since we have to verify that each element is appears once or not... for that purpose here we use \\n        //vector of sets since set stores only unique entries\\n        vector<set<int>> rows(9),cols(9),blocks(9); \\n        \\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                //if board[i][j] entry is \\'.\\' then we just continue as we only care about the duplicate values\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n                \\n                int curr = board[i][j]; //we can get the value at given index to check that if it is already \\n                // present in set or not\\n                \\n                //here our count function returns 1 if value is already present in row or column or block otherwise it will return 0\\n                \\n                //for block try this formula using pen and paper you will get it..\\n                if(rows[i].count(curr) || cols[j].count(curr) ||\\n                  blocks[(i/3)*3 + j/3].count(curr)){\\n                    return false; //we return false because the value currently we have is already present in set\\n                }\\n                //if we don\\'t found the value then after that we must enter this value in our set\\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3*3) + j/3].insert(curr);\\n            }\\n        }\\n        return true; //after loop finishes our control reaches here that means our sudoko is valid...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729180,
                "title": "python-solutions-single-traversal-single-dictionary",
                "content": "Just store the indexs of the numbers in a dictionary in `(x, y)` format. Then for every number check for same row, same col and same box condition.\\nThis will require a single traversal. The same box condition can be checked using `pos[0]//3 == x//3 and pos[1]//3 == y//3` since `i//3` and `j//3` give the box position.\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        boardMap = collections.defaultdict(list)\\n        for x in range(9):\\n            for y in range(9):\\n                char = board[x][y]\\n                if char != \\'.\\': \\n                    if char in boardMap:\\n                        for pos in boardMap[char]:\\n                            if (pos[0]== x) or (pos[1] == y) or (pos[0]//3 == x//3 and pos[1]//3 == y//3):\\n                                return False\\n                    boardMap[char].append((x,y))\\n   \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        boardMap = collections.defaultdict(list)\\n        for x in range(9):\\n            for y in range(9):\\n                char = board[x][y]\\n                if char != \\'.\\': \\n                    if char in boardMap:\\n                        for pos in boardMap[char]:\\n                            if (pos[0]== x) or (pos[1] == y) or (pos[0]//3 == x//3 and pos[1]//3 == y//3):\\n                                return False\\n                    boardMap[char].append((x,y))\\n   \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840656,
                "title": "java-explained-in-detail-simple-fast-solution-intuitive-hash-table",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n## 1st Approach - Intuitive\\n\\nUsing the intuitive way of checking, which is to check the row, the column and the box to see if any same number.\\n\\nWith that, we can split it into 3 separate methods to check the row, the column and the box respectively.\\n\\nThis approach is adapted from the solution to solving the whole sudoku.\\n\\nHowever, we need to take note to skip the current row and column when checking, which is not necessary when solving the sudoku.\\n\\n</br>\\n\\n## Complexity\\n\\n#### Time Complexity  : O(n^3),\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\n\\nFor each position in the board, we perform 3 checks, row, column and box, which iterates 9 positions each.\\n\\nThus, to be more exact, it is O(3 * 9 * 9 * 9).\\n\\n#### Space Complexity : O(1),\\nas only fixed auxiliary variable is used to check.\\n\\n</br>\\n\\n### Java - Intuitive (With Explanation)\\n```\\npublic class ValidSudoku {\\n\\n    // Main Method to check the valid sudoku.\\n    public boolean isValidSudoku(char[][] board) {\\n        // Checking every number in the \\'board\\'.\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n\\n    // Method to check if identical number found in the row.\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"column != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the row and return true if found.\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        // If we did not find any identical number in the row, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"row != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the column and return true if found.\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        // If we did not find any identical number in the column, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        // Here, we get the top left corner position of the box the \\'number\\' is in,\\n        // because we are going to scan from top left to bottom right of the box.\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n\\n        // Checking just the 3 row and 3 column position in the box.\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                // \"row != i && column != j\" to skip the current number.\\n                // Otherwise, check if any identical number in the box and return true if found.\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        // If we did not find any identical number in the box, then return false.\\n        return false;\\n    }\\n\\n    // Additional wrapper method for all three checks to make the code more readable.\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        // If the number is not found in the row, column and the box, then it is a valid placement and return true.\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n\\n```\\n\\n### Java - Intuitive (Clean Code)\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n```\\n---\\n## 2nd Approach\\nCredit to @StefanPochmann for this clean and readable solution.\\n\\nUsing a HashSet to record the number that was already found in the row, column and box.\\n\\nIf there are any same number in the row, column or box is already in the HashSet, then we have found the identical number, which resulted in an invalid sudoku board.\\n\\nThere are multiple approaches for the HashSet, either use separate HashSet for the rows, columns and boxes, or using String to include all the information into a single HashSet.\\n\\nThe latter approach is implemented here.\\n\\n</br>\\n\\n## Complexity\\n\\n#### Time Complexity  : O(n^2),\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\nThis is because we iterate through every number in \\'board\\'.\\nDo note that the string concatenation take use some additional time, but they are constant time and do not scale linearly with \\'n\\'.\\n\\n\\n#### Space Complexity : O(n^2),\\n\\nwhere \\'n\\' is 9, the length and width of the \\'board\\'.\\nThis is due to the HashSet used, which stores the information of the number in the row, column and box.\\nEvery row with every 9 numbers, likewise for every column and every box, thus, to be more precise, it is O (n^2 + n^2 + n^2).\\n\\n</br>\\n\\n### Java - Hash Table (With Explanation)\\n```\\nclass Solution {\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                // If the position is a number (!= \\'.\\'),\\n                // then we can try adding the number and its information into the HashSet.\\n                if (number != \\'.\\') {\\n                    // The HashSet.add() function returns a boolean result, true if added successfully and false otherwise.\\n                    // As such, we can just use this boolean return from add() to check if we successfully added.\\n                    // If any of the 3 (row, column and box) is not added successfully,\\n                    // then \\'board\\' is not a valid sudoku board.\\n                    // 1. Store the number in the row.\\n                    // 2. Store the number in the column.\\n                    // 3. Store the number in the box. (Make sure to separate row and column information with a delimiter).\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n}\\n```\\n\\n### Java - Hash Table (Clean Code)\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                if (number != \\'.\\') {\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class ValidSudoku {\\n\\n    // Main Method to check the valid sudoku.\\n    public boolean isValidSudoku(char[][] board) {\\n        // Checking every number in the \\'board\\'.\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n\\n    // Method to check if identical number found in the row.\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"column != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the row and return true if found.\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        // If we did not find any identical number in the row, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            // \"row != i\" to skip the current number.\\n            // Otherwise, check if any identical number in the column and return true if found.\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        // If we did not find any identical number in the column, then return false.\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        // Here, we get the top left corner position of the box the \\'number\\' is in,\\n        // because we are going to scan from top left to bottom right of the box.\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n\\n        // Checking just the 3 row and 3 column position in the box.\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                // \"row != i && column != j\" to skip the current number.\\n                // Otherwise, check if any identical number in the box and return true if found.\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        // If we did not find any identical number in the box, then return false.\\n        return false;\\n    }\\n\\n    // Additional wrapper method for all three checks to make the code more readable.\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        // If the number is not found in the row, column and the box, then it is a valid placement and return true.\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                if (board[row][column] != \\'.\\' && !isValidPlacement(board, board[row][column], row, column))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private boolean isNumberInRow(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (column != i && board[row][i] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInColumn(char[][] board, char number, int row, int column) {\\n        for (int i = 0; i < 9; i++) {\\n            if (row != i && board[i][column] == number) return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean isNumberInBox(char[][] board, char number, int row, int column) {\\n        int boxRow = row - row % 3;\\n        int boxColumn = column - column % 3;\\n        for (int i = boxRow; i < boxRow + 3; i++) {\\n            for (int j = boxColumn; j < boxColumn + 3; j++) {\\n                if (row != i && column != j && board[i][j] == number) return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private boolean isValidPlacement(char[][] board, char number, int row, int column) {\\n        return !isNumberInRow(board, number, row, column) &&\\n                !isNumberInColumn(board, number, row, column) &&\\n                !isNumberInBox(board, number, row, column);\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                // If the position is a number (!= \\'.\\'),\\n                // then we can try adding the number and its information into the HashSet.\\n                if (number != \\'.\\') {\\n                    // The HashSet.add() function returns a boolean result, true if added successfully and false otherwise.\\n                    // As such, we can just use this boolean return from add() to check if we successfully added.\\n                    // If any of the 3 (row, column and box) is not added successfully,\\n                    // then \\'board\\' is not a valid sudoku board.\\n                    // 1. Store the number in the row.\\n                    // 2. Store the number in the column.\\n                    // 3. Store the number in the box. (Make sure to separate row and column information with a delimiter).\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        // If all checks succeed, then the \\'board\\' is a valid sudoku.\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int row = 0; row < 9; row++) {\\n            for (int column = 0; column < 9; column++) {\\n                char number = board[row][column];\\n                if (number != \\'.\\') {\\n                    if (!set.add(number + \" in row \" + row) ||\\n                            !set.add(number + \" in column \" + column) ||\\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840666,
                "title": "python3-easy-to-understand-beginner-friendly",
                "content": "Since the Sudoku is 9 by 9, it doesn\\'t really matter if we go over it once, twice, or three times. I feel like if we get this question in an interview, the interviewer is looking for a clean code. The tricky part of this problem would be handling the sub-box indices.\\n\\n**Clear and Understandable Approach**\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Given an arr of row/col/sub,\\n        # check if there are duplicates.\\n        def isValid(arr):\\n            s = \\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s) == len(set(s))\\n        \\n        # Check each row in the board\\n        def checkRow():\\n            for row in board:\\n                if not isValid(row):\\n                    return False\\n            return True\\n        \\n        # Check each col in the board,\\n        # To access each col, we first unpack the board into sperate lists using *\\n        # We then zip these rows together into columns.\\n        def checkCol():\\n            for col in zip(*board):\\n                if not isValid(col):\\n                    return False\\n            return True\\n        \\n        # To get each sub-box, we first get the top-left indices of each sub-box,\\n        # We then go 3 steps on each row and 3 steps on each col to construct the box.\\n        def checkSub():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    sub = [board[r+dr][c+dc] for dr in range(3) for dc in range(3)]\\n                    if not isValid(sub):\\n                        return False\\n            return True\\n        \\n        # In order to be a valid Sudoku, all row, col, and sub-box need to be valid\\n        return checkRow() and checkCol() and checkSub()\\n```\\n\\n**One pass using row, col, sub-box ID**\\nWe can also optimize the solution a little bit, using a hashmap to store the visited elements for each row, col, and sub-box.\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Row, Col, and subBox will each contain 9 sets to keep track of the visited element.\\n        # Using 0-8 as the id for each row, col, and sub-box.\\n        # At any time if the same number is visited twice, return False. \\n        Row = defaultdict(set)\\n        Col = defaultdict(set)\\n        subBox = defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                \\n                cur = board[r][c]\\n                if cur==\\'.\\':\\n                    continue\\n                \\n                # r is the id for Row \\n                if cur in Row[r]:\\n                    return False\\n                Row[r].add(cur)\\n                \\n                # c is the id for Col\\n                if cur in Col[c]:\\n                    return False\\n                Col[c].add(cur)\\n                \\n                # sub-box id is a little bit tricky\\n                # r//3*3 will map the number 0-8 to 0,3,6 which is the starting id for each row.\\n                # c//3 will map the number 0-8 to 0,1,2, which is the column.\\n                # So r//3*3+c//3 is corresponding to sub-box id as shown\\n                                                             ----- ----- -----\\n                boxId = r//3*3+c//3                         |  0  |  1  |  2  |\\n                if cur in subBox[boxId]:                     ----- ----- -----\\n                    return False                            |  3  |  4  |  5  |\\n                subBox[boxId].add(cur)                       ----- ----- -----\\n                                                            |  6  |  7  |  8  |\\n                                                             ----- ----- -----\\n        # We passed all the tests, return True\\n        return True\\n```\\n\\nFor more advanced solutions check [HERE](https://leetcode.com/problems/valid-sudoku/discuss/2840529/PythonC%2B%2BJavaRust-O(1)-space-an-other-approaches...-%2B-BONUS-ONE-LINER-(explained))\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Given an arr of row/col/sub,\\n        # check if there are duplicates.\\n        def isValid(arr):\\n            s = \\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s) == len(set(s))\\n        \\n        # Check each row in the board\\n        def checkRow():\\n            for row in board:\\n                if not isValid(row):\\n                    return False\\n            return True\\n        \\n        # Check each col in the board,\\n        # To access each col, we first unpack the board into sperate lists using *\\n        # We then zip these rows together into columns.\\n        def checkCol():\\n            for col in zip(*board):\\n                if not isValid(col):\\n                    return False\\n            return True\\n        \\n        # To get each sub-box, we first get the top-left indices of each sub-box,\\n        # We then go 3 steps on each row and 3 steps on each col to construct the box.\\n        def checkSub():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    sub = [board[r+dr][c+dc] for dr in range(3) for dc in range(3)]\\n                    if not isValid(sub):\\n                        return False\\n            return True\\n        \\n        # In order to be a valid Sudoku, all row, col, and sub-box need to be valid\\n        return checkRow() and checkCol() and checkSub()\\n```\n```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # Row, Col, and subBox will each contain 9 sets to keep track of the visited element.\\n        # Using 0-8 as the id for each row, col, and sub-box.\\n        # At any time if the same number is visited twice, return False. \\n        Row = defaultdict(set)\\n        Col = defaultdict(set)\\n        subBox = defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                \\n                cur = board[r][c]\\n                if cur==\\'.\\':\\n                    continue\\n                \\n                # r is the id for Row \\n                if cur in Row[r]:\\n                    return False\\n                Row[r].add(cur)\\n                \\n                # c is the id for Col\\n                if cur in Col[c]:\\n                    return False\\n                Col[c].add(cur)\\n                \\n                # sub-box id is a little bit tricky\\n                # r//3*3 will map the number 0-8 to 0,3,6 which is the starting id for each row.\\n                # c//3 will map the number 0-8 to 0,1,2, which is the column.\\n                # So r//3*3+c//3 is corresponding to sub-box id as shown\\n                                                             ----- ----- -----\\n                boxId = r//3*3+c//3                         |  0  |  1  |  2  |\\n                if cur in subBox[boxId]:                     ----- ----- -----\\n                    return False                            |  3  |  4  |  5  |\\n                subBox[boxId].add(cur)                       ----- ----- -----\\n                                                            |  6  |  7  |  8  |\\n                                                             ----- ----- -----\\n        # We passed all the tests, return True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840529,
                "title": "python-c-java-o-logn-space-and-other-approaches-bonus-one-liner-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nHere, I provide several approaches to check for a valid sudoku game. The best of them has **O(m\\\\*n)** time compleixty and **O(logN)** space complexity.\\n****\\n\\n**Comment.** There are numerous approaches on how to tackle this problem, however, they all differ in the amount of memoization done. The typical solutions employ:\\n1. Bit manipulation to reduce memory requirements to just one number. \\n2. Memoizing into a hashset until a collision happens.\\n3. Memoizing into a list, then making a set and comparing its size to the size of the original list.\\n\\n**Python #1.** An **O(logN)**-space solution using *zip* to transpose, a generator to yield blocks and bit memoization to check for unique digits.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # a function to check rows, columns and blocks using O(logN) space\\n        def not_valid(digits, m=0):\\n            return any( 1 & (m >> int(d)) + (m := (m | (1 << int(d))))*0\\n                        for d in digits if d != \".\")\\n                       \\n        # a generator to extract blocks\\n        def blocks():\\n            for i in range(3):\\n                for j in range(3):\\n                    yield (n for row in board[i*3:(i+1)*3] for n in row[j*3:(j+1)*3])\\n        \\n        if any(map(not_valid, board))       : return False       # [1] test rows\\n        if any(map(not_valid, zip(*board))) : return False       # [2] test columns\\n        if any(map(not_valid, blocks()))    : return False       # [3] test blocks\\n        \\n        return True\\n```\\nThe one-liner to check digits can be expanded as follows:\\n```\\ndef not_valid(digits, m=0):\\n\\tfor d in digits:\\n\\t\\tif d != \".\":\\n\\t\\t\\tif (1 & (m >> int(d))) == 1 : return True\\n\\t\\t\\tm |= (1 << int(d))\\n\\treturn False\\n```\\n\\nIf you\\'re not comfortable with it, you can use the standard `len(set(list)) != len(list)` technique that is linear in allocated space:\\n```\\ndef not_valid(digits):\\n\\treturn len(set(s:= [d for d in digits if d != \".\"])) != len(s)\\n```\\n\\n**Python #2.** Here, we use smart memoization where for rows, columns and blocks, different types of memoization elements are being constructed. This prevents interference between them when using `len(set(list)) == len(list)` approach.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        seen = []\\n        \\n        for i, row in enumerate(board):\\n            for j, d in enumerate(row):\\n                if  d != \".\":\\n                    seen.extend([(d,i), (j,d), (d,i//3,j//3)])    # these tuples never interfere!\\n        \\n        return len(set(seen)) == len(seen)\\n```\\n\\n**Python #3.** Easy ranges with *numpy*.\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        board = np.array(board)\\n        \\n        def not_valid(digits):\\n            s = \"\".join(digits).replace(\".\", \"\")\\n            return len(s) != len(set(s))\\n        \\n        for k in range(9):\\n            r, c = board[k,:], board[:,k]\\n            i, j = 3*(k//3), 3*(k%3)\\n            b    = board[i:i+3,j:j+3].flatten()\\n            if any(map(not_valid, (r,c,b))) : return False\\n        \\n        return True\\n```\\n\\nSolutions in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/Jjxoh3cu/shared\" frameBorder=\"0\" width=\"800\" height=\"380\"></iframe>\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** Finally, it\\'s one-liner time! The solution #2 can be compactified as follows.\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        return len(seen := sum(([(d,i),(j,d),(d,i//3,j//3)]\\n                                if  d != \".\" else []\\n                                for i, row in enumerate(board)\\n                                for j, d   in enumerate(row)),[])) == len(set(seen))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # a function to check rows, columns and blocks using O(logN) space\\n        def not_valid(digits, m=0):\\n            return any( 1 & (m >> int(d)) + (m := (m | (1 << int(d))))*0\\n                        for d in digits if d != \".\")\\n                       \\n        # a generator to extract blocks\\n        def blocks():\\n            for i in range(3):\\n                for j in range(3):\\n                    yield (n for row in board[i*3:(i+1)*3] for n in row[j*3:(j+1)*3])\\n        \\n        if any(map(not_valid, board))       : return False       # [1] test rows\\n        if any(map(not_valid, zip(*board))) : return False       # [2] test columns\\n        if any(map(not_valid, blocks()))    : return False       # [3] test blocks\\n        \\n        return True\\n```\n```\\ndef not_valid(digits, m=0):\\n\\tfor d in digits:\\n\\t\\tif d != \".\":\\n\\t\\t\\tif (1 & (m >> int(d))) == 1 : return True\\n\\t\\t\\tm |= (1 << int(d))\\n\\treturn False\\n```\n```\\ndef not_valid(digits):\\n\\treturn len(set(s:= [d for d in digits if d != \".\"])) != len(s)\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        seen = []\\n        \\n        for i, row in enumerate(board):\\n            for j, d in enumerate(row):\\n                if  d != \".\":\\n                    seen.extend([(d,i), (j,d), (d,i//3,j//3)])    # these tuples never interfere!\\n        \\n        return len(set(seen)) == len(seen)\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        board = np.array(board)\\n        \\n        def not_valid(digits):\\n            s = \"\".join(digits).replace(\".\", \"\")\\n            return len(s) != len(set(s))\\n        \\n        for k in range(9):\\n            r, c = board[k,:], board[:,k]\\n            i, j = 3*(k//3), 3*(k%3)\\n            b    = board[i:i+3,j:j+3].flatten()\\n            if any(map(not_valid, (r,c,b))) : return False\\n        \\n        return True\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        return len(seen := sum(([(d,i),(j,d),(d,i//3,j//3)]\\n                                if  d != \".\" else []\\n                                for i, row in enumerate(board)\\n                                for j, d   in enumerate(row)),[])) == len(set(seen))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794580,
                "title": "solution-very-detailed-explanation-in-c-please-upvote-if-you-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\nThis problem looks intimidating in the first glance but we just need to split our solution into three parts:\\n1. Check if the sudoku board fulfils the row requirement that \"Each row must contain the digits 1-9 without repetition.\"\\n\\n2. Check if it fulfils column requirement that \"Each column must contain the digits 1-9 without repetition.\"\\n\\n3. Check if it has the right subbox such that \"Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\"\\n\\nIf you scroll down to the bottom, \"Constraints\" section, you\\'ll find that board[i][j] must be a digit from 1 to 9. So all we need to check is if there is any repitition in row, column, and subbox. To support quick lookups, we can use hashmap, unordered_set specifically. \\n\\nA note is that I used two unordered_sets: check_row, check_col in my solution. However, you can just use one, which means that you reuse the unordered_set after part 1 by clearing its content and reusing it for part 2. \\n\\nTime complexity is O(1) because the nested for loops will run 81 (9 * 9) times. Space complexity is O(n). \\n\\nSince I\\'m a beginner, I\\'m still looking for ways to improve the time and memory efficiency of my solution, but I\\'m sure it\\'s an understandable, though not perfect, solution. \\n*/\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    // 1. Check row quality\\n    for (int row = 0; row < 9; row++){\\n        unordered_set<char> check_row;\\n        for (int col = 0; col < 9; col++){\\n            if (board[row][col] != \\'.\\' && check_row.find(board[row][col]) != check_row.end()){\\n                return false;\\n            }\\n            check_row.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 2. Check column quality\\n    for (int col = 0; col < 9; col++){\\n        unordered_set<char> check_col;\\n        for (int row = 0; row < 9; row++){\\n            if (board[row][col] != \\'.\\' && check_col.find(board[row][col]) != check_col.end()){\\n                return false;\\n            }\\n            check_col.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 3. Check 3*3 sub-boxes\\n    /*\\n    Idea here is that we can break the Sudoku board into 9 subboxes, numbered 0, 1, 2, ..., 8, and these box numbers correspond to the index in the vector \"check_subbox.\"\\n\\n    Then, we need to find a way to determine which subbox an element should go based on its row and col number. We can use a formula: int location = (row/3) * 3 + col/3. This way, we can put the element into the desire box. One example is coordinate [8, 8]. It should be put into the last subbox (subbox 8). By this formula, it should go to (8/3) * 3 + 8/3 = 2*3 + 2 = 8. You can take other examples to verify but that\\'s pretty much the logics. \\n    */\\n    vector<unordered_set<char>> check_subbox(9);\\n    for (int row = 0; row < 9; row++){\\n        for (int col = 0; col < 9; col++){\\n            int loc = (row / 3) * 3 + col / 3;\\n            if (board[row][col] != \\'.\\' && check_subbox[loc].find(board[row][col]) != check_subbox[loc].end()){\\n                return false;\\n            }\\n            check_subbox[loc].insert(board[row][col]);\\n        }\\n    }\\n    return true;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\nThis problem looks intimidating in the first glance but we just need to split our solution into three parts:\\n1. Check if the sudoku board fulfils the row requirement that \"Each row must contain the digits 1-9 without repetition.\"\\n\\n2. Check if it fulfils column requirement that \"Each column must contain the digits 1-9 without repetition.\"\\n\\n3. Check if it has the right subbox such that \"Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\"\\n\\nIf you scroll down to the bottom, \"Constraints\" section, you\\'ll find that board[i][j] must be a digit from 1 to 9. So all we need to check is if there is any repitition in row, column, and subbox. To support quick lookups, we can use hashmap, unordered_set specifically. \\n\\nA note is that I used two unordered_sets: check_row, check_col in my solution. However, you can just use one, which means that you reuse the unordered_set after part 1 by clearing its content and reusing it for part 2. \\n\\nTime complexity is O(1) because the nested for loops will run 81 (9 * 9) times. Space complexity is O(n). \\n\\nSince I\\'m a beginner, I\\'m still looking for ways to improve the time and memory efficiency of my solution, but I\\'m sure it\\'s an understandable, though not perfect, solution. \\n*/\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    // 1. Check row quality\\n    for (int row = 0; row < 9; row++){\\n        unordered_set<char> check_row;\\n        for (int col = 0; col < 9; col++){\\n            if (board[row][col] != \\'.\\' && check_row.find(board[row][col]) != check_row.end()){\\n                return false;\\n            }\\n            check_row.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 2. Check column quality\\n    for (int col = 0; col < 9; col++){\\n        unordered_set<char> check_col;\\n        for (int row = 0; row < 9; row++){\\n            if (board[row][col] != \\'.\\' && check_col.find(board[row][col]) != check_col.end()){\\n                return false;\\n            }\\n            check_col.insert(board[row][col]);\\n        }\\n    }\\n\\n    // 3. Check 3*3 sub-boxes\\n    /*\\n    Idea here is that we can break the Sudoku board into 9 subboxes, numbered 0, 1, 2, ..., 8, and these box numbers correspond to the index in the vector \"check_subbox.\"\\n\\n    Then, we need to find a way to determine which subbox an element should go based on its row and col number. We can use a formula: int location = (row/3) * 3 + col/3. This way, we can put the element into the desire box. One example is coordinate [8, 8]. It should be put into the last subbox (subbox 8). By this formula, it should go to (8/3) * 3 + 8/3 = 2*3 + 2 = 8. You can take other examples to verify but that\\'s pretty much the logics. \\n    */\\n    vector<unordered_set<char>> check_subbox(9);\\n    for (int row = 0; row < 9; row++){\\n        for (int col = 0; col < 9; col++){\\n            int loc = (row / 3) * 3 + col / 3;\\n            if (board[row][col] != \\'.\\' && check_subbox[loc].find(board[row][col]) != check_subbox[loc].end()){\\n                return false;\\n            }\\n            check_subbox[loc].insert(board[row][col]);\\n        }\\n    }\\n    return true;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841310,
                "title": "c-use-hashmap-easy-efficient-solution",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    \\n    bool isValidSudoku(vector<vector<char> > &board)\\n    {\\n\\t\\t//Hashmap for checking repeated number(from 1 to 9) in each row (9 rows), column (9 cols) and grid (9 grids)\\n        int row[9][9] = {0}, col[9][9] = {0}, grid_3x3[9][9] = {0}; \\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[i].size(); j++)\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'1\\', k = i/3*3+j/3; //k for finding grid index from 0 to 8\\n                    if(row[i][num] || col[j][num] || grid_3x3[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = grid_3x3[k][num] = 1;\\n                }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    \\n    bool isValidSudoku(vector<vector<char> > &board)\\n    {\\n\\t\\t//Hashmap for checking repeated number(from 1 to 9) in each row (9 rows), column (9 cols) and grid (9 grids)\\n        int row[9][9] = {0}, col[9][9] = {0}, grid_3x3[9][9] = {0}; \\n        \\n        for(int i = 0; i < board.size(); i++)\\n            for(int j = 0; j < board[i].size(); j++)\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'1\\', k = i/3*3+j/3; //k for finding grid index from 0 to 8\\n                    if(row[i][num] || col[j][num] || grid_3x3[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = grid_3x3[k][num] = 1;\\n                }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15643,
                "title": "simple-clear-java-solution",
                "content": "    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            \\n           boolean[][] row = new boolean[9][9];\\n           boolean[][] column = new boolean[9][9];\\n           boolean[][] block = new boolean[9][9];\\n           \\n           for(int i = 0;i<9;i++){\\n               for(int j=0;j<9;j++){\\n                    int c = board[i][j] - '1';       \\n                    if(board[i][j]=='.'){\\n                        continue;\\n                    }\\n                    if(row[i][c]||column[j][c]||block[i - i % 3 + j / 3][c]){\\n                        return false;\\n                    }\\n                    row[i][c] = column[j][c] = block[i - i % 3 + j / 3][c] = true;\\n               }\\n           }\\n           return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            \\n           boolean[][] row = new boolean[9][9];\\n           boolean[][] column = new boolean[9][9];\\n           boolean[][] block = new boolean[9][9];\\n           \\n           for(int i = 0;i<9;i++){\\n               for(int j=0;j<9;j++){\\n                    int c = board[i][j] - '1';       \\n                    if(board[i][j]=='.'){\\n                        continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 511365,
                "title": "simple-intuitive-python-approach",
                "content": "![image](https://assets.leetcode.com/users/tohbaino/image_1581904292.png)\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        rows = [set() for i in range(9)]\\n        cols = [set() for i in range(9)]\\n        mMat = [set() for i in range(9)]\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                cur = board[i][j]\\n                if cur != \\'.\\':\\n                    \\n                    k = (i // 3 ) * 3 + j // 3\\n                \\n                    if cur not in rows[i]: rows[i].add(cur)\\n                    else: return False\\n                    \\n                    if cur not in cols[j]: cols[j].add(cur)\\n                    else: return False\\n                \\n                    if cur not in mMat[k]: mMat[k].add(cur)\\n                    else: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        rows = [set() for i in range(9)]\\n        cols = [set() for i in range(9)]\\n        mMat = [set() for i in range(9)]\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                cur = board[i][j]\\n                if cur != \\'.\\':\\n                    \\n                    k = (i // 3 ) * 3 + j // 3\\n                \\n                    if cur not in rows[i]: rows[i].add(cur)\\n                    else: return False\\n                    \\n                    if cur not in cols[j]: cols[j].add(cur)\\n                    else: return False\\n                \\n                    if cur not in mMat[k]: mMat[k].add(cur)\\n                    else: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15642,
                "title": "share-my-c-solution",
                "content": "    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char,int> row[9],col[9],blk[9];\\n        char c;\\n        for(int i = 0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                c = board[i][j];\\n                if((c!='.')&&(0<row[i][c]++ || 0<col[j][c]++ || 0<blk[i/3*3+j/3][c]++)) return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char,int> row[9],col[9],blk[9];\\n        char c;\\n        for(int i = 0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                c = board[i][j];\\n                if((c!='.')&&(0<row[i][c]++ || 0<col[j][c]++ || 0<blk[i/3*3+j/3][c]++)) return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 160227,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        dic_list1 = [set() for _ in range(9)]\\n        dic_list2 = [set() for _ in range(9)]\\n        dic_list3 = [[set() for _ in range(3)] for _ in range(3)]\\n        for i in range(9):\\n            for j in range(9):\\n                if not board[i][j].isnumeric():\\n                    continue\\n                y = i // 3\\n                x = j // 3\\n                num = board[i][j]\\n                if (num in dic_list1[i]) or (num in dic_list2[j]) or (num in dic_list3[x][y]):\\n                    return False\\n                else:\\n                    dic_list1[i].add(num)\\n                    dic_list2[j].add(num)\\n                    dic_list3[x][y].add(num)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        dic_list1 = [set() for _ in range(9)]\\n        dic_list2 = [set() for _ in range(9)]\\n        dic_list3 = [[set() for _ in range(3)] for _ in range(3)]\\n        for i in range(9):\\n            for j in range(9):\\n                if not board[i][j].isnumeric():\\n                    continue\\n                y = i // 3\\n                x = j // 3\\n                num = board[i][j]\\n                if (num in dic_list1[i]) or (num in dic_list2[j]) or (num in dic_list3[x][y]):\\n                    return False\\n                else:\\n                    dic_list1[i].add(num)\\n                    dic_list2[j].add(num)\\n                    dic_list3[x][y].add(num)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156618,
                "title": "javascript-using-arrays-of-hash-maps-beats-99-54",
                "content": "My solution is relatively straight-forward (an explanation for the value of `k` is explained below in the comments).\\n\\n```javascript\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {    \\n    const boxes = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\\n    const cols = [{}, {}, {}, {}, {}, {}, {}, {}, {}]; \\n    const rows = [{}, {}, {}, {}, {}, {}, {}, {}, {}];   \\n    \\n    for (let i = 0; i < 9; i++) {              \\n        for (let j = 0; j < 9; j++) {            \\n            const digit = board[i][j];\\n            \\n            if (digit !== \\'.\\') {\\n                const k = Math.floor(j / 3) + (Math.floor(i / 3) * 3);\\n\\n                if (boxes[k][digit] || cols[j][digit] || rows[i][digit]) {\\n                    return false;\\n                }\\n\\n                boxes[k][digit] = cols[j][digit] = rows[i][digit] = true;       \\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {    \\n    const boxes = [{}, {}, {}, {}, {}, {}, {}, {}, {}];\\n    const cols = [{}, {}, {}, {}, {}, {}, {}, {}, {}]; \\n    const rows = [{}, {}, {}, {}, {}, {}, {}, {}, {}];   \\n    \\n    for (let i = 0; i < 9; i++) {              \\n        for (let j = 0; j < 9; j++) {            \\n            const digit = board[i][j];\\n            \\n            if (digit !== \\'.\\') {\\n                const k = Math.floor(j / 3) + (Math.floor(i / 3) * 3);\\n\\n                if (boxes[k][digit] || cols[j][digit] || rows[i][digit]) {\\n                    return false;\\n                }\\n\\n                boxes[k][digit] = cols[j][digit] = rows[i][digit] = true;       \\n            }\\n        }\\n    }\\n    \\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055145,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][9]={0};\\n\\tint cols[9][9]={0};\\n\\tint blocks[3][3][9]={0};\\n\\tfor(int r=0;r<9;r++)\\n\\t\\tfor(int c=0;c<9;c++)\\n\\t\\t\\tif(board[r][c]!=\\'.\\'){\\n\\t\\t\\t\\tint number=board[r][c]-\\'1\\';\\n\\t\\t\\t\\tif(rows[r][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(cols[c][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(blocks[r/3][c/3][number]++)\\n                 return 0;\\n\\t\\t\\t}\\n\\treturn 1;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][9]={0};\\n\\tint cols[9][9]={0};\\n\\tint blocks[3][3][9]={0};\\n\\tfor(int r=0;r<9;r++)\\n\\t\\tfor(int c=0;c<9;c++)\\n\\t\\t\\tif(board[r][c]!=\\'.\\'){\\n\\t\\t\\t\\tint number=board[r][c]-\\'1\\';\\n\\t\\t\\t\\tif(rows[r][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(cols[c][number]++)\\n                 return 0;\\n\\t\\t\\t\\tif(blocks[r/3][c/3][number]++)\\n                 return 0;\\n\\t\\t\\t}\\n\\treturn 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513191,
                "title": "java-tc-o-9-9-sc-o-1-most-optimized-solution-using-bit-manipulation",
                "content": "```java\\n/**\\n * Most Optimized solution using Bit Manipulation\\n * \\n * Using only one int to store the bits for Row, Column and Box.\\n *\\n * This Solution uses True O(1) space and requires True O(N^2) time.\\n *\\n * Bit 0 -> 8 will represent ith Row\\n * Bit 9 -> 17 will represent ith Column\\n * Bit 18 -> 26 will represent ith Box\\n *\\n * Time Complexity: O(9*9)\\n *\\n * Space Complexity: O(1). Using only one integer.\\n */\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        if (board == null || board.length != 9 || board[0].length != 9) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int rowColBox = 0;\\n\\n        for (int i = 0; i < 9; i++) { // Index of row, column and box\\n            for (int j = 0; j < 9; j++) {\\n                // Check ith row\\n                rowColBox = validateAndAddCell(board[i][j], 0, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith column\\n                rowColBox = validateAndAddCell(board[j][i], 1, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith box\\n                int boxRow = 3 * (i / 3) + (j / 3);\\n                int colRow = 3 * (i % 3) + (j % 3);\\n                rowColBox = validateAndAddCell(board[boxRow][colRow], 2, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n            }\\n            rowColBox = 0;\\n        }\\n\\n        return true;\\n    }\\n\\n    private int validateAndAddCell(char c, int type, int rowColBox) {\\n        if (c == \\'.\\') {\\n            return rowColBox;\\n        }\\n        if (c < \\'1\\' || c > \\'9\\') {\\n            return -1;\\n        }\\n\\n        int bitIdx = type * 9 + (c - \\'1\\');\\n        if (((rowColBox >> bitIdx) & 1) == 1) {\\n            return -1;\\n        }\\n\\n        return rowColBox | (1 << bitIdx);\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Sudoku question on LeetCode:\\n- [37. Sudoku Solver](https://leetcode.com/problems/sudoku-solver/discuss/1513192/Java-or-TC:-O(9N)-or-SC:-O(N)-or-Most-Optimized-Backtracking-solution-using-Bit-Manipulation)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Most Optimized solution using Bit Manipulation\\n * \\n * Using only one int to store the bits for Row, Column and Box.\\n *\\n * This Solution uses True O(1) space and requires True O(N^2) time.\\n *\\n * Bit 0 -> 8 will represent ith Row\\n * Bit 9 -> 17 will represent ith Column\\n * Bit 18 -> 26 will represent ith Box\\n *\\n * Time Complexity: O(9*9)\\n *\\n * Space Complexity: O(1). Using only one integer.\\n */\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        if (board == null || board.length != 9 || board[0].length != 9) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int rowColBox = 0;\\n\\n        for (int i = 0; i < 9; i++) { // Index of row, column and box\\n            for (int j = 0; j < 9; j++) {\\n                // Check ith row\\n                rowColBox = validateAndAddCell(board[i][j], 0, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith column\\n                rowColBox = validateAndAddCell(board[j][i], 1, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n\\n                // Check ith box\\n                int boxRow = 3 * (i / 3) + (j / 3);\\n                int colRow = 3 * (i % 3) + (j % 3);\\n                rowColBox = validateAndAddCell(board[boxRow][colRow], 2, rowColBox);\\n                if (rowColBox == -1) {\\n                    return false;\\n                }\\n            }\\n            rowColBox = 0;\\n        }\\n\\n        return true;\\n    }\\n\\n    private int validateAndAddCell(char c, int type, int rowColBox) {\\n        if (c == \\'.\\') {\\n            return rowColBox;\\n        }\\n        if (c < \\'1\\' || c > \\'9\\') {\\n            return -1;\\n        }\\n\\n        int bitIdx = type * 9 + (c - \\'1\\');\\n        if (((rowColBox >> bitIdx) & 1) == 1) {\\n            return -1;\\n        }\\n\\n        return rowColBox | (1 << bitIdx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653359,
                "title": "solution-swift-valid-sudoku-test-cases",
                "content": "```swift\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in board.indices {\\n            let rows = board[i].filter { $0 != \".\" }\\n            let cols = board.map{ $0[i] }.filter { $0 != \".\" }\\n            let n = (a: 3 * (i / 3), b: 3 * (i % 3))\\n            let blks = board[n.a ..< n.a + 3].flatMap{$0[n.b ..< n.b + 3]}.filter{$0 != \".\"}\\n            if rows.count != Set(rows).count ||\\n                cols.count != Set(cols).count ||\\n                blks.count != Set(blks).count { return false }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.076 (0.078) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isValidSudoku([[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, true)\\n    }\\n    func test1() {\\n        let value = solution.isValidSudoku([[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in board.indices {\\n            let rows = board[i].filter { $0 != \".\" }\\n            let cols = board.map{ $0[i] }.filter { $0 != \".\" }\\n            let n = (a: 3 * (i / 3), b: 3 * (i % 3))\\n            let blks = board[n.a ..< n.a + 3].flatMap{$0[n.b ..< n.b + 3]}.filter{$0 != \".\"}\\n            if rows.count != Set(rows).count ||\\n                cols.count != Set(cols).count ||\\n                blks.count != Set(blks).count { return false }\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isValidSudoku([[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, true)\\n    }\\n    func test1() {\\n        let value = solution.isValidSudoku([[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n                                            [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],\\n                                            [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],\\n                                            [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],\\n                                            [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],\\n                                            [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\\n                                            [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],\\n                                            [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],\\n                                            [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]])\\n        XCTAssertEqual(value, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237662,
                "title": "easiest-java-100-faster-98-2-less-memory",
                "content": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(!isValid(board,i,j,board[i][j]))\\n                        return false;\\n                }\\n            }\\n         }\\n        return true;\\n    }\\n    \\n    public boolean isValid(char[][] board, int row, int col, char num){\\n        \\n        //for row checking\\n        for(int i=col+1;i<9;i++){\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n        \\n        //For col checking\\n        for(int i=row+1;i<9;i++){\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n        \\n        //for internal square\\n        int x = row - row%3, y = col-col%3;\\n        for(int i=x; i<x+3; i++){\\n            for(int j=y; j<y+3; j++){\\n                if(board[i][j]==num && !(i==row && j==col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    }   \\n}\\n\\n\\n\\nPlease upvote if you find it easy and simple to understand\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(!isValid(board,i,j,board[i][j]))\\n                        return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 780278,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    let seen = new Set();\\n    for(let i = 0; i < 9; i++) {\\n      for(let j = 0; j < 9; j++) {\\n        let cell = board[i][j];\\n        if(cell != \\'.\\') {\\n            let colCell = `cell: ${j} ${cell}`;\\n            let rowCell = `row: ${i} ${cell}`;\\n            let subBoxCell = `subBox: ${parseInt(i/3)}-${parseInt(j/3)} ${cell}`;\\n        \\n            if(!seen.has(colCell) && !seen.has(rowCell) && !seen.has(subBoxCell)) {\\n                seen.add(colCell);\\n                seen.add(rowCell);\\n                seen.add(subBoxCell);\\n            }\\n            else \\n                return false;\\n          }\\n      }\\n    }\\n    return true;\\n};\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    let seen = new Set();\\n    for(let i = 0; i < 9; i++) {\\n      for(let j = 0; j < 9; j++) {\\n        let cell = board[i][j];\\n        if(cell != \\'.\\') {\\n            let colCell = `cell: ${j} ${cell}`;\\n            let rowCell = `row: ${i} ${cell}`;\\n            let subBoxCell = `subBox: ${parseInt(i/3)}-${parseInt(j/3)} ${cell}`;\\n        \\n            if(!seen.has(colCell) && !seen.has(rowCell) && !seen.has(subBoxCell)) {\\n                seen.add(colCell);\\n                seen.add(rowCell);\\n                seen.add(subBoxCell);\\n            }\\n            else \\n                return false;\\n          }\\n      }\\n    }\\n    return true;\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124036,
                "title": "readable-javascript-solution-w-comments",
                "content": "Didn\\'t come up with this, but I think I made it a bit more readable.\\n\\nInspired by:\\n1. https://leetcode.com/problems/valid-sudoku/discuss/15527/Simple-JavaScript-One-Pass-Solution \\n2. https://leetcode.com/problems/valid-sudoku/discuss/121921/javascript \\n\\n```\\nvar isValidSudoku = function(board) {\\n  // create an empty set for each row/col/square\\n  const rowRules = new Array(9).fill().map(() => new Set())\\n  const colRules = new Array(9).fill().map(() => new Set())\\n  const mixedRules = new Array(9).fill().map(() => new Set())\\n  \\n  // iterate through each cell on the board\\n  for (let row = 0; row < 9; row++) {\\n    for (let col = 0; col < 9; col++) {\\n      const curr = board[row][col]\\n      \\n      // some tricky math to get the index of the 3x3 squares\\n      const mixedIdx = Math.floor(row / 3) * 3 + Math.floor(col / 3)\\n\\n      if (curr === \".\") continue  // ignore dots\\n      \\n      // if the current number already exists in the set, board is invalid\\n      const a = rowRules[row].has(curr)\\n      const b = colRules[col].has(curr)\\n      const c = mixedRules[mixedIdx].has(curr)\\n      if (a || b || c) return false\\n      \\n      // add the number to the appropriate set\\n      rowRules[row].add(curr)\\n      colRules[col].add(curr)\\n      mixedRules[mixedIdx].add(curr)\\n    }\\n  }\\n  \\n  // all checks out\\n  return true\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  // create an empty set for each row/col/square\\n  const rowRules = new Array(9).fill().map(() => new Set())\\n  const colRules = new Array(9).fill().map(() => new Set())\\n  const mixedRules = new Array(9).fill().map(() => new Set())\\n  \\n  // iterate through each cell on the board\\n  for (let row = 0; row < 9; row++) {\\n    for (let col = 0; col < 9; col++) {\\n      const curr = board[row][col]\\n      \\n      // some tricky math to get the index of the 3x3 squares\\n      const mixedIdx = Math.floor(row / 3) * 3 + Math.floor(col / 3)\\n\\n      if (curr === \".\") continue  // ignore dots\\n      \\n      // if the current number already exists in the set, board is invalid\\n      const a = rowRules[row].has(curr)\\n      const b = colRules[col].has(curr)\\n      const c = mixedRules[mixedIdx].has(curr)\\n      if (a || b || c) return false\\n      \\n      // add the number to the appropriate set\\n      rowRules[row].add(curr)\\n      colRules[col].add(curr)\\n      mixedRules[mixedIdx].add(curr)\\n    }\\n  }\\n  \\n  // all checks out\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3194965,
                "title": "python-clean-simple-faster-than-96-in-runtime",
                "content": "To solve this problem we have to check if each value in sudoku does not repeat in its:\\n\\n1. Row\\n1. Column\\n1. Block\\n\\n# Complexity\\n- Time complexity: $$O(n*n)$$ \\n    where n is fiexed here.\\n    so, Time Complexity will be O(81) ==> O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        block = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                curr = board[i][j]\\n                if curr == \\'.\\':\\n                    continue\\n                if (curr in rows[i]) or (curr in cols[j]) or (curr in block[i // 3][j // 3]):\\n                    return False\\n                rows[i].add(curr)\\n                cols[j].add(curr)\\n                block[i // 3][j // 3].add(curr)\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [set() for _ in range(9)]\\n        cols = [set() for _ in range(9)]\\n        block = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                curr = board[i][j]\\n                if curr == \\'.\\':\\n                    continue\\n                if (curr in rows[i]) or (curr in cols[j]) or (curr in block[i // 3][j // 3]):\\n                    return False\\n                rows[i].add(curr)\\n                cols[j].add(curr)\\n                block[i // 3][j // 3].add(curr)\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15617,
                "title": "java-solution-easy-to-understand",
                "content": "    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] block = new boolean[9][9];\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == '.') {\\n                    continue;\\n                }\\n                int digit = board[i][j] - '1';\\n                int blockId = i / 3 * 3 + j / 3;\\n                if (col[j][digit]) {\\n                    return false;\\n                } else {\\n                    col[j][digit] = true;\\n                }\\n                if (row[i][digit]) {\\n                    return false;\\n                } else {\\n                    row[i][digit] = true;\\n                }\\n                if (block[blockId][digit]) {\\n                    return false;\\n                } else {\\n                    block[blockId][digit] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] block = new boolean[9][9];\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] == '.') {\\n                    continue;\\n                }\\n                int digit = board[i][j] - '1';\\n                int blockId = i / 3 * 3 + j / 3;\\n                if (col[j][digit]) {\\n                    return false;\\n                } else {\\n                    col[j][digit] = true;\\n                }\\n                if (row[i][digit]) {\\n                    return false;\\n                } else {\\n                    row[i][digit] = true;\\n                }\\n                if (block[blockId][digit]) {\\n                    return false;\\n                } else {\\n                    block[blockId][digit] = true;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 936699,
                "title": "c-easiest-to-understand-hashset",
                "content": "Sharing my Very Readable C++ Solution:\\n\\n```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n\\tvector<unordered_set<int>> rows(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> columns(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> boxes(9, unordered_set<int>());\\n\\n\\tfor (int i = 0; i < 9; ++i) {\\n\\t  for (int j = 0; j < 9; ++j) {\\n\\t\\tif (board[i][j] == \\'.\\')\\n\\t\\t  continue;\\n\\n\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\tif (rows[i].count(num))\\n\\t\\t  return false;\\n\\n\\t\\tif (columns[j].count(num))\\n\\t\\t  return false;\\n\\n\\t\\t// This is a straight-forward math formula to locate a box\\n\\t\\t// Out of the 9 boxes\\n\\t\\tint box_index = (i / 3) * 3 + j / 3;\\n\\n\\t\\tif (boxes[box_index].count(num))\\n\\t\\t  return false;\\n\\n\\t\\trows[i].insert(num);\\n\\t\\tcolumns[j].insert(num);\\n\\t\\tboxes[box_index].insert(num);\\n\\t  }\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n\\tvector<unordered_set<int>> rows(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> columns(9, unordered_set<int>());\\n\\tvector<unordered_set<int>> boxes(9, unordered_set<int>());\\n\\n\\tfor (int i = 0; i < 9; ++i) {\\n\\t  for (int j = 0; j < 9; ++j) {\\n\\t\\tif (board[i][j] == \\'.\\')\\n\\t\\t  continue;\\n\\n\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\tif (rows[i].count(num))\\n\\t\\t  return false;\\n\\n\\t\\tif (columns[j].count(num))\\n\\t\\t  return false;\\n\\n\\t\\t// This is a straight-forward math formula to locate a box\\n\\t\\t// Out of the 9 boxes\\n\\t\\tint box_index = (i / 3) * 3 + j / 3;\\n\\n\\t\\tif (boxes[box_index].count(num))\\n\\t\\t  return false;\\n\\n\\t\\trows[i].insert(num);\\n\\t\\tcolumns[j].insert(num);\\n\\t\\tboxes[box_index].insert(num);\\n\\t  }\\n\\t}\\n\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2134346,
                "title": "c-fast-easy-short-commented-code-8-lines-of-code",
                "content": "# Here we will run two for loops, one for rows and one for columns,\\n# If the element in the board is a number from 1 to 9 then we will check their presence---->\\n* ***IN THAT ROW :***   by using a row checker 2d array\\n* ***IN THE COLUMN :*** by using a column checker 2d array\\n* ***IN THAT BOX :*** by using the formula  **(row/3)3+(col/3)** \\uD83D\\uDE0E\\n\\n```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n        int checkrow[10][10]={0},checkcol[10][10]={0},checkbox[10][10]={0};       //declaring three check arrays with initially zero values.\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col]==\\'.\\')continue;         //if not a number we need to skip to the next index.\\n                int num=board[row][col]-\\'0\\';                //as \\'char\\' is given we make it int.\\n                int box=(row/3)*3+(col/3);                 //applying formula\\n                if(checkrow[row][num] || checkcol[num][col] || checkbox[box][num])       //if any of the checker gives true then the number is already present in that row/col/box.\\n                    return false;\\n                checkrow[row][num]=checkcol[num][col]=checkbox[box][num]=true;       //after checking we set the values true\\n            }\\n        }\\n        return true;\\n    }\\n```\\n![image](https://assets.leetcode.com/users/images/d9d71f90-6afb-45c0-8a51-f7af505db1da_1654853094.572027.png)\\n\\n\\uD83D\\uDE0E\\uD83D\\uDE4C HAPPY CODING !! \\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isValidSudoku(vector<vector<char>>& board) {\\n        int checkrow[10][10]={0},checkcol[10][10]={0},checkbox[10][10]={0};       //declaring three check arrays with initially zero values.\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col]==\\'.\\')continue;         //if not a number we need to skip to the next index.\\n                int num=board[row][col]-\\'0\\';                //as \\'char\\' is given we make it int.\\n                int box=(row/3)*3+(col/3);                 //applying formula\\n                if(checkrow[row][num] || checkcol[num][col] || checkbox[box][num])       //if any of the checker gives true then the number is already present in that row/col/box.\\n                    return false;\\n                checkrow[row][num]=checkcol[num][col]=checkbox[box][num]=true;       //after checking we set the values true\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1647166,
                "title": "javascript",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  \\n    const set = new Set()\\n    \\n    \\n    //i rows, j columns\\n    //check valid columns and rows O(9*9)\\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            const value = board[i][j]\\n            if(value !== \".\"){\\n                const rowString = `${value} at row ${i}`\\n                const colString = `${value} at col ${j}`\\n                const boxString = `${value} at box ${Math.floor(i/3)}, ${Math.floor(j/3)}`\\n                \\n                if(set.has(rowString) || set.has(colString) || set.has(boxString)){\\n                    return false\\n                }else{\\n                    set.add(rowString)\\n                    set.add(colString)\\n                    set.add(boxString)\\n                }\\n            }\\n        }\\n    }\\n\\n    return true\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  \\n    const set = new Set()\\n    \\n    \\n    //i rows, j columns\\n    //check valid columns and rows O(9*9)\\n    for(let i = 0; i < board.length; i++){\\n        for(let j = 0; j < board[0].length; j++){\\n            const value = board[i][j]\\n            if(value !== \".\"){\\n                const rowString = `${value} at row ${i}`\\n                const colString = `${value} at col ${j}`\\n                const boxString = `${value} at box ${Math.floor(i/3)}, ${Math.floor(j/3)}`\\n                \\n                if(set.has(rowString) || set.has(colString) || set.has(boxString)){\\n                    return false\\n                }else{\\n                    set.add(rowString)\\n                    set.add(colString)\\n                    set.add(boxString)\\n                }\\n            }\\n        }\\n    }\\n\\n    return true\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15660,
                "title": "share-my-solution-for-valid-sudoku",
                "content": "    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tboolean[][] row = new boolean[9][9];\\n\\t\\tboolean[][] col = new boolean[9][9];\\n\\t\\tboolean[][] box = new boolean[9][9];\\n\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tchar c = board[i][j];\\n\\t\\t\\t\\tif (c == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (c < '0' || c > '9')\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tint number = c - '1';\\n\\t\\t\\t\\tif (row[i][number] || col[j][number] || box[(i / 3) * 3 + j / 3][number])\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\trow[i][number] = true;\\n\\t\\t\\t\\tcol[j][number] = true;\\n\\t\\t\\t\\tbox[(i / 3) * 3 + j / 3][number] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tboolean[][] row = new boolean[9][9];\\n\\t\\tboolean[][] col = new boolean[9][9];\\n\\t\\tboolean[][] box = new boolean[9][9];\\n\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tchar c = board[i][j];\\n\\t\\t\\t\\tif (c == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (c < '0' || c > '9')\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tint number = c - '1';\\n\\t\\t\\t\\tif (row[i][number] || col[j][number] || box[(i / 3) * 3 + j / 3][number])\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\trow[i][number] = true;\\n\\t\\t\\t\\tcol[j][number] = true;\\n\\t\\t\\t\\tbox[(i / 3) * 3 + j / 3][number] = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2730348,
                "title": "java-hashset-easy",
                "content": "## Don\\'t forget to upvote if you like my solution \\uD83D\\uDE07\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (set.contains(n + \"r\" + i) || set.contains(n + \"c\" + j) ||\\n                        set.contains(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                    set.add(n + \"r\" + i);\\n                    set.add(n + \"c\" + j);\\n                    set.add(n + \"b\" + i / 3 + j / 3);\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n**The same thing can be done in a shorter way:**\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (!set.add(n + \"r\" + i) || \\n                        !set.add(n + \"c\" + j) ||\\n                        !set.add(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(9 ^ 2) => O(1)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (set.contains(n + \"r\" + i) || set.contains(n + \"c\" + j) ||\\n                        set.contains(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                    set.add(n + \"r\" + i);\\n                    set.add(n + \"c\" + j);\\n                    set.add(n + \"b\" + i / 3 + j / 3);\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                char n = board[i][j];\\n                if (n != \\'.\\') {\\n                    if (!set.add(n + \"r\" + i) || \\n                        !set.add(n + \"c\" + j) ||\\n                        !set.add(n + \"b\" + i / 3 + j / 3)) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(9 ^ 2) => O(1)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251171,
                "title": "c-explained-24ms-o-n2",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // To check if it is valid,\\n    // Firstly, replace the character with a \\'.\\' so that we can check even after this it is already present or not .. \\n    //  - Check for the entire row if it already has the same character twice? Return false if it does\\n    //  - Check for the entire col if it already has the same character twice? Return false if it does\\n    //  - Check for the 3x3 box to see it already has it? Return false if it does\\n    // Replace the incorrect \\'.\\' back to the character c\\n    \\n    // NOTE: Given a row, col, if we need to find the starting i,j of that 3x3 box, then we do row/3*3 and col/3*3\\n    \\n    bool isValid(vector<vector<char>>& board, int row, int col){\\n        int c = board[row][col];\\n        board[row][col] = \\'.\\';\\n        for(int i=0;i<9;i++)\\n            if(board[row][i] == c) return false;\\n        for(int i=0;i<9;i++)\\n            if(board[i][col] == c) return false;\\n        for(int i=0;i<3;i++)\\n            for(int j=0;j<3;j++)\\n                if(board[row/3*3 + i][col/3*3 + j] == c)\\n                    return false;\\n        \\n        board[row][col] = c;\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // Go for all the rows & columns looking for an invalid number\\n        // If you find an invalid entry, return false\\n        // If you don not find an invalid entry till the end, it has to be good, return true.\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\' && !isValid(board,i,j)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // To check if it is valid,\\n    // Firstly, replace the character with a \\'.\\' so that we can check even after this it is already present or not .. \\n    //  - Check for the entire row if it already has the same character twice? Return false if it does\\n    //  - Check for the entire col if it already has the same character twice? Return false if it does\\n    //  - Check for the 3x3 box to see it already has it? Return false if it does\\n    // Replace the incorrect \\'.\\' back to the character c\\n    \\n    // NOTE: Given a row, col, if we need to find the starting i,j of that 3x3 box, then we do row/3*3 and col/3*3\\n    \\n    bool isValid(vector<vector<char>>& board, int row, int col){\\n        int c = board[row][col];\\n        board[row][col] = \\'.\\';\\n        for(int i=0;i<9;i++)\\n            if(board[row][i] == c) return false;\\n        for(int i=0;i<9;i++)\\n            if(board[i][col] == c) return false;\\n        for(int i=0;i<3;i++)\\n            for(int j=0;j<3;j++)\\n                if(board[row/3*3 + i][col/3*3 + j] == c)\\n                    return false;\\n        \\n        board[row][col] = c;\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // Go for all the rows & columns looking for an invalid number\\n        // If you find an invalid entry, return false\\n        // If you don not find an invalid entry till the end, it has to be good, return true.\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\' && !isValid(board,i,j)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266986,
                "title": "c-solution-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_map<string,int>hash;\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col] != \\'.\\')\\n                {\\n    \\n                    string r= \"row\"+to_string(row)+to_string(board[row][col]);\\n                    string c= \"col\"+to_string(col)+to_string(board[row][col]);\\n                    int b = (row/3) * 3 + (col/3);\\n                    string box= \"box\"+ to_string(b) + to_string(board[row][col]);\\n\\n                    if(hash[r] != 1 && hash[c] != 1 && hash[box] != 1){\\n                        hash[r]=1;\\n                        hash[c]=1;\\n                        hash[box]=1;\\n                    }else{\\n                        return false;\\n                    }\\n\\n                    }\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_map<string,int>hash;\\n        for(int row=0;row<9;row++){\\n            for(int col=0;col<9;col++){\\n                if(board[row][col] != \\'.\\')\\n                {\\n    \\n                    string r= \"row\"+to_string(row)+to_string(board[row][col]);\\n                    string c= \"col\"+to_string(col)+to_string(board[row][col]);\\n                    int b = (row/3) * 3 + (col/3);\\n                    string box= \"box\"+ to_string(b) + to_string(board[row][col]);\\n\\n                    if(hash[r] != 1 && hash[c] != 1 && hash[box] != 1){\\n                        hash[r]=1;\\n                        hash[c]=1;\\n                        hash[box]=1;\\n                    }else{\\n                        return false;\\n                    }\\n\\n                    }\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15613,
                "title": "share-my-java-solution",
                "content": "    public class Solution {\\n    public Set<Character> set=new HashSet<Character>();\\n    public boolean isValidSudoku(char[][] board) {\\n       for(int i=0;i<9;i++){\\n           if(validPartial(board,i,i,0,8)==false) return false;\\n           if(validPartial(board,0,8,i,i)==false) return false;\\n       } \\n       for(int i=0;i<9;i+=3){\\n           for(int j=0;j<9;j+=3){\\n               if(validPartial(board,i,i+2,j,j+2)==false) return false;\\n           }\\n       }\\n       return true;\\n    }\\n    public boolean validPartial(char[][] board,int row1,int row2,int col1,int col2){\\n        set.clear();\\n        for(int i=row1;i<=row2;i++){\\n            for(int j=col1;j<=col2;j++){\\n                if(board[i][j]!='.') {\\n                    if(!set.add(board[i][j])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public Set<Character> set=new HashSet<Character>();\\n    public boolean isValidSudoku(char[][] board) {\\n       for(int i=0;i<9;i++){\\n           if(validPartial(board,i,i,0,8)==false) return false;\\n           if(validPartial(board,0,8,i,i)==false) return false;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 2291325,
                "title": "java-best-solution-to-ever-exist",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            char number = board[i][j];\\n            if(!map.add(number + \"in row\" + i) \\n               || !map.add(number + \"in column\" + j) \\n               || !map.add(number + \"in block\" + i / 3 + \"-\" + j / 3))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF YOU LIKED IT",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            char number = board[i][j];\\n            if(!map.add(number + \"in row\" + i) \\n               || !map.add(number + \"in column\" + j) \\n               || !map.add(number + \"in block\" + i / 3 + \"-\" + j / 3))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916780,
                "title": "javascript-simple-and-fast-solution-with-comments-easy-to-remember",
                "content": "```javascript\\nvar isValidSudoku = function(board) {\\n\\n    const map = {};                            // Map for storing our key-strings.\\n    \\n    for (let i = 0; i < 9; i++) {              // Outer-loop for rows.\\n        for (let j = 0; j < 9; j++) {          // Inner-loop for cols.\\n            \\n            if (board[i][j] === \\'.\\') continue; // Skip checking empty spaces.\\n            \\n            let num = board[i][j],\\n                x   = Math.floor(i / 3),       // We can iterate through each box\\n                y   = Math.floor(j / 3);       // using indices (i, j) divided by 3.\\n                \\n\\t\\t\\tlet err = (map[\\'r\\'+i+num] ||       // Check if any of the computed\\n\\t\\t\\t\\t\\t   map[\\'c\\'+j+num] ||       // key-strings already exist in\\n\\t\\t\\t\\t\\t   map[\\'b\\'+x+y+num]);      // our map object.\\n            \\n            if (err) return false;             // If \\'err\\' is true, board is invalid.\\n            \\n            map[\\'r\\'+i+num]   = 1;              // Add \\'row\\' key-string to map.\\n            map[\\'c\\'+j+num]   = 1;              // Add \\'col\\' key-string to map.\\n            map[\\'b\\'+x+y+num] = 1;              // Add \\'box\\' key-string to map.\\n        }\\n    }\\n    \\n    return true;                               // If no error, board is valid.\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isValidSudoku = function(board) {\\n\\n    const map = {};                            // Map for storing our key-strings.\\n    \\n    for (let i = 0; i < 9; i++) {              // Outer-loop for rows.\\n        for (let j = 0; j < 9; j++) {          // Inner-loop for cols.\\n            \\n            if (board[i][j] === \\'.\\') continue; // Skip checking empty spaces.\\n            \\n            let num = board[i][j],\\n                x   = Math.floor(i / 3),       // We can iterate through each box\\n                y   = Math.floor(j / 3);       // using indices (i, j) divided by 3.\\n                \\n\\t\\t\\tlet err = (map[\\'r\\'+i+num] ||       // Check if any of the computed\\n\\t\\t\\t\\t\\t   map[\\'c\\'+j+num] ||       // key-strings already exist in\\n\\t\\t\\t\\t\\t   map[\\'b\\'+x+y+num]);      // our map object.\\n            \\n            if (err) return false;             // If \\'err\\' is true, board is invalid.\\n            \\n            map[\\'r\\'+i+num]   = 1;              // Add \\'row\\' key-string to map.\\n            map[\\'c\\'+j+num]   = 1;              // Add \\'col\\' key-string to map.\\n            map[\\'b\\'+x+y+num] = 1;              // Add \\'box\\' key-string to map.\\n        }\\n    }\\n    \\n    return true;                               // If no error, board is valid.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427130,
                "title": "very-clear-js-solution-memory-100-time-95",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  let rows = new Set();\\n  let cols = new Set();\\n  let boxes = new Set();\\n  let curRowElem;\\n  let curColElem;\\n  let curBoxElem;\\n\\n  for (let i = 0; i < board.length; i += 1) {\\n    for (let j = 0; j < board[0].length; j += 1) {\\n      curRowElem = board[i][j]\\n      curColElem = board[j][i]\\n      curBoxElem = board[3 * Math.floor(i / 3) + Math.floor(j / 3)][((i * 3) % 9) + (j % 3)]\\n\\n      if (rows.has(curRowElem)) return false;\\n      if (curRowElem !== \".\") rows.add(curRowElem);\\n\\n      if (cols.has(curColElem)) return false;\\n      if (curColElem !== \".\") cols.add(curColElem);\\n\\n      if (boxes.has(curBoxElem)) return false;\\n      if (curBoxElem !== \".\") boxes.add(curBoxElem);\\n    }\\n\\n    rows.clear()\\n    cols.clear()\\n    boxes.clear()\\n  }\\n\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  let rows = new Set();\\n  let cols = new Set();\\n  let boxes = new Set();\\n  let curRowElem;\\n  let curColElem;\\n  let curBoxElem;\\n\\n  for (let i = 0; i < board.length; i += 1) {\\n    for (let j = 0; j < board[0].length; j += 1) {\\n      curRowElem = board[i][j]\\n      curColElem = board[j][i]\\n      curBoxElem = board[3 * Math.floor(i / 3) + Math.floor(j / 3)][((i * 3) % 9) + (j % 3)]\\n\\n      if (rows.has(curRowElem)) return false;\\n      if (curRowElem !== \".\") rows.add(curRowElem);\\n\\n      if (cols.has(curColElem)) return false;\\n      if (curColElem !== \".\") cols.add(curColElem);\\n\\n      if (boxes.has(curBoxElem)) return false;\\n      if (curBoxElem !== \".\") boxes.add(curBoxElem);\\n    }\\n\\n    rows.clear()\\n    cols.clear()\\n    boxes.clear()\\n  }\\n\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729690,
                "title": "swift-easy-solution-using-hashset",
                "content": "```\\nfinal class Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        var seen = Set<String>()\\n        for i in 0..<9 {\\n            for j in 0..<9 {\\n                let currVal = board[i][j]\\n                if currVal == \".\" {\\n                    continue\\n                }\\n                let row = \"\\\\(currVal) found in row \\\\(i)\"\\n                let col = \"\\\\(currVal) found in col \\\\(j)\"\\n                let box = \"\\\\(currVal) found in box \\\\((i/3)) - \\\\((j/3))\"\\n                if seen.contains(row) {\\n                    return false\\n                } else {\\n                    seen.insert(row)\\n                }\\n                if seen.contains(col) {\\n                    return false\\n                } else {\\n                    seen.insert(col)\\n                }\\n                if seen.contains(box) {\\n                    return false\\n                } else {\\n                    seen.insert(box)\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        var seen = Set<String>()\\n        for i in 0..<9 {\\n            for j in 0..<9 {\\n                let currVal = board[i][j]\\n                if currVal == \".\" {\\n                    continue\\n                }\\n                let row = \"\\\\(currVal) found in row \\\\(i)\"\\n                let col = \"\\\\(currVal) found in col \\\\(j)\"\\n                let box = \"\\\\(currVal) found in box \\\\((i/3)) - \\\\((j/3))\"\\n                if seen.contains(row) {\\n                    return false\\n                } else {\\n                    seen.insert(row)\\n                }\\n                if seen.contains(col) {\\n                    return false\\n                } else {\\n                    seen.insert(col)\\n                }\\n                if seen.contains(box) {\\n                    return false\\n                } else {\\n                    seen.insert(box)\\n                }\\n            }\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15469,
                "title": "11-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        vector<unordered_map<char, int>>row(n);\\n        vector<unordered_map<char, int>>col(n);\\n        vector<vector<unordered_map<char, int>>>sub(n/3, vector<unordered_map<char, int>>(n/3));\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                char c = board[i][j];\\n                if(c == '.') continue;\\n                if(row[i][c]++ > 0 || col[j][c]++ > 0 || sub[i/3][j/3][c]++ > 0) return false;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        vector<unordered_map<char, int>>row(n);\\n        vector<unordered_map<char, int>>col(n);\\n        vector<vector<unordered_map<char, int>>>sub(n/3, vector<unordered_map<char, int>>(n/3));\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++){\\n                char c = board[i][j];\\n                if(c == '.') continue;\\n                if(row[i][c]++ > 0 || col[j][c]++ > 0 || sub[i/3][j/3][c]++ > 0) return false;\\n            }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430239,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<String> check = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    // Making a unique key for every element\\n                    String row = board[i][j] + \"in row\" + i;\\n                    String col = board[i][j] + \"in col\" + j;\\n                    String box = board[i][j] + \"in box\" + i/3 + \"and\" + j/3;\\n                    \\n                    if(check.contains(row) || check.contains(col) || check.contains(box)){\\n                        return false;\\n                    }\\n                    \\n                    check.add(row);\\n                    check.add(col);\\n                    check.add(box);\\n                }\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n\\n\\n**Upvote if you find it easy to understand :)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<String> check = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    // Making a unique key for every element\\n                    String row = board[i][j] + \"in row\" + i;\\n                    String col = board[i][j] + \"in col\" + j;\\n                    String box = board[i][j] + \"in box\" + i/3 + \"and\" + j/3;\\n                    \\n                    if(check.contains(row) || check.contains(col) || check.contains(box)){\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1206509,
                "title": "python3-no-need-explanation-solution-15-lines",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        row_bag = defaultdict(set)\\n        col_bag = defaultdict(set)\\n        sec_bag = defaultdict(set)\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                num = board[i][j]\\n\\n                if not num.isdigit():\\n                    continue\\n\\n                sec = (i // 3, j // 3)\\n                if num in row_bag[i] or num in col_bag[j] or num in sec_bag[sec]:\\n                    return False\\n                else:\\n                    row_bag[i].add(num)\\n                    col_bag[j].add(num)\\n                    sec_bag[sec].add(num)\\n        return True\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        row_bag = defaultdict(set)\\n        col_bag = defaultdict(set)\\n        sec_bag = defaultdict(set)\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                num = board[i][j]\\n\\n                if not num.isdigit():\\n                    continue\\n\\n                sec = (i // 3, j // 3)\\n                if num in row_bag[i] or num in col_bag[j] or num in sec_bag[sec]:\\n                    return False\\n                else:\\n                    row_bag[i].add(num)\\n                    col_bag[j].add(num)\\n                    sec_bag[sec].add(num)\\n        return True\\n",
                "codeTag": "Java"
            },
            {
                "id": 15578,
                "title": "fast-and-clean-java-solution",
                "content": "       public boolean isValidSudoku(char[][] board) {\\n            //first dimension 0/horizontal 1/vertical 2/square\\n            //second dimension 0-8 represents the ith row/column/square\\n            //third dimension represents the occurrence of number 1-9\\n            boolean[][][] occur = new boolean[3][9][9];\\n            for (int i = 0; i < 9; i++){\\n                for (int j = 0; j < 9; j++){\\n                    if (board[i][j] == '.') continue;\\n                    int num = board[i][j] - '1';\\n                    if (occur[0][i][num]) return false;\\n                    else occur[0][i][num] = true;\\n                    if (occur[1][j][num]) return false;\\n                    else occur[1][j][num] = true;\\n                    int s = (i / 3) * 3 + j / 3;\\n                    if (occur[2][s][num]) return false;\\n                    else occur[2][s][num] = true;\\n                }\\n            }\\n            return true;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "       public boolean isValidSudoku(char[][] board) {\\n            //first dimension 0/horizontal 1/vertical 2/square\\n            //second dimension 0-8 represents the ith row/column/square\\n            //third dimension represents the occurrence of number 1-9\\n            boolean[][][] occur = new boolean[3][9][9];\\n            for (int i = 0; i < 9; i++){\\n                for (int j = 0; j < 9; j++){\\n                    if (board[i][j] == '.') continue;\\n                    int num = board[i][j] - '1';\\n                    if (occur[0][i][num]) return false;\\n                    else occur[0][i][num] = true;\\n                    if (occur[1][j][num]) return false;\\n                    else occur[1][j][num] = true;\\n                    int s = (i / 3) * 3 + j / 3;\\n                    if (occur[2][s][num]) return false;\\n                    else occur[2][s][num] = true;\\n                }\\n            }\\n            return true;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3689261,
                "title": "very-easy-to-understand-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Very first approach in my mind** : Iterate through begining and create vector of vector of size 9 and keep checking for duplicates .\\nthis approach will also accpeted due to small size of problem .\\nTime complaxity O(n^3) // we check every index 3 times .\\nSpace complexiyt O(n^2)  // we create vector of vector.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create set of pair of integer and char. And iterate through each index and check for row,col and grid , If yes they are there than we return false. Because the integer part denote the Row number abd character part denote the value at that respective row .If any pair will be same means the same value is presemt in same row .\\nSame for col and grid .\\n\\ngrid means the division of 3*3 sections,which we give the numbering from 0-9. we can calculate it through the given row and column number .\\n\\n---\\n\\n000 111 222  \\n000 111 222\\n000 111 222        \\n333 444 555\\n333 444 555\\n333 444 555\\n666 777 888\\n666 777 888\\n666 777 888\\n\\n---\\n\\nThis is our grid number and we can simply calculate it as we iterater following **:::::::** (0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(1,0)..... so on.\\nso our grid will will be such that ---> Divide the row by 3 **(gives the row no and divide by 3 gives the grid )**  than multiply by 3 **(represent that one row has the vlaue of 3 grid)** than add in it the vlaue of col/3;\\n\\n**you can give your view also to make better understanding**\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \"where n is the size of box\" \\n as we iterate onces at every index \\n\\n//give your view also ,your view is very helpful for me \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) we create set of pair\\n\\n//give your view also ,your view is very helpful for me \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<pair<int,char>> row,col,grid;\\n\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                int count=(i/3)*3 +j/3;\\n                \\n                if(row.find({i,board[i][j]})==row.end())\\n                    row.insert({{i,board[i][j]}});\\n                 else return false;\\n\\n                if(col.find({j,board[i][j]})==col.end())\\n                    col.insert({{j,board[i][j]}});\\n                 else return false;\\n\\n                if(grid.find({count,board[i][j]})==grid.end())\\n                    grid.insert({{count,board[i][j]}});\\n                 else  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<pair<int,char>> row,col,grid;\\n\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                int count=(i/3)*3 +j/3;\\n                \\n                if(row.find({i,board[i][j]})==row.end())\\n                    row.insert({{i,board[i][j]}});\\n                 else return false;\\n\\n                if(col.find({j,board[i][j]})==col.end())\\n                    col.insert({{j,board[i][j]}});\\n                 else return false;\\n\\n                if(grid.find({count,board[i][j]})==grid.end())\\n                    grid.insert({{count,board[i][j]}});\\n                 else  return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415177,
                "title": "c-simple-and-easy-10-short-line-solution",
                "content": "For each row, column and block we keep a set of numbers.\\nIf we find a number that was seen already in that row, column or block - return false.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414924,
                "title": "python-check-27-conditions-explained",
                "content": "We just need to check all `27` conditions - for every row, every column and every square.\\n\\n1. First `3` lines of code to check rows and columns: we check each row in `board` and in transposed board `*board` and collect all elements which are not equal to `.`\\n2. Next `4` lines of code to check all `9` cells: first we create all centers of `3x3` cells and then again collect all elements, not equal to `.`\\n\\n#### Complexity\\nTime complexity is `O(n^2)`, where `n` is size of board, space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def isValidSudoku(self, board):\\n        for row in chain(board, zip(*board)):\\n            cand = [i for i in row if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n            \\n        for x, y in product([1,4,7],[1,4,7]):\\n            cand = [board[x+i][y+j] for i,j in product([-1,0,1],[-1,0,1])]\\n            cand = [i for i in cand if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n        \\n        return True\\n```\\n\\nf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board):\\n        for row in chain(board, zip(*board)):\\n            cand = [i for i in row if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n            \\n        for x, y in product([1,4,7],[1,4,7]):\\n            cand = [board[x+i][y+j] for i,j in product([-1,0,1],[-1,0,1])]\\n            cand = [i for i in cand if i != \".\"]\\n            if len(set(cand)) != len(cand): return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15662,
                "title": "java-solution-using-array-of-hashset",
                "content": "\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet[] row = new HashSet[9];\\n        HashSet[] col = new HashSet[9];\\n        HashSet[] cell = new HashSet[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<Character>();\\n            col[i] = new HashSet<Character>();\\n            cell[i] = new HashSet<Character>();\\n        }\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    if (row[i].contains(board[i][j]) || col[j].contains(board[i][j]) || cell[3*(i/3)+j/3].contains(board[i][j])) {\\n                        return false;\\n                    } else {\\n                        row[i].add(board[i][j]);\\n                        col[j].add(board[i][j]);\\n                        cell[3*(i/3)+j/3].add(board[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet[] row = new HashSet[9];\\n        HashSet[] col = new HashSet[9];\\n        HashSet[] cell = new HashSet[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<Character>();\\n            col[i] = new HashSet<Character>();\\n            cell[i] = new HashSet<Character>();\\n        }\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != '.') {\\n                    if (row[i].contains(board[i][j]) || col[j].contains(board[i][j]) || cell[3*(i/3)+j/3].contains(board[i][j])) {\\n                        return false;\\n                    } else {\\n                        row[i].add(board[i][j]);\\n                        col[j].add(board[i][j]);\\n                        cell[3*(i/3)+j/3].add(board[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3471217,
                "title": "solution-with-explanatory",
                "content": "# Intuition\\nWe will go through 3 steps to check the correctness of the sudoku.\\n1-By checking each line, we will see if there are any numbers that are the same as each other.\\n2-We will check every 3x3 square to see if there are any numbers that are the same.\\n3- By checking each column, we will see if there are any numbers that are the same.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1- We will sort each row in order and check if it is a consecutive number.\\n\\n2-We will check with for loops for every3x3 block. While the first 2 for loops will travel through the squares in order, the next 2 for loops will travel inside the squares and each number inside the squares will be assigned to the vector we call control. Then, the elements in the vector will be sorted and it will be checked whether they are consecutive numbers.\\n\\n3- A for loop will return every column. The other for loop will through the columns and assign the elements inside each column to the control2 vector. We will perform a sequential number comparison by sorting the assigned elements.\\n\\nif consecutive number detection occurs at these stages, the function return false. Function return true if sudoku doesn\\'t get stuck in controls\\n<!-- Describe your approach to solving the problem. -->\\n\\n# extra\\nIf you get stuck on the solution, I can help you in the comments.\\n\\nI spend a lot of effort deciphering the codes, if you found the solution useful, you can support me by upvoting.Thanks.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    \\t\\n\\n//      1-Rows--------------------\\n\\n    \\tfor(int t=0; t<9; t++){\\n    \\t\\tvector<char> vv = board[t];\\n    \\t    std::sort(vv.begin(), vv.end());\\n    \\t    for(int a=0; a<8; a++){\\n    \\t        if(vv[a] == vv[a+1] && vv[a] != \\'.\\'){\\n    \\t        \\treturn false;\\n    \\t        }\\n    \\t    }\\n    \\t}\\n//      2-3x3 Squares-------------\\n\\n    \\tfor(int i=0; i<9; i+=3) { \\n\\t        for(int j=0; j<9; j+=3) {\\n\\t            vector<char> control;\\n\\t            for(int k=0; k<3; k++) {\\n\\t                for(int l=0; l<3; l++) {\\n\\t                    control.push_back(board[i+k][j+l]);\\n\\t                }\\n\\t            }\\n\\t            sort(control.begin(), control.end()); \\n\\t            for(int k=1; k<control.size(); k++) {\\n\\t                if(control[k] == control[k-1] && control[k] != \\'.\\') {\\n\\t                    return false; \\n\\t                }\\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n\\n//      3-Columns------------------\\n\\n    \\tfor(int j=0; j<9; j++) { \\n\\t        vector<char> control2;\\n\\t        for(int i=0; i<9; i++) {\\n\\t            control2.push_back(board[i][j]);\\n\\t        }\\n\\t        sort(control2.begin(), control2.end()); \\n\\t        for(int k=1; k<control2.size(); k++) {\\n\\t            if(control2[k] == control2[k-1] && control2[k] != \\'.\\') {\\n\\t                return false; \\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n    \\treturn true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n    \\t\\n\\n//      1-Rows--------------------\\n\\n    \\tfor(int t=0; t<9; t++){\\n    \\t\\tvector<char> vv = board[t];\\n    \\t    std::sort(vv.begin(), vv.end());\\n    \\t    for(int a=0; a<8; a++){\\n    \\t        if(vv[a] == vv[a+1] && vv[a] != \\'.\\'){\\n    \\t        \\treturn false;\\n    \\t        }\\n    \\t    }\\n    \\t}\\n//      2-3x3 Squares-------------\\n\\n    \\tfor(int i=0; i<9; i+=3) { \\n\\t        for(int j=0; j<9; j+=3) {\\n\\t            vector<char> control;\\n\\t            for(int k=0; k<3; k++) {\\n\\t                for(int l=0; l<3; l++) {\\n\\t                    control.push_back(board[i+k][j+l]);\\n\\t                }\\n\\t            }\\n\\t            sort(control.begin(), control.end()); \\n\\t            for(int k=1; k<control.size(); k++) {\\n\\t                if(control[k] == control[k-1] && control[k] != \\'.\\') {\\n\\t                    return false; \\n\\t                }\\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n\\n//      3-Columns------------------\\n\\n    \\tfor(int j=0; j<9; j++) { \\n\\t        vector<char> control2;\\n\\t        for(int i=0; i<9; i++) {\\n\\t            control2.push_back(board[i][j]);\\n\\t        }\\n\\t        sort(control2.begin(), control2.end()); \\n\\t        for(int k=1; k<control2.size(); k++) {\\n\\t            if(control2[k] == control2[k-1] && control2[k] != \\'.\\') {\\n\\t                return false; \\n\\t            }\\n\\t        }\\n    \\t}\\n    \\t\\n    \\treturn true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414952,
                "title": "python-super-easy-set-validation",
                "content": "**Idea**\\n* First create function `valid` to check duplicates \\n* Then simply check Validation **row wise**, **Column wise** and **Block wise** \\n* if either of them found not valid return **false**    and if all of them passed validation then simply return **true**\\n\\n**Complexity**\\n* Time Complexity :- `O(n^2)` i.e `O(81)`\\n* Space Complexity :- `O(n)` i.e. `O(9)` , because of `seen`, `col` and `block`\\n\\n**Block creation**\\ni/j \\xA0   0..2 3..5 6..8\\n0..2 \\xA0B1  \\xA0B2 \\xA0 B3\\n3..5 \\xA0B4  \\xA0B5  \\xA0B6\\n6..8 \\xA0B7 \\xA0 B8 \\xA0 B9\\n\\n**B1** and **B6** can be represented as \\n```\\nB1 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  B6\\n00 01 02 \\xA0 \\xA0 \\xA0 \\xA036 37 38\\n10 11 12 \\xA0 \\xA0 \\xA0 \\xA046 47 48\\n20 21 22 \\xA0 \\xA0 \\xA0 \\xA056 57 58\\n```\\n\\n**code** \\xA0 \\xA0 \\xA0 \\xA0\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking if 1D array valid\\n        def valid(arr):\\n            seen = set()\\n            for val in arr:\\n                if val == \\'.\\':\\n                    continue\\n                if val in seen:\\n                    return False\\n                seen.add(val)\\n            return True\\n        \\n        #Row wise\\n        for row in board:\\n            if not valid(row):\\n                return False\\n        \\n        #column wise\\n        for j in range(9):\\n            col = [board[i][j] for i in range(9)]\\n            if not valid(col):\\n                return False\\n       \\n        #Block wise\\n        for i in range(0, 9, 3):\\n            for j in range(0, 9, 3):\\n                block = [board[k][l] for k in range(i, i+3) for l in range(j, j+3)]\\n                if not valid(block):\\n                    return False\\n \\xA0 \\xA0 \\xA0 \\xA0return True\\n```\\n\\n*Please upvote if you like the solution and comment if have queries*. \\xA0 \\xA0 \\xA0",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nB1 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  B6\\n00 01 02 \\xA0 \\xA0 \\xA0 \\xA036 37 38\\n10 11 12 \\xA0 \\xA0 \\xA0 \\xA046 47 48\\n20 21 22 \\xA0 \\xA0 \\xA0 \\xA056 57 58\\n```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking if 1D array valid\\n        def valid(arr):\\n            seen = set()\\n            for val in arr:\\n                if val == \\'.\\':\\n                    continue\\n                if val in seen:\\n                    return False\\n                seen.add(val)\\n            return True\\n        \\n        #Row wise\\n        for row in board:\\n            if not valid(row):\\n                return False\\n        \\n        #column wise\\n        for j in range(9):\\n            col = [board[i][j] for i in range(9)]\\n            if not valid(col):\\n                return False\\n       \\n        #Block wise\\n        for i in range(0, 9, 3):\\n            for j in range(0, 9, 3):\\n                block = [board[k][l] for k in range(i, i+3) for l in range(j, j+3)]\\n                if not valid(block):\\n                    return False\\n \\xA0 \\xA0 \\xA0 \\xA0return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827706,
                "title": "c-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][10];\\n        int cols[9][10];\\n        int boxes[9][10];\\n        memset(rows, 0, sizeof(rows));\\n        memset(cols, 0, sizeof(cols));\\n        memset(boxes, 0, sizeof(boxes));\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'0\\';\\n                    if (++rows[i][num] > 1 || ++cols[j][num] > 1 || ++boxes[(i/3)*3 + j/3][num] > 1) return false;\\n                \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int rows[9][10];\\n        int cols[9][10];\\n        int boxes[9][10];\\n        memset(rows, 0, sizeof(rows));\\n        memset(cols, 0, sizeof(cols));\\n        memset(boxes, 0, sizeof(boxes));\\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    int num = board[i][j] - \\'0\\';\\n                    if (++rows[i][num] > 1 || ++cols[j][num] > 1 || ++boxes[(i/3)*3 + j/3][num] > 1) return false;\\n                \\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15576,
                "title": "java-clear-solution",
                "content": "    public class Solution {\\n    public static boolean isValidSudoku(char[][] board) {\\n    \\t\\tSet<Character>[] setXX = new HashSet[9];\\n    \\t\\tSet<Character>[] setYY = new HashSet[9];\\n    \\t\\tSet<Character>[] setXY = new HashSet[9];\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tsetXX[i] = new HashSet<>();\\n    \\t\\t\\tsetYY[i] = new HashSet<>();\\n    \\t\\t\\tsetXY[i] = new HashSet<>();\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tfor (int j = 0; j < 9; j++) {\\n    \\t\\t\\t\\tif (board[i][j] == '.') {\\n    \\t\\t\\t\\t\\tcontinue;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setXX[i].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setYY[j].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif(!setXY[(j / 3)* 3 + i / 3].add(board[i][j])){\\n    \\t\\t\\t\\t\\treturn false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn true;\\n    \\t}\\n    \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public static boolean isValidSudoku(char[][] board) {\\n    \\t\\tSet<Character>[] setXX = new HashSet[9];\\n    \\t\\tSet<Character>[] setYY = new HashSet[9];\\n    \\t\\tSet<Character>[] setXY = new HashSet[9];\\n    \\t\\tfor (int i = 0; i < 9; i++) {\\n    \\t\\t\\tsetXX[i] = new HashSet<>();\\n    \\t\\t\\tsetYY[i] = new HashSet<>();\\n    \\t\\t\\tsetXY[i] = new HashSet<>();\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2840682,
                "title": "c-java-not-the-fastest-but-the-most-simple-to-grasp",
                "content": "\\nHere we will run two for loops, one for rows and one for columns,\\nIf the element in the board is a number from 1 to 9 then we will check their presence---->\\n* IN THAT ROW : by using a row checker 2d array\\n* IN THE COLUMN : by using a column checker 2d array\\n* IN THAT BOX : by using the formula (row/3)3+(col/3) \\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean IsSafe(char[][] board, int row, int col, char num){\\n\\n        for(int i = col+1; i < 9; i++){         //for row checking\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n\\n        for(int i = row+1; i < 9; i++){         //For col checking\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n\\n        int x = row - row%3, y = col-col%3;        //for internal square\\n        for(int i = x; i < x+3; i++){\\n            for(int j = y; j < y+3; j++){\\n                if(board[i][j] == num && !(i == row && j == col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    } \\n    public boolean isValidSudoku(char[][] board) {\\n\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    if(!IsSafe(board, i, j, board[i][j]))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n--------------------------------------------\\n\\n**c++**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSafe(vector<vector<char>>& board , int temp, int row, int col)\\n    {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[row][i] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[i][col] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[row/3 *3 + i/3] [  col/3 * 3 +   (i%3)  ] == temp)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board.size();j++)\\n            {\\n                \\n                if(board[i][j] != \\'.\\')                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                {\\n                    int temp = board[i][j];\\n                    board[i][j]  = \\'*\\';\\n                    if(!isSafe(board, temp, i ,j))\\n                    {\\n                        return false;\\n                    }\\n                    board[i][j] =  temp;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n-----------------------------------------------\\n\\n**However, if you need a faster and more optimal solution, here it is:**\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int row[9][9] = {0}, col[9][9] = {0}, sub[9][9] = {0};\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++)  {\\n                if(board[i][j] != \\'.\\')  {\\n                    int num = board[i][j] - \\'0\\' - 1, k = i/3*3 + j/3;\\n                    if(row[i][num] || col[j][num] || sub[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = sub[k][num] = 1;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean IsSafe(char[][] board, int row, int col, char num){\\n\\n        for(int i = col+1; i < 9; i++){         //for row checking\\n            if(board[row][i] == num)\\n                return false;\\n        }\\n\\n        for(int i = row+1; i < 9; i++){         //For col checking\\n            if(board[i][col] == num)\\n                return false;\\n        }\\n\\n        int x = row - row%3, y = col-col%3;        //for internal square\\n        for(int i = x; i < x+3; i++){\\n            for(int j = y; j < y+3; j++){\\n                if(board[i][j] == num && !(i == row && j == col))\\n                    return false;\\n            }\\n        }   \\n        return true;\\n    } \\n    public boolean isValidSudoku(char[][] board) {\\n\\n        for(int i = 0; i < 9; i++){\\n            for(int j = 0; j < 9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    if(!IsSafe(board, i, j, board[i][j]))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool isSafe(vector<vector<char>>& board , int temp, int row, int col)\\n    {\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[row][i] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[i][col] == temp)\\n            {\\n                return false;\\n            }\\n            if(board[row/3 *3 + i/3] [  col/3 * 3 +   (i%3)  ] == temp)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board.size();j++)\\n            {\\n                \\n                if(board[i][j] != \\'.\\')                // If the position is a number (!= \\'.\\'), and it is a not a valid placement, then return false.\\n                {\\n                    int temp = board[i][j];\\n                    board[i][j]  = \\'*\\';\\n                    if(!isSafe(board, temp, i ,j))\\n                    {\\n                        return false;\\n                    }\\n                    board[i][j] =  temp;\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int row[9][9] = {0}, col[9][9] = {0}, sub[9][9] = {0};\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++)  {\\n                if(board[i][j] != \\'.\\')  {\\n                    int num = board[i][j] - \\'0\\' - 1, k = i/3*3 + j/3;\\n                    if(row[i][num] || col[j][num] || sub[k][num])\\n                        return false;\\n                    row[i][num] = col[j][num] = sub[k][num] = 1;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397764,
                "title": "java-simple-solution-hashset",
                "content": "PLEASE UPVOTE IF YOU LIKE IT-\\n\\n**keypoint**- HashSet returns true if element is not present in HashSet else returns false;\\n\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n       HashSet<String> seen = new HashSet<>();\\n      \\n        for(int i=0; i<9; i++){\\n             for(int j=0; j<9; j++){\\n              if(board[i][j] != \\'.\\'){ \\n                  char currentVal = board[i][j];\\n                   if(!(seen.add(currentVal + \"found in row \"+ i)) ||\\n                      !(seen.add(currentVal + \"found in column \"+ j) ) ||\\n                      !(seen.add(currentVal + \"found in sub box \"+ i/3 + \"-\"+ j/3)))\\n                       return false;\\n              }\\n          \\n           } \\n        \\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n       HashSet<String> seen = new HashSet<>();\\n      \\n        for(int i=0; i<9; i++){\\n             for(int j=0; j<9; j++){\\n              if(board[i][j] != \\'.\\'){ \\n                  char currentVal = board[i][j];\\n                   if(!(seen.add(currentVal + \"found in row \"+ i)) ||\\n                      !(seen.add(currentVal + \"found in column \"+ j) ) ||\\n                      !(seen.add(currentVal + \"found in sub box \"+ i/3 + \"-\"+ j/3)))\\n                       return false;\\n              }\\n          \\n           } \\n        \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905778,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        func isInvalid(_ box: [Character]) -> Bool {\\n            var chars: [Character] = []\\n            for c in box where c != \".\" {\\n                if chars.contains(c) { return true } else { chars.append(c) }\\n            }\\n            return false\\n        }\\n\\n        for i in 0..<9 {\\n            if isInvalid(board[i]) { return false }\\n            if isInvalid(board.map({ $0[i] })) { return false }\\n            let col = (i % 3) * 3\\n            let row = (i / 3) * 3\\n            let box = Array(board[row][col..<col + 3]) + Array(board[row + 1][col..<col + 3]) + Array(board[row + 2][col..<col + 3])\\n            if isInvalid(box) { return false }\\n        }\\n        return true\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        func isInvalid(_ box: [Character]) -> Bool {\\n            var chars: [Character] = []\\n            for c in box where c != \".\" {\\n                if chars.contains(c) { return true } else { chars.append(c) }\\n            }\\n            return false\\n        }\\n\\n        for i in 0..<9 {\\n            if isInvalid(board[i]) { return false }\\n            if isInvalid(board.map({ $0[i] })) { return false }\\n            let col = (i % 3) * 3\\n            let row = (i / 3) * 3\\n            let box = Array(board[row][col..<col + 3]) + Array(board[row + 1][col..<col + 3]) + Array(board[row + 2][col..<col + 3])\\n            if isInvalid(box) { return false }\\n        }\\n        return true\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15605,
                "title": "3ms-concise-java-solution-with-bit-operation",
                "content": "    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            int[] rows = new int[9];\\n            int[] columns = new int[9];\\n            int[] blocks = new int[9];\\n            for(int i=0;i<9;i++){\\n                for(int j=0;j<9;j++){\\n                    int mask = board[i][j]=='.'?0:(1<<(board[i][j]-'0'));\\n                    if(mask==0) continue;\\n                    if((rows[i]&mask)!=0) return false;\\n                    if((columns[j]&mask)!=0) return false;\\n                    if((blocks[i/3*3+j/3]&mask)!=0) return false;\\n                    rows[i] |= mask;\\n                    columns[j] |= mask;\\n                    blocks[i/3*3+j/3] |= mask;\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            int[] rows = new int[9];\\n            int[] columns = new int[9];\\n            int[] blocks = new int[9];\\n            for(int i=0;i<9;i++){\\n                for(int j=0;j<9;j++){\\n                    int mask = board[i][j]=='.'?0:(1<<(board[i][j]-'0'));\\n                    if(mask==0) continue;\\n                    if((rows[i]&mask)!=0) return false;\\n                    if((columns[j]&mask)!=0) return false;\\n                    if((blocks[i/3*3+j/3]&mask)!=0) return false;\\n                    rows[i] |= mask;\\n                    columns[j] |= mask;\\n                    blocks[i/3*3+j/3] |= mask;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 705765,
                "title": "good-explanation-for-the-same-code-as-in-discussion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // Ok so it was a freaking great solution\\n        // What are we going to do is, lets say i got 3 2d vectors\\n        /// Now, I am going to start with current i,j i.e each row will have its\\n        // Own box, so my 0th row, will have a unique element box as well as 0th Column\\n        // So, for eg, if we start with the first element 5, we are going to check if\\n        // [0][5] present or not, that is, does current row have 5 as element or not\\n        // In similar way [0][5] for column, now, what about, the 3x3 box, what to do \\n        // about that, well this where freakin thinking of the user paid off\\n        // Ok so what we are going to do is, we are going to assign every 3x3 grid \\n        // as 1 box, i.e, First 3x3 Grid will have 0 number box, which will store all\\n        // The unique elements.\\n        \\n        vector<vector<int>> rbox(9, vector<int>(9)), cbox(9, vector<int>(9)), ubox(9, vector<int>(9));\\n        // Ok so this are row boxes, column boxes, unique boxes\\n        \\n        for(int i = 0;i<board.size();i++){\\n            for(int j = 0; j< board[i].size(); j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int nums = board[i][j] - \\'0\\' - 1;\\n                    // Now this is how we are going to check with respect to particular point\\n                    // Lets say our point is (1,2) That means I need to check 0th Unique Box if\\n                    // The element present is there or not\\n                    // Now how are we going to achieve that 0th Number, lets see,\\n                    // First of all, as you can see both are less than 3 becoz we need 3x3 grid\\n                    // Now lets take another example (2,6) Now which Unique Box it will be in\\n                    // It will be in 3rd Box, now how should we make a value that unique,\\n                    // Ok so we could reduce both numbers 2/3 = 0, 6/3 = 2 (As per indexing)\\n                    // Ok so if we divide the index by 3 it will be good, but\\n                    // Lets take another point, (6, 7) 6/3 = 2, 7/3 = 2 => 4th Unique Box\\n                    // Which is wrong, instead it will be in 9th Unique Box, so we are going to \\n                    // do that, by multiplying, ith index by 3 we will get 2x3 = 6, 6 + 2 \\n                    // which is 8(Indexing), we got our 9th Unique Box, noice\\n                    // Lets apply for our first point, and see if it helps\\n                    // 1/3 = 0, 0x3 = 0; 2/3 = 0 => Which means we are at our 1st Unique box\\n                    // Noice.....\\n                    int k = i/3*3 + j/3;\\n\\n                    if(rbox[i][nums] || cbox[j][nums] || ubox[k][nums]){\\n                        return false;\\n                    }\\n\\n                    rbox[i][nums] = cbox[j][nums] = ubox[k][nums] = 1;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // Ok so it was a freaking great solution\\n        // What are we going to do is, lets say i got 3 2d vectors\\n        /// Now, I am going to start with current i,j i.e each row will have its\\n        // Own box, so my 0th row, will have a unique element box as well as 0th Column\\n        // So, for eg, if we start with the first element 5, we are going to check if\\n        // [0][5] present or not, that is, does current row have 5 as element or not\\n        // In similar way [0][5] for column, now, what about, the 3x3 box, what to do \\n        // about that, well this where freakin thinking of the user paid off\\n        // Ok so what we are going to do is, we are going to assign every 3x3 grid \\n        // as 1 box, i.e, First 3x3 Grid will have 0 number box, which will store all\\n        // The unique elements.\\n        \\n        vector<vector<int>> rbox(9, vector<int>(9)), cbox(9, vector<int>(9)), ubox(9, vector<int>(9));\\n        // Ok so this are row boxes, column boxes, unique boxes\\n        \\n        for(int i = 0;i<board.size();i++){\\n            for(int j = 0; j< board[i].size(); j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int nums = board[i][j] - \\'0\\' - 1;\\n                    // Now this is how we are going to check with respect to particular point\\n                    // Lets say our point is (1,2) That means I need to check 0th Unique Box if\\n                    // The element present is there or not\\n                    // Now how are we going to achieve that 0th Number, lets see,\\n                    // First of all, as you can see both are less than 3 becoz we need 3x3 grid\\n                    // Now lets take another example (2,6) Now which Unique Box it will be in\\n                    // It will be in 3rd Box, now how should we make a value that unique,\\n                    // Ok so we could reduce both numbers 2/3 = 0, 6/3 = 2 (As per indexing)\\n                    // Ok so if we divide the index by 3 it will be good, but\\n                    // Lets take another point, (6, 7) 6/3 = 2, 7/3 = 2 => 4th Unique Box\\n                    // Which is wrong, instead it will be in 9th Unique Box, so we are going to \\n                    // do that, by multiplying, ith index by 3 we will get 2x3 = 6, 6 + 2 \\n                    // which is 8(Indexing), we got our 9th Unique Box, noice\\n                    // Lets apply for our first point, and see if it helps\\n                    // 1/3 = 0, 0x3 = 0; 2/3 = 0 => Which means we are at our 1st Unique box\\n                    // Noice.....\\n                    int k = i/3*3 + j/3;\\n\\n                    if(rbox[i][nums] || cbox[j][nums] || ubox[k][nums]){\\n                        return false;\\n                    }\\n\\n                    rbox[i][nums] = cbox[j][nums] = ubox[k][nums] = 1;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355779,
                "title": "python-solution-using-set-76ms",
                "content": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        rows  = [set() for _ in range(9)]\\n        cols  = [set() for _ in range(9)]\\n        dices = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                if e == \\'.\\': continue\\n                if e in rows[i] or e in cols[j] or e in dices[i//3][j//3]: return False\\n                rows[i].add(e)\\n                cols[j].add(e)\\n                dices[i//3][j//3].add(e)\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n        rows  = [set() for _ in range(9)]\\n        cols  = [set() for _ in range(9)]\\n        dices = [[set() for _ in range(3)] for _ in range(3)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                if e == \\'.\\': continue\\n                if e in rows[i] or e in cols[j] or e in dices[i//3][j//3]: return False\\n                rows[i].add(e)\\n                cols[j].add(e)\\n                dices[i//3][j//3].add(e)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 326928,
                "title": "python-4-lines",
                "content": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = [[x for x in y if x != \\'.\\'] for y in board]\\n        col = [[x for x in y if x != \\'.\\'] for y in zip(*board)]\\n        pal = [[board[i+m][j+n] for m in range(3) for n in range(3) if board[i+m][j+n] != \\'.\\'] for i in (0, 3, 6) for j in (0, 3, 6)]\\n        return all(len(set(x)) == len(x) for x in (*row, *col, *pal))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = [[x for x in y if x != \\'.\\'] for y in board]\\n        col = [[x for x in y if x != \\'.\\'] for y in zip(*board)]\\n        pal = [[board[i+m][j+n] for m in range(3) for n in range(3) if board[i+m][j+n] != \\'.\\'] for i in (0, 3, 6) for j in (0, 3, 6)]\\n        return all(len(set(x)) == len(x) for x in (*row, *col, *pal))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160973,
                "title": "go-solution",
                "content": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, cols, boxes []map[byte]bool\\n    for i := 0; i < 9; i++ {\\n        rows = append(rows, make(map[byte]bool))\\n        cols = append(cols, make(map[byte]bool))\\n        boxes = append(boxes, make(map[byte]bool))\\n    }\\n    for i := range board {\\n        for j, num := range board[i] {\\n            if num == \\'.\\' { continue }\\n            if rows[i][num] || cols[j][num] || boxes[(i/3)*3+j/3][num] {\\n                return false\\n            }\\n            rows[i][num] = true\\n            cols[j][num] = true\\n            boxes[(i/3)*3+j/3][num] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, cols, boxes []map[byte]bool\\n    for i := 0; i < 9; i++ {\\n        rows = append(rows, make(map[byte]bool))\\n        cols = append(cols, make(map[byte]bool))\\n        boxes = append(boxes, make(map[byte]bool))\\n    }\\n    for i := range board {\\n        for j, num := range board[i] {\\n            if num == \\'.\\' { continue }\\n            if rows[i][num] || cols[j][num] || boxes[(i/3)*3+j/3][num] {\\n                return false\\n            }\\n            rows[i][num] = true\\n            cols[j][num] = true\\n            boxes[(i/3)*3+j/3][num] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15687,
                "title": "sharing-my-simple-o-n-2-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            int rows = board.size();\\n            int cols = board[0].size();\\n            int mask=0;\\n            int val;\\n            for(int i=0;i<rows;i++){\\n                mask=0;\\n                for(int j=0;j<cols;j++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }\\n                }\\n            }\\n            //rows are checked\\n            for(int j=0;j<cols;j++){\\n                mask=0;\\n                for(int i=0;i<rows;i++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }\\n                }\\n            }\\n            //cols are checked\\n            for(int i=0;i<rows;i+=3)\\n            {\\n                for(int j=0;j<cols;j+=3)\\n                {\\n                    mask=0;\\n                    for(int k=i;k<=i+2;k++)\\n                    {\\n                        for(int l=j;l<=j+2;l++)\\n                        {\\n                            if(board[k][l]!='.'){\\n                                val = (int)(board[k][l]-'0');\\n                                if(mask&(1<<val))\\n                                    return false;\\n                                else mask|=(1<<val);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return true;\\n        }\\n    };\\n\\nI use 'mask' to see which all digits have occurred before. This check is done using binary operators. This check is done for each row, each column and each block of 3*3. Any comments/suggestions/improvements are welcome!",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            int rows = board.size();\\n            int cols = board[0].size();\\n            int mask=0;\\n            int val;\\n            for(int i=0;i<rows;i++){\\n                mask=0;\\n                for(int j=0;j<cols;j++){\\n                    if(board[i][j]!='.'){\\n                        int val = (int)(board[i][j]-'0');\\n                        if(mask & (1<<val))\\n                            return false;\\n                        else mask |= (1<<val);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3254549,
                "title": "c-easiest-solution-hashing",
                "content": "# Intuition\\nCheck Every Row,Column,Box, if there is duplicate of not.\\nWe will do it in one iteration.\\n\\n# Approach\\nThere will be 9 row, 9 col and 9 box. We can determine the row and col no. easily (i,j if we iterate throw board ). And to to determine the box no --> [(i/3)*3 +(j/3)] ;\\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<char> row[9];\\n        set<char> col[9];\\n        set<char> box[9];\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                char ch=board[i][j];\\n                if(ch==\\'.\\') continue;\\n\\n                <!-- Checking the Row -->\\n                if(row[i].count(ch)>=1) return false;\\n                else row[i].insert(ch);\\n\\n                <!-- Checking the Col -->\\n                if(col[j].count(ch)>=1) return false;\\n                else col[j].insert(ch);\\n                \\n                <!-- Calculating the box no-->\\n                int bi=(i/3)*3 + (j/3);\\n\\n                <!-- Checking the Box -->\\n                if(box[bi].count(ch)>=1) return false;\\n                else box[bi].insert(ch);\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<char> row[9];\\n        set<char> col[9];\\n        set<char> box[9];\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                char ch=board[i][j];\\n                if(ch==\\'.\\') continue;\\n\\n                <!-- Checking the Row -->\\n                if(row[i].count(ch)>=1) return false;\\n                else row[i].insert(ch);\\n\\n                <!-- Checking the Col -->\\n                if(col[j].count(ch)>=1) return false;\\n                else col[j].insert(ch);\\n                \\n                <!-- Calculating the box no-->\\n                int bi=(i/3)*3 + (j/3);\\n\\n                <!-- Checking the Box -->\\n                if(box[bi].count(ch)>=1) return false;\\n                else box[bi].insert(ch);\\n            }\\n        }\\n\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925966,
                "title": "time-o-1-space-o-1",
                "content": "# Intuition\\nIn this problem, we simply need to check whether the board is a valid board, i.e. there are no duplicate numbers in any row, column, or box. We could brute force it by repeating work to check each row, column, box, individually. However, to improve performance, we will maintain 9 hashsets for each row/col/box. The only complication is how to determine the box based on the row, col. Let\\'s consider a couple options:\\n\\n```\\nrow = 2, col = 2, box should be 0\\nrow = 2, col = 8, box should be 2\\nrow = 5, col = 5, box should be 4\\nrow = 7, col = 7, box should be 8\\n```\\n\\nBased on the above examples, I came up with the following:\\n```\\nbox = 3*(row/3) + (col/3)\\n```\\n\\nYou can check the math yourself if you are interested.\\n\\n\\n# Approach\\n1. Maintain hashsets for each row, col, and box\\n2. If \\'.\\' continue, otherwise, check if element in the corresponding hashset\\n3. If ever found, return false. Otherwise, after processing all elements, return true \\n\\n# Complexity in general case\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(3 * n)$$ ~ $$O(n)$$\\n\\n# Complexity in specific case\\n- Time complexity:\\n$$O(9 * 9)$$ = $$O(81)$$ ~ $$O(1)$$\\n\\n- Space complexity:\\n$$O(9 * 9 * 3)$$ ~ $$O(243)$$ ~ $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsValidSudoku(char[][] board) {\\n        HashSet<char>[] row = new HashSet<char>[9];\\n        HashSet<char>[] col = new HashSet<char>[9];\\n        HashSet<char>[] box = new HashSet<char>[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<char>();\\n            col[i] = new HashSet<char>();\\n            box[i] = new HashSet<char>();\\n        }\\n\\n        for (int r = 0; r < board.Length; r++) {\\n            for (int c = 0; c < board[r].Length; c++) {\\n                char elem = board[r][c];\\n                if (elem == \\'.\\') {\\n                    continue;\\n                }\\n\\n                if (!row[r].Add(elem)) {\\n                    return false;\\n                }\\n\\n                if (!col[c].Add(elem)) {\\n                    return false;\\n                }\\n                \\n                int b = (3 * (r / 3)) + (c / 3);\\n                if (!box[b].Add(elem)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nrow = 2, col = 2, box should be 0\\nrow = 2, col = 8, box should be 2\\nrow = 5, col = 5, box should be 4\\nrow = 7, col = 7, box should be 8\\n```\n```\\nbox = 3*(row/3) + (col/3)\\n```\n```\\npublic class Solution {\\n    public bool IsValidSudoku(char[][] board) {\\n        HashSet<char>[] row = new HashSet<char>[9];\\n        HashSet<char>[] col = new HashSet<char>[9];\\n        HashSet<char>[] box = new HashSet<char>[9];\\n        for (int i = 0; i < 9; i++) {\\n            row[i] = new HashSet<char>();\\n            col[i] = new HashSet<char>();\\n            box[i] = new HashSet<char>();\\n        }\\n\\n        for (int r = 0; r < board.Length; r++) {\\n            for (int c = 0; c < board[r].Length; c++) {\\n                char elem = board[r][c];\\n                if (elem == \\'.\\') {\\n                    continue;\\n                }\\n\\n                if (!row[r].Add(elem)) {\\n                    return false;\\n                }\\n\\n                if (!col[c].Add(elem)) {\\n                    return false;\\n                }\\n                \\n                int b = (3 * (r / 3)) + (c / 3);\\n                if (!box[b].Add(elem)) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116277,
                "title": "python-brute-force-use-3-dictionaries-with-comments",
                "content": "I use brute force to scan through each cell in the sudoku. Use 3 dictionaries to store:\\n1. number that filled in each row\\n2. number that filled in each column\\n3. number that filled in each block\\nA trick is to use ```(r//3, c//3)``` to identify each block as follows\\n![image](https://assets.leetcode.com/users/images/88531b71-a215-4561-a269-c6e8327fdbc6_1654479090.7013428.jpeg)\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = collections.defaultdict(set) # r: set(\"1\", \"2\", \"3\", ...)\\n        col = collections.defaultdict(set) # c: set(\"1\", \"2\", \"3\", ...)       \\n        block = collections.defaultdict(set) # (r//3, c//3): set(\"1\", \"2\", \"3\", ...)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\": # don\\'t need to check empty cells\\n                    continue\\n                # return false if the number in the cell has been filled in the same row, column, or block.\\n                if (board[r][c] in row[r]) or (board[r][c] in col[c]) or (board[r][c] in block[(r//3, c//3)]):\\n                    return False\\n                # otherwise, add the number to the hash set\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                block[(r//3, c//3)].add(board[r][c])\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```(r//3, c//3)```\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row = collections.defaultdict(set) # r: set(\"1\", \"2\", \"3\", ...)\\n        col = collections.defaultdict(set) # c: set(\"1\", \"2\", \"3\", ...)       \\n        block = collections.defaultdict(set) # (r//3, c//3): set(\"1\", \"2\", \"3\", ...)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\": # don\\'t need to check empty cells\\n                    continue\\n                # return false if the number in the cell has been filled in the same row, column, or block.\\n                if (board[r][c] in row[r]) or (board[r][c] in col[c]) or (board[r][c] in block[(r//3, c//3)]):\\n                    return False\\n                # otherwise, add the number to the hash set\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                block[(r//3, c//3)].add(board[r][c])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074970,
                "title": "valid-sudoku-using-back-tracking-100-faster-with-proper-explanation",
                "content": "Just tell me who hasn\\'t played sudoku ,there might be some.\\nBut now tell me who hasn\\'t even listen sudoku word ,nobody. Right!. thats all we need.\\nHowever,if you want to learn more about sudoku you can read it here\\nhttps://en.wikipedia.org/wiki/Sudoku\\nlet\\'s solve this problem together.\\nThis is a problem of sudoku which will be solved using techniques \\n1. Recursion.\\n2. only BackTracking\\n3. Hashing\\nQuestion says you need to tell whether the given sudoku is valid or not\\n\\nYou really donot need to solve \"Sudoku\" to find out whether it is valid or not\\nSay if our sudoku is whole empty thats also a valid sudoku \"The Question clearly says\".and we donot need Recursion anymore.\\n-\\nyou can really get the idea if you pass the test case \\nyou can check out by having the test case \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nif you are  really a sudoku solver  you will say this is an invalid sudoku ,but unfortunately this is what the question says.\\nNow comes the point how will you tell whether the sudoku is valid or not.\\nProgram-All we need to check the given number present in any 1* 1 cell should not be present in the row,column ,big 3* 3 cell associated with that 1* 1 cell.\\nAlgorithm\\n1. we here traverse the sudoku in breadth search manner this is row-wise we will assess each cell character.\\n2. if 1*1 cell conatins \\'.\\' then nothing needs to be checked\\n3. else store the present number and change it to \\' .\\' . \\n4. check the stored number if present anywhere in the row,in the column,or  in the block associated with that cell ,immediately return false;\\n5. else change it back to the number it was storing repeat the process until gets completed.\\n6. \\nNow ,the question arises how will you check whether the given number is present anywhere in the row ,in the column or in the block to with which the cell is associated.\\n-\\nwe will solve it using one for loop.\\n1. we are supposed to get the row no. of the cell and column no. of the cell and number that was there\\n2. run a loop from 0 to 9\\n3. fix row as row no. given \\n4. fix colum as column number given\\n\\t5. now divide the sudoku into 3 * 3 from 9* 9 i.e, coordinate shifting as shown\\n\\t![image](https://assets.leetcode.com/users/images/03a9ef26-b35e-44d2-80d3-4f8ce945a16f_1653546224.107758.png)\\n0 to 8 can be shifted to block \\nfirst of all the find the \\nblock row no.-row no./3\\nblock column number -column no./3\\nreal row index-(row no./3)*3+(k/3)\\n//k/3 will always gives value\\nfor k={0,1,2}->k/3 is {0,0,0} respectively/*row remains same for block*/\\nfor k={3,4,5}->k/3 is {1,1,1} respectively/*row remains same for block*/\\nfor k={6,7,8}->k/3 is t{2,2,2} respectively/*row remains same for block*/\\n#add respective block column number you will get required indexes\\nreal column idex-(column no./3)*3+(k%3)\\n//k%3 will always gives value\\nfor k={0,1,2}->k%3 is {0,1,2} respectively/*column varies for block*/\\nfor k={3,4,5}->k%3 is {0,1,2} respectively/*column varies for block*/\\nfor k={6,7,8}->k%3 is {0,1,2} respectively/*column varies for block*/\\nthat is used to switch columns within block\\n#add respective block row number you will get required indexes\\n\\ncode-\\n-\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n     for(int i=0;i<9;i++)\\n     {\\n         for(int j=0;j<9;j++)//traverse in bfs manner \\n         {\\n             char ch=board[i][j];\\n             if(ch!=\\'.\\')//if ch is apart from \\'.\\'we need to check whether the given number is verifiable\\n             {\\n                 board[i][j]=\\'.\\';//change it to . so that it cannot consider itself\\n                 if(!isValid(board,ch,i,j))//if not verifiable\\n                     return false;//invalid sudoku\\n                 board[i][j]=ch;//after checking change it to its initial value\\n             }\\n         }\\n     }\\n        return true;\\n    }\\n    static boolean isValid(char[][]ch,char ch1,int i,int j)\\n    {\\n      for(int k=0;k<9;k++)\\n      {\\n          if(ch[i][k]==ch1)return false;//for checking row associated with it\\n          if(ch[k][j]==ch1)return false;//for checking column associated with it\\n          if(ch[3*(i/3)+k/3][3*(j/3)+k%3]==ch1)return false;//for checking block associated with it\\n      }\\n        return true;\\n    }\\n}\\n```\\nthis question is very easy ,just in any case if you face any problem anywhere let me know in the comments.\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n     for(int i=0;i<9;i++)\\n     {\\n         for(int j=0;j<9;j++)//traverse in bfs manner \\n         {\\n             char ch=board[i][j];\\n             if(ch!=\\'.\\')//if ch is apart from \\'.\\'we need to check whether the given number is verifiable\\n             {\\n                 board[i][j]=\\'.\\';//change it to . so that it cannot consider itself\\n                 if(!isValid(board,ch,i,j))//if not verifiable\\n                     return false;//invalid sudoku\\n                 board[i][j]=ch;//after checking change it to its initial value\\n             }\\n         }\\n     }\\n        return true;\\n    }\\n    static boolean isValid(char[][]ch,char ch1,int i,int j)\\n    {\\n      for(int k=0;k<9;k++)\\n      {\\n          if(ch[i][k]==ch1)return false;//for checking row associated with it\\n          if(ch[k][j]==ch1)return false;//for checking column associated with it\\n          if(ch[3*(i/3)+k/3][3*(j/3)+k%3]==ch1)return false;//for checking block associated with it\\n      }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135904,
                "title": "0ms-simple-go-code",
                "content": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    rowsMap := [9][9]bool{}\\n    colsMap := [9][9]bool{}\\n    gridMap := [9][9]bool{}\\n    \\n    for row:=0; row<9; row++ {\\n        for col:=0; col<9; col++ {\\n            val, err := strconv.Atoi(string(board[row][col]))\\n            if err != nil {\\n                continue\\n            }\\n            val--\\n            gridIndex := col/3 + (row/3) * 3\\n            if rowsMap[row][val] || colsMap[col][val] || gridMap[gridIndex][val] {\\n                return false\\n            } \\n            rowsMap[row][val] = true\\n            colsMap[col][val] = true    \\n            gridMap[gridIndex][val] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    rowsMap := [9][9]bool{}\\n    colsMap := [9][9]bool{}\\n    gridMap := [9][9]bool{}\\n    \\n    for row:=0; row<9; row++ {\\n        for col:=0; col<9; col++ {\\n            val, err := strconv.Atoi(string(board[row][col]))\\n            if err != nil {\\n                continue\\n            }\\n            val--\\n            gridIndex := col/3 + (row/3) * 3\\n            if rowsMap[row][val] || colsMap[col][val] || gridMap[gridIndex][val] {\\n                return false\\n            } \\n            rowsMap[row][val] = true\\n            colsMap[col][val] = true    \\n            gridMap[gridIndex][val] = true\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476302,
                "title": "javascript-string-map-solution",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  const map = {};\\n  \\n  for (let row = 0; row < 9; row ++) {\\n    for (let col = 0; col < 9; col ++) {\\n      const val = board[row][col];\\n      \\n      if (val === \\'.\\') continue;\\n      \\n      const keyRow = `row ${row} has ${val}`;\\n      const keyCol = `col ${col} has ${val}`;\\n      const keyBox = `box ${Math.floor(row / 3)}-${Math.floor(col / 3)} has ${val}`;\\n\\n      if (map[keyRow] || map[keyCol] || map[keyBox]) return false;\\n\\n      map[keyRow] = true;\\n      map[keyCol] = true;\\n      map[keyBox] = true;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  const map = {};\\n  \\n  for (let row = 0; row < 9; row ++) {\\n    for (let col = 0; col < 9; col ++) {\\n      const val = board[row][col];\\n      \\n      if (val === \\'.\\') continue;\\n      \\n      const keyRow = `row ${row} has ${val}`;\\n      const keyCol = `col ${col} has ${val}`;\\n      const keyBox = `box ${Math.floor(row / 3)}-${Math.floor(col / 3)} has ${val}`;\\n\\n      if (map[keyRow] || map[keyCol] || map[keyBox]) return false;\\n\\n      map[keyRow] = true;\\n      map[keyCol] = true;\\n      map[keyBox] = true;\\n    }\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15587,
                "title": "my-one-pass-o-1-space-solution-using-java",
                "content": " \\n  This solution saves more space. \\n  Using bit-map to represent the occupation of each number.\\n  In the outer loop, the i represents ith row, column and block \\n  for the row, col and block variable separately to validate \\n  the jth element in this row (column and the block) seperately.\\n\\n\\n  Time complexity: O(n^2); where n is the width of the board.\\n\\n  Space complexity: O(1);\\n\\n  Status: Accepted.\\n \\n\\n    public class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            // precondition: board is not null\\n            if (board == null) {\\n                throw new NullPointerException();\\n            }\\n    \\n            for (int i = 0; i < 9; i++) {\\n                int row = 0;\\n                int col = 0;\\n                int block = 0;\\n                for (int j = 0; j < 9; j++) {\\n                    int rowVal = board[i][j] - '1';\\n                    int colVal = board[j][i] - '1';\\n                    int blockVal = board[i/3*3 + j/3][i%3*3 + j%3] - '1';\\n                    if (rowVal >= 0 && (row & (1 << rowVal)) != 0\\n                     || colVal >= 0 && (col & (1 << colVal)) != 0\\n                     || blockVal >= 0 && (block & (1 << blockVal)) !=0) {\\n                        return false;\\n                    }\\n                    row |= rowVal >= 0 ? 1 << rowVal : 0;\\n                    col |= colVal >=0 ? 1 << colVal : 0;\\n                    block |= blockVal >= 0 ? 1 << blockVal : 0;\\n                }\\n            }\\n    \\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidSudoku(char[][] board) {\\n            // precondition: board is not null\\n            if (board == null) {\\n                throw new NullPointerException();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3919253,
                "title": "beats-96-06-50-145-top-interview-question",
                "content": "# Intuition\\n*A simple straight-forward solution!*\\n\\n# Approach\\nThis code block is an implementation of the solution to `isValidSudoku`. Let\\'s break down the code step by step:\\n\\n1. The code starts by importing the `collections` module, which is used to create defaultdicts (Why? Will explain!).\\n   \\n2. Within the `isValidSudoku` method, three defaultdicts are created: `rows`, `columns`, and `sub_boxes`. These defaultdicts will store sets of numbers that are present in each row, column, and sub-box of the Sudoku board, respectively.\\n\\n3. The code then uses two nested loops to iterate through each cell in the 9x9 Sudoku board.\\n\\n4. For each cell, it checks the value of the number in the cell (`num`):\\n\\n   - If the cell contains a period (`.`), which represents an empty cell, it skips the current iteration using `continue`.\\n\\n   - If the cell contains a number, it checks three conditions to determine if the number violates the rules of Sudoku:\\n\\n     - It checks if the number is already present in the set of numbers in the same row (`rows[row]`).\\n     \\n     - It checks if the number is already present in the set of numbers in the same column (`columns[col]`).\\n     \\n     - It checks if the number is already present in the set of numbers in the corresponding sub-box (`sub_boxes[(row//3, col//3)]`).\\n\\n   - If any of these conditions are met, it means the Sudoku rules are violated, and the function immediately returns `False`, indicating that the Sudoku board is not valid.\\n\\n5. If none of the conditions are met, meaning the number can be safely placed in the current cell without violating any rules, the code updates the sets in `rows`, `columns`, and `sub_boxes` to include the new number.\\n\\n6. After iterating through the entire board, if no violations were found, the function returns `True`, indicating that the Sudoku board is valid.\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(1) , ***Actually O(81) since constant\\'s are O(1)***\\n\\n- Space complexity:\\n    O(1),  ***Confusing? It\\'s simple. The total space incurred will be three times the size of the Sudoku board, and it\\'s constant in length! It might get smaller but will never exceed 3(9+1 x 9+1).***\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Create dictionaries to keep track of numbers in rows, columns, and sub-boxes\\n        rows = collections.defaultdict(set)\\n        columns = collections.defaultdict(set)\\n        sub_boxes = collections.defaultdict(set)\\n\\n        # Iterate through each cell in the 9x9 Sudoku board\\n        for row in range(9):\\n            for col in range(9):\\n                num = board[row][col]\\n\\n                # Skip empty cells represented by \".\"\\n                if num == \".\":\\n                    continue\\n\\n                # Check if the current number violates Sudoku rules\\n                if (num in rows[row] or \\n                    num in columns[col] or \\n                    num in sub_boxes[(row // 3, col // 3)]):\\n                   return False\\n\\n                # Update sets to keep track of encountered numbers\\n                rows[row].add(num)\\n                columns[col].add(num)\\n                sub_boxes[(row // 3, col // 3)].add(num)\\n\\n        # If all cells satisfy Sudoku rules, the board is valid\\n        return True\\n\\n```\\n\\n***Extra note:***\\n\\n*Why we used **defaultdict?**.*\\n-- *It is to simplify the process of initializing and accessing values in a dictionary, especially when dealing with keys that might not exist yet. It provides a convenient way to handle default values for keys that are not present in the dictionary.*\\n\\n\\n- `num in sub_boxes[(row // 3, col // 3)]`:\\n\\n*This line checks whether the number `num` is already present in the set that corresponds to the specific ***3x3*** sub-box where the current cell is located.*\\n\\n*Imagine you\\'re playing a game on a ***9x9*** Sudoku board. To make sure you\\'re not violating the rules, you want to know if the number you\\'re considering ***(let\\'s say \"5\")*** is already in the little ***3x3*** box that your current cell is part of. You\\'d look at that ***3x3*** box, see if the number ***\"5\"*** is already there, and if it is, you\\'d know you can\\'t place another ***\"5\"*** there. This line of code is doing that exact check for you, but programmatically.*\\n\\n```\\n    0       1      2\\n   - - - | - - - | - - -\\n0  - - - | - - - | - - -  // sub_boxes key\\'s as a tuple (x,y)\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n1  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n2  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n```\\n\\n- `sub_boxes[(row // 3, col // 3)].add(num)`:\\n\\n*This line adds the current number `num` to the set that corresponds to the ***3x3*** sub-box where the current cell is located.*\\n\\n*Continuing from the previous analogy, let\\'s say you found that the number **\"5\"** isn\\'t in the ***3x3*** box yet, so you want to add it there. You take your pen and add the ***\"5\"*** to the list of numbers you\\'ve placed in that box. This line of code does the same thing in code. It adds the current number `num` to the set that represents the numbers placed in that specific ***3x3*** sub-box.*\\n\\n***In both cases, these lines help ensure that you\\'re following the rules of Sudoku by keeping track of the numbers in rows, columns, and sub-boxes, making sure no number repeats within the same row, column, or sub-box.***\\n\\n***END***\\n\\n\\n*It took a lot of time and effort to write this documentation, but I will be really happy if it becomes useful to someone!* \\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Create dictionaries to keep track of numbers in rows, columns, and sub-boxes\\n        rows = collections.defaultdict(set)\\n        columns = collections.defaultdict(set)\\n        sub_boxes = collections.defaultdict(set)\\n\\n        # Iterate through each cell in the 9x9 Sudoku board\\n        for row in range(9):\\n            for col in range(9):\\n                num = board[row][col]\\n\\n                # Skip empty cells represented by \".\"\\n                if num == \".\":\\n                    continue\\n\\n                # Check if the current number violates Sudoku rules\\n                if (num in rows[row] or \\n                    num in columns[col] or \\n                    num in sub_boxes[(row // 3, col // 3)]):\\n                   return False\\n\\n                # Update sets to keep track of encountered numbers\\n                rows[row].add(num)\\n                columns[col].add(num)\\n                sub_boxes[(row // 3, col // 3)].add(num)\\n\\n        # If all cells satisfy Sudoku rules, the board is valid\\n        return True\\n\\n```\n```\\n    0       1      2\\n   - - - | - - - | - - -\\n0  - - - | - - - | - - -  // sub_boxes key\\'s as a tuple (x,y)\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n1  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n  -----------------------\\n   - - - | - - - | - - -\\n2  - - - | - - - | - - -\\n   - - - | - - - | - - -\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474482,
                "title": "typescript-easy-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n# Code\\n```\\nfunction isValidSudoku(board: string[][]): boolean {\\n    const set = new Set()\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            const cell = board[i][j]\\n            if(cell === \\'.\\') continue\\n            const row = `row: ${i}, value: ${cell}`\\n            const column = `column: ${j}, value: ${cell}`\\n            const boxNumber = 3 * Math.floor(i / 3) + Math.floor(j / 3)\\n            const box = `boxNumber: ${boxNumber}, value: ${cell}`\\n            if(set.has(row) || set.has(column) || set.has(box)) return false\\n            set.add(row).add(column).add(box)\\n        }\\n    }\\n    return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nfunction isValidSudoku(board: string[][]): boolean {\\n    const set = new Set()\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            const cell = board[i][j]\\n            if(cell === \\'.\\') continue\\n            const row = `row: ${i}, value: ${cell}`\\n            const column = `column: ${j}, value: ${cell}`\\n            const boxNumber = 3 * Math.floor(i / 3) + Math.floor(j / 3)\\n            const box = `boxNumber: ${boxNumber}, value: ${cell}`\\n            if(set.has(row) || set.has(column) || set.has(box)) return false\\n            set.add(row).add(column).add(box)\\n        }\\n    }\\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2840609,
                "title": "python-solution-using-set-faster-than-95",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # idea: mark row, col, and sub-board appearance for each element. Check repetition at the end. \\n        tags = []\\n        for i in range(9):\\n            for j in range(9):\\n                ele = board[i][j]\\n                if ele != \\'.\\':\\n                    tags.append(f\\'{ele} @ {i}th row\\')\\n                    tags.append(f\\'{ele} @ {j}th col\\') \\n                    tags.append(f\\'{ele} @ {i//3}-{j//3}th subboard\\')\\n\\n        return len(tags) == len(set(tags))\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        # idea: mark row, col, and sub-board appearance for each element. Check repetition at the end. \\n        tags = []\\n        for i in range(9):\\n            for j in range(9):\\n                ele = board[i][j]\\n                if ele != \\'.\\':\\n                    tags.append(f\\'{ele} @ {i}th row\\')\\n                    tags.append(f\\'{ele} @ {j}th col\\') \\n                    tags.append(f\\'{ele} @ {i//3}-{j//3}th subboard\\')\\n\\n        return len(tags) == len(set(tags))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534738,
                "title": "typescript-javascript-map-hashset",
                "content": "This solution is technically constant time because the number of cells never exceeds 81\\n\\n```\\nconst EMPTY_CELL = \".\";\\nconst NUMBER_OF_CELLS = 81;\\nconst SUB_BOARD_WIDTH = 3;\\nconst SUB_BOARD_HEIGHT = 3;\\n\\nfunction isValidSudoku(board: string[][]): boolean {\\n  const rows = new Map<number, Set<number>>();\\n  const columns = new Map<number, Set<number>>();\\n  const boxes = new Map<number, Set<number>>();\\n  \\n  for(let i = 0 ; i < NUMBER_OF_CELLS ; i++){\\n    const row = Math.floor(i / 9);\\n    const column = i % 9;\\n    const box =  Math.floor(row / 3) * 3 + Math.floor(column / 3);\\n    const cell = Number(board[row][column]);\\n    \\n    // if empty cell, skip\\n    if(isNaN(cell)) continue;\\n    \\n    // initialize sets if not initialized for\\n    // row, column, or box\\n    if(!rows.has(row)) rows.set(row, new Set<number>());\\n    if(!columns.has(column)) columns.set(column, new Set<number>());\\n    if(!boxes.has(box)) boxes.set(box, new Set<number>());\\n    \\n    // if the cell value was seen before, this means\\n    // this is an invalid sudoku, return false\\n    if(rows.get(row).has(cell)) return false;\\n    if(columns.get(column).has(cell)) return false;\\n    if(boxes.get(box).has(cell)) return false;\\n    \\n    // if we haven\\'t seen the cell before, add it to\\n    // row, column, and box\\n    rows.get(row).add(cell)\\n    columns.get(column).add(cell)\\n    boxes.get(box).add(cell)\\n  }\\n  \\n  \\n  // if we manage to exit the loop without breaking\\n  // sudoku rules, then this is a valid sudoku\\n  return true\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst EMPTY_CELL = \".\";\\nconst NUMBER_OF_CELLS = 81;\\nconst SUB_BOARD_WIDTH = 3;\\nconst SUB_BOARD_HEIGHT = 3;\\n\\nfunction isValidSudoku(board: string[][]): boolean {\\n  const rows = new Map<number, Set<number>>();\\n  const columns = new Map<number, Set<number>>();\\n  const boxes = new Map<number, Set<number>>();\\n  \\n  for(let i = 0 ; i < NUMBER_OF_CELLS ; i++){\\n    const row = Math.floor(i / 9);\\n    const column = i % 9;\\n    const box =  Math.floor(row / 3) * 3 + Math.floor(column / 3);\\n    const cell = Number(board[row][column]);\\n    \\n    // if empty cell, skip\\n    if(isNaN(cell)) continue;\\n    \\n    // initialize sets if not initialized for\\n    // row, column, or box\\n    if(!rows.has(row)) rows.set(row, new Set<number>());\\n    if(!columns.has(column)) columns.set(column, new Set<number>());\\n    if(!boxes.has(box)) boxes.set(box, new Set<number>());\\n    \\n    // if the cell value was seen before, this means\\n    // this is an invalid sudoku, return false\\n    if(rows.get(row).has(cell)) return false;\\n    if(columns.get(column).has(cell)) return false;\\n    if(boxes.get(box).has(cell)) return false;\\n    \\n    // if we haven\\'t seen the cell before, add it to\\n    // row, column, and box\\n    rows.get(row).add(cell)\\n    columns.get(column).add(cell)\\n    boxes.get(box).add(cell)\\n  }\\n  \\n  \\n  // if we manage to exit the loop without breaking\\n  // sudoku rules, then this is a valid sudoku\\n  return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494087,
                "title": "easy-100-fully-explained-java-clean-solution-two-approaches",
                "content": "# **Java Solution:**\\n```\\n/** First Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        // Base case...\\n        if (board == null || board.length != 9 || board[0].length != 9)\\n\\t\\t    return false;\\n        \\n\\t    //For each column check that their is repeatation of any digit present in filled cells...\\n\\t    for (int i = 0; i < 9; i++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int j = 0; j < 9; j++) {\\n                // For filled cells only...\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\n\\t    // For each row check that their is repeatation of any digit present in filled cells...\\n\\t    for (int j = 0; j < 9; j++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int i = 0; i < 9; i++) {\\n                // For filled cells only\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n \\n\\t    // Check that every 3*3 grid must contain different values means no repeatation of any digit present in filled cells...\\n\\t    for (int grid = 0; grid < 9; grid++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n            // Traverse each grid through the loops...\\n\\t\\t    for (int i = grid / 3 * 3; i < grid / 3 * 3 + 3; i++) {\\n\\t\\t\\t    for (int j = grid % 3 * 3; j < grid % 3 * 3 + 3; j++) {\\n                    // For filled cells only...\\n\\t\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                        // That number-1, is its index in every checking array\\n\\t\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    return true;\\n    }\\n}\\n\\n__________________________________________________________________________________________________________________________________________________________________\\n\\n\\n/** Second Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        // Traverse all the elements of all the boxes through loops...\\n        for (int i = 0; i < 9; ++i)\\n            for (int j = 0; j < 9; ++j) {\\n                // For filled cells only...\\n                if (board[i][j] == \\'.\\')\\n                    continue;\\n                final char ch = board[i][j];\\n                // Check each row, column & 3x3 box...\\n                if (!set.add(ch + \"@row\" + i) || !set.add(ch + \"@col\" + j) || !set.add(ch + \"@box\" + i/3 + j/3))\\n                    return false;\\n            }\\n        return true;\\n    }\\n}\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n/** First Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        // Base case...\\n        if (board == null || board.length != 9 || board[0].length != 9)\\n\\t\\t    return false;\\n        \\n\\t    //For each column check that their is repeatation of any digit present in filled cells...\\n\\t    for (int i = 0; i < 9; i++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int j = 0; j < 9; j++) {\\n                // For filled cells only...\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\n\\t    // For each row check that their is repeatation of any digit present in filled cells...\\n\\t    for (int j = 0; j < 9; j++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n\\t\\t    for (int i = 0; i < 9; i++) {\\n                // For filled cells only\\n\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                    // That number-1, is its index in every checking array...\\n\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n \\n\\t    // Check that every 3*3 grid must contain different values means no repeatation of any digit present in filled cells...\\n\\t    for (int grid = 0; grid < 9; grid++) {\\n\\t\\t    boolean[] set = new boolean[9];\\n            // Traverse each grid through the loops...\\n\\t\\t    for (int i = grid / 3 * 3; i < grid / 3 * 3 + 3; i++) {\\n\\t\\t\\t    for (int j = grid % 3 * 3; j < grid % 3 * 3 + 3; j++) {\\n                    // For filled cells only...\\n\\t\\t\\t\\t    if (board[i][j] != \\'.\\') {\\n                        // That number-1, is its index in every checking array\\n\\t\\t\\t\\t\\t    if (set[(int) (board[i][j] - \\'1\\')]) {\\n\\t\\t\\t\\t\\t\\t    return false;\\n\\t\\t\\t\\t\\t    }\\n\\t\\t\\t\\t\\t    set[(int) (board[i][j] - \\'1\\')] = true;\\n\\t\\t\\t\\t    }\\n\\t\\t\\t    }\\n\\t\\t    }\\n\\t    }\\n\\t    return true;\\n    }\\n}\\n\\n__________________________________________________________________________________________________________________________________________________________________\\n\\n\\n/** Second Approach **/\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set<String> set = new HashSet<>();\\n        // Traverse all the elements of all the boxes through loops...\\n        for (int i = 0; i < 9; ++i)\\n            for (int j = 0; j < 9; ++j) {\\n                // For filled cells only...\\n                if (board[i][j] == \\'.\\')\\n                    continue;\\n                final char ch = board[i][j];\\n                // Check each row, column & 3x3 box...\\n                if (!set.add(ch + \"@row\" + i) || !set.add(ch + \"@col\" + j) || !set.add(ch + \"@box\" + i/3 + j/3))\\n                    return false;\\n            }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466662,
                "title": "java-hashset-with-minimal-lines-of-code",
                "content": "```\\npublic boolean isValidSudoku(char[][] board) {\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                char currVal = board[i][j];\\n                if(currVal!=\\'.\\'){\\n                    if(!set.add(currVal+\" found in row \"+i) ||\\n                        !set.add(currVal+\" found in column \"+j) ||\\n                        !set.add(currVal+\" found in sub Box \"+i/3+j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValidSudoku(char[][] board) {\\n        HashSet<String> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                char currVal = board[i][j];\\n                if(currVal!=\\'.\\'){\\n                    if(!set.add(currVal+\" found in row \"+i) ||\\n                        !set.add(currVal+\" found in column \"+j) ||\\n                        !set.add(currVal+\" found in sub Box \"+i/3+j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1668785,
                "title": "java-clean-code",
                "content": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    String r = \\'r\\' + \"-\" + i + \"-\" + board[i][j];\\n                    String c = \\'c\\' + \"-\" + j + \"-\" + board[i][j];\\n                    String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n                    if (!hs.add(r) || !hs.add(c) || !hs.add(rc)) \\n                        return false;\\n\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashSet;\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    String r = \\'r\\' + \"-\" + i + \"-\" + board[i][j];\\n                    String c = \\'c\\' + \"-\" + j + \"-\" + board[i][j];\\n                    String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n                    if (!hs.add(r) || !hs.add(c) || !hs.add(rc)) \\n                        return false;\\n\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622505,
                "title": "pythonic-python",
                "content": "Very python\\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \"\"\"\\n        Let\\'s keep tracking each element and see where they belong\\n        \"\"\"\\n        \\n        # Initialize tackers for each row, column and box\\n        row = {i: [] for i in range(9)}\\n        col = {i: [] for i in range(9)}\\n        box = {i: [] for i in range(9)}\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                box_index = (i // 3) * 3 + j // 3\\n                \\n                if e == \\'.\\':\\n                    continue\\n                    \\n                if e in row[i] or e in col[j] or e in box[box_index]:\\n                    return False\\n                else:\\n                    row[i].append(e)\\n                    col[j].append(e)\\n                    box[box_index].append(e)\\n                    \\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \"\"\"\\n        Let\\'s keep tracking each element and see where they belong\\n        \"\"\"\\n        \\n        # Initialize tackers for each row, column and box\\n        row = {i: [] for i in range(9)}\\n        col = {i: [] for i in range(9)}\\n        box = {i: [] for i in range(9)}\\n        \\n        for i in range(9):\\n            for j in range(9):\\n                e = board[i][j]\\n                box_index = (i // 3) * 3 + j // 3\\n                \\n                if e == \\'.\\':\\n                    continue\\n                    \\n                if e in row[i] or e in col[j] or e in box[box_index]:\\n                    return False\\n                else:\\n                    row[i].append(e)\\n                    col[j].append(e)\\n                    box[box_index].append(e)\\n                    \\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320921,
                "title": "python-clean-soln",
                "content": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        cols = defaultdict(set)\\n        rows = defaultdict(set)\\n        squares = defaultdict(set)\\n\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \\'.\\':\\n                    continue\\n                if (board[r][c] in rows[r] or board[r][c] in cols[c] or\\n                        board[r][c] in squares[(r//3, c//3)]):\\n                    return False\\n\\n                rows[r].add(board[r][c])\\n                cols[c].add(board[r][c])\\n                squares[(r//3, c//3)].add(board[r][c])\\n\\n        return True\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        cols = defaultdict(set)\\n        rows = defaultdict(set)\\n        squares = defaultdict(set)\\n\\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \\'.\\':\\n                    continue\\n                if (board[r][c] in rows[r] or board[r][c] in cols[c] or\\n                        board[r][c] in squares[(r//3, c//3)]):\\n                    return False\\n\\n                rows[r].add(board[r][c])\\n                cols[c].add(board[r][c])\\n                squares[(r//3, c//3)].add(board[r][c])\\n\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1151068,
                "title": "python-clean-easy-solution",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        seen = set()\\n        for i in range(9):\\n            for j in range(9):\\n                number = str(board[i][j])\\n                if number != \\'.\\':\\n                    row = number +\\'in row\\' + str(i)\\n                    col = number +\\'in col\\' + str(j)\\n                    # // for integer\\n                    block = number +\\'in block\\' + str(i//3) + str(j//3)\\n                    if row in seen or col in seen or block in seen:\\n                        return False\\n                    seen.add(row)\\n                    seen.add(col)\\n                    seen.add(block)\\n        return True\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        seen = set()\\n        for i in range(9):\\n            for j in range(9):\\n                number = str(board[i][j])\\n                if number != \\'.\\':\\n                    row = number +\\'in row\\' + str(i)\\n                    col = number +\\'in col\\' + str(j)\\n                    # // for integer\\n                    block = number +\\'in block\\' + str(i//3) + str(j//3)\\n                    if row in seen or col in seen or block in seen:\\n                        return False\\n                    seen.add(row)\\n                    seen.add(col)\\n                    seen.add(block)\\n        return True\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 410216,
                "title": "easy-to-understand-c-solution-8ms-beats-98",
                "content": "Runtime: 8 ms, faster than 98.48% of C++ online submissions for Valid Sudoku.\\nMemory Usage: 9.8 MB, less than 58.97% of C++ online submissions for Valid Sudoku.\\n\\n```\\n bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        //check for each row\\n        for(int r=0; r<board.size(); r++)\\n        {\\n            vector<int> mpRow(10,0);\\n            for(int elem=0; elem < board[0].size(); elem++)\\n            {\\n                if(\\'1\\' <= board[r][elem] && board[r][elem] <= \\'9\\')\\n                    mpRow[board[r][elem]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpRow[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for each col\\n        for(int c=0; c<board[0].size(); c++)\\n        {\\n            vector<int> mpCol(10,0);\\n            for(int elem=0; elem < board.size(); elem++)\\n            {\\n                if(\\'1\\' <= board[elem][c] && board[elem][c] <= \\'9\\')\\n                    mpCol[board[elem][c]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpCol[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for 3*3 cells\\n        for(int i=0; i<9; i+=3)\\n        {\\n            for(int j=0; j<9; j+=3)\\n            {\\n                vector<int> mpBox(10,0);\\n                for(int k=i; k<i+3; k++)\\n                {\\n                    for(int l=j; l<j+3; l++)\\n                    {\\n                        if(\\'1\\' <= board[k][l] && board[k][l] <= \\'9\\')\\n                            mpBox[board[k][l]-\\'0\\']++;\\n                    }\\n                }\\n                \\n                for(int i=1; i<10; i++)\\n                {\\n                    if(mpBox[i] > 1)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Runtime: 8 ms, faster than 98.48% of C++ online submissions for Valid Sudoku.\\nMemory Usage: 9.8 MB, less than 58.97% of C++ online submissions for Valid Sudoku.\\n\\n```\\n bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        //check for each row\\n        for(int r=0; r<board.size(); r++)\\n        {\\n            vector<int> mpRow(10,0);\\n            for(int elem=0; elem < board[0].size(); elem++)\\n            {\\n                if(\\'1\\' <= board[r][elem] && board[r][elem] <= \\'9\\')\\n                    mpRow[board[r][elem]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpRow[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for each col\\n        for(int c=0; c<board[0].size(); c++)\\n        {\\n            vector<int> mpCol(10,0);\\n            for(int elem=0; elem < board.size(); elem++)\\n            {\\n                if(\\'1\\' <= board[elem][c] && board[elem][c] <= \\'9\\')\\n                    mpCol[board[elem][c]-\\'0\\']++;\\n            }\\n            \\n            for(int i=1; i<10; i++)\\n            {\\n                if(mpCol[i] > 1)\\n                    return false;\\n            }\\n        }\\n        \\n        //check for 3*3 cells\\n        for(int i=0; i<9; i+=3)\\n        {\\n            for(int j=0; j<9; j+=3)\\n            {\\n                vector<int> mpBox(10,0);\\n                for(int k=i; k<i+3; k++)\\n                {\\n                    for(int l=j; l<j+3; l++)\\n                    {\\n                        if(\\'1\\' <= board[k][l] && board[k][l] <= \\'9\\')\\n                            mpBox[board[k][l]-\\'0\\']++;\\n                    }\\n                }\\n                \\n                for(int i=1; i<10; i++)\\n                {\\n                    if(mpBox[i] > 1)\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 338064,
                "title": "javascript-13-lines-short-solution",
                "content": "```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(), col = new Set(), sqr = new Set();\\n    for (let j = 0; j < 9; j++) {\\n      let rowc = board[i][j];\\n      let colc = board[j][i];\\n      let sqrc = board[Math.floor(i / 3) * 3 + Math.floor(j / 3)][(i % 3) * 3 + j % 3];\\n      if (row.has(rowc) || col.has(colc) || sqr.has(sqrc)) return false;\\n      if (rowc !== \".\") row.add(rowc);\\n      if (colc !== \".\") col.add(colc);\\n      if (sqrc !== \".\") sqr.add(sqrc);\\n    }\\n  }\\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n  for (let i = 0; i < 9; i++) {\\n    let row = new Set(), col = new Set(), sqr = new Set();\\n    for (let j = 0; j < 9; j++) {\\n      let rowc = board[i][j];\\n      let colc = board[j][i];\\n      let sqrc = board[Math.floor(i / 3) * 3 + Math.floor(j / 3)][(i % 3) * 3 + j % 3];\\n      if (row.has(rowc) || col.has(colc) || sqr.has(sqrc)) return false;\\n      if (rowc !== \".\") row.add(rowc);\\n      if (colc !== \".\") col.add(colc);\\n      if (sqrc !== \".\") sqr.add(sqrc);\\n    }\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 15455,
                "title": "simple-ruby-solution-using-sets",
                "content": "The idea is to initialize a set per collection of (1-9) characters that we care about (each row, each column, and each box) to ensure that there are no duplicate numbers, which would make the solution invalid.\\n\\n```\\ndef is_valid_sudoku(board)\\n    boxes = Array.new(3) { Array.new(3) { Set.new } }\\n    rows = Array.new(9) { Set.new }\\n    cols = Array.new(9) { Set.new }\\n    \\n    board.each_with_index do |array, row|\\n        array.each_with_index do |num, col|\\n            next if num == '.'\\n            return false unless boxes[row/3][col/3].add?(num) && rows[row].add?(num) && cols[col].add?(num)\\n        end\\n    end\\n    true\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_valid_sudoku(board)\\n    boxes = Array.new(3) { Array.new(3) { Set.new } }\\n    rows = Array.new(9) { Set.new }\\n    cols = Array.new(9) { Set.new }\\n    \\n    board.each_with_index do |array, row|\\n        array.each_with_index do |num, col|\\n            next if num == '.'\\n            return false unless boxes[row/3][col/3].add?(num) && rows[row].add?(num) && cols[col].add?(num)\\n        end\\n    end\\n    true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3427605,
                "title": "simple-swift-solution-easy-to-understand",
                "content": "# Approach\\nThe solution iterates through each `row` of the board. For each `row`, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the `row` and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next `row`.\\n\\nThe solution then iterates through each `column` of the board. For each `column`, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the `column` and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next `column`.\\n\\nThe solution then iterates through each $$3 \\\\times 3$$ sub-box of the board. For each $$3 \\\\times 3$$ sub-box, it creates a new `set` to keep track of the digits seen so far. It then iterates through each cell of the sub-box and checks if the cell is empty or not. If the cell is not empty, it checks if the digit already exists in the `set` or not. If the digit already exists in the `set`, it returns `false` as it violates the Sudoku rule. Otherwise, it adds the digit to the `set` and continues to the next cell. If the iteration completes without finding any violation, it continues to the next $$3 \\\\times 3$$ sub-box.\\n\\nIf the solution completes all iterations without finding any violation, it returns `true` indicating that the board is a valid Sudoku board. Otherwise, it returns `false` indicating that the board is not valid.\\n\\n# Complexity\\nThe *time complexity* of the given solution is $$O(n^2)$$, where $$n$$ is the number of cells in the Sudoku board.\\n\\nThe *space complexity* of the solution is $$O(n)$$, where $$n$$ is the number of cells in the Sudoku board.\\n\\n# Code\\n```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for j in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for j in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for k in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in k / 3 * 3 ..< k / 3 * 3 + 3 {\\n                for j in k % 3 * 3 ..< k % 3 * 3 + 3 {\\n                    if board[i][j] != \".\", set.contains(board[i][j]) {\\n                        return false\\n                    }\\n                    set.insert(board[i][j])\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/241e5676-737d-4137-ab6b-440f1d715ee1_1681748155.5014086.png)\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    func isValidSudoku(_ board: [[Character]]) -> Bool {\\n        for i in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for j in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for j in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in 0 ..< 9 {\\n                if board[i][j] != \".\", set.contains(board[i][j]) {\\n                    return false\\n                }\\n                set.insert(board[i][j])\\n            }\\n        }\\n\\n        for k in 0 ..< 9 {\\n            var set = Set<Character>()\\n            for i in k / 3 * 3 ..< k / 3 * 3 + 3 {\\n                for j in k % 3 * 3 ..< k % 3 * 3 + 3 {\\n                    if board[i][j] != \".\", set.contains(board[i][j]) {\\n                        return false\\n                    }\\n                    set.insert(board[i][j])\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140050,
                "title": "simple-java-c-easy-readable-3-lines-code-100-working",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet <String> seen = new HashSet <>();\\n        \\n        for (int i = 0; i < 9; i ++) {\\n            for (int j = 0; j < 9; j ++) {\\n                char cur = board[i][j];\\n                if(cur != \\'.\\') if(!seen.add(cur + \"row\" + i)||!seen.add(cur + \"col\" + j)||!seen.add(cur + \"grid\" + i / 3 + \"-\" + j / 3)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet <String> seen = new HashSet <>();\\n        \\n        for (int i = 0; i < 9; i ++) {\\n            for (int j = 0; j < 9; j ++) {\\n                char cur = board[i][j];\\n                if(cur != \\'.\\') if(!seen.add(cur + \"row\" + i)||!seen.add(cur + \"col\" + j)||!seen.add(cur + \"grid\" + i / 3 + \"-\" + j / 3)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843298,
                "title": "python-3-explained-solution-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking for each row if a value doesn\\'t repeat \\n        for row in range(9): #for each row\\n            row_values=[] #we create a list of values that are in the row\\n            for col in range(9): #we go through each column\\n                if board[row][col] != \".\": #if there is a number \\n                    if board[row][col] in row_values: #and the number is already in the list of values that are in the row => repetition \\n                        return False #sudoku is not valid\\n                    row_values.append(board[row][col]) #if the number is not in the list of values that are in the row, we add it\\n                    \\n        #checking for each col if a value doesn\\'t repeat\\n        for col in range(9): #for each column\\n            col_values=[] #we create a list of values that are in the column\\n            for row in range(9): #we go through each row\\n                if board[row][col] != \".\": #if there is a number\\n                    if board[row][col] in col_values: #and the number is already in the list of values that are in the column => repetition\\n                        return False #sudoku is not valid \\n                    col_values.append(board[row][col]) #if the number is not in the list of values that are in the column, we add it\\n    \\n        #checking for each 3*3 squares\\n        #the combination of squares are : \\n\\t\\t#[0,1,2][0,1,2] [0,1,2][3,4,5] [0,1,2][6,7,8]\\n\\t\\t#[3,4,5][0,1,2] [3,4,5][3,4,5] [3,4,5][6,7,8]\\n\\t\\t#[6,7,8][0,1,2] [6,7,8][3,4,5] [6,7,8][6,7,8]\\n\\t\\tlist = [[0,1,2], [3,4,5], [6,7,8]] \\n\\t\\t#those squares are the combination of the same indexes so we create a list to iterate upon with i and j\\n        for i in range(3): \\n            for j in range(3):\\n                square_values = [] #for each square we create a list of value that are in the square\\n                for col in list[i]: #we\\'re gonna go through 3 columns (1st : col 0, col 1 & col 2, then : col 3, col 4 & col 5 and finally : col 6, col 7, col 8)\\n                    for row in list[j]:#and 3 rows (1st : row 0, row 1 & row 2, then : row 3, row 4 & row 5 and finally : row 6, row 7, row 8)\\n                        if board[row][col] != \".\": #if there is a number \\n                            if board[row][col] in square_values: #and the number is already in the list of values that are in the square\\n                                return False #sudoku isn\\'t valid\\n                            square_values.append(board[row][col]) #if the number is not in the list of values that are in the square, we add it \\n        \\n        return True #if we could not find invalid sudoku in those 3 cases, then sudoku is valid\\n```\\nPlease upvote if it does help ! :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        #checking for each row if a value doesn\\'t repeat \\n        for row in range(9): #for each row\\n            row_values=[] #we create a list of values that are in the row\\n            for col in range(9): #we go through each column\\n                if board[row][col] != \".\": #if there is a number \\n                    if board[row][col] in row_values: #and the number is already in the list of values that are in the row => repetition \\n                        return False #sudoku is not valid\\n                    row_values.append(board[row][col]) #if the number is not in the list of values that are in the row, we add it\\n                    \\n        #checking for each col if a value doesn\\'t repeat\\n        for col in range(9): #for each column\\n            col_values=[] #we create a list of values that are in the column\\n            for row in range(9): #we go through each row\\n                if board[row][col] != \".\": #if there is a number\\n                    if board[row][col] in col_values: #and the number is already in the list of values that are in the column => repetition\\n                        return False #sudoku is not valid \\n                    col_values.append(board[row][col]) #if the number is not in the list of values that are in the column, we add it\\n    \\n        #checking for each 3*3 squares\\n        #the combination of squares are : \\n\\t\\t#[0,1,2][0,1,2] [0,1,2][3,4,5] [0,1,2][6,7,8]\\n\\t\\t#[3,4,5][0,1,2] [3,4,5][3,4,5] [3,4,5][6,7,8]\\n\\t\\t#[6,7,8][0,1,2] [6,7,8][3,4,5] [6,7,8][6,7,8]\\n\\t\\tlist = [[0,1,2], [3,4,5], [6,7,8]] \\n\\t\\t#those squares are the combination of the same indexes so we create a list to iterate upon with i and j\\n        for i in range(3): \\n            for j in range(3):\\n                square_values = [] #for each square we create a list of value that are in the square\\n                for col in list[i]: #we\\'re gonna go through 3 columns (1st : col 0, col 1 & col 2, then : col 3, col 4 & col 5 and finally : col 6, col 7, col 8)\\n                    for row in list[j]:#and 3 rows (1st : row 0, row 1 & row 2, then : row 3, row 4 & row 5 and finally : row 6, row 7, row 8)\\n                        if board[row][col] != \".\": #if there is a number \\n                            if board[row][col] in square_values: #and the number is already in the list of values that are in the square\\n                                return False #sudoku isn\\'t valid\\n                            square_values.append(board[row][col]) #if the number is not in the list of values that are in the square, we add it \\n        \\n        return True #if we could not find invalid sudoku in those 3 cases, then sudoku is valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841289,
                "title": "c-using-set-comments-added-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) \\n    {\\n        map<int,set<int>> rows;                                      // for keep cheking the previous row value\\n        map<int,set<int>> cols;                                       // for keep cheking the previous col value\\n        map<pair<int,int>,set<int>> subBox;                 // for keep cheking the previous curr 3x3 matrix value by pair\\n        \\n        for(int r=0;r<9;r++)                                              // each row\\n        {\\n            for(int c=0;c<9;c++)                                        // each col\\n            {\\n                // if it is . skip it\\n                if(board[r][c]==\\'.\\') continue;\\n                \\n                // if we found current value previously then return false\\n                \\n                // Check row\\n                if(rows[r].find(board[r][c]-\\'0\\') != rows[r].end())\\n                    return false;\\n                \\n                // check col\\n                if(cols[c].find(board[r][c]-\\'0\\') != cols[c].end())\\n                    return false;\\n                \\n                // check sub boxes\\n\\t\\t\\t\\t// (r/3,c/3) will tell the curr sub Box as we are taking them from (0,0) to (2,2)\\n                if(subBox[{r/3,c/3}].find(board[r][c]-\\'0\\') != subBox[{r/3,c/3}].end())\\n                    return false;\\n                \\n                \\n                // if none of then return false then add curr board value to the declared set for next check\\n                rows[r].insert(board[r][c]-\\'0\\');\\n                cols[c].insert(board[r][c]-\\'0\\');\\n                subBox[{r/3,c/3}].insert(board[r][c]-\\'0\\');\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) \\n    {\\n        map<int,set<int>> rows;                                      // for keep cheking the previous row value\\n        map<int,set<int>> cols;                                       // for keep cheking the previous col value\\n        map<pair<int,int>,set<int>> subBox;                 // for keep cheking the previous curr 3x3 matrix value by pair\\n        \\n        for(int r=0;r<9;r++)                                              // each row\\n        {\\n            for(int c=0;c<9;c++)                                        // each col\\n            {\\n                // if it is . skip it\\n                if(board[r][c]==\\'.\\') continue;\\n                \\n                // if we found current value previously then return false\\n                \\n                // Check row\\n                if(rows[r].find(board[r][c]-\\'0\\') != rows[r].end())\\n                    return false;\\n                \\n                // check col\\n                if(cols[c].find(board[r][c]-\\'0\\') != cols[c].end())\\n                    return false;\\n                \\n                // check sub boxes\\n\\t\\t\\t\\t// (r/3,c/3) will tell the curr sub Box as we are taking them from (0,0) to (2,2)\\n                if(subBox[{r/3,c/3}].find(board[r][c]-\\'0\\') != subBox[{r/3,c/3}].end())\\n                    return false;\\n                \\n                \\n                // if none of then return false then add curr board value to the declared set for next check\\n                rows[r].insert(board[r][c]-\\'0\\');\\n                cols[c].insert(board[r][c]-\\'0\\');\\n                subBox[{r/3,c/3}].insert(board[r][c]-\\'0\\');\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840703,
                "title": "c-hashset-faster-easy-to-understand",
                "content": "* ***Using Hashset***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& mat) {\\n        \\n        // declare a set\\n        \\n        unordered_set<string> s;\\n        \\n        // box number for any cell [i, j] is (i / 3) * + j / 3, taking (3 * 3) boxes\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(mat[i][j] != \\'.\\')\\n                {\\n                    // if the curr number is already present in set\\n                    \\n                    if(s.count(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                \\n                    if(s.count(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                         return false;\\n                    }\\n                \\n                    if(s.count(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    // insert the curr number in set with row no., col no., box no.\\n                \\n                    s.insert(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& mat) {\\n        \\n        // declare a set\\n        \\n        unordered_set<string> s;\\n        \\n        // box number for any cell [i, j] is (i / 3) * + j / 3, taking (3 * 3) boxes\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(mat[i][j] != \\'.\\')\\n                {\\n                    // if the curr number is already present in set\\n                    \\n                    if(s.count(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                \\n                    if(s.count(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                         return false;\\n                    }\\n                \\n                    if(s.count(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j])))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    // insert the curr number in set with row no., col no., box no.\\n                \\n                    s.insert(\"row\" + to_string(i) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"col\" + to_string(j) + \"*\" + to_string(mat[i][j]));\\n                \\n                    s.insert(\"box\" + to_string((i / 3) * 3 + j / 3) + \"*\" + to_string(mat[i][j]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423241,
                "title": "c-best-explanation-simple-100-faster",
                "content": "**Approach**\\n**1. Brute Force**\\n(a) - You can use 3 nested loops \\n(b) - For checking rows,column and box seperately.\\n\\n**2. Using a Single loop**\\n(a) - Make vectors of sets.\\n(b) - Each vector contain 9 sets. i.e, *9 set for rows, 9 set for column & 9 for box.*\\n(c) - Check if element is present in the box or not.\\n(d) - If Present, **return false**.\\n(e) - If Not Present, insert it into set and check for next element.\\n\\n`For accessing box set we use this formula  (i/3)*3 + (j/3)`\\n\\n![image](https://assets.leetcode.com/users/images/740929b0-0a47-4a0f-bd75-cc83920148c2_1660460466.4924154.jpeg)\\n\\n**Code :-**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        vector<set<int>> row(9),col(9),box(9);\\n        \\n        for(int i=0;i< 9;i++)\\n        {\\n            for(int j = 0;j < 9;j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'0\\';\\n                    \\n                    if(row[i].count(num) || col[j].count(num) || box[(i/3)*3 + (j/3)].count(num))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    row[i].insert(num);\\n                    col[j].insert(num);\\n                    box[(i/3)*3 + (j/3)].insert(num);\\n            \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        vector<set<int>> row(9),col(9),box(9);\\n        \\n        for(int i=0;i< 9;i++)\\n        {\\n            for(int j = 0;j < 9;j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    int num = board[i][j] - \\'0\\';\\n                    \\n                    if(row[i].count(num) || col[j].count(num) || box[(i/3)*3 + (j/3)].count(num))\\n                    {\\n                        return false;\\n                    }\\n                    \\n                    row[i].insert(num);\\n                    col[j].insert(num);\\n                    box[(i/3)*3 + (j/3)].insert(num);\\n            \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151963,
                "title": "c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        unordered_map<string, int> seen;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                int element = board[i][j];\\n                // skip if the cell is not filled\\n                if(element == \\'.\\')\\n                    continue;\\n                \\n                // string for each element found at a row to store in hashmap\\n                string rowFind = to_string(element) + \"found at row\" + to_string(i);\\n                \\n                // string for each element found at a column to store in hashmap\\n                string colFind = to_string(element) + \"found at column\" + to_string(j);\\n                \\n                // string for each element found at a sub-box to store in hashmap\\n                string boxFind = to_string(element) + \"found at box\" + to_string(i/3) + \\'-\\' + to_string(j/3);\\n                \\n                // checking if those are already inside hashmap, if not we\\'ll be putting em into hashmap\\n                if(seen.find(rowFind) != seen.end() ||\\n                   seen.find(colFind) != seen.end() ||\\n                   seen.find(boxFind) != seen.end()){\\n                    return false;\\n                }\\n                else{\\n                    seen[rowFind]++;\\n                    seen[colFind]++;\\n                    seen[boxFind]++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        unordered_map<string, int> seen;\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                int element = board[i][j];\\n                // skip if the cell is not filled\\n                if(element == \\'.\\')\\n                    continue;\\n                \\n                // string for each element found at a row to store in hashmap\\n                string rowFind = to_string(element) + \"found at row\" + to_string(i);\\n                \\n                // string for each element found at a column to store in hashmap\\n                string colFind = to_string(element) + \"found at column\" + to_string(j);\\n                \\n                // string for each element found at a sub-box to store in hashmap\\n                string boxFind = to_string(element) + \"found at box\" + to_string(i/3) + \\'-\\' + to_string(j/3);\\n                \\n                // checking if those are already inside hashmap, if not we\\'ll be putting em into hashmap\\n                if(seen.find(rowFind) != seen.end() ||\\n                   seen.find(colFind) != seen.end() ||\\n                   seen.find(boxFind) != seen.end()){\\n                    return false;\\n                }\\n                else{\\n                    seen[rowFind]++;\\n                    seen[colFind]++;\\n                    seen[boxFind]++;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527978,
                "title": "java-short-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    if(!set.add(\"row\" + i+ board[i][j]) || !set.add(\"col\" + j + board[i][j]) || !set.add(\"box\" + (i/3) *3+j/3 + board[i][j] )){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> set = new HashSet<>();\\n        \\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                \\n                if(board[i][j] != \\'.\\'){\\n                    \\n                    if(!set.add(\"row\" + i+ board[i][j]) || !set.add(\"col\" + j + board[i][j]) || !set.add(\"box\" + (i/3) *3+j/3 + board[i][j] )){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462256,
                "title": "js-set-time-and-space-o-1",
                "content": "```\\n\\n//approach: using set\\n//as I loop through the board\\'s col and row, I will make sure to put the element inside the set\\n//we know same row, col and the subBox cannot have the same value more than once, if it does, return false\\n\\nvar isValidSudoku = function(board) {\\n    let set = new Set();\\n    \\n    for(let r = 0; r < board.length; r++){\\n        for(let c = 0; c < board[r].length; c++){\\n            let val = board[r][c];\\n            \\n            if(val === \\'.\\')\\n                continue;\\n            \\n            //basically, formula is 3 * row + col --> to turn 2d array into 1d array\\n            //using Math.floor(row/3) + Math.floor(col/3) --> so we can find row and col of our sub box \\n            let boxNum = 3 * Math.floor(r/3) + Math.floor(c/3);\\n            \\n            let inRow = `row: ${r}, value: ${val}`;\\n            let inCol = `col: ${c}, value: ${val}`;\\n            let inSubBox = `subBox: ${boxNum}, value: ${val}`;\\n            \\n            if(set.has(inRow) || set.has(inCol) || set.has(inSubBox))\\n                return false;\\n            \\n            set.add(inRow);\\n            set.add(inCol);\\n            set.add(inSubBox);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\n\\n//approach: using set\\n//as I loop through the board\\'s col and row, I will make sure to put the element inside the set\\n//we know same row, col and the subBox cannot have the same value more than once, if it does, return false\\n\\nvar isValidSudoku = function(board) {\\n    let set = new Set();\\n    \\n    for(let r = 0; r < board.length; r++){\\n        for(let c = 0; c < board[r].length; c++){\\n            let val = board[r][c];\\n            \\n            if(val === \\'.\\')\\n                continue;\\n            \\n            //basically, formula is 3 * row + col --> to turn 2d array into 1d array\\n            //using Math.floor(row/3) + Math.floor(col/3) --> so we can find row and col of our sub box \\n            let boxNum = 3 * Math.floor(r/3) + Math.floor(c/3);\\n            \\n            let inRow = `row: ${r}, value: ${val}`;\\n            let inCol = `col: ${c}, value: ${val}`;\\n            let inSubBox = `subBox: ${boxNum}, value: ${val}`;\\n            \\n            if(set.has(inRow) || set.has(inCol) || set.has(inSubBox))\\n                return false;\\n            \\n            set.add(inRow);\\n            set.add(inCol);\\n            set.add(inSubBox);\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 684745,
                "title": "98-5-time-python3-using-prime-numbers",
                "content": "Assign each value (1-9) to a unique prime number, doesn\\'t matter which.\\n\\nFor each container, e.g. row,col, or box, assign its value to be the product of all the chosen primes.\\n\\nWhen you encounter a value x in some container, divide that container\\'s value by x. If this division results in a non-zero remainder, you know the container is invalid. This works because the remainder will only be nonzero if we\\'ve divided by x more than once. \\n\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        primes = [2,3,5,7,11,13,17,19,23]\\n        prod = 1\\n        for p in primes:\\n            prod *= p\\n        boxes = [prod] * 9\\n        rows = [prod] * 9\\n        cols = [prod] * 9\\n        for r in range(9):\\n            for c in range(9):\\n                s = board[r][c]\\n                if s == \".\":\\n                    continue\\n                b = (r // 3) * 3 + c // 3\\n                p = primes[int(s)-1]\\n                if boxes[b] % p != 0:\\n                    return False\\n                boxes[b] /= p\\n                if rows[r] % p != 0:\\n                    return False\\n                rows[r] /= p\\n                if cols[c] % p != 0:\\n                    return False\\n                cols[c] /= p\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        primes = [2,3,5,7,11,13,17,19,23]\\n        prod = 1\\n        for p in primes:\\n            prod *= p\\n        boxes = [prod] * 9\\n        rows = [prod] * 9\\n        cols = [prod] * 9\\n        for r in range(9):\\n            for c in range(9):\\n                s = board[r][c]\\n                if s == \".\":\\n                    continue\\n                b = (r // 3) * 3 + c // 3\\n                p = primes[int(s)-1]\\n                if boxes[b] % p != 0:\\n                    return False\\n                boxes[b] /= p\\n                if rows[r] % p != 0:\\n                    return False\\n                rows[r] /= p\\n                if cols[c] % p != 0:\\n                    return False\\n                cols[c] /= p\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15552,
                "title": "python-solution-simple-and-fast",
                "content": "    class Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n    \\n        map_row = [{} for _ in xrange(9)]\\n        map_col = [{} for _ in xrange(9)]\\n        map_cell = [[{} for _ in xrange(3)] for __ in xrange(3)]\\n        for i in xrange(9):\\n            for j in xrange(9):\\n                char = board[i][j]\\n                if char == '.': continue\\n                if char in map_row[i]: return False\\n                else: map_row[i][char] = [i,j]\\n                if char in map_col[j]: return False\\n                else: map_col[j][char] = [i,j]\\n                if char in map_cell[i/3][j/3]: return False\\n                else: map_cell[i/3][j/3][char] = [i,j]\\n        return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def isValidSudoku(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: bool\\n        \"\"\"\\n    \\n        map_row = [{}",
                "codeTag": "Java"
            },
            {
                "id": 4073241,
                "title": "simple-java-solutions-runtime-2ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java\\nclass Solution {\\n   public boolean isValidSudoku(char[][] board) {\\n\\n         for (int i = 0; i < 9; i++) {\\n            HashSet<Character> RowSet = new HashSet<>();\\n            HashSet<Character> ColSet = new HashSet<>();\\n            for (int j = 0; j < 9; j++) {\\n                char r = board[i][j];\\n                char c = board[j][i];\\n                if ( (r != \\'.\\' && !RowSet.add(r) ) || (c != \\'.\\' && !ColSet.add(c))) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < 9; i = i + 3) {\\n            for (int j = 0; j < 9; j = j + 3) {\\n                if (!checkBlock(i, j, board))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static boolean checkBlock(int IdI, int IdJ, char[][] boards) {\\n        HashSet<Character> set = new HashSet<>();\\n\\n        int rows = IdI + 3;\\n        int cols = IdJ + 3;\\n        for (int i = IdI; i < rows; i++) {\\n            for (int j = IdJ; j < cols; j++) {\\n                char c = boards[i][j];\\n                if (c != \\'.\\' && !set.add(c)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/19750e74-99dc-4312-82af-f5aaa467fe64_1695313499.690562.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n   public boolean isValidSudoku(char[][] board) {\\n\\n         for (int i = 0; i < 9; i++) {\\n            HashSet<Character> RowSet = new HashSet<>();\\n            HashSet<Character> ColSet = new HashSet<>();\\n            for (int j = 0; j < 9; j++) {\\n                char r = board[i][j];\\n                char c = board[j][i];\\n                if ( (r != \\'.\\' && !RowSet.add(r) ) || (c != \\'.\\' && !ColSet.add(c))) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < 9; i = i + 3) {\\n            for (int j = 0; j < 9; j = j + 3) {\\n                if (!checkBlock(i, j, board))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static boolean checkBlock(int IdI, int IdJ, char[][] boards) {\\n        HashSet<Character> set = new HashSet<>();\\n\\n        int rows = IdI + 3;\\n        int cols = IdJ + 3;\\n        for (int i = IdI; i < rows; i++) {\\n            for (int j = IdJ; j < cols; j++) {\\n                char c = boards[i][j];\\n                if (c != \\'.\\' && !set.add(c)) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842282,
                "title": "brute-force-c-solution-working-fine",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char, int> mp;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\')\\n                mp[board[i][j]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[j][i] != \\'.\\')\\n                mp[board[j][i]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n        for(int m=0; m<9; m+=3){\\n            for(int i=0; i<9; i+=3){\\n                for(int j=m; j<m+3; j++){\\n                    for(int k=i; k<i+3; k++){\\n                        if(board[j][k] != \\'.\\')\\n                        mp[board[j][k]]++;\\n                    }\\n                }\\n                for(auto x : mp){\\n                    if(x.second > 1)\\n                    return false;\\n                }\\n                mp.clear();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        map<char, int> mp;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\')\\n                mp[board[i][j]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[j][i] != \\'.\\')\\n                mp[board[j][i]]++;\\n            }\\n            for(auto x : mp){\\n                if(x.second > 1)\\n                return false;\\n            }\\n            mp.clear();\\n        }\\n        for(int m=0; m<9; m+=3){\\n            for(int i=0; i<9; i+=3){\\n                for(int j=m; j<m+3; j++){\\n                    for(int k=i; k<i+3; k++){\\n                        if(board[j][k] != \\'.\\')\\n                        mp[board[j][k]]++;\\n                    }\\n                }\\n                for(auto x : mp){\\n                    if(x.second > 1)\\n                    return false;\\n                }\\n                mp.clear();\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841489,
                "title": "rust-iterators-14-lines-4mc",
                "content": "```\\nfn uniq<\\'a>(it: impl Iterator<Item = &\\'a char>) -> bool {\\n    let mut v = [0; 10];\\n    it.filter_map(|c| c.to_digit(10))\\n        .for_each(|c| v[c as usize] += 1);\\n    v.iter().all(|&v| v < 2)\\n}\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let block_it = |i, j| board[i..i + 3].iter().flat_map(move |row| &row[j..j + 3]);\\n\\n        (0..3).all(|i| (0..3).all(|j| uniq(block_it(i * 3, j * 3))))\\n            && (0..9).all(|i| uniq(board.iter().map(|row| &row[i])))\\n            && board.iter().map(|v| v.iter()).all(uniq)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nfn uniq<\\'a>(it: impl Iterator<Item = &\\'a char>) -> bool {\\n    let mut v = [0; 10];\\n    it.filter_map(|c| c.to_digit(10))\\n        .for_each(|c| v[c as usize] += 1);\\n    v.iter().all(|&v| v < 2)\\n}\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let block_it = |i, j| board[i..i + 3].iter().flat_map(move |row| &row[j..j + 3]);\\n\\n        (0..3).all(|i| (0..3).all(|j| uniq(block_it(i * 3, j * 3))))\\n            && (0..9).all(|i| uniq(board.iter().map(|row| &row[i])))\\n            && board.iter().map(|v| v.iter()).all(uniq)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2807940,
                "title": "easy-c-solution-explanation-in-simple-hinglish-for-intuition",
                "content": "Pure sudoku board ko 9 boxes/grid mein divide kar do aur numbering 0 to 8 kar do\\n0 1 2\\n3 4 5 \\n6 7 8\\n\\nHar ek box ek grid ki tarah hai to ab usko calculate karne ka formula hai :=\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t(row/3)*3+(col/3)\\n\\npure ke pure value ko string bana ke attach kar do= \"ROW+row_val+element\".....\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tsimilarly column aur box ke liye karo.\\n\\nFir set mein check karo kya pehle se row ya col ya grid ka strings set mein h?? \\nAgar hai to false return kar do nai to insert kar do.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<string> s;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j]!=\\'.\\')\\n                {\\n                    string row=\"row\"+to_string(i)+board[i][j];\\n                    string col=\"col\"+to_string(j)+board[i][j];\\n                    string box=\"box\"+to_string((i/3)*3+(j/3))+board[i][j];\\n                    \\n                    if(s.find(row)==s.end() && s.find(col)==s.end() && s.find(box)==s.end())\\n                    {\\n                        s.insert(row);\\n                        s.insert(col);\\n                        s.insert(box);\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        set<string> s;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                if(board[i][j]!=\\'.\\')\\n                {\\n                    string row=\"row\"+to_string(i)+board[i][j];\\n                    string col=\"col\"+to_string(j)+board[i][j];\\n                    string box=\"box\"+to_string((i/3)*3+(j/3))+board[i][j];\\n                    \\n                    if(s.find(row)==s.end() && s.find(col)==s.end() && s.find(box)==s.end())\\n                    {\\n                        s.insert(row);\\n                        s.insert(col);\\n                        s.insert(box);\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504217,
                "title": "python-hashset-simple-solution",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Validate each row\\n        for r in range(9):\\n            hashSet = set()\\n            for c in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each column\\n        for c in range(9):\\n            hashSet = set()\\n            for r in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each box\\n        r, c = 0, 0\\n        while True:\\n            hashSet = set()\\n            for i in range(r, r+3):\\n                for j in range(c, c+3):\\n                    if board[i][j] != \\'.\\':\\n                        if board[i][j] in hashSet:\\n                            return False\\n                        hashSet.add(board[i][j])\\n            c += 3\\n            if c == 9:\\n                r += 3\\n                # Break if we have verified all 9 boxes\\n                if r == 9:\\n                    break\\n                c = 0\\n        return True\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Validate each row\\n        for r in range(9):\\n            hashSet = set()\\n            for c in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each column\\n        for c in range(9):\\n            hashSet = set()\\n            for r in range(9):\\n                if board[r][c] != \\'.\\':\\n                    if board[r][c] in hashSet:\\n                        return False\\n                    hashSet.add(board[r][c])\\n        \\n        # Validate each box\\n        r, c = 0, 0\\n        while True:\\n            hashSet = set()\\n            for i in range(r, r+3):\\n                for j in range(c, c+3):\\n                    if board[i][j] != \\'.\\':\\n                        if board[i][j] in hashSet:\\n                            return False\\n                        hashSet.add(board[i][j])\\n            c += 3\\n            if c == 9:\\n                r += 3\\n                # Break if we have verified all 9 boxes\\n                if r == 9:\\n                    break\\n                c = 0\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488448,
                "title": "c-just-12-lines-of-code-no-space-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& ar) {\\n        \\n        for(int i=0;i<ar.size();i++)\\n            for(int j=0;j<ar.size();j++)\\n                if(ar[i][j] != \\'.\\'){\\n                    for(int k=0;k<9;k++)\\n                        if( (i!=k && ar[k][j]==ar[i][j]) || (j!=k && ar[i][k]==ar[i][j]) )\\n                            return 0;\\n                    for(int row=3*(i/3); row<3*(i/3)+3; row++)\\n                        for(int col=3*(j/3); col<3*(j/3)+3; col++)\\n                            if( (row!=i || col!=j) && ar[row][col]==ar[i][j])\\n                                return 0;\\n                }\\n        return 1;\\n    }\\n};\\n\\nHit like if found helpful : )",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& ar) {\\n        \\n        for(int i=0;i<ar.size();i++)\\n            for(int j=0;j<ar.size();j++)\\n                if(ar[i][j] != \\'.\\'){\\n                    for(int k=0;k<9;k++)\\n                        if( (i!=k && ar[k][j]==ar[i][j]) || (j!=k && ar[i][k]==ar[i][j]) )\\n                            return 0;\\n                    for(int row=3*(i/3); row<3*(i/3)+3; row++)\\n                        for(int col=3*(j/3); col<3*(j/3)+3; col++)\\n                            if( (row!=i || col!=j) && ar[row][col]==ar[i][j])\\n                                return 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1471156,
                "title": "1ms-java-solution-brute-force-hashmap-hashset",
                "content": "**HashMap**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<9; i++)\\n            for(int j=0; j<9; j++)\\n                if(board[i][j] != \\'.\\') {\\n                    \\n                    String row = board[i][j] + \" row \" + i;\\n                    String col = board[i][j] + \" col \" + j;\\n                    String box = board[i][j] + \" box \" + i/3 + \"and\" + j/3;\\n                    \\n                    map.put(row, map.getOrDefault(row, 0) + 1);\\n                    map.put(col, map.getOrDefault(col, 0) + 1);\\n                    map.put(box, map.getOrDefault(box, 0) + 1);\\n                    \\n                    if(map.get(row) > 1 || map.get(col) > 1 || map.get(box) > 1)\\n                        return false;\\n                }\\n                \\n        return true;\\n    }\\n```\\nSimilarly, You can implement this using HahsSet.\\n\\n**Brute force**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] box = new boolean[9][9];\\n        \\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != \\'.\\') {\\n                    \\n                    int n = board[i][j] - \\'1\\';\\n                    \\n                    if (row[n][i]) \\n                        return false;\\n                    row[n][i] = true;\\n                    \\n                    if (col[n][j]) \\n                        return false;\\n                    col[n][j] = true;\\n                    \\n                    int bi = (i / 3) * 3 + (j / 3);\\n                    \\n                    if (box[n][bi]) \\n                        return false;\\n                    box[n][bi] = true;\\n                }\\n                \\n        return true;\\n    }\\n```\\n\\n**Please UPVOTE ^ If this post is useful for you.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isValidSudoku(char[][] board) {\\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for(int i=0; i<9; i++)\\n            for(int j=0; j<9; j++)\\n                if(board[i][j] != \\'.\\') {\\n                    \\n                    String row = board[i][j] + \" row \" + i;\\n                    String col = board[i][j] + \" col \" + j;\\n                    String box = board[i][j] + \" box \" + i/3 + \"and\" + j/3;\\n                    \\n                    map.put(row, map.getOrDefault(row, 0) + 1);\\n                    map.put(col, map.getOrDefault(col, 0) + 1);\\n                    map.put(box, map.getOrDefault(box, 0) + 1);\\n                    \\n                    if(map.get(row) > 1 || map.get(col) > 1 || map.get(box) > 1)\\n                        return false;\\n                }\\n                \\n        return true;\\n    }\\n```\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] row = new boolean[9][9];\\n        boolean[][] col = new boolean[9][9];\\n        boolean[][] box = new boolean[9][9];\\n        \\n        for (int i = 0; i < 9; i++)\\n            for (int j = 0; j < 9; j++)\\n                if (board[i][j] != \\'.\\') {\\n                    \\n                    int n = board[i][j] - \\'1\\';\\n                    \\n                    if (row[n][i]) \\n                        return false;\\n                    row[n][i] = true;\\n                    \\n                    if (col[n][j]) \\n                        return false;\\n                    col[n][j] = true;\\n                    \\n                    int bi = (i / 3) * 3 + (j / 3);\\n                    \\n                    if (box[n][bi]) \\n                        return false;\\n                    box[n][bi] = true;\\n                }\\n                \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1415732,
                "title": "kotlin-simple-easy-and-short-solution",
                "content": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n        val rowRecord = Array(9) { mutableSetOf<Char>() }\\n        val columnRecord = Array(9) { mutableSetOf<Char>() }\\n        val subBoxRecord = Array(9) { mutableSetOf<Char>() }\\n\\n        board.forEachIndexed { rowIndex, chars ->\\n            chars.forEachIndexed { columnIndex, c ->\\n                if (c in \\'1\\'..\\'9\\') {\\n                    val subBoxIndex = rowIndex / 3 * 3 + columnIndex / 3\\n                    if (!rowRecord[rowIndex].add(c)\\n                        || !columnRecord[columnIndex].add(c)\\n                        || !subBoxRecord[subBoxIndex].add(c)) {\\n                        return false\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n        val rowRecord = Array(9) { mutableSetOf<Char>() }\\n        val columnRecord = Array(9) { mutableSetOf<Char>() }\\n        val subBoxRecord = Array(9) { mutableSetOf<Char>() }\\n\\n        board.forEachIndexed { rowIndex, chars ->\\n            chars.forEachIndexed { columnIndex, c ->\\n                if (c in \\'1\\'..\\'9\\') {\\n                    val subBoxIndex = rowIndex / 3 * 3 + columnIndex / 3\\n                    if (!rowRecord[rowIndex].add(c)\\n                        || !columnRecord[columnIndex].add(c)\\n                        || !subBoxRecord[subBoxIndex].add(c)) {\\n                        return false\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700753,
                "title": "python-solution",
                "content": "The goal of this problem is to check if the current board is valid or not.\\nLet\\'s define what it means to be valid in a game of sudoku:\\n1. Each row should have unique numbers from 1 - 9\\n2. Each column should have unique numbers from 1 - 9\\n3. Each box should have unique numbers from 1 - 9\\n\\nThus, this means if we hold the values of each row, column, and box and check for duplicates, we will be able to check if the board is valid or not.\\nThe trickiest part would be to check the duplicate values for each box.\\nOne way to do this would be to name each box as 0~8, and consider the box as (row // 3)*3 + (col // 3).\\n\\n```\\ndef isValidSudoku(self, board):\\n\\trows = [set() for i in range(9)]\\n\\tcols = [set() for i in range(9)]\\n\\tboxes = [set() for i in range(9)]\\n\\t#quadrant = (row / 3) * 3 + (col / 3)\\n\\tfor row in range(len(board)):\\n\\t\\tfor col in range(len(board)):\\n\\t\\t\\tif board[row][col] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnumber = board[row][col]\\n\\t\\t\\tbox = (row // 3) * 3 + col // 3\\n\\t\\t\\tif number in rows[row] or number in cols[col] or number in boxes[box]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\trows[row].add(number)\\n\\t\\t\\tcols[col].add(number)\\n\\t\\t\\tboxes[box].add(number)\\n\\treturn True\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef isValidSudoku(self, board):\\n\\trows = [set() for i in range(9)]\\n\\tcols = [set() for i in range(9)]\\n\\tboxes = [set() for i in range(9)]\\n\\t#quadrant = (row / 3) * 3 + (col / 3)\\n\\tfor row in range(len(board)):\\n\\t\\tfor col in range(len(board)):\\n\\t\\t\\tif board[row][col] == \\'.\\':\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tnumber = board[row][col]\\n\\t\\t\\tbox = (row // 3) * 3 + col // 3\\n\\t\\t\\tif number in rows[row] or number in cols[col] or number in boxes[box]:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\trows[row].add(number)\\n\\t\\t\\tcols[col].add(number)\\n\\t\\t\\tboxes[box].add(number)\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 304054,
                "title": "java-beats-100",
                "content": "```java\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int[] rows = new int[9], cols = new int[9], squares = new int[9];\\n        for(int r=0; r<board.length; r++){\\n            for(int c=0; c<board[0].length; c++){\\n                if(board[r][c] != \\'.\\'){\\n                    int value = (1 << (board[r][c] - \\'1\\'));\\n                    if((value & rows[r]) > 0 || (value & cols[c]) > 0 || (value & squares[3*(r/3)+c/3]) > 0) return false;\\n                    rows[r] |= value;\\n                    cols[c] |= value;\\n                    squares[3*(r/3)+c/3] |= value;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int[] rows = new int[9], cols = new int[9], squares = new int[9];\\n        for(int r=0; r<board.length; r++){\\n            for(int c=0; c<board[0].length; c++){\\n                if(board[r][c] != \\'.\\'){\\n                    int value = (1 << (board[r][c] - \\'1\\'));\\n                    if((value & rows[r]) > 0 || (value & cols[c]) > 0 || (value & squares[3*(r/3)+c/3]) > 0) return false;\\n                    rows[r] |= value;\\n                    cols[c] |= value;\\n                    squares[3*(r/3)+c/3] |= value;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15493,
                "title": "c-o-n-2-solution",
                "content": "```\\npublic class Solution {\\n    public bool IsValidSudoku(char[,] board) {\\n        for(var i=0;i<9;++i){\\n            var col = new HashSet<char>();\\n            var row = new HashSet<char>();\\n            var sub = new HashSet<char>();\\n\\n            for(var j=0;j<9;j++){\\n                \\n                if(board[i,j]!='.' && col.Contains(board[i,j])) return false;\\n                col.Add(board[i,j]);\\n                \\n                if(board[j,i]!='.' && row.Contains(board[j,i])) return false;\\n                row.Add(board[j,i]);\\n                \\n                var x = (i%3)*3 + j%3;\\n                var y = (i/3)*3 + j/3;\\n                if(board[x,y]!='.' && sub.Contains(board[x,y])) return false;\\n                sub.Add(board[x,y]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsValidSudoku(char[,] board) {\\n        for(var i=0;i<9;++i){\\n            var col = new HashSet<char>();\\n            var row = new HashSet<char>();\\n            var sub = new HashSet<char>();\\n\\n            for(var j=0;j<9;j++){\\n                \\n                if(board[i,j]!='.' && col.Contains(board[i,j])) return false;\\n                col.Add(board[i,j]);\\n                \\n                if(board[j,i]!='.' && row.Contains(board[j,i])) return false;\\n                row.Add(board[j,i]);\\n                \\n                var x = (i%3)*3 + j%3;\\n                var y = (i/3)*3 + j/3;\\n                if(board[x,y]!='.' && sub.Contains(board[x,y])) return false;\\n                sub.Add(board[x,y]);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 15612,
                "title": "simple-solution-with-explanation",
                "content": "For this problem, just according to the define of Sudoku, \\n\\n1. row: in the row, there can't have  same number.\\n\\n2. column: in the  column, there can't have  same number.\\n\\n3. 3 * 3 grid:  in the 3 * 3 grid, there can't have  same number.\\n\\nwe can get a simple solution. One place to need to pay attention to is board[i / 3 * 3][j / 3 * 3] is the top left of the 3 * 3 grid.\\n\\n    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tif (board[i][j] == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (!isValid(board, i, j))\\n\\t\\t\\t\\t\\treturn false;\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n\\tprivate static  boolean isValid(char[][] board, int i, int j) {\\n\\t\\tfor (int m = 0; m < 9; m++) {\\n\\t\\t\\tif (m != j && board[i][m] == board[i][j]) // row\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (m != i && board[m][j] == board[i][j]) // column\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor (int m = i / 3 * 3; m < i / 3 * 3 + 3; m++) { // 3 * 3 grid\\n\\t\\t\\tfor (int n = j / 3 * 3; n < j / 3 * 3 + 3; n++) {\\n\\t\\t\\t\\tif (m != i && n != j && board[m][n] == board[i][j])\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "solutionTags": [],
                "code": "For this problem, just according to the define of Sudoku, \\n\\n1. row: in the row, there can't have  same number.\\n\\n2. column: in the  column, there can't have  same number.\\n\\n3. 3 * 3 grid:  in the 3 * 3 grid, there can't have  same number.\\n\\nwe can get a simple solution. One place to need to pay attention to is board[i / 3 * 3][j / 3 * 3] is the top left of the 3 * 3 grid.\\n\\n    public static boolean isValidSudoku(char[][] board) {\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\tif (board[i][j] == '.')\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif (!isValid(board, i, j))\\n\\t\\t\\t\\t\\treturn false;\\t\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true; \\n    }\\n\\tprivate static  boolean isValid(char[][] board, int i, int j) {\\n\\t\\tfor (int m = 0; m < 9; m++) {\\n\\t\\t\\tif (m != j && board[i][m] == board[i][j]) // row\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (m != i && board[m][j] == board[i][j]) // column\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor (int m = i / 3 * 3; m < i / 3 * 3 + 3; m++) { // 3 * 3 grid\\n\\t\\t\\tfor (int n = j / 3 * 3; n < j / 3 * 3 + 3; n++) {\\n\\t\\t\\t\\tif (m != i && n != j && board[m][n] == board[i][j])\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 15705,
                "title": "my-c-code-o-n2-time-and-space",
                "content": "The basic idea is to use an array to indicate whether a number in a row/column/3x3 sub-block already occurs. We need a 9x9 array existNum and\\na) the LSB of existNum[i][j] indicates whether number j occurs on the i-th row before\\nb) the 2-LSB of existNum[i][j] indicates whether number j occurs on the i-th column before\\nc) the 3-LSB of existNum[i][j] indicates whether number j occurs on the i-th sub-block before, k= (i/3)*3 + j/3\\n\\n\\n    class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            char existNum[10][10]={0};\\n            int i,j;\\n            \\n            for(i=0; i<9; i++)\\n            {\\n                for(j=0; j<9; j++)\\n                {\\n                    if(board[i][j]!='.')\\n                    {\\n                        if(existNum[i][board[i][j] - '0'] & 0x1)return false; // check if the i-row already has such number, LSB\\n                        if(existNum[j][board[i][j] - '0'] & 0x2) return false; // check if the j-col already has such number, 2-LSB\\n                        if(existNum[(i/3) *3 + j/3][board[i][j] - '0'] & 0x4) return false; // check if the k-subblock already has such number, 3-LSB\\n                        existNum[i][board[i][j] - '0'] ^=0x1;\\n                        existNum[j][board[i][j] - '0'] ^=0x2;\\n                        existNum[(i/3) *3 + j/3][board[i][j] - '0'] ^=0x4;\\n                    }\\n                    \\n                }\\n            }\\n            \\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSudoku(vector<vector<char> > &board) {\\n            char existNum[10][10]={0}",
                "codeTag": "Java"
            },
            {
                "id": 3768728,
                "title": "100-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        return solve(board);\\n    }\\n     boolean solve(char[][]board)\\n    { for(int i=0;i<board.length;i++)\\n    {for(int j=0;j<board.length;j++)\\n    { if(board[i][j] != \\'.\\')\\n    { char num=board[i][j];\\n     board[i][j]=\\'.\\';\\n     if(!isSafe(board,i,j,num)) return false;\\n      else\\n    //backtrack\\n     board[i][j]=num;\\n     } }}\\n    return true; }\\n     boolean isSafe(char[][] board,int row,int col,char num)\\n    { // check the row\\n      for(int i=0;i<board.length;i++)\\n      { // check if the number is in the row\\n        if(board[i][col] == num)  return false;\\n         // check the column\\n        // check if the number is in the column\\n        if(board[row][i]== num) return false;\\n      }int sqrt=(int)(Math.sqrt(board.length));\\n      int rowStart=row - row % sqrt;\\n      int colStart=col - col % sqrt;\\n      for(int r=rowStart;r<rowStart + sqrt;r++)\\n      { for(int c=colStart;c<colStart + sqrt;c++)\\n       {if(board[r][c] == num)   return false; }\\n      }return true;\\n}\\n}\\n\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/91a30870-3320-44a9-84bb-88a9fb3a4f2e_1689425161.7847996.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        return solve(board);\\n    }\\n     boolean solve(char[][]board)\\n    { for(int i=0;i<board.length;i++)\\n    {for(int j=0;j<board.length;j++)\\n    { if(board[i][j] != \\'.\\')\\n    { char num=board[i][j];\\n     board[i][j]=\\'.\\';\\n     if(!isSafe(board,i,j,num)) return false;\\n      else\\n    //backtrack\\n     board[i][j]=num;\\n     } }}\\n    return true; }\\n     boolean isSafe(char[][] board,int row,int col,char num)\\n    { // check the row\\n      for(int i=0;i<board.length;i++)\\n      { // check if the number is in the row\\n        if(board[i][col] == num)  return false;\\n         // check the column\\n        // check if the number is in the column\\n        if(board[row][i]== num) return false;\\n      }int sqrt=(int)(Math.sqrt(board.length));\\n      int rowStart=row - row % sqrt;\\n      int colStart=col - col % sqrt;\\n      for(int r=rowStart;r<rowStart + sqrt;r++)\\n      { for(int c=colStart;c<colStart + sqrt;c++)\\n       {if(board[r][c] == num)   return false; }\\n      }return true;\\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653296,
                "title": "c-easy-fully-explained-hindi-english-best",
                "content": "\\n\\n# Approach\\nThe question is asking us to check whether any integer between 1-9 appears more than once in a particular row, column, or 3x3 grid.\\n\\nFor this, we will create three hash arrays, a, b, and c. Array a will check whether any integer from 1 to 9 appears more than once in a particular row, array b will check whether any integer from 1 to 9 appears more than once in a particular column, and array c will check whether any integer from 1 to 9 appears more than once in a particular 3x3 grid.\\n\\nIf any of these conditions are true, we will return false; otherwise, we will return true\\n\\nk = i / 3 * 3 + j / 3\\nfor those who need to visualize k > here\\n\\n0 0 0 | 1 1 1 | 2 2 2\\n0 0 0 | 1 1 1 | 2 2 2\\n0 0 0 | 1 1 1 | 2 2 2\\n--------+---------+---------\\n3 3 3 | 4 4 4 | 5 5 5\\n3 3 3 | 4 4 4 | 5 5 5\\n3 3 3 | 4 4 4 | 5 5 5\\n--------+----------+--------\\n6 6 6 | 7 7 7 | 8 8 8\\n6 6 6 | 7 7 7 | 8 8 8\\n6 6 6 | 7 7 7 | 8 8 8\\n\\nPLease upvote the solution.****\\n\\nhindi-\\nEss question mai hame check karna hai ki koi integer{1-9} particular row ya coloum ya 3*3 ki grid mai ek se jayda baar na aaye .\\n\\niske liye ham a,b,c 3 hash array create karenge jisme A check karegi ki kya koi integer[1-9] ek row mai do baar toh nahi aa rha or B check karegi ki kya koi integer[1-9] ek coloum mai do baar toh nahi aa rha or C ka kaam hoga ki check karna ki kya koi integer[1-9] ek 3*3 ki grid mai do baar toh nahi aa rha agar isme se ek bhi condition true hoti hai to ham false return karenge else true return karenge\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int a[9][9]={0},b[9][9]={0},c[9][9]={0};\\n        for(int i=0;i<board.size();++i){\\n            for(int j=0;j<board.size();++j){\\n                if(board[i][j]!=\\'.\\'){\\n                    int num=board[i][j]-\\'0\\'-1;\\n                    int k= i / 3 * 3 + j / 3;\\n                    if(a[i][num]||b[j][num]||c[k][num]){\\n                        return false;\\n                    }\\n                        a[i][num]=b[j][num]=c[k][num]=1;\\n                    \\n                }\\n\\n            \\n            }\\n\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int a[9][9]={0},b[9][9]={0},c[9][9]={0};\\n        for(int i=0;i<board.size();++i){\\n            for(int j=0;j<board.size();++j){\\n                if(board[i][j]!=\\'.\\'){\\n                    int num=board[i][j]-\\'0\\'-1;\\n                    int k= i / 3 * 3 + j / 3;\\n                    if(a[i][num]||b[j][num]||c[k][num]){\\n                        return false;\\n                    }\\n                        a[i][num]=b[j][num]=c[k][num]=1;\\n                    \\n                }\\n\\n            \\n            }\\n\\n        }\\n        return true;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613853,
                "title": "w-explanation-c-c-python-solution-uses-bool-arrays-bitsets-sets-as-hash-tables",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFrom {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9>, boolean arrays or sets suffice to use for recording and checking and play the role of hash tables!! \\n\\nLeetcode 37. Sudoku Solver is also solved in the similar manner.\\n[https://leetcode.com/problems/sudoku-solver/solutions/3622243/w-explain-c-c-solves-via-backtracking-bool-arrays-in-3-ms/](https://leetcode.com/problems/sudoku-solver/solutions/3622243/w-explain-c-c-solves-via-backtracking-bool-arrays-in-3-ms/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nC solution Runtime 8 ms Beats 92.31%.\\n[Please turn on English subtitles if neccessary]\\n[https://youtu.be/hkXrewUTqyc](https://youtu.be/hkXrewUTqyc)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bitset<9> Col[9];\\n        bitset<9> Row[9];\\n        bitset<9> Block[9];\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c == \\'.\\') continue;\\n                int x=(c-\\'0\\')%9; \\n                // Convert the character digit to an index (0-8) 0 for 9\\n\\n                if (Row[i][x]) return 0;\\n                Row[i][x] = 1;\\n\\n                if (Col[j][x]) return 0;\\n                Col[j][x] = 1;\\n                \\n                int bidx = (i / 3) * 3 + j / 3;\\n                if (Block[bidx][x]) return 0;\\n                Block[bidx][x] = 1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n```C []\\nbool isValidSudoku(char** board, int boardSize, int* boardColSize)\\n{\\n    bool Col[9][9]={0};\\n    bool Row[9][9]={0};\\n    bool Block[9][9]={0};\\n\\n    for(int i=0; i<9; i++){\\n        for(int j=0; j<9; j++){\\n            char c = board[i][j];\\n            if (c == \\'.\\') continue;\\n            int x=(c-\\'0\\')%9; \\n            // Convert the character digit to an index (0-8) 0 for 9\\n\\n            if (Row[i][x]==1) return 0;\\n            Row[i][x] = 1;\\n\\n            if (Col[j][x]==1) return 0;\\n            Col[j][x] = 1;\\n                \\n            int bidx = (i / 3) * 3 + j / 3;\\n            if (Block[bidx][x]==1) return 0;\\n            Block[bidx][x] = 1;\\n        }\\n    }\\n    return 1;\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Use sets\\n        Col = [set() for _ in range(9)]\\n        Row = [set() for _ in range(9)]\\n        Block = [set() for _ in range(9)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                c=board[i][j]\\n                if c==\\'.\\': continue\\n                x=(ord(c)-ord(\\'0\\'))%9\\n\\n                if x in Row[i]: return False\\n                Row[i].add(x)\\n\\n                if x in Col[j]: return False\\n                Col[j].add(x)\\n\\n                idx=i//3*3+j//3\\n                if x in Block[idx]: return False\\n                Block[idx].add(x)\\n        return True\\'\\n```\\nAnother approach uses C++ unordered_set for strings.\\n# C++ solution uses unordered_set\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> C;\\n        int n=0;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c != \\'.\\') {\\n                    n++;\\n                    string row=\"row\"+to_string(i)+c;\\n                    string col=\"col\"+to_string(j)+c;\\n                    int bidx = (i / 3) * 3 + j / 3;\\n                    string block=\"block\"+to_string(bidx)+c;\\n                    C.insert(row);\\n                    C.insert(col);\\n                    C.insert(block);\\n                }\\n            }\\n        }\\n        return C.size()==3*n;\\n    }\\n};\\n```\\nNext step is to use backtracking solving it!\\n[https://youtu.be/_B8ihi2SVSU](https://youtu.be/_B8ihi2SVSU)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bitset<9> Col[9];\\n        bitset<9> Row[9];\\n        bitset<9> Block[9];\\n\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c == \\'.\\') continue;\\n                int x=(c-\\'0\\')%9; \\n                // Convert the character digit to an index (0-8) 0 for 9\\n\\n                if (Row[i][x]) return 0;\\n                Row[i][x] = 1;\\n\\n                if (Col[j][x]) return 0;\\n                Col[j][x] = 1;\\n                \\n                int bidx = (i / 3) * 3 + j / 3;\\n                if (Block[bidx][x]) return 0;\\n                Block[bidx][x] = 1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\n```C []\\nbool isValidSudoku(char** board, int boardSize, int* boardColSize)\\n{\\n    bool Col[9][9]={0};\\n    bool Row[9][9]={0};\\n    bool Block[9][9]={0};\\n\\n    for(int i=0; i<9; i++){\\n        for(int j=0; j<9; j++){\\n            char c = board[i][j];\\n            if (c == \\'.\\') continue;\\n            int x=(c-\\'0\\')%9; \\n            // Convert the character digit to an index (0-8) 0 for 9\\n\\n            if (Row[i][x]==1) return 0;\\n            Row[i][x] = 1;\\n\\n            if (Col[j][x]==1) return 0;\\n            Col[j][x] = 1;\\n                \\n            int bidx = (i / 3) * 3 + j / 3;\\n            if (Block[bidx][x]==1) return 0;\\n            Block[bidx][x] = 1;\\n        }\\n    }\\n    return 1;\\n}\\n```\n```Python []\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        # Use sets\\n        Col = [set() for _ in range(9)]\\n        Row = [set() for _ in range(9)]\\n        Block = [set() for _ in range(9)]\\n\\n        for i in range(9):\\n            for j in range(9):\\n                c=board[i][j]\\n                if c==\\'.\\': continue\\n                x=(ord(c)-ord(\\'0\\'))%9\\n\\n                if x in Row[i]: return False\\n                Row[i].add(x)\\n\\n                if x in Col[j]: return False\\n                Col[j].add(x)\\n\\n                idx=i//3*3+j//3\\n                if x in Block[idx]: return False\\n                Block[idx].add(x)\\n        return True\\'\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> C;\\n        int n=0;\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                char c = board[i][j];\\n                if (c != \\'.\\') {\\n                    n++;\\n                    string row=\"row\"+to_string(i)+c;\\n                    string col=\"col\"+to_string(j)+c;\\n                    int bidx = (i / 3) * 3 + j / 3;\\n                    string block=\"block\"+to_string(bidx)+c;\\n                    C.insert(row);\\n                    C.insert(col);\\n                    C.insert(block);\\n                }\\n            }\\n        }\\n        return C.size()==3*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324188,
                "title": "powerful-logic-with-two-method",
                "content": "\\n\\n# 1. Without Hashtable Approach\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def valid(arr):\\n            s=\\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s)==len(set(s))\\n        def checkrow():\\n            for row in board:\\n                if not valid(row):\\n                    return False\\n            return True\\n        def checkcol():\\n            for col in zip(*board):\\n                if not valid(col):\\n                    return False\\n            return True\\n        def square():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    nums=[board[r+i][c+j] for i in range(3) for j in range(3)]\\n                    if not valid(nums):\\n                        return False\\n            return True\\n        return checkrow() and checkcol() and square()\\n\\n//please upvote me it would encourage me alot\\n\\n```\\n\\n# 2.With Hashtable Approach\\n```\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row=defaultdict(set)\\n        col=defaultdict(set)\\n        square=defaultdict(set)\\n        for r in range(9):\\n            for c in range(9):\\n                x=board[r][c]\\n                if board[r][c]==\".\":\\n                    continue\\n                if x in row[r] or x in col[c] or x in square[(r//3,c//3)]:\\n                    return False\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                square[(r//3,c//3)].add(board[r][c])\\n        return True\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def valid(arr):\\n            s=\\'\\'.join(arr).replace(\\'.\\',\\'\\')\\n            return len(s)==len(set(s))\\n        def checkrow():\\n            for row in board:\\n                if not valid(row):\\n                    return False\\n            return True\\n        def checkcol():\\n            for col in zip(*board):\\n                if not valid(col):\\n                    return False\\n            return True\\n        def square():\\n            for r in range(0,9,3):\\n                for c in range(0,9,3):\\n                    nums=[board[r+i][c+j] for i in range(3) for j in range(3)]\\n                    if not valid(nums):\\n                        return False\\n            return True\\n        return checkrow() and checkcol() and square()\\n\\n//please upvote me it would encourage me alot\\n\\n```\n```\\n\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        row=defaultdict(set)\\n        col=defaultdict(set)\\n        square=defaultdict(set)\\n        for r in range(9):\\n            for c in range(9):\\n                x=board[r][c]\\n                if board[r][c]==\".\":\\n                    continue\\n                if x in row[r] or x in col[c] or x in square[(r//3,c//3)]:\\n                    return False\\n                row[r].add(board[r][c])\\n                col[c].add(board[r][c])\\n                square[(r//3,c//3)].add(board[r][c])\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079159,
                "title": "javascript-99-4-fast-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/yaMicoAZsrI\\n\\n# Code\\n```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    \\n    for(let i =0; i<board.length;i++){\\n        let rowMap = {}\\n        let colMap = {}\\n        let boxMap = {}\\n        for(let j=0; j<board[i].length;j++){\\n\\n            let box = board[3* Math.floor(i/3) +Math.floor(j/3)][3*(i%3)+(j%3)]\\n            \\n            if(board[i][j] != \\'.\\'){\\n                if(rowMap[board[i][j]]) return false;\\n                rowMap[board[i][j]] = 1;\\n            }\\n            if(board[j][i] != \\'.\\') {\\n                if(colMap[board[j][i]]) return false;\\n                colMap[board[j][i]] = 1;\\n            }\\n            if(box!= \\'.\\'){\\n                if(boxMap[box]) return false;\\n                boxMap[box] = 1;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {boolean}\\n */\\nvar isValidSudoku = function(board) {\\n    \\n    for(let i =0; i<board.length;i++){\\n        let rowMap = {}\\n        let colMap = {}\\n        let boxMap = {}\\n        for(let j=0; j<board[i].length;j++){\\n\\n            let box = board[3* Math.floor(i/3) +Math.floor(j/3)][3*(i%3)+(j%3)]\\n            \\n            if(board[i][j] != \\'.\\'){\\n                if(rowMap[board[i][j]]) return false;\\n                rowMap[board[i][j]] = 1;\\n            }\\n            if(board[j][i] != \\'.\\') {\\n                if(colMap[board[j][i]]) return false;\\n                colMap[board[j][i]] = 1;\\n            }\\n            if(box!= \\'.\\'){\\n                if(boxMap[box]) return false;\\n                boxMap[box] = 1;\\n            }\\n        }\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3005232,
                "title": "single-pass-python-solution-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial approach was to traverse the sudoku 3 times and check for row satisfiability in first pass, column satisfiability in second pass and sub-box satisfiability in third pass. However, we could design an approach with an extra space to optimize this and check for all conditions in a single pass of the sudoku.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare an defaultdict(taking set as the default_factory). Iterate the Sudoku and check if the number exists in our defaultdict for row, column and sub-box condition with the help of keys (discussed below). If it is not present at all 3 keys, add the number in the 3 locations. If it is present, return False as it is not a valid Sudoku.\\nIf we successfully traverse the Sudoku without encountering a single instance where number is already present in the defaultdict, it means it is a valid Sudoku so return True.\\n\\n# Keys:\\n**i** : For Row i.e. defaultdict[i] will have the numbers in i\\'th row.\\n**j+9**: For Column i.e. defaultdict[j+9] will have numbers in the j\\'th column. 9 added to avoid clash with keys of rows.\\n**(i//3,j//3)**: For Sub-box condition, as the key represent\\'s the sub box in which the element of (i\\'th row,j\\'th column) exists.\\n\\n# Complexity\\n- Time complexity: O(N^2) [Basically Single pass over the Sudoku. ]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) [A dictionary of 27 keys and each having a set as the value to store the numbers].\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n***Please Like the Solution if you understood it***.\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        checker = defaultdict(set)\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j]==\".\":\\n                    continue\\n\\n                box = (i//3,j//3)\\n                if board[i][j] in checker[i] or board[i][j] in checker[j+9] or board[i][j] in checker[box]:\\n                    return False\\n                else:\\n                    checker[i].add(board[i][j])\\n                    checker[j+9].add(board[i][j])\\n                    checker[box].add(board[i][j])\\n        #print(checker)\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        \\n        checker = defaultdict(set)\\n        for i in range(9):\\n            for j in range(9):\\n                if board[i][j]==\".\":\\n                    continue\\n\\n                box = (i//3,j//3)\\n                if board[i][j] in checker[i] or board[i][j] in checker[j+9] or board[i][j] in checker[box]:\\n                    return False\\n                else:\\n                    checker[i].add(board[i][j])\\n                    checker[j+9].add(board[i][j])\\n                    checker[box].add(board[i][j])\\n        #print(checker)\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597616,
                "title": "python3-simple-solution-using-hashset",
                "content": "Code:\\n```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        cols = collections.defaultdict(set)\\n        rows = collections.defaultdict(set)\\n        squares = collections.defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\":\\n                    continue\\n                if (board[r][c] in rows[r] or \\n                    board[r][c] in cols[c] or \\n                    board[r][c] in squares[(r//3,c//3)]):\\n                    return False\\n                cols[c].add(board[r][c])\\n                rows[r].add(board[r][c])\\n                squares[(r//3,c//3)].add(board[r][c])\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        cols = collections.defaultdict(set)\\n        rows = collections.defaultdict(set)\\n        squares = collections.defaultdict(set)\\n        \\n        for r in range(9):\\n            for c in range(9):\\n                if board[r][c] == \".\":\\n                    continue\\n                if (board[r][c] in rows[r] or \\n                    board[r][c] in cols[c] or \\n                    board[r][c] in squares[(r//3,c//3)]):\\n                    return False\\n                cols[c].add(board[r][c])\\n                rows[r].add(board[r][c])\\n                squares[(r//3,c//3)].add(board[r][c])\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457762,
                "title": "c-easy-solution-set-solution",
                "content": "Here ATQ,\\n  For Valid sudoko , we need some validation .\\n  1. No two elements should be in the same row .\\n  2. No two elements should be in the same column.\\n  3. No same should present in each 3*3  Block Matrix.\\n \\n So for that we are taking the set data structures to store and validate.\\n The main key is here for the  9block  -   3* 3 blocks  to validate.\\n For traversing in the block index becomes   (i/3)*3 + j/3;\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // using set data structure to store and validate in rows , cols  and 3*3 each blocks.\\n        \\n       vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        // using set data structure to store and validate in rows , cols  and 3*3 each blocks.\\n        \\n       vector<set<int>> rows(9), cols(9), blocks(9);\\n        \\n        for (int i = 0; i < 9; i++) {\\n            for (int j = 0; j < 9; j++) {\\n                \\n                if (board[i][j] == \\'.\\') continue;\\n                \\n                int curr = board[i][j] - \\'0\\';\\n                if (rows[i].count(curr) || cols[j].count(curr) || blocks[(i/3)*3+j/3].count(curr)) \\n                    return false;\\n                \\n                rows[i].insert(curr);\\n                cols[j].insert(curr);\\n                blocks[(i/3)*3+j/3].insert(curr);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434689,
                "title": "simple-optimal-solution-kotlin-using-string",
                "content": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n       val seen = HashSet<String>()\\n       \\n       for(i in 0 until 9){\\n           for(j in 0 until 9){\\n               var number = board[i][j]\\n               if(number != \\'.\\'){\\n                   if(!seen.add(\"$number in row $i\") ||\\n                      !seen.add(\"$number in column $j\") ||\\n                      !seen.add(\"$number in block ${i/3}-${j/3}\")) return false\\n                   \\n               }\\n           }\\n       }\\n       \\n       return true\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    fun isValidSudoku(board: Array<CharArray>): Boolean {\\n       val seen = HashSet<String>()\\n       \\n       for(i in 0 until 9){\\n           for(j in 0 until 9){\\n               var number = board[i][j]\\n               if(number != \\'.\\'){\\n                   if(!seen.add(\"$number in row $i\") ||\\n                      !seen.add(\"$number in column $j\") ||\\n                      !seen.add(\"$number in block ${i/3}-${j/3}\")) return false\\n                   \\n               }\\n           }\\n       }\\n       \\n       return true\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430291,
                "title": "python-91ms-faster-than-98-w-proof-easy-to-understand-readable",
                "content": "1. Initialize a set\\n2. Traverse through the cells one by one and add them to set with proper names for example,\\n\\t1. If `3` is in `board[0][1]`, then add these three keys to the set\\n\\t2. `3 in row 0`\\n\\t3. `3 in col 1`\\n\\t4. `3 in box 0`\\n3. If the key already exists in the set, then return False\\n\\n```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\ts = set()\\n\\n\\tfor i in range(9):\\n\\t\\tfor j in range(9):\\n\\t\\t\\tif board[i][j] != \\'.\\':\\n\\t\\t\\t\\tc = board[i][j]\\n\\n\\t\\t\\t\\t# Row check\\n\\t\\t\\t\\tkey = f\\'{c} in row {i}\\' # same as -> str(c) + \\' in row \\' + str(i)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Column check\\n\\t\\t\\t\\tkey = f\\'{c} in col {j}\\' # same as -> str(c) + \\' in col \\' + str(j)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Box check\\n\\t\\t\\t\\tboxIndex = (i // 3) * 3 + (j // 3)\\n\\t\\t\\t\\tkey = f\\'{c} in box {boxIndex}\\' # same as -> str(c) + \\' in box \\' + str(boxIndex)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key) \\n\\n\\treturn True\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6a37c991-15e9-4c82-915d-81f86191a795_1660582920.076614.png)\\n\\n![image](https://assets.leetcode.com/users/images/ae445c1c-9ed7-447e-bb74-134e7cd36e35_1660753850.275268.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\ts = set()\\n\\n\\tfor i in range(9):\\n\\t\\tfor j in range(9):\\n\\t\\t\\tif board[i][j] != \\'.\\':\\n\\t\\t\\t\\tc = board[i][j]\\n\\n\\t\\t\\t\\t# Row check\\n\\t\\t\\t\\tkey = f\\'{c} in row {i}\\' # same as -> str(c) + \\' in row \\' + str(i)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Column check\\n\\t\\t\\t\\tkey = f\\'{c} in col {j}\\' # same as -> str(c) + \\' in col \\' + str(j)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key)\\n\\n\\t\\t\\t\\t# Box check\\n\\t\\t\\t\\tboxIndex = (i // 3) * 3 + (j // 3)\\n\\t\\t\\t\\tkey = f\\'{c} in box {boxIndex}\\' # same as -> str(c) + \\' in box \\' + str(boxIndex)\\n\\n\\t\\t\\t\\tif key in s:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts.add(key) \\n\\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2374430,
                "title": "simple-java-0ms-100-faster-solution",
                "content": "**Java \\u2705 || 0ms || 100% faster Solution**\\n\\n**Please  \\uD83D\\uDC4D this.solution if(you understood == true)**\\n\\n```\\n// Best Approach : HashSet\\n// Time Complexity : O(n2)\\n// Space Complexity : O(n2)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set set = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != \\'.\\') {\\n                    String el = \"[\" + board[i][j] + \"]\";\\n                    if (!set.add(el + i) || !set.add(j + el) || !set.add(i/3 + el + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n// Best Approach : HashSet\\n// Time Complexity : O(n2)\\n// Space Complexity : O(n2)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        Set set = new HashSet();\\n        for (int i=0; i<9; ++i) {\\n            for (int j=0; j<9; ++j) {\\n                if (board[i][j] != \\'.\\') {\\n                    String el = \"[\" + board[i][j] + \"]\";\\n                    if (!set.add(el + i) || !set.add(j + el) || !set.add(i/3 + el + j/3))\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2287201,
                "title": "rust-simple-hashset-0ms",
                "content": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let mut row_set = HashSet::new();\\n        let mut col_set = HashSet::new();\\n        let mut sub_box_sets = vec![HashSet::new(); 9];\\n        \\n        for r in 0..9 {\\n            for c in 0..9 {\\n                if let Some(digit) = board[r][c].to_digit(10) {\\n\\t\\t\\t\\t\\t// Has this combination of row number r and digit already been encountered?\\n                    if !row_set.insert((r, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Has this combination of column number c and digit already been encountered?\\n                    if !col_set.insert((c, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Iterator math to determine which of the 9 sub boxes the current board[r][c] is in. \\n\\t\\t\\t\\t\\t// Has it already been encountered?\\n                    if !sub_box_sets[3 * (r/3) + c/3].insert(digit) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool {\\n        let mut row_set = HashSet::new();\\n        let mut col_set = HashSet::new();\\n        let mut sub_box_sets = vec![HashSet::new(); 9];\\n        \\n        for r in 0..9 {\\n            for c in 0..9 {\\n                if let Some(digit) = board[r][c].to_digit(10) {\\n\\t\\t\\t\\t\\t// Has this combination of row number r and digit already been encountered?\\n                    if !row_set.insert((r, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Has this combination of column number c and digit already been encountered?\\n                    if !col_set.insert((c, digit)) {\\n                        return false;\\n                    }\\n\\t\\t\\t\\t\\t// Iterator math to determine which of the 9 sub boxes the current board[r][c] is in. \\n\\t\\t\\t\\t\\t// Has it already been encountered?\\n                    if !sub_box_sets[3 * (r/3) + c/3].insert(digit) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745150,
                "title": "c-simple-and-easy-hashset",
                "content": "For each row, column and block we keep a set of characters.\\nIf we find the char again while inserting we return a false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\n        vector<set<char>> row(9), col(9), block(9); // each char set for checking every row coloumn and block\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    char c = board[i][j];\\n                    if(!row[j].insert(c).second or !col[i].insert(c).second or !block[(i/3)*3 + j/3].insert(c).second) \\n\\t\\t\\t\\t\\t\\treturn false;\\n/* checking while inserting in the set\\t\\t\\t\\t\\t\\t\\n   An insert operation on a set returns a pair, with its member first set to an iterator pointing\\n   to either the newly inserted element or to the equivalent element already in the set. \\n   The second element in the pair is set to true if a new element was inserted or false if an equivalent element already existed.*/\\t\\t\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\nFor block[(i/3)*3 + j/3] \\nWe have to map each 3x3 boxes, and label the boxes like this:\\n\\n0 1 2\\n3 4 5\\n6 7 8\\n\\nSo we have boxIndex as  r/3*3 +c/3\\nDo a dry run you will get to know easily.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\n        vector<set<char>> row(9), col(9), block(9); // each char set for checking every row coloumn and block\\n        \\n        for(int i = 0; i < 9; i++) {\\n            for(int j = 0; j < 9; j++) {\\n                if(board[i][j] != \\'.\\') {\\n                    char c = board[i][j];\\n                    if(!row[j].insert(c).second or !col[i].insert(c).second or !block[(i/3)*3 + j/3].insert(c).second) \\n\\t\\t\\t\\t\\t\\treturn false;\\n/* checking while inserting in the set\\t\\t\\t\\t\\t\\t\\n   An insert operation on a set returns a pair, with its member first set to an iterator pointing\\n   to either the newly inserted element or to the equivalent element already in the set. \\n   The second element in the pair is set to true if a new element was inserted or false if an equivalent element already existed.*/\\t\\t\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706655,
                "title": "o-1-time-complexity-using-set-with-comments",
                "content": "```\\nclass Solution {\\n    /*in this we have to check 3 things\\n    1:-that each number should be unique in the colum\\n    2:- each number should be unique in th row\\n    3:- each number should be unique in the box\\n   steps:-\\n   \\n   1:-we will make set of string type\\n   2:- then we will make 3 string row,colum,box\\n   3:-and we will make the string in this way like:-\\n   \\n   row = row+number(board[i][j])+i;\\n   colum = colum+number+j;\\n   and to get the which in which box it belongs we have one formula\\n   int Box=((i/3)*3+(j/3));\\n   and every itration row colum will change accordingly string will also change .\\n   \\n   so if supppose we have string like:-\\n   row+number+i = row5 abd the row is 3\\n   row+number+i = row5 and the row is 3\\n   then it will give false same for colum and box;\\n   \\n   4:- if(box[i][j]!=\\'.\\') then only we have to chck\\n   \\n   5:- now check if have the string then return false;\\n   \\n   6:- otherwise add into the set.\\n   */\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n         unordered_set<string>u;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                string row=\"\";\\n                row+=\"row\";\\n                row+=board[i][j];\\n                row+=i;\\n                \\n                string colum=\"\";\\n                colum+=\"colum\";\\n                colum+=board[i][j];\\n                colum+=j;\\n                \\n                int Box=((i/3)*3+(j/3));\\n                string box=\"\";\\n                box+=\"box\";\\n                box+=board[i][j];\\n                box+=Box;\\n                if(board[i][j]!=\\'.\\')\\n                if(u.count(row) || u.count(colum) ||u.count(box))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    u.insert(row);\\n                    u.insert(colum);\\n                    u.insert(box);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```\\n\\n**PLEASE LET ME KNOW IF ANY SUGGESTION OR DOUBTS**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    /*in this we have to check 3 things\\n    1:-that each number should be unique in the colum\\n    2:- each number should be unique in th row\\n    3:- each number should be unique in the box\\n   steps:-\\n   \\n   1:-we will make set of string type\\n   2:- then we will make 3 string row,colum,box\\n   3:-and we will make the string in this way like:-\\n   \\n   row = row+number(board[i][j])+i;\\n   colum = colum+number+j;\\n   and to get the which in which box it belongs we have one formula\\n   int Box=((i/3)*3+(j/3));\\n   and every itration row colum will change accordingly string will also change .\\n   \\n   so if supppose we have string like:-\\n   row+number+i = row5 abd the row is 3\\n   row+number+i = row5 and the row is 3\\n   then it will give false same for colum and box;\\n   \\n   4:- if(box[i][j]!=\\'.\\') then only we have to chck\\n   \\n   5:- now check if have the string then return false;\\n   \\n   6:- otherwise add into the set.\\n   */\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n         unordered_set<string>u;\\n        for(int i=0;i<9;i++)\\n        {\\n            for(int j=0;j<9;j++)\\n            {\\n                string row=\"\";\\n                row+=\"row\";\\n                row+=board[i][j];\\n                row+=i;\\n                \\n                string colum=\"\";\\n                colum+=\"colum\";\\n                colum+=board[i][j];\\n                colum+=j;\\n                \\n                int Box=((i/3)*3+(j/3));\\n                string box=\"\";\\n                box+=\"box\";\\n                box+=board[i][j];\\n                box+=Box;\\n                if(board[i][j]!=\\'.\\')\\n                if(u.count(row) || u.count(colum) ||u.count(box))\\n                {\\n                    return false;\\n                }\\n                else\\n                {\\n                    u.insert(row);\\n                    u.insert(colum);\\n                    u.insert(box);\\n                }\\n                \\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493936,
                "title": "c-easy-solution-using-hashmap-runtime-32-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int N = board.size();\\n        unordered_set<char>rowset[N],colset[N],boxset[N];\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int boxno = (i/3)*3+(j/3);\\n                char val = board[i][j];\\n                if(val==\\'.\\')\\n                    continue;\\n                if(rowset[i].count(val) || colset[j].count(val) || boxset[boxno].count(val))\\n                    return false;\\n                rowset[i].insert(val);\\n                colset[j].insert(val);\\n                boxset[boxno].insert(val);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n*Please feel free to ask in the comments if you were not able to grasp anything from this solution*\\n**Happy Coding\\uD83D\\uDE07**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int N = board.size();\\n        unordered_set<char>rowset[N],colset[N],boxset[N];\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int boxno = (i/3)*3+(j/3);\\n                char val = board[i][j];\\n                if(val==\\'.\\')\\n                    continue;\\n                if(rowset[i].count(val) || colset[j].count(val) || boxset[boxno].count(val))\\n                    return false;\\n                rowset[i].insert(val);\\n                colset[j].insert(val);\\n                boxset[boxno].insert(val);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416689,
                "title": "c-3-approaches-with-diagrams",
                "content": "```\\n//Approach-1 (Naive and simplest using 3 iterations of the sudoku)\\nclass Solution {\\npublic:\\n    bool validSub(vector<vector<char>>& board, int sr, int er, int sc, int ec) {\\n        unordered_set<char> st;\\n        for(int row = sr; row<=er; row++) {\\n            for(int col = sc; col <= ec; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //validate rows\\n        for(int row = 0; row<9; row++) {\\n            unordered_set<char> st;\\n            for(int col = 0; col <9; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n        //validate columns\\n        for(int col = 0; col<9; col++) {\\n            unordered_set<char> st;\\n            for(int row = 0; row <9; row++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n\\t\\t//validate ech 3*3 box\\n\\t\\t/*\\n\\t\\t\\tsr = start row\\n\\t\\t\\ter = end row\\n\\t\\t\\tsc = start column\\n\\t\\t\\tec = end column\\n\\t\\t*/\\n        for(int sr = 0; sr < 9; sr+=3) {\\n            int er = sr+2;\\n            for(int sc = 0; sc < 9; sc+=3) {\\n                int ec = sc+2;\\n                if(!validSub(board, sr, er, sc, ec))\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (One iteration using hashmap and indexing boxes)\\n//see the diagrma below to understand the indexing of the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> st;\\n        \\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                string row = string(1, board[i][j]) + \"_row_\" + to_string(i);\\n                string col = string(1, board[i][j]) + \"_col_\" + to_string(j);\\n                string box = string(1, board[i][j]) + \"_box_\" + to_string(i/3) + \"_\" + to_string(j/3);\\n                if(st.count(row) || st.count(col) || st.count(box)) return false;\\n                st.insert(row);\\n                st.insert(col);\\n                st.insert(box);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nDiagram for approach-2 :\\n![image](https://assets.leetcode.com/users/images/57d3cdd5-96a8-4e92-a247-0cf704cd6975_1629523773.4062777.jpeg)\\n\\n\\n```\\n//Approach-3 (Assigning a number to each box)\\n//see the diagrma below to understand how I have numbered the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool row[9][9] = {0};\\n        bool col[9][9] = {0};\\n        bool box[9][9] = {0};\\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                int digit     = board[i][j] - \\'0\\' - 1; //(-1 to avoid overflow in index)\\n                \\n                //we have numbered 9 boxes of (3*3) as 0, 1, 2, 3, 4 ... 9 (see the diagram below)\\n                int boxIndex  = (i/3)*3 + (j/3);\\n                \\n                if(row[i][digit] || col[j][digit] || box[boxIndex][digit]) return false;\\n                row[i][digit]        = true;\\n                col[j][digit]        = true;\\n                box[boxIndex][digit] = true;\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n//YouTube : https://www.youtube.com/watch?v=dGZjzA9zLW8\\n```\\n\\nDiagram for approach-2 :\\n![image](https://assets.leetcode.com/users/images/9feb7938-89d9-4bfe-a336-177037ebdf04_1629523884.2286322.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Naive and simplest using 3 iterations of the sudoku)\\nclass Solution {\\npublic:\\n    bool validSub(vector<vector<char>>& board, int sr, int er, int sc, int ec) {\\n        unordered_set<char> st;\\n        for(int row = sr; row<=er; row++) {\\n            for(int col = sc; col <= ec; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        //validate rows\\n        for(int row = 0; row<9; row++) {\\n            unordered_set<char> st;\\n            for(int col = 0; col <9; col++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n        //validate columns\\n        for(int col = 0; col<9; col++) {\\n            unordered_set<char> st;\\n            for(int row = 0; row <9; row++) {\\n                char ch = board[row][col];\\n                if(ch == \\'.\\') continue;\\n                if(st.count(ch)) return false;\\n                st.insert(ch);\\n            }\\n        }\\n        \\n\\t\\t//validate ech 3*3 box\\n\\t\\t/*\\n\\t\\t\\tsr = start row\\n\\t\\t\\ter = end row\\n\\t\\t\\tsc = start column\\n\\t\\t\\tec = end column\\n\\t\\t*/\\n        for(int sr = 0; sr < 9; sr+=3) {\\n            int er = sr+2;\\n            for(int sc = 0; sc < 9; sc+=3) {\\n                int ec = sc+2;\\n                if(!validSub(board, sr, er, sc, ec))\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\n//Approach-2 (One iteration using hashmap and indexing boxes)\\n//see the diagrma below to understand the indexing of the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        unordered_set<string> st;\\n        \\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                string row = string(1, board[i][j]) + \"_row_\" + to_string(i);\\n                string col = string(1, board[i][j]) + \"_col_\" + to_string(j);\\n                string box = string(1, board[i][j]) + \"_box_\" + to_string(i/3) + \"_\" + to_string(j/3);\\n                if(st.count(row) || st.count(col) || st.count(box)) return false;\\n                st.insert(row);\\n                st.insert(col);\\n                st.insert(box);\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\n```\\n//Approach-3 (Assigning a number to each box)\\n//see the diagrma below to understand how I have numbered the boxes\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool row[9][9] = {0};\\n        bool col[9][9] = {0};\\n        bool box[9][9] = {0};\\n        for(int i = 0; i<9; i++) {\\n            for(int j = 0; j<9; j++) {\\n                if(board[i][j] == \\'.\\') continue;\\n                \\n                int digit     = board[i][j] - \\'0\\' - 1; //(-1 to avoid overflow in index)\\n                \\n                //we have numbered 9 boxes of (3*3) as 0, 1, 2, 3, 4 ... 9 (see the diagram below)\\n                int boxIndex  = (i/3)*3 + (j/3);\\n                \\n                if(row[i][digit] || col[j][digit] || box[boxIndex][digit]) return false;\\n                row[i][digit]        = true;\\n                col[j][digit]        = true;\\n                box[boxIndex][digit] = true;\\n                \\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n//YouTube : https://www.youtube.com/watch?v=dGZjzA9zLW8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1261934,
                "title": "rust-solution-using-three-1-d-arrays-with-bit-manipulation-instead-of-hashset",
                "content": "Normally, simplest approach here would be to instantiate 9 HashSets for Rows, Columns, and Boxes to check for duplicate entries - but it is very wasteful. Instead, we could simply use an array and represent values as bits which span from 1 to 9. Thus, it is possible to represent all in `u16` type.\\n\\n```rust\\nimpl Solution \\n{\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool \\n    {\\n        let mut rows: [u16; 9] = [0; 9];\\n        let mut cols: [u16; 9] = [0; 9];\\n        let mut boxes: [u16; 9] = [0; 9];\\n        \\n        for i in 0..9 {\\n            for j in 0..9 {\\n                match board[i][j] \\n                {\\n                    \\'.\\' => continue,\\n                    c => {\\n                        let b: usize = (i / 3) * 3 + (j / 3);\\n                        let curr = 1 << (c.to_digit(10).unwrap());\\n                        \\n                        if rows[i] & curr != 0 || cols[j] & curr != 0 || boxes[b] & curr != 0 {\\n                            return false;\\n                        }\\n    \\n                        rows[i] |= curr;\\n                        cols[j] |= curr;\\n                        boxes[b] |= curr;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```rust\\nimpl Solution \\n{\\n    pub fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool \\n    {\\n        let mut rows: [u16; 9] = [0; 9];\\n        let mut cols: [u16; 9] = [0; 9];\\n        let mut boxes: [u16; 9] = [0; 9];\\n        \\n        for i in 0..9 {\\n            for j in 0..9 {\\n                match board[i][j] \\n                {\\n                    \\'.\\' => continue,\\n                    c => {\\n                        let b: usize = (i / 3) * 3 + (j / 3);\\n                        let curr = 1 << (c.to_digit(10).unwrap());\\n                        \\n                        if rows[i] & curr != 0 || cols[j] & curr != 0 || boxes[b] & curr != 0 {\\n                            return false;\\n                        }\\n    \\n                        rows[i] |= curr;\\n                        cols[j] |= curr;\\n                        boxes[b] |= curr;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788607,
                "title": "swift-simple-sweet-for-100-complexity",
                "content": "Time; O(n), Space: O(n) where n is 81. In other words, it is **O(1)** for both\\n```\\nfunc isValidSudoku(_ board: [[Character]]) -> Bool {\\n\\tvar set = Set<String>()\\n\\n\\tfor row in 0..<9 {\\n\\t\\tfor col in 0..<9 {\\n\\t\\t\\tlet char = board[row][col]\\n\\t\\t\\tif char != \".\" {\\n\\t\\t\\t\\tlet num = char.wholeNumberValue!\\n\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row)(\\\\(num))\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"(\\\\(num))\\\\(col)\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row/3)(\\\\(num))\\\\(col/3)\").0 { return false }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidSudoku(_ board: [[Character]]) -> Bool {\\n\\tvar set = Set<String>()\\n\\n\\tfor row in 0..<9 {\\n\\t\\tfor col in 0..<9 {\\n\\t\\t\\tlet char = board[row][col]\\n\\t\\t\\tif char != \".\" {\\n\\t\\t\\t\\tlet num = char.wholeNumberValue!\\n\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row)(\\\\(num))\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"(\\\\(num))\\\\(col)\").0 { return false }\\n\\t\\t\\t\\tif !set.insert(\"\\\\(row/3)(\\\\(num))\\\\(col/3)\").0 { return false }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310692,
                "title": "java-o-2-beats-100",
                "content": "Rule 1 and 2 are trivial, rule 3 a little bit tricky. We use division to get whole part. Lets say we have item [3][5], so it will be 3* (3/3) + 5/3 = 3 + 1 = 4 hence it will be block 4 (overall there are 9 blocks with indicies from 0 to 8). I used 10 iteams instead of 9 just to avoid -1 every time since java indicies start with 0.\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] rule1 = new boolean[9][10];\\n        boolean[][] rule2 = new boolean[9][10];\\n        boolean[][] rule3 = new boolean[9][10];\\n        for(int i=0; i<9; ++i) {\\n            for(int j=0; j<9; j++) {\\n                char digit = board[i][j];\\n\\n                if (digit != \\'.\\') {\\n                    int idx3 = 3 * (i / 3) + j / 3;\\n                    // convert char to int \\'0\\' -> 0\\n                    digit -= \\'0\\';\\n                    if (rule1[j][digit] || rule2[i][digit] || rule3[idx3][digit]) {\\n                        return false;\\n                    }\\n                    rule1[j][digit] = true;\\n                    rule2[i][digit] = true;\\n                    rule3[idx3][digit] = true; \\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        boolean[][] rule1 = new boolean[9][10];\\n        boolean[][] rule2 = new boolean[9][10];\\n        boolean[][] rule3 = new boolean[9][10];\\n        for(int i=0; i<9; ++i) {\\n            for(int j=0; j<9; j++) {\\n                char digit = board[i][j];\\n\\n                if (digit != \\'.\\') {\\n                    int idx3 = 3 * (i / 3) + j / 3;\\n                    // convert char to int \\'0\\' -> 0\\n                    digit -= \\'0\\';\\n                    if (rule1[j][digit] || rule2[i][digit] || rule3[idx3][digit]) {\\n                        return false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 240709,
                "title": "simple-c-code",
                "content": "```\\nbool isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n    char tmpR[9][9] = {0};\\n    char tmpC[9][9] = {0};\\n    char tmpI[9][9] = {0};\\n    int num;\\n    int index;\\n    for(int i = 0 ; i < 9;++i){\\n        for(int j = 0; j < 9; ++j){\\n            if(board[i][j] == \\'.\\'){\\n                continue;\\n            }\\n            num = board[i][j] - \\'1\\';\\n            index = (i/3)*3 + j/3;\\n            if(tmpR[i][num]|tmpC[j][num]|tmpI[index][num]){\\n                return false;\\n            }\\n            tmpR[i][num] = tmpC[j][num] = tmpI[index][num] = 1;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isValidSudoku(char** board, int boardRowSize, int boardColSize) {\\n    char tmpR[9][9] = {0};\\n    char tmpC[9][9] = {0};\\n    char tmpI[9][9] = {0};\\n    int num;\\n    int index;\\n    for(int i = 0 ; i < 9;++i){\\n        for(int j = 0; j < 9; ++j){\\n            if(board[i][j] == \\'.\\'){\\n                continue;\\n            }\\n            num = board[i][j] - \\'1\\';\\n            index = (i/3)*3 + j/3;\\n            if(tmpR[i][num]|tmpC[j][num]|tmpI[index][num]){\\n                return false;\\n            }\\n            tmpR[i][num] = tmpC[j][num] = tmpI[index][num] = 1;\\n        }\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196923,
                "title": "java-beat-97-code",
                "content": "\\u6C42\\u70B9\\u8D5E\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] map_row = new boolean[10][10];\\n        boolean[][] map_col = new boolean[10][10];       \\n        //check row and col\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    if(map_row[i][num]) return false;\\n                    map_row[i][num] = true;\\n                    if(map_col[num][j]) return false;\\n                    map_col[num][j] = true;\\n                }\\n            }\\n        }\\n        \\n        //check 3*3\\n        for(int i=0; i<9; i= i+3){\\n            for(int j=0; j<9; j=j+3) {\\n                boolean[] map = new boolean[10];\\n                for(int k=0; k<3; k++){\\n                    for(int t=0; t<3; t++){\\n                        int num = board[k+i][t+j] - \\'0\\';\\n                        if(board[k+i][t+j] != \\'.\\'){\\n                            if(map[num]) return false;\\n                            map[num] = true;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n     return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        boolean[][] map_row = new boolean[10][10];\\n        boolean[][] map_col = new boolean[10][10];       \\n        //check row and col\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int num = board[i][j] - \\'0\\';\\n                    if(map_row[i][num]) return false;\\n                    map_row[i][num] = true;\\n                    if(map_col[num][j]) return false;\\n                    map_col[num][j] = true;\\n                }\\n            }\\n        }\\n        \\n        //check 3*3\\n        for(int i=0; i<9; i= i+3){\\n            for(int j=0; j<9; j=j+3) {\\n                boolean[] map = new boolean[10];\\n                for(int k=0; k<3; k++){\\n                    for(int t=0; t<3; t++){\\n                        int num = board[k+i][t+j] - \\'0\\';\\n                        if(board[k+i][t+j] != \\'.\\'){\\n                            if(map[num]) return false;\\n                            map[num] = true;\\n                        }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175187,
                "title": "beats-77-java-with-explanations",
                "content": "**Logic**\\nA valid Sudoku should satisfy 3 requirements. For each requirement, we go through the whole grid once.\\n**Thought**\\nThe bottleneck of the Brute Force approach described above is that we traverse the grid 3 times. Could we do better?\\nWe could do row-validation and column-validation together within one traversal. That reduces the time complexity from O(3n) to O(2n) - n is the number of cells in the board (9 x 9 in this case).\\nAs for the validation on sub-boxes, it\\'s tricky to do with multi-level for-loops. If we regard a sub-box as a whole, there are 3 x 3 sub-boxes. Then we focus on the cells within a sub-box. \\n\\n**Code**\\n```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<Character> rowSet = new HashSet<>(); // Helper set to check duplicates of one row.\\n        Set<Character> colSet = new HashSet<>(); // Helper set to check duplicates of one column.\\n        Set<Character> boxSet = new HashSet<>(); // Helper set to check duplicates of one 3x3 sub-box.\\n        \\n        // Check for row and column (together).\\n        for (int i = 0; i < 9; i++) {\\n            rowSet.clear();\\n            colSet.clear();\\n            for (int j = 0; j < 9; j++) {               \\n                char val = board[i][j];\\n                if (val != \\'.\\') {\\n                    if (rowSet.contains(val))\\n                        return false;\\n                    rowSet.add(val);\\n                }\\n                char symmetricVal = board[j][i];\\n                if (symmetricVal != \\'.\\') {\\n                    if (colSet.contains(symmetricVal))\\n                        return false;\\n                    colSet.add(symmetricVal);                    \\n                }\\n            }\\n        }\\n        \\n        // Check for 3x3 sub-boxes of the grid.\\n        for (int i = 0; i < 3; i++) { // Subbox row number.\\n            for (int j = 0; j < 3; j++) { // Subbox column number.\\n                boxSet.clear();\\n                for (int x = i * 3; x < i * 3 + 3; x++) { // Cell row number.\\n                    for (int y = j * 3; y < j * 3 + 3; y++) { // Cel column number.\\n                        if (board[x][y] != \\'.\\' && !boxSet.add(board[x][y])) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n           }\\n        }\\n        \\n        return true;\\n    }\\n```\\n**I appreciate your VOTE UP (\\u25B0\\u2579\\u25E1\\u2579\\u25B0)**",
                "solutionTags": [],
                "code": "```\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        Set<Character> rowSet = new HashSet<>(); // Helper set to check duplicates of one row.\\n        Set<Character> colSet = new HashSet<>(); // Helper set to check duplicates of one column.\\n        Set<Character> boxSet = new HashSet<>(); // Helper set to check duplicates of one 3x3 sub-box.\\n        \\n        // Check for row and column (together).\\n        for (int i = 0; i < 9; i++) {\\n            rowSet.clear();\\n            colSet.clear();\\n            for (int j = 0; j < 9; j++) {               \\n                char val = board[i][j];\\n                if (val != \\'.\\') {\\n                    if (rowSet.contains(val))\\n                        return false;\\n                    rowSet.add(val);\\n                }\\n                char symmetricVal = board[j][i];\\n                if (symmetricVal != \\'.\\') {\\n                    if (colSet.contains(symmetricVal))\\n                        return false;\\n                    colSet.add(symmetricVal);                    \\n                }\\n            }\\n        }\\n        \\n        // Check for 3x3 sub-boxes of the grid.\\n        for (int i = 0; i < 3; i++) { // Subbox row number.\\n            for (int j = 0; j < 3; j++) { // Subbox column number.\\n                boxSet.clear();\\n                for (int x = i * 3; x < i * 3 + 3; x++) { // Cell row number.\\n                    for (int y = j * 3; y < j * 3 + 3; y++) { // Cel column number.\\n                        if (board[x][y] != \\'.\\' && !boxSet.add(board[x][y])) {\\n                            return false;\\n                        }\\n                    }\\n                }\\n           }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576940,
                "title": "go-15-lines-using-array-100-100",
                "content": "\\n```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, columns, squares [9][9]bool\\n    for i, row := range board {\\n        for j, v := range row {\\n            if v != \\'.\\' {\\n                k := int(v)-49\\n                if rows[i][k] || columns[j][k] || squares[i/3*3 + j/3][k] {\\n                    return false\\n                }\\n                rows[i][k], columns[j][k], squares[i/3*3 + j/3][k] = true, true, true\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidSudoku(board [][]byte) bool {\\n    var rows, columns, squares [9][9]bool\\n    for i, row := range board {\\n        for j, v := range row {\\n            if v != \\'.\\' {\\n                k := int(v)-49\\n                if rows[i][k] || columns[j][k] || squares[i/3*3 + j/3][k] {\\n                    return false\\n                }\\n                rows[i][k], columns[j][k], squares[i/3*3 + j/3][k] = true, true, true\\n            }\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3545709,
                "title": "easy-intuitive-java-solution-beats-100-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n\\n        int[] res;\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[i][j]-\\'1\\']++;\\n\\n                if(res[board[i][j]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[j][i] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[j][i]-\\'1\\']++;\\n\\n                if(res[board[j][i]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0;i < 3;i++){\\n            for(int j = 0;j < 3;j++){\\n                res = new int[9];\\n                for(int p = 3*i;p < 3*i+3;p++){\\n                    for(int q = 3*j;q < 3*j+3;q++){\\n                        if(board[p][q] == \\'.\\'){\\n                            continue;\\n                        }\\n\\n                        res[board[p][q]-\\'1\\']++;\\n\\n                        if(res[board[p][q]-\\'1\\'] > 1){\\n                            return false;\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Matrix",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n\\n        int[] res;\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[i][j] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[i][j]-\\'1\\']++;\\n\\n                if(res[board[i][j]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i < 9;i++){\\n\\n            res = new int[9];\\n\\n            for(int j = 0;j < 9;j++){\\n                if(board[j][i] == \\'.\\'){\\n                    continue;\\n                }\\n\\n                res[board[j][i]-\\'1\\']++;\\n\\n                if(res[board[j][i]-\\'1\\'] > 1){\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0;i < 3;i++){\\n            for(int j = 0;j < 3;j++){\\n                res = new int[9];\\n                for(int p = 3*i;p < 3*i+3;p++){\\n                    for(int q = 3*j;q < 3*j+3;q++){\\n                        if(board[p][q] == \\'.\\'){\\n                            continue;\\n                        }\\n\\n                        res[board[p][q]-\\'1\\']++;\\n\\n                        if(res[board[p][q]-\\'1\\'] > 1){\\n                            return false;\\n                        }\\n\\n                    }\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951286,
                "title": "single-iteration-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n- O(n\\xB2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n\\xB2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        set<string> s;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    string r = \"r\" + to_string(i) +  board[i][j];\\n                    string c = \"c\" + to_string(j) +  board[i][j];\\n                    string sqr = \"sqr\" + to_string((i/3)*3 + (j/3)) +  board[i][j];\\n\\n                    if(s.find(r)==s.end() && s.find(c)==s.end() && s.find(sqr)==s.end()){\\n                        s.insert(r);\\n                        s.insert(c);\\n                        s.insert(sqr);\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        set<string> s;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(board[i][j] != \\'.\\'){\\n                    string r = \"r\" + to_string(i) +  board[i][j];\\n                    string c = \"c\" + to_string(j) +  board[i][j];\\n                    string sqr = \"sqr\" + to_string((i/3)*3 + (j/3)) +  board[i][j];\\n\\n                    if(s.find(r)==s.end() && s.find(c)==s.end() && s.find(sqr)==s.end()){\\n                        s.insert(r);\\n                        s.insert(c);\\n                        s.insert(sqr);\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843411,
                "title": "python-easy-99-73-faster-using-set",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def check(a):\\n            s=set()\\n            for i in a:\\n                if i==\\'.\\':\\n                    continue\\n                if i in s:\\n                    return False\\n                s.add(i)\\n            return True\\n        \\n        #To check each row must contain the digits 1-9 without repetition.\\n        for row in board:\\n            if not check(row):\\n                return False\\n        \\n        #To check each column must contain the digits 1-9 without repetition.\\n        for i in range(9):\\n            column=[]\\n            for j in range(9):\\n                column.append(board[j][i])\\n            if not check(column):\\n                return False\\n        \\n        #To check each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9                without repetition.\\n        for i in range(0,9,3):\\n            for j in range(0,9,3):\\n                square=[]\\n                for k in range(i,i+3):\\n                    for l in range(j,j+3):\\n                        square.append(board[k][l])\\n                if not check(square):\\n                    return False\\n        return True\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        def check(a):\\n            s=set()\\n            for i in a:\\n                if i==\\'.\\':\\n                    continue\\n                if i in s:\\n                    return False\\n                s.add(i)\\n            return True\\n        \\n        #To check each row must contain the digits 1-9 without repetition.\\n        for row in board:\\n            if not check(row):\\n                return False\\n        \\n        #To check each column must contain the digits 1-9 without repetition.\\n        for i in range(9):\\n            column=[]\\n            for j in range(9):\\n                column.append(board[j][i])\\n            if not check(column):\\n                return False\\n        \\n        #To check each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9                without repetition.\\n        for i in range(0,9,3):\\n            for j in range(0,9,3):\\n                square=[]\\n                for k in range(i,i+3):\\n                    for l in range(j,j+3):\\n                        square.append(board[k][l])\\n                if not check(square):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841718,
                "title": "c-just-check-for-everything",
                "content": "```\\n#define vb vector<bool>\\n#define vvc vector<vector<char>>\\nclass Solution {\\npublic:\\n    void hash_setter (vb &hash){\\n        for (int i = 0; i < 10; i++) hash[i] = 0;\\n    }    \\n    \\n    bool row_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[i][j] == \\'.\\') continue;\\n                if (hash[board[i][j]-\\'0\\']) return 0;\\n                \\n                hash[board[i][j]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool col_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[j][i] == \\'.\\') continue;\\n                if (hash[board[j][i]-\\'0\\']) return 0;\\n                \\n                hash[board[j][i]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool sub_box_check (vvc &board, int i, int j){\\n        vb hash (10,0);\\n        \\n        for (int k = i; k < i+3; k++){\\n            for (int l = j; l < j+3; l++){\\n                if (board[k][l] == \\'.\\') continue;\\n                if (hash[board[k][l]-\\'0\\']) return 0;\\n                \\n                hash[board[k][l]-\\'0\\'] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool sub_box_generate (vvc &board){\\n        for (int i = 0; i < 9; i+=3){\\n            for (int j = 0; j < 9; j+=3){\\n                if (sub_box_check (board, i, j) == 0) return 0;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) { \\n        if (!row_check (board) || !col_check (board) || !sub_box_generate (board)) return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define vb vector<bool>\\n#define vvc vector<vector<char>>\\nclass Solution {\\npublic:\\n    void hash_setter (vb &hash){\\n        for (int i = 0; i < 10; i++) hash[i] = 0;\\n    }    \\n    \\n    bool row_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[i][j] == \\'.\\') continue;\\n                if (hash[board[i][j]-\\'0\\']) return 0;\\n                \\n                hash[board[i][j]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool col_check (vvc &board){\\n        vb hash (10, 0);\\n        \\n        for (int i = 0; i < 9; i++){\\n            for (int j = 0; j < 9; j++){\\n                if (board[j][i] == \\'.\\') continue;\\n                if (hash[board[j][i]-\\'0\\']) return 0;\\n                \\n                hash[board[j][i]-\\'0\\'] = 1;\\n            }\\n            \\n            hash_setter (hash);\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    bool sub_box_check (vvc &board, int i, int j){\\n        vb hash (10,0);\\n        \\n        for (int k = i; k < i+3; k++){\\n            for (int l = j; l < j+3; l++){\\n                if (board[k][l] == \\'.\\') continue;\\n                if (hash[board[k][l]-\\'0\\']) return 0;\\n                \\n                hash[board[k][l]-\\'0\\'] = 1;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    bool sub_box_generate (vvc &board){\\n        for (int i = 0; i < 9; i+=3){\\n            for (int j = 0; j < 9; j+=3){\\n                if (sub_box_check (board, i, j) == 0) return 0;\\n            }\\n        }\\n        \\n        return 1;\\n    }\\n    \\n    \\n    bool isValidSudoku(vector<vector<char>>& board) { \\n        if (!row_check (board) || !col_check (board) || !sub_box_generate (board)) return 0;\\n        \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841476,
                "title": "c-bit-masking-easy-to-understand",
                "content": "# Approach 1: bitmasking\\nN.B. ```\\'1\\' & 0xf == 1```, this yields the same result as ```\\'1\\' - \\'0\\'```, but is still a neat trick to convert ASCII digits. That\\'s a trick from the times when CPUs where a lot slower and it was cheaper to do ```and``` than ```sub```.\\n\\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                // row\\n                if (rows[r] & mask) return false;\\n                rows[r] |= mask;\\n                // col\\n                if (cols[c] & mask) return false;\\n                cols[c] |= mask;\\n                // box    \\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if (boxes[box] & mask) return false;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\\n\\nMaybe a quesion of taste, but we could also write this a bit more compact:\\n\\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if ((rows[r] & mask) || (cols[c] & mask) || (boxes[box] & mask))\\n                    return false;\\n                rows[r] |= mask;\\n                cols[c] |= mask;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\\n\\nStrictly speaking we could use ```array<short, 9>``` instead of ```array<int, 9>``` or maybe even pack everything into a ```bitset<81>```.\\n\\n**Complexity Analysis**\\nThe input size is fixed, hence this is $$O(1)$$ in both cases. Is this correct?\\n  * Time complexity: $$O(1)$$.\\n  * Space complexity: $$O(1)$$.\\n\\nOTAH if we considered $$n$$ as the length of the board, i.e. 9 and assume it could grow then:\\n  * Time complexity: $$O(n^2)$$ and\\n  * Space complexity: $$O(n)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\'1\\' & 0xf == 1```\n```\\'1\\' - \\'0\\'```\n```and```\n```sub```\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                // row\\n                if (rows[r] & mask) return false;\\n                rows[r] |= mask;\\n                // col\\n                if (cols[c] & mask) return false;\\n                cols[c] |= mask;\\n                // box    \\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if (boxes[box] & mask) return false;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\n```cpp\\n    static bool isValidSudoku(const vector<vector<char>>& board) noexcept {\\n        array<int, 9> rows = {};\\n        array<int, 9> cols = {};\\n        array<int, 9> boxes = {};\\n        for (int r = 0; r < 9; ++r) {\\n            for (int c = 0; c < 9; ++c) {\\n                if (board[r][c] == \\'.\\') continue;\\n                const int mask = 1 << (board[r][c] & 0xf);\\n                const int box = (r / 3)  * 3 + (c / 3);\\n                if ((rows[r] & mask) || (cols[c] & mask) || (boxes[box] & mask))\\n                    return false;\\n                rows[r] |= mask;\\n                cols[c] |= mask;\\n                boxes[box] |= mask;\\n            }\\n        }        \\n        return true;\\n    }\\n```\n```array<short, 9>```\n```array<int, 9>```\n```bitset<81>```",
                "codeTag": "Unknown"
            },
            {
                "id": 2841425,
                "title": "java-easy-to-understand-with-comments-using-hashset-beats-100",
                "content": "*Upvote if you like the solution!!!*\\n```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<Character> Rset = new HashSet<>(); //to check repetition in rows\\n        HashSet<Character> Cset = new HashSet<>(); //to check repetition in columns\\n\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board.length;j++){\\n                if(board[i][j]==\\'.\\') continue;\\n                else {\\n                    if(!Rset.add(board[i][j])) return false;  //if same elemets are added Rset.add return false;\\n                }\\n                }\\n            Rset = new HashSet<>();  //clearing the Rset after checking for one row.\\n            }\\n        \\n\\n        for(int j=0;j<board.length;j++){\\n            for(int i=0;i<board.length;i++){\\n                if(board[i][j]==\\'.\\')continue;\\n                    else{\\n                    if(!Cset.add(board[i][j])) return false; //if same elemets are added Cset.add return false;\\n                    }\\n            }\\n            Cset = new HashSet<>();  //clearing the Cset after checking for one column.\\n        }\\n        \\n        //now the 3rd condition checking repetitions in 3x3 sub-boxes.\\n        for(int i=0;i<9;i+=3){\\n            for(int j=0;j<9;j+=3){\\n                if(!check3(i,j,board)) return false;\\n            }\\n        }\\n        \\n        //if all conditions are validated we return true.\\n        return true;\\n        }\\n    \\n    //this function checks repetition in a 3x3 matrix\\n    public boolean check3(int i,int j,char[][] board){\\n        HashSet<Character> set3 = new HashSet<>();\\n        for(int m=i;m<3+i;m++){\\n            for(int n=j;n<3+j;n++){\\n                if(board[m][n]==\\'.\\') continue;\\n                else {\\n                    if(!set3.add(board[m][n])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<Character> Rset = new HashSet<>(); //to check repetition in rows\\n        HashSet<Character> Cset = new HashSet<>(); //to check repetition in columns\\n\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board.length;j++){\\n                if(board[i][j]==\\'.\\') continue;\\n                else {\\n                    if(!Rset.add(board[i][j])) return false;  //if same elemets are added Rset.add return false;\\n                }\\n                }\\n            Rset = new HashSet<>();  //clearing the Rset after checking for one row.\\n            }\\n        \\n\\n        for(int j=0;j<board.length;j++){\\n            for(int i=0;i<board.length;i++){\\n                if(board[i][j]==\\'.\\')continue;\\n                    else{\\n                    if(!Cset.add(board[i][j])) return false; //if same elemets are added Cset.add return false;\\n                    }\\n            }\\n            Cset = new HashSet<>();  //clearing the Cset after checking for one column.\\n        }\\n        \\n        //now the 3rd condition checking repetitions in 3x3 sub-boxes.\\n        for(int i=0;i<9;i+=3){\\n            for(int j=0;j<9;j+=3){\\n                if(!check3(i,j,board)) return false;\\n            }\\n        }\\n        \\n        //if all conditions are validated we return true.\\n        return true;\\n        }\\n    \\n    //this function checks repetition in a 3x3 matrix\\n    public boolean check3(int i,int j,char[][] board){\\n        HashSet<Character> set3 = new HashSet<>();\\n        for(int m=i;m<3+i;m++){\\n            for(int n=j;n<3+j;n++){\\n                if(board[m][n]==\\'.\\') continue;\\n                else {\\n                    if(!set3.add(board[m][n])) return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840675,
                "title": "python-3-10-lines-bitmaps-t-m-95-85",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\n        row, col, hse = [0]*9, [0]*9, [0]*9\\n\\n        for i,j in product(range(9), range(9)):\\n\\n            b = board[i][j]\\n            if not b.isdigit(): continue\\n            b, ij = 1<<int(b), 3*(i//3)+j//3\\n\\n            if row[i]&b or col[j]&b or hse[ij]&b: return False\\n\\n            row[i ]|=b\\n            col[j ]|=b\\n            hse[ij]|=b\\n\\n        return True\\n```\\n[https://leetcode.com/problems/valid-sudoku/submissions/997890268/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n\\n        row, col, hse = [0]*9, [0]*9, [0]*9\\n\\n        for i,j in product(range(9), range(9)):\\n\\n            b = board[i][j]\\n            if not b.isdigit(): continue\\n            b, ij = 1<<int(b), 3*(i//3)+j//3\\n\\n            if row[i]&b or col[j]&b or hse[ij]&b: return False\\n\\n            row[i ]|=b\\n            col[j ]|=b\\n            hse[ij]|=b\\n\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291296,
                "title": "java-cleanest-code-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            String r = \\'r\\' + \"-\" + i + board[i][j];\\n            String c = \\'c\\' + \"-\" + j + board[i][j];\\n            String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n            \\n            if(!map.add(r) || !map.add(c) || !map.add(rc))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n      HashSet<String> map = new HashSet<>();\\n      for(int i = 0; i < 9; i ++) {\\n        for(int j = 0; j < 9; j ++) {\\n          if(board[i][j] != \\'.\\') {\\n            String r = \\'r\\' + \"-\" + i + board[i][j];\\n            String c = \\'c\\' + \"-\" + j + board[i][j];\\n            String rc = (i / 3) + \"-\" + board[i][j] + \"-\" + (j / 3);\\n            \\n            if(!map.add(r) || !map.add(c) || !map.add(rc))\\n              return false;\\n          }\\n        }\\n      }\\n      return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281872,
                "title": "java-in-depth-explanation-easy-to-implement",
                "content": "**Intuition**\\nBasically, we need to check three conditions:\\n\\n1. Each row must contain the digits 1-9 without repetition.\\n2. Each column must contain the digits 1-9 without repetition.\\n3. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\\n\\nIf all of them are true, then return true. Otherwise, return false.\\n\\n**Debat**\\nI personally think both time and space complexity are O(1) since we would achieve O(81) mostly because of the size of board[ ][ ]. But this could be debatable. You could talk this to your interviewer during the interview. My interviwer agrees my point by the way. \\n\\n```\\nclass Solution \\n{\\n    public boolean isValidSudoku(char[][] board)\\n    {\\n        // O(1) time | O(1) space\\n        HashSet<String> mySet = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    if(mySet.contains(\"row\" + i + board[i][j]) || mySet.contains(\"col\" + j + board[i][j]) || mySet.contains(\"box\" + i/3 + j/3 + board[i][j]))\\n                        return false;\\n                    \\n                    mySet.add(\"row\" + i + board[i][j]);\\n                    mySet.add(\"col\" + j + board[i][j]);\\n                    mySet.add(\"box\" + i/3 + j/3 + board[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean isValidSudoku(char[][] board)\\n    {\\n        // O(1) time | O(1) space\\n        HashSet<String> mySet = new HashSet<>();\\n        \\n        for(int i = 0; i < 9; i++)\\n        {\\n            for(int j = 0; j < 9; j++)\\n            {\\n                if(board[i][j] != \\'.\\')\\n                {\\n                    if(mySet.contains(\"row\" + i + board[i][j]) || mySet.contains(\"col\" + j + board[i][j]) || mySet.contains(\"box\" + i/3 + j/3 + board[i][j]))\\n                        return false;\\n                    \\n                    mySet.add(\"row\" + i + board[i][j]);\\n                    mySet.add(\"col\" + j + board[i][j]);\\n                    mySet.add(\"box\" + i/3 + j/3 + board[i][j]);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2033555,
                "title": "javascript-hashmap-solution-with-short-comment-97-12-faster",
                "content": "```\\nvar isValidSudoku = function(board) {\\n    const hash = {};\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            if(board[i][j] === \\'.\\') continue; // if current value is equal \\'.\\' , skip to next index\\n            if(hash[board[i][j]] === undefined) { \\n                const box = calculateBox(i,j);\\n                hash[board[i][j]] = [[i, j, box]]; // because the same value can be repeated, it is created as an array\\n            } \\n            else { \\n                for(let k = 0; k < hash[board[i][j]].length; k++) {  \\n                    const [row, col, box] = hash[board[i][j]][k];  // Get row, col, and box information of the same value as the current value\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// check current value is validated with sdoku rules\\n                    if(row === i || col === j) return false;  \\n                    else if(calculateBox(i,j) === box) return false;\\n                }\\n                hash[board[i][j]].push([i, j, calculateBox(i,j)]); // if it is valitated sudoku rules, push to hashmap  for example hash {\\'5\\': [ [ 2, 0, 1 ], [ 3, 3, 5 ] ] }\\n            }\\n        }\\n    }\\n    return true;\\n};\\n\\n\\nfunction calculateBox(row, col) { //calculate box number with row and col\\n return Math.floor(row/3) * 3 + Math.floor(col/3);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidSudoku = function(board) {\\n    const hash = {};\\n    \\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[i].length; j++) {\\n            if(board[i][j] === \\'.\\') continue; // if current value is equal \\'.\\' , skip to next index\\n            if(hash[board[i][j]] === undefined) { \\n                const box = calculateBox(i,j);\\n                hash[board[i][j]] = [[i, j, box]]; // because the same value can be repeated, it is created as an array\\n            } \\n            else { \\n                for(let k = 0; k < hash[board[i][j]].length; k++) {  \\n                    const [row, col, box] = hash[board[i][j]][k];  // Get row, col, and box information of the same value as the current value\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// check current value is validated with sdoku rules\\n                    if(row === i || col === j) return false;  \\n                    else if(calculateBox(i,j) === box) return false;\\n                }\\n                hash[board[i][j]].push([i, j, calculateBox(i,j)]); // if it is valitated sudoku rules, push to hashmap  for example hash {\\'5\\': [ [ 2, 0, 1 ], [ 3, 3, 5 ] ] }\\n            }\\n        }\\n    }\\n    return true;\\n};\\n\\n\\nfunction calculateBox(row, col) { //calculate box number with row and col\\n return Math.floor(row/3) * 3 + Math.floor(col/3);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1918864,
                "title": "java-easy-solution-2-lines-of-logic",
                "content": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> seen = new HashSet();\\n        \\n        for (int i =0 ; i < 9; i++) {\\n            \\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    if (!seen.add(\"row\" + i + board[i][j]) || !seen.add(\"col\" + j + board[i][j])) {\\n                        return false;\\n                    }\\n                    if (!seen.add(\"box\" + (i / 3) * 3 + j / 3 + board[i][j])) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        HashSet<String> seen = new HashSet();\\n        \\n        for (int i =0 ; i < 9; i++) {\\n            \\n            for (int j = 0; j < 9; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    if (!seen.add(\"row\" + i + board[i][j]) || !seen.add(\"col\" + j + board[i][j])) {\\n                        return false;\\n                    }\\n                    if (!seen.add(\"box\" + (i / 3) * 3 + j / 3 + board[i][j])) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822522,
                "title": "using-unordered-set-with-comments-c",
                "content": "Implementation\\n\\n**Using Unordered Set\\nTime Complexity = O(N^2)\\nSpace Complexity = O(N^2)**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // store the row index and value of that particular row index\\n        // store the col index and value of that particular col index\\n        // store the particular box index and value in the particular box index\\n        // we will store the row, col & box index and their value into this visited unordered set\\n        unordered_set<string> visited;\\n        \\n        for(int row = 0; row < 9; row++){\\n            for(int col = 0; col < 9; col++){\\n                \\n                // if the current index value is dot(.) then we don\\'t need to do anything \\n                if(board[row][col] != \\'.\\'){\\n                    \\n                    // if any particular (row index with value) or (col index with value) or (box index with value) already visited it means that is not a valid sudoku, so we will directly return false\\n                    if(visited.find(\"Row\" + to_string(row) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Col\" + to_string(col) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Box\" + to_string(((row/3) * 3 + (col/3))) + to_string(board[row][col])) != visited.end()){\\n                        return false;\\n                    }\\n                    \\n                    // if not visited yet, then add (row index & value) and (col index & value) and (box index & value) into the visited unordered set\\n                    visited.insert(\"Row\" + to_string(row) + to_string(board[row][col]));\\n                    visited.insert(\"Col\" + to_string(col) + to_string(board[row][col]));\\n                    visited.insert(\"Box\" + to_string((row/3)*3 + (col/3)) + to_string(board[row][col]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "String",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        \\n        // store the row index and value of that particular row index\\n        // store the col index and value of that particular col index\\n        // store the particular box index and value in the particular box index\\n        // we will store the row, col & box index and their value into this visited unordered set\\n        unordered_set<string> visited;\\n        \\n        for(int row = 0; row < 9; row++){\\n            for(int col = 0; col < 9; col++){\\n                \\n                // if the current index value is dot(.) then we don\\'t need to do anything \\n                if(board[row][col] != \\'.\\'){\\n                    \\n                    // if any particular (row index with value) or (col index with value) or (box index with value) already visited it means that is not a valid sudoku, so we will directly return false\\n                    if(visited.find(\"Row\" + to_string(row) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Col\" + to_string(col) + to_string(board[row][col])) != visited.end()\\n                       || visited.find(\"Box\" + to_string(((row/3) * 3 + (col/3))) + to_string(board[row][col])) != visited.end()){\\n                        return false;\\n                    }\\n                    \\n                    // if not visited yet, then add (row index & value) and (col index & value) and (box index & value) into the visited unordered set\\n                    visited.insert(\"Row\" + to_string(row) + to_string(board[row][col]));\\n                    visited.insert(\"Col\" + to_string(col) + to_string(board[row][col]));\\n                    visited.insert(\"Box\" + to_string((row/3)*3 + (col/3)) + to_string(board[row][col]));\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777939,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    string toStr(int k)\\n    {\\n        stringstream ss;\\n        ss << k;\\n        string s;\\n        ss >> s;\\n        return s;\\n    }\\n    bool isValidSudoku(vector<vector<char>> &board)\\n    {\\n        map<string, int> mp;\\n        string temp;\\n        int n = board.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (board[i][j] != \\'.\\')\\n                {\\n                    //-------------------Inserting for ROW and value in its cell\\n                    //-------------------In case the same row contains the duplicate values, we can find it by map/ set or any DS.\\n                    temp = \"ROW\";\\n                    temp += toStr(i) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for COL and value in its cell\\n                    temp = \"COL\";\\n                    temp += toStr(j) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for BOX \\n                    //-------------------There are 9 boxes of size 3x3 in sudoku\\n                    //-------------------and every value in box should be unique\\n                    temp = \"BOX\";\\n                    temp += toStr((i / 3) * 3 + (j / 3)) + (board[i][j]);\\n                    // cout<<temp<<endl;\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    string toStr(int k)\\n    {\\n        stringstream ss;\\n        ss << k;\\n        string s;\\n        ss >> s;\\n        return s;\\n    }\\n    bool isValidSudoku(vector<vector<char>> &board)\\n    {\\n        map<string, int> mp;\\n        string temp;\\n        int n = board.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (board[i][j] != \\'.\\')\\n                {\\n                    //-------------------Inserting for ROW and value in its cell\\n                    //-------------------In case the same row contains the duplicate values, we can find it by map/ set or any DS.\\n                    temp = \"ROW\";\\n                    temp += toStr(i) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for COL and value in its cell\\n                    temp = \"COL\";\\n                    temp += toStr(j) + (board[i][j]);\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n\\n                    //-------------------Inserting for BOX \\n                    //-------------------There are 9 boxes of size 3x3 in sudoku\\n                    //-------------------and every value in box should be unique\\n                    temp = \"BOX\";\\n                    temp += toStr((i / 3) * 3 + (j / 3)) + (board[i][j]);\\n                    // cout<<temp<<endl;\\n                    if (mp.find(temp) == mp.end())\\n                    {\\n                        mp[temp]++;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1714485,
                "title": "python-3-using-hash-o-n-time-o-n-space",
                "content": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [{} for _ in range(9)] # check which value exists in each row\\n        cols = [{} for _ in range(9)] # check which value exists in each column\\n        boxes = [{} for _ in range(9)] # check which value exists in each box\\n        for row in range(9):\\n            for col in range(9):\\n                bIdx =(row//3)*3 + col//3 # convert cell location to box location\\n                v = board[row][col]\\n                if v!=\\'.\\':\\n                    if v in rows[row] or v in cols[col] or v in boxes[bIdx]: # if exist in either rows/cols/boxes\\n                        return False\\n                    else: # add them in\\n                        rows[row][v] = True\\n                        cols[col][v] = True\\n                        boxes[bIdx][v] = True\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\\n        rows = [{} for _ in range(9)] # check which value exists in each row\\n        cols = [{} for _ in range(9)] # check which value exists in each column\\n        boxes = [{} for _ in range(9)] # check which value exists in each box\\n        for row in range(9):\\n            for col in range(9):\\n                bIdx =(row//3)*3 + col//3 # convert cell location to box location\\n                v = board[row][col]\\n                if v!=\\'.\\':\\n                    if v in rows[row] or v in cols[col] or v in boxes[bIdx]: # if exist in either rows/cols/boxes\\n                        return False\\n                    else: # add them in\\n                        rows[row][v] = True\\n                        cols[col][v] = True\\n                        boxes[bIdx][v] = True\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1442272,
                "title": "c-using-set",
                "content": "**Please Upvote if you like!**\\n\\n     bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\t// Create vectors of unordered sets to keep track of numbers in rows, columns, and boxes\\n\\t\\tvector<unordered_set<int>> rows(9);\\n\\t\\tvector<unordered_set<int>> columns(9);\\n\\t\\tvector<unordered_set<int>> boxes(9);\\n\\n\\t\\t// Iterate through each cell in the Sudoku board\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\t// If the cell is empty, continue to the next cell\\n\\t\\t\\t\\tif (board[i][j] == \\'.\\') {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Convert the character to an integer to get the number in the cell\\n\\t\\t\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current row\\n\\t\\t\\t\\tif (rows[i].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current column\\n\\t\\t\\t\\tif (columns[j].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Calculate the index of the box the current cell belongs to\\n\\t\\t\\t\\tint index = (i / 3) * 3 + j / 3;\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current box\\n\\t\\t\\t\\tif (boxes[index].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the number doesn\\'t violate any rules, insert it into the sets\\n\\t\\t\\t\\trows[i].insert(num);\\n\\t\\t\\t\\tcolumns[j].insert(num);\\n\\t\\t\\t\\tboxes[index].insert(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If the Sudoku has been checked and no violations were found, it\\'s valid\\n\\t\\treturn true;\\n\\t}\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "**Please Upvote if you like!**\\n\\n     bool isValidSudoku(vector<vector<char>>& board) {\\n\\t\\t// Create vectors of unordered sets to keep track of numbers in rows, columns, and boxes\\n\\t\\tvector<unordered_set<int>> rows(9);\\n\\t\\tvector<unordered_set<int>> columns(9);\\n\\t\\tvector<unordered_set<int>> boxes(9);\\n\\n\\t\\t// Iterate through each cell in the Sudoku board\\n\\t\\tfor (int i = 0; i < 9; i++) {\\n\\t\\t\\tfor (int j = 0; j < 9; j++) {\\n\\t\\t\\t\\t// If the cell is empty, continue to the next cell\\n\\t\\t\\t\\tif (board[i][j] == \\'.\\') {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Convert the character to an integer to get the number in the cell\\n\\t\\t\\t\\tint num = board[i][j] - \\'0\\';\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current row\\n\\t\\t\\t\\tif (rows[i].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current column\\n\\t\\t\\t\\tif (columns[j].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Calculate the index of the box the current cell belongs to\\n\\t\\t\\t\\tint index = (i / 3) * 3 + j / 3;\\n\\n\\t\\t\\t\\t// Check if the same number already exists in the current box\\n\\t\\t\\t\\tif (boxes[index].count(num)) {\\n\\t\\t\\t\\t\\treturn false; // If yes, the Sudoku is invalid\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// If the number doesn\\'t violate any rules, insert it into the sets\\n\\t\\t\\t\\trows[i].insert(num);\\n\\t\\t\\t\\tcolumns[j].insert(num);\\n\\t\\t\\t\\tboxes[index].insert(num);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// If the Sudoku has been checked and no violations were found, it\\'s valid\\n\\t\\treturn true;\\n\\t}\\n",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1566470,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1568854,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572579,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1711763,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1565592,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1567818,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1798774,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1576771,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572483,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1921338,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1566470,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1568854,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572579,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1711763,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1565592,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1567818,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1798774,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1576771,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1572483,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1921338,
                "content": [
                    {
                        "username": "Sam_Zhang",
                        "content": "the following test case for 'valid sudoku', it's invalid. why the expected answer is true? \\nit make me confused. \\n[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Just check and validate the given numbers. You dont need to fill any number in the matrix."
                    },
                    {
                        "username": "akasharjun3123",
                        "content": "[@coniferish](/coniferish) then how to check if its valid or not\\n"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "After reading the replies i still dont understand "
                    },
                    {
                        "username": "apnadivyam",
                        "content": "[@coniferish](/coniferish)  oh okay thankyou"
                    },
                    {
                        "username": "coniferish",
                        "content": "This test case should return true. The challenge isn't to test whether the sudoku is solvable, but whether or not it violates any of the rules/has repeating digits within a column. row, or quadrant. You're correct this would not be a solvable sudoku, though"
                    },
                    {
                        "username": "pahtreeck",
                        "content": "This is the only test case that I am not passing: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"]\\n\\nThe expected result is \"false\", but I don't see anything wrong with this particular Sudoku. I'm returning true for this test case. Can anyone help me identify why it's not valid?"
                    },
                    {
                        "username": "Yup2013",
                        "content": "[@kartikkk1212](/kartikkk1212) good reply, thanks"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "You are not checking the 3x3 grid properly, make sure you initialize the set/map outside both loops"
                    },
                    {
                        "username": "pstrait",
                        "content": "Row 2, column 4 is a 3. Row 3, column 6 is also a 3. Those are both in the top middle box."
                    },
                    {
                        "username": "ToanNguyen",
                        "content": "After I submitted my code, the checker reported a wrong answer for this test case\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nHow could the checker expects \"False\" result for this. Could someone please point me out?\\n\\nThanks,\\n\\nThomas\\n"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "well, if I\\'m correct you have a repetition in a column, two 5s, that\\'s why this sudoku is invalid, false is the right answer, correct me if I\\'m mistaken, thanks"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "Test Case 473 is wrong. There is no mistake on the board but it returns false ? \\n. . . . 5 . . 1 . \\n. 4 . 3 . . . . . \\n. . . . . 3 . . 1 \\n8 . . . . . . 2 . \\n. . 2 . 7 . . . . \\n. 1 5 . . . . . . \\n. . . . . 2 . . . \\n. 2 . 9 . . . . . \\n. . 4 . . . . . . "
                    },
                    {
                        "username": "misiaczek416",
                        "content": "Yes, I\\'m passing also 472 cases and the fails on this one?? my code seems correct and yet ....."
                    },
                    {
                        "username": "uditdamare01",
                        "content": "[@chickooo](/chickooo) what? can you elaborate?\\n"
                    },
                    {
                        "username": "ibrahimaksan",
                        "content": "[@chickooo](/chickooo) yes dude i didnt notice at first, thank you. "
                    },
                    {
                        "username": "chickooo",
                        "content": "In,\n0 <= row <= 2\n6 <= col <= 8\n\n```\n.1.\n...\n..1\n```\n\n1 is repeated twice. Hence, invalid"
                    },
                    {
                        "username": "StefanPochmann",
                        "content": "    def is_valid_sudoku(board)\\n     !(0..80).flat_map{|k| (c=board[i=k/9][j=k%9])>'.' ? [[c,i],[j,c],[i/3,j/3,c]] : k}.uniq!\\n    end"
                    },
                    {
                        "username": "Miguell0706",
                        "content": "seriously tho what is this"
                    },
                    {
                        "username": "rayoh123",
                        "content": "Terrible solution. Unreadable and inefficient."
                    },
                    {
                        "username": "pstrait",
                        "content": "wut"
                    },
                    {
                        "username": "Jackiy",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue\\n\\nThis is not a valid sudoku. As the position(0,0) has to be 9, but it is duplicated with the last row. A but in the OJ."
                    },
                    {
                        "username": "divyanshu1593",
                        "content": "Read the question carefully, it mentions that the sudoku can be valid even if it is unsolvable. So you need to check for the current elements of the sudoku, you don't need to consider the element at 0,0 because in current state there is no element there."
                    },
                    {
                        "username": "william1357chen",
                        "content": "I find it the hardest to figure out what the box number should be with the row and column number. Is there a better way of thinking about this?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Divide row and column by 3 to get the box numbers."
                    },
                    {
                        "username": "k1b219",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n [\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n[0][0] <- can\\'t put 1~digit\\n"
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "jjjjgggg",
                        "content": "This problem is easy at best. The board dimension is fixed 9x9 so every solution is O(1) in theory. Using 27 hash sets would be a no brainer for any one."
                    },
                    {
                        "username": "firezdog",
                        "content": "[@Tom_Dev](/Tom_Dev) I think the point is that since the size of the input is fixed, it takes constant time to solve."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Isn\\'t it O(n^2)?"
                    },
                    {
                        "username": "orangejuice555",
                        "content": "does this always require more lines of code than if you do O(n^2) complexity?"
                    },
                    {
                        "username": "anwendeng",
                        "content": "From {1, 2,..., 9} there are 2**9=512 different ways to choose each\\ndigit once or none.\\nThere are 27 conditions need to check.\\n3 kinds of conditions: columns , rows and blocks.\\nEach board[i][j] lies exactly in one column, one row and one block.\\nbitset<9> or boolean arrays suffice to use for recording and checking and play the role of hash tables!!"
                    }
                ]
            },
            {
                "id": 1683701,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1569508,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1567730,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1862520,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1809889,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1884629,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1770423,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1694929,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 1571088,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 2076453,
                "content": [
                    {
                        "username": "bikcrum",
                        "content": "Why is this a medium problem? Should be easy imo."
                    },
                    {
                        "username": "Demaxl",
                        "content": "If its too easy for you just move on to another problem why do you have to say this. A beginner might find it difficult "
                    },
                    {
                        "username": "M_Suleman",
                        "content": "Yeah it should be hard."
                    },
                    {
                        "username": "leetcancode",
                        "content": "No bru, not easy for beginners."
                    },
                    {
                        "username": "192731",
                        "content": "the boxes though"
                    },
                    {
                        "username": "egithinji",
                        "content": "I must say, I agree"
                    },
                    {
                        "username": "glaucusec",
                        "content": "[@thepasterover](/thepasterover) can relate to this"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "[@Naveen_kumar_0910](/Naveen_kumar_0910)  just use mapping for numbers it will be easy "
                    },
                    {
                        "username": "Naveen_kumar_0910",
                        "content": "can you give out any hint to solve the condition with grids"
                    },
                    {
                        "username": "thepasterover",
                        "content": "[@Zelda_Galadriel](/Zelda_Galadriel) Hard agree. I have figured out how to do rows and cols. I just cant figure out how to do it with grids"
                    },
                    {
                        "username": "Zelda_Galadriel",
                        "content": "Nah the easy version of this problem would just be the rows and columns, without the boxes."
                    },
                    {
                        "username": "user2628Z",
                        "content": "\\nHow can this expect true?\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "This is true because there\\'s no repeatition in the columns, rows and 3 x 3 sub square. Check the question description."
                    },
                    {
                        "username": "rajkamallashkari",
                        "content": "This sudoku is unsolvable, but not invalid yet. For the sudoku to be considered invalid in this problem means it should violate the rule of repeating any digit in either row, column, or grid."
                    },
                    {
                        "username": "raman56",
                        "content": "\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nthere\\'s no valid sudoku fro this testcase"
                    },
                    {
                        "username": "ZhixiL",
                        "content": "Since its stated that \"A Sudoku board (partially filled) could be valid but is not necessarily solvable.\"\\nAnd for this case, all the three restriction passed:\\nEach row must contain the digits 1-9 without repetition. (Check)\\nEach column must contain the digits 1-9 without repetition. (Check)\\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. (Check)\\nSo this is a valid case."
                    },
                    {
                        "username": "user5378Ua",
                        "content": "[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n [\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n [\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n [\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n [\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWhy that case(368) should return false?"
                    },
                    {
                        "username": "asthashrivastava11",
                        "content": "Why the following test case must return true? \\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThere are no digits in any row/columns or quadrant? As per the description a valid sudoku is where each row/column and quadrant must contain digit from 1-9 without repetition. Hence the above case must return false but expected is true. can anyone explain? "
                    },
                    {
                        "username": "mihir-k5",
                        "content": "Only filled cells need to be validated with the rule. Your code should ignore any cells with \".\" (dot). This type of problems, you check for a rule, and even a single False is enough to stop the function. But True is returned only at very end, after all checks are done. So the code should skip all \".\" then the last line of your function will return True."
                    },
                    {
                        "username": "amitjha00",
                        "content": "can anyone help me in checking that non repeating elements in box 3x3 how to check"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "To get the indexes for the boxes divide row and column by 3."
                    },
                    {
                        "username": "betrayy",
                        "content": "Was it just me who couldn\\'t figure out the \"formula\" for knowing which sub-box you\\'re in at position (r,c)? "
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is expected to return false, but i think it is clearly true bcoz there is no repitation?\\nCan anyone please tell me what is wrong in this?\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],\\n[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],\\n[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],\\n[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],\\n[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],\\n[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "oh thankyou karthik i just got it\ni missed the condition of 3x3"
                    },
                    {
                        "username": "KarthikV123",
                        "content": "Its False as we have 1 in positions (1,8) and (3,9)\\n"
                    },
                    {
                        "username": "mdw",
                        "content": "Input:\\t[\".87654321\",\"2........\",\"3........\",\"4........\",\"5........\",\"6........\",\"7........\",\"8........\",\"9........\"]\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "Padma_Dhar",
                        "content": "This should evaluate to false. However OJ says it is true\\n\\n[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"8\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"3\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"7\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"4\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"6\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\"5\"]]"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "the testcases might be confusing"
                    }
                ]
            },
            {
                "id": 2071938,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2052835,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2051907,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2050119,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2040084,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 2038730,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1879995,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1806063,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1575839,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1574493,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "As a hint , A particular element can be uniquely identified by the row , column and block. Use this unique identifier to check if soduku is valid or not "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good bro"
                    },
                    {
                        "username": "AdamGold",
                        "content": "Why is this a medium? This question is basically asking if you know how for loops work and if you know how to determine if a character has been repeated. "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Yes, but to put everything together is not trivial."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@be4ko](/be4ko) Yes, two nested loops are O(n^2)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "idk"
                    },
                    {
                        "username": "be4ko",
                        "content": "if you are gonna only use for loops is that gonna be a O(n^2) ?? "
                    },
                    {
                        "username": "be4ko",
                        "content": "What Data Structure should I use to Solve this Problem Set ? Map ?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I am using arrays of unordered_set. unordered_set is using hashing, set is using a tree."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Good question, I used ordered set"
                    },
                    {
                        "username": "revolution14",
                        "content": "getting runtime error when checking for duplicates in box, any hints? \n        `unordered_set<char> setRow, setColumn;\n        unordered_map<int, unordered_set<char>> setBox;\n\n        for(int i=0; i<9; i++){\n            for(int j=0; j<9; j++){\n                char num = board[i][j], num2 = board[j][i];\n                 \n                // checking for row\n                if(num!='.' && setRow.find(num)!=setRow.end())\n                    return false;\n                setRow.insert(num);\n\n                // checking for column\n                if(num2!='.' && setColumn.find(num2)!=setColumn.end())\n                    return false;\n                setColumn.insert(num2);\n\n                // checking for individual box\n                auto it = setBox.find((i/3)*3+j/3);\n                if(it==setBox.end()){\n                    setBox.insert({(i/3)*3+j/3, unordered_set<char> ({num})}) ;\n                }\n                else if(num!='.' && it->second.find(num)!=it->second.end())\n                    return false;\n                it->second.insert(num);\n\n                \n            }\n\n            setRow.clear();\n            setColumn.clear();\n        }\n\n        return true;\n`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "nope"
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "I got confused in string and char because of example contains \"\" on elements."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "i think \"\" will return false"
                    },
                    {
                        "username": "nadabao",
                        "content": "what a boring question."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I find it interesting."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "same"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "The condition says that each row and column must have a number, but in the test where all the points are, the correct answer is true."
                    },
                    {
                        "username": "Ansh_verma21",
                        "content": "what should be the time complexity for this code\\n"
                    },
                    {
                        "username": "weswithley",
                        "content": "This case looks no repition exist, but why output should be false ?\\n[\\n\\t[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],\\n\\t[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],\\n\\t[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n\\t[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n]\\n\\nUPDATE : \\nAs my understanding, all the re-org groups from top left to bottom right should be :  \\n1. [\".\", \".\", \"4\", \".\", \".\", \".\", \"5\", \".\", \".\"]\\n2. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n3. [\"6\", \"3\", \".\", \".\", \".\", \".\", \".\", \"9\", \".\"]\\n4. [\".\", \".\", \".\", \"4\", \".\", \"3\", \".\", \".\", \".\"]\\n5. [\"5\", \"6\", \".\", \".\", \".\", \".\", \"7\", \".\", \".\"]\\n6. [\".\", \"9\", \".\", \".\", \".\", \".\", \".\", \".\", \"1\"]\\n7. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n8. [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n9. [\".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]\\n\\nlooks like no repitation in each group. \\uD83E\\uDD14"
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "There\\'s a repeatition in the first column. look out for 5"
                    },
                    {
                        "username": "Coder0622",
                        "content": "There\\'s a repetition in the first row. The number 5 exists in [5][0], and [8,0]."
                    },
                    {
                        "username": "AnkitRaj06",
                        "content": "Can someone please help me understand, how can the below test case give an output \"False\"?\\n\\n[[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]"
                    },
                    {
                        "username": "Coder0622",
                        "content": "The fourth column has two 5\\'s: [3][3] and [7][3]"
                    }
                ]
            },
            {
                "id": 1574352,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1574267,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573556,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573156,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1573029,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1572416,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1572116,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571089,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571090,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1574892,
                "content": [
                    {
                        "username": "YogeshK",
                        "content": "not sure its not going through in my head and dont wanna memorize it...\\nEnded up comparing x and y and calculating each box index."
                    },
                    {
                        "username": "lgdelacruz",
                        "content": "I spent a long time on this thinking it has to be solvable to be valid. No, you just need to check if it is valid."
                    },
                    {
                        "username": "ronghuali980303",
                        "content": "[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nMy submission fails at this one. It\\'s appearently only 9 can be in the first element according to the row.However 9 also exists in the first column. Therefore my answer to this is false. But the expected output is true. Anyone can tell me why?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "ksuzuki",
                        "content": "There is a test case:\\n\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],\\n[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nwhich should return False because the top left corner can\\'t populate any values without breaking the constraints. Column is looking for a 1, but Row is looking for a 9. But leetcode is expecting the output to be True.\\n\\nany thoughts?\\n"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "We do not check if sudoku is solvable, we check if it breaks any rules at the current point. No square here has repeating numbers, and neither do columns and rows."
                    },
                    {
                        "username": "divi13",
                        "content": "Hi,\\n\\nFor the second input (with 8 instead of 5), the grader says that my code produces the result \\'true\\' but when I run it myself, I am getting the expected false. This happened a few days ago too with another question. Is it possible that the grader is somehow storing the previous result and incorrectly outputting that as the current result too? Could you please fix the grader?"
                    },
                    {
                        "username": "JingxuOuyang",
                        "content": "{{\\'.\\',\\'8\\',\\'7\\',\\'6\\',\\'5\\',\\'4\\',\\'3\\',\\'2\\',\\'1\\'},\\n{\\'2\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'3\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'4\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'5\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'6\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'7\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'8\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'},\\n{\\'9\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\',\\'.\\'}}\\nexcept true?"
                    },
                    {
                        "username": "otherside2",
                        "content": "How is this a valid Sudoku?\\n\\nWrong Answer\\nInput: \\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\nOutput: false\\nExpected: true"
                    },
                    {
                        "username": "kaihua",
                        "content": "the last input is \\n[\"..5.....6\",\"....14...\",\".........\",\".....92..\",\"5....2...\",\".......3.\",\"...54....\",\"3.....42.\",\"...27.6..\"]\\n\\n\".....92..\",\"5....2...\" will be wrong."
                    },
                    {
                        "username": "42nl",
                        "content": "below is the outcome from my judge:\\n\\nInput:\\t[\"..4...63.\",\".........\",\"5......9.\",\"...56....\",\"4.3.....1\",\"...7.....\",\"...5.....\",\".........\",\".........\"]\\nOutput:\\ttrue\\nExpected:\\tfalse\\n\\nDoes anybody know why this input should be false? Could you tell me?"
                    },
                    {
                        "username": "Dominiqos",
                        "content": "4th row has the number 5 two times in it"
                    },
                    {
                        "username": "kushagrabainsla",
                        "content": "I tried this for 2 hours and after checking out the discussions, i found out that we don\\'t have to solve it, but have to check than whether it is a valid sudoku or not.\\nMoral of the story: Read the question very carefully."
                    }
                ]
            },
            {
                "id": 1571885,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2059206,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2058299,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2025457,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 2020432,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1984607,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1973127,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1949150,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1946320,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1910695,
                "content": [
                    {
                        "username": "zackzhu20",
                        "content": "I am wondering if this question is about checking the validity of the sudoku or checking if there is solution for this sudoku. If it is the latter case, it is much more difficult then (need to solve the sudoku and check)"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "It is only about checking the validity of sudoku"
                    },
                    {
                        "username": "HamzaGorcevic",
                        "content": "Why is fasle expected:\\n [[\".\",\".\",\"4\",\".\",\".\",\".\",\"6\",\"3\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\"9\",\".\"],[\".\",\".\",\".\",\"5\",\"6\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"1\"],[\".\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n. I sent rules and board to chatgpt and it says its valid"
                    },
                    {
                        "username": "adevlinb",
                        "content": "Not all of the test cases are giving the proper outcome..."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@adevlinb](/adevlinb) The testcases are wrote by computer"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) I cannot reproduce that. My Javascript solution got accepted."
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev) \\n\\nJavascript"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "[@adevlinb](/adevlinb) Which programming language is that?"
                    },
                    {
                        "username": "adevlinb",
                        "content": "[@Tom_Dev](/Tom_Dev)  \\na human wrote the test, no? So it is possible that the test is wrong... #473:\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nThis is set to expect the value of False.. when in fact.. it is True that it is a valid sudoku board.. if you read each horizontal and vertical line.. there are no repeating numbers.. The test is wrong. "
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "why"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Then your code is wrong."
                    },
                    {
                        "username": "amitpr02",
                        "content": "class Solution {\\n    bool isValid(vector<vector<char>> &board, char ch, int row, int col) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[i][col] == ch) \\n                return false;\\n            if (board[row][i] == ch) \\n                return false;\\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == ch) \\n                return false;       \\n        }\\n        return true;\\n    }\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n = board.size();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] != \\'.\\') {\\n                    char ch = board[i][j];\\n                    if (!isValid(board, ch, i, j)) \\n                        return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\nWhat\\'s wrong in the code. Can anybody tell?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Use arrays of hash sets."
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "Remained stuck in this Test case for a duplicate column. it is a good question can have been categorized as Easy too. \n                          {{'.','.','4','.','.','.','6','3','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'5','.','.','.','.','.','.','9','.'},\n\t\t                   {'.','.','.','5','6','.','.','.','.'},\n\t\t                   {'4','.','3','.','.','.','.','.','1'},\n\t\t                   {'.','.','.','7','.','.','.','.','.'},\n\t\t                   {'.','.','.','5','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'},\n\t\t                   {'.','.','.','.','.','.','.','.','.'}};"
                    },
                    {
                        "username": "nikhikpal173",
                        "content": "the discussion number was 69  before this \\u2665"
                    },
                    {
                        "username": "m1059006",
                        "content": "I thought it is a challenging problem at the first sight. Later, I found it is actually not too hard. I was just overthinking.\\nIt just asked you to check if the initial board is valid (so that following all rules in the description).  It doesn\\'t matter it is solvable or not."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "test case 473: [\"....5..1.\",\".4.3.....\",\".....3..1\",\"8......2.\",\"..2.7....\",\".15......\",\".....2...\",\".2.9.....\",\"..4......\"];\\nI have checked and found no repeatition. All rows and columns have unique values.\\nwhy expected answer is false? can anyone help me? Thanks in advance."
                    },
                    {
                        "username": "sandeep0423",
                        "content": "I have the answer -- each 3x3 sub box must have unique digits"
                    },
                    {
                        "username": "EricTsaiQA",
                        "content": "Having q question about test case 371, if all elements are \".\" , why it should return true ?  i suppose it should return false, lol"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It does not have duplicate numbers, so it is valid."
                    },
                    {
                        "username": "adhyayana",
                        "content": "Why this code is not working :\\nclass Solution {\\n\\n    public  boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public  boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n}\\n"
                    }
                ]
            },
            {
                "id": 1891660,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1890091,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1866863,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1852501,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1842159,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1804528,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1801860,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1793480,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1793287,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1792556,
                "content": [
                    {
                        "username": "lethienluc2021",
                        "content": "why [[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]] has result true"
                    },
                    {
                        "username": "NithinModiboyana",
                        "content": "[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"]\\n,[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"]\\n,[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"]\\n,[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"]\\n,[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\ncan someone explain why is this False? "
                    },
                    {
                        "username": "Skripko",
                        "content": "In my view, this task should be easy, not medium"
                    },
                    {
                        "username": "Janvigurjar",
                        "content": "def isValid(row,col,board,c):\\n            for i in range(len(board)):\\n                if board[row][i]==c  and i!=row:\\n                    return False\\n                if board[i][col]==c and i!=col:\\n                    return False\\n                if board[3*(row//3)+i//3][3*(col//3)+i%3]==c and i!= 3*(row//3)+i//3 :\\n                    return False\\n            return True\\n        \\ndef check(board):\\n    for i in range(len(board)):\\n        for j in range(len(board)):\\n            if board[i][j]!=\".\":\\n                if isValid(i,j,board,board[i][j])==False:\\n                    return False\\n    return True\\n\\n\\n\\ncan anyone help in this"
                    },
                    {
                        "username": "zaman_ishtiyaq",
                        "content": "is this board solvable?\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\\n[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n"
                    },
                    {
                        "username": "Navfalbek",
                        "content": "I think there is a bug in testcase 350 which is:\\n[[\".\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"],\\n          [\"2\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"3\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"4\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"5\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"6\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"7\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"8\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"],\\n          [\"9\", \".\", \".\", \".\", \".\", \".\", \".\", \".\", \".\"]]\\n\\nWhen I submited the solution it only fails in this one. But when I run the same code on PyCharm the result was True (Valid) however, when I run in LeetCode\\'s codespace it gives False. I do not know why this is happening. Is there someone also faced with this problem?"
                    },
                    {
                        "username": "kanishkamehrotra",
                        "content": "why is this test case failing ,my solution is giving true for this but it seems that the answer is false ,no number is rows coloumns are repeating and not even in the blocks \\n[\\n[\".\",\".\",\"4\", \".\",\".\",\".\", \"6\",\"3\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\"5\",\".\",\".\", \".\",\".\",\".\", \".\",\"9\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\"6\",\".\", \".\",\".\",\".\"],\\n[\"4\",\".\",\"3\", \".\",\".\",\".\", \".\",\".\",\"1\"],\\n[\".\",\".\",\".\", \"7\",\".\",\".\", \".\",\".\",\".\"],\\n\\n[\".\",\".\",\".\", \"5\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"],\\n[\".\",\".\",\".\", \".\",\".\",\".\", \".\",\".\",\".\"]\\n]"
                    },
                    {
                        "username": "itsathakur30",
                        "content": "How output can be true?\\n\\n\\nboard =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\n\\nOutput\\nfalse\\n\\n\\nExpected\\ntrue\\n\\n\\n\\n"
                    },
                    {
                        "username": "h4sh_19",
                        "content": "who else wrote the code to solve the sudoku and find the valid sudoku instead of just checking only filled spots? Only me ? \\uD83D\\uDE29"
                    },
                    {
                        "username": "DaffyDuck",
                        "content": "Can someone help me find the bug here ?\\n\\nLooks like object.equals is not working as expected from the print statements , I am not sure where is the actual bug in the method. \\n\\nTest case 2 fails with this approach as the solution cannot detect that two 8\\'s are in the same grid even though they map to the same grid. \\n\\nFWIW I solved it through another approach but wanted to do it in a OOPS way.\\n\\n\\n   ` class Solution {\\n\\n     char[][] board;\\n\\n    public boolean isValidSudoku(char[][] board) {\\n        \\n        this.board = board;\\n        \\n        return solveUsingOOPS();\\n    \\n    }\\n\\n    private boolean solveUsingOOPS(){\\n\\n        Set<SudokuPosition> set = new HashSet<>();\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j] != \\'.\\'){\\n                    int rowGrid = i/3;\\n                    int colGrid = j/3;\\n                    SudokuPosition pos = new SudokuPosition(board[i][j],i,j,rowGrid*3+colGrid);\\n\\n                    if(set.contains(pos)){\\n                        return false;\\n                    }else{\\n                        set.add(pos);\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n\\n    private class SudokuPosition{\\n        char val;\\n        int row; \\n        int col;\\n        int grid;\\n\\n        public SudokuPosition(char val,int row,int col,int grid){\\n            this.val = val;\\n            this.row = row;\\n            this.col = col;\\n            this.grid = grid;\\n        }\\n\\n        @Override\\n    public boolean equals(Object other) {\\n        if (!(other instanceof SudokuPosition)) {\\n            return false;\\n        }\\n        SudokuPosition spos = (SudokuPosition)other;\\n        return (this.val == spos.val) &&\\n               ((this.row == spos.row) || (this.col == spos.col) || (this.grid == spos.grid)); \\n    }\\n\\n    @Override\\n    public int hashCode() {\\n        return 31 * (31 * row + col) + grid;\\n    }\\n    \\n    }\\n\\n    }`"
                    }
                ]
            },
            {
                "id": 1768442,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1767626,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1766850,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1762149,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1757021,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1753314,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1752608,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1749110,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1737683,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1729151,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why this code is passing only for 4 test cases ? for sudoku solver problem \\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n    for (int i = 0; i < 9; i++) {\\n      for (int j = 0; j < 9; j++) {\\n        if (board[i][j] == \\'.\\') {\\n\\n          for (char c = \\'1\\'; c <= \\'9\\'; c++) {\\n            if (isValid(board, i, j, c)) {\\n              board[i][j] = c;\\n\\n              if (isValidSudoku(board))\\n                return true;\\n              else\\n                board[i][j] = \\'.\\';\\n            }\\n          }\\n\\n          return false;\\n        }\\n      }\\n    }\\n    return true;\\n  }\\n\\n  public boolean isValid(char[][] board, int row, int col, char c) {\\n    for (int i = 0; i < 9; i++) {\\n      if (board[i][col] == c)\\n        return false;\\n\\n      if (board[row][i] == c)\\n        return false;\\n\\n      if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c)\\n        return false;\\n    }\\n    return true;\\n  }\\n\\n}"
                    },
                    {
                        "username": "pt33",
                        "content": "Can someone help me out with why im able to run this for only 4 test cases..\\nclass Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row=board.length;\\n        int col=board[0].length;\\n        return solve(board,row,col);\\n    }\\n    public boolean solve(char[][] board,int row,int col){\\n        int i,j;\\n        char c;\\n         for(i=0;i<row;i++){\\n             for(j=0;j<col;j++){\\n                 if(board[i][j]==\\'.\\')\\n                 {\\n                     for(c=\\'1\\';c<=\\'9\\';c++){\\n                     if(valid(c,i,j,board)){\\n                        board[i][j]=c;\\n                        if(solve(board,row,col)==true)\\n                        return true;\\n                        else\\n                        board[i][j]=\\'.\\';\\n\\n                       }\\n                       \\n                    }\\n                    return false;\\n                 }\\n                 \\n             }\\n             \\n         }\\n       return true;\\n    }\\n  \\n\\n\\n\\nboolean valid(char c,int r,int cl,char board[][]){\\n    int i;\\n    for(i=0;i<9;i++){\\n            if(board[i][cl]==c)\\n            return false;\\n            if(board[r][i]==c)\\n            return false;\\n            if(board[3*(r/3)+i/3][3*(cl/3)+i%3]==c)\\n            return false;\\n        \\n    }\\n    return true;\\n}\\n} "
                    },
                    {
                        "username": "boakyeokyere96",
                        "content": "Algorithm for basic python solution\n\nSteps\n1. The first loop should check for the vertical and horizontal stretch simultaneaously to find a repeatition. Dictionary could be useful here\n\n2. The next should check for each 3 x 3 square for a repeatition.\n"
                    },
                    {
                        "username": "user7780HP",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "Found the difficulty on this problem to be in the \"2nd\" part so to speak, because each 3x3 box has to have unique numbers.\\nThe unique numbers part, not an issue, but the iterating through the box elements, and delimiting boxes. omg such a PITA, and really not much intuition needed.\\n\\nAs a hint:\\n(do not read if you don\\'t want hints)\\n\\nhint 1:\\non each level (0,1,2) iterate through each box set (0,1,2)\\nreset the i, j starts depending on the level and box set nr respectively.\\nTbh, this is pen & paper and you figuring out indexes.\\n\\nhint 2:\\nBonus for JS: much easier with sets than with maps\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "r0kkka",
                        "content": "are these not the same?\n\n```\n# if key in rows[i] or key in cols[j] or key in grids[(i // 3, j // 3)]:\n#     return False\n\nif key in [rows[i], cols[j], grids[(i // 3, j // 3)]]:\n    return False\n```"
                    },
                    {
                        "username": "Shangyuan_LIU",
                        "content": "I have to admit that the description is quite misleading and vague"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "This is a python code with explanation, approach and algorithm. \\n\\n\\n\\nhttps://siteinvokers.com/valid-sudoku-leet-code-36/"
                    }
                ]
            },
            {
                "id": 1728953,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1728092,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1726273,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1721325,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1720748,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1699178,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1695612,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1694022,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1693586,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            },
            {
                "id": 1686551,
                "content": [
                    {
                        "username": "singhsupriya711",
                        "content": "344/507 testcases passed can anyone tell me y?\\n\\nclass Solution {\\npublic:\\nbool isvalid(vector<vector<char>>& board,int row,int col){\\n    for(int i=0;i<9;i++){\\n        if(board[row][i]==board[row][col]){\\n            return false;\\n        }\\n        if(board[i][col]==board[row][col]){\\n            return false;\\n        }\\n        if(board[3*(row/3)+i/3][3*(col/3)+i%3]==board[row][col]){\\n            return false;\\n        }\\n        \\n    }\\n\\n    return true;\\n}\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool t=false;\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<9;j++){\\n                if(board[i][j]!=\\'.\\'){\\n                    if(isvalid(board,i,j)){\\n                        t=true;\\n                    }else t=false;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};"
                    },
                    {
                        "username": "AverageDPenjoyer",
                        "content": " `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        int row[] = new int[9];\\n        int col[] = new int[9];\\n        int box [][] = new int[3][3];\\n        for(int i=0;i<9;i++){\\n            for(int j =0;j<9;j++){\\n                int ch = Character.getNumericValue(board[i][j]);\\n                \\n                if(ch!=(-1)){\\n                    System.out.println(ch);\\n                    if(row[i]==ch || col[i]==ch || box[i/3][j/3]==ch){\\n                        return false;\\n                    }\\n                    row[i]=ch;\\n                    col[j]=ch;\\n                    box[i/3][j/3]=ch;\\n                }\\n            }\\n        }\\n        return true;\\n\\n    }\\n}`\\nCan somebody explain what is wrong in my code "
                    },
                    {
                        "username": "qingcheng2014",
                        "content": "board =\\n[[\".\",\"8\",\"7\",\"6\",\"5\",\"4\",\"3\",\"2\",\"1\"],[\"2\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"3\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"4\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"5\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"7\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\"9\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n4 / 507 testcases passed\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nthis test case is wrong? omg????????\\nwhy  expected value is true??????"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "\\nMy testcase is not getting passed, expected answer is false, it is showing true for me. Please help\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nclass Solution {\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        int n=board.size();\\n        vector<unordered_map<char,int>> r(n);\\n          vector<unordered_map<char,int>>  col(n);\\n\\n        for (int i=0;i<board.size();i++)\\n        {  \\n            for (int j=0;j<board.size();j++)\\n            {   \\n                char c=board[i][j];\\n                if (c==\\'.\\')\\n                    continue;\\n                if (r[i][c]++ >0 ||col[j][c]++ >0 )\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "Aastha_Goyal",
                        "content": "while calculating boxnum if I\\'m using (i) + (j/3) it\\'s giving me wrong ans but if I\\'m using  int boxnum = ((i/3)*3) + (j/3); it\\'s giving correct ans. Why is this?\\n\\n `class Solution {\\n    public boolean isValidSudoku(char[][] board) {\\n        HashSet<String> hs = new HashSet<>();\\n\\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n               if(board[i][j] != \\'.\\'){\\n                    String row = \"row\"+i+board[i][j];\\n                    String col = \"col\"+j+board[i][j];\\n                    int boxnum = ((i/3)*3) + (j/3);\\n                    String box = \"box\"+boxnum+board[i][j];\\n\\n                    if(hs.contains(row) || hs.contains(col) || hs.contains(box)) return false;\\n\\n                    hs.add(row);\\n                    hs.add(col);\\n                    hs.add(box);\\n\\n               }\\n\\n            }\\n        }\\n        return true;\\n    }\\n} `"
                    },
                    {
                        "username": "Udit_69",
                        "content": "class Solution {\\n    final int radix = 10;\\n    public boolean isSafe(char board[][],int row,int col,int digit){\\n        //column\\n        for(int i=0;i<=8;i++){\\n            if(board[i][col]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // row\\n        for(int j=0;j<=8;j++){\\n           if(board[row][j]==Character.forDigit(digit,radix))\\n               return false;\\n        }\\n        // grid\\n        int sr = (row/3)*3;\\n        int sc = (col/3)*3;\\n        for(int i=sr;i<sr+3;i++){\\n            for(int j=sc;j<sc+3;j++){\\n                if(board[i][j]==Character.forDigit(digit,radix))\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean sudokoSol(char board[][],int row,int col){\\n        // base case\\n        if(row==9)\\n           return true;   \\n        // recursion work\\n        int nextRow = row , nextCol = col+1;\\n        if(nextCol==9){\\n            nextRow = row+1;\\n            nextCol=0;\\n        }\\n        if(board[row][col]!=\\'.\\'){\\n            return sudokoSol(board,nextRow,nextCol);\\n        }\\n        for(int digit=1;digit<=9;digit++){\\n           if(isSafe(board,row,col,digit)){\\n               char c= Character.forDigit(digit,radix);\\n               board[row][col] = c;\\n               if(sudokoSol(board,nextRow,nextCol)){\\n                   return true;\\n               }\\n               board[row][col]=\\'.\\';\\n           }\\n        }\\n        return false;\\n\\n    }\\n    public boolean isValidSudoku(char[][] board) {\\n        if(sudokoSol(board,0,0)){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\ncan anyone please explain why this code is passing 4 testcases only?"
                    },
                    {
                        "username": "Simran_Achra",
                        "content": "https://leetcode.com/problems/valid-sudoku/discussion/comments/1694929\\nplease?"
                    },
                    {
                        "username": "Mitulagr",
                        "content": "Converting i (0-9) & j(0-9) to Mini-Square Indices : \\nRow Index = j/3 + 3*(i/3)\\nCol Index = j%3 + 3*(i%3)"
                    },
                    {
                        "username": "zoomber",
                        "content": "There should be a third Testcase for testing sub 3x3 boxes. "
                    },
                    {
                        "username": "anshuman_raina",
                        "content": "To those of us who are getting false in this case :\\n\\n[[\".\",\".\",\".\",\".\",\"5\",\".\",\".\",\"1\",\".\"],[\".\",\"4\",\".\",\"3\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"3\",\".\",\".\",\"1\"],[\"8\",\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\"],[\".\",\".\",\"2\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\".\",\"1\",\"5\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\"],[\".\",\"2\",\".\",\"9\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"4\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\\nWe also have to remember that the mini squares too must not have a repetition. i.e. square with diagonal a[0][0]-a[2]][2]"
                    },
                    {
                        "username": "sparklingness",
                        "content": "There\\'s duplicated 1\\'s at a[0][7] and a[2][8].\\nThey are in the same square."
                    }
                ]
            }
        ]
    },
    {
        "title": "Single Number",
        "question_content": "<p>Given a <strong>non-empty</strong>&nbsp;array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p>\n\n<p>You must&nbsp;implement a solution with a linear runtime complexity and use&nbsp;only constant&nbsp;extra space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [2,2,1]\n<strong>Output:</strong> 1\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [4,1,2,1,2]\n<strong>Output:</strong> 4\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> nums = [1]\n<strong>Output:</strong> 1\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li><code>-3 * 10<sup>4</sup> &lt;= nums[i] &lt;= 3 * 10<sup>4</sup></code></li>\n\t<li>Each element in the array appears twice except for one element which appears only once.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1771720,
                "title": "c-easy-solutions-sorting-xor-maps-or-frequency-array",
                "content": "Hi , everybody . This question is quite easy. I am quite confident that most of you would have reached atleast 1 of the following approaches to solve this question. But , incase you missed any of them , do give this a read.\\n### EXPLANATION :\\n**The question simply asks us to find an element in the given array whose frequency is 1.All the other elements have a frequency=2. \\nWe have to do so in :**\\n* **Linear Time**\\n* **Using Constant Space**\\n\\n\\n\\n##### METHOD 1 : USING MAPS (NOT USING CONSTANT SPACE ) \\nThe question states that we have to find an element in the array with frequency=1. \\nSo , the first idea that pops in the mind is to store the frequency of each element in a map (or a frequency array) and then traverse that map/array and return the element with frequency=1. \\n\\n1. Map the given array\\'s elements to their frequency. ( KEY : ELEMENT , VALUE : FREQUENCY )\\n2. Traverse that map and return the key whose value =1. \\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};\\n```\\n\\n**TC: O(N)**\\n**SC: O(N)**\\n\\n\\nNow , if we see the above method uses variable extra space, which is why it can\\'t be our answer. \\n(Although it is an approach to solve this problem). \\nThen how do we solve this ?? \\nImagine you have blocks with the array elements inscribed on them. Now , if I sort the array for you and now ask you to find the element , CAN YOU DO SO ?? \\n\\nYes , upon sorting , every element will have a similar element adjacent to it , if it has the frequency of 2.\\n\\n##### METHOD 2 : USING SORTING (USING CONSTANT SPACE ) \\nAs explained above , we do the following :\\n1. Sort the array. \\n2. Traverse the array and check if one of the adjacent elements is equal to the current element or not. \\n3. If yes , move ahead. Else return the current element. \\n\\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\\n\\n**TC: O(NlogN)**\\n**SC: O(1)**\\n\\nThe above approach can be used to solve the problem . But what if we can improve the time complexity ??\\nWhat if we don\\'t have to sort the array ?? \\nThe following method deals with that approach. \\n##### METHOD 3 : USING BITWISE XOR OPERATOR (USING CONSTANT SPACE ) \\nTo use this approach you first need to understand about Bitwise XOR operator. \\nMost of us who have a background in physics ( highschool level ) , are aware of the LOGIC GATES. \\nOne of such gates is the XOR Gate : \\nAccording to this gate , the output is true , only if both the inputs are of opposite kind . \\nThat is , \\n\\t\\t\\t\\t\\t **A             B                   Y**\\n\\t\\t\\t\\t\\t **0             0                    0**\\n\\t\\t\\t\\t\\t **0             1                    1**\\n\\t\\t\\t\\t\\t **1             0                    1**\\n\\t\\t\\t\\t\\t **1             1                    0**\\n\\t\\t\\t\\t\\t \\nWe apply the extended version of this gate in our bitwise XOR operator. \\nIf we do \"a^b\" , it means that we are applying the XOR gate on the 2 numbers in a bitwise fashion ( on each of the corresponding bits of the numbers). \\nSimilarly , if we observe , \\n1.  ***A^A=0***\\n2.  ***A^B^A=B***\\n3.  ***(A^A^B) = (B^A^A) = (A^B^A) = B***  This shows that position doesn\\'t matter. \\n4.  Similarly , if we see , ***a^a^a......... (even times)=0 and a^a^a........(odd times)=a***\\n\\nGoogle It for more details. \\n\\nWe apply the above observations : \\n1. Traverse the array and take the Bitwise XOR of each element. \\n2. Return the value. \\n\\n**Why does this work ??**\\nBecause , the elements with frequency=2 will result in 0. And then the only element with frequency=1 will generate the answer. \\n\\t\\t\\t\\t\\t \\n##### CODE : \\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       int ans=0;\\n\\t   for(auto x:nums)\\n\\t   ans^=x;\\n\\t   return ans;\\n    }\\n};\\n```\\n\\n**TC: O(N)**\\n**SC: O(1)**\\n\\n\\n### PS : METHOD 4: SUM OF ELEMENTS \\nAll the unique elements , in the array have a frequency of 2 , except one element. \\n\\n1. Store all the unique elements in set. \\n2. Add the elements of the set and multiply by 2 (SUM_1). \\n3. Add all the elements of the array(ARRAY_SUM). \\n4. Return (SUM_1 - ARRAY_SUM) . \\n\\n**Why does this work ??**\\nARRAY_SUM = 2*(a1+a2+a3...+ak) + a(k+1)\\nSUM_1 = 2*(a1+a2+a3+....+ak+ a(k+1)) \\n\\n*a(x) represents the xth unique element in the array. \\na(k+1) represents the element with frequency=1.*\\n\\nHope you found this post useful . If so , then do upvote and comment below.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i+=2)\\n        {\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       int ans=0;\\n\\t   for(auto x:nums)\\n\\t   ans^=x;\\n\\t   return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771771,
                "title": "think-it-through-time-o-n-space-o-1-python-explained",
                "content": "\\n### Edge Cases:\\n1. No element appears twice; it is a constraint so not possible\\n2. Single length array; return the only element already present in the array\\n3. len(nums) > 1; find the single element that does not appear twice\\n\\n### Approaches:\\n1. **Brute Force**\\nIntuition:\\nIterate through every element in the nums and check if any of the element does not appear twice, in that case return the element.\\n*Time: O(n^2)\\nSpace: O(1)*\\n\\n2. **Use Sorting**\\nIntuition:\\nIf the elements of the nums array are sorted/when we sort it, we can compare the neighbours to find the single element. It is already mentioned that all other elements appear twice except one.\\n*Time: O(nlogn) for sorting then O(n) to check neighbouring elements\\nSpace: O(1)*\\n\\n3. **Use Hashing/Set**\\nIntuition:\\ni) As we iterate through the nums array we store the elements encountered and check if we find them again while iteration continues. While checking if we find them again, we maintain a single_element object/variable which stores that single element, eventually returning the single_element.\\nii) The other way is to maintain a num_frequency hashmap/dictionary and iterate over it to find which has exactly 1 frequency and return that key/num.\\n*Time: O(n) for iterating over the nums array\\nSpace: O(n) for hashing*\\n\\n4. **Use Xor/Bit Manipulation**\\nIntuition:\\nXor of any two num gives the difference of bit as 1 and same bit as 0.\\nThus, using this we get 1 ^ 1 == 0 because the same numbers have same bits.\\nSo, we will always get the single element because all the same ones will evaluate to 0 and 0^single_number = single_number.\\n*Time: O(n)\\nSpace: O(1)*\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        \\n        return xor\\n\\n```\\n\\n**Updated**:\\n*You can find more of my solutions like this in discuss forums by searching through either **satyamsinha93** or **Think it through**.*\\n\\nThanks for all the love and upvoting!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        \\n        return xor\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772139,
                "title": "c-explained-everything-w-why-xor-works-brute-force-to-optimized-step-by-step-dry-run",
                "content": "***Brief note about Question-***\\n* We have to return the number which is *appears single time* in the array.\\n```\\nLet\\'s take an example not given in question -\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\nSo, our answer should be \\'7\\' as it appears only single time in the array. \\n```\\n_________________\\n***Solution - I (using unorderd map, Accepted)-***\\n* Since we are very obedient person and don\\'t want to do anything extra from our side.\\n* So, on seeing the question, the first idea that clicks to our mind is to ***store frequency*** of all over the elements.\\n* After storing frequency, we will simply ***find the element whose frequency is 1***.\\n* The element whose frequency is 1, that is our answer.\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(n) // we will store the frequency of every element\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\\n***So, How we will implement that?***\\n* Whenever we heard the name *frequency*, we will call our one and only superhero i.e `unordered_map`.\\n* We will store frequency of each element in our unorderd map.\\n* After that, we **traverse from the map**, and for every element we check whether it\\'s **frequency is 1** or not.\\n* If it\\'s frequency is 1, then we will simply store the answer and break the loop.\\n* See, an example.\\n```\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nso, after storing frequency of each element in our map, our map looks like -\\n5 -> 2\\n1 -> 2\\n3 -> 2\\n4 -> 2\\n7 -> 1     On traversing, we will see that it\\'s frequency is 1, so this should be our answer.\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // taking the size of the array \\n        \\n        unordered_map<int, int> mp; // unordered map to store the frequency\\n        \\n        // storing frequency in the map\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int ans; // variable to store our answer\\n        for(auto x: mp) // traverse from the map\\n        {\\n            if(x.second == 1) //if frequency of any elemennt is 1\\n            {\\n                ans = x.first; // store in our answer\\n                break; // break the loop, as we got our answer now\\n            }\\n        }\\n        \\n        return ans; // return ans\\n    }\\n};\\n```\\n____\\n***Solution - II (using property of xor, Accepted)-***\\n* Now, the question arises, is their any way so that we do not need to store frequency, i.e \\n**can we space optimized our answer**?\\n* Since, we want not to use map, so we will see our map that where is the problem?\\n* We observe a very basic thing that other than our answer, **frequency of each element is 2**, that means our question wants to say that, ***every element appears twice except the single one and we have to find that particular single element.***\\n* So, if every element appears twice, *do we really need to store the frequency of each element*?\\n* Answer is **No**, we do not need to store the frequency of each element because we already know that, for each element their is only two ways, **either it\\'s frequency is 1 or it\\'s frequency is 2**. Their is not any third option other than that.\\n* In this way, we can think of ***the property of XOR-***\\n```\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\n```\\n* If we see, we will find out that ***xor of two same number is zero***.\\n* Can we use this property here?\\n* Answer is ***Yes***. But how? \\n* We will run a loop from all over the array, and simply start taking xor of two.\\n* We do xor between prev answer of xor and current element.\\n* See dry run for more clarification.\\n* But, Question is **WHY**? why this works?\\n```\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0\\n2) xor is commutative that means a ^ b = b ^ a.\\n3) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nwe will rearrange the array, and take all the numbers together, then our array looks like\\n                     arr[]: [1, 1, 3, 3, 4, 4, 5, 5, 7]\\n\\t\\t\\t\\t\\t now, take xor of all numbers -\\n\\t\\t\\t\\t\\t 1 ^ 1 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 7   (rearrange the array)\\n\\t\\t\\t\\t\\t   0   ^   0   ^   0   ^   0   ^ 7   (see point number 1)\\n\\t\\t\\t\\t\\t               7                     (see point number 3) \\n\\n```\\n* Now, The question again arises, **do we really need to rearrange the array ?**\\n* Answer is ***NO***.\\n* We already know a property of xor, that says we don\\'t need to rearrange the array. But wait, where?\\n* `xor is commutative that means a ^ b = b ^ a. (see above point number 2)`  \\n* Okay, if this is ? **Can you do this without rearaanging the array?**\\n* Answer is **Yes**, see below-\\n```\\nSo, our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4] \\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n \\u2191  \\u2191\\n 5 ^ 1 = 4\\n \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n       \\u2191                       \\n\\t   4 ^ 3 = 7 (prev answer xor current index)\\n\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\t      \\u2191\\n\\t\\t  7 ^ 1 = 6 (prev answer xor current index)\\n\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n             \\u2191\\n\\t\\t\\t 6 ^ 3 = 5 (prev answer xor current index)\\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                \\u2191\\n\\t\\t\\t\\t5 ^ 4 = 1  (prev answer xor current index)\\n\\t\\t\\t\\t\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                   \\u2191\\n\\t\\t\\t\\t   1 ^ 5 = 4 (prev answer xor current index)\\n\\t\\t\\t\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                      \\u2191\\n\\t\\t\\t\\t\\t  4 ^ 7 = 3 (prev answer xor current index)\\n\\t\\t\\t\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                         \\u2191\\n\\t\\t\\t\\t\\t\\t 3 ^ 4 = 7 (prev answer xor current index)\\n\\t\\t\\t\\t\\t\\t \\nSo, the element which we got as left should be our answer, so the answer is \\'7\\'\\n```\\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(1) // we are not using anything extra from our side\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        // traverse from the array\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            arr[i + 1] = arr[i] ^ arr[i + 1]; // (prev answer xor current index)\\n        }\\n        \\n        return arr[n- 1]; // return left over element\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\nSo, our answer should be \\'7\\' as it appears only single time in the array. \\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(n) // we will store the frequency of every element\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\n```\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nso, after storing frequency of each element in our map, our map looks like -\\n5 -> 2\\n1 -> 2\\n3 -> 2\\n4 -> 2\\n7 -> 1     On traversing, we will see that it\\'s frequency is 1, so this should be our answer.\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // taking the size of the array \\n        \\n        unordered_map<int, int> mp; // unordered map to store the frequency\\n        \\n        // storing frequency in the map\\n        for(int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        \\n        int ans; // variable to store our answer\\n        for(auto x: mp) // traverse from the map\\n        {\\n            if(x.second == 1) //if frequency of any elemennt is 1\\n            {\\n                ans = x.first; // store in our answer\\n                break; // break the loop, as we got our answer now\\n            }\\n        }\\n        \\n        return ans; // return ans\\n    }\\n};\\n```\n```\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\n```\n```\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0\\n2) xor is commutative that means a ^ b = b ^ a.\\n3) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nSuppose our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4]\\nwe will rearrange the array, and take all the numbers together, then our array looks like\\n                     arr[]: [1, 1, 3, 3, 4, 4, 5, 5, 7]\\n\\t\\t\\t\\t\\t now, take xor of all numbers -\\n\\t\\t\\t\\t\\t 1 ^ 1 ^ 3 ^ 3 ^ 4 ^ 4 ^ 5 ^ 5 ^ 7   (rearrange the array)\\n\\t\\t\\t\\t\\t   0   ^   0   ^   0   ^   0   ^ 7   (see point number 1)\\n\\t\\t\\t\\t\\t               7                     (see point number 3) \\n\\n```\n```\\nSo, our array is arr[]: [5, 1, 3, 1, 3, 4, 5, 7, 4] \\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n \\u2191  \\u2191\\n 5 ^ 1 = 4\\n \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n       \\u2191                       \\n\\t   4 ^ 3 = 7 (prev answer xor current index)\\n\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n\\t      \\u2191\\n\\t\\t  7 ^ 1 = 6 (prev answer xor current index)\\n\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n             \\u2191\\n\\t\\t\\t 6 ^ 3 = 5 (prev answer xor current index)\\n\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                \\u2191\\n\\t\\t\\t\\t5 ^ 4 = 1  (prev answer xor current index)\\n\\t\\t\\t\\t\\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                   \\u2191\\n\\t\\t\\t\\t   1 ^ 5 = 4 (prev answer xor current index)\\n\\t\\t\\t\\t   \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                      \\u2191\\n\\t\\t\\t\\t\\t  4 ^ 7 = 3 (prev answer xor current index)\\n\\t\\t\\t\\t\\t  \\n[5, 1, 3, 1, 3, 4, 5, 7, 4]\\n                         \\u2191\\n\\t\\t\\t\\t\\t\\t 3 ^ 4 = 7 (prev answer xor current index)\\n\\t\\t\\t\\t\\t\\t \\nSo, the element which we got as left should be our answer, so the answer is \\'7\\'\\n```\n```\\nTime Complexity --> O(n) // where n is the size of the array\\nSpace Complexity --> O(1) // we are not using anything extra from our side\\n\\nIt paases [ 61 / 61 ] in built test cases\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& arr) {\\n        int n = arr.size(); // extracting the size of the array\\n        \\n        // traverse from the array\\n        for(int i = 0; i < n - 1; i++)\\n        {\\n            arr[i + 1] = arr[i] ^ arr[i + 1]; // (prev answer xor current index)\\n        }\\n        \\n        return arr[n- 1]; // return left over element\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1771791,
                "title": "python3-one-liner-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use the nice property of XOR operation which is if you XOR same numbers it will return zero. Since the `nums` contains just one non-repeating number, we can just XOR all numbers together and the final result will be our answer.\\n\\n*For reference about `reduce`: https://thepythonguru.com/python-builtin-functions/reduce/*\\n\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn reduce(lambda total, el: total ^ el, nums)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn reduce(lambda total, el: total ^ el, nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 42997,
                "title": "my-o-n-solution-using-xor",
                "content": "known that A XOR A = 0 and the XOR operator is commutative, the solution will be very straightforward.\\n`\\n\\n    int singleNumber(int A[], int n) {\\n        int result = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n\\t\\t\\tresult ^=A[i];\\n        }\\n\\t\\treturn result;\\n    }\\n`",
                "solutionTags": [],
                "code": "known that A XOR A = 0 and the XOR operator is commutative, the solution will be very straightforward.\\n`\\n\\n    int singleNumber(int A[], int n) {\\n        int result = 0;\\n        for (int i = 0; i<n; i++)\\n        {\\n\\t\\t\\tresult ^=A[i];\\n        }\\n\\t\\treturn result;\\n    }\\n`",
                "codeTag": "Unknown"
            },
            {
                "id": 43000,
                "title": "python-different-solutions",
                "content": "   \\n    def singleNumber1(self, nums):\\n        dic = {}\\n        for num in nums:\\n            dic[num] = dic.get(num, 0)+1\\n        for key, val in dic.items():\\n            if val == 1:\\n                return key\\n    \\n    def singleNumber2(self, nums):\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n        return res\\n        \\n    def singleNumber3(self, nums):\\n        return 2*sum(set(nums))-sum(nums)\\n        \\n    def singleNumber4(self, nums):\\n        return reduce(lambda x, y: x ^ y, nums)\\n        \\n    def singleNumber(self, nums):\\n        return reduce(operator.xor, nums)",
                "solutionTags": [
                    "Python",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "   \\n    def singleNumber1(self, nums):\\n        dic = {}\\n        for num in nums:\\n            dic[num] = dic.get(num, 0)+1\\n        for key, val in dic.items():\\n            if val == 1:\\n                return key\\n    \\n    def singleNumber2(self, nums):\\n        res = 0\\n        for num in nums:\\n            res ^= num\\n        return res\\n        \\n    def singleNumber3(self, nums):\\n        return 2*sum(set(nums))-sum(nums)\\n        \\n    def singleNumber4(self, nums):\\n        return reduce(lambda x, y: x ^ y, nums)\\n        \\n    def singleNumber(self, nums):\\n        return reduce(operator.xor, nums)",
                "codeTag": "Python3"
            },
            {
                "id": 3171261,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = nums[0];\\n\\n        for(int i = 1 ; i < nums.size() ; i++){\\n            ans = ans ^ nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    return functools.reduce(lambda x, y: x ^ y, nums, 0)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result=0;\\n        for(int i=0; i<nums.length; i++) {\\n            result = result^nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = nums[0];\\n\\n        for(int i = 1 ; i < nums.size() ; i++){\\n            ans = ans ^ nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n  def singleNumber(self, nums: List[int]) -> int:\\n    return functools.reduce(lambda x, y: x ^ y, nums, 0)\\n```\n```Java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result=0;\\n        for(int i=0; i<nums.length; i++) {\\n            result = result^nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43201,
                "title": "easy-java-solution-tell-you-why-using-bitwise-xor",
                "content": "  \\nwe use bitwise XOR to solve this problem : \\n\\nfirst , we have to know the bitwise XOR in java\\n\\n 1. **0 ^ N = N**\\n 2. **N ^ N = 0**\\n\\n\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N  \\n\\n  = (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n  = 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n  = N  \\n\\n\\n  \\n \\n\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans =0;\\n        \\n        int len = nums.length;\\n        for(int i=0;i!=len;i++)\\n            ans ^= nums[i];\\n        \\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "  \\nwe use bitwise XOR to solve this problem : \\n\\nfirst , we have to know the bitwise XOR in java\\n\\n 1. **0 ^ N = N**\\n 2. **N ^ N = 0**\\n\\n\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N  \\n\\n  = (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n  = 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n  = N  \\n\\n\\n  \\n \\n\\n\\n\\n    public int singleNumber(int[] nums) {\\n        int ans =0;\\n        \\n        int len = nums.length;\\n        for(int i=0;i!=len;i++)\\n            ans ^= nums[i];\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3021354,
                "title": "java-easy-solution-beats-100-runtime-1ms-bit-manipulation",
                "content": "\\n# Approach\\nUsing Bit Manipulation - \\n\\n1) As we know XOR operation with 0 gives the same number \\ni.e,  a XOR 0 = a\\neg, for decimal no. 2=>  2 XOR 0 = 2\\nin binary, 010 XOR 000 = 010 \\n\\n2) Also we know that , XOR operation with same number gives 0\\ni.e, a XOR a = 0 \\neg, 2 XOR 2 = 0\\nin binary, 010 XOR 010 = 000 \\n\\n3) XOR is associative (like sum)\\ni.e, (2 XOR 3) XOR 4 = 2 XOR (3 XOR 4), So the order doesn\\'t matter in performing XOR operation. \\neg, 2^3^4^6 = 3^2^6^4 = 4^2^6^3 ......\\n\\nSo, using these three properties of XOR , we will solve the question. we will take ans variable with 0 as initial value. And then for each element i in array, we will perform the XOR operation of the element  with 0, ans will become 0 if the same number is found (as a XOR a = 0) and so after the completion of the loop, only element with no duplicate number will remain and will be returned as ans.\\n\\n\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0; //since XOR with 0 returns same number \\n        for(int i=0; i<nums.length; i++){\\n            ans ^= nums[i];  // ans = (ans) XOR (array element at i) \\n        }\\n        return ans;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0; //since XOR with 0 returns same number \\n        for(int i=0; i<nums.length; i++){\\n            ans ^= nums[i];  // ans = (ans) XOR (array element at i) \\n        }\\n        return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43228,
                "title": "easiest-way-to-solve-by-using-bit-manipulation",
                "content": "\\n**Logic:** XOR will return 1 only on two different bits. So if two numbers are the same, XOR will return 0. Finally only one number left.\\nA ^ A = 0 and A ^ B ^ A = B.\\n\\n\\n\\n\\n\\n    class Solution {\\n        public:\\n            int singleNumber(int A[], int n) {\\n                int result=A[0];\\n                for(int i=1;i<n;i++)\\n                {\\n                    result= result^A[i];  /* Get the xor of all elements */\\n                }\\n                return result;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int singleNumber(int A[], int n) {\\n                int result=A[0];\\n                for(int i=1;i<n;i++)\\n                {\\n                    result= result^A[i];  /* Get the xor of all elements */\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 43171,
                "title": "1ms-java-solution",
                "content": "public class Solution {\\n    \\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums) {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums) {\\n            result ^= i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2438883,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "**Problem:**\\nGiven a non-empty array of integers nums, every element appears twice except for one. Find that single one.\\n**Input:**   nums = [ 4, 1, 2, 1, 2 ]\\n**Output:**  4\\n**Explanation:**   1\\u2019s and 2\\u2019s appear twice, only 4 appears exactly once. So the answer is 4.\\n**Concept of XOR:**\\nXOR of zero and some bit returns that bit i.e. x^0 = x...\\nXOR of two same bits returns 0 i.e. x^x = 0...\\nAnd,  x^y^x = (x^x)^y = 0^y = y...\\nXOR all bits together to find the unique number.\\n\\n\\n# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Single Number.\\nMemory Usage: 46.2 MB, less than 89.95% of Java online submissions for Single Number.\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\nRuntime: 6 ms, faster than 98.77% of C++ online submissions for Single Number.\\nMemory Usage: 11.8 MB, less than 98.93% of C++ online submissions for Single Number.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar singleNumber = function(nums) {\\n    // Initialize the unique number...\\n    let uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n};\\n```\\n\\n# **C Language:**\\n```\\nint singleNumber(int* nums, int numsSize){\\n    // Initialize the unique number...\\n    int uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        // Initialize the unique number...\\n        int uniqNum = 0;\\n        // TRaverse all elements through the loop...\\n        for (int idx : nums) {\\n            // Concept of XOR...\\n            uniqNum ^= idx;\\n        } return uniqNum;       // Return the unique number...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```\n```\\nvar singleNumber = function(nums) {\\n    // Initialize the unique number...\\n    let uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (let idx = 0; idx < nums.length; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n};\\n```\n```\\nint singleNumber(int* nums, int numsSize){\\n    // Initialize the unique number...\\n    int uniqNum = 0;\\n    // TRaverse all elements through the loop...\\n    for (int idx = 0; idx < numsSize; idx++) {\\n        // Concept of XOR...\\n        uniqNum = uniqNum ^ nums[idx];\\n    } return uniqNum;       // Return the unique number...\\n}\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        # Initialize the unique number...\\n        uniqNum = 0;\\n        # TRaverse all elements through the loop...\\n        for idx in nums:\\n            # Concept of XOR...\\n            uniqNum ^= idx;\\n        return uniqNum;       # Return the unique number...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264959,
                "title": "well-expalined-code-in-java",
                "content": "\\n\\n# Approach\\nThe code is a Java implementation of a function that takes an integer array nums as input and returns the single integer in the array that appears only once. The function assumes that all other integers in the array appear exactly twice.\\n\\nThe implementation sorts the input array using the Arrays.sort() method. Sorting the array ensures that all duplicate integers are adjacent to each other. Then, the implementation iterates through the sorted array using a loop that increments the index by 2 in each iteration. Inside the loop, the implementation checks if the current integer and the next integer are not equal. If they are not equal, the implementation returns the current integer as the single integer that appears only once.\\n\\nIf the loop completes without finding a single integer that appears only once, the implementation returns the last element of the sorted array. This is because the last element is the only remaining element in the array, and it must be the single integer that appears only once.\\n\\n# Complexity\\n- Time complexity:\\nThe Arrays.sort method used at the beginning of the function has a time complexity of O(n log n), where n is the length of the input array. This is because it uses a variant of the quicksort algorithm, which has an average time complexity of O(nlogn).\\n\\n- Space complexity:\\nThe space complexity of the function is O(1), as it uses only a constant amount of additional memory to store the loop variable and some temporary variables for the sorting operation. The sorting operation is performed in-place, so it does not require any additional memory allocation.\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length-1;i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n       return nums[nums.length-1];\\n    }\\n    \\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/02c5a619-d6fa-418b-b177-8b523fc2b30f_1678114992.5292022.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length-1;i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n       return nums[nums.length-1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43237,
                "title": "4-lines-of-c-solution",
                "content": "    nt singleNumber(int a[], int n) {\\n         //xor all numbers, the left over number would be the non repeated one\\n         // since the equl numbers cancel out each others bits\\n         int num = 0;\\n         for (int i = 0; i < n; ++i) {\\n             num ^= a[i];\\n         }\\n         return num;\\n        }",
                "solutionTags": [],
                "code": "    nt singleNumber(int a[], int n) {\\n         //xor all numbers, the left over number would be the non repeated one\\n         // since the equl numbers cancel out each others bits\\n         int num = 0;\\n         for (int i = 0; i < n; ++i) {\\n             num ^= a[i];\\n         }\\n         return num;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 558767,
                "title": "python-space-o-1-xor-reduce-very-simple-one-liner-with-explanation",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\\n\\n**Explanation**\\nI will try to explain this solution by walking through the initial solution that I wrote:\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n\\t\\tfor n in nums:\\n\\t\\t\\tresult ^= n\\n\\t\\treturn result\\n```\\nThe most crucial trick here is to recognize that if you XOR any same number together, you cancel it out (=0).\\nFor example:\\nnums = [2,4,5,4,3,5,2]\\nXORing everything together\\n= 2 ^ 4 ^ 5 ^ 4 ^ 3 ^ 5 ^ 2\\n= (2^2) ^ (4^4) ^ (5^5) ^ 3\\n= 0 ^ 0 ^0 ^ 3\\n= 3\\n\\n(If you are unfamiliar with the XOR operation, you can check out [this stackoverflow post](https://stackoverflow.com/questions/14526584/what-does-the-xor-operator-do))\\n\\nNow, let\\'s go back to the one liner:\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\\n- The `reduce` here just simplifies the previous `for` loop into one line, it\\'s not doing anything different. \\n- The initializer `0` is put there to prevent the the scenerio where `nums` is an empty list (I didn\\'t realize that the question statement explicitly mentioned that it would be non-empty).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n\\t\\tfor n in nums:\\n\\t\\t\\tresult ^= n\\n\\t\\treturn result\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x^y, nums, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43193,
                "title": "javascript-solution",
                "content": "```js\\nfunction singleNumber(nums) {\\n\\treturn nums.reduce((prev, curr) => prev ^ curr);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction singleNumber(nums) {\\n\\treturn nums.reduce((prev, curr) => prev ^ curr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174407,
                "title": "easy-c-solution-beginner-friendly",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED**\\n\\n**Optimised Approach**\\n* Since in XOR Operations 0^0 = 0 and 1^1 = 0.\\n* Hence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            ans = ans^nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Bruteforce Approach**\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        if(nums.size() < 1) {\\n            return 0;\\n        }\\n        \\n        else if(nums.size() > 1) {\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for(int i=0; i<nums.size(); i++) {\\n                if(nums[i] != nums[i+1]) {\\n                    return nums[i];\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        //else for nums.size() == 1\\n        return nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            ans = ans^nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        if(nums.size() < 1) {\\n            return 0;\\n        }\\n        \\n        else if(nums.size() > 1) {\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for(int i=0; i<nums.size(); i++) {\\n                if(nums[i] != nums[i+1]) {\\n                    return nums[i];\\n                }\\n                i++;\\n            }\\n        }\\n        \\n        //else for nums.size() == 1\\n        return nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43216,
                "title": "my-very-simple-solution-linear-time-no-extra-memory",
                "content": "\\nXOR of two equal numbers is 0 : a^a=0. This is the main idea of the algorithm.\\n\\n    class Solution { \\n        public:\\n            int singleNumber(int A[], int n) {\\n                for (int i = 1; i < n; ++i)\\n                    A[0] ^= A[i];\\n                 return A[0];\\n            } \\n        };",
                "solutionTags": [],
                "code": "class Solution { \\n        public:\\n            int singleNumber(int A[], int n) {\\n                for (int i = 1; i < n; ++i)\\n                    A[0] ^= A[i];\\n                 return A[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43019,
                "title": "1-line-simple-python-solution",
                "content": "    class Solution(object):\\n    def singleNumber(self, nums):\\n        return sum(list(set(nums)))*2 - sum(nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def singleNumber(self, nums):\\n        return sum(list(set(nums)))*2 - sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 43153,
                "title": "my-java-solution-in-o-n-time-complexity-and-o-1-space-complexity-using-xor",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = 0;\\n            for(int num : nums) {\\n                res ^= num;\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = 0;\\n            for(int num : nums) {\\n                res ^= num;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1428325,
                "title": "all-c-solutions-100-faster-99-26-less-space",
                "content": "***1. O(NLog N) Time and O(1) Space solution: [99.26% less space]***\\n```\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1;){\\n            if(nums[i+1] != nums[i])\\n                return nums[i];\\n            else\\n                i+=2;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\\n\\n***2. Using Unordered Maps (Hash Tables)***\\n```\\n    int singleNumber(vector<int>& nums) {        \\n        unordered_map<int, int> um;\\n        for(int a: nums)\\n            um[a]++;\\n        for(auto it = um.begin(); it!=um.end(); it++){\\n            if(it->second==1)\\n                return it->first;\\n        }\\n        return 0;\\n    }\\n```\\n\\n***3. Using XOR(^) bitwise operator to find unique number*** (Fastest)\\nBitwise XOR Operator(^) has three properties: \\n1. a^a = 0\\n2. 0^a = a\\n3. XOR is associative just like addition, multiplication, etc which means that -> a^b^c = a^(b^c) = (a^b)^c = (a^c)^b\\nSo, when we XOR all the numbers in the list, all the numbers that occur 2 times become 0 as a^a = 0. At the end, we will be left with an expression like 0^n, where n is the only number occurring once. Using second property 0^a = a :-  0^n = n. Hence, we get the unique number.\\n```\\n    int singleNumber(vector<int>& nums) {        \\n        \\n        // Using XOR property for Unique number\\n        int resultXOR = 0;                \\n        for(int a: nums)\\n            resultXOR ^= a;        \\n        return resultXOR;            \\n    }\\n```\\n***Please Upvote if found useful!***",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    int singleNumber(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size()-1;){\\n            if(nums[i+1] != nums[i])\\n                return nums[i];\\n            else\\n                i+=2;\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\n```\\n    int singleNumber(vector<int>& nums) {        \\n        unordered_map<int, int> um;\\n        for(int a: nums)\\n            um[a]++;\\n        for(auto it = um.begin(); it!=um.end(); it++){\\n            if(it->second==1)\\n                return it->first;\\n        }\\n        return 0;\\n    }\\n```\n```\\n    int singleNumber(vector<int>& nums) {        \\n        \\n        // Using XOR property for Unique number\\n        int resultXOR = 0;                \\n        for(int a: nums)\\n            resultXOR ^= a;        \\n        return resultXOR;            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43232,
                "title": "simple-c-solution",
                "content": "The trick is: A^B^A=B\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if(nums.empty()) return 0;\\n            int first = nums[0];\\n            for(int i = 1; i<nums.size();i++) {\\n                first = first ^ nums[i];\\n            }\\n            return first;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            if(nums.empty()) return 0;\\n            int first = nums[0];\\n            for(int i = 1; i<nums.size();i++) {\\n                first = first ^ nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1184007,
                "title": "3-different-java-solutions-with-explanations",
                "content": "First Approach by using hashMap  :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer, Integer> hash = new<Integer, Integer> HashMap();\\n        \\n        for(int x : nums){\\n            if(hash.containsKey(x)){       //if hashmap contains \\'element\\', then increase correspoding val\\n                int count = hash.get(x);\\n                hash.put(x, ++count);\\n            }\\n            else\\n                hash.put(x, 1);           //if hashmap does not contain  \\'element\\', then put it in hashmap\\n        }\\n        \\n        for(int x : hash.keySet()){       //Iterate through \\'keys\\' of HashMap\\n            if(hash.get(x)==1)            //if \\'value\\' for \\'key\\' is \\'1\\', then return that \\'key\\' element\\n                return x;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\nTime Complexity : O(nlogn) , as there is a for loop and inside for loop \\'hash.containsKey\\' \\nSpace Complexity : O(n)  ,  as HashMap of size nearly \\'n/2\\' is used.\\n\\n\\nSecond Approach by using \\'Sort()\\' method :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);                          //Sort the array\\n        for(int i=0 ; i<nums.length-1; i+=2){       \\n            if(nums[i]!=nums[i+1])                  //Check pairwise values in array\\n                return nums[i];                     //if any pairwise values are different, then it is answer\\n        }\\n        return nums[nums.length - 1];       //if answer is largest value, then it will not be detected in above loop hence return it here\\n   }\\n}\\n```\\nTime Complexity : O(nlogn) , as \\'sort()\\' method is used \\nSpace Complexity : O(1)  ,  as No extra space is used other than some constant\\n\\n\\n\\nOptimal Approach by using \\'XOR\\'  :-\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int x: nums){\\n            result = result ^ x;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\nBitwise \\'XOR\\' gives zero when both inputs are same. And if we apply XOR for \\'zero\\' and \\'any number\\', it will give output as that number itself. So if the array is {4,1,2,1,2} then \\'XOR\\' operation is\\n        ((2^2)^(1^1)^(4)) => (0^0^4) => 4\\n\\t\\t\\nTime Complexity : O(n) , as only one \\'for\\'loop\\nSpace Complexity : O(1)  , as No extra space is used other than some constant\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer, Integer> hash = new<Integer, Integer> HashMap();\\n        \\n        for(int x : nums){\\n            if(hash.containsKey(x)){       //if hashmap contains \\'element\\', then increase correspoding val\\n                int count = hash.get(x);\\n                hash.put(x, ++count);\\n            }\\n            else\\n                hash.put(x, 1);           //if hashmap does not contain  \\'element\\', then put it in hashmap\\n        }\\n        \\n        for(int x : hash.keySet()){       //Iterate through \\'keys\\' of HashMap\\n            if(hash.get(x)==1)            //if \\'value\\' for \\'key\\' is \\'1\\', then return that \\'key\\' element\\n                return x;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);                          //Sort the array\\n        for(int i=0 ; i<nums.length-1; i+=2){       \\n            if(nums[i]!=nums[i+1])                  //Check pairwise values in array\\n                return nums[i];                     //if any pairwise values are different, then it is answer\\n        }\\n        return nums[nums.length - 1];       //if answer is largest value, then it will not be detected in above loop hence return it here\\n   }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int x: nums){\\n            result = result ^ x;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558787,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        r=nums[0]\\n        for i in range(1,n):\\n            r = r ^ nums[i] \\n\\n        return r\\n```\\n\\t\\t\\n\\t\\nexplanation:-\\nLet ^ be xor operator as in python 3\\n\\nr = 7 ^ 3 ^ 5 ^ 4 ^ 5 ^ 3 ^ 4\\n\\nSince XOR is associative and commutative, above \\nexpression can be written as:\\nr = 7 ^ (3 ^ 3) ^ (4 ^ 4) ^ (5 ^ 5)  \\n    = 7 ^ 0 ^ 0 ^ 0\\n    = 7 ^ 0\\n    = 7",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        r=nums[0]\\n        for i in range(1,n):\\n            r = r ^ nums[i] \\n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43209,
                "title": "non-bitwise-java-solution-using-set",
                "content": "    public int singleNumber(int[] A) {\\n            \\n           Set<Integer> s = new HashSet<Integer>();\\n    \\t    for (int i: A){\\n    \\t    \\tif(!s.add(i)){\\n    \\t    \\t\\ts.remove(i);\\n    \\t    \\t}\\n    \\t    }\\n    \\t    return s.iterator().next();\\n            \\n        }",
                "solutionTags": [],
                "code": "    public int singleNumber(int[] A) {\\n            \\n           Set<Integer> s = new HashSet<Integer>();\\n    \\t    for (int i: A){\\n    \\t    \\tif(!s.add(i)){\\n    \\t    \\t\\ts.remove(i);\\n    \\t    \\t}\\n    \\t    }\\n    \\t    return s.iterator().next();\\n            \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 43217,
                "title": "java-solution-with-explanation",
                "content": "    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res = res^nums[i];\\n        }\\n        return res;\\n    }\\n\\n\\n----------\\nidea: for every bit, use bit manipulation. 0^0^0 = 0, 1^1^1 = 1, 0^0^1 = 1, 1^1^0 = 0. Thus, after the bit manipulation of XOR, the every bit of result is the bit of single number.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res = res^nums[i];\\n        }\\n        return res;\\n    }\\n\\n\\n----------\\nidea: for every bit, use bit manipulation. 0^0^0 = 0, 1^1^1 = 1, 0^0^1 = 1, 1^1^0 = 0. Thus, after the bit manipulation of XOR, the every bit of result is the bit of single number.",
                "codeTag": "Unknown"
            },
            {
                "id": 690738,
                "title": "python-o-1-space-simple-solution-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : XOR ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # If we take XOR of zero and some bit, it will return that bit\\n        # a XOR 0 = a, a XOR 0=a\\n        # If we take XOR of two same bits, it will return 0\\n        # a XOR a = 0 a XOR a=0\\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b \\n        # a\\u2295b\\u2295a=(a\\u2295a)\\u2295b=0\\u2295b=b\\n        # So we can XOR all bits together to find the unique number.\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        ## RC ##\\n        ## APPROACH : XOR ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n        \\n        # If we take XOR of zero and some bit, it will return that bit\\n        # a XOR 0 = a, a XOR 0=a\\n        # If we take XOR of two same bits, it will return 0\\n        # a XOR a = 0 a XOR a=0\\n        # a XOR b XOR a = (a XOR a) XOR b = 0 XOR b = b \\n        # a\\u2295b\\u2295a=(a\\u2295a)\\u2295b=0\\u2295b=b\\n        # So we can XOR all bits together to find the unique number.\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387175,
                "title": "python-3-xor-explanation",
                "content": "This problem asks us to solve it in **O(n) time** and **O(1) space**. \\n\\nThe best way to do this is to use **XOR (\\u2295)** operations (`^` in Python), because there are two benefits from XOR operation:\\n\\n1. **The XOR of any two identical numbers is 0.** For example, `0101 ^ 0101 = 0000`.\\n2. **The XOR of any number and 0 is the number itself.** For example, `0101 ^ 0000 = 0101`\\n\\nIn addition, XOR operations are associative and commutative; therefore, the operations can be written in the following form:\\n\\n```\\n    4 ^ 1 ^ 2 ^ 1 ^ 2\\n=   4 ^ 1 ^ 1 ^ 2 ^ 2      (commutativity)\\n=   4 ^ (1 ^ 1) ^ (2 ^ 2)  (associativity)\\n=   4 ^ 0 ^ 0\\n=   4\\n```\\n\\n\\n``` py\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        z = nums[0]\\n        for num in nums[1:]:\\n            z^= num\\n        return z\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n    4 ^ 1 ^ 2 ^ 1 ^ 2\\n=   4 ^ 1 ^ 1 ^ 2 ^ 2      (commutativity)\\n=   4 ^ (1 ^ 1) ^ (2 ^ 2)  (associativity)\\n=   4 ^ 0 ^ 0\\n=   4\\n```\n``` py\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        z = nums[0]\\n        for num in nums[1:]:\\n            z^= num\\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43028,
                "title": "one-line-python-solution-with-o-n-time",
                "content": "    return reduce(lambda x, y: x ^ y, nums)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    return reduce(lambda x, y: x ^ y, nums)",
                "codeTag": "Unknown"
            },
            {
                "id": 3197054,
                "title": "very-simple-and-easy-solution",
                "content": "# Intuition\\nThe sort method is called on the nums array, which modifies the original array in place to sort it in ascending order. This is not necessary for the solution, but it does make it easier to find the single number by grouping all of the duplicate numbers together.\\n\\nThe for loop iterates over the arr array by 2, comparing each pair of adjacent elements.\\n\\nIf a non-matching pair of adjacent elements is found, the first element in the pair is returned as the single number.\\n\\nIf no non-matching pair is found, the last element in the array is returned as the single number, since it must be the only element that does not have a matching pair.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function (nums) {\\n  let arr = nums.sort((a, b) => a - b); // Create a copy of the array and sort it\\n\\n  for (let i = 0; i <= nums.length - 1; i += 2) { // Iterate by 2\\n    if (arr[i] !== arr[i + 1]) {\\n      return arr[i];\\n    }\\n  }\\n\\n  return arr[arr.length - 1];  // Return the first non-matching pair\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/19f45496-d52e-4b20-928b-3e16c79afc98_1676631777.988186.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function (nums) {\\n  let arr = nums.sort((a, b) => a - b); // Create a copy of the array and sort it\\n\\n  for (let i = 0; i <= nums.length - 1; i += 2) { // Iterate by 2\\n    if (arr[i] !== arr[i + 1]) {\\n      return arr[i];\\n    }\\n  }\\n\\n  return arr[arr.length - 1];  // Return the first non-matching pair\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641351,
                "title": "python-3-easy-solution-in-one-line-without-using-xor",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(list(set(nums)) * 2) - sum(nums)\\n```\\n\\nIf you find XOR hard to understand, then maybe use this solution instead.\\n\\nGive me some upvote if you like the solution! Cheers!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(list(set(nums)) * 2) - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396584,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n)\\n// space O(n)\\nfunction singleNumber(nums) {\\n  const map = {};\\n  for (let n of nums) {\\n    if (map[n] == null) map[n] = 0;\\n    map[n]++;\\n  }\\n\\n  for (let n in map) {\\n    if (map[n] === 1) return Number(n);\\n  }\\n}\\n```\\n\\n```\\n// time O(n)\\n// space O(1)\\nfunction singleNumber(nums) {\\n  let num = 0;\\n  for (let n of nums) {\\n    num ^= n;\\n  }\\n  return num;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n)\\n// space O(n)\\nfunction singleNumber(nums) {\\n  const map = {};\\n  for (let n of nums) {\\n    if (map[n] == null) map[n] = 0;\\n    map[n]++;\\n  }\\n\\n  for (let n in map) {\\n    if (map[n] === 1) return Number(n);\\n  }\\n}\\n```\n```\\n// time O(n)\\n// space O(1)\\nfunction singleNumber(nums) {\\n  let num = 0;\\n  for (let n of nums) {\\n    num ^= n;\\n  }\\n  return num;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1771869,
                "title": "python-simple-python-solution-with-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 with XOR Operation :-\\n# Runtime: 144 ms, faster than 64.43% of Python3 online submissions for Single Number.\\n# Memory Usage: 18.9 MB, less than 76.74% of Python3 online submissions for Single Number.\\n\\n# XOR Concept : -\\n\\t0 ^ 0 = 0\\n\\t0 ^ 1 = 1\\n\\t1 ^ 0 = 1\\n\\t1 ^ 1 = 0\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tresult = result ^ num\\n\\n\\t\\t\\treturn result \\n\\n# Approach 2 with Counting Frequency :-\\n# Runtime: 140 ms, faster than 79.48% of Python3 online submissions for Single Number.\\n# Memory Usage: 19 MB, less than 54.30% of Python3 online submissions for Single Number.\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tfrequency = {}\\n\\n\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\tif num not in frequency:\\n\\n\\t\\t\\t\\t\\tfrequency[num] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tfrequency[num] = frequency[num] + 1\\n\\n\\t\\t\\tfor key in frequency:\\n\\n\\t\\t\\t\\tif frequency[key] == 1:\\n\\n\\t\\t\\t\\t\\treturn key\\t\\t\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tresult = result ^ num\\n\\n\\t\\t\\treturn result \\n\\n# Approach 2 with Counting Frequency :-\\n# Runtime: 140 ms, faster than 79.48% of Python3 online submissions for Single Number.\\n# Memory Usage: 19 MB, less than 54.30% of Python3 online submissions for Single Number.\\n\\n\\tclass Solution:\\n\\t\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tfrequency = {}",
                "codeTag": "Java"
            },
            {
                "id": 43229,
                "title": "maybe-the-shortest-java-solution",
                "content": "    public class Solution {\\n        public int singleNumber(int[] A) {\\n            int a=0;\\n            for(int i:A)\\n                a^=i;\\n            return a;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            int a=0;\\n            for(int i:A)\\n                a^=i;\\n            return a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43154,
                "title": "easy-c-solution",
                "content": "\\n     int singleNumber(int* nums, int numsSize) {\\n     int x = 0;\\n     int i = 0;\\n     for (i = 0; i<numsSize;i++)\\n     {\\n       x=x^nums[i];\\n     }\\n     return x;\\n    }",
                "solutionTags": [],
                "code": "\\n     int singleNumber(int* nums, int numsSize) {\\n     int x = 0;\\n     int i = 0;\\n     for (i = 0; i<numsSize;i++)\\n     {\\n       x=x^nums[i];\\n     }\\n     return x;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43052,
                "title": "strongly-recommended-support-scala-language",
                "content": "and here is the code for solve the single number, and using scala language is just only one line of code. With now, functional programming is very popular in big data area. So, I strongly recommended the leecode support the compiler compatible with scala. \\n\\n     def singleNumber(nums:Array[Int]): Int = {\\n        nums.foldLeft(0)(_^_)\\n      }\\n    \\n      val arr = Array(1,2,2,3,3,4,5,6,6,5,4,1,9)\\n      println(singleNumber(arr))\\n\\nAnd another example can directly show more message , and just needs a tuple. I show you with this is wish to tell you that scala can support more message and expressive.\\n\\n    def hummingWeight(n: Int): (Int, ArrayBuffer[Int]) = {\\n        val arrBuffer = ArrayBuffer[Int]()\\n        var alt_n = n\\n        var count = 0\\n        while (alt_n > 0) {\\n          if ((alt_n & 1) == 1){\\n            count+=1\\n            arrBuffer += 1\\n          } else {\\n            arrBuffer += 0\\n          }\\n          alt_n >>= 1\\n        }\\n        (count, arrBuffer.reverse)\\n      }\\n      println (hummingWeight(2147483647))\\n    }\\n\\nAnd the output like following\\n\\n    (31,ArrayBuffer(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))",
                "solutionTags": [],
                "code": "and here is the code for solve the single number, and using scala language is just only one line of code. With now, functional programming is very popular in big data area. So, I strongly recommended the leecode support the compiler compatible with scala. \\n\\n     def singleNumber(nums:Array[Int]): Int = {\\n        nums.foldLeft(0)(_^_)\\n      }\\n    \\n      val arr = Array(1,2,2,3,3,4,5,6,6,5,4,1,9)\\n      println(singleNumber(arr))\\n\\nAnd another example can directly show more message , and just needs a tuple. I show you with this is wish to tell you that scala can support more message and expressive.\\n\\n    def hummingWeight(n: Int): (Int, ArrayBuffer[Int]) = {\\n        val arrBuffer = ArrayBuffer[Int]()\\n        var alt_n = n\\n        var count = 0\\n        while (alt_n > 0) {\\n          if ((alt_n & 1) == 1){\\n            count+=1\\n            arrBuffer += 1\\n          } else {\\n            arrBuffer += 0\\n          }\\n          alt_n >>= 1\\n        }\\n        (count, arrBuffer.reverse)\\n      }\\n      println (hummingWeight(2147483647))\\n    }\\n\\nAnd the output like following\\n\\n    (31,ArrayBuffer(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1))",
                "codeTag": "Python3"
            },
            {
                "id": 509005,
                "title": "my-javascript-solution-56ms",
                "content": "```\\nvar singleNumber = function(nums) {\\n    let hash = {}\\n    for(let val of nums){\\n        hash[val]?delete hash[val]:hash[val]=1;\\n    }\\n    return Object.keys(hash)[0]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNumber = function(nums) {\\n    let hash = {}\\n    for(let val of nums){\\n        hash[val]?delete hash[val]:hash[val]=1;\\n    }\\n    return Object.keys(hash)[0]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43114,
                "title": "one-liner-in-js",
                "content": "```\\nvar singleNumber = function(nums) {\\n    return nums.reduce((a, b) => a^b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    return nums.reduce((a, b) => a^b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43197,
                "title": "o-n-using-xor-in-java-for-single-number-problem",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = nums[0];\\n            for (int i = 1; i < nums.length; i++)\\n                res = res ^ nums[i];\\n    \\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int res = nums[0];\\n            for (int i = 1; i < nums.length; i++)\\n                res = res ^ nums[i];\\n    \\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1771956,
                "title": "simple-3-approaches-easy-to-understand",
                "content": "**Approach 1 = Using HashSet  ==>   TC = O(n)   SC=O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tHashSet<Integer> set = new HashSet<Integer>();\\n\\t\\t\\tfor(int i : nums) {\\n\\t\\t\\t\\tif(set.contains(i)) {\\n\\t\\t\\t\\t\\tset.remove(i);\\n\\t\\t\\t\\t} else{\\n\\t\\t\\t\\t\\tset.add(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i:set) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\n**Approach 2 = Using Sorting  ==> TC: O(NlogN)    SC: O(1)** \\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tfor(int i = 1; i < nums.length; i+=2) {\\n\\t\\t\\t\\tif(nums[i] != nums[i-1]) {\\n\\t\\t\\t\\t\\treturn nums[i-1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums[nums.length-1];\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n**Approach 3 = Using XOR  ==>  TC: O(N)   SC: O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int x : nums)\\n\\t\\t\\t\\tans^=x;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0\\uD83C\\uDF38), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic int singleNumber(int[] nums) {\\n\\t\\t\\tHashSet<Integer> set = new HashSet<Integer>();\\n\\t\\t\\tfor(int i : nums) {\\n\\t\\t\\t\\tif(set.contains(i)) {\\n\\t\\t\\t\\t\\tset.remove(i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 43081,
                "title": "simple-c-solution",
                "content": "class Solution \\n{public:\\n\\n    int singleNumber(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); ++i) nums[0] ^= nums[i];\\n        \\n        return nums[0];\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{public:\\n\\n    int singleNumber(vector<int>& nums) {\\n        \\n        for(int i = 1; i < nums.size(); ++i) nums[0] ^= nums[i];\\n        \\n        return nums[0];\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 43196,
                "title": "c-implementation-using-xor",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            // XOR (^) is both commutative and associative \\n            // The numbers which appear twice will be cancelled\\n            // Only the number that appear twice survive \\n            int value = 0;\\n            int i, n;\\n            n = nums.size();\\n            for(i=0; i<n; i++)\\n                value = value ^ nums[i];\\n            return value;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            // XOR (^) is both commutative and associative \\n            // The numbers which appear twice will be cancelled\\n            // Only the number that appear twice survive \\n            int value = 0;\\n            int i, n;\\n            n = nums.size();\\n            for(i=0; i<n; i++)\\n                value = value ^ nums[i];\\n            return value;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43215,
                "title": "o-n-solution-using-bit-operation-only-22-characters",
                "content": "    def singleNumber(self, A):\\n        r = 0\\n        for i in A:\\n            r ^= i\\n        return r",
                "solutionTags": [],
                "code": "    def singleNumber(self, A):\\n        r = 0\\n        for i in A:\\n            r ^= i\\n        return r",
                "codeTag": "Python3"
            },
            {
                "id": 899031,
                "title": "easy-python-solution-o-n-time-and-o-1-space-explanation",
                "content": "The idea is when you XOR a number with itself (since it will appear TWICE only )it will result in a 0, so when you XOR all the elements the end result will be the element that is appearing once only\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res=0\\n        for n in nums:\\n            res^=n\\n        return res    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res=0\\n        for n in nums:\\n            res^=n\\n        return res    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 43185,
                "title": "my-c-solution-using-unordered-set-int",
                "content": "\\n        unordered_set<int> mySet;\\n        for(int i = 0;i < nums.size();++i){\\n            if(mySet.find(nums[i]) == mySet.end()) mySet.insert(nums[i]);\\n            else mySet.erase(nums[i]);\\n        }\\n        auto it = mySet.begin();\\n        return *it;",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n        unordered_set<int> mySet;\\n        for(int i = 0;i < nums.size();++i){\\n            if(mySet.find(nums[i]) == mySet.end()) mySet.insert(nums[i]);\\n            else mySet.erase(nums[i]);\\n        }\\n        auto it = mySet.begin();\\n        return *it;",
                "codeTag": "Unknown"
            },
            {
                "id": 43060,
                "title": "only-one-line-python-solution",
                "content": "reduce(func, A) means: func(func(A[0], A[1]), A[2])...\\n\\nSo the reduce function below just return all elements' XOR value, that is our single number.\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        return reduce(lambda x, y: x ^ y, A)",
                "solutionTags": [],
                "code": "reduce(func, A) means: func(func(A[0], A[1]), A[2])...\\n\\nSo the reduce function below just return all elements' XOR value, that is our single number.\\n\\n    class Solution:\\n    # @param A, a list of integer\\n    # @return an integer\\n    def singleNumber(self, A):\\n        return reduce(lambda x, y: x ^ y, A)",
                "codeTag": "Java"
            },
            {
                "id": 1938482,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ans = 0\\n        for num in nums { ans ^= num }\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var ans = 0\\n        for num in nums { ans ^= num }\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075088,
                "title": "simplest-solution-for-beginners",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if(nums.count(i) == 1):\\n                return(i)\\n```\\n**Please upvote if you like it**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if(nums.count(i) == 1):\\n                return(i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43049,
                "title": "javascript-solution",
                "content": "Javascript Solution / 102ms Runtime\\n```\\nvar singleNumber = function(nums) {\\n    var result = nums[0];\\n    for(var i = 1; i < nums.length; i++) {\\n        result = result^nums[i];\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    var result = nums[0];\\n    for(var i = 1; i < nums.length; i++) {\\n        result = result^nums[i];\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43140,
                "title": "xor-java-solution",
                "content": "    public class Solution {\\n        public int singleNumber(int[] nums) {\\n            int result = 0;\\n            for(int i = 0;i<nums.length;i++){\\n            result = result ^ nums[i];\\n            }\\n            return result;\\n    }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int singleNumber(int[] nums) {\\n            int result = 0;\\n            for(int i = 0;i<nums.length;i++){\\n            result = result ^ nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 43222,
                "title": "java-solution-using-xor",
                "content": "    public int singleNumber(int[] nums) {\\n      int ans = 0;\\n            \\n      for (int i = 0; i < nums.length; i++)\\n        ans ^= nums[i];\\n            \\n      return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int singleNumber(int[] nums) {\\n      int ans = 0;\\n            \\n      for (int i = 0; i < nums.length; i++)\\n        ans ^= nums[i];\\n            \\n      return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1772428,
                "title": "c-3-approaches-beginner-friendly-easy-and-intuitive-well-explained",
                "content": "## **Approach 1: Frequency Counting + Linear Traversal (Hashmap or Frequency Array)**\\nSo the very first brute force approach that comes to our mind after reading this question is that we can count the frequency of each element in the array and then find the element with frequency as 1.\\n\\n#### Example: \\n\\n![image](https://assets.leetcode.com/users/images/44b16506-49ab-4a4c-aeca-736b8b3c2f34_1644902604.556138.jpeg)\\n\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> elementToFreqMap; //key=element of nums array, value=freq of that element in the nums array\\n        \\n        for(int num: nums){\\n            elementToFreqMap[num]++;\\n        }\\n        \\n        for(auto it: elementToFreqMap){\\n            if(it.second==1) return it.first;\\n        }\\n        \\n        return -1;\\n    }\\n```\\n\\n#### Complexity:\\n***TC* = O(n)**[traversal of whole array] **+ O(n/2 + 1)**[traversal of map, as all elements appear twice except 1, so there will be (n/2)+1 distinct keys int the map to traverse]  **=  O(n)**\\n***SC* = O(n/2 +1)**[space taken by the map] **= O(n)**\\n\\n**************************************************************************************\\n\\n## **Approach 2: Sorting + Linear traversal**\\nIt is essentially kind of counting for the frequency only, but here we will not be using extra space.\\n1. The idea is to sort the elements and then start traversing the array in a way that we check `every second element` in the array starting from index 1.\\n\\n2. If that element is similar to its previous element, then that is not our answer, so continue finding the answer.\\n\\n3. Else if the element if not equal to its previous element, then that means, the frequency of this element is 1 in the array, so this element is our ans. Therefore return this element.\\n\\n4. As the `array will always be odd` (let there be k elements in the array which occur twice and 1 element which occurs only once, that means the length of array will be 2k+1, which is always odd) therefore the `indices will range from 0 to 2k` (last index being even), and we are traversing every other element starting from index 1. So the indices we are looking at are 1, 3, 5, 7... (all odd indices). Now if we come out of loop with no answer as of now, then we can clearly say that the element at the last index is our answer because it is the only index we didnot look at and as it is sure that there is exactly one element which is our answer. So return the last element of the sorted array, if you didnot find the ans inside the loop. **[Hope you got this]**\\n\\n#### Example (Dry Run):\\n\\n![image](https://assets.leetcode.com/users/images/1cf30585-0e07-43a4-82fb-f7e8aaed7752_1644904686.652919.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/24510508-d5f5-4d42-b406-0b6f56e7d3ac_1644904700.7419345.jpeg)\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       sort(nums.begin() ,nums.end());\\n        \\n        for(int i=1; i<nums.size(); i+=2){ //i+=2 as we want to check every other element\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1]; //if we didnot find answer in the loop, so return the last element.\\n    }\\n```\\n\\n#### Complexity:\\n***TC*** **= O(nlogn)**[because of sorting] **+ O(n/2)**[traversing every other element of array] **= O(nlogn)**\\n***SC*** **= O(1)** [no extra space being used]\\n\\n*************************************************************************************\\n\\n## **Approach 3: Bit Manipulation (XOR)**\\nFirst let us look at the truth table for XOR :-\\n\\n![image](https://assets.leetcode.com/users/images/c15fc714-37a8-4c8d-9eb2-f7ad7ac5f37b_1644905576.1700804.jpeg)\\n\\nFrom the table we can conclude 2 things \\n`OBS1: If both the bits are same (either both 1 or both 0) then the result of XOR is 0, and if both the bits are different (one of them is 1 and other is 0) then the result of XOR is 1`\\n\\n`OBS2: Any bit \\'a\\' when xored with 0, gives the original bit itself. That means a^0 = 0^a = a.`\\n\\nAlso from OBS1 we can conclude one more thing that\\n\\n`OBS3: For any number \\'a\\', its xor with itself will result in 0. That means, a^a=0.`\\nWhy?? Look at this example\\n\\n![image](https://assets.leetcode.com/users/images/42916f13-104b-4643-90c2-9244f2b9b3e2_1644906064.9595697.jpeg)\\n\\nAs we can see that xoring a number with itself will result in same bits at every place, because of which in the ans there will be 0s at every place, making the answer as 0.\\n\\nSo till now we have made 2 observations which will help us building the logic for this approach:\\n\\n`a^a = 0      ...(i)`\\n`0^a = a^0 = a      ...(ii)`\\n\\nNow, let\\'s come to the question...\\nWe know that in the array all the elements appear twice except one element.\\n`So, if we xor all the elements of the array then the result will be the element which occurs only once!`\\nWhy??\\n\\nLook at this example:\\n\\n#### Example:\\n![image](https://assets.leetcode.com/users/images/ebbacfc8-57de-408e-a9c9-91c6e5246edd_1644908267.6280568.jpeg)\\n\\n`So, in simple layman terms we can say that all the elements which occur twice will cancel each other out, and hence we will be left with the element which doesn\\'t have its counter to cancel it. That means we will be left with the element which occurs only once. And this will be our answer.`\\n\\n#### Code:\\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       int xorOfAllElements = 0;\\n        \\n        for(int num: nums)\\n            xorOfAllElements ^= num;\\n        \\n        return xorOfAllElements; //At the end this xor will be containing our answer.\\n    }\\n```\\n\\n#### Complexity:\\n***TC*** **= O(n)** [traversing all the elements of the array]\\n***SC*** **= O(1)** [no extra space used]\\n\\n\\n***Plz upvote the post, if you found it useful***\\n\\n\\n \\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```cpp\\nint singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> elementToFreqMap; //key=element of nums array, value=freq of that element in the nums array\\n        \\n        for(int num: nums){\\n            elementToFreqMap[num]++;\\n        }\\n        \\n        for(auto it: elementToFreqMap){\\n            if(it.second==1) return it.first;\\n        }\\n        \\n        return -1;\\n    }\\n```\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       sort(nums.begin() ,nums.end());\\n        \\n        for(int i=1; i<nums.size(); i+=2){ //i+=2 as we want to check every other element\\n            if(nums[i]!=nums[i-1])\\n                return nums[i-1];\\n        }\\n        return nums[nums.size()-1]; //if we didnot find answer in the loop, so return the last element.\\n    }\\n```\n```cpp\\nint singleNumber(vector<int>& nums) { \\n       int xorOfAllElements = 0;\\n        \\n        for(int num: nums)\\n            xorOfAllElements ^= num;\\n        \\n        return xorOfAllElements; //At the end this xor will be containing our answer.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 834955,
                "title": "2-different-approach-xor-map-3-lines-code",
                "content": "Property of XOR (exclusive or) a^a=0 and a^0=a , based on this we can say XOR of any number which is occuring even number of times will give zero and after this if any number which is occuring single time will be the answer.\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto i : nums) ans = ans ^ i;\\n        return ans;\\n    }\\n};\\n```\\n* Using unordered map\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i : nums) mp[i]++;\\n        \\n        for(auto i : mp)\\n            if(i.second == 1) return i.first;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto i : nums) ans = ans ^ i;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i : nums) mp[i]++;\\n        \\n        for(auto i : mp)\\n            if(i.second == 1) return i.first;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114402,
                "title": "hashmap-in-java",
                "content": "XOR is cool. I solved this question with HashMap in JAVA.\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i],1);\\n            }\\n            else {\\n                map.put(nums[i],map.get(nums[i]) + 1);\\n            }\\n        }\\n        for ( Map.Entry<Integer,Integer> entry : map.entrySet()) {\\n            Integer key = entry.getKey();\\n            Integer value = entry.getValue();\\n            if (map.get(key) == 1) {\\n                return key;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i],1);\\n            }\\n            else {\\n                map.put(nums[i],map.get(nums[i]) + 1);\\n            }\\n        }\\n        for ( Map.Entry<Integer,Integer> entry : map.entrySet()) {\\n            Integer key = entry.getKey();\\n            Integer value = entry.getValue();\\n            if (map.get(key) == 1) {\\n                return key;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103877,
                "title": "java-simple-solution",
                "content": "> Please Upvote if this Solution Helps You\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    count++;\\n                }\\n            }\\n            if (count == 1) {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] == nums[j]) {\\n                    count++;\\n                }\\n            }\\n            if (count == 1) {\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474244,
                "title": "c-o-1-space-o-n-time-easiest-explanation-3-lines-of-code",
                "content": "# **Logic ( XOR OPERATION )**\\n\\n- Before going into the solution, let\\'s recall some facts about the XOR operation. If you don\\'t understand any point down below, try to callibrate that point by yourself, and still don\\'t tell me in the comments section. I will try to help you out there. :)\\n- XOR operation of any number with 0 gives the number itself.\\n- XOR operation of same numbers appearing even number of times gives 0.\\n- Now let\\'s move to the solution part\\n    - As every number comes twice in the array the XOR of all those duplicates will boil down to 0.\\n    - As the result of all those duplicates values is 0, XOR of the result (0) with the only single element will give that number itself (SEE THE POINT Number 2 FROM TOP)\\n    - Bingo, you get that number, SEE it\\'s peaceful man :)\\n\\n```cpp\\nint singleNumber(vector<int>& nums) {\\n    int num=0;\\n    for(auto &i : nums) num ^= i;\\n    return num;\\n}\\n\\n```\\n\\n\\n\\n**Like it? please upvote...\\nHave any comments? I\\'d love to hear!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint singleNumber(vector<int>& nums) {\\n    int num=0;\\n    for(auto &i : nums) num ^= i;\\n    return num;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3353219,
                "title": "java-code-that-beat-100-of-the-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n        This can be easily solved with XOR. \\n        When a number is XORed by the same number, the result is 0. \\n        We can leverage this to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        We just need loop through the elements, XOR them one by one \\n        and add them.\\n        At the end, only the non repeating number remains because it is \\n        the only non duplicate number.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // easily solved with XOR; when the same number is XORed, the result is 0. \\n        // just loop through the elements and XOR them; the non repeating number remains.\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        // easily solved with XOR; when the same number is XORed, the result is 0. \\n        // just loop through the elements and XOR them; the non repeating number remains.\\n        int ans =0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43089,
                "title": "java-solution-in-3-lines-o-n-and-without-extra-space",
                "content": "A simple solution, using 2 properties of XOR: **A \\u2295 A = 0** and **B \\u2295 0 = B**\\nIn other words, **A \\u2295 A \\u2295 B = B**\\n\\n```\\npublic int singleNumber(int[] nums) {\\n  for(int i=0;i<nums.length-1;i++){\\n    nums[i+1] ^= nums[i];\\n  }\\n  return nums[nums.length-1];\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "A simple solution, using 2 properties of XOR: **A \\u2295 A = 0** and **B \\u2295 0 = B**\\nIn other words, **A \\u2295 A \\u2295 B = B**\\n\\n```\\npublic int singleNumber(int[] nums) {\\n  for(int i=0;i<nums.length-1;i++){\\n    nums[i+1] ^= nums[i];\\n  }\\n  return nums[nums.length-1];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 43200,
                "title": "c-solution-using-xor",
                "content": "Duplicates will be 0 with xor operations. res xor num is num. The one left in the end is the unique one.\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res = 0;\\n            for (int n : nums) res ^= n;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res = 0;\\n            for (int n : nums) res ^= n;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43290,
                "title": "linear-but-uses-extra-spaces-accepted-but-needs-improvement-welcome-suggestions",
                "content": "Below is my code. I used a set to record a new element and add it to the sum; if the element shows up again, delete it from the set and subtract it from the sum. At the end, the sum will be the single element.\\nThanks for comments and suggestions.\\n\\n    public class Solution {\\n      public static int singleNumber(int[] A) {\\n        int single = 0;\\n        Set<Integer> s = new TreeSet<Integer>();\\n        for (int i : A) {\\n          if (s.contains(i)) {\\n            single = single - i;\\n            s.remove(i);\\n          } else {\\n            s.add(i);\\n            single = single + i;\\n          }\\n        }\\n      return single;\\n      }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n      public static int singleNumber(int[] A) {\\n        int single = 0;\\n        Set<Integer> s = new TreeSet<Integer>();\\n        for (int i : A) {\\n          if (s.contains(i)) {\\n            single = single - i;\\n            s.remove(i);\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 3524018,
                "title": "c-java-python-javascript-fully-explained-easy-to-understand",
                "content": "# Intuition:\\nThe given problem asks us to find the number that appears only once in the given vector of integers. We can solve this problem using the bitwise XOR operation.\\n\\n# Approach:\\n1. Initialize a variable `c` to 0. This variable will store the XOR of all the elements in the vector.\\n2. Iterate through each element `num` in the vector.\\n   - Update `c` by performing `c = c ^ num`. This XOR operation will cancel out the duplicate occurrences of the numbers, leaving only the number that appears only once.\\n3. After the loop, the value of `c` will be the number that appears only once.\\n4. Return `c` as the result.\\n\\n# Complexity:\\n- Time Complexity: O(n), where n is the size of the input vector `nums`. We iterate through each element once.\\n- Space Complexity: O(1), as we are using a constant amount of extra space.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            c= c^nums[i];\\n        }\\n            return c;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            c = c ^ nums[i];\\n        }\\n        return c;\\n    }\\n}\\n\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        n = len(nums)\\n        c = 0\\n        for i in range(n):\\n            c = c ^ nums[i]\\n        return c\\n\\n```\\n---\\n# JavaScript\\n```\\nvar singleNumber = function(nums) {\\n    let n = nums.length;\\n    let c = 0;\\n    for (let i = 0; i < n; i++) {\\n        c = c ^ nums[i];\\n    }\\n    return c; \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            c= c^nums[i];\\n        }\\n            return c;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for (int i = 0; i < n; i++) {\\n            c = c ^ nums[i];\\n        }\\n        return c;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        n = len(nums)\\n        c = 0\\n        for i in range(n):\\n            c = c ^ nums[i]\\n        return c\\n\\n```\n```\\nvar singleNumber = function(nums) {\\n    let n = nums.length;\\n    let c = 0;\\n    for (let i = 0; i < n; i++) {\\n        c = c ^ nums[i];\\n    }\\n    return c; \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795592,
                "title": "java-1-problem-5-solutions-easy",
                "content": "# Please Upvote :D\\n---\\n##### 1. Sorting:\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n\\n        for (int i = 1; i < nums.length; i += 2) {\\n            if (nums[i] != nums[i - 1]) {\\n                return nums[i - 1];\\n            }\\n        }\\n\\n        return nums[nums.length - 1];\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```\\n---\\n##### 2. Bit-Manipulation (XOR):\\n* `0^a = a`\\n* `a^b`\\n* `a^b^a = (a^a)^b = 0^b`\\n* In this way only the number which is unique (lets say b) remains till the end.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for (int n : nums) ans ^= n;\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n\\n##### 3. Using HashMap:\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        for (int n : map.keySet()) {\\n            if (map.get(n) == 1) {\\n                return n;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 4. Using HashSet:\\nKeep removing elements when found to be already existing in the set.\\nThe one which is not duplicate will never be removed from the set.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            if (set.contains(n)) {\\n                set.remove(n);\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n\\n        return set.iterator().next();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 5. Using ArrayList:\\nKeep removing elements when found to be already existing in the list.\\nThe one which is not duplicate will never be removed from the list.\\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int n : nums) {\\n            if (list.contains(n)) {\\n                list.remove(Integer.valueOf(n));\\n            } else {\\n                list.add(n);\\n            }\\n        }\\n\\n        return list.get(0);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        if (nums.length == 1) {\\n            return nums[0];\\n        }\\n\\n        for (int i = 1; i < nums.length; i += 2) {\\n            if (nums[i] != nums[i - 1]) {\\n                return nums[i - 1];\\n            }\\n        }\\n\\n        return nums[nums.length - 1];\\n    }\\n}\\n\\n// TC: O(n * logn) + O(n) => O(n * logn)\\n// SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for (int n : nums) ans ^= n;\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.put(n, map.getOrDefault(n, 0) + 1);\\n        }\\n\\n        for (int n : map.keySet()) {\\n            if (map.get(n) == 1) {\\n                return n;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : nums) {\\n            if (set.contains(n)) {\\n                set.remove(n);\\n            } else {\\n                set.add(n);\\n            }\\n        }\\n\\n        return set.iterator().next();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int n : nums) {\\n            if (list.contains(n)) {\\n                list.remove(Integer.valueOf(n));\\n            } else {\\n                list.add(n);\\n            }\\n        }\\n\\n        return list.get(0);\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772481,
                "title": "python-oneliner-solution-explained",
                "content": "There is straightforward hash-table solution with `O(n)` memory and time. We can also use bit manipulation trick to evaluate XOR of all numbers, which is what we need.\\n\\n#### Complexity\\nTime is `O(n)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(xor, nums)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(xor, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43164,
                "title": "java-solution-using-hashset-instead-of-xor",
                "content": "    public int singleNumber(int[] nums) {\\n        HashSet<Integer> check = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++)\\n            if(!check.remove(nums[i]))\\n                check.add(nums[i]);\\n        return check.iterator().next();\\n    }",
                "solutionTags": [],
                "code": "    public int singleNumber(int[] nums) {\\n        HashSet<Integer> check = new HashSet<Integer>();\\n        for(int i = 0; i < nums.length; i++)\\n            if(!check.remove(nums[i]))\\n                check.add(nums[i]);\\n        return check.iterator().next();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43240,
                "title": "four-lines-of-code-for-java",
                "content": "public class Solution {\\n    public int singleNumber(int[] A) {\\n        int result = 0;\\n        for (int i : A)\\n            result ^= i ;\\n        return result ;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] A) {\\n        int result = 0;\\n        for (int i : A)\\n            result ^= i ;\\n        return result ;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1771894,
                "title": "c-3-lines-memory-99-time-92-3-in-place",
                "content": "We all know a solution using XOR operation, maintaining the answer in a varible and returning it, but do we even need to use that one extra variable? \\n\\nWell no, and here\\'s how we can acheive it:\\n\\n```\\nclass Solution {\\npublic:\\n  int singleNumber(vector<int>& nums) {\\n    for(int i=1;i<nums.size();i++)\\n      nums[i] = nums[i]^nums[i-1];\\n    return nums[nums.size()-1];\\n  }\\n};\\n```\\n\\nHave a good day :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int singleNumber(vector<int>& nums) {\\n    for(int i=1;i<nums.size();i++)\\n      nums[i] = nums[i]^nums[i-1];\\n    return nums[nums.size()-1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570604,
                "title": "c-xor-solution-16-ms-17-mb",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans ^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans ^= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133245,
                "title": "javascript-o-n-speed-and-o-n-space-solution-easy-to-read",
                "content": "```\\nfunction singleNumber (nums) {\\n  const memo = new Set();\\n\\n  for (let num of nums) {\\n    if (memo.has(num)) {\\n      memo.delete(num);\\n    } else {\\n      memo.add(num);\\n    }\\n  }\\n\\n  return [...memo][0];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction singleNumber (nums) {\\n  const memo = new Set();\\n\\n  for (let num of nums) {\\n    if (memo.has(num)) {\\n      memo.delete(num);\\n    } else {\\n      memo.add(num);\\n    }\\n  }\\n\\n  return [...memo][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 559971,
                "title": "python-js-java-go-c-o-n-by-xor-w-hint",
                "content": "[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/651110b2fd89780001cb6c1d)\\n\\nPython O(n) sol by XOR. \\n\\n---\\n\\n**Hint**:\\n\\nUtilize the property of XOR, **A \\u2295 A = 0**, to cancel those elements which appeared twice.\\n\\n---\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        xor_result = 0\\n        for x in nums:\\n            xor_result ^= x\\n            \\n        return xor_result\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( lambda x, y: x^y, nums, 0)\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( operator.xor, nums, 0)\\n```\\n\\n---\\n\\nJava:\\n\\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int xorResult = 0;\\n        \\n        for( int number : nums ){\\n            xorResult ^= number;\\n        }\\n        \\n        return xorResult;\\n    }\\n}\\n\\n```\\n\\nor\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        // Java supports reduce in data stream\\n        return Arrays.stream( nums ).reduce( 0, (x, y) -> (x^y) );\\n    }\\n}\\n```\\n\\n---\\n\\nJavaScript:\\n\\n```\\nvar singleNumber = function(nums) {\\n    \\n    let xor_result = 0; \\n\\t\\n    for(let number of nums){\\n        \\n        xor_result ^= number;    \\n    }\\n    \\n    return xor_result;\\n};\\n```\\n\\nor\\n\\n\\n```\\nvar singleNumber = function(nums) {\\n        \\n    return nums.reduce( (x, y,) =>( x ^ y ), 0 );\\n};\\n```\\n\\n---\\n\\nGolang:\\n\\n```\\nfunc singleNumber(nums []int) int {\\n    \\n    xor_result := 0\\n    \\n    for _, number := range nums{\\n        \\n        xor_result ^= number\\n    }\\n    \\n    return xor_result\\n}\\n```\\n\\n---\\n\\nC++:\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int result = 0;\\n        \\n        for( const int& number : nums){\\n            result ^= number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nor\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        //C++ supports native bitwise xor operator \\n        return std::accumulate( nums.cbegin(), nums.cend(),0, std::bit_xor<int>() );\\n    }\\n};\\n```\\n\\nor\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         \\n        return std::accumulate( nums.cbegin(), nums.cend(),0,  [](int x, int y){return x^y ;} );\\n    }\\n};\\n```\\n\\n---\\n\\n[Wiki: XOR operator](https://en.wikipedia.org/wiki/Exclusive_or)\\n\\n[Python official docs about XOR operator](https://docs.python.org/3/reference/expressions.html#binary-bitwise-operations)\\n\\n[MDN official doscs about JavaScript XOR operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR)\\n\\n[Golang offical docs about XOR operator](https://go.dev/ref/spec#Arithmetic_operators)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        xor_result = 0\\n        for x in nums:\\n            xor_result ^= x\\n            \\n        return xor_result\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( lambda x, y: x^y, nums, 0)\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\n        return reduce( operator.xor, nums, 0)\\n```\n```\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        int xorResult = 0;\\n        \\n        for( int number : nums ){\\n            xorResult ^= number;\\n        }\\n        \\n        return xorResult;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        // Java supports reduce in data stream\\n        return Arrays.stream( nums ).reduce( 0, (x, y) -> (x^y) );\\n    }\\n}\\n```\n```\\nvar singleNumber = function(nums) {\\n    \\n    let xor_result = 0; \\n\\t\\n    for(let number of nums){\\n        \\n        xor_result ^= number;    \\n    }\\n    \\n    return xor_result;\\n};\\n```\n```\\nvar singleNumber = function(nums) {\\n        \\n    return nums.reduce( (x, y,) =>( x ^ y ), 0 );\\n};\\n```\n```\\nfunc singleNumber(nums []int) int {\\n    \\n    xor_result := 0\\n    \\n    for _, number := range nums{\\n        \\n        xor_result ^= number\\n    }\\n    \\n    return xor_result\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        int result = 0;\\n        \\n        for( const int& number : nums){\\n            result ^= number;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n        //C++ supports native bitwise xor operator \\n        return std::accumulate( nums.cbegin(), nums.cend(),0, std::bit_xor<int>() );\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n         \\n        return std::accumulate( nums.cbegin(), nums.cend(),0,  [](int x, int y){return x^y ;} );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288612,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var singleNumber = 0;\\n        foreach (var num in nums) {\\n            singleNumber ^= num;\\n        }\\n        return singleNumber;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var singleNumber = 0;\\n        foreach (var num in nums) {\\n            singleNumber ^= num;\\n        }\\n        return singleNumber;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43190,
                "title": "4-simple-lines-of-java",
                "content": "    public class Solution {\\n    public int singleNumber(int[] nums) {\\n        int r = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            r ^= nums[i];\\n        return r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int r = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            r ^= nums[i];\\n        return r;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3436371,
                "title": "easy-xor-soultion",
                "content": "# Intuition\\nI solved it via XOR bit operator\\n\\n# Approach\\nFor instance, I have an array [12, 1, 13, 1, 12]\\n1010\\n0001\\n\\n1011\\n1011\\n\\n0000\\n0001\\n\\n0001\\n1010\\n\\n1011 (bin) = 13 (dec)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int mask = 0;\\n\\n        for(int num : nums) {\\n            mask ^= num;\\n        }\\n\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int mask = 0;\\n\\n        for(int num : nums) {\\n            mask ^= num;\\n        }\\n\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500050,
                "title": "golang-without-auxiliary-variables",
                "content": "```\\nfunc singleNumber(nums []int) int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[0] ^= nums[i]\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc singleNumber(nums []int) int {\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tnums[0] ^= nums[i]\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541621,
                "title": "updated-python-xor-explained-resources",
                "content": "At first, recommend you to skim through the following resources:\\n1. https://www.interviewcake.com/table-of-contents#section_bit-manipulation_concept_not\\n2. https://leetcode.com/discuss/general-discussion/1073221/All-about-Bitwise-Operations-Beginner-Intermediate\\n\\n**Steps:**\\n\\ntake `[4,1,2,1,2]` as an example\\n\\n1. ^ will do addition in bitwise manner.\\n2. But why do we need `result=0`? Why not simply `result=nums[0]` and start iteration from the second? => As I mentioned in the beginning, it is an addition. So, taking 4 and 1, it will give 5. But with `result=0` it\\'ll give 4 at first,\\nthen we add 1 and 2.\\n3. But then, we find duplicates of 1 and 2 which will be subtracted. Why? ^ gives 0 when 2 similar numbers are applied:\\n* 8 ^ 8 = 0\\n\\nOkay, let me explain everything in more details.\\nTake binary representation: \\n0000: 0\\n0001: 1\\n0010: 2\\n0011: 3\\n0100: 4\\n0101: 5\\n0110: 6\\n0111: 7\\n1000: 8\\n1001: 9\\n1010: 10\\n\\nSo, let\\'s iterate over that array:\\n1. 0 ^ 4: we check bit by bit: 0 ^ 0 is 0 and 0 ^ 1 is 1, 1 ^ 1 is 0\\n\\t=> we get 0100 from it. To put it simply, 4\\n\\n2. 4 ^ 1: 0100 ^ 0001 => 0101 which is 5\\n3. 5 ^ 2:  0101 ^ 0010 => 0111 which is 7\\n4. 7 ^ 1: 0111 ^ 0001 => 0110 which is 6\\n5.  6 ^ 2: 0110 ^ 0010 => 0100 which is 4\\n\\nAnd 4 is our answer\\n\\t\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n        for num in nums:\\n            result ^= num\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        result = 0\\n        for num in nums:\\n            result ^= num\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434725,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        //even occurence will nullify\\n        for(int i=0;i<nums.length;i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        //even occurence will nullify\\n        for(int i=0;i<nums.length;i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279451,
                "title": "faster-than-100-00-bit-manipulation-explained",
                "content": "XOR operator is cumulative in nature i.e., say 5 ^ 3 ^ 5 is same as 5 ^ 5 ^ 3.\\nAlso XOR operation it return 0 for same operands : 1 ^ 1 = 0 and 0 ^ 0 = 0 then 5 ^ 5 = 0101 ^ 0101 = 0000.\\nEvery number repeats twice except the single number ,  so if we take the XOR of the entire array then all the duplicates would get cancelled out to 0 and the one that will be remaining will be our desired result. \\n\\n\\n```\\n public int singleNumber(int[] nums) {\\n    int single=0;\\n    for(int i=0;i<nums.length;i++)\\n        single=single^nums[i];\\n    return single;   \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n public int singleNumber(int[] nums) {\\n    int single=0;\\n    for(int i=0;i<nums.length;i++)\\n        single=single^nums[i];\\n    return single;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643075,
                "title": "3-swift-implementations",
                "content": "I wrote a blog post on how to solve this problem in Swift in 3 different ways: https://cocoaswiftly.com/leetcode-solutions/136-single-number/\\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    var numsSeen = Set<Int>()\\n\\n    for num in nums {\\n        // the insert operation returns a tuple, the first value of which is a bool,\\n        // indicating whether the insertion is successful\\n        if !numsSeen.insert(num).0 {\\n            numsSeen.remove(num)\\n        }\\n    }\\n    \\n    // it\\'s ok to force unwrap as a valid answer is guaranteed\\n    return numsSeen.first!\\n}\\n```\\n\\nor \\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    let distinctNums = Set(nums)\\n\\n    return distinctNums.reduce(0, +) * 2 - nums.reduce(0, +)\\n}\\n```\\n\\nor\\n\\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    return nums.reduce(0, ^)\\n}\\n```\\n\\nCheckout the post for detailed explanations : https://cocoaswiftly.com/leetcode-solutions/136-single-number/",
                "solutionTags": [],
                "code": "```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    var numsSeen = Set<Int>()\\n\\n    for num in nums {\\n        // the insert operation returns a tuple, the first value of which is a bool,\\n        // indicating whether the insertion is successful\\n        if !numsSeen.insert(num).0 {\\n            numsSeen.remove(num)\\n        }\\n    }\\n    \\n    // it\\'s ok to force unwrap as a valid answer is guaranteed\\n    return numsSeen.first!\\n}\\n```\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    let distinctNums = Set(nums)\\n\\n    return distinctNums.reduce(0, +) * 2 - nums.reduce(0, +)\\n}\\n```\n```\\nfunc singleNumber(_ nums: [Int]) -> Int {\\n    return nums.reduce(0, ^)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43144,
                "title": "1-line-javascript-solution",
                "content": "    var singleNumber = function(nums) {\\n        return nums.reduce((a,b) => a^b);\\n    };",
                "solutionTags": [],
                "code": "    var singleNumber = function(nums) {\\n        return nums.reduce((a,b) => a^b);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3224500,
                "title": "explanation-of-thought-process-and-bitmask-solution-one-liner-solution",
                "content": "# Intuition\\nThe question stated some key things, my initial thoughts were:\\n1. Non-empty array of integers, -3 * 10^4 <= nums[i] <= 3 * 10^4, therefore numbers can be negative.\\n2. Every number appears 2 times, except one number. Maybe this piece of info has the key?\\n3. Time Complexity must be O(N).\\n4. Space Complexity must be O(1).\\n5. Therefore, Brute force solution (time complexity -> O(n^2)). Maps (space complexity -> O(n)) won\\'t cut it.\\n6. However, there must be something I can use to \\'**memorize**\\' or \\'**remember**\\' where each element is, or else, how will I identify/track my count of numbers.\\n\\n# Approach\\n1. I\\'m not gonna lie, the only reason I knew how to do this was because I read a similar solution before. The answer was using a bit manipulation of the numbers.\\n2. On a high level we can think of bits or bitmasks as able to \"store/remember\" information using the position of the bits.\\n3. In this case whenever 2 same numbers are XOR\\'ed with each other, they cancel out to form 0, on the other hand if 0 and any number are XOR\\'ed the output is the number itself. So,\\n\\n    7^7 = 0, simple?\\n\\n    7^7^7 =  what will this be? Well XOR\\'s are associative so let\\'s break it down.\\n\\n    7^7 will be 0\\n\\n    111 (7)\\n    111 (7)\\n    ^__\\n    000 (0)\\n\\n    so now it\\'s 0 ^ 7, which is\\n\\n    000 (0)\\n    111 (7)\\n    ^__\\n    111 (7)\\n\\n    So therefore 7^7^7 = 7, similarly 1^1^2 = 2, \\n\\n    4^1^2^1^2 = will be what?\\n\\n    In this case, the 1\\'s and 2\\'s cancel out and we\\'re left with 4^0 = 4, which is the only number with 1 occurrence and our answer in this case.\\n\\n# Complexity\\n- Time complexity: O(n), we\\'re iterating through the array once.\\n\\n- Space complexity: O(1), no extra space is used, we\\'re using the initial bitmask which is `0` and using XORs with the subsequent numbers/calculations.\\n\\n# Code\\n\\nTo anyone who doesn\\'t understand this code(JavaScript) when we use the `reduce` method of an array we pass a `function(callback)` to it, as the 1st argument and an `accumulator` as the 2nd argument(in this case 0).\\n\\nInside the callback, the first argument being passed is the `accumulator` and in the first iteration this will be `0` that we passed to `reduce`, for all subsequent iterations it will be the value passed by the `callback function`. The function is called for each element of the array and we also get the previous return value as `prev` to the function.\\n\\nSo, for nums = [4, 1, 2, 1, 2]. The function will calculate 0^4^1^2^1^2.\\n\\n```\\nfunction singleNumber(nums: number[]): number {\\n    return nums.reduce((prev, val) => prev ^ val, 0)\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunction singleNumber(nums: number[]): number {\\n    return nums.reduce((prev, val) => prev ^ val, 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626069,
                "title": "easy-java-sol-by-xor-operation",
                "content": "//Xor operation\\n```\\n int res=0;\\n        for(int i : nums){\\n            res =res ^ i;\\n        }\\n        return res;\\n```\\n**Kindly upvote if you like sol**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n int res=0;\\n        for(int i : nums){\\n            res =res ^ i;\\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753472,
                "title": "easiest-java-solution-using-hashmap",
                "content": "```\\n#**Please upvote if you like the Solution\\nclass Solution {\\n    public int singleNumber(int[] nums) \\n    {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }\\n            else\\n            {\\n                map.put(nums[i],1);\\n            }\\n        }\\n        int ans=0;\\n        for(int i:map.keySet())\\n        {\\n            if(map.get(i)==1)\\n            {\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) \\n    {\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(map.containsKey(nums[i]))\\n            {\\n                map.put(nums[i],map.get(nums[i])+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1682200,
                "title": "python-solution-using-xor-bits-116-ms-faster-than-99-54-with-comments",
                "content": "\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# This approach uses XOR bit operation\\n        # XOR with 0 will give that bit\\n        # XOR with same number will give 0\\n        # Hence in the end we will get the number which just occurs once in the array\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n![image](https://assets.leetcode.com/users/images/36e97307-7867-4ac5-9bab-6c780ed39fe2_1641884096.3620715.png)\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# This approach uses XOR bit operation\\n        # XOR with 0 will give that bit\\n        # XOR with same number will give 0\\n        # Hence in the end we will get the number which just occurs once in the array\\n        \\n        a = 0\\n        for i in nums:\\n            a ^= i\\n        return a\\n![image](https://assets.leetcode.com/users/images/36e97307-7867-4ac5-9bab-6c780ed39fe2_1641884096.3620715.png)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1547325,
                "title": "2-easy-approaches-explained-xor-and-hash-set-explained-with-example",
                "content": "*upvote and comment if you find this helpful*  <3\\n**Approach 1:**\\nThe function of XOR is to detect the presence of duplicate elements. XOR returns 0 if the elements are same else returns 1. \\nAccordingly,  \\n5^5 = 0, \\n5^0 = 5;\\n5^1 = negation(5)\\n\\nWhile traversing the array if the same element is encountered, the statement result = result ^ element will make dissolve the repeating element into zero. At the end of this iteration, only the unique element remains.\\nFor example,\\nnums = [2,3,1,1,2]\\nres = 0^2 \\nres =2^3^1^1 = 2^3^0 = 2^3\\nres =2^3^2 = 3^0 = 3\\nres =3 (answer)\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        \\n        //      1.\\n        /* USING BIT MANIPULATION - Constant space, optimized linear time */\\n       int result = 0;\\n        \\n        for (int element: nums)\\n        {\\n            result = result ^ element;\\n        }\\n        return result;\\n\\t\\t}\\n\\t}\\n```\\n\\n**Approach 2:**\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n    \\n        //      2.\\n        //USING COLLECTION FRAMEWORK- Linear time but extra space\\n    \\n        Set<Integer> setobj = new HashSet<Integer>();\\n        if (nums.length == 1)\\n            return nums[0];\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for (int element: nums)\\n        {\\n            if (setobj.contains(element) == true)\\n            {\\n                setobj.remove(element);\\n            }\\n            \\n            else\\n                setobj.add(element);\\n        }\\n        \\n        for (int element: setobj)\\n        ans = element;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        \\n        //      1.\\n        /* USING BIT MANIPULATION - Constant space, optimized linear time */\\n       int result = 0;\\n        \\n        for (int element: nums)\\n        {\\n            result = result ^ element;\\n        }\\n        return result;\\n\\t\\t}\\n\\t}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n    \\n        //      2.\\n        //USING COLLECTION FRAMEWORK- Linear time but extra space\\n    \\n        Set<Integer> setobj = new HashSet<Integer>();\\n        if (nums.length == 1)\\n            return nums[0];\\n        int ans=Integer.MIN_VALUE;\\n        \\n        for (int element: nums)\\n        {\\n            if (setobj.contains(element) == true)\\n            {\\n                setobj.remove(element);\\n            }\\n            \\n            else\\n                setobj.add(element);\\n        }\\n        \\n        for (int element: setobj)\\n        ans = element;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558955,
                "title": "java-100-runtime-no-extra-space-and-o-n-complexity-using-xor-with-explaination",
                "content": "**XOR Properties**:\\n\\t\\t1.  n^n = 0 \\n\\t\\t2.  n^0 = n\\n\\nNow we use this property to iterate over the complete array and store it in the 0th index to save space\\neverything that is duplicated turns into 0 (using first property) and the single number left, that is unique is\\nremaining at 0 index because it has no duplicat, it is left.\\nTo understand this further try XOR over an array with all members having a pair. You would see that the final result would be 0. Therfore as the problem says there is one unique number which does not have a pair, remains as it is at the 0th index here.\\n\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n      for(int i = 1; i < nums.length; i++) {\\n        nums[0] = nums[0] ^ nums[i];\\n      }\\n      return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n      for(int i = 1; i < nums.length; i++) {\\n        nums[0] = nums[0] ^ nums[i];\\n      }\\n      return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323132,
                "title": "c-code-12ms-faster-than-98-using-xor-vote-up-plz",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int single_num = nums.at(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            single_num = single_num ^ nums.at(i);\\n        }\\n        return single_num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int single_num = nums.at(0);\\n        for (int i = 1; i < nums.size(); i++) {\\n            single_num = single_num ^ nums.at(i);\\n        }\\n        return single_num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212520,
                "title": "xor-python",
                "content": "A number XOR itself will get result 0. And a number XOR 0 will get itself. For example,\\n```\\n>>> 1 ^ 1\\n0\\n>>> 0 ^ 2\\n2\\n```\\nIn this way, if we XOR numbers with each other: two identical numbers XOR to 0, the `standard` will be the single number finally.\\n> Version 1\\n```\\n    def singleNumber(self, nums):\\n        standard = 0\\n        for num in nums:\\n            standard = num ^ standard\\n        \\n        return standard\\n```\\n> Version 2\\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(lambda a, b : a ^ b, nums)\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n>>> 1 ^ 1\\n0\\n>>> 0 ^ 2\\n2\\n```\n```\\n    def singleNumber(self, nums):\\n        standard = 0\\n        for num in nums:\\n            standard = num ^ standard\\n        \\n        return standard\\n```\n```\\nfrom functools import reduce\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        return reduce(lambda a, b : a ^ b, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43062,
                "title": "o-n-time-without-extra-space-java",
                "content": "```\\npublic int singleNumber(int[] nums) {\\n    if(nums.length == 1) {\\n        return nums[0];\\n    }\\n    for(int i = 1; i < nums.length; i++) {\\n        nums[0] ^= nums[i]; \\n    }\\n    return nums[0]; \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n    if(nums.length == 1) {\\n        return nums[0];\\n    }\\n    for(int i = 1; i < nums.length; i++) {\\n        nums[0] ^= nums[i]; \\n    }\\n    return nums[0]; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43211,
                "title": "simple-20ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size();\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                ans ^= nums[i];\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size();\\n            int ans = 0;\\n            for(int i=0;i<n;i++){\\n                ans ^= nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3448433,
                "title": "best-three-solutions-in-java-in-runtime-6ms-and-beats-45-7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\nin Runtime 6ms and Beats 45.7%\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n    for(int i=0; i<nums.length-1;i++)\\n    {\\n        if(nums[i]==nums[i+1]){\\n            i++;\\n        }else{\\n            return nums[i];\\n        }             \\n    }\\n        return nums[nums.length-1];\\n    }\\n}\\n```\\n\\n# Code2 \\nin Runtime 7ms and Beats 31.57%\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == nums.length-1 ) return nums[i];\\n\\n                if (  nums[i] != nums[i+1]){\\n                    if (i == 0)\\n                    return nums[i];\\n                    \\n                    if (nums[i-1] != nums[i])\\n                        return nums[i];\\n\\n                }\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n\\n\\n# Code3\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n         boolean cond = false;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            test1:for (int j = 0; j < nums.length; j++)\\n            {\\n                if (i != j && nums[i] == nums[j]){\\n                    cond = false;\\n                    break test1;\\n                }\\n                cond = true;\\n            }\\n\\n                if (cond)\\n                    return nums[i];\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n\\n\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/8b272e6c-3dd9-44e1-92d1-87a9a34fd04a_1682279216.3808486.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n    for(int i=0; i<nums.length-1;i++)\\n    {\\n        if(nums[i]==nums[i+1]){\\n            i++;\\n        }else{\\n            return nums[i];\\n        }             \\n    }\\n        return nums[nums.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       Arrays.sort(nums);\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i == nums.length-1 ) return nums[i];\\n\\n                if (  nums[i] != nums[i+1]){\\n                    if (i == 0)\\n                    return nums[i];\\n                    \\n                    if (nums[i-1] != nums[i])\\n                        return nums[i];\\n\\n                }\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n         boolean cond = false;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            test1:for (int j = 0; j < nums.length; j++)\\n            {\\n                if (i != j && nums[i] == nums[j]){\\n                    cond = false;\\n                    break test1;\\n                }\\n                cond = true;\\n            }\\n\\n                if (cond)\\n                    return nums[i];\\n\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040043,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPick the odd one using XOR operator\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne line solution\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLinear Time Complexity\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant Space Complexity\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(arr) {\\n\\n// SOLUTION I \\n\\n//    const count = arr.reduce((obj, curr)=>{\\n//        if(obj[curr] == undefined)\\n//        obj[curr] = 1\\n//        else\\n//        obj[curr]++\\n\\n//        return obj\\n//    }, {})\\n\\n\\n//     for(const[key, value] of Object.entries(count)){\\n//         if(value === 1){\\n//         return key;\\n//         }\\n//     }\\n    \\n// SOLUTION II\\n\\n    // let res = 0, i, n = arr.length;\\n    // for (i = 0; i < n; i++)\\n    //     res ^= arr[i];\\n    // return res;\\n\\n// SOLUTION III\\n\\n    return arr.reduce((prev, curr) => prev^curr)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(arr) {\\n\\n// SOLUTION I \\n\\n//    const count = arr.reduce((obj, curr)=>{\\n//        if(obj[curr] == undefined)\\n//        obj[curr] = 1\\n//        else\\n//        obj[curr]++\\n\\n//        return obj\\n//    }, {})\\n\\n\\n//     for(const[key, value] of Object.entries(count)){\\n//         if(value === 1){\\n//         return key;\\n//         }\\n//     }\\n    \\n// SOLUTION II\\n\\n    // let res = 0, i, n = arr.length;\\n    // for (i = 0; i < n; i++)\\n    //     res ^= arr[i];\\n    // return res;\\n\\n// SOLUTION III\\n\\n    return arr.reduce((prev, curr) => prev^curr)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3035192,
                "title": "beats-99-31-memory-beginner-friendly-using-indexof-and-lastindexof",
                "content": "# Code\\n```\\nfunction singleNumber(nums: number[]): number {\\n   if(nums.length === 1) return nums[0];\\n   \\n   for(let i = 0; i < nums.length; i++){\\n       if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])){\\n           return nums[i]\\n       }\\n   }\\n   return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction singleNumber(nums: number[]): number {\\n   if(nums.length === 1) return nums[0];\\n   \\n   for(let i = 0; i < nums.length; i++){\\n       if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])){\\n           return nums[i]\\n       }\\n   }\\n   return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812149,
                "title": "java-easy-fast-2-approaches-bit-manipulation-xor",
                "content": "**Approach 1 -Using hashmap**\\nMaintain Hashmap and check the count against array and return the elements if we found the one as a value, \\nSince there is only one unique element as soon as we get value as 1 we return that element.\\nTC - O(N)\\nSC- O(Min(n,m)) \\n\\n\\n    class Solution{\\n\\t\\tpublic int singleNumber(int[] nums){\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t  map.put(i, map.getOrDefault(i, 0) + 1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t\\t  if (map.get(i) == 1) {\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t  }\\n\\t\\t}\\n    return 0;\\n  }\\n}\\n\\n\\n**Approach 2 -Using BitManipulation**\\nProperties of XOR:\\n1. It returns the same number if weXOR with zero.\\n2. It return zero if we take XOR of two same numbers.\\n\\nSo We can XOR all the numbers in the given input, as per XOR properties; all the duplicate number will zero out each other and we will be left with single number.\\nTC - O(N)\\nSC- O(1) \\n\\n\\tclass Solution { \\n\\tpublic int singleNumber(int[] nums) {\\n\\t\\tint num = 0;\\n \\n\\t\\tfor (int i : nums) {\\n\\t\\t  num =num ^ i;\\n\\t\\t}\\n\\t\\treturn num;\\n\\t}\\n}\\n\\n\\n\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution{\\n\\t\\tpublic int singleNumber(int[] nums){\\n\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\n\\t\\tfor (int i : nums) {\\n\\t\\t  map.put(i, map.getOrDefault(i, 0) + 1);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1771850,
                "title": "easy-python-solution",
                "content": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n        c=Counter(nums)\\n        for i in nums:\\n            if c[i]==1:\\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n        c=Counter(nums)\\n        for i in nums:\\n            if c[i]==1:\\n                return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1753083,
                "title": "c-fastest-3-line-solution",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED**\\n\\n****Optimised Approach**\\n*  Since in XOR Operations 0^0 = 0 and 1^1 = 0.\\n* Hence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int c=0;\\n        for(auto cc:nums)c^=cc;\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int c=0;\\n        for(auto cc:nums)c^=cc;\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423042,
                "title": "java-solution-o-n",
                "content": "Try to dry run the code for a sample input to understand what goes beneath! \\nRemember, \\n1. 0 XOR num = num\\n2. num XOR num = 0\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n     return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n     return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1092980,
                "title": "2-simple-way-solution-with-explanation-cpp",
                "content": "First solution (by comparing elements):\\n```\\nint singleNumber(vector<int>& nums) {\\n        if (nums.size() > 1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            for(int i = 0; i < nums.size()-1; i+=2)\\n            {\\n                if(nums[i] != nums[i+1])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\\n\\nSecond solution (using bitwise XOR):\\n```\\nint singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i : nums)\\n        {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n```\\nHow does it work? \\nfor example, we have input vector {4,1,2,1,2}\\nres = 0, next element = 4\\nres = 000 ^ 100 = 100\\n\\nres = 4, next element = 1\\nres = 100 ^ 001 = 101\\n\\nres = 5, next element = 2\\nres = 101 ^ 010 = 111\\n\\nres = 7, next element = 1\\nres = 111 ^ 001 = 110\\n\\nres = 6, next element = 2\\nres = 110 ^ 010 = 100\\n\\nfinally res = 4, as expected =)\\n\\n\\n**Please, upvote, if it was useful for you..**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n        if (nums.size() > 1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            for(int i = 0; i < nums.size()-1; i+=2)\\n            {\\n                if(nums[i] != nums[i+1])\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return nums[nums.size()-1];\\n    }\\n```\n```\\nint singleNumber(vector<int>& nums) {\\n        int result = 0;\\n        for(int i : nums)\\n        {\\n            result ^= i;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 225006,
                "title": "java-solutions",
                "content": "**Solution 1: Bit Manipulation - Using XOR**\\n\\n- If we take XOR of zero and some bit, it will return that bit\\n`a ^ 0 = a`\\n\\n- If we take XOR of two same bits, it will return 0\\n`a ^ a = 0`\\n\\n- XOR operator is commutative\\n`a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b`\\n\\nSo we can XOR all bits together to find the unique number.\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        int result = 0;\\n        \\n        for(int n : A)\\n            result ^= n;\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n**Solution 2: General Solution for K**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n\\tpublic int singleNumber(int[] A)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\tint K = 2;\\t\\t\\t\\t\\t\\t// Every element appears twice except for one\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int n: A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((n >> i & 1) == 1)\\n\\t\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t\\tsum %= K;\\n\\t\\t\\tresult |= sum << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```\\n\\n**Solution 3: Using Set**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(n)`\\n\\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int n : A)\\n        {\\n            if(set.contains(n))\\n                set.remove(n);\\n            else\\n                set.add(n);\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        int result = 0;\\n        \\n        for(int n : A)\\n            result ^= n;\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\tpublic int singleNumber(int[] A)\\n\\t{\\n\\t\\tint result = 0;\\n\\t\\tint K = 2;\\t\\t\\t\\t\\t\\t// Every element appears twice except for one\\n\\t\\t\\n\\t\\tfor(int i = 0; i < 32; i++)\\n\\t\\t{\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int n: A)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((n >> i & 1) == 1)\\n\\t\\t\\t\\t\\tsum++;\\n\\t\\t\\t}\\n\\t\\t\\tsum %= K;\\n\\t\\t\\tresult |= sum << i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n}\\n```\n```\\nclass Solution \\n{\\n    public int singleNumber(int[] A)\\n    {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int n : A)\\n        {\\n            if(set.contains(n))\\n                set.remove(n);\\n            else\\n                set.add(n);\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43169,
                "title": "c-solution-using-xor",
                "content": "    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res=0;\\n            for(auto num : nums)\\n                res ^= num;\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int res=0;\\n            for(auto num : nums)\\n                res ^= num;\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43181,
                "title": "share-my-c-solution-using-xor",
                "content": "***We can verify the associative law and the commutative law for XOR,and x^x = 0, x^0 = x***\\n\\n    class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size(), i = 0, ret = 0;\\n            \\n            for (i = 0; i < n; ++i)\\n                ret ^= nums[i];\\n                \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int singleNumber(vector<int>& nums) {\\n            int n = nums.size(), i = 0, ret = 0;\\n            \\n            for (i = 0; i < n; ++i)\\n                ret ^= nums[i];\\n                \\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43226,
                "title": "1-line-c-shortest-solution",
                "content": "The whole idea is to XOR all the elements and the value that we get after XORing all the elements is the element which appears only once in the array. \\n\\nBy default, accumulate adds up every element in the range. Since, we want to XOR all the elements int he range and not add them, we can specify bit_xor function. This can be done in 1 line in C++ :\\n\\n    int singleNumber(vector<int>& nums) {\\n            \\n        return nums.size() == 0 ? 0 : accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n            \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "The whole idea is to XOR all the elements and the value that we get after XORing all the elements is the element which appears only once in the array. \\n\\nBy default, accumulate adds up every element in the range. Since, we want to XOR all the elements int he range and not add them, we can specify bit_xor function. This can be done in 1 line in C++ :\\n\\n    int singleNumber(vector<int>& nums) {\\n            \\n        return nums.size() == 0 ? 0 : accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());\\n            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43230,
                "title": "very-concise-java-solution-using-xor",
                "content": "    public class Solution {\\n        public int singleNumber(int[] A) {\\n            int result = 0;\\n            for (int i=0; i<A.length; i++){\\n                result = result ^ A[i];\\n            }\\n            return result;    \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int singleNumber(int[] A) {\\n            int result = 0;\\n            for (int i=0; i<A.length; i++){\\n                result = result ^ A[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3205701,
                "title": "136-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(n), where n is the length of the input array, since we loop through the entire array once.\\n\\n- Space complexity:\\nThe space complexity is O(1), since we only use a constant amount of extra space to store the result variable.\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Given a non-empty array of integers nums, every element appears twice except for one.\\n        Find that single one.\\n        \"\"\"\\n        # We\\'ll use the XOR operator to find the single number that appears only once\\n        # XORing a number with itself gives 0, so all the pairs will cancel each other out\\n        # The result will be the number that appears only once\\n        result = 0\\n    \\n        # XOR all the numbers in the list\\n        for num in nums:\\n            result ^= num\\n    \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Given a non-empty array of integers nums, every element appears twice except for one.\\n        Find that single one.\\n        \"\"\"\\n        # We\\'ll use the XOR operator to find the single number that appears only once\\n        # XORing a number with itself gives 0, so all the pairs will cancel each other out\\n        # The result will be the number that appears only once\\n        result = 0\\n    \\n        # XOR all the numbers in the list\\n        for num in nums:\\n            result ^= num\\n    \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538019,
                "title": "java-xor-solution-explained",
                "content": "-If we use XOR operator between two same values , it will return zero.\\n-If one of the value is zero, and the other is non-zero, it returns the non-zero value.\\n\\n***XOR\\nX^X = 0\\n0^X = X***\\n\\nConsider an array [1,2,1,3,3] -\\n-> (1^2^1^3^3) = 2, it doesn\\'t matter what the order is.\\n\\n```\\npublic int singleNumber(int[] nums) {\\n\\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            ans ^= nums[i]; \\n        }\\n        return ans;\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "-If we use XOR operator between two same values , it will return zero.\\n-If one of the value is zero, and the other is non-zero, it returns the non-zero value.\\n\\n***XOR\\nX^X = 0\\n0^X = X***\\n\\nConsider an array [1,2,1,3,3] -\\n-> (1^2^1^3^3) = 2, it doesn\\'t matter what the order is.\\n\\n```\\npublic int singleNumber(int[] nums) {\\n\\n        int n = nums.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            ans ^= nums[i]; \\n        }\\n        return ans;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2441785,
                "title": "solved-using-bitwise-xor-with-full-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/605f0c08-55a9-4446-a149-167a47bd69b7_1660786303.7149374.png)\\n\\nXOR Rules in simple terms:\\n\\t1. It returns zero if we take XOR of two same numbers.\\n\\t2. It returns the same number if we XOR with zero.\\n\\n```\\n// check for valid input\\nif (nums.length < 1) return 0;\\n\\t// initialize variable\\n    let num = 0;\\n\\t\\n\\t// iterate through the nums array and XOR all the numbers in the input, \\n\\t// As stated in the rule above, duplicate numbers will zero out each other and we will be left with the single number.\\n    for (let i = 0; i < nums.length; i++) {\\n        num ^= nums[i];\\n    }\\n\\n    return num;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// check for valid input\\nif (nums.length < 1) return 0;\\n\\t// initialize variable\\n    let num = 0;\\n\\t\\n\\t// iterate through the nums array and XOR all the numbers in the input, \\n\\t// As stated in the rule above, duplicate numbers will zero out each other and we will be left with the single number.\\n    for (let i = 0; i < nums.length; i++) {\\n        num ^= nums[i];\\n    }\\n\\n    return num;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1675221,
                "title": "c-accepted-100-more-xor-based-tricks",
                "content": "This post includes the solution to this problem and one more XOR based trick that you might find useful in future. \\nFirst things first, XOR can be a useful bitwise operation given the range of properties it offers. This question exploits 2 such properties, i.e, XOR of any 2 similar numbers will give us a 0 value and XOR of any number with 0 gives us the same number. \\n\\na^a =0;\\n0^a=a;\\n\\nSo, the very first thing that comes into our minds if we know these properties is we can simply XOR all elements in the array and store the value as we loop through, in an integer ans. \\nAs we find a copy of any value, our ans variable will be initialized back to 0 (a^a=0) and at last the only unique element will be left with us which we can return. \\n\\nCode: \\n```\\nint singleNumber(vector<int>& nums) {\\n        int ans=0; \\n        for(int x: nums){\\n            ans^=x;\\n        }\\n        return ans;\\n    }\\n```\\n\\nNow for another XOR property that might come in handy:\\n\\n- In-place swapping of 2 numbers:  We can swap 2 numbers in place by just 3 lines of a XOR code, that goes:\\n\\n```\\nvoid swapInplace(int x, int y){\\n\\tx ^= y\\n\\ty ^= x\\n\\tx ^= y\\n}\\n```\\n\\nThe logical explaination of the code aforementioned is something like:\\n```\\nx ^= y # =>                      (x ^ y, y)\\ny ^= x # => (x ^ y, y ^ x ^ y) = (x ^ y, x)\\nx ^= y # => (x ^ y ^ x, x)     = (y, x)\\n```\\n\\nAlthough all this can be done the conventional ways too, I think it is good to know how to solve a particular problem a few different ways. Hope it helps. \\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint singleNumber(vector<int>& nums) {\\n        int ans=0; \\n        for(int x: nums){\\n            ans^=x;\\n        }\\n        return ans;\\n    }\\n```\n```\\nvoid swapInplace(int x, int y){\\n\\tx ^= y\\n\\ty ^= x\\n\\tx ^= y\\n}\\n```\n```\\nx ^= y # =>                      (x ^ y, y)\\ny ^= x # => (x ^ y, y ^ x ^ y) = (x ^ y, x)\\nx ^= y # => (x ^ y ^ x, x)     = (y, x)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1360149,
                "title": "c-xor-o-1-space-time-explained",
                "content": "we use bitwise XOR to solve this problem :\\n\\nfirst , we have to know the bitwise XOR in java\\n\\n0 ^ N = N\\nN ^ N = 0\\nSo..... if N is the single number\\n\\nN1 ^ N1 ^ N2 ^ N2 ^..............^ Nx ^ Nx ^ N\\n(since XOR is associative thus the order doesn\\'t matter )\\n\\n= (N1^N1) ^ (N2^N2) ^..............^ (Nx^Nx) ^ N\\n\\n= 0 ^ 0 ^ ..........^ 0 ^ N\\n\\n= N\\n\\n\\n```\\n    int singleNumber(vector<int>& nums)\\n    {\\n        int temp=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp=temp^nums[i];\\n        }\\n        return temp;\\n    }\\n\\t\\n\\t\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int singleNumber(vector<int>& nums)\\n    {\\n        int temp=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            temp=temp^nums[i];\\n        }\\n        return temp;\\n    }\\n\\t\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346064,
                "title": "python-2-solutions-in-o-n-with-explanation-faster-than-94",
                "content": "# Solution 1:\\n# Using Map:-\\n\\nUsing map which will store the count of each element in the hashmap.\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n         mp = [0]*100000\\n         for i in range(len(nums)):\\n             nums[i] += 30000\\n        \\n         for i in range(len(nums)):\\n             mp[nums[i]]+=1\\n            \\n         for j in range(len(mp)):\\n             if mp[j] ==1:\\n                 return j - 30000\\n         return -1\\n```\\n\\n# Solution2:\\n# Using maths :- \\nFormula: 2*(a+b+c) - (a+a+b+b+c) = c\\n\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(set(nums)) - sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n         mp = [0]*100000\\n         for i in range(len(nums)):\\n             nums[i] += 30000\\n        \\n         for i in range(len(nums)):\\n             mp[nums[i]]+=1\\n            \\n         for j in range(len(mp)):\\n             if mp[j] ==1:\\n                 return j - 30000\\n         return -1\\n```\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(set(nums)) - sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1216856,
                "title": "python-solutions",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version 2.0, Using python library to build dictionary\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Bitwise operation\\n        # 1 xor 1 gives 0. 2 xor 2 gives 0\\n        # what it means 1 xor 1, 2 xor 2, 3 xor 3 will always give you 0\\n        # [4,1,2,1,2] - > [4] will stay as 4 [1,2,1,2] will cancel each other. \\n        # T: O(N)\\n        # S: O(1)\\n        \\n        combined = 0\\n        for i in nums:\\n            combined ^= i\\n        \\n        return combined\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = {}\\n        for i in nums:\\n            if i in d:\\n                d[i] += 1\\n            else:\\n                d[i] = 1\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Brute force version 2.0, Using python library to build dictionary\\n        # T: O(N)\\n        # S: O(N)\\n        \\n        d = Counter(nums)\\n        \\n        for k,v in d.items():\\n            if v == 1:\\n                return k\\n            \\n    def singleNumber(self, nums: List[int]) -> int:\\n        \\n        # Bitwise operation\\n        # 1 xor 1 gives 0. 2 xor 2 gives 0\\n        # what it means 1 xor 1, 2 xor 2, 3 xor 3 will always give you 0\\n        # [4,1,2,1,2] - > [4] will stay as 4 [1,2,1,2] will cancel each other. \\n        # T: O(N)\\n        # S: O(1)\\n        \\n        combined = 0\\n        for i in nums:\\n            combined ^= i\\n        \\n        return combined\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834478,
                "title": "java-c-c-super-simple-solution-0-ms-100-faster",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.length; i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579498,
                "title": "java-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ret = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            ret ^= nums[i];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ret = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            ret ^= nums[i];\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428189,
                "title": "php-1-line-beats-100-time-and-space",
                "content": "Independent bitwise xor function:\\n\\n\\tfunction singleNumber($A) {\\n\\t\\tfunction bitwise_xor($x, $y){\\n\\t\\t\\treturn $x ^ $y;\\n\\t\\t}\\n        return array_reduce($A, \"bitwise_xor\");\\n    }\\n\\nIn-line anonymous function:\\n\\n\\tfunction singleNumber($A) {\\n        return array_reduce($A, function($x, $y){ return $x ^ $y; });\\n    }",
                "solutionTags": [
                    "PHP"
                ],
                "code": "Independent bitwise xor function:\\n\\n\\tfunction singleNumber($A) {\\n\\t\\tfunction bitwise_xor($x, $y){\\n\\t\\t\\treturn $x ^ $y;\\n\\t\\t}\\n        return array_reduce($A, \"bitwise_xor\");\\n    }\\n\\nIn-line anonymous function:\\n\\n\\tfunction singleNumber($A) {\\n        return array_reduce($A, function($x, $y){ return $x ^ $y; });\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 314884,
                "title": "my-4-swift-solutions",
                "content": "```\\n\\n// Bit manipulation solution\\nfunc findSingleNumber(_ nums: [Int]) -> Int {\\n    var result = 0\\n    for number in nums {\\n        result ^= number\\n    }\\n    return result\\n}\\n\\nassert(findSingleNumber([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Time Limit Exceeded - Array Solution - O(n\\u02C62)\\nfunc findSingleNumber2(_ nums: [Int]) -> Int {\\n    var array: [Int] = []\\n    for number in nums {\\n        if let index = array.firstIndex(of: number) {\\n            array.remove(at: index)\\n        } else {\\n            array.append(number)\\n        }\\n    }\\n    return array.first ?? 0\\n}\\n\\nassert(findSingleNumber2([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber2([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Hash Table Solution\\nfunc findSingleNumber3(_ nums: [Int]) -> Int {\\n    var table: [Int: Int] = [:]\\n    for number in nums {\\n        if table[number] != nil {\\n            table[number] = nil\\n        } else {\\n            table[number, default: 0] += 1\\n        }\\n    }\\n    return table.first?.key ?? 0\\n}\\n\\nassert(findSingleNumber3([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber3([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Math Solution\\n// 1. Sum of all numbers: a + a + b + c + c = 2a + 2c + b\\n// 2. Sum of unique numbers: a + b + c\\n// 3. Multiply by 2 unique sum: 2a + 2b + 2c\\n// 4. Subtract: 2a + 2b + 2c - (2a + 2c + b) = b\\n// 5 Formula: singleNumber = 2 * Sum(Set(nums)) - sum(nums)\\n\\nfunc findSingleNumber4(_ nums: [Int]) -> Int {\\n    let setSum2 = 2 * Set(nums).reduce(0, +)\\n    let numsSum = nums.reduce(0, +)\\n    return setSum2 - numsSum\\n}\\n\\nassert(findSingleNumber4([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber4([4,1,2,1,2]) == 4, \"Failed\")\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n\\n// Bit manipulation solution\\nfunc findSingleNumber(_ nums: [Int]) -> Int {\\n    var result = 0\\n    for number in nums {\\n        result ^= number\\n    }\\n    return result\\n}\\n\\nassert(findSingleNumber([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Time Limit Exceeded - Array Solution - O(n\\u02C62)\\nfunc findSingleNumber2(_ nums: [Int]) -> Int {\\n    var array: [Int] = []\\n    for number in nums {\\n        if let index = array.firstIndex(of: number) {\\n            array.remove(at: index)\\n        } else {\\n            array.append(number)\\n        }\\n    }\\n    return array.first ?? 0\\n}\\n\\nassert(findSingleNumber2([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber2([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Hash Table Solution\\nfunc findSingleNumber3(_ nums: [Int]) -> Int {\\n    var table: [Int: Int] = [:]\\n    for number in nums {\\n        if table[number] != nil {\\n            table[number] = nil\\n        } else {\\n            table[number, default: 0] += 1\\n        }\\n    }\\n    return table.first?.key ?? 0\\n}\\n\\nassert(findSingleNumber3([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber3([4,1,2,1,2]) == 4, \"Failed\")\\n\\n// Math Solution\\n// 1. Sum of all numbers: a + a + b + c + c = 2a + 2c + b\\n// 2. Sum of unique numbers: a + b + c\\n// 3. Multiply by 2 unique sum: 2a + 2b + 2c\\n// 4. Subtract: 2a + 2b + 2c - (2a + 2c + b) = b\\n// 5 Formula: singleNumber = 2 * Sum(Set(nums)) - sum(nums)\\n\\nfunc findSingleNumber4(_ nums: [Int]) -> Int {\\n    let setSum2 = 2 * Set(nums).reduce(0, +)\\n    let numsSum = nums.reduce(0, +)\\n    return setSum2 - numsSum\\n}\\n\\nassert(findSingleNumber4([2,2,1]) == 1, \"Failed\")\\nassert(findSingleNumber4([4,1,2,1,2]) == 4, \"Failed\")\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 154920,
                "title": "five-line-javascript-solution",
                "content": "Compare indexOf and lastIndexOf each element, if equal, the number is single.\\n```\\nvar singleNumber = function(nums) {\\n    for(var i=0;i<nums.length;i++) {\\n        if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) return nums[i];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar singleNumber = function(nums) {\\n    for(var i=0;i<nums.length;i++) {\\n        if(nums.indexOf(nums[i]) === nums.lastIndexOf(nums[i])) return nums[i];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43244,
                "title": "shortest-solution-with-c",
                "content": "     while (--n)\\n\\tA[n - 1] ^= A[n];\\n    return A[0];",
                "solutionTags": [],
                "code": "     while (--n)\\n\\tA[n - 1] ^= A[n];\\n    return A[0];",
                "codeTag": "Unknown"
            },
            {
                "id": 43275,
                "title": "my-linear-complexity-without-using-extra-memory-solution",
                "content": "Hi all,\\n\\nI have a different solution here which take no extra memory. This algorithm is based on the three way partition method. First, choose a element in the array as pivot. Second, split this array to three partition, less than pivot, equal to pivot and greater than pivot. Now we have three partitions and we also know the size of these three partitions too. If the single number in any partition, the size of this partition must be 2*n+1, and should not be divisible by 2. Last, we just recursively find the single number in the partition which size can not be divisible by 2.\\n\\nThis method can be easily modified to solve the single number 2 problem.\\n\\n\\n    void swap(int A[], int a, int b)\\n    {\\n        int t = A[a];\\n        A[a] = A[b];\\n        A[b] = t;\\n    }\\n    \\n    void threeWayPartition(int A[], int n, int&l, int&h)\\n    {\\n        int pivot = A[0];\\n        int j = -1;\\n        int k = n;\\n        \\n        for (int i=0; i<k;)\\n        {\\n            if (A[i] < pivot)\\n            {\\n                swap(A, i, ++j);\\n                i++;\\n            }\\n            else if (A[i] > pivot)\\n            {\\n                swap(A, i, --k);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        \\n        l = j;\\n        h = k;\\n    }\\n    \\n    #define APPEAR_NUMBER (2)\\n    \\n    class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            if (n==1)\\n            {\\n                return A[0];\\n            }\\n    \\n            int l=0;\\n            int h=0;\\n            threeWayPartition(A, n, l, h);\\n            \\n            int p = l+1;\\n    \\n            if (A[p] != A[p+1])\\n            {\\n                return A[p];\\n            }\\n            else if(p%APPEAR_NUMBER == 0)\\n            {\\n                return singleNumber(A+(p+APPEAR_NUMBER), n-(p+APPEAR_NUMBER));\\n            }\\n            else\\n            {\\n                return singleNumber(A, p);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int singleNumber(int A[], int n) {\\n            if (n==1)\\n            {\\n                return A[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3349420,
                "title": "c-solution-using-maps-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we have an array, where every single element is repeated twice, but there is one element which is occuring only one. we will need to count it and then print it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt can be solved using the bit manipulation technique as well as using the mapping technique. Here we have used the mapping technique. To keep track of the count of the number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n          unordered_map<int,int> mp;\\n          for(int i=0;i<nums.size();i++){\\n              mp[nums[i]]++;\\n          }\\n\\n        //   for(auto it: mp){\\n        //       cout<<it.first<<\" \"<<it.second<<endl;\\n        //   }\\n          \\n          for(auto it: mp){\\n              if(it.second==1){ return it.first; break;}\\n          }\\n          return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        \\n          unordered_map<int,int> mp;\\n          for(int i=0;i<nums.size();i++){\\n              mp[nums[i]]++;\\n          }\\n\\n        //   for(auto it: mp){\\n        //       cout<<it.first<<\" \"<<it.second<<endl;\\n        //   }\\n          \\n          for(auto it: mp){\\n              if(it.second==1){ return it.first; break;}\\n          }\\n          return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2788653,
                "title": "pythonic",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        stack=[]\\n        if len(nums)==1:\\n            return nums[0]\\n        for i in range(len(nums)):\\n            if nums[i] not  in stack :\\n                stack.append(nums[i])\\n            else:\\n                stack.pop()\\n        return stack[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        nums.sort()\\n        stack=[]\\n        if len(nums)==1:\\n            return nums[0]\\n        for i in range(len(nums)):\\n            if nums[i] not  in stack :\\n                stack.append(nums[i])\\n            else:\\n                stack.pop()\\n        return stack[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678049,
                "title": "python-3-fastest-solution-faster-than-96-of-submissions",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def singleNumber(self, nums):\\n      a = dict(Counter(nums))\\n      b = [k for k, v in a.items() if v==1]\\n      return b[0]\\n\\t  \\n```\\n\\nUpvote if you like the solution. Feel free to ask any question",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def singleNumber(self, nums):\\n      a = dict(Counter(nums))\\n      b = [k for k, v in a.items() if v==1]\\n      return b[0]\\n\\t  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2547758,
                "title": "easy-python3-solution",
                "content": "if it is helpful please ***upvote*** me\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        return xor\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        xor = 0\\n        for num in nums:\\n            xor ^= num\\n        return xor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773553,
                "title": "java-simple-short-and-easy-solution-bit-manipulation-xor",
                "content": "```\\n//logic is very simple -> xor of two same number cancel each other( in simple word ) \\n//because xor of two same number equals zero\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums)\\n            result ^= i;\\n        \\n        return result;\\n    }\\n}\\n\\n//please upvote",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int result = 0;\\n        for(int i : nums)\\n            result ^= i;\\n        \\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1739614,
                "title": "solution-swift-single-number-test-cases",
                "content": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var result = nums[0]\\n        for n in nums[1...] { result ^= n }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.017 (0.019) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,1])\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([4,1,2,1,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.singleNumber([1])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        var result = nums[0]\\n        for n in nums[1...] { result ^= n }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.singleNumber([2,2,1])\\n        XCTAssertEqual(value, 1)\\n    }\\n    \\n    func test1() {\\n        let value = solution.singleNumber([4,1,2,1,2])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.singleNumber([1])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523589,
                "title": "all-possible-solutions-by-ashay-nayak-best-solution-o-n",
                "content": "Please **upvote** if you find it helpful. Thank You.\\n**Purpose** - Practice of thinking all possible solution which help you in **interviews**.\\nFeel free to comment below if you don\\'t get anything. I will surely reply back **within 12 hours**.\\npossible solutions,\\nSee read the question twice that **every element appears twice except for one.**\\n1.) Using 2 for loops - TC - O(n^2) and SC - O(1)  -  please try to think by yourself and if you don\\'t get it then comment below.\\n\\n2.) Using HashMap - two iteration required - TC - O(n) and SC - O(n)  - Iterate through each element of nums array and increment it\\'s count in map. Here, key will be element present in nums and value will be the count. Now, iterate through map and return the element with count value 1. - please try to code by yourself and if you don\\'t get it then comment below\\n\\n3.) Using HashSet - one iteration required - TC - O(n) and SC - O(n) -  Iterate through each element of nums array. While iterating, check if element is present in set or not. If it is already present then remove that element from set and if it is not present then add the element to the set. Element which has appeared only for single time will remain in set and it will be the answer. - please try to code by yourself and if you don\\'t get it then comment below.\\n\\n4.) Using XOR - TC - O(n) and SC - O(1) -**best solution** - keep these two things in mind for xor. (a.) 0^x = x and (b.) x^x = 0 . Now initialize a variable say ans = 0 and iterate through nums elements. While iterate** take xor of all elements with ans**. Finally value of ans will be the element which appears only once. See this example, 3,4,3,1,1 - what I said that intitialize ans=0 and  **take xor of all elements with ans** so I will write - ans^3^4^3^1^1 - replace ans with 0 - 0^3^4^3^1^1 - same elements will become 0 as per x^x=0. So we will left with 0^4 which becomes 4 as per 0^x = x.\\n\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190791,
                "title": "faster-than-99-95",
                "content": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(list(set(nums))) - sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\treturn 2*sum(list(set(nums))) - sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 643220,
                "title": "cpp-using-hash-table",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint singleNumber(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int, int> hash;\\n\\t\\t\\tfor (auto num : nums) {\\n\\t\\t\\t\\tif (!hash[num])\\n\\t\\t\\t\\t\\thash[num] = 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thash.erase(num);\\n\\t\\t\\t}\\n\\t\\t\\treturn hash.begin()->first;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint singleNumber(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int, int> hash;\\n\\t\\t\\tfor (auto num : nums) {\\n\\t\\t\\t\\tif (!hash[num])\\n\\t\\t\\t\\t\\thash[num] = 1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\thash.erase(num);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 515893,
                "title": "c-code-3-lines-solution-99-optimal-code",
                "content": "```\\nint singleNumber(int* nums, int numsSize){\\n    int val = 0;\\n    while(numsSize--) val ^= nums[numsSize];\\n    return val;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint singleNumber(int* nums, int numsSize){\\n    int val = 0;\\n    while(numsSize--) val ^= nums[numsSize];\\n    return val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515023,
                "title": "javascript-xor-linear-time-no-extra-space",
                "content": "```\\n// XOR is commutative, means- 1^2^1 = 1^1^2 (since a^a =0 hence 2 will be left)\\nvar singleNumber = function(nums) {\\n    let res = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        res = res ^ nums[i]\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// XOR is commutative, means- 1^2^1 = 1^1^2 (since a^a =0 hence 2 will be left)\\nvar singleNumber = function(nums) {\\n    let res = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        res = res ^ nums[i]\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468420,
                "title": "python3-bitwise-and-non-bitwise-solutions-w-explanation",
                "content": "\\n# **Bitwise**\\n```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tsol = 0\\n\\tfor n in nums:\\n\\t\\tsol ^= n\\n\\n\\treturn sol\\n```\\nExplanation:\\nThe key to this bitwise solution is understanding how XOR works. In this case we use this operator as a sort of do and undo. Let\\'s look at an example to see what I mean by that. \\n\\n```\\n>> x = 2  // 0010 in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n...\\n``` \\nAs you see in the example, when we XOR `2` with `3` we get `1`, but if we do the operation again then we end up with our original `2`, essentially undoing what we just did. The same is true if we do this operation any even number of times. \\n\\nFor this problem since each number comes in pairs other than solution, XOR-ing our result by each number in our list will ultimately leave us with the the only number that occurs once which is the solution.\\n\\n# **Non Bitwise**\\n```\\n# Note this is not fast or memory efficient but it is readable\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tref = {}\\n\\tfor i in nums:\\n\\t\\tif i not in ref:\\n\\t\\t\\tref[i] = 1\\n\\t\\telse:\\n\\t\\t\\tref[i] += 1\\n\\n\\tfor k, v in ref.items():\\n\\t\\tif v == 1 :\\n\\t\\t\\treturn k\\n```\\n*Explanation:*\\nFor the non bitwise solution we are just using a map (dictionary in python terminology) to keep track of how many times each number occurs in the list. We iterate through and add the number to the map if it doesn\\'t exist and if it does we increment it by one. In the end we just go through each key value pair in the map and if any value is `1` (meaning there is only one instance of it) then we return the key to that value.\\n\\n**P.S** Feedback is always appreciated. Let me know what you think in the comments :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tsol = 0\\n\\tfor n in nums:\\n\\t\\tsol ^= n\\n\\n\\treturn sol\\n```\n```\\n>> x = 2  // 0010 in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n>> x ^= 3 // 0010 ^ 0011 = 0001       (1) in bits\\n>> x ^= 3 // 0001 ^ 0011 = 0010       (2) in bits\\n...\\n```\n```\\n# Note this is not fast or memory efficient but it is readable\\ndef singleNumber(self, nums: List[int]) -> int:\\n\\tref = {}\\n\\tfor i in nums:\\n\\t\\tif i not in ref:\\n\\t\\t\\tref[i] = 1\\n\\t\\telse:\\n\\t\\t\\tref[i] += 1\\n\\n\\tfor k, v in ref.items():\\n\\t\\tif v == 1 :\\n\\t\\t\\treturn k\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444555,
                "title": "4-different-solutions-in-go",
                "content": "### 1. Using a HashMap (Set) to find the single number\\n\\n> Runtime: 8 ms, faster than 95.97%\\n> Memory Usage: 5.4 MB, less than 14.29%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  for _, num := range nums {\\n    if _, found := m[num]; found {\\n      delete(m, num)\\n    } else {\\n      m[num] = struct{}{}\\n    }\\n  }\\n  for k := range m {\\n    return k\\n  }\\n  return -1\\n}\\n```\\n\\n### 2. Using a HashMap (Set) to create a Set of numbers\\n\\n> Runtime: 8 ms, faster than 95.97%\\n> Memory Usage: 5.4 MB, less than 14.29%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  var wholeSum int\\n  for _, num := range nums {\\n    m[num] = struct{}{}\\n    wholeSum += num\\n  }\\n  var uniqueSum int\\n  for num := range m {\\n    uniqueSum += num\\n  }\\n  return uniqueSum*2 - wholeSum\\n}\\n```\\n\\n### 3. Sorting the array\\n\\n> Runtime: 16 ms, faster than 15.99%\\n> Memory Usage: 4.7 MB, less than 100.00%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  sort.Ints(nums)\\n  lastIndex := len(nums) - 1\\n  for i := 0; i < lastIndex; i += 2 {\\n    if nums[i] != nums[i+1] {\\n      return nums[i]\\n    }\\n  }\\n  return nums[lastIndex]\\n}\\n```\\n\\n### 4. Bit manipulation (XOR)\\n\\n> Runtime: 8 ms, faster than 95.94%\\n> Memory Usage: 4.7 MB, less than 100.00%\\n\\n```go\\nfunc singleNumber(nums []int) int {\\n  var result int\\n  for _, num := range nums {\\n    result ^= num\\n  }\\n  return result\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  for _, num := range nums {\\n    if _, found := m[num]; found {\\n      delete(m, num)\\n    } else {\\n      m[num] = struct{}{}\\n    }\\n  }\\n  for k := range m {\\n    return k\\n  }\\n  return -1\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  m := map[int]struct{}{}\\n  var wholeSum int\\n  for _, num := range nums {\\n    m[num] = struct{}{}\\n    wholeSum += num\\n  }\\n  var uniqueSum int\\n  for num := range m {\\n    uniqueSum += num\\n  }\\n  return uniqueSum*2 - wholeSum\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  sort.Ints(nums)\\n  lastIndex := len(nums) - 1\\n  for i := 0; i < lastIndex; i += 2 {\\n    if nums[i] != nums[i+1] {\\n      return nums[i]\\n    }\\n  }\\n  return nums[lastIndex]\\n}\\n```\n```go\\nfunc singleNumber(nums []int) int {\\n  var result int\\n  for _, num := range nums {\\n    result ^= num\\n  }\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254014,
                "title": "java-no-extra-memory",
                "content": "My solution, no extra memory.\\n```\\npublic int singleNumber(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[0] = nums[0] ^ nums[i];\\n        }\\n        return nums[0];\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n        for (int i = 1; i < nums.length; i++) {\\n            nums[0] = nums[0] ^ nums[i];\\n        }\\n        return nums[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 132680,
                "title": "kotlin-reduce-and-xor-1-line",
                "content": "```fun singleNumber(data: IntArray) = data.reduce { acc, i -> acc.xor(i) }```",
                "solutionTags": [],
                "code": "```fun singleNumber(data: IntArray) = data.reduce { acc, i -> acc.xor(i) }```",
                "codeTag": "Unknown"
            },
            {
                "id": 3367818,
                "title": "beginner-friendly-javascript-bitwise-explanation-47ms-99-83-beats-6-lines-code",
                "content": "![Screenshot 2023-04-02 at 01.21.19.png](https://assets.leetcode.com/users/images/5f6d740d-c4be-4a28-b060-7f38fa574e1a_1680391459.988997.png)\\n\\n# What is XOR operation and how it works:\\n\\nXOR (Exclusive OR) is a logical operation that takes two operands and returns a result based on their boolean values. The operation returns true if and only if exactly one of the operands is true.\\n\\nIn the context of binary numbers, the XOR operation is applied bitwise to each pair of corresponding bits, and the result is a new binary number. The operation returns a 1 in each bit position where the corresponding bits of the operands are different, and a 0 where they are the same.\\n\\nHere\\'s an example of how XOR works on two binary numbers, *1010* and *1101*:\\n```\\n  1010\\nX 1101\\n-----\\n  0111\\n```\\nIn this example, the XOR operation was applied bitwise to each pair of bits in the two operands. The result is a new binary number, 0111, which is the XOR of 1010 and 1101.\\n\\nIn the context of the code we have been discussing, the XOR operation is used to find the single number in an array of numbers that does not have a duplicate. The properties of the XOR operation ensure that when the same number is XORed twice, it results in 0, effectively cancelling out any duplicates. The remaining number that is not cancelled out is the single number that we are looking for.\\n# Explanation\\n1. Check if the input array nums is empty. If it is empty, the function immediately returns 0.\\n2. Initialize a variable called num to 0.\\n3. Iterate through each element of the input array nums.\\n4. For each element, apply the XOR operation between the current value of num and the value of the element. Store the result back in num.\\n5. After all elements have been processed, return the value of num.\\n\\n\\n# Complexity\\n- Time complexity:\\nIt is O(n), where n is the length of the input array. This is because the code iterates through each element of the array exactly once to perform the XOR operation.\\n\\n- Space complexity:\\nIt is O(1), as it only uses a constant amount of extra space to store the num variable. This means that the space required by the code does not depend on the size of the input array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n    if(nums.length<0){\\n        return 0\\n    }\\n    let num = 0 ;\\n    for (let i = 0; i<nums.length; i++ ){\\n        num^=nums[i]\\n    }\\n    return num\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n  1010\\nX 1101\\n-----\\n  0111\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNumber = function(nums) {\\n    if(nums.length<0){\\n        return 0\\n    }\\n    let num = 0 ;\\n    for (let i = 0; i<nums.length; i++ ){\\n        num^=nums[i]\\n    }\\n    return num\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125796,
                "title": "python-simple-solution-linear-runtime-constant-space-explained",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        #go through each numbers\\n        for i in nums:\\n            #Using count method to check how many times current number appear in array\\n            if nums.count(i) == 1:\\n            #IF the current number appear 1 so return the answer\\n                return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        #go through each numbers\\n        for i in nums:\\n            #Using count method to check how many times current number appear in array\\n            if nums.count(i) == 1:\\n            #IF the current number appear 1 so return the answer\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045415,
                "title": "c-and-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var result = 0;\\n        for (int i = 0; i < nums.Length; i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int SingleNumber(int[] nums) {\\n        var result = 0;\\n        for (int i = 0; i < nums.Length; i++){\\n            result ^= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041411,
                "title": "swift-solution-using-xor-with-comments-beats-93",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we use the property of XOR operation, that is a^b^b = a. \\nSo, if we take XOR of all the elements, the duplicated ones will cancel out each other and we will be left with the single element.\\n\\n# Code\\n```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        \\n        var result = 0\\n\\n        for num in nums {\\n            result ^= num\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n# A little theory\\nThe XOR (exclusive OR) operation is a logical operation that compares two binary digits and returns 1 if they are different and 0 if they are the same. It is represented by the symbol \"^\".\\n\\nThe XOR operation has several properties that make it useful in various algorithms and problems. Some of the most important properties of XOR are:\\n\\nCommutative: The order of the operands does not affect the result, so a^b = b^a\\nAssociative: The grouping of the operands does not affect the result, so (a^b)^c = a^(b^c)\\nIdentity: a^0 = a\\nInverse: a^a = 0",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func singleNumber(_ nums: [Int]) -> Int {\\n        guard !nums.isEmpty else { return 0 }\\n        \\n        var result = 0\\n\\n        for num in nums {\\n            result ^= num\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007305,
                "title": "java-easy-solution-beginner-friendly-beat-100",
                "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n            \\n        }\\n    \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans=ans^nums[i];\\n            \\n        }\\n    \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765242,
                "title": "simple-fast",
                "content": "```\\nclass Solution:\\n\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\tresult = 0\\n\\n\\t\\tfor i in nums:\\n\\t\\t\\tresult = result ^ i\\n\\n\\t\\treturn result \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef singleNumber(self, nums: List[int]) -> int:\\n\\n\\t\\tresult = 0\\n\\n\\t\\tfor i in nums:\\n\\t\\t\\tresult = result ^ i\\n\\n\\t\\treturn result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522877,
                "title": "java-solution-time-o-n-space-o-1-xor-explained",
                "content": "The property of XOR :-\\n\\n0 ^ 0 --> 0\\n0 ^ 1 --> 1\\n1 ^ 0 --> 1\\n1 ^ 1 --> 0\\nWe know every number is appears twice except a single number which appears only single time.\\n\\nSee, we already discuss a thing a that xor of a same number with itself is zero, i.e A ^ A = 0\\nNow, we will look some more property of xor-\\n\\n1) xor of a same number with itself is zero, i.e A ^ A = 0.\\n2) xor of any number with zero is the number itself i.e A ^ 0 = A.\\n\\nOur array is : {4,1,2,1,2}\\n                      4^1  \\n\\t\\t\\t\\t\\t  4^1^2\\n\\t\\t\\t\\t\\t  4^1^2^1   ->[1^1=0]\\n\\t\\t\\t\\t\\t  4^2\\n\\t\\t\\t\\t\\t  4^2^2    -> [2^2=0]\\n\\t\\t\\t\\t\\t  4\\n\\t\\t\\t\\t\\t  So, the element which we got as left should be our answer, so the answer is  \\'4\\'\\n\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t  Time complexicity -> O(n)\\n\\t\\t\\t\\t\\t  Space complexicity -> O(1)\\n\\t\\t\\t\\tcode :-\\t  \\n\\t\\t\\t\\t\\t  class Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0; \\n      for(int i=0; i<nums.length; i++) {\\n          res = res ^ nums[i]; \\n      }\\n        return res;\\n    }\\n}\\nIf you find this useful, kindly consider to upvote.\\n\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0; \\n      for(int i=0; i<nums.length; i++) {\\n          res = res ^ nums[i]; \\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1645511,
                "title": "python-3-faster-than-92-98-one-liner",
                "content": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(set(nums))*2 - sum(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return sum(set(nums))*2 - sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491449,
                "title": "js-xor-solution",
                "content": "```\\nvar singleNumber = function(nums) {\\n    let single = 0;\\n    for (let num of nums) {\\n        single ^= num\\n    }\\n    return single\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNumber = function(nums) {\\n    let single = 0;\\n    for (let num of nums) {\\n        single ^= num\\n    }\\n    return single\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1468062,
                "title": "c-super-straight-forward-solution-using-xor",
                "content": "```\\n/*\\n    https://leetcode.com/problems/single-number/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int unique = 0;\\n        // XOR of A XOR A = 0, so all duplicates will cancel each other, \\n        // leaving the non duplicate \\n        for(int &num: nums)\\n            unique ^= num;\\n        return unique;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/single-number/\\n    \\n    TC: O(N)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int unique = 0;\\n        // XOR of A XOR A = 0, so all duplicates will cancel each other, \\n        // leaving the non duplicate \\n        for(int &num: nums)\\n            unique ^= num;\\n        return unique;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998258,
                "title": "rust-fold-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Single Number.\\nMemory Usage: 2.2 MB, less than 80.77% of Rust online submissions for Single Number.\\n```\\nimpl Solution {\\n    pub fn single_number(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn single_number(nums: Vec<i32>) -> i32 {\\n        nums.iter().fold(0, |acc, x| acc ^ x)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955161,
                "title": "python-1-liner-maths-logic-without-using-libraries-beats-97",
                "content": "![image](https://assets.leetcode.com/users/images/05f7734e-e9d1-48d7-9075-b3e307bb55af_1606775426.1568828.png)\\n\\n```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        return ((2*(sum(set(nums))))-(sum(nums)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        return ((2*(sum(set(nums))))-(sum(nums)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813225,
                "title": "simple-typescript-math-solution",
                "content": "```\\nconst singleNumber = (nums: number[]): number => {\\n  const set = new Set(nums);\\n  const setSum = [...set].reduce((acc, elem) => acc + elem);\\n  const numsSum = nums.reduce((acc, elem) => acc + elem);\\n\\n  return 2 * setSum - numsSum;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst singleNumber = (nums: number[]): number => {\\n  const set = new Set(nums);\\n  const setSum = [...set].reduce((acc, elem) => acc + elem);\\n  const numsSum = nums.reduce((acc, elem) => acc + elem);\\n\\n  return 2 * setSum - numsSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 562515,
                "title": "136-single-number-java-100-speed-with-notes-explaining-solution",
                "content": "```\\npublic int singleNumber(int[] nums) {\\n        // Count the number of integers in the array\\n        int size = nums.length;\\n        // Isolate the first number in the array\\n        int result = nums[0];\\n        \\n        // Traverse through the entire array starting from the second number\\n        for (int i = 1; i < size; i++)\\n            /**\\n             * Use an XOR gate to find the number without a match.\\n             *\\n             * XOR or Exclusive Or is a  logical operation that outputs\\n             * true only when inputs differ (one is true, the other is\\n             * false).\\n             *\\n             * In this case, the program will traverse through the array\\n             * adding each number to the result until it comes to a number\\n             * it has already added. Instead of adding a number again, the\\n             * program will subtract the number from result. When the\\n             * for-loop has completed, the result will be the number\\n             * that was added but not subtracted.\\n             * */\\n            result = result ^ nums[i];\\n            \\n        // Return the \"true\" integer that does not appear twice\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int singleNumber(int[] nums) {\\n        // Count the number of integers in the array\\n        int size = nums.length;\\n        // Isolate the first number in the array\\n        int result = nums[0];\\n        \\n        // Traverse through the entire array starting from the second number\\n        for (int i = 1; i < size; i++)\\n            /**\\n             * Use an XOR gate to find the number without a match.\\n             *\\n             * XOR or Exclusive Or is a  logical operation that outputs\\n             * true only when inputs differ (one is true, the other is\\n             * false).\\n             *\\n             * In this case, the program will traverse through the array\\n             * adding each number to the result until it comes to a number\\n             * it has already added. Instead of adding a number again, the\\n             * program will subtract the number from result. When the\\n             * for-loop has completed, the result will be the number\\n             * that was added but not subtracted.\\n             * */\\n            result = result ^ nums[i];\\n            \\n        // Return the \"true\" integer that does not appear twice\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378036,
                "title": "java-hashset-solution",
                "content": "Time complexity: O(n)\\nSpace complexity: O(n)\\n```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        //Sanity check\\n        if (nums == null || nums.length < 1) {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) {\\n                set.remove(num);\\n            } else {\\n                set.add(num);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        //Sanity check\\n        if (nums == null || nums.length < 1) {\\n            return 0;\\n        }\\n        Set<Integer> set = new HashSet<>();\\n        for (int num : nums) {\\n            if (set.contains(num)) {\\n                set.remove(num);\\n            } else {\\n                set.add(num);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43085,
                "title": "my-simple-javascript-solution",
                "content": "var singleNumber = function(nums) {\\n            nums.sort();\\n            for (var i = 0; i < nums.length; i += 2) {\\n                if (nums[i] != nums[i + 1]) {\\n                    return nums[i];\\n                }\\n            }\\n        };",
                "solutionTags": [],
                "code": "var singleNumber = function(nums) {\\n            nums.sort();\\n            for (var i = 0; i < nums.length; i += 2) {\\n                if (nums[i] != nums[i + 1]) {\\n                    return nums[i];\\n                }\\n            }\\n        };",
                "codeTag": "Unknown"
            },
            {
                "id": 3545995,
                "title": "python-o-n-with-mathematical-explanation-and-comparison-xor",
                "content": "# Simple Math Explanation \\n\\nThis problem involves mathematics application to solve the problem. We are given a list of numbers which has single occurence of a number and the rest numbers occur twice.\\n\\nThe XOR (^) comes into picture to solve the problem.\\nThe XOR truth table:\\nA | B | A ^ B\\n ---| --- | ---\\n1 | 1 | 0\\n0 | 1 | 1\\n1 | 0 | 1\\n0 | 0 | 0\\n\\nTherefore, if an element(A) occurs twice, then A ^ A = 0\\nAlso, since, 0 ^ B = B, we reach the final stage where we get the odd one out.\\nWe also have to take in consideration on more math law([Rule of Association](https://www.javatpoint.com/laws-and-rules-of-boolean-algebra-in-digital-electronics)):\\n> (A ^ B) ^ C = A ^ (B ^ C)\\n\\n</br>\\nConsider the below number list:\\n> [1,2,1]\\nWe begin the operations from the left side (according to precedence of operations) <br>\\n\\n> (1 ^ 2) ^ 1\\n= 2 ^ (1 ^ 1)\\n=  2 ^ (False)\\n=  2\\n\\nThere, we have the single occuring element, 2.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\nI have implemented the approach using loops and lambda for both beginner and advanced implementations.\\n\\n``` Python_Simple_Approach []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res = nums[0]\\n        for val in nums[1:]:\\n            res ^= val\\n        return res\\n```\\n```Python_Using_Reduce_and_Lambda []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```\\nExecution time and memory for simple approach\\n![Image of Execution time and memory for simple approach](https://assets.leetcode.com/users/images/45ca0279-267d-493a-9213-cbed24396c0a_1679894667.6784487.png)\\n\\n<hr></hr>\\nExecution time and memory for simple approach\\n\\n![Image of Execution time and memory for simple approach](https://assets.leetcode.com/users/images/448edc17-d2bf-4991-b2bf-b4e74d495b8c_1679894709.117987.png)\\n\\n### Please upvote if you find it helpful",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "``` Python_Simple_Approach []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        res = nums[0]\\n        for val in nums[1:]:\\n            res ^= val\\n        return res\\n```\n```Python_Using_Reduce_and_Lambda []\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x ^ y, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464164,
                "title": "c-python-o-1-space",
                "content": "\\n# Using bitwise XOR\\na ^ 0 = a\\na ^ a = 0 , so every duplicate will become 0 and only the single no. will remain\\n\\neg : [ -1, 2, 3, -2, -1] now if we add all elements of this array then only 3 will remain , that\\'s how XOR also works ,order doesn\\'t matter, like 2 ^ 3 ^ 2 ^ 1 ^ 3 = 3 ^ 2 ^ 2 ^ 3 ^ 1 =  and so on ..\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int once = 0;\\n        for(auto i : nums) {\\n            once ^= i;\\n        }\\n        return once;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        once = 0\\n        for i in nums:\\n            once ^= i\\n        return once\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int once = 0;\\n        for(auto i : nums) {\\n            once ^= i;\\n        }\\n        return once;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        once = 0\\n        for i in nums:\\n            once ^= i\\n        return once\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166006,
                "title": "best-c-solutions-bit-manipulation-xor-sorting-hash-table-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using multiple approaches.\\n\\n1. Using Sorting.\\n2. Using Hash Table.\\n3. Using Bit Manipulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(NlogN). Since we are using sorting.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i+=2){\\n            if(nums[i-1] != nums[i]){\\n                return nums[i-1];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of nums. Here loop creates the times complexity.\\n    Space Complexity : O(N), Unordered map space.\\n\\n    Using Array + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(it.second == 1){\\n                return it.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n    Space complexity: O(1), Constant Space.\\n\\n    Solved using Array + Bit Manipulation(Xor).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int res = 0;\\n        for(auto it : nums){\\n            res ^= it;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(NlogN). Since we are using sorting.\\n\\n    Space Complexity : O(1). Since we are not using any auxiliary space.\\n\\n    Using Array + Sorting.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i=1; i<n; i+=2){\\n            if(nums[i-1] != nums[i]){\\n                return nums[i-1];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of nums. Here loop creates the times complexity.\\n    Space Complexity : O(N), Unordered map space.\\n\\n    Using Array + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto it : nums){\\n            map[it]++;\\n        }\\n        for(auto it : map){\\n            if(it.second == 1){\\n                return it.first;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Where N is the size of Array(nums). Here loop creates the times complexity.\\n\\n    Space complexity: O(1), Constant Space.\\n\\n    Solved using Array + Bit Manipulation(Xor).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int res = 0;\\n        for(auto it : nums){\\n            res ^= it;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080343,
                "title": "3-easy-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        bool flag;\\n        int i, j;\\n        int ans = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            flag = false;\\n            for (j = 0; j < nums.size(); j++) {\\n                if (nums[i] == nums[j] && i != j) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag == false) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```\\n# Approach 2\\nHashmap\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map <int, int> mp;\\n        int ans;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (mp[nums[i]] == 1) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;      \\n    }\\n};\\n```\\n\\n# Approach 3\\nBit Magic\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        bool flag;\\n        int i, j;\\n        int ans = 0;\\n        for (i = 0; i < nums.size(); i++) {\\n            flag = false;\\n            for (j = 0; j < nums.size(); j++) {\\n                if (nums[i] == nums[j] && i != j) {\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if (flag == false) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map <int, int> mp;\\n        int ans;\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]]++;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (mp[nums[i]] == 1) {\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;      \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567884,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1720470,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1572607,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565663,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1569469,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1938174,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1573009,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1566345,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565420,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565834,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1567884,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1720470,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1572607,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565663,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1569469,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1938174,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1573009,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1566345,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565420,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1565834,
                "content": [
                    {
                        "username": "ABoyNamedCrow",
                        "content": "This is trivial if you understand bitwise operations, and as far as I know, impossible to solve in O(1) space if you don't. Since bitwise operations don't come up often in actual programming, I think this problem is bad, as either an interview question or an intellectually interesting brain-teaser."
                    },
                    {
                        "username": "vmoathome",
                        "content": "[@shaun-sweet](/shaun-sweet) using a set is not an acceptable solution, since problem description states that you must only use O(constant) extra space."
                    },
                    {
                        "username": "leson1106",
                        "content": "[@davist6](/davist6) Unfortunately, they said `use only constant extra space`"
                    },
                    {
                        "username": "davist6",
                        "content": "This can easily be solved without bitwise operations using two sets."
                    },
                    {
                        "username": "HarrisonA",
                        "content": "This is definitely no an easy question, unless you know bitwise manipulation."
                    },
                    {
                        "username": "juansymontano",
                        "content": "[@arobe91594](/arobe91594) True. I too dislike specific knowledge based difficulty -- it is not a good measure of how well someone codes. I did not know how to approach this until I read this discussion.\\n\\nIf this was an interview question I\\'d fail."
                    },
                    {
                        "username": "arobe91594",
                        "content": "[@charonme](/charonme) To be fair, the constraints guarantee that what you mention holds true. But I agree that this does not belong in the easy category. The knowledge required is just too specific, and I heavily dislike when the difficulty of a problem is characterized in a way which may discourage newer programmers."
                    },
                    {
                        "username": "CalCreate",
                        "content": "Thanks for the hint - I had no idea what bitwise operations was and this was stumping me"
                    },
                    {
                        "username": "charonme",
                        "content": "yeah exactly, this definitely isn\\'t \"easy\" and also it only works if there is exactly one non-paired number in the array and all the other numbers are paired"
                    },
                    {
                        "username": "shaun-sweet",
                        "content": "i don\\'t know bitwise operations (front end dev).  I did it by tossing each number as a key in a map which points to true.  Before that, however, I\\'m checking to see if the key exists and deleting it if it does.  then i\\'m just returning the first key in the map as my result which is O(n) runtime.  its memory intensive, however"
                    },
                    {
                        "username": "mascomen4",
                        "content": "I had a number of technical interviews when they gave me problems related to bitwise operations  "
                    },
                    {
                        "username": "Jypar",
                        "content": "Hint :  XOR of two equal numbers gives 0 :)"
                    },
                    {
                        "username": "xxdouhua",
                        "content": "![image](https://assets.leetcode.com/users/xxdouhua/image_1554869704.png)\\n****\\n![image](https://assets.leetcode.com/users/xxdouhua/image_1554869741.png)\\n\\n"
                    },
                    {
                        "username": "Architmishr",
                        "content": "[@AnisahC](/AnisahC)  it is 4, just a typing mistake."
                    },
                    {
                        "username": "AnisahC",
                        "content": "wouldn\\'t the output for the second case be 4?"
                    },
                    {
                        "username": "loudnut",
                        "content": "Hello guys,\\n\\nIf I'm curious how frequently a specific problem is asked in an interview, where can I see the statics?\\nI looked almost everywhere in the page but just couldn't find it.\\n\\nThank you all :D"
                    },
                    {
                        "username": "mkohar",
                        "content": "[@pozitron](/pozitron)  exactly! at this point I am tired of reporting his comments"
                    },
                    {
                        "username": "pozitron",
                        "content": "[@AdityaBhate](/AdityaBhate) could You please stop spamming everyone with the links to your solutions ?"
                    },
                    {
                        "username": "MiloTheDog",
                        "content": "I thought the array has to be ordered in order for this to work. After looking into how bitwise XOR works, here is an example. \\n\\nit does the XOR operation on the bit representation of the number; \\n\\n8 => 1000\\n15 =>1111\\n8 ^ 15 = 7 => 0111\\n7 ^ 8 = 15 => 1111\\n\\nYou are welcome :)"
                    },
                    {
                        "username": "anushamaurya",
                        "content": "Thanks!! "
                    },
                    {
                        "username": "ajaypathade8788",
                        "content": "[@JaredMathis](/JaredMathis) but this way has problem of Runtime error"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If the array is sorted, then the duplicates will be sequential. Therefore a number that was different on either side would be the answer."
                    },
                    {
                        "username": "an5dy90",
                        "content": "emotional damage"
                    },
                    {
                        "username": "ansb2011",
                        "content": "The best solution is to use a bit shifting idea, which seems like it can be done in O(1). But, it can\\'t. \\n\\nThe integer used to hold the bits being canceled by the XORing must be large enough to contain all of the bits in the largest integer. So, if the largest integer needs only 2 bits, the additional memory can be 2 bits (plus the iterator/index counter). However, if the largest integer requires 100 bits, the the additional memory requires 100 bits. \\n\\nWe know that numbers are not repeated more than once, so at worst case the nth number is n, which requires log2(n) bits to store. \\n\\nSo, the extra memory required is actually at worst O(log(n))!\\n\\nNote that if we use 32 bit integers (or really integers of any fixed size) as our tracking bits, we can pretend the memory used is constant - but really all we\\'ve done is allocated a lot of extra memory which happens to be enough."
                    },
                    {
                        "username": "xgordon",
                        "content": "why do you think this is the best solution? XOR\\'s commutativity makes this possible with one stack allocation?"
                    },
                    {
                        "username": "uditnarayan",
                        "content": "functools.reduce(operator.ixor, nums)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-number/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** List operation\n\n  \n**Approach 2:** Hash Table\n\n  \n**Approach 3:** Math\n\n  \n**Approach 4:** Bit Manipulation\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "yesterdaysun",
                        "content": "    def single_number(nums)\\n      nums.reduce(:^)\\n    end"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    }
                ]
            },
            {
                "id": 1568956,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1568606,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1825606,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1767548,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1574573,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1572235,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1572058,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571294,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1574851,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571293,
                "content": [
                    {
                        "username": "gn00437805",
                        "content": "public int SingleNumber(List<int> searchList)\\n       \\n {\\n            \\n  return searchList.Aggregate( (a, b) => a ^ b); \\n\\n }"
                    },
                    {
                        "username": "Felicia919",
                        "content": "\\'\\'\\'\\nreturn 2*sum(set(nums))-sum(nums)\\n\\'\\'\\'"
                    },
                    {
                        "username": "ericmcelyea",
                        "content": "Can we just generally agree it is a gimmicky question if there is only one workable solution that fits all the constraints?"
                    },
                    {
                        "username": "FerasBarahmeh",
                        "content": "\\nkeep in mind we will find a solution in one loop (linear runtime complexity)\\n\\nAsk yourself a question how i can abandon duplicate numbers ?\\n\\nIt may be dangerous for your mind tow solutions\\n\\n- subtraction the repated numbers\\n- using XOR operator (We Will solve problem in this way)\\n    in XOR operation the same number will give zero (in binary)\\n    for example :\\n        3 ^ 3 Three in binary equal 0 0 1 1\\n       let\\'s Go applay Xor operation :  3 ^ 3\\n        0 0 1 1\\n        0 0 1 1 ^\\n        -------\\n        0 0 0 0\\n\\n    I hope the explanation is clear at the this point\\n\\n    Now I think you can now imagine the solution\\n    if you applay xor for all elemnet in array all the appears    twice numbers will give zeros in the result you find just a single number Let tack example\\n\\n    array = [4,1,2,1,2]\\n    let sort array [1,1,2,2,4]\\n    1 ^ 1 = 0 \\n    0 ^ 2 ^ 2 = 0 ***(0 the result of 1 ^ 1 = 0)***\\n    0 ^ 4 = 4 \\n   (So The Result is 4)\\n\\n"
                    },
                    {
                        "username": "silentvoyager",
                        "content": "I didn\\'t realize I could use XOR so I came up with a tricky solution that used the fact the input numbers are in [-30000,30000] range so require 2 bytes each. I reused the upper 2 bytes of each element in the array to implement an open addressing hash set with linear probing. Basically the hash set ended up being in place in the same input array without using any additional memory. I realized this was overcomplicated but I was interested to see if I could make this work. I did."
                    },
                    {
                        "username": "ondeezesug",
                        "content": "[@1Hanif1](/1Hanif1) you need to attend your data structure classes lol \\n"
                    },
                    {
                        "username": "1Hanif1",
                        "content": "I\\'m 2 years late but can you explain what \"open addressing hash set with linear probing\" is please?"
                    },
                    {
                        "username": "yqzfm123",
                        "content": " return reduce(lambda a,b:a^b,nums)"
                    },
                    {
                        "username": "zhenf",
                        "content": "Most of the submissions of O(n) without extra space here use XOR. Is there any other possible solutions here?"
                    },
                    {
                        "username": "shourovkun",
                        "content": "[@srkr](/srkr) Doesn\\'t set_of_nums have linear space complexity?"
                    },
                    {
                        "username": "srkr",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        sum_of_nums=sum(nums)\\n        sum_of_set=sum(set(nums))\\n        single_number = 2*sum_of_set-sum_of_nums\\n        return single_number"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        x=Counter(nums)\\n        t=min(x.values())\\n        for x1,y1 in x.items():\\n            if y1==t:\\n                return x1"
                    },
                    {
                        "username": "Niloofar.montazeri",
                        "content": "I can see how the xor solution works for an array like [1,2,1,3,2,4,3,...], where at most 2 numbers are combined with xor before one gets cancelled. But Let's say the array is arranged as [1,2,3,4,5  1,2,3,4,5,6]. Then the cumulative xor of the first five elements should be able to keep [the information] for all these five numbers, so that they get cancelled, one by one, after the 6th element. How is that possible?"
                    },
                    {
                        "username": "mikematar",
                        "content": "\\'\\'\\'\\nprint([k for k,v in Counter(nums).items() if v==1][0])\\n\\'\\'\\'"
                    },
                    {
                        "username": "magiclin",
                        "content": "    def single_number(nums)\\n      nums.inject(&:^)\\n    end"
                    }
                ]
            },
            {
                "id": 1571295,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 1575362,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 1571928,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2074267,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2072776,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2069067,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2065678,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2064320,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2055747,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2046328,
                "content": [
                    {
                        "username": "AnastasiiaL",
                        "content": "     x = nums[0]\\n        for i in 1...nums.size do x = x^nums[i] end\\n     x"
                    },
                    {
                        "username": "amrithaunni",
                        "content": "\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t\\t# Xoring the entire list will give the unique element\\n\\t\\treturn reduce(lambda x, y: x ^ y, nums)\\n"
                    },
                    {
                        "username": "sweetleaf",
                        "content": "Can we solve this problem by sorting the array and doing a binary search?"
                    },
                    {
                        "username": "hadinajafi",
                        "content": "Yes. you also can use Stack when you sort it. If stack is empty, just push, and if next element is as same as the head of stack, then pop the element.\\nAt the end, only the unique element will remain at stack."
                    },
                    {
                        "username": "chandrikabijore",
                        "content": "ask"
                    },
                    {
                        "username": "ShubhRajawat",
                        "content": "sort() method is allowed here\\n"
                    },
                    {
                        "username": "Shahwali_python",
                        "content": "can i use ` count ` function \\n"
                    },
                    {
                        "username": "eascgpq048",
                        "content": "Does anybody known which promble with this code?\\n\\nclass Solution(object):\\n    def singleNumber(self, nums):\\n        for i in range(len(nums)):\\n            found_match = False\\n            for j in range(i+1, len(nums)):\\n                if nums[i] == nums[j]:\\n                    found_match = True\\n                    break\\n            if not found_match and nums[i] not in nums[:i]:\\n                print(nums[i])"
                    },
                    {
                        "username": "coveyjorjet",
                        "content": "HINT: XOR is your friend here"
                    },
                    {
                        "username": "kundanpms527",
                        "content": "int singleNumber(vector<int>& nums)\\n     {\\n         int result = 0;\\n    for (int num : nums) {\\n        result ^= num;\\n    }\\n    return result;\\n     }"
                    },
                    {
                        "username": "Sugamgoel28",
                        "content": "Celebrate the small victory that you solved this one. Give a shot to [Single Number II](https://leetcode.com/problems/single-number-ii/description/) now. All the best \\u2728"
                    }
                ]
            },
            {
                "id": 2017201,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2015335,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2010807,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2010338,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2005921,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 2005890,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1998202,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1996606,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1992220,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1988819,
                "content": [
                    {
                        "username": "zurakatsura",
                        "content": "It can be solved without bitwise in O(1) as well right? Make a set of array, generate sum - sum of array values."
                    },
                    {
                        "username": "ysarath2022",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n       int n = nums.size();\\n     vector<int> count;\\n       for(int i=0;i < n; i++)\\n       {\\n           count[nums[i]]++;\\n       }\\n       for(int i = 0; i< n ; i++)\\n       {\\n           if(count[nums[i]] == 1)\\n           return nums[i];\\n        }\\n        return (-1);\\n\\n        \\n    }\\n}; why is my code not working"
                    },
                    {
                        "username": "Mohtashim_ali",
                        "content": "A simple question for all the people with sound knowledge of logic gates , bit manipulations etc "
                    },
                    {
                        "username": "TwilightVortex",
                        "content": "Hey I don\\'t know if this well help anyone or not, but here is a solution without XOR in C. It is certainly not very effecient, but it works so here it is:\\n\\n```\\nstruct pair {\\n    int num;\\n    bool paired;\\n};\\n\\nvoid addNum(struct pair *nums, int num, int *size) {\\n    for (int i = 0; i < *size; i++) {\\n        if (nums[i].num == num) {\\n            nums[i].paired = true;\\n        }\\n    }\\n    nums[size].num = num;\\n    nums[size].paired = false;\\n    *(size)++;\\n}\\n\\nint singleNumber(int* nums, int numsSize){\\n    int size = 0;\\n    struct pair *nums = malloc(sizeof(struct pair) * numsSize);\\n    for (int i = 0; i < numsSize; i++) {\\n           addNum(nums, num, &size);\\n    }\\n    for (int i = 0; i < size; i++) {\\n        if (nums[i].paired == false) {\\n            return nums[i].num;\\n        }\\n    }\\n    return 1;\\n} \\n```"
                    },
                    {
                        "username": "anilkumarhv",
                        "content": "Hi Guys, XOR operation giving wrong output for below input array\\nint[] nums= [4, 1, 2, 1, 2, 4, 7, 1]\\nexpected output: 7\\nbut actual output : 6"
                    },
                    {
                        "username": "himanshuone",
                        "content": "This Submission passed all the Test cases but, Why I\\'m getting Good Feelings with This?\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        dic=dict()\\n        for _ in nums:\\n            if _ not in dic:\\n                dic[_]=0\\n            else:\\n                dic[_]=dic.get(_)+1\\n        temp = min(dic.values())\\n        res = [key for key in dic if dic[key] == temp]\\n        return (res[0])"
                    },
                    {
                        "username": "user3594P",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int a=0;\\n        int [] fr =new int[nums.length];\\n        int v=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int count=1;\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]==nums[j]){\\n                    count++;\\n                    fr[j]=v;\\n                }\\n            }\\n            if (fr[i]!=v){\\n                fr[i]=count;\\n            }\\n             for(int x=0;x<fr.length;x++)\\n             {\\n                 if(fr[x]==1)\\n                 {\\n                     a=nums[i];\\n                 }\\n             }\\n\\n        }\\n        return a;\\n    }\\n} can anyone tell the error in code ?\\n"
                    },
                    {
                        "username": "kunalmahadule77",
                        "content": "Solution of the problem in Python\\n\\nclass Solution:\\n    def singleNumber(self, nums):\\n        # Initialize the result variable with 0\\n        result = 0\\n\\n        # XOR all the elements in the array\\n        for num in nums:\\n            result ^= num\\n\\n        return result\\n"
                    },
                    {
                        "username": "mg5050",
                        "content": "Bad problem description. For people who don\\'t know it\\'s a bit manipulation problem, they need to specify that all inputs are powers of 2. The expected solution does not work once you start throwing in non-power-of-2 numbers, and it\\'s not listed as a constraint anywhere.\\n\\nConstraints should be updated with:\\n\\nnums[i] == 2^X\\n\\nIt\\'s a trick question as far as I\\'m concerned."
                    },
                    {
                        "username": "hugjobk",
                        "content": "If you know how to swap 2 numbers without using a temporary variable then you will know the solution :))"
                    }
                ]
            },
            {
                "id": 1943007,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1941832,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1940387,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1937163,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1927862,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1927126,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1920226,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1907192,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1907190,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1878150,
                "content": [
                    {
                        "username": "Pokemon_Margo",
                        "content": "At first I decided by the logical method that came to mind. I saw that the speed was too low. I read the comments. Learned the binary method - XOR :) "
                    },
                    {
                        "username": "user8257Am",
                        "content": "i was using hash array technique, but it is failing one testcase when array has -ve elements. i am not sure how can i take care of -ve element."
                    },
                    {
                        "username": "ArunSreekanth",
                        "content": "How do we get the idea to solve using XOR. "
                    },
                    {
                        "username": "Ricardommgomes",
                        "content": "Hi [@ArunSreekanth](/ArunSreekanth)\\nThe following challenges requires you to find out which single number is only represented once in an array. The XOR operator is perfect for this. If you XOR every number in your array you will get the singled out number.\\n\\nHere is an example:\\nInput: nums = [4,1,2,1,2]\\n4 ^ 1 = 5  \\n5 ^ 2 = 7\\n7 ^ 1 = 6\\n6 ^ 2 = 4\\nOutput: 4\\n\\nIf you want to know more what XOR is: https://www.w3schools.com/js/js_bitwise.asp \\n"
                    },
                    {
                        "username": "vishalrana17",
                        "content": "when mums[-1]\\noutput is -1\\nand my output is 1\\ncan any one tell my right one\\n\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n       for(int i =0;i<nums.length-1;i++){\\n           int curr = nums[i];\\n           for(int j=i+1;j<nums.length;j++){\\n               if(curr!=nums[j]&&curr-1!=nums[j]){\\n              return curr;\\n               }\\n               }\\n           }\\n          return  1;\\n\\n       }\\n}"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "Bitwise XOR : if corresponding number is different it gives 1 else it shows 0."
                    },
                    {
                        "username": "harika_drona",
                        "content": "if i try to submit this code, i am getting output as time limit exceeded for the testcase 59\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        for i in range(0,n):\\n            count =0\\n            for j in range(0,n):\\n                if(nums[i]==nums[j]):\\n                    count+=1\\n                    \\n            if(count==1):\\n                return nums[i]\\n\\nCan someone help me "
                    },
                    {
                        "username": "RipperPY",
                        "content": "SPOILER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\\n\\nclass Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "Traverse the array and XOR  all the elements, if repeated then reduces to 0 else remain ,then return."
                    },
                    {
                        "username": "Gaurav_kumar4460",
                        "content": "XOR of equal numbers is 0 and XOR of 0 and any number is the number itself."
                    },
                    {
                        "username": "Mohd_Musaiyab",
                        "content": "Well the given problem can easily be solved using Bitwise Operators .Using the EX-OR operator will just give us the answer we need.\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans=nums[i] ^ ans;\\n        }\\n        return ans;\\n              }\\n};"
                    }
                ]
            },
            {
                "id": 1840988,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1826599,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1824907,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1805259,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1805248,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1803246,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1803217,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1794956,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1786805,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1785569,
                "content": [
                    {
                        "username": "Sudhanshu145",
                        "content": "it is very easy if you know about bitwise operation and or or xor .. etc..\n"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "I have tried this but I don\\'t why i showing error\\n    def singleNumber(self, nums):\\n        if len(nums)<=1:\\n            return nums\\n        else:\\n            temp = Counter(nums)\\n            for i in temp:\\n                if temp[i] == 1:\\n                    return i"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "So, looking at the discussion section I understood that it has to do with bit manipulation. But guys I have a doubt by any chance can we use Moore\\'s voting algorithm? Like the element which will repeat will first be 1, 2, then 0 but the element which is appearing only once will go like 1 then 0. \\n\\nExample: [4,1, 2,1,2]\\nElement: 4\\nVotes: 1, 0\\n\\nGotcha it can\\'t be used as when I cancel 4 and go to 1 the votes too will become and 1 then 0 as the array is not sorted and we can\\'t even sort it as we need to solve it in linear time complexity. "
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n       from collections import Counter\\n       nums = Counter(nums)\\n       for key, val in nums.items():\\n\\n        if val == 1:\\n           return key"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        else if(nums.size() > 1){\\n             sort(nums.begin(),nums.end());\\n\\n             for(int i=0;i<nums.size();i++){\\n                 if(nums[i] != nums[i+1]){\\n                     return nums[i];\\n                 }\\n                 i++;\\n             }\\n        }\\n        return nums[0];\\n\\n    //     int ans = 0;\\n    //     for(int i = 0; i<nums.size();i++){\\n    //         ans = ans^nums[i];\\n    //     }\\n    //     return ans;\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Since in XOR Operations 0^0 = 0 and 1^1 = 0.\nHence here the same bits(numbers) will cancel out each other i.e result to zero and only the unique bit(number) will be left.!!!\n\nA^A=0\nA^B^A=B\n(A^A^B) = (B^A^A) = (A^B^A) = B This shows that position doesn't matter.\nSimilarly , if we see , a^a^a......... (even times)=0 and a^a^a........(odd times)=a\n\n\n\n\nclass Solution {\n  int singleNumber(List<int> nums) {\n    \n    int res = 0;\n    for(int i in nums){\n        res = res^i;\n    }\n      return res;\n  }\n}\n\n\n\n"
                    },
                    {
                        "username": "MrunalMania",
                        "content": "XOR and concept of reduce function in python , makes this problem one-liner."
                    },
                    {
                        "username": "agupta354",
                        "content": " `class Solution {\\n    public int singleNumber(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int j=0;\\n        for(int i=1;i<nums.length;i=i+2){\\n            if(nums[j]!=nums[i]){\\n                return nums[j];\\n            }\\n            j=j+2;\\n        }\\n\\n        return nums[j];\\n\\n    }\\n}`"
                    },
                    {
                        "username": "shivam08122001",
                        "content": "this solution is given by using c only\\ndeclare a int (suppose Ans) keep Ans=nums[0];\\nthen by using loop perform xor on the given array, start the index from 1\\nex:-for(int i=1; ..............................................)\\n{\\nans=ans+nums[i];\\n}\\n"
                    }
                ]
            },
            {
                "id": 1783051,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1781246,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1774418,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1768168,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1767664,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1764748,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1760643,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1758411,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757341,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1756357,
                "content": [
                    {
                        "username": "skcoder007",
                        "content": "Time Complexity = O(n)\nSpace Complexity = O(1) \n/* Bit Manipulation  using XOR\nn^n=0\n0^n=n\nso, 0^3^7^5^3^5 = 7\n\n``class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int n = nums.size();\n        int res =0;\n        for (int i=0;i<n;i++){\n            res=res^nums[i];\n        }\n        return res;\n    }\n};``\n"
                    },
                    {
                        "username": "natest77",
                        "content": "Go for  solving the problem using xor which gives 100% runtime,less code and easy to understand. Others solution may be there but solution using xor will be so intresting!!! . "
                    },
                    {
                        "username": "Ambarcode",
                        "content": "Won\\'t be easy if You don\\'t know the concept of bitwise operator(XOR here)"
                    },
                    {
                        "username": "bravepoatotes",
                        "content": "Everytime I run the following code: \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            o = nums.count(i)\\n        for k in nums:\\n            if o<=0:\\n                return k\\n`\\nI get the following error\\n\\n TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 31 in _driver (Solution.py)\\n    _driver()\\nLine 38 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 29 in _driver (Solution.py)\\n\\nAnyone know why this is happening?"
                    },
                    {
                        "username": "ayush3105",
                        "content": "You can use property of XOR"
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in nums:\\n            if nums.count(i) == 1:\\n                return i\\n"
                    },
                    {
                        "username": "Snigdha_Reddy_Kathula",
                        "content": "It includes Arrays combines with Bit Manipulation. we can use XOR here,\\nTip: a^a=0\\n       a^0=a\\nby using this you can solve this easily, i think"
                    },
                    {
                        "username": "user9423V",
                        "content": "for i in set(nums):\\n            nums.remove(i)\\n            if i not in nums:\\n                return i\\n            else:\\n                nums.remove(i)\\n        return \"not found\""
                    },
                    {
                        "username": "clever_code",
                        "content": "Hello guys, can you find out the problem in my code\\n\\nimport java.util.Arrays;\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int ans = nums[0];\\n        for (int i = 0; i < n-1; i+=2){\\n            if (!(nums[i] == nums[i+1])){\\n                ans = nums[i];\\n                return nums[i];\\n            }\\n            else{\\n                ans = nums[n-1];\\n                return nums[n-1];\\n            }\\n        }\\n        return ans;\\n    }\\n} "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754996,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1746239,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1739414,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1736284,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1736277,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1728891,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1727538,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1726490,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1726224,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1724071,
                "content": [
                    {
                        "username": "jamesschreiner03",
                        "content": "Using this code \\n`class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if nums.count(nums[i]) == 1:\\n                print(nums[i])\\n                break\\n            else:\\n                continue\\n`\\nThere a TypeError that only occurs while in the LeetCode IDE. In a local IDE the arrays output the correct answers.\\nThis is the error\\n `TypeError: None is not valid value for the expected return type integer\\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\\nLine 32 in _driver (Solution.py)\\n    _driver()\\nLine 39 in <module> (Solution.py)\\nDuring handling of the above exception, another exception occurred:\\nTypeError: \\'<\\' not supported between instances of \\'int\\' and \\'NoneType\\'\\nLine 12 in _serialize_int (./python3/__serializer__.py)\\nLine 61 in _serialize (./python3/__serializer__.py)\\n    out = ser._serialize(ret, \\'integer\\')\\nLine 30 in _driver (Solution.py)`"
                    },
                    {
                        "username": "piyush_chhawachharia",
                        "content": "What if I use a HashMap and store all elements along with the frequency so that would take O(N) time and then for O(N) for finding the element in HashMap with frequency as 1\\nWorks in O(N).\\n"
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "wouldn\\'t be constant space, which was specified"
                    },
                    {
                        "username": "Pratham2000",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        Arrays.sort(nums);\\n        int single = nums[0];\\n        for(int i =0;i<nums.length-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                i=+1;              \\n            }\\n            else if(nums[i]!=nums[i+1]){\\n                single = nums[i];\\n            }\\n        }\\n        return single;\\n        \\n    }\\n}\\n\\nIs my solution right? If there is no Time Limit."
                    },
                    {
                        "username": "gc-leetcode",
                        "content": "sort is N log N not linear time"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            ans=ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n//SC: O(1), TC:O(1)"
                    },
                    {
                        "username": "srijans",
                        "content": "class Solution {\\n    public int singleNumber(int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(set.contains(nums[i])){\\n                set.remove(nums[i]);\\n            }else{\\n                set.add(nums[i]);\\n            }\\n        }\\n        return set.iterator().next();\\n    }\\n}\\n//TC: O(n) SC: O(n)"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/125_valid_pallindrome.cpp"
                    },
                    {
                        "username": "tppatil910",
                        "content": "// Easy Solution in java\\n  int unique = nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            unique ^= nums[i];\\n        }   \\n        return unique;"
                    },
                    {
                        "username": "elfaidi-ghassen",
                        "content": "God bless JavaScript\\'s objects!"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "int n=(int)nums.size();\\n        int a=0;\\n        for(int i=0;i<n;i++){\\n            a^=nums[i];\\n        }\\n        return a;"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\n    public int singleNumber(int[] nums) {\\n        int res = 0;\\n        for (int n : nums) {\\n            res ^= n;\\n        }\\n        return res;\\n    }\\n}\\n```"
                    }
                ]
            },
            {
                "id": 1723961,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1715611,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1711607,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1710369,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1708943,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1706927,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1684179,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1680317,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1671026,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            },
            {
                "id": 1670516,
                "content": [
                    {
                        "username": "thanyaniinnocent20",
                        "content": "I\\'ve a question : I used a hash Map to count every number from array using a for loop, which I believe it\\'s O(n). Then I loop through dict keys when I find a value which a value is 1, I returned the key. It\\'s also O(n) thus O(2n) which is equivalent to O(n). Is this solution fine or maybe I\\'m wrong with my BigO? "
                    },
                    {
                        "username": "_hopa_",
                        "content": "hello guys, how to solve this problem by Map stls in Cpp"
                    },
                    {
                        "username": "user2891YF",
                        "content": "You can use a set. Go through the numbers, if the number is already in the set, remove it, otherwise add it. At the end of the loop, you\\'ll have exactly one number left in your set so you can just return the front iterator."
                    },
                    {
                        "username": "ak_r_a_m_7",
                        "content": "XOR approach is well efficient"
                    },
                    {
                        "username": "shank9931",
                        "content": "I am going to ask a very newbie question here, please bear with me.\n\nQuestion1: Why did my code not work ?\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n       int ans;\n       sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               ans=nums[i-1];\n               break;\n                  }\n           else{\n              ans=nums[nums.size()-1];\n                 }\n       }\n       return ans;\n    }\n};\n```\nas opposed to this\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int ans;\n        sort(nums.begin(),nums.end());\n       for(int i=1;i<nums.size();i=i+2){\n           if(nums[i]!=nums[i-1]){\n               return nums[i-1];\n           }\n       }\n       return nums[nums.size()-1];\n    }\n};\n```\n\nPlease do not be harsh to the noob.\n\nQuestion 2: \nTestcase 3: nums=[1]\n\nhow nums[1]!=nums[0] is compared as there are no elements for nums[1]? Or why isn't there an error?"
                    },
                    {
                        "username": "vansh_agarwal31",
                        "content": "SIMPLE 3LINE CODE EASY TO UNDERSTAND\\n\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n      int a=0;\\n      for(int i =0; i<nums.size();i++)\\n      {\\n          a = a^nums[i];\\n      }\\n      return a;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "shank9931",
                        "content": "nice work vansh. \\nCould you checkout my question above and help me with it?"
                    },
                    {
                        "username": "mezbahuddin800",
                        "content": "class Solution:\\n    def singleNumber(self, nums: List[int]) -> int:\\n\\t    return reduce(lambda total, el: total ^ el, nums)"
                    },
                    {
                        "username": "hawkeye1806",
                        "content": "class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) { \\n       unordered_map<int,int> a;\\n\\t   for(auto x: nums)\\n\\t\\t   a[x]++;\\n\\t   for(auto z:a)\\n\\t\\t   if(z.second==1)\\n\\t\\t\\t   return z.first;\\n\\t   return -1;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714O(N) | Optimized EZ Bit - Manipulation CPP\\uD83C\\uDFC6\\nhttps://leetcode.com/problems/single-number/solutions/2221211/o-n-optimized-ez-bit-manipulation-cpp/"
                    },
                    {
                        "username": "shank9931",
                        "content": "Hey Aditya could you help me with my question posted here? Thanks in advance."
                    },
                    {
                        "username": "mascomen4",
                        "content": "They key idea I think is that you try to apply XOR to more than two operands..."
                    },
                    {
                        "username": "harishkhope89",
                        "content": "easy approach | hashmap implementation| faster than 60%  of submissions\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        unordered_map<int, int >mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto i: mp){\\n            if (i.second==1){\\n                return i.first;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}; \\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Lowest Common Ancestor of a Binary Tree",
        "question_content": "<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: &ldquo;The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <b>a node to be a descendant of itself</b>).&rdquo;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" style=\"width: 200px; height: 190px;\" />\n<pre>\n<strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.</li>\n\t<li><code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code></li>\n\t<li>All <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>p != q</code></li>\n\t<li><code>p</code> and <code>q</code> will exist in the tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 65225,
                "title": "4-lines-c-java-python-ruby",
                "content": "Same solution in several languages. It\\'s recursive and expands the meaning of the function. If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil.\\n\\nUpdate: I also wrote [two iterative solutions](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65245/Iterative-Solutions-in-PythonC%2B%2B) now, one of them being a version of the solution here. They\\'re more complicated than this simple recursive solution, but I do find them interesting.\\n\\n---\\n\\n**C++**\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (!root || root == p || root == q) return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        return !left ? right : !right ? left : root;\\n    }\\n\\n---\\n\\n**Python**\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        left, right = (self.lowestCommonAncestor(kid, p, q)\\n                       for kid in (root.left, root.right))\\n        return root if left and right else left or right\\n\\nOr using that `None` is considered smaller than any node:\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        subs = [self.lowestCommonAncestor(kid, p, q)\\n                for kid in (root.left, root.right)]\\n        return root if all(subs) else max(subs)\\n\\n---\\n\\n**Ruby**\\n\\n    def lowest_common_ancestor(root, p, q)\\n        return root if [nil, p, q].index root\\n        left = lowest_common_ancestor(root.left, p, q)\\n        right = lowest_common_ancestor(root.right, p, q)\\n        left && right ? root : left || right\\n    end\\n\\n---\\n\\n**Java**\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left == null ? right : right == null ? left : root;\\n    }",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby"
                ],
                "code": "Same solution in several languages. It\\'s recursive and expands the meaning of the function. If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil.\\n\\nUpdate: I also wrote [two iterative solutions](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65245/Iterative-Solutions-in-PythonC%2B%2B) now, one of them being a version of the solution here. They\\'re more complicated than this simple recursive solution, but I do find them interesting.\\n\\n---\\n\\n**C++**\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (!root || root == p || root == q) return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        return !left ? right : !right ? left : root;\\n    }\\n\\n---\\n\\n**Python**\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        left, right = (self.lowestCommonAncestor(kid, p, q)\\n                       for kid in (root.left, root.right))\\n        return root if left and right else left or right\\n\\nOr using that `None` is considered smaller than any node:\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        if root in (None, p, q): return root\\n        subs = [self.lowestCommonAncestor(kid, p, q)\\n                for kid in (root.left, root.right)]\\n        return root if all(subs) else max(subs)\\n\\n---\\n\\n**Ruby**\\n\\n    def lowest_common_ancestor(root, p, q)\\n        return root if [nil, p, q].index root\\n        left = lowest_common_ancestor(root.left, p, q)\\n        right = lowest_common_ancestor(root.right, p, q)\\n        left && right ? root : left || right\\n    end\\n\\n---\\n\\n**Java**\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left == null ? right : right == null ? left : root;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 65226,
                "title": "my-java-solution-which-is-easy-to-understand",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root == null || root == p || root == q)  return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if(left != null && right != null)   return root;\\n            return left != null ? left : right;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root == null || root == p || root == q)  return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if(left != null && right != null)   return root;\\n            return left != null ? left : right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 152682,
                "title": "python-simple-recursive-solution-with-detailed-explanation",
                "content": "```\\ndef lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\t\\t\\t\\t# If looking for me, return myself\\n        if root == p or root == q:\\n            return root\\n        \\n        left = right = None\\n        # else look in left and right child\\n        if root.left:\\n            left = self.lowestCommonAncestor(root.left, p, q)\\n        if root.right:\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n\\n        # if both children returned a node, means\\n        # both p and q found so parent is LCA\\n        if left and right:\\n            return root\\n        else:\\n        # either one of the chidren returned a node, meaning either p or q found on left or right branch.\\n        # Example: assuming \\'p\\' found in left child, right child returned \\'None\\'. This means \\'q\\' is\\n        # somewhere below node where \\'p\\' was found we dont need to search all the way, \\n        # because in such scenarios, node where \\'p\\' found is LCA\\n            return left or right\\n```",
                "solutionTags": [],
                "code": "```\\ndef lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n\\t\\t\\t\\t# If looking for me, return myself\\n        if root == p or root == q:\\n            return root\\n        \\n        left = right = None\\n        # else look in left and right child\\n        if root.left:\\n            left = self.lowestCommonAncestor(root.left, p, q)\\n        if root.right:\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n\\n        # if both children returned a node, means\\n        # both p and q found so parent is LCA\\n        if left and right:\\n            return root\\n        else:\\n        # either one of the chidren returned a node, meaning either p or q found on left or right branch.\\n        # Example: assuming \\'p\\' found in left child, right child returned \\'None\\'. This means \\'q\\' is\\n        # somewhere below node where \\'p\\' was found we dont need to search all the way, \\n        # because in such scenarios, node where \\'p\\' found is LCA\\n            return left or right\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65236,
                "title": "java-python-iterative-solution",
                "content": "**Python**\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        stack = [root]\\n        parent = {root: None}\\n        while p not in parent or q not in parent:\\n            node = stack.pop()\\n            if node.left:\\n                parent[node.left] = node\\n                stack.append(node.left)\\n            if node.right:\\n                parent[node.right] = node\\n                stack.append(node.right)\\n        ancestors = set()\\n        while p:\\n            ancestors.add(p)\\n            p = parent[p]\\n        while q not in ancestors:\\n            q = parent[q]\\n        return q\\n\\n    # 31 / 31 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 108 ms\\n    # 99.14%\\n\\n\\n**Java**\\n\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            Map<TreeNode, TreeNode> parent = new HashMap<>();\\n            Deque<TreeNode> stack = new ArrayDeque<>();\\n            parent.put(root, null);\\n            stack.push(root);\\n    \\n            while (!parent.containsKey(p) || !parent.containsKey(q)) {\\n                TreeNode node = stack.pop();\\n                if (node.left != null) {\\n                    parent.put(node.left, node);\\n                    stack.push(node.left);\\n                }\\n                if (node.right != null) {\\n                    parent.put(node.right, node);\\n                    stack.push(node.right);\\n                }\\n            }\\n            Set<TreeNode> ancestors = new HashSet<>();\\n            while (p != null) {\\n                ancestors.add(p);\\n                p = parent.get(p);\\n            }\\n            while (!ancestors.contains(q))\\n                q = parent.get(q);\\n            return q;\\n        }\\n    }\\n\\nTo find the lowest common ancestor, we need to find where is `p` and `q` and a way to track their ancestors. A `parent` pointer for each node found is good for the job. After we found both `p` and `q`, we create a set of `p`'s `ancestors`. Then we travel through `q`'s `ancestors`, the first one appears in `p`'s is our answer.",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            Map<TreeNode, TreeNode> parent = new HashMap<>();\\n            Deque<TreeNode> stack = new ArrayDeque<>();\\n            parent.put(root, null);\\n            stack.push(root);\\n    \\n            while (!parent.containsKey(p) || !parent.containsKey(q)) {\\n                TreeNode node = stack.pop();\\n                if (node.left != null) {\\n                    parent.put(node.left, node);\\n                    stack.push(node.left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1306476,
                "title": "c-python-2-solutions-clean-concise-o-n",
                "content": "**\\u2714\\uFE0F Solution 1: Depth First Search**\\n- Please note that `p` and `q` always exist in the tree.\\n- Since we `dfs` from the root down to its children, if current `root == p` or `root == q` then current `root` must be their LCA.\\n- If `left` subtree contains one of descendant (`p` or `q`) and `right` subtree contains the remaining descendant (`q` or `p`) then the `root` is their LCA.\\n- If `left` subtree contains both `p` and `q` then return `left` as their LCA.\\n- If `right` subtree contains both `p` and `q` then return `right` as their LCA.\\n\\nFor a clear explanation, you can check video title \"Lowest Common Ancestor Binary Tree\" by \"Tushar Roy\" on Youtube.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q: return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        if left != None and right != None: return root\\n        if left != None: return left\\n        return right\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == nullptr || root == p || root == q) return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        if (left != nullptr && right != nullptr) return root;\\n        if (left != nullptr) return left;\\n        return right;\\n    }\\n};\\n```\\n\\nComplexity:\\n- Time: `O(N)`, where `N` is number of nodes in the Binary Tree.\\n- Space: `O(H)`, where `H` is the heigh of Binary Tree.\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Find Parent and Level of nodes**\\n- Using `dfs` to find `parent` and `level` of nodes.\\n- Make `p` and `q` go to the same level that is if `level[p] < level[q]` then jump `q` to parents `level[q] - level[p]` times else jump `p`.\\n- Jump both `p` and `q` util they meet at thier LCA.\\n- Return their LCA.\\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        def jumpParent(u, steps):\\n            while steps > 0:\\n                u = parent[u]\\n                steps -= 1\\n            return u\\n\\n        def dfs(u, p, depth):\\n            if u == None: return\\n            parent[u] = p\\n            level[u] = depth\\n            dfs(u.left, u, depth + 1)\\n            dfs(u.right, u, depth + 1)\\n\\n        parent = dict()\\n        level = dict()\\n        dfs(root, None, 0)\\n        if level[p] < level[q]:  # Make node p and node q the same level\\n            q = jumpParent(q, level[q] - level[p])\\n        else:\\n            p = jumpParent(p, level[p] - level[q])\\n        while q != p:  # Jump util their LCA\\n            q = parent[q]\\n            p = parent[p]\\n        return q\\n```\\nComplexity:\\n- Time & Space: `O(N)`, where `N` is number of nodes in the Binary Tree.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q: return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        if left != None and right != None: return root\\n        if left != None: return left\\n        return right\\n```\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == nullptr || root == p || root == q) return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        if (left != nullptr && right != nullptr) return root;\\n        if (left != nullptr) return left;\\n        return right;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        def jumpParent(u, steps):\\n            while steps > 0:\\n                u = parent[u]\\n                steps -= 1\\n            return u\\n\\n        def dfs(u, p, depth):\\n            if u == None: return\\n            parent[u] = p\\n            level[u] = depth\\n            dfs(u.left, u, depth + 1)\\n            dfs(u.right, u, depth + 1)\\n\\n        parent = dict()\\n        level = dict()\\n        dfs(root, None, 0)\\n        if level[p] < level[q]:  # Make node p and node q the same level\\n            q = jumpParent(q, level[q] - level[p])\\n        else:\\n            p = jumpParent(p, level[p] - level[q])\\n        while q != p:  # Jump util their LCA\\n            q = parent[q]\\n            p = parent[p]\\n        return q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65375,
                "title": "very-simple-dfs-c-solution-only-10-lines",
                "content": "    TreeNode * dfsTraverse(TreeNode * root, TreeNode * p , TreeNode * q)\\n    {\\n        if( root == p || root == q || root == NULL)\\n            return root;\\n        TreeNode * parent1 = dfsTraverse(root->left, p, q);\\n        TreeNode * parent2 = dfsTraverse(root->right, p, q);\\n        if( parent1 && parent2)\\n            return root;\\n        else\\n            return parent1 ? parent1:parent2;\\n    }\\n    TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * p, TreeNode * q)\\n    {\\n        return dfsTraverse(root, p, q);\\n    }",
                "solutionTags": [],
                "code": "    TreeNode * dfsTraverse(TreeNode * root, TreeNode * p , TreeNode * q)\\n    {\\n        if( root == p || root == q || root == NULL)\\n            return root;\\n        TreeNode * parent1 = dfsTraverse(root->left, p, q);\\n        TreeNode * parent2 = dfsTraverse(root->right, p, q);\\n        if( parent1 && parent2)\\n            return root;\\n        else\\n            return parent1 ? parent1:parent2;\\n    }\\n    TreeNode * lowestCommonAncestor(TreeNode * root, TreeNode * p, TreeNode * q)\\n    {\\n        return dfsTraverse(root, p, q);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1037162,
                "title": "python-easy-to-understand",
                "content": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q:\\n            return root\\n        \\n\\t\\t# Find p/q in left subtree\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n\\t\\t\\n\\t\\t# Find p/q in right subtree\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n        \\n\\t\\t# If p and q found in left and right subtree of this node, then this node is LCA\\n        if l and r:\\n            return root\\n        \\n\\t\\t# Else return the node which returned a node from it\\'s subtree such that one of it\\'s ancestor will be LCA\\n        return l if l else r\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q:\\n            return root\\n        \\n\\t\\t# Find p/q in left subtree\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n\\t\\t\\n\\t\\t# Find p/q in right subtree\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n        \\n\\t\\t# If p and q found in left and right subtree of this node, then this node is LCA\\n        if l and r:\\n            return root\\n        \\n\\t\\t# Else return the node which returned a node from it\\'s subtree such that one of it\\'s ancestor will be LCA\\n        return l if l else r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65245,
                "title": "iterative-solutions-in-python-c",
                "content": "**Solution 1**\\n\\nSame algorithm as [my recursive solution](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65225/4-lines-C%2B%2BJavaPythonRuby) (look there if you want some explanation), but iterative. I do a post-order traversal with a stack. Each stack element at first is a [node, parent] pair, where parent is the stack element of the node\\'s parent node. When the children of a parent get finished, their results are appended to their parent\\'s stack element. So when a parent gets finished, we have the results of its children/subtrees available (its stack element at that point is [node, parent, resultForLeftSubtree, resultForRightSubtree]).\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        answer = []\\n        stack = [[root, answer]]\\n        while stack:\\n            top = stack.pop()\\n            (node, parent), subs = top[:2], top[2:]\\n            if node in (None, p, q):\\n                parent += node,\\n            elif not subs:\\n                stack += top, [node.right, top], [node.left, top]\\n            else:\\n                parent += node if all(subs) else max(subs),\\n        return answer[0]\\n\\n---\\n\\n**Solution 2**\\n\\nHere I find the paths to p and q and then find the last node where the paths match. I just came up with the path-building technique for this, and I find it quite neat and maybe it could be useful elsewhere.\\n\\n    def lowestCommonAncestor(self, root, p, q):\\n        def path(root, goal):\\n            path, stack = [], [root]\\n            while True:\\n                node = stack.pop()\\n                if node:\\n                    if node not in path[-1:]:\\n                        path += node,\\n                        if node == goal:\\n                            return path\\n                        stack += node, node.right, node.left\\n                    else:\\n                        path.pop()\\n        return next(a for a, b in zip(path(root, p), path(root, q))[::-1] if a == b)\\n\\n---\\n\\n**C++ version of Solution 1**\\n\\nI don\\'t use C++ much, so maybe there\\'s room for improvement with stuff that I don\\'t know.\\n\\n    class Solution {\\n        struct Frame {\\n            TreeNode* node;\\n            Frame* parent;\\n            vector<TreeNode*> subs;\\n        };\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            Frame answer;\\n            stack<Frame> stack;\\n            stack.push({root, &answer});\\n            while (stack.size()) {\\n                Frame *top = &stack.top(), *parent = top->parent;\\n                TreeNode *node = top->node;\\n                if (!node || node == p || node == q) {\\n                    parent->subs.push_back(node);\\n                    stack.pop();\\n                } else if (top->subs.empty()) {\\n                    stack.push({node->right, top});\\n                    stack.push({node->left, top});\\n                } else {\\n                    TreeNode *left = top->subs[0], *right = top->subs[1];\\n                    parent->subs.push_back(!left ? right : !right ? left : node);\\n                    stack.pop();\\n                }\\n            }\\n            return answer.subs[0];\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Iterator"
                ],
                "code": "class Solution {\\n        struct Frame {\\n            TreeNode* node;\\n            Frame* parent;\\n            vector<TreeNode*> subs;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65372,
                "title": "javascript-solution",
                "content": "    function lowestCommonAncestor(root, p, q) {\\n      if (!root || root === p || root === q) return root;\\n      var resL = lowestCommonAncestor(root.left, p, q);\\n      var resR = lowestCommonAncestor(root.right, p, q);\\n      return (resL && resR) ? root : (resL || resR);\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function lowestCommonAncestor(root, p, q) {\\n      if (!root || root === p || root === q) return root;\\n      var resL = lowestCommonAncestor(root.left, p, q);\\n      var resR = lowestCommonAncestor(root.right, p, q);\\n      return (resL && resR) ? root : (resL || resR);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1405170,
                "title": "4-steps-solution-easy-heavily-explained-with-complexities",
                "content": "* **I FOUND MY SOLUTION EASIER & MORE INTUITIVE THAN LEETCODE OFFICIAL SOLUTION / MANY OTHER SOLUTIONS TOO !!! : }**\\n* ``A VERY CLASSICAL PROBLEM OF BINARY TREE / GRAPH``\\n#### **EXPLANATION**\\n\\n* **`We\\'ll do just normal tree traversal of the given binary tree recursivly`.**  \\n* **`For finding LCA (lowest common ancestor) we\\'ve following conditions for every node in the tree,`**\\n* **`But before that, this solutions works under the assumption that both Node \\'p\\' & Node \\'q\\' will present in the tree...`**\\n* **`if single one of the node is present in the tree, it\\'ll not work or simply return null`.**\\n\\n#### **CONDITIONS: -**\\t\\t\\t\\t\\t\\t\\t\\t\\n1. **`if current node is same as \\'p\\' OR \\'q\\'.`**\\n2. **`if one of it\\'s subtrees contains \\'p\\' and other \\'q\\' (subtrees means, left_sub_tree and right_sub_tree).`**\\n3. **`if one of it\\'s subtree contains both \\'p\\' & \\'q\\'.`**\\n4. **`if none of it\\'s subtrees contains any of \\'p\\' & \\'q\\'.`**\\n\\n* **`Note: that\\'s a tricky implementation, but works well under the assumption that \\'p\\' & \\'q\\' will be definitely present`.**\\n\\n**EFFICIENT SOLUTION**\\n* **Runtime: 15ms [C++]**\\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(root == NULL) return NULL;\\n\\tif(root->val == p->val || root->val == q->val) return root;       // \\uD83D\\uDC49 FIRST CONDITION...\\n\\n\\tTreeNode* lca1 = lowestCommonAncestor(root->left, p, q);          // traverse on the left part of the tree\\n\\tTreeNode* lca2 = lowestCommonAncestor(root->right, p, q);         // traverse on the right part of the tree\\n\\n\\tif(lca1 != NULL && lca2 != NULL) return root;                     // \\uD83D\\uDC49 SECOND CONDITION... (IF BOTH SUB-TREE CONTAINS \\'p\\' & \\'q\\' RESPECTIVELY)\\n\\tif(lca1 != NULL) return lca1;                                     // \\uD83D\\uDC49 THIRD CONDITION...\\n\\treturn lca2;                                                      // \\uD83D\\uDC49 FOURTH CONDITION...\\n}\\n```\\n**TIME COMPLEXITY : `O(N), `Where N : total number of nodes in the BT\\nSPACE COMPLEXITY :` O(H) or O(N) (Worse Case)`, Where H : total height of tree for recursion stack**\\n\\n**(Found mistakes || Share something) ? Please** drop a comment :  **Please Upvote `(If it makes any sense)` ; }**\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(root == NULL) return NULL;\\n\\tif(root->val == p->val || root->val == q->val) return root;       // \\uD83D\\uDC49 FIRST CONDITION...\\n\\n\\tTreeNode* lca1 = lowestCommonAncestor(root->left, p, q);          // traverse on the left part of the tree\\n\\tTreeNode* lca2 = lowestCommonAncestor(root->right, p, q);         // traverse on the right part of the tree\\n\\n\\tif(lca1 != NULL && lca2 != NULL) return root;                     // \\uD83D\\uDC49 SECOND CONDITION... (IF BOTH SUB-TREE CONTAINS \\'p\\' & \\'q\\' RESPECTIVELY)\\n\\tif(lca1 != NULL) return lca1;                                     // \\uD83D\\uDC49 THIRD CONDITION...\\n\\treturn lca2;                                                      // \\uD83D\\uDC49 FOURTH CONDITION...\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 777296,
                "title": "faster-than-98-09-c-recursive",
                "content": "\\n     class Solution {\\n     public:\\n         TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n             if(root==NULL) return NULL;\\n        \\n             if(root==p || root==q) return root;\\n        \\n             TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n             TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        \\n             if(left!=NULL and right!=NULL) return root;\\n        \\n             return left!=NULL? left : right;\\n         }\\n     };\\n\\t \\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n     public:\\n         TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n             if(root==NULL) return NULL;\\n        \\n             if(root==p || root==q) return root;\\n        \\n             TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n             TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        \\n             if(left!=NULL and right!=NULL) return root;\\n        \\n             return left!=NULL? left : right;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 65251,
                "title": "clear-javascript-solution",
                "content": "```\\nconst lowestCommonAncestor = (root, p, q) => {\\n    if (!root || root === p || root === q) return root\\n    const left = lowestCommonAncestor(root.left, p, q)\\n    const right = lowestCommonAncestor(root.right, p, q)\\n    if (!left) return right  // p and q are in the right subtree\\n    if (!right) return left  // p and q are in the left subtree\\n    return root              // p is in one side and q is in the other\\n};\\n```\\nThe basic algorithm has been posted by many, but hopefully these commented lines will help someone.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst lowestCommonAncestor = (root, p, q) => {\\n    if (!root || root === p || root === q) return root\\n    const left = lowestCommonAncestor(root.left, p, q)\\n    const right = lowestCommonAncestor(root.right, p, q)\\n    if (!left) return right  // p and q are in the right subtree\\n    if (!right) return left  // p and q are in the left subtree\\n    return root              // p is in one side and q is in the other\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3231708,
                "title": "236-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The function lowestCommonAncestor takes in three parameters: the root of a binary tree (root) and two nodes of the binary tree (p and q).\\n\\n2. The first if statement checks if the root is None or if it is equal to either p or q. If either of these conditions is true, it means that we have found one of the nodes we are looking for, and we return the root.\\n\\n3. Next, we recursively call the lowestCommonAncestor function on the left and right subtrees of the root, passing in the same nodes p and q. We store the results of these recursive calls in variables l and r, respectively.\\n\\n4. The second if statement checks if both l and r are not None. If this condition is true, it means that we have found both p and q in different subtrees of the current root, and therefore the current root is the lowest common ancestor. We return the current root.\\n\\n5. If the second if statement is not satisfied, we return either l or r, depending on which one is not None. This is because if only one of l and r is not None, it means that the other node is not in the subtree of the current root, so we return the node that is in the subtree.\\n\\n6. If none of the previous conditions is satisfied, it means that both l and r are None, so we return None. This happens when we have reached the end of a branch of the binary tree without finding either p or q.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n    if not root or root == p or root == q:\\n      return root\\n\\n    l = self.lowestCommonAncestor(root.left, p, q)\\n    r = self.lowestCommonAncestor(root.right, p, q)\\n\\n    if l and r:\\n      return root\\n    return l or r\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n  def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n    if not root or root == p or root == q:\\n      return root\\n\\n    l = self.lowestCommonAncestor(root.left, p, q)\\n    r = self.lowestCommonAncestor(root.right, p, q)\\n\\n    if l and r:\\n      return root\\n    return l or r\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65335,
                "title": "java-iterative-and-recursive-solutions",
                "content": "        \\n    // iteratively \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        parent.put(root, null);\\n        queue.add(root);\\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\\n            TreeNode node = queue.poll();\\n            if (node != null) {\\n                parent.put(node.left, node);\\n                parent.put(node.right, node);\\n                queue.add(node.left);\\n                queue.add(node.right);\\n            }\\n        }\\n        Set<TreeNode> set = new HashSet<>();\\n        while (p != null) {\\n            set.add(p);\\n            p = parent.get(p);\\n        }\\n        while (!set.contains(q)) {\\n            q = parent.get(q);\\n        }\\n        return q;\\n    }\\n    \\n    // recursively\\n    public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        return l != null && r != null?root : l == null?r: l;\\n    }\\n    \\n    public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        int count = leftCount(root.left, p, q);\\n        if (count == 0) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        } else if (count == 2) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n    \\n    private int leftCount(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root == p && root == q) {\\n            return 2;\\n        }\\n        if (root == p || root == q) {\\n            return 1 + leftCount(root.left, p, q) + leftCount(root.right, p, q);\\n        }\\n        return leftCount(root.left, p, q) + leftCount(root.right, p, q);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // iteratively \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Map<TreeNode, TreeNode> parent = new HashMap<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        parent.put(root, null);\\n        queue.add(root);\\n        while (!parent.containsKey(p) || !parent.containsKey(q)) {\\n            TreeNode node = queue.poll();\\n            if (node != null) {\\n                parent.put(node.left, node);\\n                parent.put(node.right, node);\\n                queue.add(node.left);\\n                queue.add(node.right);\\n            }\\n        }\\n        Set<TreeNode> set = new HashSet<>();\\n        while (p != null) {\\n            set.add(p);\\n            p = parent.get(p);\\n        }\\n        while (!set.contains(q)) {\\n            q = parent.get(q);\\n        }\\n        return q;\\n    }\\n    \\n    // recursively\\n    public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        return l != null && r != null?root : l == null?r: l;\\n    }\\n    \\n    public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        int count = leftCount(root.left, p, q);\\n        if (count == 0) {\\n            return lowestCommonAncestor(root.right, p, q);\\n        } else if (count == 2) {\\n            return lowestCommonAncestor(root.left, p, q);\\n        } else {\\n            return root;\\n        }\\n    }\\n    \\n    private int leftCount(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        if (root == p && root == q) {\\n            return 2;\\n        }\\n        if (root == p || root == q) {\\n            return 1 + leftCount(root.left, p, q) + leftCount(root.right, p, q);\\n        }\\n        return leftCount(root.left, p, q) + leftCount(root.right, p, q);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3649508,
                "title": "c-easy-method",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root){\\n            return NULL;\\n        }\\n        if(root==p || root==q)return root;\\n        TreeNode* l,*r;\\n        l = lowestCommonAncestor(root->left,p,q);\\n        r= lowestCommonAncestor(root->right,p,q);\\n        if(l && r)return root;\\n        if(l)return l;\\n        if(r) return r;\\n        return NULL;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/a795b7d2-14fe-46fa-951b-0297c789a792_1687025691.7140567.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root){\\n            return NULL;\\n        }\\n        if(root==p || root==q)return root;\\n        TreeNode* l,*r;\\n        l = lowestCommonAncestor(root->left,p,q);\\n        r= lowestCommonAncestor(root->right,p,q);\\n        if(l && r)return root;\\n        if(l)return l;\\n        if(r) return r;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65228,
                "title": "5-lines-java-solution",
                "content": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left != null && right != null ? root : left == null ? right : left; \\n    }",
                "solutionTags": [],
                "code": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left != null && right != null ? root : left == null ? right : left; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65369,
                "title": "short-and-clean-c-solution",
                "content": "Want to share my solution.\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if (!root || !p || !q) {\\n            return NULL;\\n        }\\n        \\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        \\n        TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n        \\n        if (l && r) {\\n            return root;\\n        }\\n        \\n        return l? l : r;\\n    }",
                "solutionTags": [],
                "code": "Want to share my solution.\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if (!root || !p || !q) {\\n            return NULL;\\n        }\\n        \\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        \\n        TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n        \\n        if (l && r) {\\n            return root;\\n        }\\n        \\n        return l? l : r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65417,
                "title": "share-my-very-concise-python-solution",
                "content": "Not quite fast (around 300 ms), but very short.\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @param {TreeNode} p\\n        # @param {TreeNode} q\\n        # @return {TreeNode}\\n        def lowestCommonAncestor(self, root, p, q):\\n            # escape condition\\n            if (not root) or (root == p) or (root == q):\\n                return root\\n            # search left and right subtree\\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n            if left and right:\\n                # both found, root is the LCA\\n                return root\\n            return left or right\\n\\nWell, I just found that it is essentially the same as [this one][1] \\n\\n\\n  [1]: https://leetcode.com/discuss/45386/4-lines-c-java-python-ruby",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 65452,
                "title": "clean-java-solution-with-explanation",
                "content": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n      if (root == null || root == p || root == q)\\n        // found p or q or touch the ground\\n        return root;\\n            \\n      // search p and q from left and right\\n      TreeNode left = lowestCommonAncestor(root.left, p, q);\\n      TreeNode right = lowestCommonAncestor(root.right, p, q);\\n      \\n      if (left != null && right != null)\\n        // from root's left & right we found both p and q, so root is the LCA\\n        return root;\\n      else\\n        // left is not null means from left's left & right we found both q and q\\n        // so left is the LCA, otherwise, right is the answer\\n        return left != null ? left : right;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n      if (root == null || root == p || root == q)\\n        // found p or q or touch the ground\\n        return root;\\n            \\n      // search p and q from left and right\\n      TreeNode left = lowestCommonAncestor(root.left, p, q);\\n      TreeNode right = lowestCommonAncestor(root.right, p, q);\\n      \\n      if (left != null && right != null)\\n        // from root's left & right we found both p and q, so root is the LCA\\n        return root;\\n      else\\n        // left is not null means from left's left & right we found both q and q\\n        // so left is the LCA, otherwise, right is the answer\\n        return left != null ? left : right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2335047,
                "title": "c-100-faster-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if (!root)\\n            return root;\\n        \\n\\t\\t// If p or q if found, return the root.\\n        if (root == p || root == q)\\n            return root;\\n        \\n\\t\\t// Save the root found at left and right recursively\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        \\n\\t\\t// If both the nodes are found, return parent of that node. That will be root.\\n        if (left && right)\\n            return root;\\n        // If left is found, and right is not found.\\n\\t\\t// It is given that both the p and q will exist for sure.\\n\\t\\t// If left present then right will be a decendent of left, or vice versa.\\n        return left? left: right;\\n    }\\n};\\n```\\n**Note**\\nTry to dry run on the given test cases for better understanding.\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if (!root)\\n            return root;\\n        \\n\\t\\t// If p or q if found, return the root.\\n        if (root == p || root == q)\\n            return root;\\n        \\n\\t\\t// Save the root found at left and right recursively\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        \\n\\t\\t// If both the nodes are found, return parent of that node. That will be root.\\n        if (left && right)\\n            return root;\\n        // If left is found, and right is not found.\\n\\t\\t// It is given that both the p and q will exist for sure.\\n\\t\\t// If left present then right will be a decendent of left, or vice versa.\\n        return left? left: right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334071,
                "title": "c-java-full-explanations-bits-99-87",
                "content": "The very first thing we can observe from the question is that we can find the LCA of 2 given nodes from \\n\\n        i) Left subtree or in\\n\\n       ii) Right subtree, if not in both the subtrees then root will be the  LCA.\\n\\n**Approach:**\\n* If root is null or if root is x or if root is y then return root\\n* Made a recursion call for both on Left subtree and Right subtree\\n* If the left subtree recursive call gives a null value that means we haven\\u2019t found LCA in the left subtree, which means we found LCA on the right subtree. So we will return right.\\n* If the right subtree recursive call gives null value, that means we haven\\u2019t found LCA on the right subtree, which means we found LCA on the left subtree. So we will return left .\\n*  If both left & right calls give values (not null)  that means the root is the LCA.\\n\\n**For a better understanding of the above example (LCA OF 4,5) :**\\n![image](https://assets.leetcode.com/users/images/e6c0c5f8-0561-4012-80da-a8ff448761d5_1658794730.2941885.png)\\n\\n**Time complexity:** `O(N)` where n is the number of nodes.\\n\\n**Space complexity:** `O(N)`, auxiliary space.\\n\\n**If you like please upvote**\\n\\n**C++ Code:-**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //base case\\n        if (root == NULL || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n        //result\\n        if(left == NULL) {\\n            return right;\\n        }\\n        else if(right == NULL) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n};\\n```\\n\\n**Java Code:-**\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //base case\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        //result\\n        if(left == null) {\\n            return right;\\n        }\\n        else if(right == null) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        //base case\\n        if (root == NULL || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n        //result\\n        if(left == NULL) {\\n            return right;\\n        }\\n        else if(right == NULL) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //base case\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        //result\\n        if(left == null) {\\n            return right;\\n        }\\n        else if(right == null) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306449,
                "title": "lowest-common-ancestor-of-a-binary-tree-recursive-solution-w-explanation",
                "content": "***\\u2705 Solution 1(Recursion-Accepted):***\\n```\\n# Approach:\\nWe will use recursion to expand and extract out all the subtree possibilities,\\n\\nCases To Consider:\\n1) If the current subtree contains both the nodes then return the root node of current subtree as answer.\\n2) If the current subtree does not contain both the nodes then return NULL, as this cannot be the LCA,\\n3) If the current subtree contain only one node , then result will be itself that node.\\n\\n# Note:\\nIt is mentioned that both the nodes exist in the tree.\\n```\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if(!root)\\n            return NULL;\\n//         If root is itself one of the node\\n        if(root==p or root==q)\\n            return root;\\n//         Traverse the left of current subtree \\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n//         Traverse the right of current subtree\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n//         Both the nodes exist under current subtree\\n        if(left and right)\\n            return root;\\n//         Both the nodes don\\'t exist under current subtree\\n        if(!left and !right)\\n            return NULL;\\n//         One node is present in right of current subtree\\n        if(!left)\\n            return right;\\n//         One node is present in left of current subtree\\n        return left;\\n    }\\n};\\n```\\n**Time Complexity : O(N)**\\n**N - The number of nodes in the tree**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n# Approach:\\nWe will use recursion to expand and extract out all the subtree possibilities,\\n\\nCases To Consider:\\n1) If the current subtree contains both the nodes then return the root node of current subtree as answer.\\n2) If the current subtree does not contain both the nodes then return NULL, as this cannot be the LCA,\\n3) If the current subtree contain only one node , then result will be itself that node.\\n\\n# Note:\\nIt is mentioned that both the nodes exist in the tree.\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if(!root)\\n            return NULL;\\n//         If root is itself one of the node\\n        if(root==p or root==q)\\n            return root;\\n//         Traverse the left of current subtree \\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n//         Traverse the right of current subtree\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n//         Both the nodes exist under current subtree\\n        if(left and right)\\n            return root;\\n//         Both the nodes don\\'t exist under current subtree\\n        if(!left and !right)\\n            return NULL;\\n//         One node is present in right of current subtree\\n        if(!left)\\n            return right;\\n//         One node is present in left of current subtree\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65227,
                "title": "10-line-java-solution-solved-in-one-traversal",
                "content": "    public class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null){\\n            return null;\\n        }\\n        \\n        if(root == p || root == q){\\n            return root;\\n        }\\n        \\n        TreeNode l = lowestCommonAncestor(root.left,p,q);\\n        TreeNode r = lowestCommonAncestor(root.right,p,q);\\n        \\n        if(l != null && r != null){\\n            return root;\\n        }\\n        \\n        return l != null ? l:r;\\n \\n    }\\n}\\n\\n\\n\\nA modified version of pre-order traversal. The point to understand this is, once a sub-branch has a possible ancestor, all its super branches will have the same one.",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 168798,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return\\n        elif root.val == p.val or root.val == q.val:\\n            return root\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n        if l and r:\\n            return root\\n        else:\\n            return l or r\\n```\\nIterative:\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        queue = collections.deque([root])\\n        parent = {}\\n        while not (p in parent and q in parent):\\n            u = queue.popleft()\\n            if u.left:\\n                parent[u.left] = u\\n                queue.append(u.left)\\n            if u.right:\\n                parent[u.right] = u\\n                queue.append(u.right)\\n        \\n        res = set()\\n        trav = p\\n        while trav in parent:\\n            res.add(trav)\\n            trav = parent[trav]\\n        res.add(root)\\n        trav = q\\n        while not trav in res:\\n            trav = parent[trav]\\n        return trav\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return\\n        elif root.val == p.val or root.val == q.val:\\n            return root\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n        if l and r:\\n            return root\\n        else:\\n            return l or r\\n```\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        queue = collections.deque([root])\\n        parent = {}\\n        while not (p in parent and q in parent):\\n            u = queue.popleft()\\n            if u.left:\\n                parent[u.left] = u\\n                queue.append(u.left)\\n            if u.right:\\n                parent[u.right] = u\\n                queue.append(u.right)\\n        \\n        res = set()\\n        trav = p\\n        while trav in parent:\\n            res.add(trav)\\n            trav = parent[trav]\\n        res.add(root)\\n        trav = q\\n        while not trav in res:\\n            trav = parent[trav]\\n        return trav\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65404,
                "title": "accepted-24ms-dfs-c-solution-only-3-lines",
                "content": "    class Solution {\\n    public:\\n\\t    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\t\\t    if (root == p || root == q || root == NULL) return root;\\n\\t\\t    TreeNode *left = lowestCommonAncestor(root->left, p, q), *right = lowestCommonAncestor(root->right, p, q);\\n\\t\\t    return left && right ? root : left ? left : right;\\n\\t    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n\\t    TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n\\t\\t    if (root == p || root == q || root == NULL) return root;\\n\\t\\t    TreeNode *left = lowestCommonAncestor(root->left, p, q), *right = lowestCommonAncestor(root->right, p, q);\\n\\t\\t    return left && right ? root : left ? left : right;\\n\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 1326597,
                "title": "java-o-n-easy-approach-with-explanation",
                "content": "```\\nclass Solution \\n{\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n        if(root == null)//base case when we reach to the null node \\n            return null;//returning back \\n        \\n        if(root == p || root == q)//when we are founding the desired node we are returning it and deleting the current activation record \\n            return root;\\n        \\n        TreeNode left= lowestCommonAncestor(root.left,p,q);//we are traversing the left subbtree \\n        TreeNode right= lowestCommonAncestor(root.right,p,q);//and then the right subtree is trsversed \\n        \\n        if(left != null && right != null)//when we got the lowest commont node from left and rigt subtree \\n            return root;\\n        \\n        if(left == null && right == null)//when both(left,right) are null we return null as there is no chance of getting our desired node\\n            return null;\\n        \\n        return (left != null)?left: right;//when one of the node is null it returns the node without null in order to compare with the next node \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) \\n    {\\n        if(root == null)//base case when we reach to the null node \\n            return null;//returning back \\n        \\n        if(root == p || root == q)//when we are founding the desired node we are returning it and deleting the current activation record \\n            return root;\\n        \\n        TreeNode left= lowestCommonAncestor(root.left,p,q);//we are traversing the left subbtree \\n        TreeNode right= lowestCommonAncestor(root.right,p,q);//and then the right subtree is trsversed \\n        \\n        if(left != null && right != null)//when we got the lowest commont node from left and rigt subtree \\n            return root;\\n        \\n        if(left == null && right == null)//when both(left,right) are null we return null as there is no chance of getting our desired node\\n            return null;\\n        \\n        return (left != null)?left: right;//when one of the node is null it returns the node without null in order to compare with the next node \\n    }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309491,
                "title": "different-heavily-commented-javascript-solution",
                "content": "Most people have the same smart solution, but I have to admit, that one did not come naturally to me. That\\'s why I worked out this idea. It\\'s slightly less efficient and and uses some more memory, but on the other hand does not require recursion and is easy to understand.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    var pNode;\\n    var qNode;\\n    \\n    // Search for the nodes, and add a parent chain while doing that\\n    // After finding both, go up each node\\'s parent chain till we find the\\n    // the same common ancestor for both nodes.\\n    \\n    // we will keep track of level, see why later\\n    root.level = 0;\\n    let stack = [root];\\n\\n    // while we have nodes to consider and we haven\\'t found p and q nodes yet\\n    while (stack.length && !(pNode && qNode)) {\\n        \\n        let node = stack.pop();\\n        \\n        if (node) {\\n            \\n            // check if we found the p node\\n            if (node.val === p.val) {\\n                pNode = node;\\n            }\\n            \\n            // check if we found the q node\\n            if (node.val === q.val) {\\n                qNode = node;\\n            }\\n    \\n            // consider the children. Set the level and set the node as parent\\n            if (node.right) {\\n                node.right.level = node.level + 1;\\n                node.right.parent = node;\\n                stack.push(node.right);\\n            }\\n            if (node.left) {\\n                node.left.level = node.level + 1;\\n                node.left.parent = node;\\n                stack.push(node.left);\\n            }\\n        }\\n    }\\n    \\n    // Now, for both p and q nodes we know the parent chain,\\n    // we move up the chain until it\\'s the same node. That is the LCA\\n    // To make sure we move up in the right order, we use the level property added during the dfs\\n    \\n    while (pNode.val !== qNode.val) {\\n        \\n        if (pNode.level > qNode.level) {\\n            pNode = pNode.parent;\\n        } else if (pNode.level < qNode.level) {\\n            qNode = qNode.parent;\\n        } else {\\n            qNode = qNode.parent;\\n            pNode = pNode.parent;\\n        }\\n    }\\n    \\n    return pNode;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    var pNode;\\n    var qNode;\\n    \\n    // Search for the nodes, and add a parent chain while doing that\\n    // After finding both, go up each node\\'s parent chain till we find the\\n    // the same common ancestor for both nodes.\\n    \\n    // we will keep track of level, see why later\\n    root.level = 0;\\n    let stack = [root];\\n\\n    // while we have nodes to consider and we haven\\'t found p and q nodes yet\\n    while (stack.length && !(pNode && qNode)) {\\n        \\n        let node = stack.pop();\\n        \\n        if (node) {\\n            \\n            // check if we found the p node\\n            if (node.val === p.val) {\\n                pNode = node;\\n            }\\n            \\n            // check if we found the q node\\n            if (node.val === q.val) {\\n                qNode = node;\\n            }\\n    \\n            // consider the children. Set the level and set the node as parent\\n            if (node.right) {\\n                node.right.level = node.level + 1;\\n                node.right.parent = node;\\n                stack.push(node.right);\\n            }\\n            if (node.left) {\\n                node.left.level = node.level + 1;\\n                node.left.parent = node;\\n                stack.push(node.left);\\n            }\\n        }\\n    }\\n    \\n    // Now, for both p and q nodes we know the parent chain,\\n    // we move up the chain until it\\'s the same node. That is the LCA\\n    // To make sure we move up in the right order, we use the level property added during the dfs\\n    \\n    while (pNode.val !== qNode.val) {\\n        \\n        if (pNode.level > qNode.level) {\\n            pNode = pNode.parent;\\n        } else if (pNode.level < qNode.level) {\\n            qNode = qNode.parent;\\n        } else {\\n            qNode = qNode.parent;\\n            pNode = pNode.parent;\\n        }\\n    }\\n    \\n    return pNode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 875568,
                "title": "python-commented-and-explained",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \\n        LCA in a binary tree..\\n        Think of it like a single node, we need to find the p and q\\n        our search will be over when we find p in our right and q in our left\\n        or vice versa, at that point, the root is the answer!\\n        \\n        \"\"\"\\n        # I have reached a dead end, I didn\\'t find anything here\\n        if not root:\\n            return None\\n        \\n        # I see one of the targets! I will inform my caller!\\n        if root == q or root == p: return root\\n        \\n        # Look in the left, if you find p or q , return yourself\\n        foundInLeft = self.lowestCommonAncestor(root.left, p, q)\\n        \\n        # Look in the right, if you find p or q , return yourself\\n        foundInRight = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        # Didnt find anything in the left, must be in right\\n        if not foundInLeft: return foundInRight\\n        \\n        # Didnt find anything in the right, must be in the left\\n        if not foundInRight: return foundInLeft\\n        \\n        # Found something in both! Hence this is the one!\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \\n        LCA in a binary tree..\\n        Think of it like a single node, we need to find the p and q\\n        our search will be over when we find p in our right and q in our left\\n        or vice versa, at that point, the root is the answer!\\n        \\n        \"\"\"\\n        # I have reached a dead end, I didn\\'t find anything here\\n        if not root:\\n            return None\\n        \\n        # I see one of the targets! I will inform my caller!\\n        if root == q or root == p: return root\\n        \\n        # Look in the left, if you find p or q , return yourself\\n        foundInLeft = self.lowestCommonAncestor(root.left, p, q)\\n        \\n        # Look in the right, if you find p or q , return yourself\\n        foundInRight = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        # Didnt find anything in the left, must be in right\\n        if not foundInLeft: return foundInRight\\n        \\n        # Didnt find anything in the right, must be in the left\\n        if not foundInRight: return foundInLeft\\n        \\n        # Found something in both! Hence this is the one!\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306574,
                "title": "python-postorder-dfs-explained",
                "content": "The idea is to traverse our tree and keep auxilary function `dfs(node)`, which returns `0` if subtree do not have desired nodes and `1` if it has (one or two of them). For given `node`, we calculate information about:\\n1. `lft` is `dfs(node.left)`, that is answer for left subtree.\\n2. `rgh` is `dfs(node.right)`, that is answer for right subtree.\\n3. `mid` is true if current node is either `p` or `q`.\\n\\nThen what we need to find is such node, for which at least `2` out of these `3` values are true. Why? If `p` is parent of `q`, then the answer is `p` and we have `mid = 1` and one of the `lft` and `rgh` equal to `1`. If `q` is parent of `p`, it is similar. If we have `h` which is LCA of `p` and `q`, then for `h` we have `lft = rgh = 1` and `mid = 0`.\\n\\n#### Complexity\\n Complexity is `O(n)`, both time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        def dfs(node):\\n            if not node: return 0\\n\\n            lft = dfs(node.left)\\n            rgh = dfs(node.right)\\n            mid = node in [p, q]\\n            if lft + rgh + mid >= 2:\\n                self.Found = node\\n\\n            return max(lft, mid, rgh)\\n        \\n        self.Found = None\\n        dfs(root)\\n        return self.Found\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        def dfs(node):\\n            if not node: return 0\\n\\n            lft = dfs(node.left)\\n            rgh = dfs(node.right)\\n            mid = node in [p, q]\\n            if lft + rgh + mid >= 2:\\n                self.Found = node\\n\\n            return max(lft, mid, rgh)\\n        \\n        self.Found = None\\n        dfs(root)\\n        return self.Found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65341,
                "title": "share-my-5-line-java-code-with-brief-explanation",
                "content": "    /*\\n        -- \\u4ece\\u4e0a\\u5411\\u4e0b\\u641c\\u7d22, \\u9047\\u5230p\\u6216q\\u6216null, return\\u4e4b\\n        -- \\u56de\\u6eaf\\u8fc7\\u7a0b\\u4e2d, (1).\\u5de6return != null\\u4e14\\u53f3return != null (\\u5373\\u5de6p\\u53f3q\\u6216\\u5de6q\\u53f3p), \\u8bf4\\u660ecurrent root\\u662fLCA, return\\u4e4b;\\n                      (2).\\u5de6\\u53f3\\u8c01\\u4e0d\\u4e3anull\\u5c31\\u5411\\u4e0areturn\\u8c01 (\\u5373p\\u6216q, \\u6216null).\\n    */ \\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root==null || root==p || root==q) { return root; }\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if (left!=null && right!=null) { return root; }\\n            return left!=null ? left : right;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root==null || root==p || root==q) { return root; }",
                "codeTag": "Java"
            },
            {
                "id": 3628698,
                "title": "lowest-common-ancestor-of-a-binary-tree-i-ii-iii-iv-solution",
                "content": "\\n\\n# [236. Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)\\n```\\nclass Solution {\\npublic:\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    // Both p and q exist in the tree\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        return LCA(root, p, q);\\n    }\\n};\\n```\\n\\n# [1644. Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/description/)\\n```\\nclass Solution {\\npublic:\\n    bool find(TreeNode* root, TreeNode* x){\\n        if(root == NULL)\\n            return false;\\n        if(root == x)\\n            return true;\\n\\n        bool left = find(root->left, x);\\n        bool right = find(root->right, x);\\n\\n        if(left == true or right == true)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n        bool first = find(root, p); // finding if p exist in binary tree or not\\n        bool second = find(root, q); // finding if q exist in binary tree or not\\n\\n        if(first == false or second == false) // if one of p or q not exist in binary tree\\n            return NULL;\\n\\n        return LCA(root, p, q);    \\n    }\\n};\\n```\\n# [1650. Lowest Common Ancestor of a Binary Tree III](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/)\\n```\\nclass Solution {\\npublic:\\n    Node* lowestCommonAncestor(Node* p, Node * q) {\\n        \\n        Node* a = p;\\n        int a_depth = 0;\\n        Node* b = q;\\n        int b_depth = 0;\\n\\n        // find distance of a from the root\\n        while(a->parent){\\n            a = a->parent;\\n            a_depth++;\\n        }\\n\\n        // find distance of b from the root\\n        while(b->parent){\\n            b = b->parent;\\n            b_depth++;\\n        }\\n\\n        // if a_depth > b_depth\\n        while(a_depth > b_depth){\\n            p = p->parent;\\n            a_depth--;\\n        }\\n\\n        // if b_depth > a_depth\\n        while(b_depth > a_depth){\\n            q = q->parent;\\n            b_depth--;\\n        }\\n\\n        // now p and q are at same depth\\n        // while loop executes, only if different elements at same depth\\n        while(p != q){\\n            p = p->parent;\\n            q = q->parent;\\n        }\\n        return p;\\n    }\\n};\\n```\\n# [1676. Lowest Common Ancestor of a Binary Tree IV](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/description/)\\n```\\nclass Solution {\\npublic:\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    // All nodes exist in the tree\\n    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {\\n        int n = nodes.size();\\n        if(nodes.size() == 1)\\n            return nodes[0];\\n        \\n        TreeNode* prev = nodes[0];\\n\\n        // finding LCA of two nodes at a time\\n        for(int i=1; i<n; i++){\\n            prev = LCA(root, prev, nodes[i]);\\n        }\\n        return prev;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    // Both p and q exist in the tree\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        return LCA(root, p, q);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool find(TreeNode* root, TreeNode* x){\\n        if(root == NULL)\\n            return false;\\n        if(root == x)\\n            return true;\\n\\n        bool left = find(root->left, x);\\n        bool right = find(root->right, x);\\n\\n        if(left == true or right == true)\\n            return true;\\n        else\\n            return false;\\n    }\\n\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n        bool first = find(root, p); // finding if p exist in binary tree or not\\n        bool second = find(root, q); // finding if q exist in binary tree or not\\n\\n        if(first == false or second == false) // if one of p or q not exist in binary tree\\n            return NULL;\\n\\n        return LCA(root, p, q);    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* lowestCommonAncestor(Node* p, Node * q) {\\n        \\n        Node* a = p;\\n        int a_depth = 0;\\n        Node* b = q;\\n        int b_depth = 0;\\n\\n        // find distance of a from the root\\n        while(a->parent){\\n            a = a->parent;\\n            a_depth++;\\n        }\\n\\n        // find distance of b from the root\\n        while(b->parent){\\n            b = b->parent;\\n            b_depth++;\\n        }\\n\\n        // if a_depth > b_depth\\n        while(a_depth > b_depth){\\n            p = p->parent;\\n            a_depth--;\\n        }\\n\\n        // if b_depth > a_depth\\n        while(b_depth > a_depth){\\n            q = q->parent;\\n            b_depth--;\\n        }\\n\\n        // now p and q are at same depth\\n        // while loop executes, only if different elements at same depth\\n        while(p != q){\\n            p = p->parent;\\n            q = q->parent;\\n        }\\n        return p;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* LCA(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n\\n        TreeNode* left = LCA(root->left, p, q);\\n        TreeNode* right = LCA(root->right, p, q);\\n\\n        if(left == NULL)\\n            return right;\\n        if(right == NULL)\\n            return left;\\n        else // both left and right are non NULL\\n            return root;\\n    }\\n\\n    // All nodes exist in the tree\\n    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {\\n        int n = nodes.size();\\n        if(nodes.size() == 1)\\n            return nodes[0];\\n        \\n        TreeNode* prev = nodes[0];\\n\\n        // finding LCA of two nodes at a time\\n        for(int i=1; i<n; i++){\\n            prev = LCA(root, prev, nodes[i]);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401044,
                "title": "python-solution-recursion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n            if not root:\\n                return None\\n            if root.val==p.val or root.val==q.val:\\n                return root\\n            left= self.lowestCommonAncestor(root.left,p,q)\\n            right= self.lowestCommonAncestor(root.right,p,q)\\n            if not left:\\n                return right\\n            if not right:\\n                return left\\n            return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n            if not root:\\n                return None\\n            if root.val==p.val or root.val==q.val:\\n                return root\\n            left= self.lowestCommonAncestor(root.left,p,q)\\n            right= self.lowestCommonAncestor(root.right,p,q)\\n            if not left:\\n                return right\\n            if not right:\\n                return left\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 285513,
                "title": "simple-c-solution-o-n-time-complexity-speed-95",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if( root == nullptr or root == p or root == q )\\n        {\\n            return root;\\n        }\\n        TreeNode* left = lowestCommonAncestor( root->left, p, q );\\n        TreeNode* right = lowestCommonAncestor( root->right, p, q );\\n        \\n        if( left == nullptr )\\n        {\\n            return right;\\n        }\\n        \\n        if( right == nullptr )\\n        {\\n            return left;\\n        }\\n        \\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if( root == nullptr or root == p or root == q )\\n        {\\n            return root;\\n        }\\n        TreeNode* left = lowestCommonAncestor( root->left, p, q );\\n        TreeNode* right = lowestCommonAncestor( root->right, p, q );\\n        \\n        if( left == nullptr )\\n        {\\n            return right;\\n        }\\n        \\n        if( right == nullptr )\\n        {\\n            return left;\\n        }\\n        \\n        return root;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65345,
                "title": "concise-4-line-c",
                "content": "This problem only has three possible return values, root, p or q. The answer depends on whether p and q on the same subtree or not.\\n\\nFor those who find it hard to understand this solution, here is a little enlightenment: \\nThe last line of code only be executed one time in the end, we search left sub tree recursively try to find p or q whichever comes the first, if not we'll reach null and return null, same thing for the right subtree. and we compare the result in the last line of code.\\n\\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if (!root || root == p || root == q) return root;\\n            TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n            TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n            return l && r ? root : l ? l : r;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if (!root || root == p || root == q) return root;\\n            TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n            TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n            return l && r ? root : l ? l : r;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2334098,
                "title": "python-lightweight-dfs-solution",
                "content": "If you ffed a node, then just return the ffed node. Otherwise, you ff the left and ff the right. It\\'s either (ffed both), or (ffed left or ffed right).\\n```python\\n        def ff(n):\\n            if n in (None, p, q): return n\\n            l, r = ff(n.left), ff(n.right)\\n            if l and r: return n\\n            else: return l or r\\n        return ff(root)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        def ff(n):\\n            if n in (None, p, q): return n\\n            l, r = ff(n.left), ff(n.right)\\n            if l and r: return n\\n            else: return l or r\\n        return ff(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 859735,
                "title": "javascript-fast-and-simple",
                "content": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n  const dfs = (node) => {\\n    if (node === null) {\\n      return null;\\n    }\\n  \\n    if (node === p || node === q) {\\n      return node \\n      \\n    }\\n    \\n    const left = dfs(node.left);\\n    const right = dfs(node.right);\\n    \\n    return left && right ? node : left || right;\\n  }\\n  \\n  return dfs(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n  const dfs = (node) => {\\n    if (node === null) {\\n      return null;\\n    }\\n  \\n    if (node === p || node === q) {\\n      return node \\n      \\n    }\\n    \\n    const left = dfs(node.left);\\n    const right = dfs(node.right);\\n    \\n    return left && right ? node : left || right;\\n  }\\n  \\n  return dfs(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 296984,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return null;\\n        if (root == p || root == q) return root;\\n\\n        var left = LowestCommonAncestor(root.left, p, q);\\n        var right = LowestCommonAncestor(root.right, p, q);\\n        \\n        if (left != null && right != null) return root;\\n\\n        if (left != null) return left;\\n        if (right != null) return right;\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return null;\\n        if (root == p || root == q) return root;\\n\\n        var left = LowestCommonAncestor(root.left, p, q);\\n        var right = LowestCommonAncestor(root.right, p, q);\\n        \\n        if (left != null && right != null) return root;\\n\\n        if (left != null) return left;\\n        if (right != null) return right;\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65401,
                "title": "share-c-c-24ms-recursive-solution",
                "content": "C++ version\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root)\\n                return NULL;\\n            if(root == p || root == q)\\n                return root;\\n            // Check if left contains p or q\\n            TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n            // Check if right contains p or q\\n            TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n            // if left and right containsp or q the it'sthe LCA\\n            if(left && right)\\n                return root;\\n            return left ? left : right;        \\n        }\\n\\nC#version\\n\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null)\\n            return null;\\n        if(root == p || root == q)\\n            return root;\\n        var left = LowestCommonAncestor(root.left, p, q);\\n        var right = LowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null)\\n            return root;\\n        return left ?? right;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "C++ version\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root)\\n                return NULL;\\n            if(root == p || root == q)\\n                return root;\\n            // Check if left contains p or q\\n            TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n            // Check if right contains p or q\\n            TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n            // if left and right containsp or q the it'sthe LCA\\n            if(left && right)\\n                return root;\\n            return left ? left : right;        \\n        }\\n\\nC#version\\n\\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null)\\n            return null;\\n        if(root == p || root == q)\\n            return root;\\n        var left = LowestCommonAncestor(root.left, p, q);\\n        var right = LowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null)\\n            return root;\\n        return left ?? right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1636280,
                "title": "java-a-summary-on-binary-lifting-to-find-lca",
                "content": "This specific problem can be solved in `O(n)` time (where `n` is the number of TreeNodes) using parent pointers. However a potential follow-up in an interview setting can be optimizing for `m` queries. A technique called Binary Lifting can be used for this - it requires us to build a DP array in `n*log(n)` time however once that is done, each LCA query can be done in `log(n)` time.\\n\\n-----------\\n\\n**Pre-requisites**\\n\\nTo use this technique we need the following information:\\n\\n1. A unique identifier for each node (this will help with DP array computation)\\n2. The direct parent of each node\\n3. The depth/level/height of each node\\n\\nFirst, let\\'s assign a unique id for each node. I will declare two HashMaps `Map<Integer, TreeNode> map`  maps a unique id to a TreeNode and `Map<TreeNode, Integer> map2` is its inverse. We can then do a simple dfs based tree traversal and fill in labels.\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n\\tint id = 0;\\n\\t\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        // TODO\\n    }\\n\\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) {\\n        map2.put(root, id);\\n        map.put(id, root);\\n        id++;\\n        \\n        if(root.left != null) {\\n            fillLabels(root.left);\\n        }\\n        if(root.right != null) {\\n            fillLabels(root.right);\\n        }\\n    }\\n}\\n```\\n\\nOnce this is done, we can fill in the following by doing another dfs based traversal: \\n1. The direct parent of each node - this will be stored in an array `parent[i]` that gives the direct parent of node i.\\n2. The level/height/depth of a node\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n    \\n    Map<Integer, Integer> levels = new HashMap<>();\\n    int id = 0;\\n    int[] parent;\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        \\n        parent = new int[map.size()];\\n        parent[0] = -1;\\n        levels.put(0, 0);\\n        fillLevelsAndParent(root);\\n\\t\\t// TODO\\n    }\\n\\t\\n    // Record level information and fill parent array\\n    private void fillLevelsAndParent(TreeNode root) {\\n        int rootVal = map2.get(root);\\n        int nextLevel = levels.get(rootVal) + 1;\\n        \\n        if(root.left != null) {\\n            int leftVal = map2.get(root.left);\\n            parent[leftVal] = rootVal;\\n            levels.put(leftVal, nextLevel);\\n            fillLevelsAndParent(root.left);\\n        }\\n        \\n        if(root.right != null) {\\n            int rightVal = map2.get(root.right);\\n            parent[rightVal] = rootVal;\\n            levels.put(rightVal, nextLevel);\\n            fillLevelsAndParent(root.right);\\n        }\\n    }\\n    \\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) { ... }\\n```\\n\\n-----\\n\\n**Kth ancestor of a TreeNode**\\n\\nOur next objective is to find the Kth ancestor of a TreeNode - this is a separate problem on Leetcode (LC-1483) linked [here](https://leetcode.com/problems/kth-ancestor-of-a-tree-node/). \\n\\nSimilar to the LCA problem, you can solve this in `O(n)` if there is just one query however if there are `m` queries, you need to do this in a better way. The idea is using a DP table to pre-compute ancestors of a node. There are a couple of different ways to approach this problem.\\n\\n**Method 1:** If the number of nodes are small you can define a function `f(i, j)` that returns the `ith` ancestor of a node with id `j`. The recurrence relation is as follows:\\n\\n```\\nf(i, j) = -1 // if parent[j] = -1\\nf(i, j) = parent[j] // if i == 1\\nf(i, j) = f(i-1, parent[j]) // otherwise\\n```\\n\\nUsing this recurrence we can construct a DP array in `O(n^2)` time and space. Once constructed, queries are extremely fast and can be done in constant time. However if the number of nodes are large and `n^2` is too much, this will not work - hence we use method 2.\\n\\n**Method 2:**  Here we re-define our function as follows: Define `f(i, j)` as a function that returns the `2^jth` parent of node `i`. The recurrence relation is as follows:\\n\\n```\\nf(j, i) = parent[i] // if j = 0\\nf(j, i) = f(j-1, f(j-1, i)) // otherwise (assuming f(j-1, i) is not -1)\\n```\\n\\nNow since there exist only `n` nodes, we can make at most `n` jumps. Since we are storing ancestors in powers of 2, we can make at most `log(n)` jumps in the worst case.\\n \\nThe dp array can be initialized as follows:\\n\\n```\\n    private void initializeCache() {\\n        int n = parent.length;\\n        int logN =  (int) (Math.log(n)/Math.log(2))+1;\\n        dp =  new int[logN][n];\\n        \\n        for(int i = 0; i<logN; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = parent[j];\\n                else if(dp[i-1][j] == -1)\\n                    dp[i][j] = -1;\\n                else\\n                    dp[i][j] = dp[i-1][dp[i-1][j]];\\n            }\\n        }\\n    }\\n```\\n\\nThe idea here is to use the binary value of `k` to make jumps and get the `kth` ancestor. Let\\'s say you want to get the 13th ancestor of a node `x`. Any number can be represented in binary form so 13 is: `1101`. This is the equivalent of the following: \\n\\n13 = `1* 2^3 + 1* 2^2 + 0* 2^1 + 1* 2^0`\\n\\nSo to find the 13th ancestor of k, we can do the following: \\n- get the `2^0th` ancestor of `k` stored in `dp[0][k]` let\\'s call this `k1`\\n- get the `2^2th` ancestor of `k1` stored in `dp[2][k1]` let\\'s call this `k2`\\n-  get the `3^3th` ancestor of `k2` stored in `dp[3][k2]` let\\'s call this `k3`\\n\\nAnd we are done.\\n\\n```\\n    private int kthAncestor(int node, int k) {\\n        String binaryString = Integer.toBinaryString(k);\\n        int currentNode = node;\\n        int powerOfTwo = 0;\\n        \\n        for(int i = binaryString.length()-1; i>=0; i--) {\\n            if(binaryString.charAt(i) == \\'1\\')\\n                currentNode = dp[powerOfTwo][currentNode];\\n            if(currentNode == -1)\\n                return -1;\\n            powerOfTwo++;\\n        }\\n        return currentNode;\\n    }\\n```\\n\\n---------\\n\\n**Getting the LCA of two Nodes**\\n\\nFinally we have everything we need to get the LCA.\\n\\n**Step 1:** Ensure both nodes are on the same level. We can do this in `log(n)` time - get the height/depth of the two nodes. Find the levelDifference between the 2. Then use the `kthAncestor(node, levelDifference)` to move the lower node to the same level.\\n\\n```\\n    private void normalizeLevels(int p, int q) {\\n        if(levels.get(p) == levels.get(q)) {\\n            node1 = p;\\n            node2 = q;\\n            return;\\n        }\\n        if(levels.get(p) < levels.get(q)) {\\n            normalizeLevels(q, p);\\n            return;\\n        }\\n        \\n        int levelDifference = levels.get(p) - levels.get(q);\\n        p = kthAncestor(p, levelDifference);\\n        node1 = p;\\n        node2 = q;\\n    }\\n```\\n\\nThe end result of this function is that two nodes with ids `node1` and `node2` are on the same level of the tree. This has been done in `log(n)` time.\\n\\n**Step 2:** Find the LCA of `node1` and `node2`. The challenge is doing this in log(n) complexity. To do this we need to think about what happens when we make a jump.\\n\\nLet\\'s say I make an arbitrary size jump and update the values the values of `node1` and `node2` accordingly. Assuming the LCA is `nodeX`, if I made a jump directly to `nodeX` or a jump greater than that to something above `nodeX`, then `node1 == node2`. However if I made a smaller jump then `node1 != node2`.\\n\\nThe idea is to make the largest jumps possible such that `node1 != node2` in a loop until we cannot make any more jumps.\\n\\n- The largest jump posible is a jump of size `n` which is `2^(log(n))`\\n\\t-  If we overshoot (which we will), dont make the jump.\\n\\t-  Otherwise make the jump\\n- Next make a jump of size `2^(log(n)-1)`\\n\\t- If we overshoot, do not make the jump. Else make the jump.\\n- Keep doing this until `2^0`\\n\\nIn the end the direct parent of any of the nodes is the LCA.\\n\\n```\\n    private void getLca() {\\n        if(node1 == node2)\\n            return;\\n        int n = map.size();\\n        int start = (int) (Math.log(n)/Math.log(2));\\n        \\n        for(int i = start; i>=0; i--) {\\n            int pNode1 = kthAncestor(node1, i);\\n            int pNode2 = kthAncestor(node2, i);\\n            \\n            if(pNode1 == pNode2) {\\n                continue;           // do not do the jump\\n            } else {                // do the jump\\n                node1 = pNode1;\\n                node2 = pNode2;\\n            }\\n        }\\n    }\\n```\\n\\nAnd we are done!\\n\\n------------\\n\\n**Full code**\\n\\nPutting it all together we have the following solution:\\n\\n- Time Complexity: n* log(n) to build the DP array and log(n) for each query\\n- Spacr Complxity: n* log(n) for the DP array\\n\\nCode:\\n\\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n    \\n    Map<Integer, Integer> levels = new HashMap<>();\\n    int id = 0;\\n    int[] parent;\\n    int[][] dp;\\n    \\n    int node1;\\n    int node2;\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        \\n        parent = new int[map.size()];\\n        parent[0] = -1;\\n        levels.put(0, 0);\\n        fillLevelsAndParent(root);\\n        \\n        initializeCache();        \\n        normalizeLevels(map2.get(p), map2.get(q));\\n        getLca();\\n        \\n        if(node1 == node2)\\n            return map.get(node1);\\n        else\\n            return map.get(parent[node1]);\\n    }\\n    \\n    private void getLca() {\\n        if(node1 == node2)\\n            return;\\n        int n = map.size();\\n        int start = (int) (Math.log(n)/Math.log(2));\\n        \\n        for(int i = start; i>=0; i--) {\\n            int pNode1 = kthAncestor(node1, i);\\n            int pNode2 = kthAncestor(node2, i);\\n            \\n            if(pNode1 == pNode2) {\\n                continue;           // do not do the jump\\n            } else {                // do the jump\\n                node1 = pNode1;\\n                node2 = pNode2;\\n            }\\n        }\\n    }\\n    \\n    private void normalizeLevels(int p, int q) {\\n        if(levels.get(p) == levels.get(q)) {\\n            node1 = p;\\n            node2 = q;\\n            return;\\n        }\\n        if(levels.get(p) < levels.get(q)) {\\n            normalizeLevels(q, p);\\n            return;\\n        }\\n        \\n        int levelDifference = levels.get(p) - levels.get(q);\\n        p = kthAncestor(p, levelDifference);\\n        node1 = p;\\n        node2 = q;\\n    }\\n    \\n    private int kthAncestor(int node, int k) {\\n        String binaryString = Integer.toBinaryString(k);\\n        int currentNode = node;\\n        int powerOfTwo = 0;\\n        \\n        for(int i = binaryString.length()-1; i>=0; i--) {\\n            if(binaryString.charAt(i) == \\'1\\')\\n                currentNode = dp[powerOfTwo][currentNode];\\n            if(currentNode == -1)\\n                return -1;\\n            powerOfTwo++;\\n        }\\n        return currentNode;\\n    }\\n    \\n    /*\\n        Let f(i, j) return 2^ith ancestor of node j\\n            f(i, j) = parent[j]         // if i = 0\\n            f(i, j) = f(i-1, f(i-1, j)) // otherwise (assuming f(i-1, j) != -1)\\n    */\\n    private void initializeCache() {\\n        int n = parent.length;\\n        int logN =  (int) (Math.log(n)/Math.log(2))+1;\\n        dp =  new int[logN][n];\\n        \\n        for(int i = 0; i<logN; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = parent[j];\\n                else if(dp[i-1][j] == -1)\\n                    dp[i][j] = -1;\\n                else\\n                    dp[i][j] = dp[i-1][dp[i-1][j]];\\n            }\\n        }\\n    }\\n    \\n    // Record level information and fill parent array\\n    private void fillLevelsAndParent(TreeNode root) {\\n        int rootVal = map2.get(root);\\n        int nextLevel = levels.get(rootVal) + 1;\\n        \\n        if(root.left != null) {\\n            int leftVal = map2.get(root.left);\\n            parent[leftVal] = rootVal;\\n            levels.put(leftVal, nextLevel);\\n            fillLevelsAndParent(root.left);\\n        }\\n        \\n        if(root.right != null) {\\n            int rightVal = map2.get(root.right);\\n            parent[rightVal] = rootVal;\\n            levels.put(rightVal, nextLevel);\\n            fillLevelsAndParent(root.right);\\n        }\\n    }\\n    \\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) {\\n        map2.put(root, id);\\n        map.put(id, root);\\n        id++;\\n        \\n        if(root.left != null) {\\n            fillLabels(root.left);\\n        }\\n        if(root.right != null) {\\n            fillLabels(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n\\tint id = 0;\\n\\t\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        // TODO\\n    }\\n\\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) {\\n        map2.put(root, id);\\n        map.put(id, root);\\n        id++;\\n        \\n        if(root.left != null) {\\n            fillLabels(root.left);\\n        }\\n        if(root.right != null) {\\n            fillLabels(root.right);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n    \\n    Map<Integer, Integer> levels = new HashMap<>();\\n    int id = 0;\\n    int[] parent;\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        \\n        parent = new int[map.size()];\\n        parent[0] = -1;\\n        levels.put(0, 0);\\n        fillLevelsAndParent(root);\\n\\t\\t// TODO\\n    }\\n\\t\\n    // Record level information and fill parent array\\n    private void fillLevelsAndParent(TreeNode root) {\\n        int rootVal = map2.get(root);\\n        int nextLevel = levels.get(rootVal) + 1;\\n        \\n        if(root.left != null) {\\n            int leftVal = map2.get(root.left);\\n            parent[leftVal] = rootVal;\\n            levels.put(leftVal, nextLevel);\\n            fillLevelsAndParent(root.left);\\n        }\\n        \\n        if(root.right != null) {\\n            int rightVal = map2.get(root.right);\\n            parent[rightVal] = rootVal;\\n            levels.put(rightVal, nextLevel);\\n            fillLevelsAndParent(root.right);\\n        }\\n    }\\n    \\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) { ... }\\n```\n```\\nf(i, j) = -1 // if parent[j] = -1\\nf(i, j) = parent[j] // if i == 1\\nf(i, j) = f(i-1, parent[j]) // otherwise\\n```\n```\\nf(j, i) = parent[i] // if j = 0\\nf(j, i) = f(j-1, f(j-1, i)) // otherwise (assuming f(j-1, i) is not -1)\\n```\n```\\n    private void initializeCache() {\\n        int n = parent.length;\\n        int logN =  (int) (Math.log(n)/Math.log(2))+1;\\n        dp =  new int[logN][n];\\n        \\n        for(int i = 0; i<logN; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = parent[j];\\n                else if(dp[i-1][j] == -1)\\n                    dp[i][j] = -1;\\n                else\\n                    dp[i][j] = dp[i-1][dp[i-1][j]];\\n            }\\n        }\\n    }\\n```\n```\\n    private int kthAncestor(int node, int k) {\\n        String binaryString = Integer.toBinaryString(k);\\n        int currentNode = node;\\n        int powerOfTwo = 0;\\n        \\n        for(int i = binaryString.length()-1; i>=0; i--) {\\n            if(binaryString.charAt(i) == \\'1\\')\\n                currentNode = dp[powerOfTwo][currentNode];\\n            if(currentNode == -1)\\n                return -1;\\n            powerOfTwo++;\\n        }\\n        return currentNode;\\n    }\\n```\n```\\n    private void normalizeLevels(int p, int q) {\\n        if(levels.get(p) == levels.get(q)) {\\n            node1 = p;\\n            node2 = q;\\n            return;\\n        }\\n        if(levels.get(p) < levels.get(q)) {\\n            normalizeLevels(q, p);\\n            return;\\n        }\\n        \\n        int levelDifference = levels.get(p) - levels.get(q);\\n        p = kthAncestor(p, levelDifference);\\n        node1 = p;\\n        node2 = q;\\n    }\\n```\n```\\n    private void getLca() {\\n        if(node1 == node2)\\n            return;\\n        int n = map.size();\\n        int start = (int) (Math.log(n)/Math.log(2));\\n        \\n        for(int i = start; i>=0; i--) {\\n            int pNode1 = kthAncestor(node1, i);\\n            int pNode2 = kthAncestor(node2, i);\\n            \\n            if(pNode1 == pNode2) {\\n                continue;           // do not do the jump\\n            } else {                // do the jump\\n                node1 = pNode1;\\n                node2 = pNode2;\\n            }\\n        }\\n    }\\n```\n```\\nclass Solution {\\n    Map<Integer, TreeNode> map = new HashMap<>();\\n    Map<TreeNode, Integer> map2 = new HashMap<>();\\n    \\n    Map<Integer, Integer> levels = new HashMap<>();\\n    int id = 0;\\n    int[] parent;\\n    int[][] dp;\\n    \\n    int node1;\\n    int node2;\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        fillLabels(root);\\n        \\n        parent = new int[map.size()];\\n        parent[0] = -1;\\n        levels.put(0, 0);\\n        fillLevelsAndParent(root);\\n        \\n        initializeCache();        \\n        normalizeLevels(map2.get(p), map2.get(q));\\n        getLca();\\n        \\n        if(node1 == node2)\\n            return map.get(node1);\\n        else\\n            return map.get(parent[node1]);\\n    }\\n    \\n    private void getLca() {\\n        if(node1 == node2)\\n            return;\\n        int n = map.size();\\n        int start = (int) (Math.log(n)/Math.log(2));\\n        \\n        for(int i = start; i>=0; i--) {\\n            int pNode1 = kthAncestor(node1, i);\\n            int pNode2 = kthAncestor(node2, i);\\n            \\n            if(pNode1 == pNode2) {\\n                continue;           // do not do the jump\\n            } else {                // do the jump\\n                node1 = pNode1;\\n                node2 = pNode2;\\n            }\\n        }\\n    }\\n    \\n    private void normalizeLevels(int p, int q) {\\n        if(levels.get(p) == levels.get(q)) {\\n            node1 = p;\\n            node2 = q;\\n            return;\\n        }\\n        if(levels.get(p) < levels.get(q)) {\\n            normalizeLevels(q, p);\\n            return;\\n        }\\n        \\n        int levelDifference = levels.get(p) - levels.get(q);\\n        p = kthAncestor(p, levelDifference);\\n        node1 = p;\\n        node2 = q;\\n    }\\n    \\n    private int kthAncestor(int node, int k) {\\n        String binaryString = Integer.toBinaryString(k);\\n        int currentNode = node;\\n        int powerOfTwo = 0;\\n        \\n        for(int i = binaryString.length()-1; i>=0; i--) {\\n            if(binaryString.charAt(i) == \\'1\\')\\n                currentNode = dp[powerOfTwo][currentNode];\\n            if(currentNode == -1)\\n                return -1;\\n            powerOfTwo++;\\n        }\\n        return currentNode;\\n    }\\n    \\n    /*\\n        Let f(i, j) return 2^ith ancestor of node j\\n            f(i, j) = parent[j]         // if i = 0\\n            f(i, j) = f(i-1, f(i-1, j)) // otherwise (assuming f(i-1, j) != -1)\\n    */\\n    private void initializeCache() {\\n        int n = parent.length;\\n        int logN =  (int) (Math.log(n)/Math.log(2))+1;\\n        dp =  new int[logN][n];\\n        \\n        for(int i = 0; i<logN; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == 0)\\n                    dp[i][j] = parent[j];\\n                else if(dp[i-1][j] == -1)\\n                    dp[i][j] = -1;\\n                else\\n                    dp[i][j] = dp[i-1][dp[i-1][j]];\\n            }\\n        }\\n    }\\n    \\n    // Record level information and fill parent array\\n    private void fillLevelsAndParent(TreeNode root) {\\n        int rootVal = map2.get(root);\\n        int nextLevel = levels.get(rootVal) + 1;\\n        \\n        if(root.left != null) {\\n            int leftVal = map2.get(root.left);\\n            parent[leftVal] = rootVal;\\n            levels.put(leftVal, nextLevel);\\n            fillLevelsAndParent(root.left);\\n        }\\n        \\n        if(root.right != null) {\\n            int rightVal = map2.get(root.right);\\n            parent[rightVal] = rootVal;\\n            levels.put(rightVal, nextLevel);\\n            fillLevelsAndParent(root.right);\\n        }\\n    }\\n    \\n    // Labels each node from 0...n\\n    private void fillLabels(TreeNode root) {\\n        map2.put(root, id);\\n        map.put(id, root);\\n        id++;\\n        \\n        if(root.left != null) {\\n            fillLabels(root.left);\\n        }\\n        if(root.right != null) {\\n            fillLabels(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65304,
                "title": "java-iterative-solution-with-1-stack",
                "content": "The idea is when finding p or q the first time current stack must contain LCA. So when stack size is decreased the pop node could be the LCA if another node (p or q) is found under it.\\n```\\npublic class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null|| root == p || root == q) return root;\\n\\n        TreeNode n = root;\\n        TreeNode res = null;\\n        int size = -1;\\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        while (n!=null || !s.empty()) {\\n            while (n!=null) {\\n                s.push(n);\\n                if (n == p || n == q) {\\n                    if (res == null) { //find p or q the first time\\n                        res = n;\\n                        size = s.size();\\n                    } else return res; //find both p and q\\n                }\\n                n = n.left;\\n            }\\n            n = s.pop();\\n            if (s.size() < size) {\\n                size = s.size();\\n                res = n;\\n            }\\n            n = n.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null|| root == p || root == q) return root;\\n\\n        TreeNode n = root;\\n        TreeNode res = null;\\n        int size = -1;\\n        Stack<TreeNode> s = new Stack<TreeNode>();\\n        while (n!=null || !s.empty()) {\\n            while (n!=null) {\\n                s.push(n);\\n                if (n == p || n == q) {\\n                    if (res == null) { //find p or q the first time\\n                        res = n;\\n                        size = s.size();\\n                    } else return res; //find both p and q\\n                }\\n                n = n.left;\\n            }\\n            n = s.pop();\\n            if (s.size() < size) {\\n                size = s.size();\\n                res = n;\\n            }\\n            n = n.right;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65319,
                "title": "my-4-lines-java-solution",
                "content": "Just blind try left and right. Then if we find in both left and right side return root, otherwise return the one we got.\\n\\n        if (root == p || root == q || root == null) { return root; }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return (left != null && right != null) ? root : (left != null ? left : right);",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Just blind try left and right. Then if we find in both left and right side return root, otherwise return the one we got.\\n\\n        if (root == p || root == q || root == null) { return root; }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return (left != null && right != null) ? root : (left != null ? left : right);",
                "codeTag": "Unknown"
            },
            {
                "id": 1222599,
                "title": "c-intuition-for-building-the-optimal-solution-step-by-step",
                "content": "## Basic Idea\\nAs described in the problem, the Lowest Common Ancestor of a two nodes in a tree is the last common node on the path from the root to p and q. Basically, there can be three cases for a particular node of the tree, depending on the position of p and q relative to it:\\n1. If p and q are in different subtrees of the node. (For eg p is in left subtree and q is in right subtree, and vice versa).\\n2. If either of p and q is equal to the node.\\n3. If p and q are in the same subtree of the current node. (For eg both p and q are in left subtree, or right subtree).\\n\\nWe will return the current node as the LCA for cases 1 and 2, and recursively call the LCA function on the corresponding subtree for case 3.\\n\\nSo for implementing the solution, we need two functions, one main function for finding the LCA, and one auxiliary function for finding the positions of p and q in the subtrees.\\n<br>\\n## Approach 1: Full Recursion (Accepted but very slow)\\nThe most naive approach would be to go full recursion on this, from the find function to the LCA function.\\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tif(root != toFind) {\\n\\t\\treturn find(root->left, toFind) || find(root->right, toFind);\\n\\t}\\n\\telse {\\n\\t\\treturn root;\\n\\t}\\n}\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(!root) return nullptr;\\n\\t// four cases\\n\\tif(find(root->left, p)) {\\n\\t\\tif(find(root->right, q)) {\\n\\t\\t\\t//root is LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\telse if(find(root->left, q)){\\n\\t\\t\\t//both are in one subtree\\n\\t\\t\\treturn lowestCommonAncestor(root->left, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//root is q;\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse if(find(root->right, p)){\\n\\t\\tif(find(root->left, q)) {\\n\\t\\t\\t//root is LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\telse if(find(root->right, q)){\\n\\t\\t\\t//both are in same subtree\\n\\t\\t\\treturn lowestCommonAncestor(root->right, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is root\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse {\\n\\t\\t//p is root;\\n\\t\\t//no matter where q is, p is LCA\\n\\t\\treturn p;\\n\\t}\\n}\\n```\\n![Runtime and Memory usage: Approach 1](https://assets.leetcode.com/users/images/63373146-7220-447c-bb62-50f528dfc4a2_1621654422.2065408.png)\\n\\n**Complexity**\\n\\nTime: O(n) (proved at the end)\\nSpace: O(n)\\nAs you can see, this solution barely passed, so it will certainly not cut it.\\n<br>\\n\\n## Approach 2: Optimize Most Called Recursive Function\\n\\nThe next step would be to optimise our most called recursive function (i.e find()).\\nAs the recursion of find() is not tail recursion (i.e only one recursive call per function call), we can\\'t eliminate the stack completely, hence we still have to use a stack to keep track of the roots of the subtrees being processed. However, we save a little on space by using this approach (although not asymptotically) by eliminating the program stack from the picture.\\n\\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tstack<TreeNode *> nodes;\\n\\tnodes.push(root);\\n\\twhile(!nodes.empty()) {\\n\\t\\tTreeNode *curr = nodes.top();\\n\\t\\tnodes.pop();\\n\\t\\tif(curr == toFind) return true;\\n\\t\\tif(curr->left) nodes.push(curr->left);\\n\\t\\tif(curr->right) nodes.push(curr->right);\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ba239023-ff4b-4c99-95b9-98967c04f95c_1621655084.0239727.png)\\n\\n**Complexity**\\nSame as previous solution\\n<br>\\n\\n## Approach 3: Some Observations and Complete Iteration\\nWe can clearly see that the recursion in our main LCA function is tail recursion, since there is only one recursive call from the function per run. Hence it can be easily converted to iteration, without even using a stack, we just modify the root variable directly for each subcall.\\nAlso, some optimizations we can make are:\\n1. Check if p or q is the root first, then we don\\'t even need to call the find() function, and the answer is root, no matter what.\\n2. Make subcases based on whether the left and right subtree of the current node exist, to avoid making calls to find() with an empty subtree.\\n\\nThis way, we can minimize the number of calls to our costly function (O(n)) and thus save on runtime a little (again, not asymptotically).\\nHence the worst case for this algorithm would be very difficult to reach, and the average case performance would be good.\\n\\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tstack<TreeNode *> nodes;\\n\\tnodes.push(root);\\n\\twhile(!nodes.empty()) {\\n\\t\\tTreeNode *curr = nodes.top();\\n\\t\\tnodes.pop();\\n\\t\\tif(curr == toFind) return true;\\n\\t\\tif(curr->left) nodes.push(curr->left);\\n\\t\\tif(curr->right) nodes.push(curr->right);\\n\\t}\\n\\treturn false;\\n}\\nTreeNode* lowestCommonAncestor(TreeNode* r, TreeNode* p, TreeNode* q) {\\n\\tTreeNode *root = r;\\n\\twhile(root) {\\n\\t\\t// four cases\\n\\t\\tif(root == p) return p;\\n\\t\\telse if(root == q) return q;\\n\\t\\tif(root->left) {\\n\\t\\t\\tif(root->right) {\\n\\t\\t\\t\\tif(find(root->left, p)) {\\n\\t\\t\\t\\t\\tif(find(root->left, q)) {\\n\\t\\t\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(find(root->right, q)) {\\n\\t\\t\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//no right child\\n\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//no left child\\n\\t\\t\\tif(root->right) {\\n\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//error\\n\\t\\t\\t\\treturn nullptr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn nullptr;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/6b5bf1ef-2316-4aab-b715-ab8a34761c52_1621655611.5542002.png)\\n\\n**Complexity**\\nTime:  O(n) (proved below)\\nSpace: O(n)\\n\\n**Upvote** if you liked this post, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\nI\\'m also a learner like everyone here, so if you find a mistake in this post, please point it out.\\n\\n**Edit:**\\nI just did a thorough analysis of the time complexity of my solution, and found out that it should be O(n), not O(nlogn) (:D). Sorry for any confusion caused by this. :(\\n\\nHere is the proof for the same:\\nStarting from the root, we make two calls of find (one for each subtree) so a total of O(n) operations here. Then we either return the result, or in the worst case, have to recurse further, to either the left or right subtree (only one of those). So the number of nodes is halved on average.\\nHence the next step costs O(n/2) and so on.\\nThus in the case of a mostly balanced tree, the total complexity is:\\n```n + n/2 + n/4 + .... + 1 = n (2 - 1/n) ``` (by Geometric Progression)\\n i.e O(2n - 1) ~ **O(n)**.\\n \\n Now for the case of skewed trees. Let\\'s assume that the tree is reduced to a linked list on the right. (i.e no nodes have left child). \\n In this case, we don\\'t even call find function, because we are bound to reach a situation where either of p or q is the root and the other is its right child.\\n Hence the complexity in this case is similar to that of traversing a linked list i.e **O(n)**.\\n \\n Since all possible cases fall between these two extremes, the complexity is **O(n)**\\n \\n Hence the time and space complexity of the same is O(n).",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tif(root != toFind) {\\n\\t\\treturn find(root->left, toFind) || find(root->right, toFind);\\n\\t}\\n\\telse {\\n\\t\\treturn root;\\n\\t}\\n}\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(!root) return nullptr;\\n\\t// four cases\\n\\tif(find(root->left, p)) {\\n\\t\\tif(find(root->right, q)) {\\n\\t\\t\\t//root is LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\telse if(find(root->left, q)){\\n\\t\\t\\t//both are in one subtree\\n\\t\\t\\treturn lowestCommonAncestor(root->left, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//root is q;\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse if(find(root->right, p)){\\n\\t\\tif(find(root->left, q)) {\\n\\t\\t\\t//root is LCA\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\telse if(find(root->right, q)){\\n\\t\\t\\t//both are in same subtree\\n\\t\\t\\treturn lowestCommonAncestor(root->right, p, q);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//q is root\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}\\n\\telse {\\n\\t\\t//p is root;\\n\\t\\t//no matter where q is, p is LCA\\n\\t\\treturn p;\\n\\t}\\n}\\n```\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tstack<TreeNode *> nodes;\\n\\tnodes.push(root);\\n\\twhile(!nodes.empty()) {\\n\\t\\tTreeNode *curr = nodes.top();\\n\\t\\tnodes.pop();\\n\\t\\tif(curr == toFind) return true;\\n\\t\\tif(curr->left) nodes.push(curr->left);\\n\\t\\tif(curr->right) nodes.push(curr->right);\\n\\t}\\n\\treturn false;\\n}\\n```\n```\\nbool find(TreeNode *root, TreeNode *toFind) {\\n\\tif(!root) return false;\\n\\tstack<TreeNode *> nodes;\\n\\tnodes.push(root);\\n\\twhile(!nodes.empty()) {\\n\\t\\tTreeNode *curr = nodes.top();\\n\\t\\tnodes.pop();\\n\\t\\tif(curr == toFind) return true;\\n\\t\\tif(curr->left) nodes.push(curr->left);\\n\\t\\tif(curr->right) nodes.push(curr->right);\\n\\t}\\n\\treturn false;\\n}\\nTreeNode* lowestCommonAncestor(TreeNode* r, TreeNode* p, TreeNode* q) {\\n\\tTreeNode *root = r;\\n\\twhile(root) {\\n\\t\\t// four cases\\n\\t\\tif(root == p) return p;\\n\\t\\telse if(root == q) return q;\\n\\t\\tif(root->left) {\\n\\t\\t\\tif(root->right) {\\n\\t\\t\\t\\tif(find(root->left, p)) {\\n\\t\\t\\t\\t\\tif(find(root->left, q)) {\\n\\t\\t\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(find(root->right, q)) {\\n\\t\\t\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//no right child\\n\\t\\t\\t\\troot = root->left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t//no left child\\n\\t\\t\\tif(root->right) {\\n\\t\\t\\t\\troot = root->right;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\t//error\\n\\t\\t\\t\\treturn nullptr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn nullptr;\\n}\\n```\n```n + n/2 + n/4 + .... + 1 = n (2 - 1/n) ```",
                "codeTag": "Unknown"
            },
            {
                "id": 133665,
                "title": "generic-solution-find-common-ancestor-of-k-nodes-in-an-n-ary-tree",
                "content": "```java\\nclass Solution {\\n    \\n    public List<TreeNode> children(TreeNode node) {\\n        List<TreeNode> list = new ArrayList<>();\\n        list.add(node.left);\\n        list.add(node.right);\\n        //list.add(node.child3);\\n        //list.add(node.child4);\\n        //....\\n        return list;\\n    }\\n    \\n    public TreeNode find(TreeNode root, Set<TreeNode> toFind) {\\n        \\n        if (toFind.isEmpty() || root == null) return null;\\n        \\n        boolean matchingNode = false;\\n        if (toFind.contains(root)) {\\n            toFind.remove(root);\\n            if (toFind.isEmpty()) return root;\\n            matchingNode = true;\\n        }\\n        \\n        for (TreeNode child: children(root)) {\\n            int matched = toFind.size();\\n            TreeNode node = find(child, toFind);\\n            if (toFind.isEmpty()) {\\n                if(matchingNode) return root;\\n                else return node;\\n            } else if (matched != toFind.size()) {\\n                matchingNode = true;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Set<TreeNode> toFind = new HashSet<>(); \\n        toFind.add(p);\\n        toFind.add(q);\\n        //toFind.add(r);\\n        //.....\\n        return find(root, toFind);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    public List<TreeNode> children(TreeNode node) {\\n        List<TreeNode> list = new ArrayList<>();\\n        list.add(node.left);\\n        list.add(node.right);\\n        //list.add(node.child3);\\n        //list.add(node.child4);\\n        //....\\n        return list;\\n    }\\n    \\n    public TreeNode find(TreeNode root, Set<TreeNode> toFind) {\\n        \\n        if (toFind.isEmpty() || root == null) return null;\\n        \\n        boolean matchingNode = false;\\n        if (toFind.contains(root)) {\\n            toFind.remove(root);\\n            if (toFind.isEmpty()) return root;\\n            matchingNode = true;\\n        }\\n        \\n        for (TreeNode child: children(root)) {\\n            int matched = toFind.size();\\n            TreeNode node = find(child, toFind);\\n            if (toFind.isEmpty()) {\\n                if(matchingNode) return root;\\n                else return node;\\n            } else if (matched != toFind.size()) {\\n                matchingNode = true;\\n            }\\n        }\\n        \\n        return null;\\n    }\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        Set<TreeNode> toFind = new HashSet<>(); \\n        toFind.add(p);\\n        toFind.add(q);\\n        //toFind.add(r);\\n        //.....\\n        return find(root, toFind);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307685,
                "title": "lca-of-a-binary-tree-1-2-and-4-same-code-c-explained",
                "content": "This code will help for three questions:\\n* [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)\\n* [Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/)\\n* [Lowest Common Ancestor of a Binary Tree IV](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/)\\n\\n**The Idea**\\n\\nFor all these questions, we are supposed to find the Lowest Common Ancestors for a number of given nodes. \\n1. [**I**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) and [**II**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/) require you to find the LCA for a total of 2 given nodes (both of them will surely exist in **I** but might not exist in **II**)\\n2. [**IV**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/) gives you a array of nodes to find LCA for, so will have some array.length() number of nodes.\\n\\nIf we traverse the tree recursively and try to find the existence of these nodes, then while moving up the recursive tree, we can find the ancestor.\\n\\nLets see how this works.\\n* Create a function which returns the number of nodes found in the current tree starting from the given root.\\n* In the function definition, we find the number of nodes found in the left subtree, `leftNodesFoun` and number of nodes in the right subtree, `leftNodesFound` and store it in `ans = leftNodesFound + rightNodesFound`\\n* If the current root is the one to be found, we increment the ans, `ans++`. To access the current root in O(1) we will store the required nodes in a map or a set (This makes more sense for **IV** where n number of nodes are given)\\n* Finally, if the ans is equal to the number of nodes found, the current root will be our LCA. (Since, we are moving up the tree, as soon as we find all the required nodes, that particular root has to be the LCA)\\n* This code is common for all the three variations of the LCA mentioned above.\\n\\nThe Code for the above defined function:\\n```\\n    TreeNode* parent = NULL;\\n    unordered_map<TreeNode*, bool> mp;\\n    int helper(TreeNode* root, int totalNodes){\\n        if (!root){\\n            return 0;\\n        }\\n        \\n        int leftNodesFound = helper(root->left, totalNodes);\\n        int rightNodesFound = helper(root->right, totalNodes);\\n        \\n        int ans = leftNodesFound + rightNodesFound;\\n        \\n        if (mp[root]){\\n            ans++;\\n        }\\n        \\n        if (ans == totalNodes){\\n\\t\\t\\t//We only want to store the first root when all the nodes are found\\n            if(!parent){\\n                parent = root;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n\\n**Caller Functions for each of the questions:**\\n1. [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/) and [Lowest Common Ancestor of a Binary Tree II](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/)\\n\\nHere, the number of nodes is 2 and we store the nodes p and q in a map defined in the snippet above.\\n\\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        mp[p] = true;\\n        mp[q] = true;\\n        helper(root, 2);\\n        return parent;\\n    }\\n```\\n\\n2. [Lowest Common Ancestor of a Binary Tree IV](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/)\\n\\nHere, the number of nodes will be equal to `nodes.size()` and we store each node in the map.\\n\\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {\\n        for (auto node: nodes){\\n            mp[node] = true;\\n        }\\n        helper(root, nodes.size());\\n        return parent;\\n    }\\n```\\n\\nThe same code will help you solve 3 Medium quesions, Please Upvote!!!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n    TreeNode* parent = NULL;\\n    unordered_map<TreeNode*, bool> mp;\\n    int helper(TreeNode* root, int totalNodes){\\n        if (!root){\\n            return 0;\\n        }\\n        \\n        int leftNodesFound = helper(root->left, totalNodes);\\n        int rightNodesFound = helper(root->right, totalNodes);\\n        \\n        int ans = leftNodesFound + rightNodesFound;\\n        \\n        if (mp[root]){\\n            ans++;\\n        }\\n        \\n        if (ans == totalNodes){\\n\\t\\t\\t//We only want to store the first root when all the nodes are found\\n            if(!parent){\\n                parent = root;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        mp[p] = true;\\n        mp[q] = true;\\n        helper(root, 2);\\n        return parent;\\n    }\\n```\n```\\nTreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*> &nodes) {\\n        for (auto node: nodes){\\n            mp[node] = true;\\n        }\\n        helper(root, nodes.size());\\n        return parent;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65364,
                "title": "my-python-recursion-and-iteration-solution-easy-and-fast",
                "content": "Iteration:\\n\\n    enter code hereclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        while root:\\n            if not root or root==p or root==q:\\n                return root\\n            if self.isnode(p,q):\\n                return p\\n            if self.isnode(q,p):\\n                return q\\n            if self.isnode(root.left,p) and self.isnode(root.left,q):\\n                root=root.left\\n            if self.isnode(root.right,p) and self.isnode(root.right,q):\\n                root=root.right\\n            else:\\n                return root\\n                \\n        \\n    def isnode(self,mother,child):\\n        if mother:\\n            if mother==child:\\n                return True\\n            else:\\n                return self.isnode(mother.left,child) or self.isnode(mother.right,child)\\n        return False        \\n\\nrecursion:\\n\\n    enter code hereclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not root or root==p or root==q:\\n            return root\\n            \\n        if self.isnode(p,q):\\n            return p\\n        if self.isnode(q,p):\\n            return q\\n            \\n        if self.isnode(root.left,p) and self.isnode(root.left,q):\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif self.isnode(root.right,p) and self.isnode(root.right,q):\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        else:\\n            return root\\n                \\n        \\n    def isnode(self,mother,child):\\n        if mother:\\n            if mother==child:\\n                return True\\n            else:\\n                return self.isnode(mother.left,child) or self.isnode(mother.right,child)\\n        return False",
                "solutionTags": [],
                "code": "Iteration:\\n\\n    enter code hereclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        while root:\\n            if not root or root==p or root==q:\\n                return root\\n            if self.isnode(p,q):\\n                return p\\n            if self.isnode(q,p):\\n                return q\\n            if self.isnode(root.left,p) and self.isnode(root.left,q):\\n                root=root.left\\n            if self.isnode(root.right,p) and self.isnode(root.right,q):\\n                root=root.right\\n            else:\\n                return root\\n                \\n        \\n    def isnode(self,mother,child):\\n        if mother:\\n            if mother==child:\\n                return True\\n            else:\\n                return self.isnode(mother.left,child) or self.isnode(mother.right,child)\\n        return False        \\n\\nrecursion:\\n\\n    enter code hereclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not root or root==p or root==q:\\n            return root\\n            \\n        if self.isnode(p,q):\\n            return p\\n        if self.isnode(q,p):\\n            return q\\n            \\n        if self.isnode(root.left,p) and self.isnode(root.left,q):\\n            return self.lowestCommonAncestor(root.left, p, q)\\n        elif self.isnode(root.right,p) and self.isnode(root.right,q):\\n            return self.lowestCommonAncestor(root.right, p, q)\\n        else:\\n            return root\\n                \\n        \\n    def isnode(self,mother,child):\\n        if mother:\\n            if mother==child:\\n                return True\\n            else:\\n                return self.isnode(mother.left,child) or self.isnode(mother.right,child)\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 65387,
                "title": "java-build-the-paths-in-stacks-from-nodes-to-root-with-dfs-return-the-first-crossing-point-on-paths",
                "content": "    public class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n    \\tStack<TreeNode> pStack = new Stack<TreeNode>();\\n    \\tStack<TreeNode> qStack = new Stack<TreeNode>();\\n    \\tTreeNode target = null;\\n    \\tif (findPath(root, p, pStack) && findPath(root, q, qStack)) {\\n     \\t\\twhile (!pStack.isEmpty()) {\\n     \\t\\t\\tTreeNode pNode = pStack.pop();\\n    \\t\\t\\tif (qStack.contains(pNode))\\n    \\t\\t\\t\\ttarget = pNode;\\n    \\t\\t}\\n    \\t} \\n    \\treturn target;\\n    }\\n\\n\\tprivate boolean findPath(TreeNode root, TreeNode node, Stack<TreeNode> stack) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn false;\\n\\t\\tif (root == node) {\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\treturn true;\\n\\t\\t} else {\\n\\t\\t\\tif (findPath(root.left, node, stack) ||  findPath(root.right, node, stack)) {\\n\\t\\t\\t    stack.push(root);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n    \\tStack<TreeNode> pStack = new Stack<TreeNode>();\\n    \\tStack<TreeNode> qStack = new Stack<TreeNode>();\\n    \\tTreeNode target = null;\\n    \\tif (findPath(root, p, pStack) && findPath(root, q, qStack)) {\\n     \\t\\twhile (!pStack.isEmpty()) {\\n     \\t\\t\\tTreeNode pNode = pStack.pop();\\n    \\t\\t\\tif (qStack.contains(pNode))\\n    \\t\\t\\t\\ttarget = pNode;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1817260,
                "title": "simple-python-recursive-solution-with-explanation",
                "content": "The logic here is to check for every node, whether p or q belong to that root\\'s subtree. \\nIf the root val is equal to either p or q, we know that the root is definitely one of it\\'s ancestors. We simply return it.\\nOne important point to note is that for a given root, if p or q are part of subtree, we return root, implying that that is an ancestor. If not, we return ```null```.  \\nWe do this recursively on the left and right subtrees of a given root.\\nIf both left and right return a non null value, we know that\\'s the lowest common ancestor. \\nIf left returns null and right returns non null, we know that the answer lies within the right subtree.\\n\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if not root:\\n            return None\\n        \\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left and right:\\n            return root\\n        if not left and not right:\\n            return None\\n        \\n        return left if left else right\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```null```",
                "codeTag": "Unknown"
            },
            {
                "id": 1614047,
                "title": "beginner-friendly-java-javascript-python-solution-explanation-with-examples",
                "content": "**Explanation :**\\n**Eg - 1**\\n![image](https://assets.leetcode.com/users/images/ca40fd95-4b47-4607-ac1f-73d32e9bd6b0_1658796345.975119.png)\\n\\n**Eg-2**\\n![image](https://assets.leetcode.com/users/images/0f24f084-61b1-4180-998a-77d02a3be449_1658796439.1572185.png)\\n\\n**Java**\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q)  return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left == null ? right : right == null ? left : root;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root || root == p || root == q)  return root\\n    let left = lowestCommonAncestor(root.left, p, q)\\n    let right = lowestCommonAncestor(root.right, p, q)\\n    return left && right ? root : left || right\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        return root if left and right else left or right\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q)  return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        return left == null ? right : right == null ? left : root;\\n    }\\n}\\n```\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root || root == p || root == q)  return root\\n    let left = lowestCommonAncestor(root.left, p, q)\\n    let right = lowestCommonAncestor(root.right, p, q)\\n    return left && right ? root : left || right\\n};\\n```\n```\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        if not root or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        return root if left and right else left or right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140471,
                "title": "literal-recursion-in-python",
                "content": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        def dfs(node):\\n            if node in (None, p, q):\\n                return node\\n            \\n            llca, rlca = dfs(node.left), dfs(node.right)\\n            return node if llca and rlca else llca or rlca\\n        \\n        return dfs(root)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        def dfs(node):\\n            if node in (None, p, q):\\n                return node\\n            \\n            llca, rlca = dfs(node.left), dfs(node.right)\\n            return node if llca and rlca else llca or rlca\\n        \\n        return dfs(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65334,
                "title": "simple-c-solution-easy-to-understand",
                "content": "    vector<TreeNode*> path, path1, path2;\\n\\n    void find_in_tree(TreeNode *root, TreeNode *p, TreeNode *q) {\\n        if (!root) return;\\n        path.push_back(root);\\n        if (root == p) {\\n            path1 = path;\\n        } else if (root == q) {\\n            path2 = path;\\n        }\\n        find_in_tree(root->left, p, q);\\n        find_in_tree(root->right, p, q);\\n        path.pop_back();\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n        find_in_tree(root, p, q);\\n        int min_size = min(path1.size(), path2.size());\\n        for (int i = 0; i < min_size; i++) {\\n            if (path1[i] != path2[i]) return path1[i - 1]; \\n        }\\n        return path1[min_size - 1];\\n    }",
                "solutionTags": [],
                "code": "    vector<TreeNode*> path, path1, path2;\\n\\n    void find_in_tree(TreeNode *root, TreeNode *p, TreeNode *q) {\\n        if (!root) return;\\n        path.push_back(root);\\n        if (root == p) {\\n            path1 = path;\\n        } else if (root == q) {\\n            path2 = path;\\n        }\\n        find_in_tree(root->left, p, q);\\n        find_in_tree(root->right, p, q);\\n        path.pop_back();\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) {\\n        find_in_tree(root, p, q);\\n        int min_size = min(path1.size(), path2.size());\\n        for (int i = 0; i < min_size; i++) {\\n            if (path1[i] != path2[i]) return path1[i - 1]; \\n        }\\n        return path1[min_size - 1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65397,
                "title": "simple-recursive-solution-in-c-no-helper-func-needed",
                "content": "    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        if(root == p || root == q)\\n        {\\n            return root;\\n        }\\n        \\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n        if(left != NULL && right != NULL)\\n        {\\n            return root;\\n        }\\n        else if(left == NULL && right == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        return left != NULL ? left : right;\\n    }",
                "solutionTags": [],
                "code": "    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        if(root == p || root == q)\\n        {\\n            return root;\\n        }\\n        \\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n        if(left != NULL && right != NULL)\\n        {\\n            return root;\\n        }\\n        else if(left == NULL && right == NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        return left != NULL ? left : right;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2339073,
                "title": "js-intuitive-dfs-recursion-in-4-lines",
                "content": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root || root.val == p.val || root.val == q.val) return root;\\n    \\n    let left = lowestCommonAncestor(root.left, p, q);\\n    let right = lowestCommonAncestor(root.right, p, q);\\n\\n    return (left && right) ? root : left || right;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root || root.val == p.val || root.val == q.val) return root;\\n    \\n    let left = lowestCommonAncestor(root.left, p, q);\\n    let right = lowestCommonAncestor(root.right, p, q);\\n\\n    return (left && right) ? root : left || right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286878,
                "title": "java-soln-6-lines-dfs",
                "content": "## Approach\\nWe can do a DFS search in the tree to locate our two nodes, the node which receives some kind of non-null result from its left and right searches will be the lowest ancestor of the required nodes. If we don\\'t get non-null response from both left & right subtree then we just return the result as it is.\\n\\n## Complexities\\n**Time: O(n)\\nSpace: O(h)**\\n\\n## Code\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null) return root;\\n        return left == null ? right : left;\\n    }\\n}\\n```\\n\\nPlease **upvote** if this helped, thanks!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p || root == q) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null) return root;\\n        return left == null ? right : left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404818,
                "title": "efficient-naive-approach-explained-logic",
                "content": "# Naive Approach:\\nTo find the LCA we store the root to Node path using path function in a ArrayList, we run this func. for both p and q. Once we\\'ve stored the path into an ArrayList, we can traverse over all the nodes in both the lists and the last common element would be the LCA.  \\n```\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ArrayList<TreeNode> p1 = new ArrayList<>();\\n        ArrayList<TreeNode> p2 = new ArrayList<>();\\n        path(root, p, p1);\\n        path(root, q, p2);\\n        int i = 0;\\n        while(i<p1.size() && i<p2.size() && p1.get(i) == p2.get(i)){\\n            i++;\\n        }\\n        return p1.get(i-1);\\n    }\\n    public boolean path(TreeNode root, TreeNode node, ArrayList<TreeNode> list){\\n        if(root == null) return false;\\n        list.add(root);\\n        if(root == node) return true;\\n        if(path(root.left, node, list) || path(root.right, node, list)){\\n            return true;\\n        }\\n        list.remove(list.size()-1);//Taaki faltu chars na store ho :P\\n        return false;\\n    }   \\n}\\n```\\nBut this isn\\'t space optimized. Let\\'s look at a space optimized approach.\\n# Efficient Approach:\\nLooking at this problem, might seem hard at first. Now to solve it lets consider a node, and breakdown the problem into few cases:\\nCase 1: The node we\\'re considering is null, now obviously we won\\'t be able to reach anywhere with null node, so just return null;\\nCase 2: if the node we\\'re holding is either p or q, if we have found p, Now this is the case \"where we allow a node to be a descendant of itself\". this node is the LCA here\\nCase 3: Now if the above two cases do not work let\\'s try considering the left and right subtree of this node, here if LeftSubtree(l in the code) returns any of p or q (definitely not null) and right subtree provides returns any of p or q (opposite to left subtree and definitely not null), the node would be the LCA.\\nCase 4: when if either of subtree returns a not null value and other provides a null value, our problem reduces to that tree only, hence just return the root of the subtree).\\n\\n```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null; // Case 1\\n        if(root == p || root == q) return root; // Case 2\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n\\n        if(l!=null && r!=null) return root; // Case 3\\n        else // Case 4\\n        {\\n            if(l!=null) return l;\\n            else return r;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ArrayList<TreeNode> p1 = new ArrayList<>();\\n        ArrayList<TreeNode> p2 = new ArrayList<>();\\n        path(root, p, p1);\\n        path(root, q, p2);\\n        int i = 0;\\n        while(i<p1.size() && i<p2.size() && p1.get(i) == p2.get(i)){\\n            i++;\\n        }\\n        return p1.get(i-1);\\n    }\\n    public boolean path(TreeNode root, TreeNode node, ArrayList<TreeNode> list){\\n        if(root == null) return false;\\n        list.add(root);\\n        if(root == node) return true;\\n        if(path(root.left, node, list) || path(root.right, node, list)){\\n            return true;\\n        }\\n        list.remove(list.size()-1);//Taaki faltu chars na store ho :P\\n        return false;\\n    }   \\n}\\n```\n```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null; // Case 1\\n        if(root == p || root == q) return root; // Case 2\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n\\n        if(l!=null && r!=null) return root; // Case 3\\n        else // Case 4\\n        {\\n            if(l!=null) return l;\\n            else return r;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306524,
                "title": "c-simple-and-easy-clean-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool rec(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (!root) return false;\\n        \\n        int in_left = rec(root->left, p, q);\\n        int in_right = rec(root->right, p, q);\\n        int curr = (root == p) || (root == q);\\n        \\n        if ((in_left && in_right) || (in_left && curr) || (in_right && curr))\\n            res = root;\\n        \\n        return in_left || in_right || curr;\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        rec(root, p, q);\\n        return res;\\n    }\\n    \\nprivate:\\n    TreeNode* res;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (!root) return false;\\n        \\n        int in_left = rec(root->left, p, q);\\n        int in_right = rec(root->right, p, q);\\n        int curr = (root == p) || (root == q);\\n        \\n        if ((in_left && in_right) || (in_left && curr) || (in_right && curr))\\n            res = root;\\n        \\n        return in_left || in_right || curr;\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        rec(root, p, q);\\n        return res;\\n    }\\n    \\nprivate:\\n    TreeNode* res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65340,
                "title": "java-easy-solution-beats-72",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root==null) return null;\\n            if(root==p) return root;\\n            if(root==q) return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if(left!=null&&right!=null){\\n                return root;\\n            }else{\\n                return left==null?right:left;\\n            }\\n        }\\n        \\n        \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if(root==null) return null;\\n            if(root==p) return root;\\n            if(root==q) return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if(left!=null&&right!=null){\\n                return root;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65278,
                "title": "my-solution-may-be-not-so-good-but-clear",
                "content": "First, we use a map to save the node  and its parent for all nodes.\\nThis saves all the path from leaves to the root.\\nSecond, from Node p ,we climb to the root to form a Route of Nodes \\nFinally , let the q goes up until it touches the route.\\n\\n    public class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        HashMap<TreeNode,TreeNode> m = new HashMap<TreeNode,TreeNode>();\\n        // bfs walking tree\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        while(queue.peek()!=null){\\n            TreeNode t = queue.poll();\\n            if(t.left!=null){\\n                m.put(t.left,t);\\n                queue.offer(t.left);\\n            }\\n            if(t.right!=null){\\n                m.put(t.right,t);\\n                queue.offer(t.right);\\n            }\\n        }\\n        // build route\\n        Set<TreeNode> l = new HashSet<TreeNode>();\\n        TreeNode pp = p;\\n        while(pp!=root){\\n            l.add(pp);\\n            pp = m.get(pp);\\n        }\\n        l.add(root);\\n        TreeNode qq = q;\\n        while(!l.contains(qq)){\\n            qq = m.get(qq);\\n        }\\n        return qq;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        HashMap<TreeNode,TreeNode> m = new HashMap<TreeNode,TreeNode>();\\n        // bfs walking tree\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        while(queue.peek()!=null){\\n            TreeNode t = queue.poll();\\n            if(t.left!=null){\\n                m.put(t.left,t);\\n                queue.offer(t.left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65451,
                "title": "my-c-solution-using-dfs",
                "content": "To get the LCA(Lowest Common Ancestor) of TreeNode p and q, the algorithm works as following:  \\n1. Use dfs to calculate the depth and parent for each TreeNode;  \\n2. Suppose depth[p] > depth[q], then let d = depth[p]-depth[q], first move p upwards d times and then move both p and q upwards until p and q point to the same node, which is the LCA of p and q;\\n\\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            unordered_map<TreeNode*, int> depth;\\n            unordered_map<TreeNode*, TreeNode*> parent;\\n            dfs(root, NULL, 0, depth, parent);\\n            if (depth[p] < depth[q])\\n                swap(p, q);\\n            int d = depth[p]-depth[q];\\n            for (int i=0; i<d; i++)\\n                p = parent[p];\\n            while (p != q) {\\n                q = parent[q];\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n        void dfs(TreeNode* node, TreeNode* p, int d, \\n            unordered_map<TreeNode*, int>& depth, \\n            unordered_map<TreeNode*, TreeNode*>& parent) {\\n            if (!node) return;\\n            depth[node] = d;\\n            parent[node] = p;\\n            dfs(node->left, node, d+1, depth, parent);\\n            dfs(node->right, node, d+1, depth, parent);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            unordered_map<TreeNode*, int> depth;\\n            unordered_map<TreeNode*, TreeNode*> parent;\\n            dfs(root, NULL, 0, depth, parent);\\n            if (depth[p] < depth[q])\\n                swap(p, q);\\n            int d = depth[p]-depth[q];\\n            for (int i=0; i<d; i++)\\n                p = parent[p];\\n            while (p != q) {\\n                q = parent[q];\\n                p = parent[p];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2228778,
                "title": "clean-simple-c-solution-beats-80-submissions",
                "content": "Steps -\\n1. Start from root node and for each node, do the following steps\\n2. Return NULL if the node is NULL (base case).\\n2. Return the node itself when it is equal to anyone of the node to be found out.\\n3. Recursively call the function for left and right children of each node.\\n4. If the returned node from both left and right children are not NULL, then our current node is the Lowest Common Ancestor and so we return current node\\n5. Else the Lowest Common Ancestor is the that node which is not NULL (from left and right children)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if (root==NULL)\\n            return NULL;\\n        \\n        if (root == p || root == q)\\n            return root;\\n        \\n        TreeNode * l = lowestCommonAncestor (root->left, p, q);\\n        TreeNode * r = lowestCommonAncestor (root->right, p, q);\\n        \\n        if (l && r)\\n            return root;\\n        \\n        if (l)\\n            return l;\\n        \\n        else\\n            return r;\\n    }\\n};\\n```\\n\\nFeel free to ask any question in the comment section.\\nI hope that you found the solution useful.\\nIf so, please do upvote and encourage me. \\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if (root==NULL)\\n            return NULL;\\n        \\n        if (root == p || root == q)\\n            return root;\\n        \\n        TreeNode * l = lowestCommonAncestor (root->left, p, q);\\n        TreeNode * r = lowestCommonAncestor (root->right, p, q);\\n        \\n        if (l && r)\\n            return root;\\n        \\n        if (l)\\n            return l;\\n        \\n        else\\n            return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554869,
                "title": "c-recursive-one-pass-solution-code-commented",
                "content": "**Time: O(n)\\nSpace: O(n)**\\n\\n**upvote if you find this helpful. Thanks:)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // if root == null or current node is equal to either p or q \\n        if(!root || (root->val == p->val) || (root->val==q->val)){\\n            return root;\\n        }\\n        \\n        // search in left and right subtree, basically postorder traversal\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        \\n        // check condition\\n        if(left==nullptr && right==nullptr){// if left and right subtree doesn\\'t contain p or q\\n            return nullptr; \\n        }\\n        if(left && right){// if p and q are present in left and right subtree\\n            return root;\\n        }\\n        \\n        // if left subtree contains both p and q return the LCA node returned from left subtree\\n        // else it is present in right subtree\\n        return (left!=nullptr)?left:right;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // if root == null or current node is equal to either p or q \\n        if(!root || (root->val == p->val) || (root->val==q->val)){\\n            return root;\\n        }\\n        \\n        // search in left and right subtree, basically postorder traversal\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        \\n        // check condition\\n        if(left==nullptr && right==nullptr){// if left and right subtree doesn\\'t contain p or q\\n            return nullptr; \\n        }\\n        if(left && right){// if p and q are present in left and right subtree\\n            return root;\\n        }\\n        \\n        // if left subtree contains both p and q return the LCA node returned from left subtree\\n        // else it is present in right subtree\\n        return (left!=nullptr)?left:right;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376667,
                "title": "c-solution-recursive-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL) return NULL;\\n        if(root->val  == p->val || root->val == q->val){\\n            return root;\\n        }\\n        TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n         TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n        if(l != NULL && r != NULL){\\n            return root;\\n        }\\n        else if(l != NULL){\\n            return l;\\n        }\\n        else{\\n            return r;\\n        }\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        return solve(root, p, q);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* solve(TreeNode* root, TreeNode* p, TreeNode* q){\\n        if(root == NULL) return NULL;\\n        if(root->val  == p->val || root->val == q->val){\\n            return root;\\n        }\\n        TreeNode* l = lowestCommonAncestor(root->left, p, q);\\n         TreeNode* r = lowestCommonAncestor(root->right, p, q);\\n        if(l != NULL && r != NULL){\\n            return root;\\n        }\\n        else if(l != NULL){\\n            return l;\\n        }\\n        else{\\n            return r;\\n        }\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        return solve(root, p, q);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259151,
                "title": "explained-solution-asked-by-microsoft-amazon-twitter-with-complexities",
                "content": "```\\n// \\t\\t\\t\\t\\t*** EXPLANATION ***:\\n// We\\'ll do just normal tree traversal of the given binary tree recursivly.  \\n// To finding LCA (lowest common ancestor) we\\'ve following conditions for every node in the tree that...\\n// But before that, this solutions works under the assumption that both Node \\'p\\' & Node \\'q\\' will present in the tree...\\n//  if only one of the node is present in the tree it\\'ll not work or simply return null... \\n\\n// CONDITIONS: -\\t\\t\\t\\t\\t\\t\\t\\t\\n// 1. if current node is same as \\'p\\' OR \\'q\\'.\\n// 2. if one of it\\'s subtrees contains \\'p\\' and other \\'q\\' (subtrees means, left_sub_tree and right_sub_tree).\\n// 3. if one of it\\'s subtree contains both \\'p\\' & \\'q\\'.\\n// 4. if none of it\\'s subtrees contains any of \\'p\\' & \\'q\\'.\\n\\n// however, that\\'s a tricky implementation, but works well under the assumption that \\'p\\' & \\'q\\' will definitely present.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\n\\t\\tif(root == NULL)\\n\\t\\t\\treturn NULL;\\n\\n\\t\\tif(root->val == p->val || root->val == q->val)       // \\uD83D\\uDC49 FIRST CONDITION...\\n\\t\\t\\treturn root;\\n\\n\\t\\tTreeNode* lca1 = lowestCommonAncestor(root->left, p, q);    // traverse on the left part of the tree\\n\\t\\tTreeNode* lca2 = lowestCommonAncestor(root->right, p, q);   // traverse on the right part of the tree\\n\\n\\t\\tif(lca1 != NULL && lca2 != NULL)                    // \\uD83D\\uDC49 SECOND CONDITION... (IF BOTH SUB-TREE CONTAINS \\'p\\' & \\'q\\' RESPECTIVELY)\\n\\t\\t\\treturn root;\\n\\t\\t\\n\\t\\tif(lca1 != NULL)                                   // \\uD83D\\uDC49 THIRD CONDITION...\\n\\t\\t\\treturn lca1;\\n\\t\\telse\\n\\t\\t\\treturn lca2;\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDC49 FOURTH CONDITION...\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY : O(N), Where N, total number of nodes in the tree\\nSPACE COMPLEXITY : O(H) , Where H, total height of tree for recursion stack**\\n\\nif you **find any mistakes pls**, drop a comment\\nif it makes any sense don\\'t forget to **Upvote**",
                "solutionTags": [],
                "code": "```\\n// \\t\\t\\t\\t\\t*** EXPLANATION ***:\\n// We\\'ll do just normal tree traversal of the given binary tree recursivly.  \\n// To finding LCA (lowest common ancestor) we\\'ve following conditions for every node in the tree that...\\n// But before that, this solutions works under the assumption that both Node \\'p\\' & Node \\'q\\' will present in the tree...\\n//  if only one of the node is present in the tree it\\'ll not work or simply return null... \\n\\n// CONDITIONS: -\\t\\t\\t\\t\\t\\t\\t\\t\\n// 1. if current node is same as \\'p\\' OR \\'q\\'.\\n// 2. if one of it\\'s subtrees contains \\'p\\' and other \\'q\\' (subtrees means, left_sub_tree and right_sub_tree).\\n// 3. if one of it\\'s subtree contains both \\'p\\' & \\'q\\'.\\n// 4. if none of it\\'s subtrees contains any of \\'p\\' & \\'q\\'.\\n\\n// however, that\\'s a tricky implementation, but works well under the assumption that \\'p\\' & \\'q\\' will definitely present.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\n\\t\\tif(root == NULL)\\n\\t\\t\\treturn NULL;\\n\\n\\t\\tif(root->val == p->val || root->val == q->val)       // \\uD83D\\uDC49 FIRST CONDITION...\\n\\t\\t\\treturn root;\\n\\n\\t\\tTreeNode* lca1 = lowestCommonAncestor(root->left, p, q);    // traverse on the left part of the tree\\n\\t\\tTreeNode* lca2 = lowestCommonAncestor(root->right, p, q);   // traverse on the right part of the tree\\n\\n\\t\\tif(lca1 != NULL && lca2 != NULL)                    // \\uD83D\\uDC49 SECOND CONDITION... (IF BOTH SUB-TREE CONTAINS \\'p\\' & \\'q\\' RESPECTIVELY)\\n\\t\\t\\treturn root;\\n\\t\\t\\n\\t\\tif(lca1 != NULL)                                   // \\uD83D\\uDC49 THIRD CONDITION...\\n\\t\\t\\treturn lca1;\\n\\t\\telse\\n\\t\\t\\treturn lca2;\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDC49 FOURTH CONDITION...\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395340,
                "title": "python-iterative-dfs-beats-98-94-in-time-and-100-in-space",
                "content": "Simply use DFS to search for `p` and `q`, and record their paths once hit, then just compare the two paths and you will find the lowest common ancestor!\\n```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        stack, p_trace, q_trace = [], [], []\\n\\t\\t\\n        while True:\\n            if root.left:\\n                stack.append(root)\\n                root.left, root = None, root.left\\n            elif root.right:\\n                stack.append(root)\\n                root.right, root = None, root.right\\n            else:\\n                if root is p:\\n                    p_trace = stack[:]\\n                    p_trace.append(root)\\n                if root is q:\\n                    q_trace = stack[:]\\n                    q_trace.append(root)\\n                if p_trace and q_trace:\\n                    break\\n                root = stack.pop()\\n\\t\\t\\t\\t\\n        i, m = 0, min(len(p_trace), len(q_trace))\\n        while i < m and p_trace[i] is q_trace[i]:\\n            ans = p_trace[i]\\n            i += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        stack, p_trace, q_trace = [], [], []\\n\\t\\t\\n        while True:\\n            if root.left:\\n                stack.append(root)\\n                root.left, root = None, root.left\\n            elif root.right:\\n                stack.append(root)\\n                root.right, root = None, root.right\\n            else:\\n                if root is p:\\n                    p_trace = stack[:]\\n                    p_trace.append(root)\\n                if root is q:\\n                    q_trace = stack[:]\\n                    q_trace.append(root)\\n                if p_trace and q_trace:\\n                    break\\n                root = stack.pop()\\n\\t\\t\\t\\t\\n        i, m = 0, min(len(p_trace), len(q_trace))\\n        while i < m and p_trace[i] is q_trace[i]:\\n            ans = p_trace[i]\\n            i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146935,
                "title": "intuitive-post-order",
                "content": "Relative positions of p and q help divide the problem.\\n\\nThere are three relative positions of p and q to root:\\n- Both p and q are to the right of root, then the LCA exists in root\\'s right subtree.\\n- Both p and q are to the left of root, then the LCA exists in root\\'s left subtree.\\n- p and q are one to the left, the other to the right of root, then the LCA is root.\\n\\nHowever, we can\\'t tell relative postitions of p and q at first, so postorder traversal is needed. Meanwhile, one more base case is needed: when we exhaust the tree, i.e. when root is null.\\n\\n****\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root is None or root == p or root == q:\\n            return root\\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left is not None and right is not None:\\n            return root\\n        elif left is not None:\\n            return left\\n        elif right is not None:\\n            return right\\n        else:\\n            return None\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root is None or root == p or root == q:\\n            return root\\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left is not None and right is not None:\\n            return root\\n        elif left is not None:\\n            return left\\n        elif right is not None:\\n            return right\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65310,
                "title": "o-nlgn-preprocessing-o-1-query-time-utilizing-rmq-reduction",
                "content": "First convert LCA problem to RMQ (range minimum query) problem by generating Euler tour. LCA must occur in between the two query nodes in the Euler tour, and LCA has the smallest level (distance to root). Therefore LCA problem is reduced to finding smallest element in an array with specified range.\\n\\nReference: Bender, Michael A., and Martin Farach-Colton. \"The LCA problem revisited.\" Latin American Symposium on Theoretical Informatics. Springer Berlin Heidelberg, 2000.\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        LinearLCA lca = new LinearLCA(root);\\n        return lca.query(p, q);\\n    }\\n\\n    public static class TreeNodeUtils {     \\n        /**\\n         * return Euler Tour in an array. An Euler Tour\\n         * traverses every edge of a directed graph\\n         * exactly once and records which nodes are visited.\\n         * each undirected edge consists of two directed \\n         * edges of opposite directions.\\n         * \\n         * @param root\\n         * @return\\n         */\\n        public static TreeNode[] EulerTour(TreeNode root) {\\n            ArrayList<TreeNode> tour = new ArrayList<TreeNode>();\\n            EulerTour(tour, root);\\n            return tour.toArray(new TreeNode[0]);\\n        }\\n        private static void EulerTour(ArrayList<TreeNode> tour, TreeNode root) {\\n            if (root == null) {\\n                return;\\n            }\\n            tour.add(root);\\n            EulerTour(tour, root.left);\\n            if (root.left != null) {\\n                tour.add(root);\\n            }\\n            EulerTour(tour, root.right);\\n            if (root.right != null) {\\n                tour.add(root);\\n            }\\n        }\\n        /**\\n         * output levels (distance from root) in Euler tour order\\n         * @return\\n         */\\n        public static int[] getLevels(TreeNode root, TreeNode[] euler) {\\n            if (root == null || euler == null || euler.length == 0) {\\n                throw new IllegalArgumentException();\\n            }\\n            Map<TreeNode, Integer> node2levels = TreeNodeUtils.getLevels(root);\\n            int[] levels = new int[euler.length];\\n            for (int i = 0; i < euler.length; i++) {\\n                levels[i] = node2levels.get(euler[i]);            \\n            }\\n            return levels;\\n        }\\n        /**\\n         * output levels in a Map with key as nodes\\n         * and values as levels. Use BFS (level-order\\n         * traversal) to find all levels.\\n         */\\n        public static Map<TreeNode, Integer> getLevels(TreeNode root) {\\n            Queue<TreeNode> toVisit = new LinkedList<TreeNode>();\\n            Map<TreeNode, Integer> node2level = new HashMap<TreeNode, Integer>();\\n            int currentLevel = 0;\\n            toVisit.offer(root);\\n            while(!toVisit.isEmpty()) {\\n                int currentLevelSize = toVisit.size();\\n                for (int i = 0; i < currentLevelSize; i++) {\\n                    TreeNode current = toVisit.poll();\\n                    if(current.left != null) {\\n                        toVisit.add(current.left);\\n                    }\\n                    if (current.right != null) {\\n                        toVisit.add(current.right);\\n                    }\\n                    node2level.put(current, currentLevel);\\n                }\\n                currentLevel++;\\n            }\\n            return node2level;\\n        }\\n    }\\n\\n    public interface LCA {\\n        public TreeNode query(TreeNode p, TreeNode q);\\n    }\\n    public class LinearLCA implements LCA {\\n        private TreeNode[] euler;\\n        private Map<TreeNode, Integer> node2representatives;\\n        private int[] levels;\\n        private RMQ rmq;\\n\\n        /**\\n         * initialize Euler tour, representatives, levels\\n         * and RMQ object\\n         * @param root\\n         */\\n        public LinearLCA(TreeNode root) {\\n            euler = TreeNodeUtils.EulerTour(root);\\n            node2representatives = getRepresentatives(euler);      \\n            levels = TreeNodeUtils.getLevels(root, euler);\\n            this.rmq = new SparseTableRMQ(this.levels);\\n        }\\n        private Map<TreeNode, Integer> getRepresentatives(TreeNode[] euler) {\\n            Map<TreeNode, Integer> representatives = new HashMap<TreeNode, Integer>();\\n            for (int i = 0; i < euler.length; i++) {\\n                if (!representatives.containsKey(euler[i])) {\\n                    representatives.put(euler[i], i);\\n                }\\n            }\\n            return representatives;\\n        }\\n        public TreeNode query(TreeNode u, TreeNode v) {\\n            if (!node2representatives.containsKey(u) || !node2representatives.containsKey(v)) {\\n                throw new IllegalArgumentException();\\n            }\\n            int firstU = node2representatives.get(u);\\n            int firstV = node2representatives.get(v);\\n            return euler[rmq.min(Math.min(firstU, firstV), Math.max(firstU,firstV))];        \\n        }\\n    }\\n\\n    /*\\n     * interface for range minimum query problem\\n     * \\n     */\\n    public interface RMQ {\\n        public int min(int i, int j);\\n    }\\n\\n    public class SparseTableRMQ implements RMQ{\\n        private int[][] st;\\n        private int[] pow;\\n        private int[] a;\\n        private int N;\\n        public SparseTableRMQ(int[] a) {\\n            this.a = a;\\n            N = a.length;\\n            if (N <= 1) {\\n                return;\\n            }\\n            //we get floor of lgN because\\n            //2*2^lgN is enough for query from 0 to N-1\\n            int lgN = (int) (Math.log(N)/Math.log(2));\\n            //pre-calculate powers of 2 to save time\\n            pow = pow2(lgN);\\n            st = new int[N][lgN + 1];\\n            //initialize first column\\n            for (int i = 0; i < N; i++) {\\n                st[i][0] = i;\\n            }\\n            for (int j = 1; j <= lgN; j++) {\\n                for (int i = 0; i < N; i++) {\\n                    //not all rows have lgN columns\\n                    //note that i is inclusive\\n                    if (i + pow[j] - 1 >= N) {\\n                        continue;\\n                    }\\n                    int leftMin = st[i][j-1];\\n                    int rightMin = st[i + pow[j-1]][j - 1];\\n                    //when there are ties, return smallest index\\n                    st[i][j] = a[leftMin] <= a[rightMin] ? leftMin : rightMin;\\n                }\\n            }\\n        }\\n        private int[] pow2(int n) {\\n            int[] pow = new int[n + 1];\\n            pow[0] = 1;\\n            for (int i = 1; i <= n; i++) {\\n                pow[i] = pow[i - 1] * 2;\\n            }\\n            return pow;\\n        }\\n        public int min(int i, int j) {\\n            if (i > j || i < 0 || j >= N) {\\n                throw new IllegalArgumentException();\\n            }\\n            if (N == 0) {\\n                return -1;\\n            }\\n            if (i == j || N == 1) {\\n                return i;\\n            }\\n            //find the step where 2*2^step >= j - i + 1\\n            int stepSize = (int) (Math.log(j - i + 1)/Math.log(2));\\n            if (pow[stepSize] == (j - i + 1)) {\\n                stepSize--;\\n            }\\n            /*\\n             * i------------------j\\n             * i--------i+step-1\\n             *     j-step+1-------j\\n             */\\n            int leftMin = st[i][stepSize];\\n            int rightMin = st[j - pow[stepSize] + 1][stepSize];\\n\\n            return a[leftMin] <= a[rightMin] ? leftMin : rightMin;\\n        }\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        LinearLCA lca = new LinearLCA(root);\\n        return lca.query(p, q);\\n    }\\n\\n    public static class TreeNodeUtils {     \\n        /**\\n         * return Euler Tour in an array. An Euler Tour\\n         * traverses every edge of a directed graph\\n         * exactly once and records which nodes are visited.\\n         * each undirected edge consists of two directed \\n         * edges of opposite directions.\\n         * \\n         * @param root\\n         * @return\\n         */\\n        public static TreeNode[] EulerTour(TreeNode root) {\\n            ArrayList<TreeNode> tour = new ArrayList<TreeNode>();\\n            EulerTour(tour, root);\\n            return tour.toArray(new TreeNode[0]);\\n        }\\n        private static void EulerTour(ArrayList<TreeNode> tour, TreeNode root) {\\n            if (root == null) {\\n                return;\\n            }\\n            tour.add(root);\\n            EulerTour(tour, root.left);\\n            if (root.left != null) {\\n                tour.add(root);\\n            }\\n            EulerTour(tour, root.right);\\n            if (root.right != null) {\\n                tour.add(root);\\n            }\\n        }\\n        /**\\n         * output levels (distance from root) in Euler tour order\\n         * @return\\n         */\\n        public static int[] getLevels(TreeNode root, TreeNode[] euler) {\\n            if (root == null || euler == null || euler.length == 0) {\\n                throw new IllegalArgumentException();\\n            }\\n            Map<TreeNode, Integer> node2levels = TreeNodeUtils.getLevels(root);\\n            int[] levels = new int[euler.length];\\n            for (int i = 0; i < euler.length; i++) {\\n                levels[i] = node2levels.get(euler[i]);            \\n            }\\n            return levels;\\n        }\\n        /**\\n         * output levels in a Map with key as nodes\\n         * and values as levels. Use BFS (level-order\\n         * traversal) to find all levels.\\n         */\\n        public static Map<TreeNode, Integer> getLevels(TreeNode root) {\\n            Queue<TreeNode> toVisit = new LinkedList<TreeNode>();\\n            Map<TreeNode, Integer> node2level = new HashMap<TreeNode, Integer>();\\n            int currentLevel = 0;\\n            toVisit.offer(root);\\n            while(!toVisit.isEmpty()) {\\n                int currentLevelSize = toVisit.size();\\n                for (int i = 0; i < currentLevelSize; i++) {\\n                    TreeNode current = toVisit.poll();\\n                    if(current.left != null) {\\n                        toVisit.add(current.left);\\n                    }\\n                    if (current.right != null) {\\n                        toVisit.add(current.right);\\n                    }\\n                    node2level.put(current, currentLevel);\\n                }\\n                currentLevel++;\\n            }\\n            return node2level;\\n        }\\n    }\\n\\n    public interface LCA {\\n        public TreeNode query(TreeNode p, TreeNode q);\\n    }\\n    public class LinearLCA implements LCA {\\n        private TreeNode[] euler;\\n        private Map<TreeNode, Integer> node2representatives;\\n        private int[] levels;\\n        private RMQ rmq;\\n\\n        /**\\n         * initialize Euler tour, representatives, levels\\n         * and RMQ object\\n         * @param root\\n         */\\n        public LinearLCA(TreeNode root) {\\n            euler = TreeNodeUtils.EulerTour(root);\\n            node2representatives = getRepresentatives(euler);      \\n            levels = TreeNodeUtils.getLevels(root, euler);\\n            this.rmq = new SparseTableRMQ(this.levels);\\n        }\\n        private Map<TreeNode, Integer> getRepresentatives(TreeNode[] euler) {\\n            Map<TreeNode, Integer> representatives = new HashMap<TreeNode, Integer>();\\n            for (int i = 0; i < euler.length; i++) {\\n                if (!representatives.containsKey(euler[i])) {\\n                    representatives.put(euler[i], i);\\n                }\\n            }\\n            return representatives;\\n        }\\n        public TreeNode query(TreeNode u, TreeNode v) {\\n            if (!node2representatives.containsKey(u) || !node2representatives.containsKey(v)) {\\n                throw new IllegalArgumentException();\\n            }\\n            int firstU = node2representatives.get(u);\\n            int firstV = node2representatives.get(v);\\n            return euler[rmq.min(Math.min(firstU, firstV), Math.max(firstU,firstV))];        \\n        }\\n    }\\n\\n    /*\\n     * interface for range minimum query problem\\n     * \\n     */\\n    public interface RMQ {\\n        public int min(int i, int j);\\n    }\\n\\n    public class SparseTableRMQ implements RMQ{\\n        private int[][] st;\\n        private int[] pow;\\n        private int[] a;\\n        private int N;\\n        public SparseTableRMQ(int[] a) {\\n            this.a = a;\\n            N = a.length;\\n            if (N <= 1) {\\n                return;\\n            }\\n            //we get floor of lgN because\\n            //2*2^lgN is enough for query from 0 to N-1\\n            int lgN = (int) (Math.log(N)/Math.log(2));\\n            //pre-calculate powers of 2 to save time\\n            pow = pow2(lgN);\\n            st = new int[N][lgN + 1];\\n            //initialize first column\\n            for (int i = 0; i < N; i++) {\\n                st[i][0] = i;\\n            }\\n            for (int j = 1; j <= lgN; j++) {\\n                for (int i = 0; i < N; i++) {\\n                    //not all rows have lgN columns\\n                    //note that i is inclusive\\n                    if (i + pow[j] - 1 >= N) {\\n                        continue;\\n                    }\\n                    int leftMin = st[i][j-1];\\n                    int rightMin = st[i + pow[j-1]][j - 1];\\n                    //when there are ties, return smallest index\\n                    st[i][j] = a[leftMin] <= a[rightMin] ? leftMin : rightMin;\\n                }\\n            }\\n        }\\n        private int[] pow2(int n) {\\n            int[] pow = new int[n + 1];\\n            pow[0] = 1;\\n            for (int i = 1; i <= n; i++) {\\n                pow[i] = pow[i - 1] * 2;\\n            }\\n            return pow;\\n        }\\n        public int min(int i, int j) {\\n            if (i > j || i < 0 || j >= N) {\\n                throw new IllegalArgumentException();\\n            }\\n            if (N == 0) {\\n                return -1;\\n            }\\n            if (i == j || N == 1) {\\n                return i;\\n            }\\n            //find the step where 2*2^step >= j - i + 1\\n            int stepSize = (int) (Math.log(j - i + 1)/Math.log(2));\\n            if (pow[stepSize] == (j - i + 1)) {\\n                stepSize--;\\n            }\\n            /*\\n             * i------------------j\\n             * i--------i+step-1\\n             *     j-step+1-------j\\n             */\\n            int leftMin = st[i][stepSize];\\n            int rightMin = st[j - pow[stepSize] + 1][stepSize];\\n\\n            return a[leftMin] <= a[rightMin] ? leftMin : rightMin;\\n        }\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65324,
                "title": "morris-traversal-solving-it-using-o-1-extra-space-o-n-time",
                "content": "The algorithm used Morris traversal, and the reduction from LCA to RMQ. For the reduction, see  [Reduction from LCA to RMQ](https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#Reduction%20from%20LCA%20to%20RMQ) (Topcoder's tutorial for RMQ and LCA)\\n\\nThe actual running time is longer than most recursive solutions. I posted it as it uses O(1) extra space. So some people might be interested in it.\\nThe idea is not hard to understand if you understand Morris traversal. Here, the traversal is the in-order traversal of binary tree. Wish it helpful.\\n```\\n\\n\\n\\tprivate TreeNode w;\\n\\tprivate boolean gathering;\\n\\tprivate int minLevel;\\n\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\tw = null;\\n\\t\\tgathering = false;\\n\\t\\tminLevel = -1;\\n\\n\\t\\tTreeNode u = root;\\n\\t\\tint level = 0;\\n\\n\\t\\twhile (u != null) {\\n\\t\\t\\tif (u.left == null) {\\n\\t\\t\\t\\tif (visit(u, level, p, q))\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint delta = 1;\\n\\t\\t\\t\\tTreeNode v = u.left;\\n\\n\\t\\t\\t\\twhile (v.right != null && v.right != u) {\\n\\t\\t\\t\\t\\tv = v.right;\\n\\t\\t\\t\\t\\tdelta++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (v.right == null) {\\n\\t\\t\\t\\t\\tv.right = u;\\n\\t\\t\\t\\t\\tu = u.left;\\n\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tv.right = null;\\n\\t\\t\\t\\t\\tlevel -= delta + 1;\\n\\t\\t\\t\\t\\tif (visit(u, level, p, q))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn w;\\n\\t}\\n\\n\\tprivate void restoreTree(TreeNode u) {\\n\\t\\tu = u.right;\\n\\t\\twhile (u != null) {\\n\\t\\t\\tif (u.left == null)\\n\\t\\t\\t\\tu = u.right;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tTreeNode v = u.left;\\n\\t\\t\\t\\twhile (v.right != null && v.right != u)\\n\\t\\t\\t\\t\\tv = v.right;\\n\\t\\t\\t\\tif (v.right == u)\\n\\t\\t\\t\\t\\tv.right = null;\\n\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate boolean visit(TreeNode u, int level, TreeNode p, TreeNode q) {\\n\\t\\tif (u == p || u == q) {\\n\\t\\t\\tif (!gathering) {\\n\\t\\t\\t\\tgathering = true;\\n\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (level < minLevel) {\\n\\t\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trestoreTree(u);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (gathering) {\\n\\t\\t\\t\\tif (level < minLevel) {\\n\\t\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\n\\tprivate TreeNode w;\\n\\tprivate boolean gathering;\\n\\tprivate int minLevel;\\n\\n\\tpublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\t\\tw = null;\\n\\t\\tgathering = false;\\n\\t\\tminLevel = -1;\\n\\n\\t\\tTreeNode u = root;\\n\\t\\tint level = 0;\\n\\n\\t\\twhile (u != null) {\\n\\t\\t\\tif (u.left == null) {\\n\\t\\t\\t\\tif (visit(u, level, p, q))\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint delta = 1;\\n\\t\\t\\t\\tTreeNode v = u.left;\\n\\n\\t\\t\\t\\twhile (v.right != null && v.right != u) {\\n\\t\\t\\t\\t\\tv = v.right;\\n\\t\\t\\t\\t\\tdelta++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (v.right == null) {\\n\\t\\t\\t\\t\\tv.right = u;\\n\\t\\t\\t\\t\\tu = u.left;\\n\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tv.right = null;\\n\\t\\t\\t\\t\\tlevel -= delta + 1;\\n\\t\\t\\t\\t\\tif (visit(u, level, p, q))\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t\\t\\t\\tlevel++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn w;\\n\\t}\\n\\n\\tprivate void restoreTree(TreeNode u) {\\n\\t\\tu = u.right;\\n\\t\\twhile (u != null) {\\n\\t\\t\\tif (u.left == null)\\n\\t\\t\\t\\tu = u.right;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tTreeNode v = u.left;\\n\\t\\t\\t\\twhile (v.right != null && v.right != u)\\n\\t\\t\\t\\t\\tv = v.right;\\n\\t\\t\\t\\tif (v.right == u)\\n\\t\\t\\t\\t\\tv.right = null;\\n\\t\\t\\t\\tu = u.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tprivate boolean visit(TreeNode u, int level, TreeNode p, TreeNode q) {\\n\\t\\tif (u == p || u == q) {\\n\\t\\t\\tif (!gathering) {\\n\\t\\t\\t\\tgathering = true;\\n\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (level < minLevel) {\\n\\t\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\trestoreTree(u);\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tif (gathering) {\\n\\t\\t\\t\\tif (level < minLevel) {\\n\\t\\t\\t\\t\\tw = u;\\n\\t\\t\\t\\t\\tminLevel = level;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65339,
                "title": "java-dfs-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == null) return null;\\n            List<TreeNode> pathTop = new ArrayList<>();\\n            List<TreeNode> pathToq = new ArrayList<>();\\n            if (!pathToNode(pathTop, root, p) || !pathToNode(pathToq,root,q)) return null;\\n            int min = Math.min(pathTop.size(), pathToq.size());\\n            int pointer = min;\\n            for (int i = 0; i < min; i++) {\\n                if (pathTop.get(i).val != pathToq.get(i).val) {\\n                    pointer = i;\\n                    break;\\n                }\\n            }\\n            return pathTop.get(pointer - 1);  \\n        }\\n        \\n        public boolean pathToNode(List<TreeNode> path, TreeNode root, TreeNode n) {\\n            if (root == null) return false;\\n            path.add(root);\\n            if (root == n) {// use root == n instead of root.val == n.val\\n                return true;\\n            }\\n            if (pathToNode(path, root.left, n)) return true;\\n            if (pathToNode(path, root.right, n)) return true;\\n            path.remove(path.size() - 1);\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == null) return null;\\n            List<TreeNode> pathTop = new ArrayList<>();\\n            List<TreeNode> pathToq = new ArrayList<>();\\n            if (!pathToNode(pathTop, root, p) || !pathToNode(pathToq,root,q)) return null;\\n            int min = Math.min(pathTop.size(), pathToq.size());\\n            int pointer = min;\\n            for (int i = 0; i < min; i++) {\\n                if (pathTop.get(i).val != pathToq.get(i).val) {\\n                    pointer = i;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 65354,
                "title": "short-easy-to-understand-java-solution",
                "content": "    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == p || root == q || root == null) return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if (left != null && right != null) return root;\\n            return left != null ? left : right;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            if (root == p || root == q || root == null) return root;\\n            TreeNode left = lowestCommonAncestor(root.left, p, q);\\n            TreeNode right = lowestCommonAncestor(root.right, p, q);\\n            if (left != null && right != null) return root;\\n            return left != null ? left : right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3649506,
                "title": "c-easy-path-method",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool f(TreeNode* root,vector<TreeNode*>&v,TreeNode*x){\\n        if(!root)return false;\\n        v.push_back(root);\\n        if(root==x)return true;\\n        if(f(root->left,v,x) || f(root->right,v,x)){\\n            return true;\\n        }\\n        v.pop_back();\\n        return false;\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)return NULL;\\n        vector<TreeNode*>p1,p2;\\n        f(root,p1,p);\\n        f(root,p2,q);\\n        for(int i=0;i<min(p1.size(),p2.size());i++){\\n            cout<<p2[i]->val<<\" \";\\n            if(p1[i]!=p2[i]){\\n                return p1[i-1];\\n            }\\n        }\\n        int x= min(p1.size(),p2.size());\\n        return p1[x-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/70d58217-d9f4-4a05-b73f-c1ef51096ff1_1687025655.7606018.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool f(TreeNode* root,vector<TreeNode*>&v,TreeNode*x){\\n        if(!root)return false;\\n        v.push_back(root);\\n        if(root==x)return true;\\n        if(f(root->left,v,x) || f(root->right,v,x)){\\n            return true;\\n        }\\n        v.pop_back();\\n        return false;\\n    }\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)return NULL;\\n        vector<TreeNode*>p1,p2;\\n        f(root,p1,p);\\n        f(root,p2,q);\\n        for(int i=0;i<min(p1.size(),p2.size());i++){\\n            cout<<p2[i]->val<<\" \";\\n            if(p1[i]!=p2[i]){\\n                return p1[i-1];\\n            }\\n        }\\n        int x= min(p1.size(),p2.size());\\n        return p1[x-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3523892,
                "title": "python-easy-o-n-recursive-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root==None or root==p or root==q:\\n            return root\\n        left=self.lowestCommonAncestor(root.left,p,q)\\n        right=self.lowestCommonAncestor(root.right,p,q)\\n        if left==None:\\n            return right\\n        elif right==None:\\n            return left\\n        else:\\n            return root\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root==None or root==p or root==q:\\n            return root\\n        left=self.lowestCommonAncestor(root.left,p,q)\\n        right=self.lowestCommonAncestor(root.right,p,q)\\n        if left==None:\\n            return right\\n        elif right==None:\\n            return left\\n        else:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131553,
                "title": "c-easy-to-understand-easy-to-code-binary-tree-tree",
                "content": "# Please upvote if you like this solution, it meant a lot to me.\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is the number of nodes.\\n\\n- Space complexity:\\nO(N) where N is the auxillary space.\\n\\n# Code\\n```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)\\n{\\n    if (root == NULL || root == p || root == q)\\n        return root;\\n\\n    TreeNode *left = lowestCommonAncestor(root->left, p, q);\\n    TreeNode *right = lowestCommonAncestor(root->right, p, q);\\n\\n    if (left == NULL)\\n        return right;\\n\\n    if (right == NULL)\\n        return left;\\n\\n    else\\n        return root;\\n}\\n```\\n### Let\\'s connect on :-\\n### https://www.linkedin.com/in/mann-chandarana-115255230/\\n\\n\\n![Upvote.png](https://assets.leetcode.com/users/images/5c72057e-5aa8-4b49-aea3-26bdd3475b63_1675341668.6139731.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Suffix Array",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q)\\n{\\n    if (root == NULL || root == p || root == q)\\n        return root;\\n\\n    TreeNode *left = lowestCommonAncestor(root->left, p, q);\\n    TreeNode *right = lowestCommonAncestor(root->right, p, q);\\n\\n    if (left == NULL)\\n        return right;\\n\\n    if (right == NULL)\\n        return left;\\n\\n    else\\n        return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2962578,
                "title": "recursive-iterative-approach-explained-in-detailed-easy-to-understand-c",
                "content": "\\n# Recursive Approach\\nUsing single Traversal \\n \\n# Complexity\\n- Time complexity:\\n  $$O(n)$$ \\n\\n- Space complexity:\\n  $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL ; \\n        //if i get p i will return it \\n        if(root==p) return p ;\\n        //if i get q i will return it \\n        if(root==q) return q ;\\n \\n      //make left call \\n      TreeNode*leftcall = lowestCommonAncestor(root->left,p,q) ; \\n      //make right call \\n     TreeNode*rightcall = lowestCommonAncestor(root->right,p,q) ;\\n\\n         //if at a node both leftcall and rightcall returned NULL--> return NULL\\n         if(leftcall==NULL and rightcall==NULL)  return NULL ; \\n\\n\\n         //if at a node leftcall returns found node and rightcall returned NULL--> return leftcall\\n         if(leftcall!=NULL and rightcall==NULL)  return leftcall ; \\n\\n      //if at a node leftcall returned NULL and rightcall returned found node--> return rightcall\\n         if(leftcall==NULL and rightcall!=NULL)  return rightcall ; \\n\\n      //if at a node both leftcall and rightcall returned found node--> return current node\\n         if(leftcall!=NULL and rightcall!=NULL)  return root ;\\n\\n      return root;\\n    }\\n};\\n```\\n\\n# Iterative  Approach\\nUsing Double Traversal and finding path for node p and q respectively than comparing there path to find LCA.\\n \\n# Complexity\\n- Time complexity:\\n  $$O(n) + O(n) $$ \\n\\n- Space complexity:\\n  $$O(n) + O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//find path of both p and q \\nbool findPath(TreeNode*root , vector<int>&path,TreeNode*toSearch){\\n\\n    if(root==NULL){\\n        return 0;\\n    }\\n   \\n   //Always store current node when moving from one path to other later we will remove if coming back with false \\n    path.push_back(root->val);\\n   \\n   //if found\\n     if(root->val == toSearch->val){\\n         return true;\\n     }\\n\\n    //see if toSearch for is found in any path return true\\n   bool leftSearch =  findPath(root->left,path,toSearch);\\n   bool rightSearch =  findPath(root->right,path,toSearch);\\n\\n   if(leftSearch==true || rightSearch==true){\\n         return true;\\n     }\\n\\n    //return false and remove last added node \\n    path.pop_back();\\n    return false;\\n}\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL){\\n            return NULL;\\n        }\\n          TreeNode*node = root;\\n        vector<int>pathforp , pathforq ; \\n\\n        bool resultLeft = findPath(root,pathforp,p);\\n        bool resultRight =findPath(root,pathforq,q);\\n        \\n      //  for(auto it : pathforp) cout<<it<<\" \";\\n      //  cout<<\"\\\\n\";\\n       // for(auto itr : pathforq) cout<<itr<<\" \";\\n      // cout<<\"\\\\n\";\\n\\n        //if any p or q not found \\n        if(resultLeft == false || resultRight==false) {\\n            return NULL;\\n        }\\n   \\n        //else path is present  \\n        bool check = 0;\\n        for(int i=0; i<pathforp.size() and i<pathforq.size() ; i++){\\n              if(pathforp[i]!=pathforq[i]){\\n                  //i.e just previous value is answer \\n                  node->val = pathforp[i-1];\\n                  check=1;\\n                    break;\\n                     }\\n        }\\n       if(!check){\\n           int mini = min(pathforp.size() , pathforq.size()) ;\\n         node->val = pathforp[mini-1]; //i.e both p and q were equal so return last value of smaller path as check=0\\n         /* [1,2] , p=2 , q=1\\n        pathforp ->  1 2 \\n        pathforq ->  1\\n        ans = 1\\n         */\\n       }  \\n        return node; //we can also return root\\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL ; \\n        //if i get p i will return it \\n        if(root==p) return p ;\\n        //if i get q i will return it \\n        if(root==q) return q ;\\n \\n      //make left call \\n      TreeNode*leftcall = lowestCommonAncestor(root->left,p,q) ; \\n      //make right call \\n     TreeNode*rightcall = lowestCommonAncestor(root->right,p,q) ;\\n\\n         //if at a node both leftcall and rightcall returned NULL--> return NULL\\n         if(leftcall==NULL and rightcall==NULL)  return NULL ; \\n\\n\\n         //if at a node leftcall returns found node and rightcall returned NULL--> return leftcall\\n         if(leftcall!=NULL and rightcall==NULL)  return leftcall ; \\n\\n      //if at a node leftcall returned NULL and rightcall returned found node--> return rightcall\\n         if(leftcall==NULL and rightcall!=NULL)  return rightcall ; \\n\\n      //if at a node both leftcall and rightcall returned found node--> return current node\\n         if(leftcall!=NULL and rightcall!=NULL)  return root ;\\n\\n      return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//find path of both p and q \\nbool findPath(TreeNode*root , vector<int>&path,TreeNode*toSearch){\\n\\n    if(root==NULL){\\n        return 0;\\n    }\\n   \\n   //Always store current node when moving from one path to other later we will remove if coming back with false \\n    path.push_back(root->val);\\n   \\n   //if found\\n     if(root->val == toSearch->val){\\n         return true;\\n     }\\n\\n    //see if toSearch for is found in any path return true\\n   bool leftSearch =  findPath(root->left,path,toSearch);\\n   bool rightSearch =  findPath(root->right,path,toSearch);\\n\\n   if(leftSearch==true || rightSearch==true){\\n         return true;\\n     }\\n\\n    //return false and remove last added node \\n    path.pop_back();\\n    return false;\\n}\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL){\\n            return NULL;\\n        }\\n          TreeNode*node = root;\\n        vector<int>pathforp , pathforq ; \\n\\n        bool resultLeft = findPath(root,pathforp,p);\\n        bool resultRight =findPath(root,pathforq,q);\\n        \\n      //  for(auto it : pathforp) cout<<it<<\" \";\\n      //  cout<<\"\\\\n\";\\n       // for(auto itr : pathforq) cout<<itr<<\" \";\\n      // cout<<\"\\\\n\";\\n\\n        //if any p or q not found \\n        if(resultLeft == false || resultRight==false) {\\n            return NULL;\\n        }\\n   \\n        //else path is present  \\n        bool check = 0;\\n        for(int i=0; i<pathforp.size() and i<pathforq.size() ; i++){\\n              if(pathforp[i]!=pathforq[i]){\\n                  //i.e just previous value is answer \\n                  node->val = pathforp[i-1];\\n                  check=1;\\n                    break;\\n                     }\\n        }\\n       if(!check){\\n           int mini = min(pathforp.size() , pathforq.size()) ;\\n         node->val = pathforp[mini-1]; //i.e both p and q were equal so return last value of smaller path as check=0\\n         /* [1,2] , p=2 , q=1\\n        pathforp ->  1 2 \\n        pathforq ->  1\\n        ans = 1\\n         */\\n       }  \\n        return node; //we can also return root\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2539410,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root==None or root.val==p.val or root.val==q.val:\\n            return root\\n        left=self.lowestCommonAncestor(root.left,p,q)\\n        right=self.lowestCommonAncestor(root.right,p,q)\\n        if left!=None and right!=None:\\n            return root\\n        elif left!=None:\\n            return left\\n        else:\\n            return right",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root==None or root.val==p.val or root.val==q.val:\\n            return root\\n        left=self.lowestCommonAncestor(root.left,p,q)\\n        right=self.lowestCommonAncestor(root.right,p,q)\\n        if left!=None and right!=None:\\n            return root\\n        elif left!=None:\\n            return left\\n        else:\\n            return right",
                "codeTag": "Java"
            },
            {
                "id": 2335189,
                "title": "java-best-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n      if(root == null || p == root || q == root)        //base case\\n        return root;\\n      \\n      TreeNode right = lowestCommonAncestor(root.right , p , q);\\n      TreeNode left = lowestCommonAncestor(root.left , p , q); \\n      \\n      if(right == null) return left;                   //results\\n      if(left == null) return right;\\n      \\n      else return root;                                //both left and right are not null, we found our result\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n      if(root == null || p == root || q == root)        //base case\\n        return root;\\n      \\n      TreeNode right = lowestCommonAncestor(root.right , p , q);\\n      TreeNode left = lowestCommonAncestor(root.left , p , q); \\n      \\n      if(right == null) return left;                   //results\\n      if(left == null) return right;\\n      \\n      else return root;                                //both left and right are not null, we found our result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334049,
                "title": "daily-leetcoding-challenge-july-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative using parent pointers\n\n  \n**Approach 3:** Iterative without parent pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2153818,
                "title": "recursive-o-n-time-if-values-are-given-instead-of-nodes",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\tbool foundone= false,foundtwo = false;\\n\\n\\t// function returns the element found on subtree, if both elements are found returns lca\\n\\tTreeNode* findelement(TreeNode* root,int a,int b){\\n\\t\\tif(!root) return NULL;\\n\\n\\t\\t// flags for checking whether both values are found \\n\\t\\tif(root->val == a) foundone = true;\\n\\t\\tif(root->val == b) foundtwo = true;\\n\\n\\t\\tTreeNode* left = findelement(root->left,a,b);\\n\\t\\tTreeNode* right = findelement(root->right,a,b);\\n\\n\\t\\tif(left && right) return root;\\n\\t\\t// return the node which has a desired value\\n\\t\\tif(!left && right || !right && left){\\n\\t\\t\\tif(root->val == a || root->val==b)\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\tif(right)\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\tif(left)\\n\\t\\t\\t\\treturn left;\\n\\t\\t}\\n\\n\\t\\tif(root->val == a || root->val==b)\\n\\t\\t\\t\\treturn root;\\n\\n\\t\\treturn NULL;\\n\\n\\n\\t}\\n\\n\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\tfoundone= false;\\n\\t\\t   foundtwo = false;\\n\\t\\t   TreeNode *anc = findelement(root,p->val,q->val);\\n\\t\\t   // anc contains node which is found in subtree , \\n\\t\\t   // if one of these doesn\\'t exist, it\\'ll return the element which is found in tree\\n\\t\\t   if(foundone && foundtwo)\\n\\t\\t\\treturn anc;\\n\\n\\t\\t   return NULL;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\tbool foundone= false,foundtwo = false;\\n\\n\\t// function returns the element found on subtree, if both elements are found returns lca\\n\\tTreeNode* findelement(TreeNode* root,int a,int b){\\n\\t\\tif(!root) return NULL;\\n\\n\\t\\t// flags for checking whether both values are found \\n\\t\\tif(root->val == a) foundone = true;\\n\\t\\tif(root->val == b) foundtwo = true;\\n\\n\\t\\tTreeNode* left = findelement(root->left,a,b);\\n\\t\\tTreeNode* right = findelement(root->right,a,b);\\n\\n\\t\\tif(left && right) return root;\\n\\t\\t// return the node which has a desired value\\n\\t\\tif(!left && right || !right && left){\\n\\t\\t\\tif(root->val == a || root->val==b)\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\tif(right)\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\tif(left)\\n\\t\\t\\t\\treturn left;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 937741,
                "title": "c-7-lines-of-code-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if(!root || root==p || root==q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\\n        if(left && right)\\n            return root;\\n        return left ? left : right;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) \\n    {\\n        if(!root || root==p || root==q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right = lowestCommonAncestor(root->right,p,q);\\n        if(left && right)\\n            return root;\\n        return left ? left : right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862349,
                "title": "easy-to-understand",
                "content": "```\\n\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tif root == nil || root == p || root == q {\\n\\t\\treturn root\\n\\t}\\n\\n\\tleft := lowestCommonAncestor(root.Left, p, q)\\n\\tright := lowestCommonAncestor(root.Right, p, q)\\n\\tif left != nil && right != nil {\\n\\t\\treturn root\\n\\t}\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n\\treturn right\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n\\tif root == nil || root == p || root == q {\\n\\t\\treturn root\\n\\t}\\n\\n\\tleft := lowestCommonAncestor(root.Left, p, q)\\n\\tright := lowestCommonAncestor(root.Right, p, q)\\n\\tif left != nil && right != nil {\\n\\t\\treturn root\\n\\t}\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n\\treturn right\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 613657,
                "title": "4-lines-in-javascript-recursive-solution",
                "content": "4 lines in javaScript\\n\\n```js\\nvar lowestCommonAncestor = function(root, p, q) {\\n  if(!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  return left && right ? root : left || right;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar lowestCommonAncestor = function(root, p, q) {\\n  if(!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  return left && right ? root : left || right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229545,
                "title": "concise-and-easy-to-understand-divide-and-conquer-solution-in-java-javascript",
                "content": "Java:\\n```java\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // in case root is null (empty tree) return null\\n        if (root == null) return null;\\n        // in case current root is either p or q, just return it\\n        if (root == p || root == q) return root;\\n\\n        // divide\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        // in case both left and right are not null, meaning that\\n        // 1) p exists in the left subtree and q exists in the right subtree\\n        // 2) q exists in the left subtree and p exists in the left subtree\\n        // then current root is the LCA in both cases\\n        if (left != null && right != null) return root;\\n\\n        // else if only one of left or right is not null\\n        // which mean that we only find one of p and q in one subtree\\n        // in that case we are returning it\\n        if (left != null) return left;\\n        if (right != null) return right;\\n\\n        // if left and right are both null, meaning that p, q cannot be found\\n        // in the current subtree, then we should return null to indicate that\\n        return null;\\n    }\\n}\\n```\\n\\nJavaScript:\\n```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    // deal with the base case, where current node is null\\n    if (!root) return null;\\n    // in case current node is either p or q, just return it\\n    if (root === p || root === q) return root;\\n\\n    // DIVIDE\\n    const left = lowestCommonAncestor(root.left, p, q);\\n    const right = lowestCommonAncestor(root.right, p, q);\\n\\n    // in case that both left and right are not null, which mean that p and q\\n    // are located in both left and right subtree, so current node will be the\\n    // LCA\\n    if (left && right) return root;\\n\\n    // else if in case that one of the p and q exists in one of the subtree,\\n    // then we still return it\\n    if (left) return left;\\n    if (right) return right;\\n\\n    // in case none of p and q exists, return null\\n    return null;\\n};\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        // in case root is null (empty tree) return null\\n        if (root == null) return null;\\n        // in case current root is either p or q, just return it\\n        if (root == p || root == q) return root;\\n\\n        // divide\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        // in case both left and right are not null, meaning that\\n        // 1) p exists in the left subtree and q exists in the right subtree\\n        // 2) q exists in the left subtree and p exists in the left subtree\\n        // then current root is the LCA in both cases\\n        if (left != null && right != null) return root;\\n\\n        // else if only one of left or right is not null\\n        // which mean that we only find one of p and q in one subtree\\n        // in that case we are returning it\\n        if (left != null) return left;\\n        if (right != null) return right;\\n\\n        // if left and right are both null, meaning that p, q cannot be found\\n        // in the current subtree, then we should return null to indicate that\\n        return null;\\n    }\\n}\\n```\n```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    // deal with the base case, where current node is null\\n    if (!root) return null;\\n    // in case current node is either p or q, just return it\\n    if (root === p || root === q) return root;\\n\\n    // DIVIDE\\n    const left = lowestCommonAncestor(root.left, p, q);\\n    const right = lowestCommonAncestor(root.right, p, q);\\n\\n    // in case that both left and right are not null, which mean that p and q\\n    // are located in both left and right subtree, so current node will be the\\n    // LCA\\n    if (left && right) return root;\\n\\n    // else if in case that one of the p and q exists in one of the subtree,\\n    // then we still return it\\n    if (left) return left;\\n    if (right) return right;\\n\\n    // in case none of p and q exists, return null\\n    return null;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65306,
                "title": "java-solution-17ms",
                "content": "I am using the same function call to check if the subtree contains one of the nodes and to return the result.\\n\\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {\\n\\n\\t\\tif (root == null || root == node1 || root == node2)\\n\\t\\t\\treturn root;\\n\\n\\t\\tTreeNode leftSearch = lowestCommonAncestor(root.left, node1, node2);\\n\\t\\tTreeNode rightSearch = lowestCommonAncestor(root.right, node1, node2);\\n\\n\\t\\tif (leftSearch != null && rightSearch != null) {\\n\\t\\t\\treturn root;\\n\\t\\t} else if (leftSearch != null && rightSearch == null) {\\n\\t\\t\\treturn leftSearch;\\n\\t\\t} else if (leftSearch == null && rightSearch != null) {\\n\\t\\t\\treturn rightSearch;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "I am using the same function call to check if the subtree contains one of the nodes and to return the result.\\n\\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode node1, TreeNode node2) {\\n\\n\\t\\tif (root == null || root == node1 || root == node2)\\n\\t\\t\\treturn root;\\n\\n\\t\\tTreeNode leftSearch = lowestCommonAncestor(root.left, node1, node2);\\n\\t\\tTreeNode rightSearch = lowestCommonAncestor(root.right, node1, node2);\\n\\n\\t\\tif (leftSearch != null && rightSearch != null) {\\n\\t\\t\\treturn root;\\n\\t\\t} else if (leftSearch != null && rightSearch == null) {\\n\\t\\t\\treturn leftSearch;\\n\\t\\t} else if (leftSearch == null && rightSearch != null) {\\n\\t\\t\\treturn rightSearch;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 65355,
                "title": "rainbowsecret-c-solution",
                "content": "Refering the post from G4G, we can know that we can construct path from root to p and q seperately.\\n\\nAnd compare the path TreeNode one by one.\\n\\nAlso, a better solution is to find the p and q , return the parent node of the p and q recusively.\\n\\nSo , in the final, we check whether they appear in the same tree or different tree.\\n\\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root || root==p || root==q)  return root;\\n            TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n            TreeNode* right=lowestCommonAncestor(root->right, p, q);\\n            \\n            /** find the LCA lowest parent **/\\n            if(left && right)  return root;\\n            /** this ensures that the LCA is the lowest **/\\n            /** as we just pass the LCA result back-track **/\\n            if(!left)  return right;\\n            if(!right)  return left;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            if(!root || root==p || root==q)  return root;\\n            TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n            TreeNode* right=lowestCommonAncestor(root->right, p, q);\\n            \\n            /** find the LCA lowest parent **/\\n            if(left && right)  return root;\\n            /** this ensures that the LCA is the lowest **/\\n            /** as we just pass the LCA result back-track **/\\n            if(!left)  return right;\\n            if(!right)  return left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65388,
                "title": "clean-java-ac-solution-13ms-with-explanation",
                "content": "    if(root == null)\\n\\t\\t\\treturn null ;\\n\\t\\tTreeNode left = lowestCommonAncestor(root.left, p, q);\\n\\t\\tTreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\t\\t\\t\\n\\t\\tif(root == p || root == q)\\n\\t\\t\\treturn root;\\n\\t\\t\\n\\t\\tif(left != null && right == null)\\n\\t\\t\\treturn left;\\n\\t\\telse if(left == null && right != null)\\n\\t\\t\\treturn right;\\n\\t\\telse if(left == null && right == null)\\n\\t\\t\\treturn null;\\n\\t\\telse\\n\\t\\t\\treturn root;\\n\\n\\nUse Post Order Traversal to loop through the tree. Find the left and right child contains tree node p and q and return current node as result.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    if(root == null)\\n\\t\\t\\treturn null ;\\n\\t\\tTreeNode left = lowestCommonAncestor(root.left, p, q);\\n\\t\\tTreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\t\\t\\t\\n\\t\\tif(root == p || root == q)\\n\\t\\t\\treturn root;\\n\\t\\t\\n\\t\\tif(left != null && right == null)\\n\\t\\t\\treturn left;\\n\\t\\telse if(left == null && right != null)\\n\\t\\t\\treturn right;\\n\\t\\telse if(left == null && right == null)\\n\\t\\t\\treturn null;\\n\\t\\telse\\n\\t\\t\\treturn root;\\n\\n\\nUse Post Order Traversal to loop through the tree. Find the left and right child contains tree node p and q and return current node as result.",
                "codeTag": "Unknown"
            },
            {
                "id": 65394,
                "title": "my-python-solution-116ms",
                "content": "    class Solution(object):\\n        def lowestCommonAncestor(self, root, p, q):\\n            if root is None:\\n                return root\\n        \\n            if root == p or root == q:\\n                return root\\n        \\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n            if left is not None and right is not None:\\n                return root\\n            elif left is not None:\\n                return left\\n            elif right is not None:\\n                return right",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def lowestCommonAncestor(self, root, p, q):\\n            if root is None:\\n                return root\\n        \\n            if root == p or root == q:\\n                return root\\n        \\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n            if left is not None and right is not None:\\n                return root\\n            elif left is not None:\\n                return left\\n            elif right is not None:\\n                return right",
                "codeTag": "Java"
            },
            {
                "id": 65353,
                "title": "dfs-java-solution",
                "content": "First find treepath for p. Next find treepath for q.  Finally compare tree pathes for common ancestor.\\n\\n    public class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            List<TreeNode> pAns = new ArrayList<TreeNode>();\\n            List<TreeNode> qAns = new ArrayList<TreeNode>();\\n            findAncestors(p, root, pAns);\\n            findAncestors(q, root, qAns);\\n    \\n            TreeNode anc = root;\\n            int i = 1;\\n            while (i<pAns.size() && i<qAns.size()){\\n                if (pAns.get(i) == qAns.get(i)){\\n                    anc = pAns.get(i);\\n                }\\n                else{\\n                    break;\\n                }\\n                i++;\\n            }\\n            return anc;\\n        }\\n        \\n        private boolean findAncestors(TreeNode toFind, TreeNode parent, List<TreeNode> ans){\\n            if (parent == null){\\n                return false;\\n            }\\n            if (toFind == parent){\\n                ans.add(parent);\\n                return true;\\n            }\\n            ans.add(parent);\\n            if (findAncestors(toFind,parent.left,ans)){\\n                return true;\\n            }\\n            if (findAncestors(toFind,parent.right,ans)){\\n                return true;\\n            }\\n            ans.remove(ans.size()-1);\\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n            List<TreeNode> pAns = new ArrayList<TreeNode>();\\n            List<TreeNode> qAns = new ArrayList<TreeNode>();\\n            findAncestors(p, root, pAns);\\n            findAncestors(q, root, qAns);\\n    \\n            TreeNode anc = root;\\n            int i = 1;\\n            while (i<pAns.size() && i<qAns.size()){\\n                if (pAns.get(i) == qAns.get(i)){\\n                    anc = pAns.get(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3755804,
                "title": "python-3-o-n-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are 3 possible cases:\\n        1. p and q on opposite side of tree\\n        2. p desc of q\\n        3. q desc of p\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce we have found either p or q, search the other side for q or p\\nIf the other side contains p or q, its case 1 since they\\'re on opposite sides of the tree, return root\\nOtherwise return p or q depending on which appears first\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$, where n is number of nodes, since each node at most visited once\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(h)$$, where h is the height of the tree, since in worst case (e.g. completely skewed tree) each node along the height is visited once. Space complexity determined by height of recursion tree which is at most $$O(h)$$ \\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        def traverse(node): \\n            # Node does not exist here\\n            if node == None: \\n                return None\\n             # Return once we find either p or q\\n            if node == p or node == q:\\n                return node\\n            left = traverse(node.left) # LCA of p or q on left side\\n            right = traverse(node.right) # LCA of p or q on right side\\n            # LCA of p and q on opposite sides, return the parent\\n            if left and right: \\n                return node\\n            return left or right # Return whichever is the ancestor\\n        return traverse(root)\\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        def traverse(node): \\n            # Node does not exist here\\n            if node == None: \\n                return None\\n             # Return once we find either p or q\\n            if node == p or node == q:\\n                return node\\n            left = traverse(node.left) # LCA of p or q on left side\\n            right = traverse(node.right) # LCA of p or q on right side\\n            # LCA of p and q on opposite sides, return the parent\\n            if left and right: \\n                return node\\n            return left or right # Return whichever is the ancestor\\n        return traverse(root)\\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580248,
                "title": "c-2-approaches-brute-force-best-approach-easy-to-understand",
                "content": "# Approach\\n2 approaches - Brute Force + Best Approach\\n\\n# Method - 1 : Brute Force\\n\\n## Complexity\\n- Time complexity: $$O(3n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2n + h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\n    public:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return root;\\n\\n        if(root == p || root == q) return root;\\n\\n        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL) return root;\\n        else if(leftAns != NULL && rightAns == NULL) return leftAns;\\n        else if(leftAns == NULL && rightAns != NULL) return rightAns;\\n        else return NULL;\\n    }\\n};\\n```\\n\\n# Method - 2 : Best Approach\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\n    bool getPath(TreeNode* root, TreeNode* x, vector<TreeNode*> &ans) {\\n        if(root == NULL) return false;\\n\\n        ans.push_back(root);\\n\\n        if(root == x) return true;\\n\\n        if(getPath(root->left, x, ans) || getPath(root->right, x, ans)) return true;\\n\\n        ans.pop_back();\\n        return false;\\n    }\\n\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans;\\n        if(root == NULL) return ans;\\n\\n        vector<TreeNode*> path1;\\n        getPath(root, p, path1);\\n        vector<TreeNode*> path2;\\n        getPath(root, q, path2);\\n\\n        int i = 0, j = 0;\\n        while(i < path1.size() && j < path2.size()) {\\n            if(path1[i] == path2[j]) {\\n                ans = path1[i];\\n            }\\n            else {\\n                return ans;\\n            }\\n            i++; j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return root;\\n\\n        if(root == p || root == q) return root;\\n\\n        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL) return root;\\n        else if(leftAns != NULL && rightAns == NULL) return leftAns;\\n        else if(leftAns == NULL && rightAns != NULL) return rightAns;\\n        else return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool getPath(TreeNode* root, TreeNode* x, vector<TreeNode*> &ans) {\\n        if(root == NULL) return false;\\n\\n        ans.push_back(root);\\n\\n        if(root == x) return true;\\n\\n        if(getPath(root->left, x, ans) || getPath(root->right, x, ans)) return true;\\n\\n        ans.pop_back();\\n        return false;\\n    }\\n\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        TreeNode* ans;\\n        if(root == NULL) return ans;\\n\\n        vector<TreeNode*> path1;\\n        getPath(root, p, path1);\\n        vector<TreeNode*> path2;\\n        getPath(root, q, path2);\\n\\n        int i = 0, j = 0;\\n        while(i < path1.size() && j < path2.size()) {\\n            if(path1[i] == path2[j]) {\\n                ans = path1[i];\\n            }\\n            else {\\n                return ans;\\n            }\\n            i++; j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228612,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector <TreeNode* > pathOfP;\\n        vector <TreeNode* > pathOfQ;\\n        getPath(root, p, pathOfP);\\n        getPath(root, q, pathOfQ);\\n        int index = 0;\\n        for (auto v: pathOfP) {\\n            auto it = find(pathOfQ.begin(), pathOfQ.end(), v);\\n            if (it != pathOfQ.end()) \\n                index = it - pathOfQ.begin();\\n        }\\n        return pathOfQ[index];\\n    }    \\nprivate:\\n    bool getPath(TreeNode* root, TreeNode* x, vector <TreeNode* >& path) {\\n        if (root == NULL)\\n            return false;\\n        path.push_back(root);\\n        if (root == x)\\n            return true;\\n        if (getPath(root->left, x, path) || getPath(root->right, x, path))\\n            return true;\\n        path.pop_back();    \\n        return false;\\n    }    \\n};\\n```\\n\\n# Approach 2\\nOptimal\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q); \\n        TreeNode* right = lowestCommonAncestor(root->right, p, q); \\n        if (left == NULL)\\n            return right;\\n        else if (right == NULL)\\n            return left;\\n        else\\n            return root;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector <TreeNode* > pathOfP;\\n        vector <TreeNode* > pathOfQ;\\n        getPath(root, p, pathOfP);\\n        getPath(root, q, pathOfQ);\\n        int index = 0;\\n        for (auto v: pathOfP) {\\n            auto it = find(pathOfQ.begin(), pathOfQ.end(), v);\\n            if (it != pathOfQ.end()) \\n                index = it - pathOfQ.begin();\\n        }\\n        return pathOfQ[index];\\n    }    \\nprivate:\\n    bool getPath(TreeNode* root, TreeNode* x, vector <TreeNode* >& path) {\\n        if (root == NULL)\\n            return false;\\n        path.push_back(root);\\n        if (root == x)\\n            return true;\\n        if (getPath(root->left, x, path) || getPath(root->right, x, path))\\n            return true;\\n        path.pop_back();    \\n        return false;\\n    }    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q); \\n        TreeNode* right = lowestCommonAncestor(root->right, p, q); \\n        if (left == NULL)\\n            return right;\\n        else if (right == NULL)\\n            return left;\\n        else\\n            return root;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059790,
                "title": "java-99-explained-recursive-dfs",
                "content": "# Intuition\\nIf root is null or if root is x or if root is y then return root\\nMade a recursion call for both\\ni) Left subtree \\nii)Right subtree\\n\\nBecause we would find LCA in the left or right subtree only.\\n\\nIf the left subtree recursive call gives a null value that means we haven\\u2019t found LCA in the left subtree, which means we found LCA on the right subtree. So we will return right.\\nIf the right subtree recursive call gives null value, that means we haven\\u2019t found LCA on the right subtree, which means we found LCA on the left subtree. So we will return left .\\n If both left & right calls give values (not null)  that means the root is the LCA.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n          if (root==null || root==p || root==q){\\n            return root;\\n        }\\n\\n        TreeNode left=lowestCommonAncestor(root.left,p,q);\\n        TreeNode right=lowestCommonAncestor(root.right,p,q);\\n        //- Result\\n        if (left==null){\\n            return right;\\n        }\\n        if (right==null){\\n            return left;\\n        }\\n        //- If both are not null that means we have find out our answer\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n          if (root==null || root==p || root==q){\\n            return root;\\n        }\\n\\n        TreeNode left=lowestCommonAncestor(root.left,p,q);\\n        TreeNode right=lowestCommonAncestor(root.right,p,q);\\n        //- Result\\n        if (left==null){\\n            return right;\\n        }\\n        if (right==null){\\n            return left;\\n        }\\n        //- If both are not null that means we have find out our answer\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335620,
                "title": "c-solution-easy-6-lines-recursion-fast-than-89",
                "content": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(root==NULL || root==p || root==q)\\t\\treturn root;\\n\\tTreeNode* left = lowestCommonAncestor(root->left, p, q);\\n\\tTreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n\\tif(left==NULL)\\t\\treturn right;\\n\\telse if(right==NULL)\\t\\treturn left;\\n\\telse\\t\\treturn root;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\tif(root==NULL || root==p || root==q)\\t\\treturn root;\\n\\tTreeNode* left = lowestCommonAncestor(root->left, p, q);\\n\\tTreeNode* right = lowestCommonAncestor(root->right, p, q);\\n\\n\\tif(left==NULL)\\t\\treturn right;\\n\\telse if(right==NULL)\\t\\treturn left;\\n\\telse\\t\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2335465,
                "title": "binary-tree-recursion-masterclass-full-intuition-explained-with-image",
                "content": "If you found this post helpful, please upvote <3\\n\\nThis post is a little longer than usual, but it\\'s a great read if you want to learn :)\\n\\n<hr />\\n\\nWe are given a binary tree, and we need to find the `lowest common ancestor (LCA)` for 2 given nodes `p` and `q`.\\n\\nLet\\'s look at an example\\n![image](https://assets.leetcode.com/users/images/a58b2eb4-6408-429b-948e-4830db327c5d_1658821225.671219.png)\\n\\nWhen working with binary trees, we need to break the given problem into smaller \"tree problems\", this means recursively look at sub trees and try to find some properties.\\n\\nIf we observe carefully, we can see that the `node = 5, which is the LCA` has both p and q as it\\'s descendants.\\n\\nIf we were to recuse the binary tree bottom-up, when we would get to node=5, we would already find nodes `q` and `p` since **head first recursion** puts all the recursion calls in the call stack, and then processes them bottom-up.\\n\\nAlso node=5 is the first node that would be reached after finding both `q` and `p`.\\n\\n![image](https://assets.leetcode.com/users/images/1d813f01-bfd0-43aa-9b82-2fd457b13d7f_1658821645.661032.png)\\n\\n\\n# Algorithm\\nOur algorithm will search the tree head first, meaning recursing into `left` and `right` childs before doing any checks on the current node.\\n\\nIf we find either `q` or `p` we mark it.\\n\\nWhenever we find both `q` and `p` we know that we found the lowest common ancestor.\\n\\nNote that the current node can be one of `q` or `p` and also form the lowest common ancestor, so we check for that also.\\n\\nI\\'ve created a class `RecursionOutput` to communicate clearly between the recursions, since the recursions communicate with the return values.\\n\\n**Optimization**: If we already found the LCA in the sub trees below, we short circuit return to stop further processing the tree.\\n\\n# Code\\nThe code is readable and commented, just go through it.\\n\\nYou can make the code smaller by cleaning up the extra class, and avoiding some checks. But the idea is to make the code clean, since the performance is the same.\\n\\n```\\nclass RecursionOutput:\\n    def __init__(self, q_found: bool, p_found: bool, lowest_common_ancestor: \\'TreeNode\\' = None):\\n        self.q_found = q_found\\n        self.p_found = p_found\\n        self.lowest_common_ancestor = lowest_common_ancestor\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        def search(node: \\'TreeNode\\'):\\n            if not node: return RecursionOutput(False, False)\\n            \\n            # Initial values\\n            is_q_found = False\\n            is_p_found = False\\n            \\n            # Search on left side\\n            left_output = search(node.left)\\n            \\n            # Already found LCA on left side -> short circuit return\\n            if left_output.lowest_common_ancestor is not None:\\n                return left_output\\n            \\n            # Search on right side\\n            right_output = search(node.right)\\n            \\n            # Found LCA on right side -> short circuit return\\n            if right_output.lowest_common_ancestor is not None:\\n                return right_output\\n            \\n            # Check if we found q in either left or right side\\n            if left_output.q_found or right_output.q_found:\\n                is_q_found = True\\n            \\n\\t\\t\\t # Check if we found p in either left or right side\\n            if left_output.p_found or right_output.p_found:\\n                is_p_found = True\\n            \\n            \\n            # Check if current node is either q or p\\n            if node == q:\\n                is_q_found = True\\n            if node == p:\\n                is_p_found = True\\n             \\n            # Prepare the output\\n            output = RecursionOutput(is_q_found, is_p_found)\\n            \\n            # if found LCA\\n            if is_q_found and is_p_found:\\n                output.lowest_common_ancestor = node\\n            \\n            return output\\n                \\n        \\n        search_result = search(root)\\n        return search_result.lowest_common_ancestor\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass RecursionOutput:\\n    def __init__(self, q_found: bool, p_found: bool, lowest_common_ancestor: \\'TreeNode\\' = None):\\n        self.q_found = q_found\\n        self.p_found = p_found\\n        self.lowest_common_ancestor = lowest_common_ancestor\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        def search(node: \\'TreeNode\\'):\\n            if not node: return RecursionOutput(False, False)\\n            \\n            # Initial values\\n            is_q_found = False\\n            is_p_found = False\\n            \\n            # Search on left side\\n            left_output = search(node.left)\\n            \\n            # Already found LCA on left side -> short circuit return\\n            if left_output.lowest_common_ancestor is not None:\\n                return left_output\\n            \\n            # Search on right side\\n            right_output = search(node.right)\\n            \\n            # Found LCA on right side -> short circuit return\\n            if right_output.lowest_common_ancestor is not None:\\n                return right_output\\n            \\n            # Check if we found q in either left or right side\\n            if left_output.q_found or right_output.q_found:\\n                is_q_found = True\\n            \\n\\t\\t\\t # Check if we found p in either left or right side\\n            if left_output.p_found or right_output.p_found:\\n                is_p_found = True\\n            \\n            \\n            # Check if current node is either q or p\\n            if node == q:\\n                is_q_found = True\\n            if node == p:\\n                is_p_found = True\\n             \\n            # Prepare the output\\n            output = RecursionOutput(is_q_found, is_p_found)\\n            \\n            # if found LCA\\n            if is_q_found and is_p_found:\\n                output.lowest_common_ancestor = node\\n            \\n            return output\\n                \\n        \\n        search_result = search(root)\\n        return search_result.lowest_common_ancestor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334147,
                "title": "java-easy-solution-100-faster-code",
                "content": "```\\nclass Solution {\\n    TreeNode ans=null;\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        helper(root,p,q);\\n        return this.ans;\\n    }\\n    \\n    public TreeNode helper(TreeNode node,TreeNode p, TreeNode q){\\n        if(node==null){\\n            return null;\\n        }\\n        \\n        TreeNode leftNode=helper(node.left,p,q);\\n        TreeNode rightNode=helper(node.right,p,q);\\n        if(((node==p || node==q)&&(leftNode!=null || rightNode!=null))||(leftNode!=null &&rightNode!=null)){\\n            this.ans=node;\\n            return node;\\n        }else if((leftNode!=null || rightNode!=null)||(node==p || node==q)){\\n            return node;\\n        }else{\\n            return null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode ans=null;\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        helper(root,p,q);\\n        return this.ans;\\n    }\\n    \\n    public TreeNode helper(TreeNode node,TreeNode p, TreeNode q){\\n        if(node==null){\\n            return null;\\n        }\\n        \\n        TreeNode leftNode=helper(node.left,p,q);\\n        TreeNode rightNode=helper(node.right,p,q);\\n        if(((node==p || node==q)&&(leftNode!=null || rightNode!=null))||(leftNode!=null &&rightNode!=null)){\\n            this.ans=node;\\n            return node;\\n        }else if((leftNode!=null || rightNode!=null)||(node==p || node==q)){\\n            return node;\\n        }else{\\n            return null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916670,
                "title": "easiest-c-solution-ever-recursive-approach",
                "content": "Here is my complete code explained with comments at each step. Just go through the code and you will easily get this.\\nAlso do upvote if this helps.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // base cases of recursion\\n        // base case 1\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        // base case 2\\n        if(root==p || root==q)\\n        {\\n            return root;\\n        }\\n        \\n        // now sending the recursion in left and right\\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        \\n        \\n        // if we get the value from both left and right of a node then that node is the LCA and simply return it\\n        if(left!=NULL && right!=NULL)\\n        {\\n            return root;\\n        }\\n        // if we only get value from left side , then return left node \\n        if(left!=NULL)\\n        {\\n            return left;\\n        }\\n        // else if we only get value from right side, then return right node\\n        else\\n        {\\n            return right;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        // base cases of recursion\\n        // base case 1\\n        if(root==NULL)\\n        {\\n            return NULL;\\n        }\\n        \\n        // base case 2\\n        if(root==p || root==q)\\n        {\\n            return root;\\n        }\\n        \\n        // now sending the recursion in left and right\\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        \\n        \\n        // if we get the value from both left and right of a node then that node is the LCA and simply return it\\n        if(left!=NULL && right!=NULL)\\n        {\\n            return root;\\n        }\\n        // if we only get value from left side , then return left node \\n        if(left!=NULL)\\n        {\\n            return left;\\n        }\\n        // else if we only get value from right side, then return right node\\n        else\\n        {\\n            return right;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777094,
                "title": "c-clean-easy-o-1-space",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(root==NULL || root==p || root==q)\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\tTreeNode* left=lowestCommonAncestor(root->left,p,q);\\n\\t\\t\\tTreeNode* right=lowestCommonAncestor(root->right,p,q);\\n\\n\\t\\t\\tif(left==NULL)\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\telse if(right==NULL)\\n\\t\\t\\t\\treturn left;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\n\\tfeel free to ask your doubts :)\\n\\tand pls upvote if it was helpful :)",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\t\\t\\tif(root==NULL || root==p || root==q)\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\tTreeNode* left=lowestCommonAncestor(root->left,p,q);\\n\\t\\t\\tTreeNode* right=lowestCommonAncestor(root->right,p,q);\\n\\n\\t\\t\\tif(left==NULL)\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\telse if(right==NULL)\\n\\t\\t\\t\\treturn left;\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn root;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1307277,
                "title": "lowest-common-ancestor-python-recursive-approach-easy",
                "content": "# upvote  if useful \\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root is None or root is p or root is q:\\n            return root\\n        l = self.lowestCommonAncestor(root.left,p,q)\\n        r = self.lowestCommonAncestor(root.right,p,q)\\n        if l and r:\\n            return root\\n        if l:\\n            return l\\n        else:\\n            return r",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Recursion"
                ],
                "code": "# upvote  if useful \\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root is None or root is p or root is q:\\n            return root\\n        l = self.lowestCommonAncestor(root.left,p,q)\\n        r = self.lowestCommonAncestor(root.right,p,q)\\n        if l and r:\\n            return root\\n        if l:\\n            return l\\n        else:\\n            return r",
                "codeTag": "Java"
            },
            {
                "id": 1300355,
                "title": "clean-java-recursive-solution-without-changing-the-signature-of-the-question",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        if (root == null)\\n            return null;\\n        \\n        TreeNode checkLeft = lowestCommonAncestor(root.left, p, q);\\n        TreeNode checkRight = lowestCommonAncestor(root.right, p, q);\\n        \\n        if (root == p || root == q)\\n            return root;\\n            \\n        else if (checkLeft == null && checkRight == null)\\n            return null;\\n        \\n        else if (checkLeft == null)\\n            return checkRight;\\n        \\n        else if (checkRight == null)\\n            return checkLeft;\\n        \\n        else\\n            return root;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        \\n        if (root == null)\\n            return null;\\n        \\n        TreeNode checkLeft = lowestCommonAncestor(root.left, p, q);\\n        TreeNode checkRight = lowestCommonAncestor(root.right, p, q);\\n        \\n        if (root == p || root == q)\\n            return root;\\n            \\n        else if (checkLeft == null && checkRight == null)\\n            return null;\\n        \\n        else if (checkLeft == null)\\n            return checkRight;\\n        \\n        else if (checkRight == null)\\n            return checkLeft;\\n        \\n        else\\n            return root;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842459,
                "title": "easy-recursive-do-upvote-if-like-the-solution",
                "content": "16 ms, faster than 98.04% of C++ online submissions for Lowest Common Ancestor of a Binary Tree\\n14.2 MB, less than 95.01% of C++ online submissions for Lowest Common Ancestor of a Binary Tree\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root==NULL) return NULL;\\n        if(root==p || root==q) return root;\\n        \\n        TreeNode* left_node=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right_node=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(left_node!=NULL && right_node!=NULL) return root;\\n        if(left_node==NULL && right_node==NULL) return NULL;\\n        \\n        if(left_node!=NULL) return left_node;\\n        return right_node;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root==NULL) return NULL;\\n        if(root==p || root==q) return root;\\n        \\n        TreeNode* left_node=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right_node=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(left_node!=NULL && right_node!=NULL) return root;\\n        if(left_node==NULL && right_node==NULL) return NULL;\\n        \\n        if(left_node!=NULL) return left_node;\\n        return right_node;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 783009,
                "title": "python-divide-and-conquer-with-explanation",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        # found p and q?\\n        if not root or root == p or root == q:\\n            return root\\n        \\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        # p and q appears in left and right respectively, then their ancestor is root\\n        if left is not None and right is not None:\\n            return root\\n        \\n        # p and q not in left, then it must be in right, otherwise left\\n        if left is None:\\n            return right\\n        \\n        if right is None:\\n            return left\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        # found p and q?\\n        if not root or root == p or root == q:\\n            return root\\n        \\n        \\n        left = self.lowestCommonAncestor(root.left, p, q)\\n        right = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        # p and q appears in left and right respectively, then their ancestor is root\\n        if left is not None and right is not None:\\n            return root\\n        \\n        # p and q not in left, then it must be in right, otherwise left\\n        if left is None:\\n            return right\\n        \\n        if right is None:\\n            return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527218,
                "title": "readable-javascript-solution-explained-99-time-100-space",
                "content": "The main thing to understand in this problem is that you are essentially checking each subtree to see is q and q exist starting from a new root with each call of recursion. if you see that both p and q exist in the subtree you return. \\nMost of the soutions I saw were written in a way tricky to understand so I wrote out as simple as possible.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    \\n    return dfs(root);\\n    \\n    function dfs(node){\\n        if(!node){\\n            return null;\\n        }\\n\\t\\t\\n\\t\\t//if you see that the current node is p or q return the current node\\n        if(node === p || node === q){\\n            return node;\\n        }\\n\\t\\t\\n\\t\\t//check the left subtree for p or q, at the bottom level of the recursive stack it returns p or q, but at the highest level it returns the lowest common ancestor\\n        let left = dfs(node.left);\\n\\t\\t\\n\\t\\t//same as what you did for left\\n        let right = dfs(node.right);\\n        \\n\\t\\t//if you found both p and q in the left and right subtree return this node\\n        if(left && right){\\n            return node;\\n        }\\n\\t\\t\\n\\t\\t//if you found both p and q in the left subtree\\n        if(left){\\n            return left;\\n        }\\n        \\n\\t\\t//if you found both p and q in the right subtree\\n        if(right){\\n            return right;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {TreeNode} p\\n * @param {TreeNode} q\\n * @return {TreeNode}\\n */\\nvar lowestCommonAncestor = function(root, p, q) {\\n    \\n    return dfs(root);\\n    \\n    function dfs(node){\\n        if(!node){\\n            return null;\\n        }\\n\\t\\t\\n\\t\\t//if you see that the current node is p or q return the current node\\n        if(node === p || node === q){\\n            return node;\\n        }\\n\\t\\t\\n\\t\\t//check the left subtree for p or q, at the bottom level of the recursive stack it returns p or q, but at the highest level it returns the lowest common ancestor\\n        let left = dfs(node.left);\\n\\t\\t\\n\\t\\t//same as what you did for left\\n        let right = dfs(node.right);\\n        \\n\\t\\t//if you found both p and q in the left and right subtree return this node\\n        if(left && right){\\n            return node;\\n        }\\n\\t\\t\\n\\t\\t//if you found both p and q in the left subtree\\n        if(left){\\n            return left;\\n        }\\n        \\n\\t\\t//if you found both p and q in the right subtree\\n        if(right){\\n            return right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 448292,
                "title": "c-iterative-post-order-traversal-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        std::stack<TreeNode *> txStk;\\n        TreeNode *prev = NULL; /* previous node visisted in Post-order traversal */\\n        TreeNode *curr = NULL; \\n        TreeNode *parent = NULL; /* placeholder for LCA */\\n        \\n        \\n        int p_found = 0;\\n        int q_found = 0;\\n\\n        if (!root) return NULL;\\n        if (p == q) return p;\\n\\n        /* Process left child of root */\\n        for (TreeNode *tmp = root; tmp; tmp = tmp->left) \\n            txStk.push(tmp);\\n        \\n        while (!txStk.empty()) {\\n            curr = txStk.top();\\n            \\n            /*\\n             * If prev was marked as a probable ancestor, then it would either be one of\\n             * (p,q) or their ancestor. Now that prev has been visited and we found only\\n             * one of (p, q), we\\'ll go to its ancestor to find next. Update ancestor while we do that.\\n             */\\n            if (parent && prev == parent) parent = curr;\\n            \\n            \\n            /*\\n             * 1. Left tree has already been processed. If last node we\\n             * processed was not right child, process right child\\n             */\\n            if (curr->right && prev != curr->right) {\\n                /* 2. Process left chlid of this node */\\n                for (TreeNode *tmp = curr->right; tmp; tmp = tmp->left)\\n                    txStk.push(tmp);\\n                continue;\\n            }\\n            \\n            txStk.pop();\\n            \\n            /* \\n             * Because we\\'re doing a ordered traversal, the left most node will be found first\\n             * or the child node if one is ancestor of other. When we\\'ve found second node,\\n             * the ancestor is already captured correctly in parent.\\n             */\\n            if (curr == p) {\\n                if (q_found) return parent;\\n                p_found = 1;\\n                parent = curr;\\n            }\\n            \\n            if (curr == q) {\\n                if (p_found) return parent;\\n                q_found = 1;\\n                parent = curr;\\n            }\\n            \\n            /* Remember last node we visited in the traversal */\\n            prev = curr;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        std::stack<TreeNode *> txStk;\\n        TreeNode *prev = NULL; /* previous node visisted in Post-order traversal */\\n        TreeNode *curr = NULL; \\n        TreeNode *parent = NULL; /* placeholder for LCA */\\n        \\n        \\n        int p_found = 0;\\n        int q_found = 0;\\n\\n        if (!root) return NULL;\\n        if (p == q) return p;\\n\\n        /* Process left child of root */\\n        for (TreeNode *tmp = root; tmp; tmp = tmp->left) \\n            txStk.push(tmp);\\n        \\n        while (!txStk.empty()) {\\n            curr = txStk.top();\\n            \\n            /*\\n             * If prev was marked as a probable ancestor, then it would either be one of\\n             * (p,q) or their ancestor. Now that prev has been visited and we found only\\n             * one of (p, q), we\\'ll go to its ancestor to find next. Update ancestor while we do that.\\n             */\\n            if (parent && prev == parent) parent = curr;\\n            \\n            \\n            /*\\n             * 1. Left tree has already been processed. If last node we\\n             * processed was not right child, process right child\\n             */\\n            if (curr->right && prev != curr->right) {\\n                /* 2. Process left chlid of this node */\\n                for (TreeNode *tmp = curr->right; tmp; tmp = tmp->left)\\n                    txStk.push(tmp);\\n                continue;\\n            }\\n            \\n            txStk.pop();\\n            \\n            /* \\n             * Because we\\'re doing a ordered traversal, the left most node will be found first\\n             * or the child node if one is ancestor of other. When we\\'ve found second node,\\n             * the ancestor is already captured correctly in parent.\\n             */\\n            if (curr == p) {\\n                if (q_found) return parent;\\n                p_found = 1;\\n                parent = curr;\\n            }\\n            \\n            if (curr == q) {\\n                if (p_found) return parent;\\n                q_found = 1;\\n                parent = curr;\\n            }\\n            \\n            /* Remember last node we visited in the traversal */\\n            prev = curr;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341420,
                "title": "strange-attribute-error",
                "content": "I am getting a strange attribute error sometimes. Specifically, whenever I try and return something I get\\n*Line 80: AttributeError: \\'int\\' object has no attribute \\'val\\'*\\n\\nI have no line 80 so I am a little confused where this could be coming from. Furthermore, the error only happens if I try and return something. If I just print the result, there are no issues. Any help would be greatly appreciated!\\n\\nCode, if that helps:\\n\\n```# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    #function for finding all ancestors\\n    def findAncestors(self, ancestors, current, goal):\\n        if current.val == goal:\\n            return ancestors\\n        else:\\n            if current.left:\\n                leftTree = Solution.findAncestors(self, ancestors + [current.left.val], current.left, goal)\\n            else:\\n                leftTree = []\\n            if current.right:\\n                rightTree = Solution.findAncestors(self, ancestors + [current.right.val], current.right, goal)\\n            else:\\n                rightTree = []\\n            return leftTree or rightTree\\n    \\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return root\\n        pAncs = Solution.findAncestors(self, [root.val], root, p.val)\\n        qAncs = Solution.findAncestors(self, [root.val], root, q.val)\\n        \\n        for i in range(len(pAncs)):\\n            if pAncs[i]==qAncs[i]:\\n                return pAncs[i]\\n```",
                "solutionTags": [],
                "code": "```# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    #function for finding all ancestors\\n    def findAncestors(self, ancestors, current, goal):\\n        if current.val == goal:\\n            return ancestors\\n        else:\\n            if current.left:\\n                leftTree = Solution.findAncestors(self, ancestors + [current.left.val], current.left, goal)\\n            else:\\n                leftTree = []\\n            if current.right:\\n                rightTree = Solution.findAncestors(self, ancestors + [current.right.val], current.right, goal)\\n            else:\\n                rightTree = []\\n            return leftTree or rightTree\\n    \\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return root\\n        pAncs = Solution.findAncestors(self, [root.val], root, p.val)\\n        qAncs = Solution.findAncestors(self, [root.val], root, q.val)\\n        \\n        for i in range(len(pAncs)):\\n            if pAncs[i]==qAncs[i]:\\n                return pAncs[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303992,
                "title": "java-iterative-and-recursive-with-detailed-explanation",
                "content": "```\\nprivate static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) {\\n            return null;\\n        }\\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        return left != null ? left : right;\\n    }\\n\\n    // Non Recursive BFS Approach: TC - O(n)\\n    // Step 1: traverse all the tree and save the node-parent pairs (in a hash map) for all the nodes in the tree (till the point we encounter BOTH p and q)\\n    // Step 2: start from p and save all the parents of p till root (including p and root) in a hash set\\n    // Step 3: start from q and and navigate through all the parents till root and whenever you see a parent that is present in the set (common ancestor for p and q), that is LCA\\n    private static TreeNode lowestCommonAncestorIterative(TreeNode root, TreeNode p, TreeNode q) {\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); // look up map for the node and its immediate parent\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        parentMap.put(root, null);\\n        queue.add(root);\\n        while (!parentMap.containsKey(p) || !parentMap.containsKey(q)) {\\n            TreeNode node = queue.poll();\\n            parentMap.put(node.left, node);  // save the node and its parentMap\\n            parentMap.put(node.right, node); // save the node and its parentMap\\n\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n        }\\n        Set<TreeNode> set = new HashSet<>();\\n        while (p != null) {   // get all the parents of p till the root\\n            set.add(p);\\n            p = parentMap.get(p);\\n        }\\n        while (!set.contains(q)) {   // starting q, get all its parents till the root and in the process, whenever you see the parentMap that is already present in the set, that\\'s the first common parentMap (which is LCA)\\n            q = parentMap.get(q);\\n        }\\n        return q;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nprivate static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) {\\n            return null;\\n        }\\n        if (root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        return left != null ? left : right;\\n    }\\n\\n    // Non Recursive BFS Approach: TC - O(n)\\n    // Step 1: traverse all the tree and save the node-parent pairs (in a hash map) for all the nodes in the tree (till the point we encounter BOTH p and q)\\n    // Step 2: start from p and save all the parents of p till root (including p and root) in a hash set\\n    // Step 3: start from q and and navigate through all the parents till root and whenever you see a parent that is present in the set (common ancestor for p and q), that is LCA\\n    private static TreeNode lowestCommonAncestorIterative(TreeNode root, TreeNode p, TreeNode q) {\\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>(); // look up map for the node and its immediate parent\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        parentMap.put(root, null);\\n        queue.add(root);\\n        while (!parentMap.containsKey(p) || !parentMap.containsKey(q)) {\\n            TreeNode node = queue.poll();\\n            parentMap.put(node.left, node);  // save the node and its parentMap\\n            parentMap.put(node.right, node); // save the node and its parentMap\\n\\n            if (node.left != null) {\\n                queue.add(node.left);\\n            }\\n            if (node.right != null) {\\n                queue.add(node.right);\\n            }\\n        }\\n        Set<TreeNode> set = new HashSet<>();\\n        while (p != null) {   // get all the parents of p till the root\\n            set.add(p);\\n            p = parentMap.get(p);\\n        }\\n        while (!set.contains(q)) {   // starting q, get all its parents till the root and in the process, whenever you see the parentMap that is already present in the set, that\\'s the first common parentMap (which is LCA)\\n            q = parentMap.get(q);\\n        }\\n        return q;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65362,
                "title": "easy-9-line-java-solution-o-n-time-using-recursion",
                "content": "    public class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p) return p;\\n        if(root == q) return q;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left == null && right == null) return null;\\n        if(left != null && right == null) return left;\\n        if(left == null && right != null) return right;\\n        return root;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) return null;\\n        if(root == p) return p;\\n        if(root == q) return q;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left == null && right == null) return null;\\n        if(left != null && right == null) return left;\\n        if(left == null && right != null) return right;\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 65396,
                "title": "3-solutions-with-explanation",
                "content": "The first one is straightforward but slow. The second one is also not difficult to come up with. The 3rd is neat and but it was hard for me to get my head around it at the first time.\\n  \\n    \\n    \\n       /**\\n         * Definition for a binary tree node.\\n         * struct TreeNode {\\n         *     int val;\\n         *     TreeNode *left;\\n         *     TreeNode *right;\\n         *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n         * };\\n         */\\n        class Solution {\\n        public:\\n            TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                  return sol1(root,p,q);\\n                //return sol2(root,p,q);\\n                //return sol3(root,p,q);\\n            }\\n            \\n            // 23ms\\n            TreeNode* sol3(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                 // no p and q\\n                 if (!root) return NULL;\\n                 // find either p or q\\n                 if (root == p || root == q) return root;\\n                 TreeNode *left = sol3(root->left,p, q);\\n                 TreeNode *right = sol3(root->right,p,q);\\n                 \\n                 // p and q are in different subtrees\\n                 if(left && right) return root;\\n                 // p and q are in the same subtree\\n                 return left ? left : right;\\n            }\\n            \\n            // 23ms   the lowest cross of the paths \\n            TreeNode* sol2(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                vector<TreeNode*> p1, p2;\\n                pathTo(root,p,p1);\\n                // if q in the path\\n                for (auto a : p1) {\\n                    if (q == a) return q;\\n                }\\n                pathTo(root,q,p2);\\n                for (auto a : p2) {\\n                    if (p == a) return p;\\n                }\\n                // if p in the path\\n                int N = p1.size();\\n                int M = p2.size();\\n                \\n                for (int i = N -1; i >= 0 ; i--) {\\n                    for (int j = M -1; j >=0 ;j--) {\\n                        if (p1[i] == p2[j]) {\\n                            return p1[i];\\n                        }\\n                    }\\n                }\\n                \\n                // should never come here\\n                return NULL;\\n            }\\n            \\n            bool pathTo(TreeNode* root, TreeNode* n, vector<TreeNode*> &path) {\\n                if (!root) return false;\\n                if (root == n) {\\n                    path.push_back(n);\\n                    return true;\\n                }\\n                \\n                path.push_back(root);\\n                if (pathTo(root->left, n, path)) return true;\\n                if (pathTo(root->right,n, path)) return true;\\n                path.pop_back();\\n                return false;\\n            }\\n        \\n            //slow....\\n            TreeNode* sol1(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                if (p == root || q == root) return root;\\n                // 1 in left, 2 in right\\n                int lp = dfsFind(root->left,p) ? 1 : 2;\\n                int lq = dfsFind(root->left,q) ? 1 : 2;\\n                \\n                if (lp != lq) return root;\\n                if (lp == 1) return lowestCommonAncestor(root->left,p,q);\\n                return lowestCommonAncestor(root->right, p, q);\\n            }\\n            \\n            bool dfsFind(TreeNode *root, TreeNode *t) {\\n                if (!root) return false;\\n                if (root == t) return true;\\n                if (dfsFind(root->left,t)) return true;\\n                return dfsFind(root->right,t);\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n                  return sol1(root,p,q);\\n                //return sol2(root,p,q);\\n                //return sol3(root,p,q);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65358,
                "title": "non-recursive-c-code-with-considering-not-both-p-and-q-are-all-in-the-tree-return-null",
                "content": "Non-recursive implement, return NULL if p, q or both are not in the three.\\n\\nC++\\n    \\n    class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            vector<TreeNode*> left_stack;\\n            vector<TreeNode*> right_stack;\\n            TreeNode* node = root;\\n            TreeNode* lca = NULL;\\n            while(node)\\n            {\\n                if(node == p || node == q)\\n                    if(lca == NULL)\\n                        lca = node;\\n                    else\\n                        return lca;\\n                left_stack.push_back(node);\\n                node = node->left;\\n            }\\n            while(left_stack.size() > 0)\\n            {\\n                node = left_stack.back();\\n                if(node->right == NULL)\\n                {\\n                    left_stack.pop_back();\\n                    if(node->left != NULL && node->left == lca)\\n                        lca = node;\\n                    continue;\\n                }\\n                if(right_stack.size() > 0 && node == right_stack.back())\\n                {\\n                    left_stack.pop_back();\\n                    right_stack.pop_back();\\n                    if(lca != NULL && (node->left == lca || node->right == lca))\\n                        lca = node;\\n                    continue;\\n                }\\n                if(lca != NULL && (node->left == lca || node->right == lca))\\n                    lca = node;\\n                right_stack.push_back(node);\\n                node = node->right;\\n                while(node)\\n                {\\n                    if(node == p || node == q)\\n                        if(lca == NULL)\\n                            lca = node;\\n                        else\\n                            return lca;\\n                    left_stack.push_back(node);\\n                    node = node->left;\\n                }\\n            }\\n            return NULL;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n            vector<TreeNode*> left_stack;\\n            vector<TreeNode*> right_stack;\\n            TreeNode* node = root;\\n            TreeNode* lca = NULL;\\n            while(node)\\n            {\\n                if(node == p || node == q)\\n                    if(lca == NULL)\\n                        lca = node;\\n                    else\\n                        return lca;\\n                left_stack.push_back(node);\\n                node = node->left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65430,
                "title": "accepted-java-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution\\n    {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n        {\\n            if(root == null)\\n                return null;\\n            if(root == p || root == q)\\n                return root; // if find at root, no need to continue, this is before branching\\n            TreeNode left = lowestCommonAncestor(root.left,p,q);\\n            TreeNode right = lowestCommonAncestor(root.right,p,q);\\n            if(left != null && right != null) //after branching\\n                return root;\\n            return left == null?right:left;//one branch null or branch not null, the brach without null automatically becomes the lca\\n                                            //both null and root doesn't match, then return null\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n    {\\n        public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q)\\n        {\\n            if(root == null)\\n                return null;\\n            if(root == p || root == q)\\n                return root; // if find at root, no need to continue, this is before branching\\n            TreeNode left = lowestCommonAncestor(root.left,p,q);\\n            TreeNode right = lowestCommonAncestor(root.right,p,q);\\n            if(left != null && right != null) //after branching\\n                return root;\\n            return left == null?right:left;//one branch null or branch not null, the brach without null automatically becomes the lca\\n                                            //both null and root doesn't match, then return null\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3947122,
                "title": "easy-iterative-dfs-solution-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        stack=[]\\n        parent=defaultdict(TreeNode)\\n        res=[]\\n        stack.append([root,0])\\n        while(stack):\\n            t=stack.pop()\\n            node=t[0]\\n            level=t[1]\\n            if node.val in [p.val,q.val]:\\n                res.append([node,level])\\n            if node.right:\\n                stack.append([node.right,level+1])\\n                parent[node.right]=node\\n            if node.left:\\n                stack.append([node.left,level+1])\\n                parent[node.left]=node\\n        p,pl=res[0][0],res[0][1]\\n        q,ql=res[1][0],res[1][1]\\n        if pl>ql:\\n            for i in range(pl-ql):\\n                p=parent[p]\\n                print(p.val)\\n        elif pl<ql:\\n            for i in range(ql-pl):\\n                q=parent[q]\\n                print(q.val)\\n        while(p.val!=q.val):\\n            p=parent[p]\\n            q=parent[q]\\n        return p\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        stack=[]\\n        parent=defaultdict(TreeNode)\\n        res=[]\\n        stack.append([root,0])\\n        while(stack):\\n            t=stack.pop()\\n            node=t[0]\\n            level=t[1]\\n            if node.val in [p.val,q.val]:\\n                res.append([node,level])\\n            if node.right:\\n                stack.append([node.right,level+1])\\n                parent[node.right]=node\\n            if node.left:\\n                stack.append([node.left,level+1])\\n                parent[node.left]=node\\n        p,pl=res[0][0],res[0][1]\\n        q,ql=res[1][0],res[1][1]\\n        if pl>ql:\\n            for i in range(pl-ql):\\n                p=parent[p]\\n                print(p.val)\\n        elif pl<ql:\\n            for i in range(ql-pl):\\n                q=parent[q]\\n                print(q.val)\\n        while(p.val!=q.val):\\n            p=parent[p]\\n            q=parent[q]\\n        return p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502560,
                "title": "5-6-lines-c-solution-very-easy-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart !\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.check if root is null or not ,if null return null;\\n2.if found q then return q;\\n3.if found p then return p;\\n4.now search in Left side of the tree ;\\n5.Now search in right side of the tree;\\n6.if not found i both side then return null;\\n7.if not found in right and found in left return left;\\n8.if not found in left and found in right return right;\\n9.if found in both return root ;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root->val==q->val) return q;\\n        if(root->val==p->val) return p;\\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        if(left==NULL&&right==NULL)return NULL;\\n        if(left!=NULL&&right==NULL)return left;\\n        if(left==NULL&&right!=NULL)return right;\\n        else return root;\\n\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/1dcb2545-6c4e-4717-bd0d-ecfe570bc1cf_1683588444.5812426.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root->val==q->val) return q;\\n        if(root->val==p->val) return p;\\n        TreeNode* left=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right=lowestCommonAncestor(root->right,p,q);\\n        if(left==NULL&&right==NULL)return NULL;\\n        if(left!=NULL&&right==NULL)return left;\\n        if(left==NULL&&right!=NULL)return right;\\n        else return root;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449442,
                "title": "c-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL)return NULL;\\n        if(root==p||root==q){\\n            return root;\\n        }\\n        TreeNode* l = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        if(l&&r)return root;\\n        if(l)return l;\\n        if(r)return r;\\n        return NULL;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL)return NULL;\\n        if(root==p||root==q){\\n            return root;\\n        }\\n        TreeNode* l = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* r = lowestCommonAncestor(root->right,p,q);\\n        if(l&&r)return root;\\n        if(l)return l;\\n        if(r)return r;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281391,
                "title": "lowest-common-ancestor-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (root == p || root == q) return root;\\n        if (left == null) return right;\\n        if (right == null) return left;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null) return root;\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (root == p || root == q) return root;\\n        if (left == null) return right;\\n        if (right == null) return left;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222257,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)\\n            return root;\\n        if(root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        if(left && right)\\n            return root;\\n        return left?left:right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)\\n            return root;\\n        if(root == p || root == q)\\n            return root;\\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\\n        if(left && right)\\n            return root;\\n        return left?left:right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178718,
                "title": "go-golang-solution-using-recursion",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n    // First base case, if root is null, return null\\n    if root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n    // Second base case, if root is equal to p or q, return root because, we found the LCA at root only\\n\\tif root == p || root == q {\\n\\t\\treturn root\\n\\t}\\n\\n    // Process left and then right nodes\\n\\tleft := lowestCommonAncestor(root.Left, p, q)\\n\\tright := lowestCommonAncestor(root.Right, p, q)\\n\\n    // if both left and right aren\\'t null, that means we found the targets on both sides of trees, means we need to return root\\n\\tif left != nil && right != nil {\\n\\t\\treturn root\\n\\t}\\n\\t// if we find in left, return left\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n    // else right\\n\\treturn right\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n    // First base case, if root is null, return null\\n    if root == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n    // Second base case, if root is equal to p or q, return root because, we found the LCA at root only\\n\\tif root == p || root == q {\\n\\t\\treturn root\\n\\t}\\n\\n    // Process left and then right nodes\\n\\tleft := lowestCommonAncestor(root.Left, p, q)\\n\\tright := lowestCommonAncestor(root.Right, p, q)\\n\\n    // if both left and right aren\\'t null, that means we found the targets on both sides of trees, means we need to return root\\n\\tif left != nil && right != nil {\\n\\t\\treturn root\\n\\t}\\n\\t// if we find in left, return left\\n\\tif left != nil {\\n\\t\\treturn left\\n\\t}\\n    // else right\\n\\treturn right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090423,
                "title": "java-super-easy-solution-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null) return null;\\n        if(root==p || root==q) return root;\\n\\n        TreeNode left=lowestCommonAncestor(root.left,p,q);\\n        TreeNode right=lowestCommonAncestor(root.right,p,q);\\n\\n        if(left==null) return right;\\n        if(right==null) return left;\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null) return null;\\n        if(root==p || root==q) return root;\\n\\n        TreeNode left=lowestCommonAncestor(root.left,p,q);\\n        TreeNode right=lowestCommonAncestor(root.right,p,q);\\n\\n        if(left==null) return right;\\n        if(right==null) return left;\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042264,
                "title": "java-simple-easy-and-fast-solution",
                "content": "This is a followup question of Node root Path here we will calculate the Node root path from root to p and root to q and after filling both the lists we will traverse in both the list and to find the common node in the extreme right and that will be our answer .\\n\\nPlease upvote if understood \\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ArrayList<TreeNode> path1 = new ArrayList<>();\\n        ArrayList<TreeNode> path2 = new ArrayList<>();\\n        \\n\\t\\t// This will fill both path1 and path2 list \\n         NodeRootPath(root,p,path1);\\n         NodeRootPath(root,q,path2);\\n        \\n        TreeNode common = root;\\n        for(int i=0 ;i<Math.min(path1.size(),path2.size());i++){\\n            if(path1.get(i)==path2.get(i)){\\n                common = path1.get(i);\\n            }\\n        }\\n        return common;\\n    }\\n    \\n    public boolean NodeRootPath(TreeNode root , TreeNode tar , ArrayList<TreeNode> path){\\n        if(root == null){\\n            return false ;\\n        }\\n        path.add(root);\\n        if(root == tar){\\n            return true ;\\n        }\\n        \\n        if(NodeRootPath(root.left,tar,path) || NodeRootPath(root.right,tar,path)){\\n            return true  ;\\n        }\\n        path.remove(path.size()-1);\\n        return false ;\\n    }\\n",
                "solutionTags": [
                    "Array",
                    "Backtracking",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "This is a followup question of Node root Path here we will calculate the Node root path from root to p and root to q and after filling both the lists we will traverse in both the list and to find the common node in the extreme right and that will be our answer .\\n\\nPlease upvote if understood \\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        ArrayList<TreeNode> path1 = new ArrayList<>();\\n        ArrayList<TreeNode> path2 = new ArrayList<>();\\n        \\n\\t\\t// This will fill both path1 and path2 list \\n         NodeRootPath(root,p,path1);\\n         NodeRootPath(root,q,path2);\\n        \\n        TreeNode common = root;\\n        for(int i=0 ;i<Math.min(path1.size(),path2.size());i++){\\n            if(path1.get(i)==path2.get(i)){\\n                common = path1.get(i);\\n            }\\n        }\\n        return common;\\n    }\\n    \\n    public boolean NodeRootPath(TreeNode root , TreeNode tar , ArrayList<TreeNode> path){\\n        if(root == null){\\n            return false ;\\n        }\\n        path.add(root);\\n        if(root == tar){\\n            return true ;\\n        }\\n        \\n        if(NodeRootPath(root.left,tar,path) || NodeRootPath(root.right,tar,path)){\\n            return true  ;\\n        }\\n        path.remove(path.size()-1);\\n        return false ;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2984604,
                "title": "java-and-python-3-explained-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find p and q in the tree, and move upward until we discover where the two paths meet. This goes bottom to top, which means we need to do some bookkeeping. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a map from each node\\'s value to that node\\'s parent. Call this map **parents**. It will be populated depth first.\\n2. Follow the line of parents from **p**, and insert each of them into the set **p_ancestors**.\\n3. Follow the line of parents from **q**, until one is a member of **p_ancestors**. Return this node.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) for an n-node tree. We traverse the entire tree to find each node and record its parents. We use this information to trace the path from **p** to root (O(1) lookup per node), and then from **q** to the lowest common ancestor node (also O(1) lookup per node).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for an n-node tree. We create the **parents** map with n entries; we also create the set **pAncestors**, with a maximum of n members.\\n# Code (Java)\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n        Map<Integer, TreeNode> parents;     // Parent node, by current node\\'s value\\n        Set<Integer> pAncestors;            // A set for p\\'s ancestors\\n    \\n    /**\\n        The constructor sets up parents and pAncestors.\\n     */\\n    public Solution() {\\n        parents = new HashMap<Integer, TreeNode>();\\n        pAncestors = new HashSet<Integer>();\\n    }\\n\\n    /**\\n      Traverse the tree depth-first, finding the parent of each node and\\n      saving it to parents, recursively.\\n\\n      @param node the starting node\\n     */\\n    private void findAllParents(TreeNode node) {\\n        if (node.left != null) {\\n            parents.put(node.left.val, node);\\n            findAllParents(node.left);\\n        }\\n        if (node.right != null) {\\n            parents.put(node.right.val, node);\\n            findAllParents(node.right);\\n        }\\n    }\\n\\n    /**\\n        Traverse tree, depth first:\\n            At each node record its parent to the parents dictionary\\n        Follow the line of parents from p, and insert all into the set p_ancestors\\n        Follow the line of parents from q, until one is a member of p_ancestors\\n\\n        @param root     the root node of the tree\\n        @param p        first node to check\\n        @param q        second node to check\\n        @return the node that is the lowest common ancestor of p and q\\n     */\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        parents.put(root.val, null);\\n        findAllParents(root);\\n        while (p != null) {\\n            pAncestors.add(p.val);\\n            p = parents.get(p.val);\\n        }\\n        while (q != root && !pAncestors.contains(q.val))\\n            q = parents.get(q.val);\\n        return q;\\n    }\\n}\\n```\\n# Code (Python 3)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\'\\'\\'\\n        Traverse tree, depth first:\\n            At each node record its parent to the parents dictionary\\n        Follow the line of parents from p, and insert all into the set p_ancestors\\n        Follow the line of parents from q, until one is a member of p_ancestors\\n        \\'\\'\\'\\n        parents = {root.val: None}      # Parent node, by current node\\'s value\\n        p_ancestors = set()             # A set for p\\'s ancestors\\n\\n        def find_all_parents(node: TreeNode) -> None:\\n            # Depth-first traversal to identify the parent of each node\\n            if node.left:\\n                parents[node.left.val] = node\\n                find_all_parents(node.left)\\n            if node.right:\\n                parents[node.right.val] = node\\n                find_all_parents(node.right)\\n    \\n        find_all_parents(root)\\n        while p is not None:\\n            p_ancestors.add(p.val)\\n            p = parents[p.val]\\n        while q != root and q.val not in p_ancestors:\\n            q = parents[q.val]\\n        return q\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n        Map<Integer, TreeNode> parents;     // Parent node, by current node\\'s value\\n        Set<Integer> pAncestors;            // A set for p\\'s ancestors\\n    \\n    /**\\n        The constructor sets up parents and pAncestors.\\n     */\\n    public Solution() {\\n        parents = new HashMap<Integer, TreeNode>();\\n        pAncestors = new HashSet<Integer>();\\n    }\\n\\n    /**\\n      Traverse the tree depth-first, finding the parent of each node and\\n      saving it to parents, recursively.\\n\\n      @param node the starting node\\n     */\\n    private void findAllParents(TreeNode node) {\\n        if (node.left != null) {\\n            parents.put(node.left.val, node);\\n            findAllParents(node.left);\\n        }\\n        if (node.right != null) {\\n            parents.put(node.right.val, node);\\n            findAllParents(node.right);\\n        }\\n    }\\n\\n    /**\\n        Traverse tree, depth first:\\n            At each node record its parent to the parents dictionary\\n        Follow the line of parents from p, and insert all into the set p_ancestors\\n        Follow the line of parents from q, until one is a member of p_ancestors\\n\\n        @param root     the root node of the tree\\n        @param p        first node to check\\n        @param q        second node to check\\n        @return the node that is the lowest common ancestor of p and q\\n     */\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        parents.put(root.val, null);\\n        findAllParents(root);\\n        while (p != null) {\\n            pAncestors.add(p.val);\\n            p = parents.get(p.val);\\n        }\\n        while (q != root && !pAncestors.contains(q.val))\\n            q = parents.get(q.val);\\n        return q;\\n    }\\n}\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\'\\'\\'\\n        Traverse tree, depth first:\\n            At each node record its parent to the parents dictionary\\n        Follow the line of parents from p, and insert all into the set p_ancestors\\n        Follow the line of parents from q, until one is a member of p_ancestors\\n        \\'\\'\\'\\n        parents = {root.val: None}      # Parent node, by current node\\'s value\\n        p_ancestors = set()             # A set for p\\'s ancestors\\n\\n        def find_all_parents(node: TreeNode) -> None:\\n            # Depth-first traversal to identify the parent of each node\\n            if node.left:\\n                parents[node.left.val] = node\\n                find_all_parents(node.left)\\n            if node.right:\\n                parents[node.right.val] = node\\n                find_all_parents(node.right)\\n    \\n        find_all_parents(root)\\n        while p is not None:\\n            p_ancestors.add(p.val)\\n            p = parents[p.val]\\n        while q != root and q.val not in p_ancestors:\\n            q = parents[q.val]\\n        return q\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830397,
                "title": "java-easy-to-understand-anuj-bhaiyya-working-code",
                "content": "Eaxact same code you can use in-> **235. Lowest Common Ancestor of a Binary Search Tree**\\n[https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree]()\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==p || root==q) return root;\\n        if(root==null) return null;\\n        TreeNode left=lowestCommonAncestor(root.left, p, q);\\n        TreeNode right=lowestCommonAncestor(root.right, p, q);\\n        if(left==null) return right;\\n        if(right==null) return left;\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==p || root==q) return root;\\n        if(root==null) return null;\\n        TreeNode left=lowestCommonAncestor(root.left, p, q);\\n        TreeNode right=lowestCommonAncestor(root.right, p, q);\\n        if(left==null) return right;\\n        if(right==null) return left;\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792209,
                "title": "easiest-approach-shortest-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL or root == p or root == q)return root;\\n        auto left = lowestCommonAncestor(root->left,p,q);\\n        auto right = lowestCommonAncestor(root->right,p,q);\\n        if(left == NULL)return right;\\n        else if(right == NULL)return left;\\n        else return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL or root == p or root == q)return root;\\n        auto left = lowestCommonAncestor(root->left,p,q);\\n        auto right = lowestCommonAncestor(root->right,p,q);\\n        if(left == NULL)return right;\\n        else if(right == NULL)return left;\\n        else return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336498,
                "title": "kotlin-dfs-easy-recursive-approach",
                "content": "```\\n\\n/*\\n    if leftSubtree and rightSubtree includes the nodes searched then it means we can easily\\n    return the root of those the left and right subtrees, \\n    \\n    In case of one of them is null, then the right one (itself) will be our lowest common ancestor\\n\\n*/\\nclass Solution {\\n    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\\n        \\n        if(root == null || p == root || q == root) return root\\n        \\n        val left = lowestCommonAncestor(root?.left, p,q)\\n        val right = lowestCommonAncestor(root?.right, p,q)\\n        \\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        \\n        return if(left == null) right else left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n/*\\n    if leftSubtree and rightSubtree includes the nodes searched then it means we can easily\\n    return the root of those the left and right subtrees, \\n    \\n    In case of one of them is null, then the right one (itself) will be our lowest common ancestor\\n\\n*/\\nclass Solution {\\n    fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? {\\n        \\n        if(root == null || p == root || q == root) return root\\n        \\n        val left = lowestCommonAncestor(root?.left, p,q)\\n        val right = lowestCommonAncestor(root?.right, p,q)\\n        \\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        \\n        return if(left == null) right else left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335739,
                "title": "beats-100-other-s-solutions",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        res = None\\n        def helper(node):\\n            nonlocal res\\n            if not node:\\n                return False\\n            l = helper(node.left)\\n            r = helper(node.right)\\n            mid = node == p or node == q\\n            if mid + l + r >= 2:\\n                res = node\\n            return mid or l or r\\n        helper(root)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        res = None\\n        def helper(node):\\n            nonlocal res\\n            if not node:\\n                return False\\n            l = helper(node.left)\\n            r = helper(node.right)\\n            mid = node == p or node == q\\n            if mid + l + r >= 2:\\n                res = node\\n            return mid or l or r\\n        helper(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334632,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n\\nAuthor : https://github.com/RajaKunalPandit1\\n\\n// Naive Solution :: Time : O(N) :: Aux_Space : O(N)\\n\\n  /**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool getPath(TreeNode *root,vector<TreeNode *> &res, int x){\\n\\n        if(root == NULL){\\n            return false;\\n        }\\n\\n        res.push_back(root);\\n\\n        if(root->val == x) return true;\\n\\n        if(getPath(root->left,res,x) || getPath(root->right,res,x)) return true;\\n\\n        res.pop_back();\\n        return false;\\n    }\\n\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n        TreeNode *res;\\n\\n        if(!root){\\n            return {};\\n        }\\n\\n        vector<TreeNode *> v1;\\n        vector<TreeNode *> v2;\\n\\n        getPath(root,v1,p->val);\\n        getPath(root,v2,q->val);\\n\\n        int n = min(v1.size(),v2.size());\\n\\n        for(int i=0;i<n;i++){\\n            if(v1[i] == v2[i]){\\n                res = v1[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(N) :: Aux_Space : O(N) [N cuz of Skew Trees]\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n\\n        if(root == NULL || root == q || root == p) return root;\\n\\n        TreeNode *left = lowestCommonAncestor(root->left,p,q);\\n        TreeNode *right = lowestCommonAncestor(root->right,p,q);\\n\\n        if(left == NULL){\\n            return right;\\n        }else if(right == NULL){\\n            return left;\\n        }else{\\n            return root;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool getPath(TreeNode *root,vector<TreeNode *> &res, int x){\\n\\n        if(root == NULL){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2334433,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left,p,q)\\n        right = self.lowestCommonAncestor(root.right,p,q)        \\n        if left != None and right != None:\\n            return root\\n        elif left != None:\\n            return left\\n        elif right != None:\\n            return right\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        if root == None or root == p or root == q:\\n            return root\\n        left = self.lowestCommonAncestor(root.left,p,q)\\n        right = self.lowestCommonAncestor(root.right,p,q)        \\n        if left != None and right != None:\\n            return root\\n        elif left != None:\\n            return left\\n        elif right != None:\\n            return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334341,
                "title": "python-dfs-clear-and-simple-code-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        #DFS solution\\n        if (root == p or root == q or not root): return root  #found what we want or there is nothing\\n        \\n        left, right = self.lowestCommonAncestor(root.left, p, q), self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left and right:  #common ancestor\\n            return root\\n        elif left:\\n            return left\\n        elif right:\\n            return right\\n        \\n        return None\\n```\\nPlease UPVOTE if you like !!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        #DFS solution\\n        if (root == p or root == q or not root): return root  #found what we want or there is nothing\\n        \\n        left, right = self.lowestCommonAncestor(root.left, p, q), self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left and right:  #common ancestor\\n            return root\\n        elif left:\\n            return left\\n        elif right:\\n            return right\\n        \\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334234,
                "title": "python3-easy-to-understand-iterative-solution",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':    \\n        que = deque([root])\\n        parent = {root: None}\\n        \\n        while que:\\n            node = que.popleft()\\n            \\n            if node.left:\\n                que.append(node.left)\\n                parent[node.left] = node\\n            \\n            if node.right:\\n                que.append(node.right)\\n                parent[node.right] = node\\n            \\n            if p in parent and q in parent:\\n                break\\n        \\n        ancestors = set()\\n        while p:\\n            ancestors.add(p)\\n            p = parent[p]\\n        \\n        while q:\\n            if q in ancestors:\\n                return q\\n            q = parent[q]\\n```\\n\\nWhile we have many recursive solution in discussion, here\\'s iterative one. Please **upvote** if you find it helpful.",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':    \\n        que = deque([root])\\n        parent = {root: None}\\n        \\n        while que:\\n            node = que.popleft()\\n            \\n            if node.left:\\n                que.append(node.left)\\n                parent[node.left] = node\\n            \\n            if node.right:\\n                que.append(node.right)\\n                parent[node.right] = node\\n            \\n            if p in parent and q in parent:\\n                break\\n        \\n        ancestors = set()\\n        while p:\\n            ancestors.add(p)\\n            p = parent[p]\\n        \\n        while q:\\n            if q in ancestors:\\n                return q\\n            q = parent[q]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292270,
                "title": "java-recursive-easy",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //base case\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        //result\\n        if(left == null) {\\n            return right;\\n        }\\n        else if(right == null) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        //base case\\n        if (root == null || root == p || root == q) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        //result\\n        if(left == null) {\\n            return right;\\n        }\\n        else if(right == null) {\\n            return left;\\n        }\\n        else { //both left and right are not null, we found our result\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219891,
                "title": "i-think-it-is-easy-to-understand-python-dfs",
                "content": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        path_p=[]; path_q=[]\\n        \\n        def DFS(r,path,t):\\n            if not r:\\n                return False\\n            path.append(r)\\n            if r.val==t.val:\\n                return True\\n            \\n            if (DFS(r.left , path , t) or DFS(r.right , path , t)):\\n                return True\\n            path.pop(-1)\\n            \\n            \\n        DFS(root,path_p,p)\\n        DFS(root,path_q,q)\\n        \\n        for n in range(min(len(path_q) , len(path_p))):\\n            if path_q[n] == path_p[n] :\\n                continue\\n            else:\\n                return path_q[n-1]\\n        return path_q[n]",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        \\n        path_p=[]; path_q=[]\\n        \\n        def DFS(r,path,t):\\n            if not r:\\n                return False\\n            path.append(r)\\n            if r.val==t.val:\\n                return True\\n            \\n            if (DFS(r.left , path , t) or DFS(r.right , path , t)):\\n                return True\\n            path.pop(-1)\\n            \\n            \\n        DFS(root,path_p,p)\\n        DFS(root,path_q,q)\\n        \\n        for n in range(min(len(path_q) , len(path_p))):\\n            if path_q[n] == path_p[n] :\\n                continue\\n            else:\\n                return path_q[n-1]\\n        return path_q[n]",
                "codeTag": "Java"
            },
            {
                "id": 2204505,
                "title": "c-recursion-5-lines",
                "content": "```\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\tif (root == null || root == p || root == q) return root;\\n\\tTreeNode right = LowestCommonAncestor(root.right, p, q);\\n\\tTreeNode left = LowestCommonAncestor(root.left, p, q);\\n\\tif (left != null && right != null) return root;\\n\\treturn right != null ? right : left;\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n\\tif (root == null || root == p || root == q) return root;\\n\\tTreeNode right = LowestCommonAncestor(root.right, p, q);\\n\\tTreeNode left = LowestCommonAncestor(root.left, p, q);\\n\\tif (left != null && right != null) return root;\\n\\treturn right != null ? right : left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1968868,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null || root==p || root==q) return root;\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        \\n\\t\\t// If both p & q were found in sub-trees of root.\\n\\t\\tif(l!=null && r!=null) return root;\\n        \\n\\t\\t// if only either of them was found, then return the one which is not null.  This logic covers side cases.\\n\\t\\treturn l==null ? r : l;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null || root==p || root==q) return root;\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        \\n\\t\\t// If both p & q were found in sub-trees of root.\\n\\t\\tif(l!=null && r!=null) return root;\\n        \\n\\t\\t// if only either of them was found, then return the one which is not null.  This logic covers side cases.\\n\\t\\treturn l==null ? r : l;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1863672,
                "title": "simple-intuitive-c-solution-o-n-time",
                "content": "The algorithm can be understand  as:\\n1.  If the root is itself p or q than it is LCA.\\n2.  Else search for lca in left and right subtree\\n3.  Now suppose both left and right are not null, this implies one node (p or q) found in left subtree and the other node is found on the right subtree. This implies root is LCA.\\n4.  If left is Null this implies that both the the node must be present in right hence the answer is right otherwise the answer is left.\\n\\n Node* lca(Node* root, Node* p, Node* q) {\\n        \\n        if(!root) return NULL;\\n        \\n        if(root==p or root==q) return root; \\n        \\n        Node *left=lca(root->left,p,q);\\n        Node* right=lca(root->right,p,q);\\n        if(!left) return right;\\n        if(!right) return left;\\n        return root;\\n    }",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "The algorithm can be understand  as:\\n1.  If the root is itself p or q than it is LCA.\\n2.  Else search for lca in left and right subtree\\n3.  Now suppose both left and right are not null, this implies one node (p or q) found in left subtree and the other node is found on the right subtree. This implies root is LCA.\\n4.  If left is Null this implies that both the the node must be present in right hence the answer is right otherwise the answer is left.\\n\\n Node* lca(Node* root, Node* p, Node* q) {\\n        \\n        if(!root) return NULL;\\n        \\n        if(root==p or root==q) return root; \\n        \\n        Node *left=lca(root->left,p,q);\\n        Node* right=lca(root->right,p,q);\\n        if(!left) return right;\\n        if(!right) return left;\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1602926,
                "title": "python-easy-to-understand-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        return self.helper(root, p, q)\\n        \\n    def helper(self, node, p, q):\\n        if node is None:\\n            return None\\n        \\n        if node.val == p.val or node.val == q.val:\\n            return node\\n        \\n        left_sub = self.helper(node.left, p, q)\\n        right_sub = self.helper(node.right, p, q)\\n        \\n        if left_sub is None:\\n            return right_sub\\n        if right_sub is None:\\n            return left_sub\\n\\n        return node\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        return self.helper(root, p, q)\\n        \\n    def helper(self, node, p, q):\\n        if node is None:\\n            return None\\n        \\n        if node.val == p.val or node.val == q.val:\\n            return node\\n        \\n        left_sub = self.helper(node.left, p, q)\\n        right_sub = self.helper(node.right, p, q)\\n        \\n        if left_sub is None:\\n            return right_sub\\n        if right_sub is None:\\n            return left_sub\\n\\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490384,
                "title": "2-approaches-path-array-s-dfs-c-o-n",
                "content": "Implementation\\n\\n**1st Approach Using path arrays**\\n**Time Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree**\\n**In this solution we require three traversal of binary tree (0(N)+0(N)+0(N)) => 3(0(N)) => 0(N).**\\n\\n```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, vector<TreeNode*> &path, TreeNode* node){\\n        if(root == NULL) return false;\\n        path.push_back(root);\\n        if(root == node) return true;\\n        if(findPath(root->left, path, node) || findPath(root->right, path, node)) return true;\\n        path.pop_back();\\n        return false;\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector<TreeNode*> path1, path2;\\n        if(findPath(root, path1, p) == false || findPath(root, path2, q) == false) return NULL;\\n        int itr = 0;\\n        for(itr; itr < min(path1.size(), path2.size()); itr++){\\n            if(path1[itr] != path2[itr]) break;\\n        }\\n        return path1[itr-1];\\n    }\\n};\\n```\\n\\n\\n**2nd Approach Using DFS\\nTime Complexity = O(N), Space Complexity = O(H) where H is the height of the Binary Tree\\nIn this solution we require only one traversal of binary tree.\\nBut in this approach both given key should be present.**\\n\\nclass Solution {\\n```\\npublic:    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return NULL;\\n        if(root == p || root == q) return root;\\n        TreeNode* lcaLeft = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* lcaRight = lowestCommonAncestor(root->right, p, q);\\n        if(lcaLeft && lcaRight) return root;        \\n        return lcaLeft ? lcaLeft : lcaRight;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findPath(TreeNode* root, vector<TreeNode*> &path, TreeNode* node){\\n        if(root == NULL) return false;\\n        path.push_back(root);\\n        if(root == node) return true;\\n        if(findPath(root->left, path, node) || findPath(root->right, path, node)) return true;\\n        path.pop_back();\\n        return false;\\n    }\\n    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        vector<TreeNode*> path1, path2;\\n        if(findPath(root, path1, p) == false || findPath(root, path2, q) == false) return NULL;\\n        int itr = 0;\\n        for(itr; itr < min(path1.size(), path2.size()); itr++){\\n            if(path1[itr] != path2[itr]) break;\\n        }\\n        return path1[itr-1];\\n    }\\n};\\n```\n```\\npublic:    \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL) return NULL;\\n        if(root == p || root == q) return root;\\n        TreeNode* lcaLeft = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* lcaRight = lowestCommonAncestor(root->right, p, q);\\n        if(lcaLeft && lcaRight) return root;        \\n        return lcaLeft ? lcaLeft : lcaRight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476396,
                "title": "java-100-faster-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null || root==p || root==q) return root;\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        \\n\\t\\t// If both p & q were found in sub-trees of root.\\n\\t\\tif(l!=null && r!=null) return root;\\n        \\n\\t\\t// if only either of them was found, then return the one which is not null.  This logic covers side cases.\\n\\t\\treturn l==null ? r : l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root==null || root==p || root==q) return root;\\n        TreeNode l = lowestCommonAncestor(root.left, p, q);\\n        TreeNode r = lowestCommonAncestor(root.right, p, q);\\n        \\n\\t\\t// If both p & q were found in sub-trees of root.\\n\\t\\tif(l!=null && r!=null) return root;\\n        \\n\\t\\t// if only either of them was found, then return the one which is not null.  This logic covers side cases.\\n\\t\\treturn l==null ? r : l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476209,
                "title": "python3-recursive-clean-code-faster-than-80",
                "content": "\\n    def lowestCommonAncestor(self, root, p, q):\\n\\t\\n        if not root: return None\\n\\t\\t\\n        if root == p or root == q: return root\\n\\t\\t\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n\\t\\t\\n        if l and r:\\n            return root\\n        else: return l if l else r",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\n    def lowestCommonAncestor(self, root, p, q):\\n\\t\\n        if not root: return None\\n\\t\\t\\n        if root == p or root == q: return root\\n\\t\\t\\n        l = self.lowestCommonAncestor(root.left, p, q)\\n        r = self.lowestCommonAncestor(root.right, p, q)\\n\\t\\t\\n        if l and r:\\n            return root\\n        else: return l if l else r",
                "codeTag": "Python3"
            },
            {
                "id": 1432959,
                "title": "js-o-n-time-and-space",
                "content": "Approach: Recursively go to the left and right child of each node and check if the value equals either of `p` or `q`. If the value matches, return the node. For each parent node, check if eboth left and right child returns a node and not null. If both returns node, that means the parent node is the LCA of the two nodes, so return that node.\\n\\n```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root) {\\n        return null;\\n    }\\n\\t// recursive call to left and right child of each node\\n    const left = lowestCommonAncestor(root.left, p, q),\\n          right = lowestCommonAncestor(root.right, p, q);\\n    \\n\\t// if either both left and right child return a node or the root node value matches p or q node value,\\n\\t// return the node\\n    if((left && right) || root.val === p.val || root.val === q.val) {\\n        return root;\\n    } else if(left) {    // if only one of the p or q node is found at the left child, return that\\n        return left;\\n    } else if(right) {    // if only one of the p or q node is found at the right child, return that\\n        return right;\\n    }\\n    return null;    // none of the nodes is found when this node is processed completely, so return null\\n};\\n```\\n\\nTime Complexity = O(n)\\nSpace Complexity = O(n) [call stack - O(h) but O(n) in case of skewed tree]",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar lowestCommonAncestor = function(root, p, q) {\\n    if(!root) {\\n        return null;\\n    }\\n\\t// recursive call to left and right child of each node\\n    const left = lowestCommonAncestor(root.left, p, q),\\n          right = lowestCommonAncestor(root.right, p, q);\\n    \\n\\t// if either both left and right child return a node or the root node value matches p or q node value,\\n\\t// return the node\\n    if((left && right) || root.val === p.val || root.val === q.val) {\\n        return root;\\n    } else if(left) {    // if only one of the p or q node is found at the left child, return that\\n        return left;\\n    } else if(right) {    // if only one of the p or q node is found at the right child, return that\\n        return right;\\n    }\\n    return null;    // none of the nodes is found when this node is processed completely, so return null\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367273,
                "title": "n-ary-tree-for-lca",
                "content": "I was asked this question in today\\'s Microsoft VO.  \\nN-ary Tree and two TreeNode\\'s LCA\\n\\n```\\npublic class Solution {\\n    \\n    public static TreeNode firstCommonAncester(TreeNode root, TreeNode n1, TreeNode n2) {\\n        if (root == null || root == n1 || root == n2) return root;\\n        if (root.children == null || root.children.size() == 0) return null;\\n        int count = 0;\\n        TreeNode res = null;\\n        for (TreeNode child : root.children) {\\n            TreeNode cur = firstCommonAncester(child, n1, n2);\\n            if (cur != null) {\\n                count++;\\n                res = cur;\\n            }\\n        }\\n        if (count == 2) return root;\\n        return res;\\n    }\\n    \\n    public static void main(String[] args) {\\n        //System.out.println(\"Hello World!\");\\n        TreeNode r1 = new TreeNode(5);\\n        TreeNode r2 = new TreeNode(1);\\n        TreeNode r3 = new TreeNode(2);\\n        List<TreeNode> c1 = Arrays.asList(new TreeNode[]{r2, r3});\\n        r1.children = c1;\\n        \\n        TreeNode r4 = new TreeNode(6);\\n        TreeNode r5 = new TreeNode(8);\\n        TreeNode r6 = new TreeNode(18);\\n        List<TreeNode> c3 = Arrays.asList(new TreeNode[]{r4, r5, r6});\\n        r3.children = c3;\\n        \\n        TreeNode r7 = new TreeNode(10);\\n        List<TreeNode> c4 =  Arrays.asList(new TreeNode[]{r7});\\n        r4.children = c4;\\n        TreeNode res = firstCommonAncester(r1, r5, r2);\\n        System.out.println(res.val);\\n    }\\n}\\n\\nclass TreeNode {\\n    int val;\\n    List<TreeNode> children;\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public static TreeNode firstCommonAncester(TreeNode root, TreeNode n1, TreeNode n2) {\\n        if (root == null || root == n1 || root == n2) return root;\\n        if (root.children == null || root.children.size() == 0) return null;\\n        int count = 0;\\n        TreeNode res = null;\\n        for (TreeNode child : root.children) {\\n            TreeNode cur = firstCommonAncester(child, n1, n2);\\n            if (cur != null) {\\n                count++;\\n                res = cur;\\n            }\\n        }\\n        if (count == 2) return root;\\n        return res;\\n    }\\n    \\n    public static void main(String[] args) {\\n        //System.out.println(\"Hello World!\");\\n        TreeNode r1 = new TreeNode(5);\\n        TreeNode r2 = new TreeNode(1);\\n        TreeNode r3 = new TreeNode(2);\\n        List<TreeNode> c1 = Arrays.asList(new TreeNode[]{r2, r3});\\n        r1.children = c1;\\n        \\n        TreeNode r4 = new TreeNode(6);\\n        TreeNode r5 = new TreeNode(8);\\n        TreeNode r6 = new TreeNode(18);\\n        List<TreeNode> c3 = Arrays.asList(new TreeNode[]{r4, r5, r6});\\n        r3.children = c3;\\n        \\n        TreeNode r7 = new TreeNode(10);\\n        List<TreeNode> c4 =  Arrays.asList(new TreeNode[]{r7});\\n        r4.children = c4;\\n        TreeNode res = firstCommonAncester(r1, r5, r2);\\n        System.out.println(res.val);\\n    }\\n}\\n\\nclass TreeNode {\\n    int val;\\n    List<TreeNode> children;\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349073,
                "title": "simple-c-iterative-approach",
                "content": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        stack<TreeNode*> s;\\n        unordered_map<TreeNode*,TreeNode*> mp;\\n        mp[root]=NULL;\\n        s.push(root);\\n        while(mp.find(p)==mp.end() || mp.find(q)==mp.end()){\\n            TreeNode *t=s.top();\\n            s.pop();\\n            if(t->left){\\n                mp[t->left]=t;\\n                s.push(t->left);\\n            }\\n            if(t->right){\\n                mp[t->right]=t;\\n                s.push(t->right);\\n            }\\n        }\\n        set<TreeNode*> sett;\\n        while(p!=NULL){\\n            sett.insert(p);\\n            p=mp[p];\\n        }\\n        while(sett.find(q)==sett.end()){\\n            q=mp[q];\\n        }\\n        return q;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        stack<TreeNode*> s;\\n        unordered_map<TreeNode*,TreeNode*> mp;\\n        mp[root]=NULL;\\n        s.push(root);\\n        while(mp.find(p)==mp.end() || mp.find(q)==mp.end()){\\n            TreeNode *t=s.top();\\n            s.pop();\\n            if(t->left){\\n                mp[t->left]=t;\\n                s.push(t->left);\\n            }\\n            if(t->right){\\n                mp[t->right]=t;\\n                s.push(t->right);\\n            }\\n        }\\n        set<TreeNode*> sett;\\n        while(p!=NULL){\\n            sett.insert(p);\\n            p=mp[p];\\n        }\\n        while(sett.find(q)==sett.end()){\\n            q=mp[q];\\n        }\\n        return q;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307284,
                "title": "c-4-liner-code",
                "content": "Require one traversal and theta(h) space for the recursive traversal.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root == NULL || root == p || root == q) return root;\\n        TreeNode* leftlca = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightlca = lowestCommonAncestor(root->right, p, q);\\n        return (leftlca == NULL ? rightlca : (rightlca==NULL) ?  leftlca :  root); \\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        if(root == NULL || root == p || root == q) return root;\\n        TreeNode* leftlca = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightlca = lowestCommonAncestor(root->right, p, q);\\n        return (leftlca == NULL ? rightlca : (rightlca==NULL) ?  leftlca :  root); \\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113932,
                "title": "4-liner-explained",
                "content": "```\\n// JS\\nvar lowestCommonAncestor = function (root, p, q) {\\n  if (!root || root === p || root === q) return root; // edge case or found p or q: return root\\n  const left = lowestCommonAncestor(root.left, p, q); // look if left child has p or q\\n  const right = lowestCommonAncestor(root.right, p, q); // look if right child has p or q\\n  return left && right ? root : left || right; // if both children returned a node, then current is an ancestor of p and q (LCA)\\n};\\n```\\n\\n```\\n// TS\\nfunction lowestCommonAncestor(\\n  root: TreeNode | null,\\n  p: TreeNode | null,\\n  q: TreeNode | null\\n): TreeNode | null {\\n  if (!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  return left && right ? root : left || right;\\n}\\n```\\n\\nMore leetcode TypeScript solutions at https://github.com/eddyhdzg/leetcode-typescript-solutions\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// JS\\nvar lowestCommonAncestor = function (root, p, q) {\\n  if (!root || root === p || root === q) return root; // edge case or found p or q: return root\\n  const left = lowestCommonAncestor(root.left, p, q); // look if left child has p or q\\n  const right = lowestCommonAncestor(root.right, p, q); // look if right child has p or q\\n  return left && right ? root : left || right; // if both children returned a node, then current is an ancestor of p and q (LCA)\\n};\\n```\n```\\n// TS\\nfunction lowestCommonAncestor(\\n  root: TreeNode | null,\\n  p: TreeNode | null,\\n  q: TreeNode | null\\n): TreeNode | null {\\n  if (!root || root === p || root === q) return root;\\n  const left = lowestCommonAncestor(root.left, p, q);\\n  const right = lowestCommonAncestor(root.right, p, q);\\n  return left && right ? root : left || right;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1013223,
                "title": "faster-than-99-10-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root==p || root==q)\\n            return root;\\n        TreeNode*l=lowestCommonAncestor(root->left,p,q);\\n        TreeNode*r=lowestCommonAncestor(root->right,p,q);\\n        if(l!=NULL && r!=NULL)\\n            return root;\\n        return (l?l:r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL) return NULL;\\n        if(root==p || root==q)\\n            return root;\\n        TreeNode*l=lowestCommonAncestor(root->left,p,q);\\n        TreeNode*r=lowestCommonAncestor(root->right,p,q);\\n        if(l!=NULL && r!=NULL)\\n            return root;\\n        return (l?l:r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632922,
                "title": "simple-java-solution-no-extra-variable-100-faster",
                "content": "```\\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n       if(root==null) {\\n           return null;\\n       } \\n       if(root.val==p.val ||root.val==q.val) {\\n           return root;\\n       }\\n       TreeNode l = lowestCommonAncestor(root.left,p,q);\\n       TreeNode r =  lowestCommonAncestor(root.right,p,q);\\n       if(l!=null && r!=null){\\n          return root;\\n       }\\n       return l!=null?l:r; \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n       if(root==null) {\\n           return null;\\n       } \\n       if(root.val==p.val ||root.val==q.val) {\\n           return root;\\n       }\\n       TreeNode l = lowestCommonAncestor(root.left,p,q);\\n       TreeNode r =  lowestCommonAncestor(root.right,p,q);\\n       if(l!=null && r!=null){\\n          return root;\\n       }\\n       return l!=null?l:r; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353652,
                "title": "beats-100-java-simple-solution",
                "content": "```\\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) {\\n            return null;\\n        } \\n        if(root == p || root == q) {\\n            return root;\\n        }\\n        \\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        else if(left != null && right == null) {\\n            return left;\\n        } \\n        else if (left == null && right != null) {\\n            return right;\\n        } \\n        else { \\n            return null;\\n        }\\n        \\n     }\\n```",
                "solutionTags": [],
                "code": "```\\n  public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null) {\\n            return null;\\n        } \\n        if(root == p || root == q) {\\n            return root;\\n        }\\n        \\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if(left != null && right != null) {\\n            return root;\\n        }\\n        else if(left != null && right == null) {\\n            return left;\\n        } \\n        else if (left == null && right != null) {\\n            return right;\\n        } \\n        else { \\n            return null;\\n        }\\n        \\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338294,
                "title": "simple-python-readable-solution-beats-99-89",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root:\\n            if root== p  or root==q:\\n                return root            \\n            else:\\n                left = root.left and self.lowestCommonAncestor(root.left, p,q)\\n                right  = root.right and self.lowestCommonAncestor(root.right , p,q)\\n                if left and right:\\n                    return root\\n                return left or right\\n        return None\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root:\\n            if root== p  or root==q:\\n                return root            \\n            else:\\n                left = root.left and self.lowestCommonAncestor(root.left, p,q)\\n                right  = root.right and self.lowestCommonAncestor(root.right , p,q)\\n                if left and right:\\n                    return root\\n                return left or right\\n        return None\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 319631,
                "title": "java-straightforward-solution-6-lines",
                "content": "```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root.val == p.val || root.val == q.val) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        return left != null ? left : right;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if (root == null || root.val == p.val || root.val == q.val) {\\n            return root;\\n        }\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n        if (left != null && right != null) {\\n            return root;\\n        }\\n        return left != null ? left : right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213243,
                "title": "simple-and-efficent-golang-100",
                "content": "Simple dfs, runtime 16ms, faster than 100% of Golang submissions.\\n\\n```\\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n     if root == nil {\\n         return nil\\n     } else if root == p {\\n         return p\\n     } else if root == q {\\n         return q\\n     }\\n     \\n     lc := lowestCommonAncestor(root.Left, p, q)\\n     rc := lowestCommonAncestor(root.Right, p, q)\\n     \\n     if lc != nil && rc != nil {\\n         return root\\n     } else if lc != nil {\\n         return lc\\n     } else {\\n         return rc\\n     }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {\\n     if root == nil {\\n         return nil\\n     } else if root == p {\\n         return p\\n     } else if root == q {\\n         return q\\n     }\\n     \\n     lc := lowestCommonAncestor(root.Left, p, q)\\n     rc := lowestCommonAncestor(root.Right, p, q)\\n     \\n     if lc != nil && rc != nil {\\n         return root\\n     } else if lc != nil {\\n         return lc\\n     } else {\\n         return rc\\n     }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181505,
                "title": "python-recursive",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        \\n        left_lca = self.lowestCommonAncestor(root.left, p, q)\\n        right_lca = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left_lca and right_lca:\\n            return root\\n        elif left_lca:\\n            return left_lca\\n        else:\\n            return right_lca\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root, p, q):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type p: TreeNode\\n        :type q: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not root:\\n            return None\\n        if root.val == p.val or root.val == q.val:\\n            return root\\n        \\n        left_lca = self.lowestCommonAncestor(root.left, p, q)\\n        right_lca = self.lowestCommonAncestor(root.right, p, q)\\n        \\n        if left_lca and right_lca:\\n            return root\\n        elif left_lca:\\n            return left_lca\\n        else:\\n            return right_lca\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 65371,
                "title": "java-solution-by-finding-the-path-for-each-node",
                "content": "Find the path for each node.\\nCompare each path to find the LCA\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){\\n        if(root==null) return null;\\n        if(p==null || q==null)  return null;\\n        ArrayList<TreeNode> p_path = new ArrayList<TreeNode>();\\n        ArrayList<TreeNode> q_path = new ArrayList<TreeNode>();\\n        findPath(root, p, p_path);\\n        findPath(root, q, q_path);\\n        int min_len = Math.min(p_path.size(), q_path.size());\\n        int LCA = 0;\\n        for(int i=0; i<min_len; i++){\\n            if(p_path.get(i)==q_path.get(i))\\n                LCA = i;\\n        }return p_path.get(LCA);\\n        \\n    }\\n    public static boolean findPath(TreeNode root, TreeNode n1, List<TreeNode> path){\\n\\t\\tif(root == null)\\n\\t\\t\\treturn false;\\n\\t\\tpath.add(root);\\n\\t\\tif(root == n1)\\n\\t\\t\\treturn true;\\n\\t\\tif(findPath (root.left, n1, path) || findPath(root.right, n1, path))\\n\\t\\t\\treturn true;\\n\\t\\tpath.remove(path.size() - 1);\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "Find the path for each node.\\nCompare each path to find the LCA\\n\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q){\\n        if(root==null) return null;\\n        if(p==null || q==null)  return null;\\n        ArrayList<TreeNode> p_path = new ArrayList<TreeNode>();\\n        ArrayList<TreeNode> q_path = new ArrayList<TreeNode>();\\n        findPath(root, p, p_path);\\n        findPath(root, q, q_path);\\n        int min_len = Math.min(p_path.size(), q_path.size());\\n        int LCA = 0;\\n        for(int i=0; i<min_len; i++){\\n            if(p_path.get(i)==q_path.get(i))\\n                LCA = i;\\n        }return p_path.get(LCA);\\n        \\n    }\\n    public static boolean findPath(TreeNode root, TreeNode n1, List<TreeNode> path){\\n\\t\\tif(root == null)\\n\\t\\t\\treturn false;\\n\\t\\tpath.add(root);\\n\\t\\tif(root == n1)\\n\\t\\t\\treturn true;\\n\\t\\tif(findPath (root.left, n1, path) || findPath(root.right, n1, path))\\n\\t\\t\\treturn true;\\n\\t\\tpath.remove(path.size() - 1);\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 65392,
                "title": "120ms-python-solution",
                "content": "I don't know what's going on. I'll admit if my solution is 100% correct, then the test cases might be too easy...\\n\\n    class Solution(object):\\n        def lowestCommonAncestor(self, root, p, q):\\n            \"\"\"\\n            :type root: TreeNode\\n            :type p: TreeNode\\n            :type q: TreeNode\\n            :rtype: TreeNode\\n            \"\"\"\\n            if not root:\\n                return root\\n                \\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n            \\n            if (p == root or q == root) or (left and right):\\n                return root\\n            else:\\n                return left if left else right",
                "solutionTags": [
                    "Python"
                ],
                "code": "I don't know what's going on. I'll admit if my solution is 100% correct, then the test cases might be too easy...\\n\\n    class Solution(object):\\n        def lowestCommonAncestor(self, root, p, q):\\n            \"\"\"\\n            :type root: TreeNode\\n            :type p: TreeNode\\n            :type q: TreeNode\\n            :rtype: TreeNode\\n            \"\"\"\\n            if not root:\\n                return root\\n                \\n            left = self.lowestCommonAncestor(root.left, p, q)\\n            right = self.lowestCommonAncestor(root.right, p, q)\\n            \\n            if (p == root or q == root) or (left and right):\\n                return root\\n            else:\\n                return left if left else right",
                "codeTag": "Java"
            },
            {
                "id": 3959105,
                "title": "2-easy-c-solutions-recursive-and-iterative-approach-beats-100",
                "content": "# Code\\n```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        \\n        TreeNode *leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode *rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL)\\n            return root;\\n        else if(leftAns != NULL && rightAns == NULL)\\n            return leftAns;\\n        return rightAns;\\n    }\\n};\\n\\n// Iterative solution\\nclass Solution{\\npublic: \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || root == p || root == q) \\n            return root;\\n\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = NULL;\\n\\n        stack<TreeNode*> stk;\\n        stk.push(root);\\n        \\n        while (parent[p] != NULL || parent[q] != NULL) {\\n            TreeNode* node = stk.top(); \\n            stk.pop();\\n            \\n            if (node->left != NULL) {\\n                parent[node->left] = node;\\n                stk.push(node->left);\\n            } \\n            if (node->right != NULL) {\\n                parent[node->right] = node;\\n                stk.push(node->right);\\n            }\\n        }\\n        \\n        set<TreeNode*> ancestor;\\n        while (p) {\\n            ancestor.insert(p);\\n            p = parent[p];\\n        }\\n        while (ancestor.find(q) == ancestor.end()) {\\n            q = parent[q];\\n        }\\n        return q;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(root == NULL || root == p || root == q)\\n            return root;\\n        \\n        TreeNode *leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode *rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if(leftAns != NULL && rightAns != NULL)\\n            return root;\\n        else if(leftAns != NULL && rightAns == NULL)\\n            return leftAns;\\n        return rightAns;\\n    }\\n};\\n\\n// Iterative solution\\nclass Solution{\\npublic: \\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL || root == p || root == q) \\n            return root;\\n\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        parent[root] = NULL;\\n\\n        stack<TreeNode*> stk;\\n        stk.push(root);\\n        \\n        while (parent[p] != NULL || parent[q] != NULL) {\\n            TreeNode* node = stk.top(); \\n            stk.pop();\\n            \\n            if (node->left != NULL) {\\n                parent[node->left] = node;\\n                stk.push(node->left);\\n            } \\n            if (node->right != NULL) {\\n                parent[node->right] = node;\\n                stk.push(node->right);\\n            }\\n        }\\n        \\n        set<TreeNode*> ancestor;\\n        while (p) {\\n            ancestor.insert(p);\\n            p = parent[p];\\n        }\\n        while (ancestor.find(q) == ancestor.end()) {\\n            q = parent[q];\\n        }\\n        return q;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935711,
                "title": "c-simple-recursive-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to return in bottom-up manner to avoid searching the same subtree multiple times\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each root we make recursive calls to the left and right subtree and return on the basis of follwoing criteria\\nReturn root if its equal to p or q\\nReturn p if only p is present\\nReturn q if only q is present\\nReturn LCA if already found\\nReturn NULL if none are present\\nReturn root if LST and RST each have p/q \\n# Complexity\\n- Time complexity: O(number of nodes)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(height) due to recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root) return nullptr;\\n        if(root->val == p->val || root->val == q->val) return root;\\n\\n        TreeNode* lst = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rst = lowestCommonAncestor(root->right, p, q);\\n        if(!lst) return rst; //always return the non NULL value\\n        if(!rst) return lst; // if both are NULL we return NULL only\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root) return nullptr;\\n        if(root->val == p->val || root->val == q->val) return root;\\n\\n        TreeNode* lst = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rst = lowestCommonAncestor(root->right, p, q);\\n        if(!lst) return rst; //always return the non NULL value\\n        if(!rst) return lst; // if both are NULL we return NULL only\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3732751,
                "title": "dfs-approach-for-lca-beats-100-best-optimized",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse depth first search approach,\\n1. Go to left, if it matches one of the values then return the node else return null.\\n2. Then go right and do the same.\\n3. If both returns null then that particular node is our LCA.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q) return root;\\n\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        if(left == null){\\n            return right;\\n        }\\n        else if(right == null){\\n            return left;\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q) return root;\\n\\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\\n\\n        if(left == null){\\n            return right;\\n        }\\n        else if(right == null){\\n            return left;\\n        }\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682917,
                "title": "easy-c-solution-beat-97-5",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* &root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL)\\n            return NULL;\\n        \\n        if(root->val==p->val)\\n            return p;\\n        if(root->val==q->val)\\n            return q;\\n        TreeNode* leftans=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* rightans=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(leftans==NULL&&rightans==NULL)\\n            return NULL;\\n        if(leftans!=NULL&&rightans==NULL)\\n            return leftans;\\n        if(leftans==NULL&&rightans!=NULL)\\n            return rightans;\\n        else\\n            return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* &root, TreeNode* p, TreeNode* q) {\\n        if(root==NULL)\\n            return NULL;\\n        \\n        if(root->val==p->val)\\n            return p;\\n        if(root->val==q->val)\\n            return q;\\n        TreeNode* leftans=lowestCommonAncestor(root->left,p,q);\\n        TreeNode* rightans=lowestCommonAncestor(root->right,p,q);\\n        \\n        if(leftans==NULL&&rightans==NULL)\\n            return NULL;\\n        if(leftans!=NULL&&rightans==NULL)\\n            return leftans;\\n        if(leftans==NULL&&rightans!=NULL)\\n            return rightans;\\n        else\\n            return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564871,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1951292,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566904,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1567232,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566119,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1568338,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1569544,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1568138,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1567925,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1573825,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1564871,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1951292,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566904,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1567232,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1566119,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1568338,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1569544,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1568138,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1567925,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1573825,
                "content": [
                    {
                        "username": "jack76",
                        "content": "Note that the problem description said that \" two given nodes in the tree.\" So the parameters `p` and `q` are node references in the tree. \\n\\nUse \\n\\n`if (root == p)` instead of  `if(root.val == p.val)`"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++ DFS(preOrder).. Easy solution\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three parameters: `root` (the current node), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n2. Check if the current node `root` is null or if it is either `p` or `q`. If any of these conditions is true, return the current node `root` as the lowest common ancestor.\\n\\n3. Recursively call the `rec` function for the left subtree of the current node and assign the result to a variable `l`.\\n\\n4. Recursively call the `rec` function for the right subtree of the current node and assign the result to a variable `r`.\\n\\n5. Check if both `l` and `r` are not null. If so, it means that `p` and `q` are found on different subtrees of the current node, and the current node `root` is their lowest common ancestor. Return the current node `root`.\\n\\n6. If `l` is null, it means that both `p` and `q` are on the right subtree (or not present in the tree). Return `r`.\\n\\n7. If none of the above conditions are met, it means that both `p` and `q` are on the left subtree (or not present in the tree). Return `l`.\\n\\n8. Define a function `lowestCommonAncestor` that takes three parameters: `root` (the root node of the tree), `p` (first node to find the lowest common ancestor for), and `q` (second node to find the lowest common ancestor for).\\n\\n9. Return the result of calling the `rec` function with the parameters `root`, `p`, and `q`. This will find and return the lowest common ancestor of nodes `p` and `q` in the given binary tree.\\n\\n-------------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n). All node have to visit in worst case.\\n\\n- Space complexity:\\nS.C=O(n) in worst case skewed tree. recursive stack take O(n).\\n--------------------------------------\\n\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/solutions/3702977/c-dfs-preorder-easy-solution/"
                    },
                    {
                        "username": "ShuminZ",
                        "content": "Update: The bug is already fixed! Thanks LC\\n\\nIt may be due to how OJ parses the test case: every time I tried to run the testcase, it spat `5 is not a valid value of type TreeNode`. \\nI also tried to enclose 5 and 1 in `[]`but no lucky there.\\nCould someone fix this, or let me know if there is a temporary fix on my end, thanks!"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "When I checked some others solutions committed and passed, I found that, they all miss the checking step,which means we need to check if there are both p and q in this tree.\\n\\nfor example,there is a question name called Share C++/C# 24ms recursive solution , the solution it shows doesn't check wether TreeNode p and TreeNode q exist when it returns.\\n\\nSo what do you guys think??"
                    },
                    {
                        "username": "GUTTTS",
                        "content": "[@mochiball](/mochiball) bro he wrote that in 2015 maybe that time there wasnt anything mentioned in the constraints\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Please read the question constraints. It tells you that p and q are in the tree. No need to check if they exist "
                    },
                    {
                        "username": "harsha335",
                        "content": "in constraints they mentioned both p and q will be present in tree and they are unique and not equal."
                    },
                    {
                        "username": "gepo",
                        "content": "Something is going wrong.\\nLine 41: TypeError: object of type \\'int\\' has no len()"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020 \\n\\nIt is important for me to train myself to get familar with C# data structure and also think better what to choose in design process. There are more than five solutions I like to share using C# data struture: List, Stack, Queue, Dictionary (HashMap), HashSet, Tuple. \\n\\nHere are my highlights:\\n1. First and most important, it is to learn and get familiar using List<TreeNode>, and understand tree traversal, use one path as List variable to solve backtracking issue; \\n2. Next it is important to learn how to solve the algorithm using recursive function without any data structure;\\n3. Advanced topic is to try ideas using Tuple<TreeNode, int> and experience how efficient it is to design and remove ambiguity in design, follow Single Responsiblity Principle SRP. \\n4. Try other options like Stack, HashSet if you have time to practice. \\n\\n**Data structure is the tool to get organized**\\n\\nLet us get started. First one is combination of Queue, Dictionary, HashSet\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n**No 1 combinations: C# Data structure: Queue, Dictionary, HashSet**\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is data structure C# List<TreeNode> \\n\\n\\nC# **List** is enough to solve the problem - topics: backtracking, space optimization\\n\\n**No 2 combinations: C# Data structure: List**\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# HashSet<TreeNode>\\n\\n\\n**No 3 combinations: C# Data structure: HashSet**\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\nJune 25, 2019\\n\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Stack<TreeNode>\\n\\n\\n**Stack** is perfect to maintain the order in last in first out order. \\n\\n**No 4 combinations: C# Data structure: Stack**\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n<br>\\n<br>\\n<br>\\n<br>\\nNext is C# Tuple<TreeNode, int><br>\\n\\n\\n**Tuple** is so powerful and time-efficient, good at strong type definition to avoid run time errors. Give it a try! \\n\\n**No 4 combinations:  C# Data structure: Tuple**\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\nIt is time for me to learn to review my own code. Track my progress and I was so surprised to learn that I need to practice backtracking in 2019, 53 year old. \\n\\n**Extra topic: backtracking, List<TreeNode>**\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sai_manoj_kumar",
                        "content": "Input for the testcase is not being parsed correctly. Where do I report this?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "From May to July 2019\\nIt is my practice for busy season from March to May for two online code assessments and one more phone screen. One of ideas is to finish another 100 algorithm on Leetcode, and pace myself sometimes to work on one algorithm with various approaches. It is for potential phone screen, I may get invited any time. So I like to learn how to prepare more carefully through practice.\\n\\nHere are various topic I cover in my practice, and I also like to share the discussion post for each idea. Some of ideas are just to study code on existing discussion post. \\n\\nI also use the algorithm to interview people on interviewing dot io. It is important for me to learn various solutions first in order to be a good interviewer, and also learn from interview experience through a lot of interviewees. \\n\\nIf you have advice for adding more topics on this algorithm as an interviewer, please leave in the comments. I will add them one by one. \\n\\n**Topics**\\n\\n[child-parent map, parent node, BFS (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[Post order traversal (May 27, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n\\n[how to build a path from p or q to root (May 11, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290664/C-How-to-build-a-path-from-p-or-q-to-root-efficiently-and-stay-on-course)\\n[how to build a path from root to p (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n[Find the path H for node p, and find path for node q and also check hashset for path H, June 14, 2019 mock interview case study ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/312471/C-find-path-for-two-given-nodes-in-two-passes-case-study-in-2019) Clever idea!\\n\\n**Recursive function design, why mix return will lead to lowest common ancestor?**\\n[recursive function - Confused and more work later (May 8, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288320/C-Work-on-the-algorithm-in-mock-interview)\\n[recursive function - mix returns, final one is lowest common ancestor (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302311/C-recursive-function-design-step-by-step-illustration)\\n[C# post order traversal and return p or q in recursive function](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/315272/C-post-order-traversal-and-return-p-or-q-in-recursive-function) case study mock interview on June 18, 2019\\n\\n**Return type**\\n**Return bool or TreeNode?**\\n[Recursive solution Easy to understand - return bool (May 15, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/289920/C-solution-using-post-order-traversal)\\n[Recursive solution Easy to understand - return TreeNode (May 29, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/302301/C-recursive-function-with-return-TreeNode-Easy-to-understand)\\n\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Using Stack data structure<TreeNode>**\\n[Recursive function using Stack return Stack<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/309381/C-Recursive-function-design-to-return-StacklessTreeNodegreater-practice-in-2019) \\n[Recursive function using Stack return bool<TreeNode> (June 10, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311947/C-Use-stack-to-store-path-from-given-node-p-to-root-node-practice-in-2019) <br>\\n\\n**Backtracking learning**\\n[Recursive solution with backtracking (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n\\n[C# recursive function to find lowest common ancestor given p and q are in the binary tree (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301664/C-recursive-function-to-find-lowest-common-ancestor-given-p-and-q-are-in-the-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (May 28, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/301686/C-Find-lowest-common-ancestor-given-two-nodes-p-and-q-may-not-in-binary-tree)\\n[C# recursive function to find lowest common ancestor given p and q (June 14, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/311875/C-Lowest-common-ancestor-given-node-p-and-q-in-binary-tree)\\n\\n**Naive solution with Timeout and Complicated function**\\n[Timeout challenge (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288284/C-time-out-need-help-using-List-preorder-traversal)\\n[Timeout challenge - using a string to store path (May 7, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/288289/C-time-out-need-help-using-string-preorder-traversal)\\n[Fix naive solution timeout with complicated function (May 13, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290656/C-Fix-timeout-bug-but-still-keep-the-code-on-purpose-complicated)\\n**Space complexity analysis**\\n[learn elegent solution using back tracking and space efficiency, avoid timeout (May 23, 2019)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290193/C-find-path-and-also-use-backtrack-to-save-space)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nJune 25, 2019\\nThree practice for three ideas; I like to be a master of the lowest common ancestor! I started again from May 8, 2019, met a lot of talent in Sillicon Valley, Seattle, Toronto area on *** on this algorithm.\\n\\nDare to be a master! Self-claim first!\\n**find one path first and then look up path for second given node q**\\n[C# find path from given node p to root first and then find q and lowest common ancestor\\n](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319849/C-find-path-from-given-node-p-to-root-first-and-then-find-q-and-lowest-common-ancestor)\\n**find one path first top down and then look up path for second given node q**\\n[C# Find top down path for a given node p and then find q\\'s path and look up lowest common ancestor](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319853/C-Find-top-down-path-for-a-given-node-p-and-then-find-q\\'s-path-and-look-up-lowest-common-ancestor)\\n**backtrack to find path from root node to given node p**\\n[C# backtrack to find root node to given node p](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/319858/C-backtrack-to-find-root-node-to-given-node-p)\\n\\nJuly 4, 2019\\nTwo node\\'s distance in binary tree, the post is [here](https://leetcode.com/discuss/interview-question/125084/Amazon-Distance-between-2-nodes). \\nMy solution is written [here](https://leetcode.com/discuss/interview-question/125084/Amazon-or-Distance-between-2-nodes/300089). The idea is to find lowest common ancestor, and then calculate the distance between two nodes indirectly both to lowest common ancestor.\\n[C# Lowest common ancestor -> two node\\'s distance practice (upward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327282/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(uperward))\\n[C# Lowest common ancestor -> two node\\'s distance practice (downward)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/327278/C-Lowest-common-ancestor-greater-two-node\\'s-distance-practice-(downward))\\n\\n**Common mistakes in mock interview**\\n\\n1. Preorder traversal vs postorder traversal, early return when p or q is found, the rest of nodes in the tree is not traversed;\\n2. Redundant code in the recursive function;\\n"
                    },
                    {
                        "username": "teddyyyy",
                        "content": "my code is pretty much the same as everyone else's, but I changed the comparison\\nfrom\\n\\n    if (root == p || root == q) then return root;\\n\\nto \\n\\n    if (root.val == p.val || root.val == q.val) then return root;\\n\\nthen I got errors, I'm really confused, if the former conditions are satisfied, the latter must be true too."
                    },
                    {
                        "username": "user3971c",
                        "content": "[@ayushanand18](/ayushanand18) I can\\'t speak for 2015, but as of now the constraints state that All Node.val are unique. "
                    },
                    {
                        "username": "omerfarooq",
                        "content": "[@ayushanand18](/ayushanand18) are you there suggesting him right after 8 years....wonder what he is doing now."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "there might also be some nodes which have the same values but not the one we are concerned about. i.e. duplicate value nodes."
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27, 2020\\n\\nI continue to ask the algorithm question in my interviewing dot io mock interviews as an interviewer in 2020, and then I was surprised to learn more about recursive function design, strong type, backtracking, and expedite the tree problem solving process. \\n\\nTo work on my C# crafting skills, I also practice the idea after each mock interview. \\n\\nApril 19, 2020\\n[C# backtracking practice after mock interview on April 19, 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655605/C-backtracking-practice-after-mock-interview-on-April-19-2020)\\n\\nMay 1, 2020\\n**Return Tuple<TreeNode, int> or ArrayList? Always strong typing**\\n[C# Postorder traversal and count nodes found practice in 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/606995/C-Postorder-traversal-and-count-nodes-found-practice-in-2020) Learn from ex-facebook engineer, super performance, April 30, 2020<br>\\n\\nMay 25, 2020\\n[C# Tuple<TreeNode, int> design talk and second practice on May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652087/C-TuplelessTreeNode-intgreater-design-talk-and-second-practice-on-May-25-2020)\\n[C# Tuple<TreeNode, int> design talk and quick practice in May 25 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/652064/C-TuplelessTreeNode-intgreater-design-talk-and-quick-practice-in-May-25-2020)\\n\\n**Follow up with review**\\nMay 26, 2020\\n[C# Find path from root to p practice on May 26, 2020](\\nhttps://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653946/C-Find-path-from-root-to-p-practice-on-May-26-2020)\\n[C# Critic my own code written on May 7, 2019](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/653910/C-critic-my-own-code-written-on-May-7-2019) Write review for my own code after 12 months\\n\\nStatistics:\\n1. 40 mock interviews as an interviewer, ask lowest common ancestor in binary tree algorithm in 2019;\\n2. Work on recursive function design over 10 times;\\n3. Work on backtracking practice over 10 times;\\n4. All engineers over 40 engineers in two months I met in 2019 cannot beat performance I met in 2020, an ex-facebook engineer. \\n\\n"
                    }
                ]
            },
            {
                "id": 1569322,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1576127,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1575846,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1573438,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1574616,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1574561,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1573826,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1572384,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1571474,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1571476,
                "content": [
                    {
                        "username": "ravitejrai123",
                        "content": "Can some body explain it to me ? \\nIs it because the tree size is small and there are only a few calls to the recursion stack ?\\n\\n"
                    },
                    {
                        "username": "AlgorithmImplementer",
                        "content": "https://leetcode.com/discuss/interview-question/1648418/Amazon-Find-Common-Manager"
                    },
                    {
                        "username": "tchola",
                        "content": "For this input\\n\\n[37,-34,-48,null,-100,-101,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\n-71\\n8\\n\\nIf this is a binary tree array representation, why is not parent of 8 a null value. I mean, if index of 8 is \\'18\\', the parent should be floor((18-1)/2) = 8 -> null\\n\\nCan someone explain this representation, please?"
                    },
                    {
                        "username": "nag418",
                        "content": "Question Note: what will  happen if the nodes\\' values are not unique\\n\\nIf the ndoes\\' value are not unique, how to slove?"
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Go through all of my accepted submissions to find the difference between each submission. (I have backtracked using if else wherever possible :p)\\nGo through CTCI also\\nGo through LC solution 1 and 2 also\\n\\nNote:\\nThis question taught me the importance of drawing out examples:![image](https://assets.leetcode.com/users/images/aab57a9e-2250-46af-b595-2988fab530cd_1606070614.143661.png)\\n"
                    },
                    {
                        "username": "serenali",
                        "content": "what if one of the input node is not in the bst? what\\'s the solution? How can you solve it with DFS?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "May 27 2020\\nIt is a good idea to put together a post to list all my past practice and also learning experience together up to May 27, 2020. \\n\\n\\n[C# Data structure talk: List, Stack, Queue, HashMap, HashSet and Tuple](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655785/C-Data-structure-talk%3A-List-Stack-Queue-HashMap-HashSet-and-Tuple)\\n[C# Recursive function design collections from 2019 to 2020](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655638/C-Recursive-function-design-collections-from-2019-to-2020)\\n[C# various topics covered in 2020 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/655518/C-various-topics-covered-in-2020-practice)\\n[C# various topics covered through 2019 practice](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/290650/C-various-topics-covered-through-2019-practice)\\n\\n"
                    },
                    {
                        "username": "pauldeepakraj",
                        "content": "Wanted to see what would be the solution for finding the lowest common ancestor of a N-ary(many children) tree?"
                    },
                    {
                        "username": "samuelsun1888",
                        "content": "Am I the only one who has this problem?"
                    },
                    {
                        "username": "bury",
                        "content": "This test case is having duplicate values of -100, which happens to be in the input as well.\\nThis TC seems to be in C++ TC list only. My equivalent Java code passed with no failures. Anyone else is having this issue?\\n\\n[37,-34,-48,null,-100,-100,48,null,null,null,null,-54,null,-71,-22,null,null,null,8]\\nnode with value -100\\nnode with value -71"
                    }
                ]
            },
            {
                "id": 1571477,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1571475,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1568020,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 2071920,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 2044851,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1956067,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1933461,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1931926,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1925231,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            },
            {
                "id": 1922888,
                "content": [
                    {
                        "username": "xuan18",
                        "content": "It is the last test case (test case number as 31 I remember). \\nI'm using Java. If you use a different language and (I don't know) have a different test case, please ignore my question.\\n\\nIn this test case, p.val==91, and q.val==93. There are more than 2000 nodes given in the serialization of the tree, roughly half of them being null.\\n\\nMy program gives 91. However the OJ says it should be 10. I looked into it. There is a node with val==91 and depth==9 (the root is considered to have depth 0, and each node has depth 1 smaller than its children) that has 91 and 93 as descendants (itself being considered one of its descendants, according to the description). There are six nodes with value 10, their depths being 1,7,8,9,11,13, among which, the ones with depths 9, 11, and 13 do not have both 91 and 93 as descendants.\\n\\nI'm doing an in-order traverse of the tree. Let's first assume that the values of nodes are distinct. Now list all the non-null nodes in the order of in-order traverse (I don't actually form a list, but just to say it for convenience), for any two nodes that appear in the list, their least common ancestor is the (unique) one between them in the list (both of them included) that has minimum depth (it's not hard to keep track of the depth of each node in the traversal). If the values are not distinct and p.val and/or q.val appear multiple times, or p.val==q.val, just some simple modifications are needed. I'm not posting my program since I don't think anyone is taking the trouble to read it (or even this post).\\n\\nI saw many posts that first dive into the left subtree and then the right subtree. So now I'm aware of that although I have doubts... (in case the depth is not well maintained, a result \"deep\" in the left subtree could be replaced by a \"shallow\" result in the right subtree... anyway, I didn't think about it carefully. Forget about it).\\n\\nSo... why am I wrong ... or does anyone also get 91 for the last one?"
                    },
                    {
                        "username": "LazyEval",
                        "content": "Looks like image importing is broken, here is a link to the screenshot: http://imgur.com/NR8uRqx\\nNotice that there are no options to \"Run code\" or \"Custom tests\", but only to \"Submit\"\\n\\nUpdate: I triggered run code via keyboard shortcut (ctrl + ') and got this message:\\n\\n**Run Code Status: Failed\\nRun code disabled for this question**\\n\\nany idea if this is expected? Whats the point of disabling run code before submission?"
                    },
                    {
                        "username": "yichenwa",
                        "content": "It cannot pass with concise recursive solution."
                    },
                    {
                        "username": "spamf",
                        "content": "in the example 1 and 2 above, why do left and right branches order look so random - sometimes is left>val>right, sometimes right>val>left, left>right>val?"
                    },
                    {
                        "username": "KarthikRam",
                        "content": "Approach was to figure out to use p and q as references and then use recursion"
                    },
                    {
                        "username": "tanish69",
                        "content": "am I not in thr right senses or test case 31 is just \"nothing\"? its not showing any input? and its causing TLE in my code?"
                    },
                    {
                        "username": "dleyba042",
                        "content": "What is the point of making a binary tree that does not conform to a specific type of ordering??? ex. go left if smaller and right if larger."
                    },
                    {
                        "username": "Anik_Banerjee",
                        "content": "Can  someone explain how to tackle a follow up which asks what will happen if one of p or q  is not present ?"
                    },
                    {
                        "username": "mikhail_khozin",
                        "content": "I do not understand what should we do.\\n\\nWe can find LCA with O(log N) time complexity if we knew parent node for each node in tree. But we don\\'t.\\n\\nSo, just to find parents we spend O(N). In this case we can traverse all nodes and mark are they ancestors or not..."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "are those node\\'s values different to each others?"
                    }
                ]
            }
        ]
    }
]